(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory();
	else if(typeof define === 'function' && define.amd)
		define("filesupload", [], factory);
	else if(typeof exports === 'object')
		exports["filesupload"] = factory();
	else
		root["filesupload"] = factory();
})(typeof self !== 'undefined' ? self : this, function() {
return /******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, {
/******/ 				configurable: false,
/******/ 				enumerable: true,
/******/ 				get: getter
/******/ 			});
/******/ 		}
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "/dist/";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 46);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ (function(module, exports) {

eval("// https://github.com/zloirock/core-js/issues/86#issuecomment-115759028\nvar global = module.exports = typeof window != 'undefined' && window.Math == Math\n  ? window : typeof self != 'undefined' && self.Math == Math ? self\n  // eslint-disable-next-line no-new-func\n  : Function('return this')();\nif (typeof __g == 'number') __g = global; // eslint-disable-line no-undef\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2dsb2JhbC5qcz9lY2FiIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUMiLCJmaWxlIjoiMC5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8vIGh0dHBzOi8vZ2l0aHViLmNvbS96bG9pcm9jay9jb3JlLWpzL2lzc3Vlcy84NiNpc3N1ZWNvbW1lbnQtMTE1NzU5MDI4XG52YXIgZ2xvYmFsID0gbW9kdWxlLmV4cG9ydHMgPSB0eXBlb2Ygd2luZG93ICE9ICd1bmRlZmluZWQnICYmIHdpbmRvdy5NYXRoID09IE1hdGhcbiAgPyB3aW5kb3cgOiB0eXBlb2Ygc2VsZiAhPSAndW5kZWZpbmVkJyAmJiBzZWxmLk1hdGggPT0gTWF0aCA/IHNlbGZcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLW5ldy1mdW5jXG4gIDogRnVuY3Rpb24oJ3JldHVybiB0aGlzJykoKTtcbmlmICh0eXBlb2YgX19nID09ICdudW1iZXInKSBfX2cgPSBnbG9iYWw7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW5kZWZcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19nbG9iYWwuanNcbi8vIG1vZHVsZSBpZCA9IDBcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///0\n");

/***/ }),
/* 1 */
/***/ (function(module, exports) {

eval("var hasOwnProperty = {}.hasOwnProperty;\nmodule.exports = function (it, key) {\n  return hasOwnProperty.call(it, key);\n};\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2hhcy5qcz8wZjYyIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBLHVCQUF1QjtBQUN2QjtBQUNBO0FBQ0EiLCJmaWxlIjoiMS5qcyIsInNvdXJjZXNDb250ZW50IjpbInZhciBoYXNPd25Qcm9wZXJ0eSA9IHt9Lmhhc093blByb3BlcnR5O1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaXQsIGtleSkge1xuICByZXR1cm4gaGFzT3duUHJvcGVydHkuY2FsbChpdCwga2V5KTtcbn07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9faGFzLmpzXG4vLyBtb2R1bGUgaWQgPSAxXG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///1\n");

/***/ }),
/* 2 */
/***/ (function(module, exports) {

eval("var core = module.exports = { version: '2.6.9' };\nif (typeof __e == 'number') __e = core; // eslint-disable-line no-undef\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2NvcmUuanM/MTVlMCJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSw2QkFBNkI7QUFDN0IsdUNBQXVDIiwiZmlsZSI6IjIuanMiLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgY29yZSA9IG1vZHVsZS5leHBvcnRzID0geyB2ZXJzaW9uOiAnMi42LjknIH07XG5pZiAodHlwZW9mIF9fZSA9PSAnbnVtYmVyJykgX19lID0gY29yZTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bmRlZlxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2NvcmUuanNcbi8vIG1vZHVsZSBpZCA9IDJcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///2\n");

/***/ }),
/* 3 */
/***/ (function(module, exports, __webpack_require__) {

eval("var dP = __webpack_require__(4);\nvar createDesc = __webpack_require__(14);\nmodule.exports = __webpack_require__(5) ? function (object, key, value) {\n  return dP.f(object, key, createDesc(1, value));\n} : function (object, key, value) {\n  object[key] = value;\n  return object;\n};\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2hpZGUuanM/ODQ5YyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSxTQUFTLG1CQUFPLENBQUMsQ0FBYztBQUMvQixpQkFBaUIsbUJBQU8sQ0FBQyxFQUFrQjtBQUMzQyxpQkFBaUIsbUJBQU8sQ0FBQyxDQUFnQjtBQUN6QztBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0EiLCJmaWxlIjoiMy5qcyIsInNvdXJjZXNDb250ZW50IjpbInZhciBkUCA9IHJlcXVpcmUoJy4vX29iamVjdC1kcCcpO1xudmFyIGNyZWF0ZURlc2MgPSByZXF1aXJlKCcuL19wcm9wZXJ0eS1kZXNjJyk7XG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vX2Rlc2NyaXB0b3JzJykgPyBmdW5jdGlvbiAob2JqZWN0LCBrZXksIHZhbHVlKSB7XG4gIHJldHVybiBkUC5mKG9iamVjdCwga2V5LCBjcmVhdGVEZXNjKDEsIHZhbHVlKSk7XG59IDogZnVuY3Rpb24gKG9iamVjdCwga2V5LCB2YWx1ZSkge1xuICBvYmplY3Rba2V5XSA9IHZhbHVlO1xuICByZXR1cm4gb2JqZWN0O1xufTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19oaWRlLmpzXG4vLyBtb2R1bGUgaWQgPSAzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///3\n");

/***/ }),
/* 4 */
/***/ (function(module, exports, __webpack_require__) {

eval("var anObject = __webpack_require__(12);\nvar IE8_DOM_DEFINE = __webpack_require__(36);\nvar toPrimitive = __webpack_require__(18);\nvar dP = Object.defineProperty;\n\nexports.f = __webpack_require__(5) ? Object.defineProperty : function defineProperty(O, P, Attributes) {\n  anObject(O);\n  P = toPrimitive(P, true);\n  anObject(Attributes);\n  if (IE8_DOM_DEFINE) try {\n    return dP(O, P, Attributes);\n  } catch (e) { /* empty */ }\n  if ('get' in Attributes || 'set' in Attributes) throw TypeError('Accessors not supported!');\n  if ('value' in Attributes) O[P] = Attributes.value;\n  return O;\n};\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX29iamVjdC1kcC5qcz83YWYwIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBLGVBQWUsbUJBQU8sQ0FBQyxFQUFjO0FBQ3JDLHFCQUFxQixtQkFBTyxDQUFDLEVBQW1CO0FBQ2hELGtCQUFrQixtQkFBTyxDQUFDLEVBQWlCO0FBQzNDOztBQUVBLFlBQVksbUJBQU8sQ0FBQyxDQUFnQjtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRyxZQUFZO0FBQ2Y7QUFDQTtBQUNBO0FBQ0EiLCJmaWxlIjoiNC5qcyIsInNvdXJjZXNDb250ZW50IjpbInZhciBhbk9iamVjdCA9IHJlcXVpcmUoJy4vX2FuLW9iamVjdCcpO1xudmFyIElFOF9ET01fREVGSU5FID0gcmVxdWlyZSgnLi9faWU4LWRvbS1kZWZpbmUnKTtcbnZhciB0b1ByaW1pdGl2ZSA9IHJlcXVpcmUoJy4vX3RvLXByaW1pdGl2ZScpO1xudmFyIGRQID0gT2JqZWN0LmRlZmluZVByb3BlcnR5O1xuXG5leHBvcnRzLmYgPSByZXF1aXJlKCcuL19kZXNjcmlwdG9ycycpID8gT2JqZWN0LmRlZmluZVByb3BlcnR5IDogZnVuY3Rpb24gZGVmaW5lUHJvcGVydHkoTywgUCwgQXR0cmlidXRlcykge1xuICBhbk9iamVjdChPKTtcbiAgUCA9IHRvUHJpbWl0aXZlKFAsIHRydWUpO1xuICBhbk9iamVjdChBdHRyaWJ1dGVzKTtcbiAgaWYgKElFOF9ET01fREVGSU5FKSB0cnkge1xuICAgIHJldHVybiBkUChPLCBQLCBBdHRyaWJ1dGVzKTtcbiAgfSBjYXRjaCAoZSkgeyAvKiBlbXB0eSAqLyB9XG4gIGlmICgnZ2V0JyBpbiBBdHRyaWJ1dGVzIHx8ICdzZXQnIGluIEF0dHJpYnV0ZXMpIHRocm93IFR5cGVFcnJvcignQWNjZXNzb3JzIG5vdCBzdXBwb3J0ZWQhJyk7XG4gIGlmICgndmFsdWUnIGluIEF0dHJpYnV0ZXMpIE9bUF0gPSBBdHRyaWJ1dGVzLnZhbHVlO1xuICByZXR1cm4gTztcbn07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fb2JqZWN0LWRwLmpzXG4vLyBtb2R1bGUgaWQgPSA0XG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///4\n");

/***/ }),
/* 5 */
/***/ (function(module, exports, __webpack_require__) {

eval("// Thank's IE8 for his funny defineProperty\nmodule.exports = !__webpack_require__(13)(function () {\n  return Object.defineProperty({}, 'a', { get: function () { return 7; } }).a != 7;\n});\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2Rlc2NyaXB0b3JzLmpzP2Y4NGQiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQSxrQkFBa0IsbUJBQU8sQ0FBQyxFQUFVO0FBQ3BDLGlDQUFpQyxRQUFRLG1CQUFtQixVQUFVLEVBQUUsRUFBRTtBQUMxRSxDQUFDIiwiZmlsZSI6IjUuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvLyBUaGFuaydzIElFOCBmb3IgaGlzIGZ1bm55IGRlZmluZVByb3BlcnR5XG5tb2R1bGUuZXhwb3J0cyA9ICFyZXF1aXJlKCcuL19mYWlscycpKGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh7fSwgJ2EnLCB7IGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gNzsgfSB9KS5hICE9IDc7XG59KTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19kZXNjcmlwdG9ycy5qc1xuLy8gbW9kdWxlIGlkID0gNVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///5\n");

/***/ }),
/* 6 */
/***/ (function(module, exports, __webpack_require__) {

eval("// to indexed object, toObject with fallback for non-array-like ES3 strings\nvar IObject = __webpack_require__(74);\nvar defined = __webpack_require__(21);\nmodule.exports = function (it) {\n  return IObject(defined(it));\n};\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX3RvLWlvYmplY3QuanM/NGRjNCJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUNBLGNBQWMsbUJBQU8sQ0FBQyxFQUFZO0FBQ2xDLGNBQWMsbUJBQU8sQ0FBQyxFQUFZO0FBQ2xDO0FBQ0E7QUFDQSIsImZpbGUiOiI2LmpzIiwic291cmNlc0NvbnRlbnQiOlsiLy8gdG8gaW5kZXhlZCBvYmplY3QsIHRvT2JqZWN0IHdpdGggZmFsbGJhY2sgZm9yIG5vbi1hcnJheS1saWtlIEVTMyBzdHJpbmdzXG52YXIgSU9iamVjdCA9IHJlcXVpcmUoJy4vX2lvYmplY3QnKTtcbnZhciBkZWZpbmVkID0gcmVxdWlyZSgnLi9fZGVmaW5lZCcpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaXQpIHtcbiAgcmV0dXJuIElPYmplY3QoZGVmaW5lZChpdCkpO1xufTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL190by1pb2JqZWN0LmpzXG4vLyBtb2R1bGUgaWQgPSA2XG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///6\n");

/***/ }),
/* 7 */
/***/ (function(module, exports, __webpack_require__) {

eval("var store = __webpack_require__(24)('wks');\nvar uid = __webpack_require__(16);\nvar Symbol = __webpack_require__(0).Symbol;\nvar USE_SYMBOL = typeof Symbol == 'function';\n\nvar $exports = module.exports = function (name) {\n  return store[name] || (store[name] =\n    USE_SYMBOL && Symbol[name] || (USE_SYMBOL ? Symbol : uid)('Symbol.' + name));\n};\n\n$exports.store = store;\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX3drcy5qcz83NTJjIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBLFlBQVksbUJBQU8sQ0FBQyxFQUFXO0FBQy9CLFVBQVUsbUJBQU8sQ0FBQyxFQUFRO0FBQzFCLGFBQWEsbUJBQU8sQ0FBQyxDQUFXO0FBQ2hDOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBIiwiZmlsZSI6IjcuanMiLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgc3RvcmUgPSByZXF1aXJlKCcuL19zaGFyZWQnKSgnd2tzJyk7XG52YXIgdWlkID0gcmVxdWlyZSgnLi9fdWlkJyk7XG52YXIgU3ltYm9sID0gcmVxdWlyZSgnLi9fZ2xvYmFsJykuU3ltYm9sO1xudmFyIFVTRV9TWU1CT0wgPSB0eXBlb2YgU3ltYm9sID09ICdmdW5jdGlvbic7XG5cbnZhciAkZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgcmV0dXJuIHN0b3JlW25hbWVdIHx8IChzdG9yZVtuYW1lXSA9XG4gICAgVVNFX1NZTUJPTCAmJiBTeW1ib2xbbmFtZV0gfHwgKFVTRV9TWU1CT0wgPyBTeW1ib2wgOiB1aWQpKCdTeW1ib2wuJyArIG5hbWUpKTtcbn07XG5cbiRleHBvcnRzLnN0b3JlID0gc3RvcmU7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fd2tzLmpzXG4vLyBtb2R1bGUgaWQgPSA3XG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///7\n");

/***/ }),
/* 8 */
/***/ (function(module, exports) {

eval("module.exports = function (it) {\n  return typeof it === 'object' ? it !== null : typeof it === 'function';\n};\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2lzLW9iamVjdC5qcz8xMmE4Il0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQSIsImZpbGUiOiI4LmpzIiwic291cmNlc0NvbnRlbnQiOlsibW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaXQpIHtcbiAgcmV0dXJuIHR5cGVvZiBpdCA9PT0gJ29iamVjdCcgPyBpdCAhPT0gbnVsbCA6IHR5cGVvZiBpdCA9PT0gJ2Z1bmN0aW9uJztcbn07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9faXMtb2JqZWN0LmpzXG4vLyBtb2R1bGUgaWQgPSA4XG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///8\n");

/***/ }),
/* 9 */
/***/ (function(module, exports) {

eval("/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n// css base code, injected by the css-loader\nmodule.exports = function(useSourceMap) {\n\tvar list = [];\n\n\t// return the list of modules as css string\n\tlist.toString = function toString() {\n\t\treturn this.map(function (item) {\n\t\t\tvar content = cssWithMappingToString(item, useSourceMap);\n\t\t\tif(item[2]) {\n\t\t\t\treturn \"@media \" + item[2] + \"{\" + content + \"}\";\n\t\t\t} else {\n\t\t\t\treturn content;\n\t\t\t}\n\t\t}).join(\"\");\n\t};\n\n\t// import a list of modules into the list\n\tlist.i = function(modules, mediaQuery) {\n\t\tif(typeof modules === \"string\")\n\t\t\tmodules = [[null, modules, \"\"]];\n\t\tvar alreadyImportedModules = {};\n\t\tfor(var i = 0; i < this.length; i++) {\n\t\t\tvar id = this[i][0];\n\t\t\tif(typeof id === \"number\")\n\t\t\t\talreadyImportedModules[id] = true;\n\t\t}\n\t\tfor(i = 0; i < modules.length; i++) {\n\t\t\tvar item = modules[i];\n\t\t\t// skip already imported module\n\t\t\t// this implementation is not 100% perfect for weird media query combinations\n\t\t\t//  when a module is imported multiple times with different media queries.\n\t\t\t//  I hope this will never occur (Hey this way we have smaller bundles)\n\t\t\tif(typeof item[0] !== \"number\" || !alreadyImportedModules[item[0]]) {\n\t\t\t\tif(mediaQuery && !item[2]) {\n\t\t\t\t\titem[2] = mediaQuery;\n\t\t\t\t} else if(mediaQuery) {\n\t\t\t\t\titem[2] = \"(\" + item[2] + \") and (\" + mediaQuery + \")\";\n\t\t\t\t}\n\t\t\t\tlist.push(item);\n\t\t\t}\n\t\t}\n\t};\n\treturn list;\n};\n\nfunction cssWithMappingToString(item, useSourceMap) {\n\tvar content = item[1] || '';\n\tvar cssMapping = item[3];\n\tif (!cssMapping) {\n\t\treturn content;\n\t}\n\n\tif (useSourceMap && typeof btoa === 'function') {\n\t\tvar sourceMapping = toComment(cssMapping);\n\t\tvar sourceURLs = cssMapping.sources.map(function (source) {\n\t\t\treturn '/*# sourceURL=' + cssMapping.sourceRoot + source + ' */'\n\t\t});\n\n\t\treturn [content].concat(sourceURLs).concat([sourceMapping]).join('\\n');\n\t}\n\n\treturn [content].join('\\n');\n}\n\n// Adapted from convert-source-map (MIT)\nfunction toComment(sourceMap) {\n\t// eslint-disable-next-line no-undef\n\tvar base64 = btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap))));\n\tvar data = 'sourceMappingURL=data:application/json;charset=utf-8;base64,' + base64;\n\n\treturn '/*# ' + data + ' */';\n}\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9saWIvY3NzLWJhc2UuanM/MTU5ZiJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DLGdCQUFnQjtBQUNuRCxJQUFJO0FBQ0o7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLGlCQUFpQjtBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksb0JBQW9CO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9EQUFvRCxjQUFjOztBQUVsRTtBQUNBIiwiZmlsZSI6IjkuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvKlxuXHRNSVQgTGljZW5zZSBodHRwOi8vd3d3Lm9wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL21pdC1saWNlbnNlLnBocFxuXHRBdXRob3IgVG9iaWFzIEtvcHBlcnMgQHNva3JhXG4qL1xuLy8gY3NzIGJhc2UgY29kZSwgaW5qZWN0ZWQgYnkgdGhlIGNzcy1sb2FkZXJcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24odXNlU291cmNlTWFwKSB7XG5cdHZhciBsaXN0ID0gW107XG5cblx0Ly8gcmV0dXJuIHRoZSBsaXN0IG9mIG1vZHVsZXMgYXMgY3NzIHN0cmluZ1xuXHRsaXN0LnRvU3RyaW5nID0gZnVuY3Rpb24gdG9TdHJpbmcoKSB7XG5cdFx0cmV0dXJuIHRoaXMubWFwKGZ1bmN0aW9uIChpdGVtKSB7XG5cdFx0XHR2YXIgY29udGVudCA9IGNzc1dpdGhNYXBwaW5nVG9TdHJpbmcoaXRlbSwgdXNlU291cmNlTWFwKTtcblx0XHRcdGlmKGl0ZW1bMl0pIHtcblx0XHRcdFx0cmV0dXJuIFwiQG1lZGlhIFwiICsgaXRlbVsyXSArIFwie1wiICsgY29udGVudCArIFwifVwiO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0cmV0dXJuIGNvbnRlbnQ7XG5cdFx0XHR9XG5cdFx0fSkuam9pbihcIlwiKTtcblx0fTtcblxuXHQvLyBpbXBvcnQgYSBsaXN0IG9mIG1vZHVsZXMgaW50byB0aGUgbGlzdFxuXHRsaXN0LmkgPSBmdW5jdGlvbihtb2R1bGVzLCBtZWRpYVF1ZXJ5KSB7XG5cdFx0aWYodHlwZW9mIG1vZHVsZXMgPT09IFwic3RyaW5nXCIpXG5cdFx0XHRtb2R1bGVzID0gW1tudWxsLCBtb2R1bGVzLCBcIlwiXV07XG5cdFx0dmFyIGFscmVhZHlJbXBvcnRlZE1vZHVsZXMgPSB7fTtcblx0XHRmb3IodmFyIGkgPSAwOyBpIDwgdGhpcy5sZW5ndGg7IGkrKykge1xuXHRcdFx0dmFyIGlkID0gdGhpc1tpXVswXTtcblx0XHRcdGlmKHR5cGVvZiBpZCA9PT0gXCJudW1iZXJcIilcblx0XHRcdFx0YWxyZWFkeUltcG9ydGVkTW9kdWxlc1tpZF0gPSB0cnVlO1xuXHRcdH1cblx0XHRmb3IoaSA9IDA7IGkgPCBtb2R1bGVzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHR2YXIgaXRlbSA9IG1vZHVsZXNbaV07XG5cdFx0XHQvLyBza2lwIGFscmVhZHkgaW1wb3J0ZWQgbW9kdWxlXG5cdFx0XHQvLyB0aGlzIGltcGxlbWVudGF0aW9uIGlzIG5vdCAxMDAlIHBlcmZlY3QgZm9yIHdlaXJkIG1lZGlhIHF1ZXJ5IGNvbWJpbmF0aW9uc1xuXHRcdFx0Ly8gIHdoZW4gYSBtb2R1bGUgaXMgaW1wb3J0ZWQgbXVsdGlwbGUgdGltZXMgd2l0aCBkaWZmZXJlbnQgbWVkaWEgcXVlcmllcy5cblx0XHRcdC8vICBJIGhvcGUgdGhpcyB3aWxsIG5ldmVyIG9jY3VyIChIZXkgdGhpcyB3YXkgd2UgaGF2ZSBzbWFsbGVyIGJ1bmRsZXMpXG5cdFx0XHRpZih0eXBlb2YgaXRlbVswXSAhPT0gXCJudW1iZXJcIiB8fCAhYWxyZWFkeUltcG9ydGVkTW9kdWxlc1tpdGVtWzBdXSkge1xuXHRcdFx0XHRpZihtZWRpYVF1ZXJ5ICYmICFpdGVtWzJdKSB7XG5cdFx0XHRcdFx0aXRlbVsyXSA9IG1lZGlhUXVlcnk7XG5cdFx0XHRcdH0gZWxzZSBpZihtZWRpYVF1ZXJ5KSB7XG5cdFx0XHRcdFx0aXRlbVsyXSA9IFwiKFwiICsgaXRlbVsyXSArIFwiKSBhbmQgKFwiICsgbWVkaWFRdWVyeSArIFwiKVwiO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGxpc3QucHVzaChpdGVtKTtcblx0XHRcdH1cblx0XHR9XG5cdH07XG5cdHJldHVybiBsaXN0O1xufTtcblxuZnVuY3Rpb24gY3NzV2l0aE1hcHBpbmdUb1N0cmluZyhpdGVtLCB1c2VTb3VyY2VNYXApIHtcblx0dmFyIGNvbnRlbnQgPSBpdGVtWzFdIHx8ICcnO1xuXHR2YXIgY3NzTWFwcGluZyA9IGl0ZW1bM107XG5cdGlmICghY3NzTWFwcGluZykge1xuXHRcdHJldHVybiBjb250ZW50O1xuXHR9XG5cblx0aWYgKHVzZVNvdXJjZU1hcCAmJiB0eXBlb2YgYnRvYSA9PT0gJ2Z1bmN0aW9uJykge1xuXHRcdHZhciBzb3VyY2VNYXBwaW5nID0gdG9Db21tZW50KGNzc01hcHBpbmcpO1xuXHRcdHZhciBzb3VyY2VVUkxzID0gY3NzTWFwcGluZy5zb3VyY2VzLm1hcChmdW5jdGlvbiAoc291cmNlKSB7XG5cdFx0XHRyZXR1cm4gJy8qIyBzb3VyY2VVUkw9JyArIGNzc01hcHBpbmcuc291cmNlUm9vdCArIHNvdXJjZSArICcgKi8nXG5cdFx0fSk7XG5cblx0XHRyZXR1cm4gW2NvbnRlbnRdLmNvbmNhdChzb3VyY2VVUkxzKS5jb25jYXQoW3NvdXJjZU1hcHBpbmddKS5qb2luKCdcXG4nKTtcblx0fVxuXG5cdHJldHVybiBbY29udGVudF0uam9pbignXFxuJyk7XG59XG5cbi8vIEFkYXB0ZWQgZnJvbSBjb252ZXJ0LXNvdXJjZS1tYXAgKE1JVClcbmZ1bmN0aW9uIHRvQ29tbWVudChzb3VyY2VNYXApIHtcblx0Ly8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXVuZGVmXG5cdHZhciBiYXNlNjQgPSBidG9hKHVuZXNjYXBlKGVuY29kZVVSSUNvbXBvbmVudChKU09OLnN0cmluZ2lmeShzb3VyY2VNYXApKSkpO1xuXHR2YXIgZGF0YSA9ICdzb3VyY2VNYXBwaW5nVVJMPWRhdGE6YXBwbGljYXRpb24vanNvbjtjaGFyc2V0PXV0Zi04O2Jhc2U2NCwnICsgYmFzZTY0O1xuXG5cdHJldHVybiAnLyojICcgKyBkYXRhICsgJyAqLyc7XG59XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2xpYi9jc3MtYmFzZS5qc1xuLy8gbW9kdWxlIGlkID0gOVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///9\n");

/***/ }),
/* 10 */
/***/ (function(module, exports, __webpack_require__) {

eval("/*\n  MIT License http://www.opensource.org/licenses/mit-license.php\n  Author Tobias Koppers @sokra\n  Modified by Evan You @yyx990803\n*/\n\nvar hasDocument = typeof document !== 'undefined'\n\nif (typeof DEBUG !== 'undefined' && DEBUG) {\n  if (!hasDocument) {\n    throw new Error(\n    'vue-style-loader cannot be used in a non-browser environment. ' +\n    \"Use { target: 'node' } in your Webpack config to indicate a server-rendering environment.\"\n  ) }\n}\n\nvar listToStyles = __webpack_require__(50)\n\n/*\ntype StyleObject = {\n  id: number;\n  parts: Array<StyleObjectPart>\n}\n\ntype StyleObjectPart = {\n  css: string;\n  media: string;\n  sourceMap: ?string\n}\n*/\n\nvar stylesInDom = {/*\n  [id: number]: {\n    id: number,\n    refs: number,\n    parts: Array<(obj?: StyleObjectPart) => void>\n  }\n*/}\n\nvar head = hasDocument && (document.head || document.getElementsByTagName('head')[0])\nvar singletonElement = null\nvar singletonCounter = 0\nvar isProduction = false\nvar noop = function () {}\nvar options = null\nvar ssrIdKey = 'data-vue-ssr-id'\n\n// Force single-tag solution on IE6-9, which has a hard limit on the # of <style>\n// tags it will allow on a page\nvar isOldIE = typeof navigator !== 'undefined' && /msie [6-9]\\b/.test(navigator.userAgent.toLowerCase())\n\nmodule.exports = function (parentId, list, _isProduction, _options) {\n  isProduction = _isProduction\n\n  options = _options || {}\n\n  var styles = listToStyles(parentId, list)\n  addStylesToDom(styles)\n\n  return function update (newList) {\n    var mayRemove = []\n    for (var i = 0; i < styles.length; i++) {\n      var item = styles[i]\n      var domStyle = stylesInDom[item.id]\n      domStyle.refs--\n      mayRemove.push(domStyle)\n    }\n    if (newList) {\n      styles = listToStyles(parentId, newList)\n      addStylesToDom(styles)\n    } else {\n      styles = []\n    }\n    for (var i = 0; i < mayRemove.length; i++) {\n      var domStyle = mayRemove[i]\n      if (domStyle.refs === 0) {\n        for (var j = 0; j < domStyle.parts.length; j++) {\n          domStyle.parts[j]()\n        }\n        delete stylesInDom[domStyle.id]\n      }\n    }\n  }\n}\n\nfunction addStylesToDom (styles /* Array<StyleObject> */) {\n  for (var i = 0; i < styles.length; i++) {\n    var item = styles[i]\n    var domStyle = stylesInDom[item.id]\n    if (domStyle) {\n      domStyle.refs++\n      for (var j = 0; j < domStyle.parts.length; j++) {\n        domStyle.parts[j](item.parts[j])\n      }\n      for (; j < item.parts.length; j++) {\n        domStyle.parts.push(addStyle(item.parts[j]))\n      }\n      if (domStyle.parts.length > item.parts.length) {\n        domStyle.parts.length = item.parts.length\n      }\n    } else {\n      var parts = []\n      for (var j = 0; j < item.parts.length; j++) {\n        parts.push(addStyle(item.parts[j]))\n      }\n      stylesInDom[item.id] = { id: item.id, refs: 1, parts: parts }\n    }\n  }\n}\n\nfunction createStyleElement () {\n  var styleElement = document.createElement('style')\n  styleElement.type = 'text/css'\n  head.appendChild(styleElement)\n  return styleElement\n}\n\nfunction addStyle (obj /* StyleObjectPart */) {\n  var update, remove\n  var styleElement = document.querySelector('style[' + ssrIdKey + '~=\"' + obj.id + '\"]')\n\n  if (styleElement) {\n    if (isProduction) {\n      // has SSR styles and in production mode.\n      // simply do nothing.\n      return noop\n    } else {\n      // has SSR styles but in dev mode.\n      // for some reason Chrome can't handle source map in server-rendered\n      // style tags - source maps in <style> only works if the style tag is\n      // created and inserted dynamically. So we remove the server rendered\n      // styles and inject new ones.\n      styleElement.parentNode.removeChild(styleElement)\n    }\n  }\n\n  if (isOldIE) {\n    // use singleton mode for IE9.\n    var styleIndex = singletonCounter++\n    styleElement = singletonElement || (singletonElement = createStyleElement())\n    update = applyToSingletonTag.bind(null, styleElement, styleIndex, false)\n    remove = applyToSingletonTag.bind(null, styleElement, styleIndex, true)\n  } else {\n    // use multi-style-tag mode in all other cases\n    styleElement = createStyleElement()\n    update = applyToTag.bind(null, styleElement)\n    remove = function () {\n      styleElement.parentNode.removeChild(styleElement)\n    }\n  }\n\n  update(obj)\n\n  return function updateStyle (newObj /* StyleObjectPart */) {\n    if (newObj) {\n      if (newObj.css === obj.css &&\n          newObj.media === obj.media &&\n          newObj.sourceMap === obj.sourceMap) {\n        return\n      }\n      update(obj = newObj)\n    } else {\n      remove()\n    }\n  }\n}\n\nvar replaceText = (function () {\n  var textStore = []\n\n  return function (index, replacement) {\n    textStore[index] = replacement\n    return textStore.filter(Boolean).join('\\n')\n  }\n})()\n\nfunction applyToSingletonTag (styleElement, index, remove, obj) {\n  var css = remove ? '' : obj.css\n\n  if (styleElement.styleSheet) {\n    styleElement.styleSheet.cssText = replaceText(index, css)\n  } else {\n    var cssNode = document.createTextNode(css)\n    var childNodes = styleElement.childNodes\n    if (childNodes[index]) styleElement.removeChild(childNodes[index])\n    if (childNodes.length) {\n      styleElement.insertBefore(cssNode, childNodes[index])\n    } else {\n      styleElement.appendChild(cssNode)\n    }\n  }\n}\n\nfunction applyToTag (styleElement, obj) {\n  var css = obj.css\n  var media = obj.media\n  var sourceMap = obj.sourceMap\n\n  if (media) {\n    styleElement.setAttribute('media', media)\n  }\n  if (options.ssrId) {\n    styleElement.setAttribute(ssrIdKey, obj.id)\n  }\n\n  if (sourceMap) {\n    // https://developer.chrome.com/devtools/docs/javascript-debugging\n    // this makes source maps inside style tags work properly in Chrome\n    css += '\\n/*# sourceURL=' + sourceMap.sources[0] + ' */'\n    // http://stackoverflow.com/a/26603875\n    css += '\\n/*# sourceMappingURL=data:application/json;base64,' + btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap)))) + ' */'\n  }\n\n  if (styleElement.styleSheet) {\n    styleElement.styleSheet.cssText = css\n  } else {\n    while (styleElement.firstChild) {\n      styleElement.removeChild(styleElement.firstChild)\n    }\n    styleElement.appendChild(document.createTextNode(css))\n  }\n}\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvdnVlLXN0eWxlLWxvYWRlci9saWIvYWRkU3R5bGVzQ2xpZW50LmpzP2FlMzgiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsaUJBQWlCO0FBQzNCO0FBQ0E7O0FBRUEsbUJBQW1CLG1CQUFPLENBQUMsRUFBZ0I7O0FBRTNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLG1CQUFtQjtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsbUJBQW1CLG1CQUFtQjtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxtQkFBbUIsc0JBQXNCO0FBQ3pDO0FBQ0E7QUFDQSx1QkFBdUIsMkJBQTJCO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsaUJBQWlCLG1CQUFtQjtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQiwyQkFBMkI7QUFDaEQ7QUFDQTtBQUNBLFlBQVksdUJBQXVCO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxxQkFBcUIsdUJBQXVCO0FBQzVDO0FBQ0E7QUFDQSw4QkFBOEI7QUFDOUI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseURBQXlEO0FBQ3pEOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwiZmlsZSI6IjEwLmpzIiwic291cmNlc0NvbnRlbnQiOlsiLypcbiAgTUlUIExpY2Vuc2UgaHR0cDovL3d3dy5vcGVuc291cmNlLm9yZy9saWNlbnNlcy9taXQtbGljZW5zZS5waHBcbiAgQXV0aG9yIFRvYmlhcyBLb3BwZXJzIEBzb2tyYVxuICBNb2RpZmllZCBieSBFdmFuIFlvdSBAeXl4OTkwODAzXG4qL1xuXG52YXIgaGFzRG9jdW1lbnQgPSB0eXBlb2YgZG9jdW1lbnQgIT09ICd1bmRlZmluZWQnXG5cbmlmICh0eXBlb2YgREVCVUcgIT09ICd1bmRlZmluZWQnICYmIERFQlVHKSB7XG4gIGlmICghaGFzRG9jdW1lbnQpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgJ3Z1ZS1zdHlsZS1sb2FkZXIgY2Fubm90IGJlIHVzZWQgaW4gYSBub24tYnJvd3NlciBlbnZpcm9ubWVudC4gJyArXG4gICAgXCJVc2UgeyB0YXJnZXQ6ICdub2RlJyB9IGluIHlvdXIgV2VicGFjayBjb25maWcgdG8gaW5kaWNhdGUgYSBzZXJ2ZXItcmVuZGVyaW5nIGVudmlyb25tZW50LlwiXG4gICkgfVxufVxuXG52YXIgbGlzdFRvU3R5bGVzID0gcmVxdWlyZSgnLi9saXN0VG9TdHlsZXMnKVxuXG4vKlxudHlwZSBTdHlsZU9iamVjdCA9IHtcbiAgaWQ6IG51bWJlcjtcbiAgcGFydHM6IEFycmF5PFN0eWxlT2JqZWN0UGFydD5cbn1cblxudHlwZSBTdHlsZU9iamVjdFBhcnQgPSB7XG4gIGNzczogc3RyaW5nO1xuICBtZWRpYTogc3RyaW5nO1xuICBzb3VyY2VNYXA6ID9zdHJpbmdcbn1cbiovXG5cbnZhciBzdHlsZXNJbkRvbSA9IHsvKlxuICBbaWQ6IG51bWJlcl06IHtcbiAgICBpZDogbnVtYmVyLFxuICAgIHJlZnM6IG51bWJlcixcbiAgICBwYXJ0czogQXJyYXk8KG9iaj86IFN0eWxlT2JqZWN0UGFydCkgPT4gdm9pZD5cbiAgfVxuKi99XG5cbnZhciBoZWFkID0gaGFzRG9jdW1lbnQgJiYgKGRvY3VtZW50LmhlYWQgfHwgZG9jdW1lbnQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoJ2hlYWQnKVswXSlcbnZhciBzaW5nbGV0b25FbGVtZW50ID0gbnVsbFxudmFyIHNpbmdsZXRvbkNvdW50ZXIgPSAwXG52YXIgaXNQcm9kdWN0aW9uID0gZmFsc2VcbnZhciBub29wID0gZnVuY3Rpb24gKCkge31cbnZhciBvcHRpb25zID0gbnVsbFxudmFyIHNzcklkS2V5ID0gJ2RhdGEtdnVlLXNzci1pZCdcblxuLy8gRm9yY2Ugc2luZ2xlLXRhZyBzb2x1dGlvbiBvbiBJRTYtOSwgd2hpY2ggaGFzIGEgaGFyZCBsaW1pdCBvbiB0aGUgIyBvZiA8c3R5bGU+XG4vLyB0YWdzIGl0IHdpbGwgYWxsb3cgb24gYSBwYWdlXG52YXIgaXNPbGRJRSA9IHR5cGVvZiBuYXZpZ2F0b3IgIT09ICd1bmRlZmluZWQnICYmIC9tc2llIFs2LTldXFxiLy50ZXN0KG5hdmlnYXRvci51c2VyQWdlbnQudG9Mb3dlckNhc2UoKSlcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAocGFyZW50SWQsIGxpc3QsIF9pc1Byb2R1Y3Rpb24sIF9vcHRpb25zKSB7XG4gIGlzUHJvZHVjdGlvbiA9IF9pc1Byb2R1Y3Rpb25cblxuICBvcHRpb25zID0gX29wdGlvbnMgfHwge31cblxuICB2YXIgc3R5bGVzID0gbGlzdFRvU3R5bGVzKHBhcmVudElkLCBsaXN0KVxuICBhZGRTdHlsZXNUb0RvbShzdHlsZXMpXG5cbiAgcmV0dXJuIGZ1bmN0aW9uIHVwZGF0ZSAobmV3TGlzdCkge1xuICAgIHZhciBtYXlSZW1vdmUgPSBbXVxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc3R5bGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgaXRlbSA9IHN0eWxlc1tpXVxuICAgICAgdmFyIGRvbVN0eWxlID0gc3R5bGVzSW5Eb21baXRlbS5pZF1cbiAgICAgIGRvbVN0eWxlLnJlZnMtLVxuICAgICAgbWF5UmVtb3ZlLnB1c2goZG9tU3R5bGUpXG4gICAgfVxuICAgIGlmIChuZXdMaXN0KSB7XG4gICAgICBzdHlsZXMgPSBsaXN0VG9TdHlsZXMocGFyZW50SWQsIG5ld0xpc3QpXG4gICAgICBhZGRTdHlsZXNUb0RvbShzdHlsZXMpXG4gICAgfSBlbHNlIHtcbiAgICAgIHN0eWxlcyA9IFtdXG4gICAgfVxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbWF5UmVtb3ZlLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgZG9tU3R5bGUgPSBtYXlSZW1vdmVbaV1cbiAgICAgIGlmIChkb21TdHlsZS5yZWZzID09PSAwKSB7XG4gICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgZG9tU3R5bGUucGFydHMubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICBkb21TdHlsZS5wYXJ0c1tqXSgpXG4gICAgICAgIH1cbiAgICAgICAgZGVsZXRlIHN0eWxlc0luRG9tW2RvbVN0eWxlLmlkXVxuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBhZGRTdHlsZXNUb0RvbSAoc3R5bGVzIC8qIEFycmF5PFN0eWxlT2JqZWN0PiAqLykge1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHN0eWxlcy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBpdGVtID0gc3R5bGVzW2ldXG4gICAgdmFyIGRvbVN0eWxlID0gc3R5bGVzSW5Eb21baXRlbS5pZF1cbiAgICBpZiAoZG9tU3R5bGUpIHtcbiAgICAgIGRvbVN0eWxlLnJlZnMrK1xuICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBkb21TdHlsZS5wYXJ0cy5sZW5ndGg7IGorKykge1xuICAgICAgICBkb21TdHlsZS5wYXJ0c1tqXShpdGVtLnBhcnRzW2pdKVxuICAgICAgfVxuICAgICAgZm9yICg7IGogPCBpdGVtLnBhcnRzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgIGRvbVN0eWxlLnBhcnRzLnB1c2goYWRkU3R5bGUoaXRlbS5wYXJ0c1tqXSkpXG4gICAgICB9XG4gICAgICBpZiAoZG9tU3R5bGUucGFydHMubGVuZ3RoID4gaXRlbS5wYXJ0cy5sZW5ndGgpIHtcbiAgICAgICAgZG9tU3R5bGUucGFydHMubGVuZ3RoID0gaXRlbS5wYXJ0cy5sZW5ndGhcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIHBhcnRzID0gW11cbiAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgaXRlbS5wYXJ0cy5sZW5ndGg7IGorKykge1xuICAgICAgICBwYXJ0cy5wdXNoKGFkZFN0eWxlKGl0ZW0ucGFydHNbal0pKVxuICAgICAgfVxuICAgICAgc3R5bGVzSW5Eb21baXRlbS5pZF0gPSB7IGlkOiBpdGVtLmlkLCByZWZzOiAxLCBwYXJ0czogcGFydHMgfVxuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBjcmVhdGVTdHlsZUVsZW1lbnQgKCkge1xuICB2YXIgc3R5bGVFbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc3R5bGUnKVxuICBzdHlsZUVsZW1lbnQudHlwZSA9ICd0ZXh0L2NzcydcbiAgaGVhZC5hcHBlbmRDaGlsZChzdHlsZUVsZW1lbnQpXG4gIHJldHVybiBzdHlsZUVsZW1lbnRcbn1cblxuZnVuY3Rpb24gYWRkU3R5bGUgKG9iaiAvKiBTdHlsZU9iamVjdFBhcnQgKi8pIHtcbiAgdmFyIHVwZGF0ZSwgcmVtb3ZlXG4gIHZhciBzdHlsZUVsZW1lbnQgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCdzdHlsZVsnICsgc3NySWRLZXkgKyAnfj1cIicgKyBvYmouaWQgKyAnXCJdJylcblxuICBpZiAoc3R5bGVFbGVtZW50KSB7XG4gICAgaWYgKGlzUHJvZHVjdGlvbikge1xuICAgICAgLy8gaGFzIFNTUiBzdHlsZXMgYW5kIGluIHByb2R1Y3Rpb24gbW9kZS5cbiAgICAgIC8vIHNpbXBseSBkbyBub3RoaW5nLlxuICAgICAgcmV0dXJuIG5vb3BcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gaGFzIFNTUiBzdHlsZXMgYnV0IGluIGRldiBtb2RlLlxuICAgICAgLy8gZm9yIHNvbWUgcmVhc29uIENocm9tZSBjYW4ndCBoYW5kbGUgc291cmNlIG1hcCBpbiBzZXJ2ZXItcmVuZGVyZWRcbiAgICAgIC8vIHN0eWxlIHRhZ3MgLSBzb3VyY2UgbWFwcyBpbiA8c3R5bGU+IG9ubHkgd29ya3MgaWYgdGhlIHN0eWxlIHRhZyBpc1xuICAgICAgLy8gY3JlYXRlZCBhbmQgaW5zZXJ0ZWQgZHluYW1pY2FsbHkuIFNvIHdlIHJlbW92ZSB0aGUgc2VydmVyIHJlbmRlcmVkXG4gICAgICAvLyBzdHlsZXMgYW5kIGluamVjdCBuZXcgb25lcy5cbiAgICAgIHN0eWxlRWxlbWVudC5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHN0eWxlRWxlbWVudClcbiAgICB9XG4gIH1cblxuICBpZiAoaXNPbGRJRSkge1xuICAgIC8vIHVzZSBzaW5nbGV0b24gbW9kZSBmb3IgSUU5LlxuICAgIHZhciBzdHlsZUluZGV4ID0gc2luZ2xldG9uQ291bnRlcisrXG4gICAgc3R5bGVFbGVtZW50ID0gc2luZ2xldG9uRWxlbWVudCB8fCAoc2luZ2xldG9uRWxlbWVudCA9IGNyZWF0ZVN0eWxlRWxlbWVudCgpKVxuICAgIHVwZGF0ZSA9IGFwcGx5VG9TaW5nbGV0b25UYWcuYmluZChudWxsLCBzdHlsZUVsZW1lbnQsIHN0eWxlSW5kZXgsIGZhbHNlKVxuICAgIHJlbW92ZSA9IGFwcGx5VG9TaW5nbGV0b25UYWcuYmluZChudWxsLCBzdHlsZUVsZW1lbnQsIHN0eWxlSW5kZXgsIHRydWUpXG4gIH0gZWxzZSB7XG4gICAgLy8gdXNlIG11bHRpLXN0eWxlLXRhZyBtb2RlIGluIGFsbCBvdGhlciBjYXNlc1xuICAgIHN0eWxlRWxlbWVudCA9IGNyZWF0ZVN0eWxlRWxlbWVudCgpXG4gICAgdXBkYXRlID0gYXBwbHlUb1RhZy5iaW5kKG51bGwsIHN0eWxlRWxlbWVudClcbiAgICByZW1vdmUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICBzdHlsZUVsZW1lbnQucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChzdHlsZUVsZW1lbnQpXG4gICAgfVxuICB9XG5cbiAgdXBkYXRlKG9iailcblxuICByZXR1cm4gZnVuY3Rpb24gdXBkYXRlU3R5bGUgKG5ld09iaiAvKiBTdHlsZU9iamVjdFBhcnQgKi8pIHtcbiAgICBpZiAobmV3T2JqKSB7XG4gICAgICBpZiAobmV3T2JqLmNzcyA9PT0gb2JqLmNzcyAmJlxuICAgICAgICAgIG5ld09iai5tZWRpYSA9PT0gb2JqLm1lZGlhICYmXG4gICAgICAgICAgbmV3T2JqLnNvdXJjZU1hcCA9PT0gb2JqLnNvdXJjZU1hcCkge1xuICAgICAgICByZXR1cm5cbiAgICAgIH1cbiAgICAgIHVwZGF0ZShvYmogPSBuZXdPYmopXG4gICAgfSBlbHNlIHtcbiAgICAgIHJlbW92ZSgpXG4gICAgfVxuICB9XG59XG5cbnZhciByZXBsYWNlVGV4dCA9IChmdW5jdGlvbiAoKSB7XG4gIHZhciB0ZXh0U3RvcmUgPSBbXVxuXG4gIHJldHVybiBmdW5jdGlvbiAoaW5kZXgsIHJlcGxhY2VtZW50KSB7XG4gICAgdGV4dFN0b3JlW2luZGV4XSA9IHJlcGxhY2VtZW50XG4gICAgcmV0dXJuIHRleHRTdG9yZS5maWx0ZXIoQm9vbGVhbikuam9pbignXFxuJylcbiAgfVxufSkoKVxuXG5mdW5jdGlvbiBhcHBseVRvU2luZ2xldG9uVGFnIChzdHlsZUVsZW1lbnQsIGluZGV4LCByZW1vdmUsIG9iaikge1xuICB2YXIgY3NzID0gcmVtb3ZlID8gJycgOiBvYmouY3NzXG5cbiAgaWYgKHN0eWxlRWxlbWVudC5zdHlsZVNoZWV0KSB7XG4gICAgc3R5bGVFbGVtZW50LnN0eWxlU2hlZXQuY3NzVGV4dCA9IHJlcGxhY2VUZXh0KGluZGV4LCBjc3MpXG4gIH0gZWxzZSB7XG4gICAgdmFyIGNzc05vZGUgPSBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShjc3MpXG4gICAgdmFyIGNoaWxkTm9kZXMgPSBzdHlsZUVsZW1lbnQuY2hpbGROb2Rlc1xuICAgIGlmIChjaGlsZE5vZGVzW2luZGV4XSkgc3R5bGVFbGVtZW50LnJlbW92ZUNoaWxkKGNoaWxkTm9kZXNbaW5kZXhdKVxuICAgIGlmIChjaGlsZE5vZGVzLmxlbmd0aCkge1xuICAgICAgc3R5bGVFbGVtZW50Lmluc2VydEJlZm9yZShjc3NOb2RlLCBjaGlsZE5vZGVzW2luZGV4XSlcbiAgICB9IGVsc2Uge1xuICAgICAgc3R5bGVFbGVtZW50LmFwcGVuZENoaWxkKGNzc05vZGUpXG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGFwcGx5VG9UYWcgKHN0eWxlRWxlbWVudCwgb2JqKSB7XG4gIHZhciBjc3MgPSBvYmouY3NzXG4gIHZhciBtZWRpYSA9IG9iai5tZWRpYVxuICB2YXIgc291cmNlTWFwID0gb2JqLnNvdXJjZU1hcFxuXG4gIGlmIChtZWRpYSkge1xuICAgIHN0eWxlRWxlbWVudC5zZXRBdHRyaWJ1dGUoJ21lZGlhJywgbWVkaWEpXG4gIH1cbiAgaWYgKG9wdGlvbnMuc3NySWQpIHtcbiAgICBzdHlsZUVsZW1lbnQuc2V0QXR0cmlidXRlKHNzcklkS2V5LCBvYmouaWQpXG4gIH1cblxuICBpZiAoc291cmNlTWFwKSB7XG4gICAgLy8gaHR0cHM6Ly9kZXZlbG9wZXIuY2hyb21lLmNvbS9kZXZ0b29scy9kb2NzL2phdmFzY3JpcHQtZGVidWdnaW5nXG4gICAgLy8gdGhpcyBtYWtlcyBzb3VyY2UgbWFwcyBpbnNpZGUgc3R5bGUgdGFncyB3b3JrIHByb3Blcmx5IGluIENocm9tZVxuICAgIGNzcyArPSAnXFxuLyojIHNvdXJjZVVSTD0nICsgc291cmNlTWFwLnNvdXJjZXNbMF0gKyAnICovJ1xuICAgIC8vIGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9hLzI2NjAzODc1XG4gICAgY3NzICs9ICdcXG4vKiMgc291cmNlTWFwcGluZ1VSTD1kYXRhOmFwcGxpY2F0aW9uL2pzb247YmFzZTY0LCcgKyBidG9hKHVuZXNjYXBlKGVuY29kZVVSSUNvbXBvbmVudChKU09OLnN0cmluZ2lmeShzb3VyY2VNYXApKSkpICsgJyAqLydcbiAgfVxuXG4gIGlmIChzdHlsZUVsZW1lbnQuc3R5bGVTaGVldCkge1xuICAgIHN0eWxlRWxlbWVudC5zdHlsZVNoZWV0LmNzc1RleHQgPSBjc3NcbiAgfSBlbHNlIHtcbiAgICB3aGlsZSAoc3R5bGVFbGVtZW50LmZpcnN0Q2hpbGQpIHtcbiAgICAgIHN0eWxlRWxlbWVudC5yZW1vdmVDaGlsZChzdHlsZUVsZW1lbnQuZmlyc3RDaGlsZClcbiAgICB9XG4gICAgc3R5bGVFbGVtZW50LmFwcGVuZENoaWxkKGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKGNzcykpXG4gIH1cbn1cblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL3Z1ZS1zdHlsZS1sb2FkZXIvbGliL2FkZFN0eWxlc0NsaWVudC5qc1xuLy8gbW9kdWxlIGlkID0gMTBcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///10\n");

/***/ }),
/* 11 */
/***/ (function(module, exports) {

eval("// shim for using process in browser\nvar process = module.exports = {};\n\n// cached from whatever global is present so that test runners that stub it\n// don't break things.  But we need to wrap it in a try catch in case it is\n// wrapped in strict mode code which doesn't define any globals.  It's inside a\n// function because try/catches deoptimize in certain engines.\n\nvar cachedSetTimeout;\nvar cachedClearTimeout;\n\nfunction defaultSetTimout() {\n    throw new Error('setTimeout has not been defined');\n}\nfunction defaultClearTimeout () {\n    throw new Error('clearTimeout has not been defined');\n}\n(function () {\n    try {\n        if (typeof setTimeout === 'function') {\n            cachedSetTimeout = setTimeout;\n        } else {\n            cachedSetTimeout = defaultSetTimout;\n        }\n    } catch (e) {\n        cachedSetTimeout = defaultSetTimout;\n    }\n    try {\n        if (typeof clearTimeout === 'function') {\n            cachedClearTimeout = clearTimeout;\n        } else {\n            cachedClearTimeout = defaultClearTimeout;\n        }\n    } catch (e) {\n        cachedClearTimeout = defaultClearTimeout;\n    }\n} ())\nfunction runTimeout(fun) {\n    if (cachedSetTimeout === setTimeout) {\n        //normal enviroments in sane situations\n        return setTimeout(fun, 0);\n    }\n    // if setTimeout wasn't available but was latter defined\n    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {\n        cachedSetTimeout = setTimeout;\n        return setTimeout(fun, 0);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedSetTimeout(fun, 0);\n    } catch(e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally\n            return cachedSetTimeout.call(null, fun, 0);\n        } catch(e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error\n            return cachedSetTimeout.call(this, fun, 0);\n        }\n    }\n\n\n}\nfunction runClearTimeout(marker) {\n    if (cachedClearTimeout === clearTimeout) {\n        //normal enviroments in sane situations\n        return clearTimeout(marker);\n    }\n    // if clearTimeout wasn't available but was latter defined\n    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {\n        cachedClearTimeout = clearTimeout;\n        return clearTimeout(marker);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedClearTimeout(marker);\n    } catch (e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally\n            return cachedClearTimeout.call(null, marker);\n        } catch (e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.\n            // Some versions of I.E. have different rules for clearTimeout vs setTimeout\n            return cachedClearTimeout.call(this, marker);\n        }\n    }\n\n\n\n}\nvar queue = [];\nvar draining = false;\nvar currentQueue;\nvar queueIndex = -1;\n\nfunction cleanUpNextTick() {\n    if (!draining || !currentQueue) {\n        return;\n    }\n    draining = false;\n    if (currentQueue.length) {\n        queue = currentQueue.concat(queue);\n    } else {\n        queueIndex = -1;\n    }\n    if (queue.length) {\n        drainQueue();\n    }\n}\n\nfunction drainQueue() {\n    if (draining) {\n        return;\n    }\n    var timeout = runTimeout(cleanUpNextTick);\n    draining = true;\n\n    var len = queue.length;\n    while(len) {\n        currentQueue = queue;\n        queue = [];\n        while (++queueIndex < len) {\n            if (currentQueue) {\n                currentQueue[queueIndex].run();\n            }\n        }\n        queueIndex = -1;\n        len = queue.length;\n    }\n    currentQueue = null;\n    draining = false;\n    runClearTimeout(timeout);\n}\n\nprocess.nextTick = function (fun) {\n    var args = new Array(arguments.length - 1);\n    if (arguments.length > 1) {\n        for (var i = 1; i < arguments.length; i++) {\n            args[i - 1] = arguments[i];\n        }\n    }\n    queue.push(new Item(fun, args));\n    if (queue.length === 1 && !draining) {\n        runTimeout(drainQueue);\n    }\n};\n\n// v8 likes predictible objects\nfunction Item(fun, array) {\n    this.fun = fun;\n    this.array = array;\n}\nItem.prototype.run = function () {\n    this.fun.apply(null, this.array);\n};\nprocess.title = 'browser';\nprocess.browser = true;\nprocess.env = {};\nprocess.argv = [];\nprocess.version = ''; // empty string to avoid regexp issues\nprocess.versions = {};\n\nfunction noop() {}\n\nprocess.on = noop;\nprocess.addListener = noop;\nprocess.once = noop;\nprocess.off = noop;\nprocess.removeListener = noop;\nprocess.removeAllListeners = noop;\nprocess.emit = noop;\nprocess.prependListener = noop;\nprocess.prependOnceListener = noop;\n\nprocess.listeners = function (name) { return [] }\n\nprocess.binding = function (name) {\n    throw new Error('process.binding is not supported');\n};\n\nprocess.cwd = function () { return '/' };\nprocess.chdir = function (dir) {\n    throw new Error('process.chdir is not supported');\n};\nprocess.umask = function() { return 0; };\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcHJvY2Vzcy9icm93c2VyLmpzPzViNjkiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixzQkFBc0I7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHFDQUFxQzs7QUFFckM7QUFDQTtBQUNBOztBQUVBLDJCQUEyQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsVUFBVSIsImZpbGUiOiIxMS5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8vIHNoaW0gZm9yIHVzaW5nIHByb2Nlc3MgaW4gYnJvd3NlclxudmFyIHByb2Nlc3MgPSBtb2R1bGUuZXhwb3J0cyA9IHt9O1xuXG4vLyBjYWNoZWQgZnJvbSB3aGF0ZXZlciBnbG9iYWwgaXMgcHJlc2VudCBzbyB0aGF0IHRlc3QgcnVubmVycyB0aGF0IHN0dWIgaXRcbi8vIGRvbid0IGJyZWFrIHRoaW5ncy4gIEJ1dCB3ZSBuZWVkIHRvIHdyYXAgaXQgaW4gYSB0cnkgY2F0Y2ggaW4gY2FzZSBpdCBpc1xuLy8gd3JhcHBlZCBpbiBzdHJpY3QgbW9kZSBjb2RlIHdoaWNoIGRvZXNuJ3QgZGVmaW5lIGFueSBnbG9iYWxzLiAgSXQncyBpbnNpZGUgYVxuLy8gZnVuY3Rpb24gYmVjYXVzZSB0cnkvY2F0Y2hlcyBkZW9wdGltaXplIGluIGNlcnRhaW4gZW5naW5lcy5cblxudmFyIGNhY2hlZFNldFRpbWVvdXQ7XG52YXIgY2FjaGVkQ2xlYXJUaW1lb3V0O1xuXG5mdW5jdGlvbiBkZWZhdWx0U2V0VGltb3V0KCkge1xuICAgIHRocm93IG5ldyBFcnJvcignc2V0VGltZW91dCBoYXMgbm90IGJlZW4gZGVmaW5lZCcpO1xufVxuZnVuY3Rpb24gZGVmYXVsdENsZWFyVGltZW91dCAoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdjbGVhclRpbWVvdXQgaGFzIG5vdCBiZWVuIGRlZmluZWQnKTtcbn1cbihmdW5jdGlvbiAoKSB7XG4gICAgdHJ5IHtcbiAgICAgICAgaWYgKHR5cGVvZiBzZXRUaW1lb3V0ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBjYWNoZWRTZXRUaW1lb3V0ID0gc2V0VGltZW91dDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNhY2hlZFNldFRpbWVvdXQgPSBkZWZhdWx0U2V0VGltb3V0O1xuICAgICAgICB9XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBjYWNoZWRTZXRUaW1lb3V0ID0gZGVmYXVsdFNldFRpbW91dDtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgICAgaWYgKHR5cGVvZiBjbGVhclRpbWVvdXQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIGNhY2hlZENsZWFyVGltZW91dCA9IGNsZWFyVGltZW91dDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNhY2hlZENsZWFyVGltZW91dCA9IGRlZmF1bHRDbGVhclRpbWVvdXQ7XG4gICAgICAgIH1cbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGNhY2hlZENsZWFyVGltZW91dCA9IGRlZmF1bHRDbGVhclRpbWVvdXQ7XG4gICAgfVxufSAoKSlcbmZ1bmN0aW9uIHJ1blRpbWVvdXQoZnVuKSB7XG4gICAgaWYgKGNhY2hlZFNldFRpbWVvdXQgPT09IHNldFRpbWVvdXQpIHtcbiAgICAgICAgLy9ub3JtYWwgZW52aXJvbWVudHMgaW4gc2FuZSBzaXR1YXRpb25zXG4gICAgICAgIHJldHVybiBzZXRUaW1lb3V0KGZ1biwgMCk7XG4gICAgfVxuICAgIC8vIGlmIHNldFRpbWVvdXQgd2Fzbid0IGF2YWlsYWJsZSBidXQgd2FzIGxhdHRlciBkZWZpbmVkXG4gICAgaWYgKChjYWNoZWRTZXRUaW1lb3V0ID09PSBkZWZhdWx0U2V0VGltb3V0IHx8ICFjYWNoZWRTZXRUaW1lb3V0KSAmJiBzZXRUaW1lb3V0KSB7XG4gICAgICAgIGNhY2hlZFNldFRpbWVvdXQgPSBzZXRUaW1lb3V0O1xuICAgICAgICByZXR1cm4gc2V0VGltZW91dChmdW4sIDApO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgICAvLyB3aGVuIHdoZW4gc29tZWJvZHkgaGFzIHNjcmV3ZWQgd2l0aCBzZXRUaW1lb3V0IGJ1dCBubyBJLkUuIG1hZGRuZXNzXG4gICAgICAgIHJldHVybiBjYWNoZWRTZXRUaW1lb3V0KGZ1biwgMCk7XG4gICAgfSBjYXRjaChlKXtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIC8vIFdoZW4gd2UgYXJlIGluIEkuRS4gYnV0IHRoZSBzY3JpcHQgaGFzIGJlZW4gZXZhbGVkIHNvIEkuRS4gZG9lc24ndCB0cnVzdCB0aGUgZ2xvYmFsIG9iamVjdCB3aGVuIGNhbGxlZCBub3JtYWxseVxuICAgICAgICAgICAgcmV0dXJuIGNhY2hlZFNldFRpbWVvdXQuY2FsbChudWxsLCBmdW4sIDApO1xuICAgICAgICB9IGNhdGNoKGUpe1xuICAgICAgICAgICAgLy8gc2FtZSBhcyBhYm92ZSBidXQgd2hlbiBpdCdzIGEgdmVyc2lvbiBvZiBJLkUuIHRoYXQgbXVzdCBoYXZlIHRoZSBnbG9iYWwgb2JqZWN0IGZvciAndGhpcycsIGhvcGZ1bGx5IG91ciBjb250ZXh0IGNvcnJlY3Qgb3RoZXJ3aXNlIGl0IHdpbGwgdGhyb3cgYSBnbG9iYWwgZXJyb3JcbiAgICAgICAgICAgIHJldHVybiBjYWNoZWRTZXRUaW1lb3V0LmNhbGwodGhpcywgZnVuLCAwKTtcbiAgICAgICAgfVxuICAgIH1cblxuXG59XG5mdW5jdGlvbiBydW5DbGVhclRpbWVvdXQobWFya2VyKSB7XG4gICAgaWYgKGNhY2hlZENsZWFyVGltZW91dCA9PT0gY2xlYXJUaW1lb3V0KSB7XG4gICAgICAgIC8vbm9ybWFsIGVudmlyb21lbnRzIGluIHNhbmUgc2l0dWF0aW9uc1xuICAgICAgICByZXR1cm4gY2xlYXJUaW1lb3V0KG1hcmtlcik7XG4gICAgfVxuICAgIC8vIGlmIGNsZWFyVGltZW91dCB3YXNuJ3QgYXZhaWxhYmxlIGJ1dCB3YXMgbGF0dGVyIGRlZmluZWRcbiAgICBpZiAoKGNhY2hlZENsZWFyVGltZW91dCA9PT0gZGVmYXVsdENsZWFyVGltZW91dCB8fCAhY2FjaGVkQ2xlYXJUaW1lb3V0KSAmJiBjbGVhclRpbWVvdXQpIHtcbiAgICAgICAgY2FjaGVkQ2xlYXJUaW1lb3V0ID0gY2xlYXJUaW1lb3V0O1xuICAgICAgICByZXR1cm4gY2xlYXJUaW1lb3V0KG1hcmtlcik7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICAgIC8vIHdoZW4gd2hlbiBzb21lYm9keSBoYXMgc2NyZXdlZCB3aXRoIHNldFRpbWVvdXQgYnV0IG5vIEkuRS4gbWFkZG5lc3NcbiAgICAgICAgcmV0dXJuIGNhY2hlZENsZWFyVGltZW91dChtYXJrZXIpO1xuICAgIH0gY2F0Y2ggKGUpe1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgLy8gV2hlbiB3ZSBhcmUgaW4gSS5FLiBidXQgdGhlIHNjcmlwdCBoYXMgYmVlbiBldmFsZWQgc28gSS5FLiBkb2Vzbid0ICB0cnVzdCB0aGUgZ2xvYmFsIG9iamVjdCB3aGVuIGNhbGxlZCBub3JtYWxseVxuICAgICAgICAgICAgcmV0dXJuIGNhY2hlZENsZWFyVGltZW91dC5jYWxsKG51bGwsIG1hcmtlcik7XG4gICAgICAgIH0gY2F0Y2ggKGUpe1xuICAgICAgICAgICAgLy8gc2FtZSBhcyBhYm92ZSBidXQgd2hlbiBpdCdzIGEgdmVyc2lvbiBvZiBJLkUuIHRoYXQgbXVzdCBoYXZlIHRoZSBnbG9iYWwgb2JqZWN0IGZvciAndGhpcycsIGhvcGZ1bGx5IG91ciBjb250ZXh0IGNvcnJlY3Qgb3RoZXJ3aXNlIGl0IHdpbGwgdGhyb3cgYSBnbG9iYWwgZXJyb3IuXG4gICAgICAgICAgICAvLyBTb21lIHZlcnNpb25zIG9mIEkuRS4gaGF2ZSBkaWZmZXJlbnQgcnVsZXMgZm9yIGNsZWFyVGltZW91dCB2cyBzZXRUaW1lb3V0XG4gICAgICAgICAgICByZXR1cm4gY2FjaGVkQ2xlYXJUaW1lb3V0LmNhbGwodGhpcywgbWFya2VyKTtcbiAgICAgICAgfVxuICAgIH1cblxuXG5cbn1cbnZhciBxdWV1ZSA9IFtdO1xudmFyIGRyYWluaW5nID0gZmFsc2U7XG52YXIgY3VycmVudFF1ZXVlO1xudmFyIHF1ZXVlSW5kZXggPSAtMTtcblxuZnVuY3Rpb24gY2xlYW5VcE5leHRUaWNrKCkge1xuICAgIGlmICghZHJhaW5pbmcgfHwgIWN1cnJlbnRRdWV1ZSkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGRyYWluaW5nID0gZmFsc2U7XG4gICAgaWYgKGN1cnJlbnRRdWV1ZS5sZW5ndGgpIHtcbiAgICAgICAgcXVldWUgPSBjdXJyZW50UXVldWUuY29uY2F0KHF1ZXVlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBxdWV1ZUluZGV4ID0gLTE7XG4gICAgfVxuICAgIGlmIChxdWV1ZS5sZW5ndGgpIHtcbiAgICAgICAgZHJhaW5RdWV1ZSgpO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gZHJhaW5RdWV1ZSgpIHtcbiAgICBpZiAoZHJhaW5pbmcpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB2YXIgdGltZW91dCA9IHJ1blRpbWVvdXQoY2xlYW5VcE5leHRUaWNrKTtcbiAgICBkcmFpbmluZyA9IHRydWU7XG5cbiAgICB2YXIgbGVuID0gcXVldWUubGVuZ3RoO1xuICAgIHdoaWxlKGxlbikge1xuICAgICAgICBjdXJyZW50UXVldWUgPSBxdWV1ZTtcbiAgICAgICAgcXVldWUgPSBbXTtcbiAgICAgICAgd2hpbGUgKCsrcXVldWVJbmRleCA8IGxlbikge1xuICAgICAgICAgICAgaWYgKGN1cnJlbnRRdWV1ZSkge1xuICAgICAgICAgICAgICAgIGN1cnJlbnRRdWV1ZVtxdWV1ZUluZGV4XS5ydW4oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBxdWV1ZUluZGV4ID0gLTE7XG4gICAgICAgIGxlbiA9IHF1ZXVlLmxlbmd0aDtcbiAgICB9XG4gICAgY3VycmVudFF1ZXVlID0gbnVsbDtcbiAgICBkcmFpbmluZyA9IGZhbHNlO1xuICAgIHJ1bkNsZWFyVGltZW91dCh0aW1lb3V0KTtcbn1cblxucHJvY2Vzcy5uZXh0VGljayA9IGZ1bmN0aW9uIChmdW4pIHtcbiAgICB2YXIgYXJncyA9IG5ldyBBcnJheShhcmd1bWVudHMubGVuZ3RoIC0gMSk7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPiAxKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBhcmdzW2kgLSAxXSA9IGFyZ3VtZW50c1tpXTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBxdWV1ZS5wdXNoKG5ldyBJdGVtKGZ1biwgYXJncykpO1xuICAgIGlmIChxdWV1ZS5sZW5ndGggPT09IDEgJiYgIWRyYWluaW5nKSB7XG4gICAgICAgIHJ1blRpbWVvdXQoZHJhaW5RdWV1ZSk7XG4gICAgfVxufTtcblxuLy8gdjggbGlrZXMgcHJlZGljdGlibGUgb2JqZWN0c1xuZnVuY3Rpb24gSXRlbShmdW4sIGFycmF5KSB7XG4gICAgdGhpcy5mdW4gPSBmdW47XG4gICAgdGhpcy5hcnJheSA9IGFycmF5O1xufVxuSXRlbS5wcm90b3R5cGUucnVuID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuZnVuLmFwcGx5KG51bGwsIHRoaXMuYXJyYXkpO1xufTtcbnByb2Nlc3MudGl0bGUgPSAnYnJvd3Nlcic7XG5wcm9jZXNzLmJyb3dzZXIgPSB0cnVlO1xucHJvY2Vzcy5lbnYgPSB7fTtcbnByb2Nlc3MuYXJndiA9IFtdO1xucHJvY2Vzcy52ZXJzaW9uID0gJyc7IC8vIGVtcHR5IHN0cmluZyB0byBhdm9pZCByZWdleHAgaXNzdWVzXG5wcm9jZXNzLnZlcnNpb25zID0ge307XG5cbmZ1bmN0aW9uIG5vb3AoKSB7fVxuXG5wcm9jZXNzLm9uID0gbm9vcDtcbnByb2Nlc3MuYWRkTGlzdGVuZXIgPSBub29wO1xucHJvY2Vzcy5vbmNlID0gbm9vcDtcbnByb2Nlc3Mub2ZmID0gbm9vcDtcbnByb2Nlc3MucmVtb3ZlTGlzdGVuZXIgPSBub29wO1xucHJvY2Vzcy5yZW1vdmVBbGxMaXN0ZW5lcnMgPSBub29wO1xucHJvY2Vzcy5lbWl0ID0gbm9vcDtcbnByb2Nlc3MucHJlcGVuZExpc3RlbmVyID0gbm9vcDtcbnByb2Nlc3MucHJlcGVuZE9uY2VMaXN0ZW5lciA9IG5vb3A7XG5cbnByb2Nlc3MubGlzdGVuZXJzID0gZnVuY3Rpb24gKG5hbWUpIHsgcmV0dXJuIFtdIH1cblxucHJvY2Vzcy5iaW5kaW5nID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3Byb2Nlc3MuYmluZGluZyBpcyBub3Qgc3VwcG9ydGVkJyk7XG59O1xuXG5wcm9jZXNzLmN3ZCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuICcvJyB9O1xucHJvY2Vzcy5jaGRpciA9IGZ1bmN0aW9uIChkaXIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3Byb2Nlc3MuY2hkaXIgaXMgbm90IHN1cHBvcnRlZCcpO1xufTtcbnByb2Nlc3MudW1hc2sgPSBmdW5jdGlvbigpIHsgcmV0dXJuIDA7IH07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9wcm9jZXNzL2Jyb3dzZXIuanNcbi8vIG1vZHVsZSBpZCA9IDExXG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///11\n");

/***/ }),
/* 12 */
/***/ (function(module, exports, __webpack_require__) {

eval("var isObject = __webpack_require__(8);\nmodule.exports = function (it) {\n  if (!isObject(it)) throw TypeError(it + ' is not an object!');\n  return it;\n};\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2FuLW9iamVjdC5qcz9lZmIzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBLGVBQWUsbUJBQU8sQ0FBQyxDQUFjO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBIiwiZmlsZSI6IjEyLmpzIiwic291cmNlc0NvbnRlbnQiOlsidmFyIGlzT2JqZWN0ID0gcmVxdWlyZSgnLi9faXMtb2JqZWN0Jyk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpdCkge1xuICBpZiAoIWlzT2JqZWN0KGl0KSkgdGhyb3cgVHlwZUVycm9yKGl0ICsgJyBpcyBub3QgYW4gb2JqZWN0IScpO1xuICByZXR1cm4gaXQ7XG59O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2FuLW9iamVjdC5qc1xuLy8gbW9kdWxlIGlkID0gMTJcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///12\n");

/***/ }),
/* 13 */
/***/ (function(module, exports) {

eval("module.exports = function (exec) {\n  try {\n    return !!exec();\n  } catch (e) {\n    return true;\n  }\n};\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2ZhaWxzLmpzPzRiY2QiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSIsImZpbGUiOiIxMy5qcyIsInNvdXJjZXNDb250ZW50IjpbIm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGV4ZWMpIHtcbiAgdHJ5IHtcbiAgICByZXR1cm4gISFleGVjKCk7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxufTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19mYWlscy5qc1xuLy8gbW9kdWxlIGlkID0gMTNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///13\n");

/***/ }),
/* 14 */
/***/ (function(module, exports) {

eval("module.exports = function (bitmap, value) {\n  return {\n    enumerable: !(bitmap & 1),\n    configurable: !(bitmap & 2),\n    writable: !(bitmap & 4),\n    value: value\n  };\n};\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX3Byb3BlcnR5LWRlc2MuanM/NWZjMCJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwiZmlsZSI6IjE0LmpzIiwic291cmNlc0NvbnRlbnQiOlsibW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoYml0bWFwLCB2YWx1ZSkge1xuICByZXR1cm4ge1xuICAgIGVudW1lcmFibGU6ICEoYml0bWFwICYgMSksXG4gICAgY29uZmlndXJhYmxlOiAhKGJpdG1hcCAmIDIpLFxuICAgIHdyaXRhYmxlOiAhKGJpdG1hcCAmIDQpLFxuICAgIHZhbHVlOiB2YWx1ZVxuICB9O1xufTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19wcm9wZXJ0eS1kZXNjLmpzXG4vLyBtb2R1bGUgaWQgPSAxNFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///14\n");

/***/ }),
/* 15 */
/***/ (function(module, exports) {

eval("module.exports = true;\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2xpYnJhcnkuanM/M2I4OCJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSIsImZpbGUiOiIxNS5qcyIsInNvdXJjZXNDb250ZW50IjpbIm1vZHVsZS5leHBvcnRzID0gdHJ1ZTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19saWJyYXJ5LmpzXG4vLyBtb2R1bGUgaWQgPSAxNVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///15\n");

/***/ }),
/* 16 */
/***/ (function(module, exports) {

eval("var id = 0;\nvar px = Math.random();\nmodule.exports = function (key) {\n  return 'Symbol('.concat(key === undefined ? '' : key, ')_', (++id + px).toString(36));\n};\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX3VpZC5qcz9kYzRhIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJmaWxlIjoiMTYuanMiLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgaWQgPSAwO1xudmFyIHB4ID0gTWF0aC5yYW5kb20oKTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGtleSkge1xuICByZXR1cm4gJ1N5bWJvbCgnLmNvbmNhdChrZXkgPT09IHVuZGVmaW5lZCA/ICcnIDoga2V5LCAnKV8nLCAoKytpZCArIHB4KS50b1N0cmluZygzNikpO1xufTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL191aWQuanNcbi8vIG1vZHVsZSBpZCA9IDE2XG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///16\n");

/***/ }),
/* 17 */
/***/ (function(module, exports, __webpack_require__) {

eval("var global = __webpack_require__(0);\nvar core = __webpack_require__(2);\nvar ctx = __webpack_require__(71);\nvar hide = __webpack_require__(3);\nvar has = __webpack_require__(1);\nvar PROTOTYPE = 'prototype';\n\nvar $export = function (type, name, source) {\n  var IS_FORCED = type & $export.F;\n  var IS_GLOBAL = type & $export.G;\n  var IS_STATIC = type & $export.S;\n  var IS_PROTO = type & $export.P;\n  var IS_BIND = type & $export.B;\n  var IS_WRAP = type & $export.W;\n  var exports = IS_GLOBAL ? core : core[name] || (core[name] = {});\n  var expProto = exports[PROTOTYPE];\n  var target = IS_GLOBAL ? global : IS_STATIC ? global[name] : (global[name] || {})[PROTOTYPE];\n  var key, own, out;\n  if (IS_GLOBAL) source = name;\n  for (key in source) {\n    // contains in native\n    own = !IS_FORCED && target && target[key] !== undefined;\n    if (own && has(exports, key)) continue;\n    // export native or passed\n    out = own ? target[key] : source[key];\n    // prevent global pollution for namespaces\n    exports[key] = IS_GLOBAL && typeof target[key] != 'function' ? source[key]\n    // bind timers to global for call from export context\n    : IS_BIND && own ? ctx(out, global)\n    // wrap global constructors for prevent change them in library\n    : IS_WRAP && target[key] == out ? (function (C) {\n      var F = function (a, b, c) {\n        if (this instanceof C) {\n          switch (arguments.length) {\n            case 0: return new C();\n            case 1: return new C(a);\n            case 2: return new C(a, b);\n          } return new C(a, b, c);\n        } return C.apply(this, arguments);\n      };\n      F[PROTOTYPE] = C[PROTOTYPE];\n      return F;\n    // make static versions for prototype methods\n    })(out) : IS_PROTO && typeof out == 'function' ? ctx(Function.call, out) : out;\n    // export proto methods to core.%CONSTRUCTOR%.methods.%NAME%\n    if (IS_PROTO) {\n      (exports.virtual || (exports.virtual = {}))[key] = out;\n      // export proto methods to core.%CONSTRUCTOR%.prototype.%NAME%\n      if (type & $export.R && expProto && !expProto[key]) hide(expProto, key, out);\n    }\n  }\n};\n// type bitmap\n$export.F = 1;   // forced\n$export.G = 2;   // global\n$export.S = 4;   // static\n$export.P = 8;   // proto\n$export.B = 16;  // bind\n$export.W = 32;  // wrap\n$export.U = 64;  // safe\n$export.R = 128; // real proto method for `library`\nmodule.exports = $export;\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2V4cG9ydC5qcz85MGNkIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBLGFBQWEsbUJBQU8sQ0FBQyxDQUFXO0FBQ2hDLFdBQVcsbUJBQU8sQ0FBQyxDQUFTO0FBQzVCLFVBQVUsbUJBQU8sQ0FBQyxFQUFRO0FBQzFCLFdBQVcsbUJBQU8sQ0FBQyxDQUFTO0FBQzVCLFVBQVUsbUJBQU8sQ0FBQyxDQUFRO0FBQzFCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUVBQWlFO0FBQ2pFO0FBQ0Esa0ZBQWtGO0FBQ2xGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1gsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSwrQ0FBK0M7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkLGNBQWM7QUFDZCxjQUFjO0FBQ2QsY0FBYztBQUNkLGVBQWU7QUFDZixlQUFlO0FBQ2YsZUFBZTtBQUNmLGdCQUFnQjtBQUNoQiIsImZpbGUiOiIxNy5qcyIsInNvdXJjZXNDb250ZW50IjpbInZhciBnbG9iYWwgPSByZXF1aXJlKCcuL19nbG9iYWwnKTtcbnZhciBjb3JlID0gcmVxdWlyZSgnLi9fY29yZScpO1xudmFyIGN0eCA9IHJlcXVpcmUoJy4vX2N0eCcpO1xudmFyIGhpZGUgPSByZXF1aXJlKCcuL19oaWRlJyk7XG52YXIgaGFzID0gcmVxdWlyZSgnLi9faGFzJyk7XG52YXIgUFJPVE9UWVBFID0gJ3Byb3RvdHlwZSc7XG5cbnZhciAkZXhwb3J0ID0gZnVuY3Rpb24gKHR5cGUsIG5hbWUsIHNvdXJjZSkge1xuICB2YXIgSVNfRk9SQ0VEID0gdHlwZSAmICRleHBvcnQuRjtcbiAgdmFyIElTX0dMT0JBTCA9IHR5cGUgJiAkZXhwb3J0Lkc7XG4gIHZhciBJU19TVEFUSUMgPSB0eXBlICYgJGV4cG9ydC5TO1xuICB2YXIgSVNfUFJPVE8gPSB0eXBlICYgJGV4cG9ydC5QO1xuICB2YXIgSVNfQklORCA9IHR5cGUgJiAkZXhwb3J0LkI7XG4gIHZhciBJU19XUkFQID0gdHlwZSAmICRleHBvcnQuVztcbiAgdmFyIGV4cG9ydHMgPSBJU19HTE9CQUwgPyBjb3JlIDogY29yZVtuYW1lXSB8fCAoY29yZVtuYW1lXSA9IHt9KTtcbiAgdmFyIGV4cFByb3RvID0gZXhwb3J0c1tQUk9UT1RZUEVdO1xuICB2YXIgdGFyZ2V0ID0gSVNfR0xPQkFMID8gZ2xvYmFsIDogSVNfU1RBVElDID8gZ2xvYmFsW25hbWVdIDogKGdsb2JhbFtuYW1lXSB8fCB7fSlbUFJPVE9UWVBFXTtcbiAgdmFyIGtleSwgb3duLCBvdXQ7XG4gIGlmIChJU19HTE9CQUwpIHNvdXJjZSA9IG5hbWU7XG4gIGZvciAoa2V5IGluIHNvdXJjZSkge1xuICAgIC8vIGNvbnRhaW5zIGluIG5hdGl2ZVxuICAgIG93biA9ICFJU19GT1JDRUQgJiYgdGFyZ2V0ICYmIHRhcmdldFtrZXldICE9PSB1bmRlZmluZWQ7XG4gICAgaWYgKG93biAmJiBoYXMoZXhwb3J0cywga2V5KSkgY29udGludWU7XG4gICAgLy8gZXhwb3J0IG5hdGl2ZSBvciBwYXNzZWRcbiAgICBvdXQgPSBvd24gPyB0YXJnZXRba2V5XSA6IHNvdXJjZVtrZXldO1xuICAgIC8vIHByZXZlbnQgZ2xvYmFsIHBvbGx1dGlvbiBmb3IgbmFtZXNwYWNlc1xuICAgIGV4cG9ydHNba2V5XSA9IElTX0dMT0JBTCAmJiB0eXBlb2YgdGFyZ2V0W2tleV0gIT0gJ2Z1bmN0aW9uJyA/IHNvdXJjZVtrZXldXG4gICAgLy8gYmluZCB0aW1lcnMgdG8gZ2xvYmFsIGZvciBjYWxsIGZyb20gZXhwb3J0IGNvbnRleHRcbiAgICA6IElTX0JJTkQgJiYgb3duID8gY3R4KG91dCwgZ2xvYmFsKVxuICAgIC8vIHdyYXAgZ2xvYmFsIGNvbnN0cnVjdG9ycyBmb3IgcHJldmVudCBjaGFuZ2UgdGhlbSBpbiBsaWJyYXJ5XG4gICAgOiBJU19XUkFQICYmIHRhcmdldFtrZXldID09IG91dCA/IChmdW5jdGlvbiAoQykge1xuICAgICAgdmFyIEYgPSBmdW5jdGlvbiAoYSwgYiwgYykge1xuICAgICAgICBpZiAodGhpcyBpbnN0YW5jZW9mIEMpIHtcbiAgICAgICAgICBzd2l0Y2ggKGFyZ3VtZW50cy5sZW5ndGgpIHtcbiAgICAgICAgICAgIGNhc2UgMDogcmV0dXJuIG5ldyBDKCk7XG4gICAgICAgICAgICBjYXNlIDE6IHJldHVybiBuZXcgQyhhKTtcbiAgICAgICAgICAgIGNhc2UgMjogcmV0dXJuIG5ldyBDKGEsIGIpO1xuICAgICAgICAgIH0gcmV0dXJuIG5ldyBDKGEsIGIsIGMpO1xuICAgICAgICB9IHJldHVybiBDLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICB9O1xuICAgICAgRltQUk9UT1RZUEVdID0gQ1tQUk9UT1RZUEVdO1xuICAgICAgcmV0dXJuIEY7XG4gICAgLy8gbWFrZSBzdGF0aWMgdmVyc2lvbnMgZm9yIHByb3RvdHlwZSBtZXRob2RzXG4gICAgfSkob3V0KSA6IElTX1BST1RPICYmIHR5cGVvZiBvdXQgPT0gJ2Z1bmN0aW9uJyA/IGN0eChGdW5jdGlvbi5jYWxsLCBvdXQpIDogb3V0O1xuICAgIC8vIGV4cG9ydCBwcm90byBtZXRob2RzIHRvIGNvcmUuJUNPTlNUUlVDVE9SJS5tZXRob2RzLiVOQU1FJVxuICAgIGlmIChJU19QUk9UTykge1xuICAgICAgKGV4cG9ydHMudmlydHVhbCB8fCAoZXhwb3J0cy52aXJ0dWFsID0ge30pKVtrZXldID0gb3V0O1xuICAgICAgLy8gZXhwb3J0IHByb3RvIG1ldGhvZHMgdG8gY29yZS4lQ09OU1RSVUNUT1IlLnByb3RvdHlwZS4lTkFNRSVcbiAgICAgIGlmICh0eXBlICYgJGV4cG9ydC5SICYmIGV4cFByb3RvICYmICFleHBQcm90b1trZXldKSBoaWRlKGV4cFByb3RvLCBrZXksIG91dCk7XG4gICAgfVxuICB9XG59O1xuLy8gdHlwZSBiaXRtYXBcbiRleHBvcnQuRiA9IDE7ICAgLy8gZm9yY2VkXG4kZXhwb3J0LkcgPSAyOyAgIC8vIGdsb2JhbFxuJGV4cG9ydC5TID0gNDsgICAvLyBzdGF0aWNcbiRleHBvcnQuUCA9IDg7ICAgLy8gcHJvdG9cbiRleHBvcnQuQiA9IDE2OyAgLy8gYmluZFxuJGV4cG9ydC5XID0gMzI7ICAvLyB3cmFwXG4kZXhwb3J0LlUgPSA2NDsgIC8vIHNhZmVcbiRleHBvcnQuUiA9IDEyODsgLy8gcmVhbCBwcm90byBtZXRob2QgZm9yIGBsaWJyYXJ5YFxubW9kdWxlLmV4cG9ydHMgPSAkZXhwb3J0O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2V4cG9ydC5qc1xuLy8gbW9kdWxlIGlkID0gMTdcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///17\n");

/***/ }),
/* 18 */
/***/ (function(module, exports, __webpack_require__) {

eval("// 7.1.1 ToPrimitive(input [, PreferredType])\nvar isObject = __webpack_require__(8);\n// instead of the ES6 spec version, we didn't implement @@toPrimitive case\n// and the second argument - flag - preferred type is a string\nmodule.exports = function (it, S) {\n  if (!isObject(it)) return it;\n  var fn, val;\n  if (S && typeof (fn = it.toString) == 'function' && !isObject(val = fn.call(it))) return val;\n  if (typeof (fn = it.valueOf) == 'function' && !isObject(val = fn.call(it))) return val;\n  if (!S && typeof (fn = it.toString) == 'function' && !isObject(val = fn.call(it))) return val;\n  throw TypeError(\"Can't convert object to primitive value\");\n};\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX3RvLXByaW1pdGl2ZS5qcz8zMjYzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0EsZUFBZSxtQkFBTyxDQUFDLENBQWM7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJmaWxlIjoiMTguanMiLCJzb3VyY2VzQ29udGVudCI6WyIvLyA3LjEuMSBUb1ByaW1pdGl2ZShpbnB1dCBbLCBQcmVmZXJyZWRUeXBlXSlcbnZhciBpc09iamVjdCA9IHJlcXVpcmUoJy4vX2lzLW9iamVjdCcpO1xuLy8gaW5zdGVhZCBvZiB0aGUgRVM2IHNwZWMgdmVyc2lvbiwgd2UgZGlkbid0IGltcGxlbWVudCBAQHRvUHJpbWl0aXZlIGNhc2Vcbi8vIGFuZCB0aGUgc2Vjb25kIGFyZ3VtZW50IC0gZmxhZyAtIHByZWZlcnJlZCB0eXBlIGlzIGEgc3RyaW5nXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpdCwgUykge1xuICBpZiAoIWlzT2JqZWN0KGl0KSkgcmV0dXJuIGl0O1xuICB2YXIgZm4sIHZhbDtcbiAgaWYgKFMgJiYgdHlwZW9mIChmbiA9IGl0LnRvU3RyaW5nKSA9PSAnZnVuY3Rpb24nICYmICFpc09iamVjdCh2YWwgPSBmbi5jYWxsKGl0KSkpIHJldHVybiB2YWw7XG4gIGlmICh0eXBlb2YgKGZuID0gaXQudmFsdWVPZikgPT0gJ2Z1bmN0aW9uJyAmJiAhaXNPYmplY3QodmFsID0gZm4uY2FsbChpdCkpKSByZXR1cm4gdmFsO1xuICBpZiAoIVMgJiYgdHlwZW9mIChmbiA9IGl0LnRvU3RyaW5nKSA9PSAnZnVuY3Rpb24nICYmICFpc09iamVjdCh2YWwgPSBmbi5jYWxsKGl0KSkpIHJldHVybiB2YWw7XG4gIHRocm93IFR5cGVFcnJvcihcIkNhbid0IGNvbnZlcnQgb2JqZWN0IHRvIHByaW1pdGl2ZSB2YWx1ZVwiKTtcbn07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fdG8tcHJpbWl0aXZlLmpzXG4vLyBtb2R1bGUgaWQgPSAxOFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///18\n");

/***/ }),
/* 19 */
/***/ (function(module, exports, __webpack_require__) {

eval("// 19.1.2.2 / 15.2.3.5 Object.create(O [, Properties])\nvar anObject = __webpack_require__(12);\nvar dPs = __webpack_require__(73);\nvar enumBugKeys = __webpack_require__(25);\nvar IE_PROTO = __webpack_require__(23)('IE_PROTO');\nvar Empty = function () { /* empty */ };\nvar PROTOTYPE = 'prototype';\n\n// Create object with fake `null` prototype: use iframe Object with cleared prototype\nvar createDict = function () {\n  // Thrash, waste and sodomy: IE GC bug\n  var iframe = __webpack_require__(37)('iframe');\n  var i = enumBugKeys.length;\n  var lt = '<';\n  var gt = '>';\n  var iframeDocument;\n  iframe.style.display = 'none';\n  __webpack_require__(78).appendChild(iframe);\n  iframe.src = 'javascript:'; // eslint-disable-line no-script-url\n  // createDict = iframe.contentWindow.Object;\n  // html.removeChild(iframe);\n  iframeDocument = iframe.contentWindow.document;\n  iframeDocument.open();\n  iframeDocument.write(lt + 'script' + gt + 'document.F=Object' + lt + '/script' + gt);\n  iframeDocument.close();\n  createDict = iframeDocument.F;\n  while (i--) delete createDict[PROTOTYPE][enumBugKeys[i]];\n  return createDict();\n};\n\nmodule.exports = Object.create || function create(O, Properties) {\n  var result;\n  if (O !== null) {\n    Empty[PROTOTYPE] = anObject(O);\n    result = new Empty();\n    Empty[PROTOTYPE] = null;\n    // add \"__proto__\" for Object.getPrototypeOf polyfill\n    result[IE_PROTO] = O;\n  } else result = createDict();\n  return Properties === undefined ? result : dPs(result, Properties);\n};\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX29iamVjdC1jcmVhdGUuanM/NjI4NiJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUNBLGVBQWUsbUJBQU8sQ0FBQyxFQUFjO0FBQ3JDLFVBQVUsbUJBQU8sQ0FBQyxFQUFlO0FBQ2pDLGtCQUFrQixtQkFBTyxDQUFDLEVBQWtCO0FBQzVDLGVBQWUsbUJBQU8sQ0FBQyxFQUFlO0FBQ3RDLHlCQUF5QjtBQUN6Qjs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLG1CQUFPLENBQUMsRUFBZTtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRSxtQkFBTyxDQUFDLEVBQVM7QUFDbkIsNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSIsImZpbGUiOiIxOS5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8vIDE5LjEuMi4yIC8gMTUuMi4zLjUgT2JqZWN0LmNyZWF0ZShPIFssIFByb3BlcnRpZXNdKVxudmFyIGFuT2JqZWN0ID0gcmVxdWlyZSgnLi9fYW4tb2JqZWN0Jyk7XG52YXIgZFBzID0gcmVxdWlyZSgnLi9fb2JqZWN0LWRwcycpO1xudmFyIGVudW1CdWdLZXlzID0gcmVxdWlyZSgnLi9fZW51bS1idWcta2V5cycpO1xudmFyIElFX1BST1RPID0gcmVxdWlyZSgnLi9fc2hhcmVkLWtleScpKCdJRV9QUk9UTycpO1xudmFyIEVtcHR5ID0gZnVuY3Rpb24gKCkgeyAvKiBlbXB0eSAqLyB9O1xudmFyIFBST1RPVFlQRSA9ICdwcm90b3R5cGUnO1xuXG4vLyBDcmVhdGUgb2JqZWN0IHdpdGggZmFrZSBgbnVsbGAgcHJvdG90eXBlOiB1c2UgaWZyYW1lIE9iamVjdCB3aXRoIGNsZWFyZWQgcHJvdG90eXBlXG52YXIgY3JlYXRlRGljdCA9IGZ1bmN0aW9uICgpIHtcbiAgLy8gVGhyYXNoLCB3YXN0ZSBhbmQgc29kb215OiBJRSBHQyBidWdcbiAgdmFyIGlmcmFtZSA9IHJlcXVpcmUoJy4vX2RvbS1jcmVhdGUnKSgnaWZyYW1lJyk7XG4gIHZhciBpID0gZW51bUJ1Z0tleXMubGVuZ3RoO1xuICB2YXIgbHQgPSAnPCc7XG4gIHZhciBndCA9ICc+JztcbiAgdmFyIGlmcmFtZURvY3VtZW50O1xuICBpZnJhbWUuc3R5bGUuZGlzcGxheSA9ICdub25lJztcbiAgcmVxdWlyZSgnLi9faHRtbCcpLmFwcGVuZENoaWxkKGlmcmFtZSk7XG4gIGlmcmFtZS5zcmMgPSAnamF2YXNjcmlwdDonOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXNjcmlwdC11cmxcbiAgLy8gY3JlYXRlRGljdCA9IGlmcmFtZS5jb250ZW50V2luZG93Lk9iamVjdDtcbiAgLy8gaHRtbC5yZW1vdmVDaGlsZChpZnJhbWUpO1xuICBpZnJhbWVEb2N1bWVudCA9IGlmcmFtZS5jb250ZW50V2luZG93LmRvY3VtZW50O1xuICBpZnJhbWVEb2N1bWVudC5vcGVuKCk7XG4gIGlmcmFtZURvY3VtZW50LndyaXRlKGx0ICsgJ3NjcmlwdCcgKyBndCArICdkb2N1bWVudC5GPU9iamVjdCcgKyBsdCArICcvc2NyaXB0JyArIGd0KTtcbiAgaWZyYW1lRG9jdW1lbnQuY2xvc2UoKTtcbiAgY3JlYXRlRGljdCA9IGlmcmFtZURvY3VtZW50LkY7XG4gIHdoaWxlIChpLS0pIGRlbGV0ZSBjcmVhdGVEaWN0W1BST1RPVFlQRV1bZW51bUJ1Z0tleXNbaV1dO1xuICByZXR1cm4gY3JlYXRlRGljdCgpO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBPYmplY3QuY3JlYXRlIHx8IGZ1bmN0aW9uIGNyZWF0ZShPLCBQcm9wZXJ0aWVzKSB7XG4gIHZhciByZXN1bHQ7XG4gIGlmIChPICE9PSBudWxsKSB7XG4gICAgRW1wdHlbUFJPVE9UWVBFXSA9IGFuT2JqZWN0KE8pO1xuICAgIHJlc3VsdCA9IG5ldyBFbXB0eSgpO1xuICAgIEVtcHR5W1BST1RPVFlQRV0gPSBudWxsO1xuICAgIC8vIGFkZCBcIl9fcHJvdG9fX1wiIGZvciBPYmplY3QuZ2V0UHJvdG90eXBlT2YgcG9seWZpbGxcbiAgICByZXN1bHRbSUVfUFJPVE9dID0gTztcbiAgfSBlbHNlIHJlc3VsdCA9IGNyZWF0ZURpY3QoKTtcbiAgcmV0dXJuIFByb3BlcnRpZXMgPT09IHVuZGVmaW5lZCA/IHJlc3VsdCA6IGRQcyhyZXN1bHQsIFByb3BlcnRpZXMpO1xufTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19vYmplY3QtY3JlYXRlLmpzXG4vLyBtb2R1bGUgaWQgPSAxOVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///19\n");

/***/ }),
/* 20 */
/***/ (function(module, exports, __webpack_require__) {

eval("// 19.1.2.14 / 15.2.3.14 Object.keys(O)\nvar $keys = __webpack_require__(38);\nvar enumBugKeys = __webpack_require__(25);\n\nmodule.exports = Object.keys || function keys(O) {\n  return $keys(O, enumBugKeys);\n};\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX29iamVjdC1rZXlzLmpzPzk2NGIiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQSxZQUFZLG1CQUFPLENBQUMsRUFBeUI7QUFDN0Msa0JBQWtCLG1CQUFPLENBQUMsRUFBa0I7O0FBRTVDO0FBQ0E7QUFDQSIsImZpbGUiOiIyMC5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8vIDE5LjEuMi4xNCAvIDE1LjIuMy4xNCBPYmplY3Qua2V5cyhPKVxudmFyICRrZXlzID0gcmVxdWlyZSgnLi9fb2JqZWN0LWtleXMtaW50ZXJuYWwnKTtcbnZhciBlbnVtQnVnS2V5cyA9IHJlcXVpcmUoJy4vX2VudW0tYnVnLWtleXMnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBPYmplY3Qua2V5cyB8fCBmdW5jdGlvbiBrZXlzKE8pIHtcbiAgcmV0dXJuICRrZXlzKE8sIGVudW1CdWdLZXlzKTtcbn07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fb2JqZWN0LWtleXMuanNcbi8vIG1vZHVsZSBpZCA9IDIwXG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///20\n");

/***/ }),
/* 21 */
/***/ (function(module, exports) {

eval("// 7.2.1 RequireObjectCoercible(argument)\nmodule.exports = function (it) {\n  if (it == undefined) throw TypeError(\"Can't call method on  \" + it);\n  return it;\n};\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2RlZmluZWQuanM/ZTc2OCJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwiZmlsZSI6IjIxLmpzIiwic291cmNlc0NvbnRlbnQiOlsiLy8gNy4yLjEgUmVxdWlyZU9iamVjdENvZXJjaWJsZShhcmd1bWVudClcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGl0KSB7XG4gIGlmIChpdCA9PSB1bmRlZmluZWQpIHRocm93IFR5cGVFcnJvcihcIkNhbid0IGNhbGwgbWV0aG9kIG9uICBcIiArIGl0KTtcbiAgcmV0dXJuIGl0O1xufTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19kZWZpbmVkLmpzXG4vLyBtb2R1bGUgaWQgPSAyMVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///21\n");

/***/ }),
/* 22 */
/***/ (function(module, exports) {

eval("// 7.1.4 ToInteger\nvar ceil = Math.ceil;\nvar floor = Math.floor;\nmodule.exports = function (it) {\n  return isNaN(it = +it) ? 0 : (it > 0 ? floor : ceil)(it);\n};\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX3RvLWludGVnZXIuanM/NTJlMSJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJmaWxlIjoiMjIuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvLyA3LjEuNCBUb0ludGVnZXJcbnZhciBjZWlsID0gTWF0aC5jZWlsO1xudmFyIGZsb29yID0gTWF0aC5mbG9vcjtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGl0KSB7XG4gIHJldHVybiBpc05hTihpdCA9ICtpdCkgPyAwIDogKGl0ID4gMCA/IGZsb29yIDogY2VpbCkoaXQpO1xufTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL190by1pbnRlZ2VyLmpzXG4vLyBtb2R1bGUgaWQgPSAyMlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///22\n");

/***/ }),
/* 23 */
/***/ (function(module, exports, __webpack_require__) {

eval("var shared = __webpack_require__(24)('keys');\nvar uid = __webpack_require__(16);\nmodule.exports = function (key) {\n  return shared[key] || (shared[key] = uid(key));\n};\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX3NoYXJlZC1rZXkuanM/NmIxZCJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSxhQUFhLG1CQUFPLENBQUMsRUFBVztBQUNoQyxVQUFVLG1CQUFPLENBQUMsRUFBUTtBQUMxQjtBQUNBO0FBQ0EiLCJmaWxlIjoiMjMuanMiLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgc2hhcmVkID0gcmVxdWlyZSgnLi9fc2hhcmVkJykoJ2tleXMnKTtcbnZhciB1aWQgPSByZXF1aXJlKCcuL191aWQnKTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGtleSkge1xuICByZXR1cm4gc2hhcmVkW2tleV0gfHwgKHNoYXJlZFtrZXldID0gdWlkKGtleSkpO1xufTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19zaGFyZWQta2V5LmpzXG4vLyBtb2R1bGUgaWQgPSAyM1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///23\n");

/***/ }),
/* 24 */
/***/ (function(module, exports, __webpack_require__) {

eval("var core = __webpack_require__(2);\nvar global = __webpack_require__(0);\nvar SHARED = '__core-js_shared__';\nvar store = global[SHARED] || (global[SHARED] = {});\n\n(module.exports = function (key, value) {\n  return store[key] || (store[key] = value !== undefined ? value : {});\n})('versions', []).push({\n  version: core.version,\n  mode: __webpack_require__(15) ? 'pure' : 'global',\n  copyright: '© 2019 Denis Pushkarev (zloirock.ru)'\n});\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX3NoYXJlZC5qcz83YmMwIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBLFdBQVcsbUJBQU8sQ0FBQyxDQUFTO0FBQzVCLGFBQWEsbUJBQU8sQ0FBQyxDQUFXO0FBQ2hDO0FBQ0Esa0RBQWtEOztBQUVsRDtBQUNBLHFFQUFxRTtBQUNyRSxDQUFDO0FBQ0Q7QUFDQSxRQUFRLG1CQUFPLENBQUMsRUFBWTtBQUM1QjtBQUNBLENBQUMiLCJmaWxlIjoiMjQuanMiLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgY29yZSA9IHJlcXVpcmUoJy4vX2NvcmUnKTtcbnZhciBnbG9iYWwgPSByZXF1aXJlKCcuL19nbG9iYWwnKTtcbnZhciBTSEFSRUQgPSAnX19jb3JlLWpzX3NoYXJlZF9fJztcbnZhciBzdG9yZSA9IGdsb2JhbFtTSEFSRURdIHx8IChnbG9iYWxbU0hBUkVEXSA9IHt9KTtcblxuKG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGtleSwgdmFsdWUpIHtcbiAgcmV0dXJuIHN0b3JlW2tleV0gfHwgKHN0b3JlW2tleV0gPSB2YWx1ZSAhPT0gdW5kZWZpbmVkID8gdmFsdWUgOiB7fSk7XG59KSgndmVyc2lvbnMnLCBbXSkucHVzaCh7XG4gIHZlcnNpb246IGNvcmUudmVyc2lvbixcbiAgbW9kZTogcmVxdWlyZSgnLi9fbGlicmFyeScpID8gJ3B1cmUnIDogJ2dsb2JhbCcsXG4gIGNvcHlyaWdodDogJ8KpIDIwMTkgRGVuaXMgUHVzaGthcmV2ICh6bG9pcm9jay5ydSknXG59KTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19zaGFyZWQuanNcbi8vIG1vZHVsZSBpZCA9IDI0XG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///24\n");

/***/ }),
/* 25 */
/***/ (function(module, exports) {

eval("// IE 8- don't enum bug keys\nmodule.exports = (\n  'constructor,hasOwnProperty,isPrototypeOf,propertyIsEnumerable,toLocaleString,toString,valueOf'\n).split(',');\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2VudW0tYnVnLWtleXMuanM/YzY3NyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQSIsImZpbGUiOiIyNS5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8vIElFIDgtIGRvbid0IGVudW0gYnVnIGtleXNcbm1vZHVsZS5leHBvcnRzID0gKFxuICAnY29uc3RydWN0b3IsaGFzT3duUHJvcGVydHksaXNQcm90b3R5cGVPZixwcm9wZXJ0eUlzRW51bWVyYWJsZSx0b0xvY2FsZVN0cmluZyx0b1N0cmluZyx2YWx1ZU9mJ1xuKS5zcGxpdCgnLCcpO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2VudW0tYnVnLWtleXMuanNcbi8vIG1vZHVsZSBpZCA9IDI1XG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///25\n");

/***/ }),
/* 26 */
/***/ (function(module, exports) {

eval("module.exports = {};\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2l0ZXJhdG9ycy5qcz9mZGI0Il0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBIiwiZmlsZSI6IjI2LmpzIiwic291cmNlc0NvbnRlbnQiOlsibW9kdWxlLmV4cG9ydHMgPSB7fTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19pdGVyYXRvcnMuanNcbi8vIG1vZHVsZSBpZCA9IDI2XG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///26\n");

/***/ }),
/* 27 */
/***/ (function(module, exports, __webpack_require__) {

eval("var def = __webpack_require__(4).f;\nvar has = __webpack_require__(1);\nvar TAG = __webpack_require__(7)('toStringTag');\n\nmodule.exports = function (it, tag, stat) {\n  if (it && !has(it = stat ? it : it.prototype, TAG)) def(it, TAG, { configurable: true, value: tag });\n};\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX3NldC10by1zdHJpbmctdGFnLmpzPzdiYTkiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEsVUFBVSxtQkFBTyxDQUFDLENBQWM7QUFDaEMsVUFBVSxtQkFBTyxDQUFDLENBQVE7QUFDMUIsVUFBVSxtQkFBTyxDQUFDLENBQVE7O0FBRTFCO0FBQ0Esb0VBQW9FLGlDQUFpQztBQUNyRyIsImZpbGUiOiIyNy5qcyIsInNvdXJjZXNDb250ZW50IjpbInZhciBkZWYgPSByZXF1aXJlKCcuL19vYmplY3QtZHAnKS5mO1xudmFyIGhhcyA9IHJlcXVpcmUoJy4vX2hhcycpO1xudmFyIFRBRyA9IHJlcXVpcmUoJy4vX3drcycpKCd0b1N0cmluZ1RhZycpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpdCwgdGFnLCBzdGF0KSB7XG4gIGlmIChpdCAmJiAhaGFzKGl0ID0gc3RhdCA/IGl0IDogaXQucHJvdG90eXBlLCBUQUcpKSBkZWYoaXQsIFRBRywgeyBjb25maWd1cmFibGU6IHRydWUsIHZhbHVlOiB0YWcgfSk7XG59O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX3NldC10by1zdHJpbmctdGFnLmpzXG4vLyBtb2R1bGUgaWQgPSAyN1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///27\n");

/***/ }),
/* 28 */
/***/ (function(module, exports, __webpack_require__) {

eval("exports.f = __webpack_require__(7);\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX3drcy1leHQuanM/MmExZSJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSxZQUFZLG1CQUFPLENBQUMsQ0FBUSIsImZpbGUiOiIyOC5qcyIsInNvdXJjZXNDb250ZW50IjpbImV4cG9ydHMuZiA9IHJlcXVpcmUoJy4vX3drcycpO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX3drcy1leHQuanNcbi8vIG1vZHVsZSBpZCA9IDI4XG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///28\n");

/***/ }),
/* 29 */
/***/ (function(module, exports, __webpack_require__) {

eval("var global = __webpack_require__(0);\nvar core = __webpack_require__(2);\nvar LIBRARY = __webpack_require__(15);\nvar wksExt = __webpack_require__(28);\nvar defineProperty = __webpack_require__(4).f;\nmodule.exports = function (name) {\n  var $Symbol = core.Symbol || (core.Symbol = LIBRARY ? {} : global.Symbol || {});\n  if (name.charAt(0) != '_' && !(name in $Symbol)) defineProperty($Symbol, name, { value: wksExt.f(name) });\n};\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX3drcy1kZWZpbmUuanM/NzJiOSJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSxhQUFhLG1CQUFPLENBQUMsQ0FBVztBQUNoQyxXQUFXLG1CQUFPLENBQUMsQ0FBUztBQUM1QixjQUFjLG1CQUFPLENBQUMsRUFBWTtBQUNsQyxhQUFhLG1CQUFPLENBQUMsRUFBWTtBQUNqQyxxQkFBcUIsbUJBQU8sQ0FBQyxDQUFjO0FBQzNDO0FBQ0EsMERBQTBELHNCQUFzQjtBQUNoRixrRkFBa0Ysd0JBQXdCO0FBQzFHIiwiZmlsZSI6IjI5LmpzIiwic291cmNlc0NvbnRlbnQiOlsidmFyIGdsb2JhbCA9IHJlcXVpcmUoJy4vX2dsb2JhbCcpO1xudmFyIGNvcmUgPSByZXF1aXJlKCcuL19jb3JlJyk7XG52YXIgTElCUkFSWSA9IHJlcXVpcmUoJy4vX2xpYnJhcnknKTtcbnZhciB3a3NFeHQgPSByZXF1aXJlKCcuL193a3MtZXh0Jyk7XG52YXIgZGVmaW5lUHJvcGVydHkgPSByZXF1aXJlKCcuL19vYmplY3QtZHAnKS5mO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAobmFtZSkge1xuICB2YXIgJFN5bWJvbCA9IGNvcmUuU3ltYm9sIHx8IChjb3JlLlN5bWJvbCA9IExJQlJBUlkgPyB7fSA6IGdsb2JhbC5TeW1ib2wgfHwge30pO1xuICBpZiAobmFtZS5jaGFyQXQoMCkgIT0gJ18nICYmICEobmFtZSBpbiAkU3ltYm9sKSkgZGVmaW5lUHJvcGVydHkoJFN5bWJvbCwgbmFtZSwgeyB2YWx1ZTogd2tzRXh0LmYobmFtZSkgfSk7XG59O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX3drcy1kZWZpbmUuanNcbi8vIG1vZHVsZSBpZCA9IDI5XG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///29\n");

/***/ }),
/* 30 */
/***/ (function(module, exports) {

eval("exports.f = {}.propertyIsEnumerable;\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX29iamVjdC1waWUuanM/MzY5MiJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSxjQUFjIiwiZmlsZSI6IjMwLmpzIiwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0cy5mID0ge30ucHJvcGVydHlJc0VudW1lcmFibGU7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fb2JqZWN0LXBpZS5qc1xuLy8gbW9kdWxlIGlkID0gMzBcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///30\n");

/***/ }),
/* 31 */
/***/ (function(module, exports) {

eval("module.exports = \"data:image/png;base64,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\"\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvYXNzZXRzL2ltYWdldmlldy9zdWZmaXgvb3RoZXIucG5nPzMxOTkiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEsaUNBQWlDIiwiZmlsZSI6IjMxLmpzIiwic291cmNlc0NvbnRlbnQiOlsibW9kdWxlLmV4cG9ydHMgPSBcImRhdGE6aW1hZ2UvcG5nO2Jhc2U2NCxpVkJPUncwS0dnb0FBQUFOU1VoRVVnQUFBSllBQUFDV0NBWUFBQUE4QVhIaUFBQU41RWxFUVZSNFh1MmRhNHdVeHhISHErY2VQQTY0M1VPS0pRT09IQWVNdVYyd1pFV0JMN0ZzOGNuK1lDc3lpWlBieFlteGp3UEZDWTd6eExGMGtoUG42ZUE4eE82Um1JUkhUQXlKRkV1Qkw3Rml4WW9FaVpRUEdDbHliRUVVUVlSQ3dtRWVkK0I3VEVVMXk5ek5Eck5iUFgwOWU4dHN6Y2ZyN3BycWYvKzJxcnBuYjFhQlhLSkFBZ3FvQkd5S1NWRUFCQ3lCSUJFRkJLeEVaQldqQXBZd2tJZ0NBbFlpc29wUkFVc1lTRVFCQVNzUldjV29nQ1VNSktLQWdKV0lyR0pVd0JJR0VsRkF3R0preGNGQjUvSy9iLyt3Mitia0Vad2NnSnRIcFhJS2NEbUFjbW9OUjRRVFBlWEM2a1JXN1NZd0ttQUZGbWwwWU0rU2NXalBJYnA1ZEZRT0VQT2dvQmRBelltN2xnSldYTVZTMEgrNC8yQTN0RS9rSFhSemdKQkhnQndDckZFS3VtMU5UOEN5cFdRVDJzR25qc3g1Yi96aUtnQTNod3J6QU9DQnBCUXNUZHBkQVN0cGhSdGczNitESmp2YWMrQkNIZ0J6cUNEUDFVRkp1aVpnSmFsdUFyWkhQbmZnMW9rSk4rOEM1a0FSUkpBamtFenFvQVRjbXpJcFlDV3A3Z3hzTjZJT21vRjc3RkFCaTVVbzJRNWVIVFI1NFM1S1lSaUlRZ3BnV2JKM1R0YTZnSldzdnRPcFlYRFF1WFIyK1IxdUcrUUJjV28zcGhTdXFIY2UxQ0Qzck45R3dMSXVLUURWUWVQdVpBNjlRaHF1MTBMTlZ3Y2xNSFdwc2E0ck1LTURVcXFEMnAyeEhCWFNxRlJsTjRicWJwdm5RVWt1ZnBLMkpXSnBxT3ZWUVdQblY2SlRnWWZPZ2lnU0thVnUweGpla2wwRUxJMWxIOTZ5djZRQUJqUzZTcGZyQ2doWUdpZ0lXQm9paGJzZ25nT0Frc0hJSmhyaW9BUHdqMFZqMXc2cjNac3V4M0ZNcThZU3NPSkltc3ErRnhCaFkwKzU4SHZkMlFsWXVrcTFmRDkwd1hVK25oM3FlMDFIQ2dGTFJ5WHBVMUVBNFgrWjg1MUwxS0ZQakhHU0NGaWNRb2J0YlV1em9PWjFHbzV1am1IdThBaTQ1NjlVT2VPZyttaDN1ZSt2bkljQ0ZxZVFZZnVDcDlkRCsvSmJERWMzeDdCcmg5K0NhNGRQVkRtakVCL0psSXUvNVR3VXNEaUZETnRURE5Zbk0rWGlRVTRXQVl0VHlMQmR3TklRVG80Yk5FUUtkVWt0V0FvZXpld3N2TW9wSWhHTFU4aXdYY0RTRUU0aWxvWklMUkt4SEZTZjZpNzMvWnBUUkNJV3A1QmhlMW9qbGwyd0J2YVhsWUxOaGhxMzVEQUJTMlBaaHdVc0RaV3F1NlFXTEJjLzNUMVVQTUFKb3BjS0JTeE94eHZhQlN3TnlTUmlhWWpVSXNVN0F2VDFsQXF2Y0lwSXhPSVVNbXhQYThRU3NBeUJzRFVzdFdBaEZuckt4Vjl4T2tuRTRoUXliQmV3TklTVEdrdERwTmFwc1lvOXBjSitUaEdKV0p4Q2h1MnBqVmdBQXBZaEUxYUdwUlVzUUxVeFcrN2J4NGtrRVl0VHlMQmR3TklRVG1vc0RaRmFwTVlDRngvTERoWDNjb3BJeE9JVU1teFBiY1FTc0F5SnNEUXN0V0FCZkNaYkt1emhaTktMV0Z2MkRTbFEvWnd4YVo5V1FNRFNvR0ZZd05KUXFicExhc0ZDOWRsc3VlK1huQ0FTc1RpRkROc0ZMQTNoSkdKcGlOUXF1MExBeDdPbDRpODRSU1JpY1FvWnRxYzJZZ2xZaGtSWUdwWmFzQkEyWmN1RjNaeE1FckU0aFF6YkJTd040YVRHMGhDcFZXb3NpVmp4WWJBNXdrYkV3cXZqTUhic0pFeThjODU3Njh2a21RdWVpL1FtRzJmeEF1aGMreUhvV0pQY3p3SkZ2aFJFcVNjeU8vdGU1clNTVk1ncFpOZytVN0RHajUrQjBiMUhBYS9XZnhWVis0cGJZTjRqOTNpdzJiNEVMTnVLV3JBM0U3Q2lGclNlUy9RZXJrWGZmQmpVdkE0TG5rK2JpQVFMOE1sTXFmaHo3a1lTc1RpRkROdE53YUowZC9tRkkxVjM3Vml6RE5xWGY4Q0xTdTc1RVpoNDl6OHdkdXhVVlIrS1hBdTJyVGYwTm5xWWdHVlZUanZHVE1FaXFQeGFpanloTkRmbi9wVTNPQlVGb09rOWE4MDQrc1ZyMEo4cEYzN0dxYVFYc1FiMjcxSUtudVNNU2Z1MEFpYUxUSkhveW83WHA0eHdVV2gwM3pFWU8zcHlxdis4RGZmQW5QdHVoTkIwWFFRc1UrVVNIR2NDRnFVM0t0ajlhLzdHZGQ3T3I5WVY3aytSalNLY3JhdEdLdHljS1JWM2NmZXdFckhvWFp1VS95azhSNzBRbFp5Z0FqUE96c1czNDc4a3RwYmRzRzM2MU1lOW44NFltaHUzUXd1S2JRSldlQ0U1RytFSTE3bnVEcGhmWE11dHVYYjdySUJGb016ZnVCYW9zQXhmdEFBalEyL0N4RHVWUmFhTEMrdGhHLzZrZkhIcjdaU0N0dC9iV3ZsZnlqajNpek5tN09ncHVIYmt4QTF2RXc3N3owRVJ0YnBrbXo1QS9rWFJ5bG5jVlJPRXE3LzVHN3oveDdlbjJ1YyttSWU1RDY3V0JvZnJXT1BsdGdPWmNuR0lHMnNVc1NpS2tIQUVGeDNpVFo0WjlpQ2lRenRxOHlNVFRab21UeGY5aldxQTRFWDluWjZ1S1J2QnRyRmovL1RxQnh0ZytSR3BsaGgrWGVQRDZNOHAzTjkvQ3pMdHpLaklyaGZCVE1EaUZpdllUajVlK3NidnFuem8ybnl2MVFQVGhvTzE2UG1IdlU4U0xkaEkrYzBiQkE3bWVvcGM0OGRQUjJybWY4TENJVDNZMlFaWWZrVGlGczRIcTVZLzlFRWdmK2pEd0owMUpRa1dRVFV5OUtlcWpFQytMWHIrSVc2S3NkcWpVeUZzeVpRS1pjNVE3SWpsdzBBaG16NHh0YTZwZnVkSDROSnowZjF1TnJCb3JyN1BkREpPaTF2clNnb3NndXJLamo5VUhVbVFEMTJiUHhaWmxuQUExR3R2S0ZnTHR6L2dwYlh3Vmpmc1lQQTArTXBMcjFkOXV2eStOek5ZOWFJc3pTOEpzS0tnSXAxcEo5aTVydmJ1MFJTdUtMQVFjV3RQdWNqK3FsbnNpSlhaMmVmNUdUN0lpM0xlRnpkY1pKcUFSWVZ0K0xUWnR4T3MzNklLOGVEWlVOaFBxcFA4QTBtdFZMaHR2VmNHY0Irc0pNQUtmMEFKS3JwUG5OMTJITWdhQmxZd2ordlVMZjQ1elB0dnZBMVhEMVdLK09BVkoyTHBDaEpuaDBjMmc1Rm51bmdmZzhuVGxXOFNCSysyWlpYZng2azFuMkJmMjJDRkZ6bHBxR2d1TmVySXoyZExoWjl3NnhFcllzMG1XUFhPa1lKblpGRmcxZHNWa2wwZmVwMGpDdHI5VXJRSy8zaFJXR2liWUVYVnMzNUp3aTN3VE5vYkJoWTVPVnVwc0ZhZFJqNXg1MWc2MFRWb3g0UHQrakdKdnpBRTc1ejc3L1IrZUluUzU4Vm5EdFZkTTV0Z2hTT2s3WVBRV2hPSkJBdlZGN0xsdmg5endPcEZyTUQvRmNZcjNoL3lVb2VONHIyUllOVXF6R2t1QzU5OXdEdHVhR1NORlY1ZzIrZFZUUUdXempFQ09hcHpMQkdueG1vR3NHaGVmdDNZeUhPczhGbWd6V2hZTC9JME5HS1JJL1NsTXZyVVVyMUJrdzZmUU5NVGR2K1UzZFlCYWJPQTVYOFl3ZytBazZ5eHZQcHlkUHFicFA0bWdrdEhNMjJQQk12RmJkbWg0bzg0MjdGVElSbWs3VzNYd0wzWEg4ZFVkbEFUNzU2RHRxV1pxY2M2MUkvYlBUVXFZZ1dmV1VZSk12YVh5dU1qN3JpQnh2cFBGV2JqSEl0YlROdnREUWVMSmxCNUNMMHU4dGxVMUNPSHFFazNDaXhPY0Y5QUhiQ0NPK05MejcxV2MzZG9NMTM1bXdsNlJ1bC94OTMyMTVDak5Kb1ZzSUtPMEdSSmNPOC9TVTdyZjczRWV3aTl1TXNMODhGdlRRWnRlMStibWQ5WjE2NTMzTENzOHM4RWZuUUsvbzBEaXhhTWZQZkgxUFBIajlqa2t6OHV5cjR0c09pbzRmSzNxaDk0eitxdU1NbFV5QzJVdE50N3BCT1ZjdWtEMFAzaWhzUmxyckZCZVRwYktyekUzZHlveHVLTVNudXlZT2tjNU5wWUF3SExob3FXYmRoS2hlUldjR2ZkaUVjNXZoUUNsbVVvYkppekNSYjU0eDg1VUxScTFGWGpIT3VMMlhMZkRzNEhTWVdjUW9idHRzRXlkR05Hd3dTc0djbVh6R0FCUzBOWGVkdU1oa2loTGdLV2htWUNsb1pJclFJVzREUFpVdkdIbkNKU1kzRUtHYmFuTm1JSldJWkVXQm9tWUdrSUthbFFRNlJXU1lVSVg4cVdDeTl5aWtncTVCUXliRTl0eEJLd0RJbXdORXpBMGhCU1VxR0dTSklLcXhTUVZCaWZHYTBSYVkxWXlzVXZaNGFLUCtCRUVMQTRoUXpiQlN3TjRTUVZhb2pVSXFsUUlsWjhGcXlPU0czRUF2eEtwbFQ4UGllV3BFSk9JY04yQVV0RE9FbUZHaUsxU2lxVWlCVWZCcHNqSkdKcHFDa1JTME9rVm9sWUNGL05sQXZmNHhTUkdvdFR5TEE5dFJGTHdESWt3dEl3QVV0RFNFbUZHaUsxU2lvRS9GcW1WUHd1cDRpa1FrNGh3L2JVUml3Qnk1QUlTOE1FTEEwaEpSVnFpQ1Nwc0VvQlNZWHhtZEVha2RhSWhRaGY3eWtYdnNPSklHQnhDaG0yQzFnYXdra3ExQkNwUlZLaFJLejRMRmdka2RxSUJiQzlwMVQ0TmllV3BFSk9JY1AyOUlLRnovYVVpaTl3c2doWW5FS0c3YWtGUzRwM1F5SXNEVXNyV0NEL0NXMkpFRU16YVFVTEVaL3FLUmQveXNraXFaQlR5TEE5cldBQndxWnN1YkNiazBYQTRoUXliRThyV0VyQm81bWRoVmM1V1FRc1RpSERkdnBsanFSK1I5RFFwZGpEL04vbHJocm80dDNab2VKeHpwaUF4U2trN1VFRkpqS1RJL1BWcnMzam5Dd0NGcWVRdEFjVXdMM1pVdkV4SFVrRUxCMlZwQThnNG1nSHFvOHNIQ3I4WFVjT0FVdEhwVmJ0Z3pnT0N2NEZxUDdjNmVMMnJsM0ZzN3BTQ0ZpNlNzWHRoM2dTQUo2SU82d1orcmVCR3A5dzNkUFpXMCtkVVlPRHJvbFBBcGFKYWxwajhLMXNxYmhHcTJzS093bFlpUzJxZ01WS085eS9QNjhjZFI4QzVrQmhMNERLS1lCRjdNQ1c3aUJnR1MzLzZNQ2VKZVBRbm5PVjJ3dW9lckVDWEs4Q1dHQmtNSFdEQkN5clN6cmN2L2UyTnRXV1E4ZnRSVkM5Z05pTHlnTnVudFViTmIweEFTdnhKVUpBZFhITEs3ZTc3bVF2S0tkWEtmQ0FBd1dyQU5TY3hCMllsUnNJV0xNaU85MFVCd2VkUzJlWDMrRlNkRVBWQytEWGI3Z1NsT3FZTmNlczNGakFzaUtqVFNPNDRXRGI1ZXpFY3RlWjlOSW9BT1FRZ1NMZENnQm90M212NUd3SldNbHBhOWt5OWc5MVhJQ3VsZEFHZVVESWc4SThnRnF0QUpaWnZwVUZjd0tXQlJGbjE4UncvOEZ1YUovSWd6dVpCeURnd0FkdUZvOUVCS3pacFNMQnU0OXVQYkJzZk5MTm8rUG0wWXR3SG5DckdwTk9CYXdFbDdiNVRPUGdHKzFYL252MlRuY1M4Nmh3OVRSdzhFRzczZ3BZZHZXOFNhM2g0eTh2dkR5M00rKzZrRWVsdkJvT0FkWW9CZDFtVXhLd3pIUnJrVkhlRXdaMDh1Z1FhR28xb0xkaHVBc1VkTmFYUU1CcUVVUmttbzFVUU92YkRZMTBTTzZWRGdVRXJIU3NZOVBOUXNCcXVpVkpoME1DVmpyV3NlbG1JV0ExM1pLa3d5RUJLeDNyMkhTekVMQ2Fia25TNFpDQWxZNTFiTHBaQ0ZoTnR5VHBjRWpBU3NjNk50MHMvZy8xcUpJZXNjcTFKd0FBQUFCSlJVNUVya0pnZ2c9PVwiXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9zcmMvYXNzZXRzL2ltYWdldmlldy9zdWZmaXgvb3RoZXIucG5nXG4vLyBtb2R1bGUgaWQgPSAzMVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///31\n");

/***/ }),
/* 32 */
/***/ (function(module, exports) {

eval("var g;\r\n\r\n// This works in non-strict mode\r\ng = (function() {\r\n\treturn this;\r\n})();\r\n\r\ntry {\r\n\t// This works if eval is allowed (see CSP)\r\n\tg = g || Function(\"return this\")() || (1,eval)(\"this\");\r\n} catch(e) {\r\n\t// This works if the window reference is available\r\n\tif(typeof window === \"object\")\r\n\t\tg = window;\r\n}\r\n\r\n// g can still be undefined, but nothing to do about it...\r\n// We return undefined, instead of nothing here, so it's\r\n// easier to handle this case. if(!global) { ...}\r\n\r\nmodule.exports = g;\r\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vKHdlYnBhY2spL2J1aWxkaW4vZ2xvYmFsLmpzPzM2OTgiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDRDQUE0Qzs7QUFFNUMiLCJmaWxlIjoiMzIuanMiLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgZztcclxuXHJcbi8vIFRoaXMgd29ya3MgaW4gbm9uLXN0cmljdCBtb2RlXHJcbmcgPSAoZnVuY3Rpb24oKSB7XHJcblx0cmV0dXJuIHRoaXM7XHJcbn0pKCk7XHJcblxyXG50cnkge1xyXG5cdC8vIFRoaXMgd29ya3MgaWYgZXZhbCBpcyBhbGxvd2VkIChzZWUgQ1NQKVxyXG5cdGcgPSBnIHx8IEZ1bmN0aW9uKFwicmV0dXJuIHRoaXNcIikoKSB8fCAoMSxldmFsKShcInRoaXNcIik7XHJcbn0gY2F0Y2goZSkge1xyXG5cdC8vIFRoaXMgd29ya3MgaWYgdGhlIHdpbmRvdyByZWZlcmVuY2UgaXMgYXZhaWxhYmxlXHJcblx0aWYodHlwZW9mIHdpbmRvdyA9PT0gXCJvYmplY3RcIilcclxuXHRcdGcgPSB3aW5kb3c7XHJcbn1cclxuXHJcbi8vIGcgY2FuIHN0aWxsIGJlIHVuZGVmaW5lZCwgYnV0IG5vdGhpbmcgdG8gZG8gYWJvdXQgaXQuLi5cclxuLy8gV2UgcmV0dXJuIHVuZGVmaW5lZCwgaW5zdGVhZCBvZiBub3RoaW5nIGhlcmUsIHNvIGl0J3NcclxuLy8gZWFzaWVyIHRvIGhhbmRsZSB0aGlzIGNhc2UuIGlmKCFnbG9iYWwpIHsgLi4ufVxyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBnO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAod2VicGFjaykvYnVpbGRpbi9nbG9iYWwuanNcbi8vIG1vZHVsZSBpZCA9IDMyXG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///32\n");

/***/ }),
/* 33 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("/* WEBPACK VAR INJECTION */(function(process) {/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_json_stringify__ = __webpack_require__(52);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_json_stringify___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_json_stringify__);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__utils_util_js__ = __webpack_require__(54);\n\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n\n\n__webpack_require__(55);\n__webpack_require__(60);\n__webpack_require__(63);\nvar $ = __webpack_require__(65);\nwindow.$ = $;\nwindow.jQuery = $;\n__webpack_require__(66);\n\n$(function () {});\n/* harmony default export */ __webpack_exports__[\"a\"] = ({\n  name: 'FileUpload',\n  props: {\n    currentNode: { // 当前选中分类\n      type: String,\n      default: ''\n    },\n    initfiles: { // 初始文件信息\n      type: Array,\n      default: function _default() {\n        return [];\n      }\n    },\n    uploadprops: {\n      type: Object,\n      default: function _default() {\n        return {\n          config: {\n            thumbWidth: 125, // 缩略图宽度，可省略，默认为110\n            thumbHeight: 125, // 缩略图高度，可省略，默认为110\n            wrapId: 'uploader', // 必填\n            shwoAlllist: false, // 是否显示全部图片标签页\n            fileformat: 'gif,jpg,jpeg,png,zip,pdf,xlsx,xls,doc,docx,ppt,rar' // 允许上传的文件格式\n          },\n          // 处理客户端新文件上传时，需要调用后台处理的地址, 必填\n          uploadUrl: '',\n          // 处理客户端原有文件更新时的后台处理地址，必填\n          updateUrl: '',\n          // 当客户端原有文件删除时的后台处理地址，必填\n          removeUrl: '',\n          // 初始化客户端上传文件，从后台获取文件的地址, 可选，当此参数为空时，默认已上传的文件为空\n          initUrl: ''\n        };\n      }\n    }\n  },\n  data: function data() {\n    return {\n      vchrInfo: {},\n      CNodeImgeCount: 0,\n      AllImgeCount: 0\n    };\n  },\n\n  watch: {\n    currentNode: function currentNode(newval, oldval) {\n      if (newval === '0') {\n        this.tabChange('allView');\n      } else {\n        this.tabChange('detailView');\n      }\n      this.showImglist(newval);\n      this.updataImgCount();\n    }\n  },\n  mounted: function mounted() {\n    // require('@/components/webuploader/webuploader-0.1.5/extend-webuploader.js')\n    // 获取url上的参数\n    var _this = this;\n    _this.initWebUploader();\n    window.onresize = function () {\n      _this.showImglist(_this.currentNode);\n    };\n  },\n  methods: {\n    initWebUploader: function initWebUploader() {\n      var _this = this;\n      /* eslint-disable */\n      if (!this.uploadprops) {\n        console.log(\"请配置好_this.uploadprops\");\n        $(\"#dndArea p\").html(\"请配置好uploadprops\");\n        return false;\n      }\n      if (!this.uploadprops.config || !this.uploadprops.config.wrapId) {\n        console.log(\"请配置好uploadprops.config.wrapId\");\n        $(\"#dndArea p\").html(\"请配置好uploadprops.config.wrapId\");\n        return false;\n      }\n      if (!_this.uploadprops.uploadUrl) {\n        console.log(\"请配置好_this.uploadprops.uploadUrl\");\n        $(\"#dndArea p\").html(\"请配置好uploadprops.uploadUrl\");\n        return false;\n      }\n      if (!_this.uploadprops.updateUrl) {\n        console.log(\"请配置好_this.uploadprops.updateUrl\");\n        $(\"#dndArea p\").html(\"请配置好uploadprops.updateUrl\");\n        return false;\n      }\n      if (!_this.uploadprops.removeUrl) {\n        console.log(\"请配置好_this.uploadprops.removeUrl\");\n        $(\"#dndArea p\").html(\"请配置好uploadprops.removeUrl\");\n        return false;\n      }\n      var disX = 0;\n      var disY = 0;\n      var minZindex = 1;\n      var origin;\n      var is_moveing = false;\n      var $wrap = $(\"#\" + _this.uploadprops.config.wrapId);\n      /* var $queue = $('<ul class=\"filelist\"></ul>').appendTo(\r\n        $wrap.find(\".queueList\")\r\n      ); */\n      var $queue = $(\".filelist\");\n      var $statusBar = $wrap.find(\".statusBar\");\n      var $info = $statusBar.find(\".info\");\n      var $upload = $wrap.find(\".uploadBtn\");\n      var $placeHolder = $wrap.find(\".placeholder\");\n      var $progress = $statusBar.find(\".progress\").hide();\n      var fileCount = 0;\n      var fileSize = 0;\n      var state = \"pedding\";\n      var percentages = {};\n      var supportTransition = function () {\n        var s = document.createElement(\"p\").style,\n            r = \"transition\" in s || \"WebkitTransition\" in s || \"MozTransition\" in s || \"msTransition\" in s || \"OTransition\" in s;\n        s = null;\n        //return r;  //暂时先写死  以后遇到问题再调试 wqd\n        return true;\n      }();\n      // 优化retina, 在retina下这个值是2\n      var ratio = window.devicePixelRatio || 1;\n      // 缩略图大小\n      var thumbnailWidth = _this.uploadprops.config.thumbWidth || 110;\n      thumbnailWidth *= ratio;\n      var thumbnailHeight = _this.uploadprops.config.thumbHeight || 110;\n      thumbnailHeight *= ratio;\n      var uploader = WebUploader.create({\n        swf: \"http://cdn.staticfile.org/webuploader/0.1.0/Uploader.swf\", //require('@/components/webuploader/webuploader-0.1.5/Uploader.swf')\n        server: _this.uploadprops.uploadUrl,\n        pick: {\n          id: \"#filePicker\",\n          label: \"点击选择图片\"\n        },\n        dnd: \".queueList\",\n        paste: document.body,\n        accept: {\n          title: \"Images\",\n          extensions: _this.uploadprops.config.fileformat,\n          mimeTypes: \"*\"\n        },\n        resize: false,\n        disableGlobalDnd: true,\n        chunked: true,\n        fileNumLimit: 9999\n      });\n\n      function setDragEvent() {\n        $(this).on(\"drop\", function (e) {\n          var $from = $(origin).parents(\"li\");\n          var $to = $(e.target).parents(\"li\");\n          var origin_pos = $from.position();\n          var target_pos = $to.position();\n          var from_sort = $from.attr(\"data-sort\");\n          var to_sort = $to.attr(\"data-sort\");\n\n          $from.addClass(\"move\").animate(target_pos, \"fast\", function () {\n            $(this).removeClass(\"move\");\n          }).attr(\"data-sort\", to_sort);\n\n          $to.addClass(\"move\").animate(origin_pos, \"fast\", function () {\n            $(this).removeClass(\"move\");\n          }).attr(\"data-sort\", from_sort);\n        }).on(\"dragstart\", function (e) {\n          if (is_moveing) {\n            return false;\n          }\n          is_moveing = true;\n          e.originalEvent.dataTransfer.effectAllowd = \"move\";\n          origin = this;\n        }).on(\"dragover\", function (e) {\n          if (e.preventDefault) e.preventDefault();\n          is_moveing = false;\n          e.originalEvent.dataTransfer.dropEffect = \"move\";\n        });\n      }\n\n      //更新服务端附件\n      function updateServerFiles() {\n        var postData = {};\n        $('[data-src=\"server\"]').each(function (index, obj) {\n          postData[$(obj).attr(\"data-key\")] = $(obj).attr(\"data-sort\");\n        });\n        $.ajax({\n          type: \"post\",\n          url: _this.uploadprops.updateUrl,\n          data: postData,\n          dataType: \"json\",\n          success: function success(data) {\n            //setState('finish');\n            alert(\"更新成功\");\n            $upload.removeClass(\"disabled\");\n            setState(\"ready\");\n            uploader.reset();\n          }\n        });\n      }\n\n      //删除服务端附件\n      function removeServerFile(file, data, a, b) {\n        var sendData = {\n          'service': 'ImgCommonService',\n          'method': 'deleteImage',\n          'F_IMG_INFOS': [{\n            'F_PKEY': file.F_PKEY\n          }]\n        };\n        $.ajax({\n          url: process.env.BASE_API + '/commAction.do',\n          type: 'POST',\n          data: { jsondata: __WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_json_stringify___default()(sendData) },\n          dataType: 'json',\n          async: false,\n          success: function success(data) {\n            if (data.F_CODE === '0') {\n              fileCount--;\n              updateStatus();\n            }\n            var text = data.F_MESSAGE;\n            _this.$info({\n              title: '提示',\n              okText: '确认',\n              content: text\n            });\n            // _this.$router.go(0) // 刷新当前页面\n          }\n        });\n        /* $.ajax({\r\n          type: \"get\",\r\n          url: _this.uploadprops.removeUrl,\r\n          data: { id: file.name },\r\n          dataType: \"json\",\r\n          success: function(data) {\r\n            fileCount--;\r\n            updateStatus();\r\n          }\r\n        }); */\n      }\n\n      //初始化服务端附件\n      function initServerFile() {\n        if (_this.uploadprops.initUrl) {\n          $.each(_this.initfiles, function (k, fl) {\n            $.each(fl.F_ATTACHS, function (index, file) {\n              file.F_FILE_TP = file.F_FILE_TP.toLowerCase();\n              var src = \"\"; //图片地址\n              try {\n                src = $.inArray(file.F_FILE_TP, __WEBPACK_IMPORTED_MODULE_1__utils_util_js__[\"a\" /* default */].imgSuffix) !== -1 ? __WEBPACK_IMPORTED_MODULE_1__utils_util_js__[\"a\" /* default */].createImgUrl(file.F_ATT_STO_KEY) : __webpack_require__(45)(\"./\" + file.F_FILE_TP + '.png');\n              } catch (error) {\n                src = $.inArray(file.F_FILE_TP, __WEBPACK_IMPORTED_MODULE_1__utils_util_js__[\"a\" /* default */].imgSuffix) !== -1 ? __WEBPACK_IMPORTED_MODULE_1__utils_util_js__[\"a\" /* default */].createImgUrl(file.F_ATT_STO_KEY) : __webpack_require__(31);\n              }\n              var obj = {\n                id: \"SVR_FILE_\" + index,\n                src: 'server',\n                name: file.F_ATT_TITLE,\n                path: src,\n                rotation: 0,\n                size: parseFloat(file.F_ATT_SIZE),\n                type: file.F_FILE_TP,\n                F_FILE_TP: file.F_FILE_TP,\n                F_PKEY: file.F_PKEY,\n                F_PARENT: file.F_PARENT,\n                F_IMG_CODE: fl.F_IMG_CODE,\n                F_ROTATE: fl.F_ROTATE //旋转度数\n              };\n              fileQueue(obj);\n            });\n          });\n          _this.showImglist(_this.currentNode);\n          /* var len = data.length;\r\n              for (var i = 0; i < len; i++) {\r\n                data[i].src = \"server\";\r\n                data[i].id = \"SVR_FILE_\" + i;\r\n                data[i].rotation = 0;\r\n                fileQueue(data[i]);\r\n              } */\n        }\n      }\n\n      //添加附件到webuploader中\n      function addFile(file) {\n        var datatype = _this.currentNode;\n        file.F_ROTATE = file.F_ROTATE || 0;\n        if (file.src === 'server') {\n          datatype = file.F_PARENT;\n        } else {\n          file.F_IMG_TYPE = datatype;\n        }\n        $.each(_this.initfiles, function (k, v) {\n          if (v.key === datatype) {\n            file.F_IMG_CODE = v.F_IMG_CODE;\n          }\n        });\n        var index = $queue.find(\"li[data-type='\" + datatype + \"']\").length;\n        /* var imgLeft = index * (thumbnailWidth + 10);\r\n        var imgTop = 0;\r\n        var wrapHeight = thumbnailHeight + 20;\r\n        var wrapWidth = $queue.width();\r\n        if (imgLeft + (thumbnailWidth + 10) >= wrapWidth) {\r\n          imgTop =\r\n            parseInt((imgLeft + (thumbnailWidth + 10)) / wrapWidth) *\r\n            (thumbnailHeight + 10);\r\n          wrapHeight = imgTop + wrapHeight;\r\n          imgLeft =\r\n            (index % parseInt(wrapWidth / (thumbnailWidth + 10))) *\r\n            (thumbnailWidth + 10);\r\n        } */\n\n        $(\".vchrimage .middle\").css(\"overflow-y\", \"hidden\");\n        $(\".vchrimage .category-view\").css(\"overflow-y\", \"hidden\");\n        var liHeight = thumbnailHeight + 25;\n        var wrapWidth = $queue.width();\n        var wrapHeight = liHeight + 20;\n        var imgNum = parseInt(wrapWidth / (thumbnailWidth + 10)); // 每行有几张图片\n        var imgTop = 0;\n        var imgLeft = index * (thumbnailWidth + 10);\n        if (index + 1 > imgNum) {\n          imgTop = parseInt(index / imgNum) * (liHeight + 10);\n          imgLeft = index % imgNum * (thumbnailWidth + 10);\n          wrapHeight = imgTop + liHeight + 10;\n        }\n\n        $queue.height(wrapHeight);\n        var $li = $('<li data-key=\"' + file.key + '\"  data-src=\"' + file.src + '\" data-sort=\"' + index + '\" data-deg=\"' + file.F_ROTATE + '\" data-type=\"' + datatype + '\" draggable=\"true\" id=\"' + file.id + '\" style=\"position:absolute;margin:0;cursor:move;width:' + thumbnailWidth + \"px;height:\" + liHeight + \"px;left:\" + imgLeft + \"px;top:\" + imgTop + 'px\">' + '<p class=\"imgWrap\"></p>' + '<p class=\"title\">' + file.name + \"</p>\" + '<p class=\"progress\"><span></span></p>' + \"</li>\"),\n            $btns = $('<div class=\"file-panel\">' + '<span class=\"cancel\">删除</span>' + '<span class=\"rotateRight\">向右旋转</span>' + '<span class=\"rotateLeft\">向左旋转</span></div>').appendTo($li),\n            $progess = $li.find(\"p.progress span\"),\n            $wrap = $li.find(\"p.imgWrap\"),\n            $info = $('<p class=\"error\"></p>'),\n            showError = function showError(code) {\n          var text = \"\";\n          switch (code) {\n            case \"exceed_size\":\n              text = \"文本大小超出\";\n              break;\n            case \"interrupt\":\n              text = \"上传暂停\";\n              break;\n            default:\n              text = \"上传失败\";\n              break;\n          }\n          $info.text(text).appendTo($li);\n        };\n        if (supportTransition) {\n          var degs = \"rotate(\" + file.rotation || 0 + \"deg)\";\n          $wrap.css({\n            \"-webkit-transform\": degs,\n            \"-mos-transform\": degs,\n            \"-o-transform\": degs,\n            transform: degs\n          });\n        }\n        //图片点击事件\n        $li.on(\"click\", function () {\n          var file = $(this).data(\"fileinfo\");\n          _this.$emit(\"imageClick\", file);\n        });\n        if (file.src == \"client\") {\n          if (file.getStatus() == \"invalid\") {\n            showError(file.statusText);\n          } else {\n            $wrap.text(\"预览中\");\n            uploader.makeThumb(file, function (error, src) {\n              if (error) {\n                /* $wrap.text(\"不能预览\");\r\n                return; */\n                file.F_FILE_TP = file.ext.toLowerCase();\n                try {\n                  src = $.inArray(file.F_FILE_TP, __WEBPACK_IMPORTED_MODULE_1__utils_util_js__[\"a\" /* default */].imgSuffix) !== -1 ? __WEBPACK_IMPORTED_MODULE_1__utils_util_js__[\"a\" /* default */].createImgUrl(file.F_ATT_STO_KEY) : __webpack_require__(45)(\"./\" + file.ext + '.png');\n                } catch (error) {\n                  src = $.inArray(file.F_FILE_TP, __WEBPACK_IMPORTED_MODULE_1__utils_util_js__[\"a\" /* default */].imgSuffix) !== -1 ? __WEBPACK_IMPORTED_MODULE_1__utils_util_js__[\"a\" /* default */].createImgUrl(file.F_ATT_STO_KEY) : __webpack_require__(31);\n                }\n              }\n              file.path = src;\n              var img = $('<img draggable=\"true\" style=\"width:' + thumbnailWidth + 'px;height:' + thumbnailHeight + 'px\" src=\"' + src + '\">');\n              img.bind(\"load\", setDragEvent);\n              $wrap.empty().append(img);\n            }, 0.8, 0.8\n            /* thumbnailWidth,\r\n            thumbnailHeight */\n            );\n            percentages[file.id] = [fileSize, 0];\n            file.rotation = 0;\n          }\n          file.on(\"statuschange\", function (cur, prev) {\n            if (prev == \"progress\") {\n              $progress.hide().width(0);\n            } else if (prev == \"queued\") {\n              //wqd 20190507注释  上传成功后还允许删除\n              //$li.off('mouseenter mouseleave');\n              //$btns.remove();\n            }\n\n            if (cur == \"error\" || cur == \"invalid\") {\n              showError(file.statusText);\n              percentages[file.id][1] = 1;\n            } else if (cur == \"interrupt\") {\n              showError(\"interrupt\");\n            } else if (cur == \"queued\") {\n              percentages[file.id][1] = 0;\n            } else if (cur == \"progress\") {\n              $info.remove();\n              $progress.css(\"display\", \"block\");\n            } else if (cur == \"complete\") {\n              $li.append('<span class=\"success\"></span>');\n            }\n\n            $li.removeClass(\"state-\" + prev).addClass(\"state-\" + cur);\n            updateStatus();\n          });\n        } else {\n          var img = $('<img draggable=\"true\" style=\"width:' + thumbnailWidth + 'px;height:' + thumbnailHeight + 'px\" src=\"' + file.path + '\">');\n          img.bind(\"load\", setDragEvent);\n          $wrap.empty().append(img);\n          $li.append('<span class=\"success\"></span>');\n          $(\".vchrimage .middle\").css(\"overflow-y\", \"auto\");\n          $(\".vchrimage .category-view\").css(\"overflow-y\", \"auto\");\n        }\n\n        $li.on(\"mouseenter\", function () {\n          $btns.stop().animate({ height: 30 });\n        });\n        $li.on(\"mouseleave\", function () {\n          $btns.stop().animate({ height: 0 });\n        });\n\n        $btns.on(\"click\", \"span\", function () {\n          var index = $(this).index(),\n              deg;\n\n          switch (index) {\n            case 0:\n              //修改删除后面所有图片的位置\n              var allImgs = {};\n              var del_sort = parseInt($(\"#\" + file.id).attr(\"data-sort\"));\n              $queue.find(\"li\").each(function (index, obj) {\n                if ($(obj).attr(\"data-sort\") > del_sort) {\n                  var sort = parseInt($(obj).attr(\"data-sort\"));\n                  var $prevObj = $(\"li[data-sort=\" + (sort - 1) + \"]\");\n                  if ($prevObj) {\n                    allImgs[$(obj).attr(\"id\")] = $prevObj.position();\n                  }\n                }\n              });\n              for (var k in allImgs) {\n                var sort = parseInt($(\"#\" + k).attr(\"data-sort\"));\n                $(\"#\" + k).attr(\"data-sort\", sort - 1).css({\n                  left: allImgs[k].left + \"px\",\n                  top: allImgs[k].top + \"px\"\n                });\n              }\n              allImgs = null;\n              if (file.src == \"client\") uploader.removeFile(file);else {\n                removeServerFile(file);\n                $(\"#\" + file.id).remove();\n                _this.updataImgCount();\n              }\n              _this.showImglist(_this.currentNode);\n              return;\n            case 1:\n              file.rotation += 90;\n              break;\n            case 2:\n              file.rotation -= 90;\n              break;\n          }\n\n          if (supportTransition) {\n            deg = \"rotate(\" + file.rotation + \"deg)\";\n            $wrap.css({\n              \"-webkit-transform\": deg,\n              \"-mos-transform\": deg,\n              \"-o-transform\": deg,\n              transform: deg\n            });\n            $wrap.parent().attr(\"data-deg\", file.rotation);\n          } else {}\n        });\n        $li.appendTo($queue);\n        $li.data(\"fileinfo\", file);\n        _this.updataImgCount();\n      }\n      //删除webupload中的图片\n      function removeFile(file) {\n        var $li = $(\"#\" + file.id);\n        delete percentages[file.id];\n        updateTotalProgress();\n        $li.off().find(\".file-panel\").off().end().remove();\n        _this.updataImgCount();\n      }\n\n      //更新webuploader中图片上传的进度\n      function updateTotalProgress() {\n        var loaded = 0,\n            total = 0,\n            spans = $progress.children(),\n            percent;\n\n        $.each(percentages, function (k, v) {\n          total += v[0];\n          loaded += v[0] * v[1];\n        });\n\n        percent = total ? loaded / total : 0;\n\n        spans.eq(0).text(Math.round(percent * 100) + \"%\");\n        spans.eq(1).css(\"width\", Math.round(percent * 100) + \"%\");\n        updateStatus();\n      }\n\n      //更新webuploader中的状态\n      function updateStatus() {\n        var text = \"\",\n            stats;\n        if (state == \"ready\") {\n          text = \"共\" + WebUploader.formatSize(fileSize) + \".\";\n        } else if (state == \"confirm\") {\n          stats = uploader.getStats();\n          if (stats.uploadFailNum) {\n            text = \"上传成功\" + stats.successNum + \"张影像，上传失败:\" + stats.uploadFailNum +\n            //'张照片上传失败,<a class=\"retry\" href=\"#\">重新上传</a>失败图片或<a class=\"ignore\" href=\"#\">忽略</a>';\n            '张影像，<a class=\"retry\" href=\"#\">重新上传</a>失败影像';\n          }\n        } else {\n          stats = uploader.getStats();\n          text = \"共\" + fileCount + \"张(\" + WebUploader.formatSize(fileSize) + \")，已上传\" + stats.successNum + \"张\";\n          if (stats.uploadFailNum) {\n            text += \",失败\" + stats.uploadFailNum + \"张\";\n          }\n        }\n        $info.html(text);\n      }\n\n      //设置webuploader的状态\n      function setState(val) {\n        var file, stats;\n        if (val == state) {\n          return;\n        }\n        $upload.removeClass(\"state-\" + state);\n        $upload.addClass(\"state-\" + val);\n        state = val;\n\n        switch (state) {\n          case \"pedding\":\n            $placeHolder.removeClass(\"element-invisible\");\n            $queue.parent().removeClass(\"filled\");\n            $queue.hide();\n            $statusBar.addClass(\"element-invisible\");\n            uploader.refresh();\n            break;\n          case \"ready\":\n            $placeHolder.addClass(\"element-invisible\");\n            $(\"#filePicker2\").removeClass(\"element-invisible\");\n            $queue.parent().addClass(\"filled\");\n            $queue.show();\n            $statusBar.removeClass(\"element-invisible\");\n            uploader.refresh();\n            break;\n          case \"uploading\":\n            $(\"filePicker2\").addClass(\"element-invisible\");\n            $progress.show();\n            $upload.text(\"暂停上传\");\n            break;\n          case \"paused\":\n            $progress.show();\n            $upload.text(\"继续上传\");\n            break;\n          case \"confirm\":\n            $progress.hide();\n            //wqd 20190508 注释\n            // $upload.text('开始上传').addClass('disabled');\n            $upload.text(\"开始上传\");\n            stats = uploader.getStats();\n            if (stats.successNum && !stats.uploadFailNum) {\n              //wqd 20190508 注释\n              //setState( 'finish' );\n              return;\n            }\n            break;\n          case \"finish\":\n            stats = uploader.getStats();\n            if (stats.successNum) {\n              alert(\"上传成功\");\n            } else {\n              state = \"done\";\n              location.reload();\n            }\n            break;\n        }\n        updateStatus();\n      }\n\n      //文件加入到webuploader中的队列\n      function fileQueue(file) {\n        file.src = file.src || \"client\";\n        fileCount++;\n        fileSize += file.size;\n\n        if (fileCount == 1) {\n          $placeHolder.addClass(\"element-invisible\");\n          $statusBar.show();\n        }\n\n        addFile(file);\n        setState(\"ready\");\n        updateTotalProgress();\n      }\n\n      if (!WebUploader.Uploader.support()) {\n        console.log(\"WebUploader 不支持\");\n        throw new Error(\"WebUploader does not support\");\n      }\n\n      uploader.addButton({\n        id: \"#filePicker2\",\n        label: \"继续添加\"\n      });\n\n      uploader.on(\"uploadProgress\", function (file, percentage) {\n        var $li = $(\"#\" + file.id),\n            $percent = $li.find(\".progress span\");\n        $percent.css({ \"width\": percentage * 100 + \"%\", \"display\": \"none\" });\n        updateTotalProgress();\n      });\n\n      uploader.on(\"fileQueued\", fileQueue);\n\n      uploader.on(\"fileDequeued\", function (file) {\n        fileCount--;\n        fileSize -= file.size;\n        if (!fileCount) {\n          setState(\"pedding\");\n        }\n        removeFile(file);\n        updateTotalProgress();\n      });\n\n      uploader.on(\"uploadSuccess\", function (file, data) {\n        if (data.F_CODE === \"0\") {\n          $(\"#\" + file.id).find(\"p.state\").text(\"已上传\");\n        }\n      });\n\n      uploader.on(\"uploadError\", function (file, b) {\n        console.log(file.id + \"上传出错\");\n      });\n\n      uploader.on(\"uploadComplete\", function (file, a, b) {\n        $(\"#\" + file.id).find(\"p.state\").fadeOut();\n      });\n\n      uploader.on(\"all\", function (type) {\n        if (type == \"uploadFinished\") {\n          setState(\"confirm\");\n        } else if (type == \"startUpload\") {\n          setState(\"uploading\");\n        } else if (type == \"stopUpload\") {\n          setState(\"paused\");\n        }\n      });\n\n      uploader.on(\"uploadBeforeSend\", function (block, data) {\n        data.sort = $(\"#\" + data.id).attr(\"data-sort\");\n        var file = $(\"#\" + data.id).data(\"fileinfo\");\n        var obj = {\n          \"F_APP_ID\": \"TAIKANG\", //来源系统标识\n          \"F_ACCESS_TOKEN\": \"\",\n          \"F_USER_ID\": \"tianmeng\", //操作人\n          \"F_USER_NAME\": \"\", //操作人名称\n          \"F_NEED_APPLY\": \"1\", //是否需要申请 默认1\n          \"F_BILL_ID\": \"LKRL201812110014\", //单据编号\n          \"F_BILL_TYPE\": \"TTFS_JS_LKRLD\", //单据类型\n          \"F_BIZ_TYPE\": \"TTFS_JS_LKRLD\", //业务类型\n          \"F_AMT\": \"\", //金额\n          \"F_CURR\": \"\", //币种\n          \"F_SC_CODE\": \"\", //共享中心\n          \"F_POOL_ID\": \"\", //业务池\n          \"F_ATT_TYPE\": \"0\", //上传方式 0普通上传 1 集中扫描\n          \"F_APPLY_FILES\": [{\n            \"F_TYPE\": \"0\",\n            \"F_OBJECT\": \"1234567890\",\n            \"F_IMG_CODE\": file.F_IMG_CODE, //影像关键码\n            \"F_IMG_TYPE\": file.F_IMG_TYPE, //影像类别\n            \"F_FILES\": [{\n              \"F_FILE_NAME\": data.name,\n              \"F_FILE_NAME1\": data.name,\n              \"F_FILE_PATH\": \"\",\n              \"F_FILE_SIZE\": data.size,\n              \"F_FILE_MD5\": \"\",\n              \"F_UPLOAD_ZIP\": \"\",\n              \"F_ENCRYPT\": \"\",\n              \"F_ENCRYPT_KEY\": \"\",\n              \"F_BIZ_INFO\": \"\", //摘要\n              \"F_OPER_TYPE\": \"\", //操作类型 默认空表示制单人上传 1表示审批人加批注或编辑图片\n              \"F_ORIG_IMG_KEY\": \"\", //审批人编辑及批注图片时有用\n              \"F_NODE_ID\": \"\", //签批节点\n              \"F_NODE_NAME\": \"\", //签批节点名称\n              \"F_SIGN_USR_NAME\": \"\", //签批人名称\n              \"F_SIGN_NOTE\": \"\", //签批内容\n              \"F_OP_ACTION\": \"\", //操作动作\n              \"F_ROTATE\": file.rotation, //旋转度数\n              \"F_FILE_ORDER\": $(\"#\" + data.id).attr(\"data-sort\"), //显示序号\n              \"F_ISHIDE\": \"0\", //是否隐藏：1是，0否\n              \"F_RISK_TYPE\": \"\" //风险类别\n            }]\n          }]\n        };\n        data.jsondata = __WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_json_stringify___default()(obj);\n        var $li = $(\"#\" + data.id),\n            $percent = $li.find(\".progress span\");\n        $percent.css({ \"width\": \"100%\", \"display\": \"block\" });\n      });\n\n      $upload.on(\"click\", function () {\n        uploader.sort(function (obj1, obj2) {\n          return $(\"#\" + obj1.id).attr(\"data-sort\") > $(\"#\" + obj2.id) ? -1 : 1;\n        });\n        if ($(this).hasClass(\"disabled\")) {\n          return false;\n        }\n        if (state == \"ready\") {\n          if (uploader.getFiles().length < 1) updateServerFiles();else uploader.upload();\n        } else if (state == \"paused\") {\n          uploader.upload();\n        } else if (state == \"uploading\") {\n          uploader.stop();\n        }\n      });\n\n      $info.on(\"click\", \".retry\", function () {\n        uploader.retry();\n      });\n\n      $info.on(\"click\", \".ignore\", function () {\n        alert(\"todo\");\n      });\n\n      $upload.addClass(\"state-\" + state);\n      updateTotalProgress();\n\n      initServerFile();\n    },\n    /* eslint-enable */\n    showImglist: function showImglist(type) {\n      $(\".filelist>li[data-type!='\" + type + \"']\").hide();\n      $(\".filelist>li[data-type='\" + type + \"']\").show();\n      $('.vchrimage .middle').css('overflow-y', 'hidden');\n      $('.vchrimage .category-view').css('overflow-y', 'hidden');\n      // 重新计算图片的位置\n      var $queue = $('.filelist');\n      // 优化retina, 在retina下这个值是2\n      var ratio = window.devicePixelRatio || 1;\n      // 缩略图大小\n      var thumbnailWidth = this.uploadprops.config.thumbWidth || 110;\n      thumbnailWidth *= ratio;\n      var thumbnailHeight = this.uploadprops.config.thumbHeight || 110;\n      thumbnailHeight = thumbnailHeight + 25;\n      thumbnailHeight *= ratio;\n      var wrapHeight = thumbnailHeight + 10;\n      var wrapWidth = $queue.width();\n      var imgNum = parseInt(wrapWidth / (thumbnailWidth + 10)); // 每行有几张图片\n      $(\".filelist>li[data-type='\" + type + \"']\").each(function (index, v) {\n        var imgTop = 0;\n        var imgLeft = index * (thumbnailWidth + 10);\n        if (index + 1 > imgNum) {\n          imgTop = parseInt(index / imgNum) * (thumbnailHeight + 10);\n          imgLeft = index % imgNum * (thumbnailWidth + 10);\n          wrapHeight = imgTop + thumbnailHeight + 10;\n        }\n        $(this).css({ left: imgLeft + 'px', top: imgTop + 'px' });\n      });\n      $queue.css('height', wrapHeight + 'px');\n      $('.vchrimage .middle').css('overflow-y', 'auto');\n      $('.vchrimage .category-view').css('overflow-y', 'auto');\n    },\n    // tab页签点击\n    tabChange: function tabChange(ref) {\n      $(this.$refs[ref]).addClass('tab-active').siblings().removeClass('tab-active');\n      if (ref === 'allView') {\n        $('.queueAllList').show().empty();\n        $('.imgWrap img').clone().appendTo($('.queueAllList'));\n        $('.queueList').hide();\n        $('.queueAllList img').css('margin', '10px');\n        this.AllImgeCount = $('.queueAllList img').length;\n      } else {\n        $('.queueList').show();\n        $('.queueAllList').hide();\n      }\n    },\n    updataImgCount: function updataImgCount() {\n      var $queue = $('.filelist');\n      var count = $queue.find(\"li[data-type='\" + this.currentNode + \"']\").length;\n      this.CNodeImgeCount = count;\n      this.$emit('CNodeImgeCount', count);\n      var allCount = $queue.find('li').length;\n      this.AllImgeCount = allCount;\n    }\n  }\n});\n/* WEBPACK VAR INJECTION */}.call(__webpack_exports__, __webpack_require__(11)))\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vc3JjL2NvbXBvbmVudHMvd2VidXBsb2FkZXIvdXBsb2FkLnZ1ZT82NmM1Il0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQW1DQTtBQUNBLG1CQUFPLENBQVA7QUFDQSxtQkFBTyxDQUFQO0FBQ0EsbUJBQU8sQ0FBUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFPLENBQVA7O0FBRUE7QUFDQTtBQUNBLG9CQURBO0FBRUE7QUFDQTtBQUNBLGtCQURBO0FBRUE7QUFGQSxLQURBO0FBS0E7QUFDQSxpQkFEQTtBQUVBO0FBQ0E7QUFDQTtBQUpBLEtBTEE7QUFXQTtBQUNBLGtCQURBO0FBRUE7QUFDQTtBQUNBO0FBQ0EsMkJBREEsRUFDQTtBQUNBLDRCQUZBLEVBRUE7QUFDQSw4QkFIQSxFQUdBO0FBQ0EsOEJBSkEsRUFJQTtBQUNBLDRFQUxBLENBS0E7QUFMQSxXQURBO0FBUUE7QUFDQSx1QkFUQTtBQVVBO0FBQ0EsdUJBWEE7QUFZQTtBQUNBLHVCQWJBO0FBY0E7QUFDQTtBQWZBO0FBaUJBO0FBcEJBO0FBWEEsR0FGQTtBQW9DQSxNQXBDQSxrQkFvQ0E7QUFDQTtBQUNBLGtCQURBO0FBRUEsdUJBRkE7QUFHQTtBQUhBO0FBS0EsR0ExQ0E7O0FBMkNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FGQSxNQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQVRBLEdBM0NBO0FBc0RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FGQTtBQUdBLEdBOURBO0FBK0RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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QUFRQSxpQ0FSQTtBQVNBLDhCQVRBLEVBU0E7QUFDQSwrQkFWQSxFQVVBO0FBQ0Esa0NBWEEsRUFXQTtBQUNBLDZCQVpBLEVBWUE7QUFDQSwrQkFiQSxFQWFBO0FBQ0EsbUNBZEEsRUFjQTtBQUNBLCtCQWZBLEVBZUE7QUFDQSwrQkFoQkEsRUFnQkE7QUFDQSx1Q0FqQkEsRUFpQkE7QUFDQSxnRUFsQkEsRUFrQkE7QUFDQSw2QkFuQkEsRUFtQkE7QUFDQSwrQkFwQkEsQ0FvQkE7QUFwQkEsYUFEQTtBQUxBLFdBREE7QUFkQTtBQStDQTtBQUNBO0FBQUEsWUFDQSxxQ0FEQTtBQUVBO0FBQ0EsT0F0REE7O0FBd0RBO0FBQ0E7QUFDQTtBQUNBLFNBRkE7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVFQUNBO0FBQ0EsU0FIQSxNQUdBO0FBQ0E7QUFDQSxTQUZBLE1BRUE7QUFDQTtBQUNBO0FBQ0EsT0FmQTs7QUFpQkE7QUFDQTtBQUNBLE9BRkE7O0FBSUE7QUFDQTtBQUNBLE9BRkE7O0FBSUE7QUFDQTs7QUFFQTtBQUNBLEtBOXVCQTtBQSt1QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0RBakJBLENBaUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FUQTtBQVVBO0FBQ0E7QUFDQTtBQUNBLEtBL3dCQTtBQWd4QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FOQSxNQU1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0E3eEJBO0FBOHhCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBcnlCQTtBQS9EQSxHIiwiZmlsZSI6IjMzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiPHRlbXBsYXRlPlxyXG4gIDxkaXY+XHJcbiAgICA8ZGl2IGNsYXNzPVwicGFnZS1jb250YWluZXJcIj5cclxuICAgICAgPGRpdiBpZD1cInVwbG9hZGVyXCI+XHJcbiAgICAgICAgPGRpdiBjbGFzcz1cInN0YXR1c0JhclwiIHN0eWxlPVwiZGlzcGxheTpub25lXCI+XHJcbiAgICAgICAgICA8ZGl2IGNsYXNzPVwidGFiLXZpZXdcIj5cclxuICAgICAgICAgICAgPGRpdiByZWY9XCJkZXRhaWxWaWV3XCIgc3R5bGU9XCJmbG9hdDpsZWZ0XCIgY2xhc3M9XCJ0YWItYWN0aXZlXCIgQGNsaWNrPVwidGFiQ2hhbmdlKCdkZXRhaWxWaWV3JylcIj7liIbnsbvlsZXnpLpcclxuICAgICAgICAgICAgICB7eyBDTm9kZUltZ2VDb3VudCB9fVxyXG4gICAgICAgICAgICA8L2Rpdj5cclxuICAgICAgICAgICAgPGRpdiB2LWlmPVwidXBsb2FkcHJvcHMuY29uZmlnLnNod29BbGxsaXN0XCIgcmVmPVwiYWxsVmlld1wiIHN0eWxlPVwiZmxvYXQ6bGVmdFwiIEBjbGljaz1cInRhYkNoYW5nZSgnYWxsVmlldycpXCI+5YWo6YOo5bGV56S6e3sgQWxsSW1nZUNvdW50IH19PC9kaXY+XHJcbiAgICAgICAgICAgIDxkaXYgc3R5bGU9XCJjbGVhcjpib3RoXCIvPlxyXG4gICAgICAgICAgPC9kaXY+XHJcbiAgICAgICAgICA8ZGl2IGNsYXNzPVwiYnRuc1wiPlxyXG4gICAgICAgICAgICA8ZGl2IGNsYXNzPVwicHJvZ3Jlc3NcIj5cclxuICAgICAgICAgICAgICA8c3BhbiBjbGFzcz1cInRleHRcIj4wJTwvc3Bhbj5cclxuICAgICAgICAgICAgICA8c3BhbiBjbGFzcz1cInBlcmNlbnRhZ2VcIi8+XHJcbiAgICAgICAgICAgIDwvZGl2PlxyXG4gICAgICAgICAgICA8ZGl2IGNsYXNzPVwiaW5mb1wiPuWFsSA1IOW8oDwvZGl2PlxyXG4gICAgICAgICAgICA8ZGl2IGlkPVwiZmlsZVBpY2tlcjJcIi8+XHJcbiAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJ1cGxvYWRCdG5cIj7lvIDlp4vkuIrkvKA8L2Rpdj5cclxuICAgICAgICAgIDwvZGl2PlxyXG4gICAgICAgIDwvZGl2PlxyXG4gICAgICAgIDxkaXYgY2xhc3M9XCJxdWV1ZUxpc3RcIj5cclxuICAgICAgICAgIDxkaXYgaWQ9XCJkbmRBcmVhXCIgY2xhc3M9XCJwbGFjZWhvbGRlclwiPlxyXG4gICAgICAgICAgICA8ZGl2IGlkPVwiZmlsZVBpY2tlclwiLz5cclxuICAgICAgICAgICAgPHA+5oiW5bCG54Wn54mH5ouW5Yiw6L+Z6YeMe3sgY3VycmVudE5vZGUgfX08L3A+XHJcbiAgICAgICAgICA8L2Rpdj5cclxuICAgICAgICAgIDx1bCBjbGFzcz1cImZpbGVsaXN0XCIgc3R5bGU9XCJoZWlnaHQ6IDEzNXB4O1wiLz5cclxuICAgICAgICA8L2Rpdj5cclxuICAgICAgICA8ZGl2IGNsYXNzPVwicXVldWVBbGxMaXN0XCIvPlxyXG4gICAgICA8L2Rpdj5cclxuICAgIDwvZGl2PlxyXG4gIDwvZGl2PlxyXG48L3RlbXBsYXRlPlxyXG48c2NyaXB0PlxyXG5pbXBvcnQgVXRpbCBmcm9tICdAL3V0aWxzL3V0aWwuanMnXHJcbnJlcXVpcmUoJ0AvY29tcG9uZW50cy93ZWJ1cGxvYWRlci9jc3MvZGVtby5jc3MnKVxyXG5yZXF1aXJlKCdAL2NvbXBvbmVudHMvd2VidXBsb2FkZXIvY3NzL3N0eWxlLmNzcycpXHJcbnJlcXVpcmUoJ0AvY29tcG9uZW50cy93ZWJ1cGxvYWRlci93ZWJ1cGxvYWRlci0wLjEuNS93ZWJ1cGxvYWRlci5jc3MnKVxyXG52YXIgJCA9IHJlcXVpcmUoJ2pxdWVyeScpXHJcbndpbmRvdy4kID0gJFxyXG53aW5kb3cualF1ZXJ5ID0gJFxyXG5yZXF1aXJlKCdAL2NvbXBvbmVudHMvd2VidXBsb2FkZXIvd2VidXBsb2FkZXItMC4xLjUvd2VidXBsb2FkZXIuanMnKVxyXG5cclxuJChmdW5jdGlvbiAoKSB7fSlcclxuZXhwb3J0IGRlZmF1bHQge1xyXG4gIG5hbWU6ICdGaWxlVXBsb2FkJyxcclxuICBwcm9wczoge1xyXG4gICAgY3VycmVudE5vZGU6IHsvLyDlvZPliY3pgInkuK3liIbnsbtcclxuICAgICAgdHlwZTogU3RyaW5nLFxyXG4gICAgICBkZWZhdWx0OiAnJ1xyXG4gICAgfSxcclxuICAgIGluaXRmaWxlczogey8vIOWIneWni+aWh+S7tuS/oeaBr1xyXG4gICAgICB0eXBlOiBBcnJheSxcclxuICAgICAgZGVmYXVsdDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiBbXVxyXG4gICAgICB9XHJcbiAgICB9LFxyXG4gICAgdXBsb2FkcHJvcHM6IHtcclxuICAgICAgdHlwZTogT2JqZWN0LFxyXG4gICAgICBkZWZhdWx0OiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgIGNvbmZpZzoge1xyXG4gICAgICAgICAgICB0aHVtYldpZHRoOiAxMjUsIC8vIOe8qeeVpeWbvuWuveW6pu+8jOWPr+ecgeeVpe+8jOm7mOiupOS4ujExMFxyXG4gICAgICAgICAgICB0aHVtYkhlaWdodDogMTI1LCAvLyDnvKnnlaXlm77pq5jluqbvvIzlj6/nnIHnlaXvvIzpu5jorqTkuLoxMTBcclxuICAgICAgICAgICAgd3JhcElkOiAndXBsb2FkZXInLCAvLyDlv4XloatcclxuICAgICAgICAgICAgc2h3b0FsbGxpc3Q6IGZhbHNlLCAvLyDmmK/lkKbmmL7npLrlhajpg6jlm77niYfmoIfnrb7pobVcclxuICAgICAgICAgICAgZmlsZWZvcm1hdDogJ2dpZixqcGcsanBlZyxwbmcsemlwLHBkZix4bHN4LHhscyxkb2MsZG9jeCxwcHQscmFyJy8vIOWFgeiuuOS4iuS8oOeahOaWh+S7tuagvOW8j1xyXG4gICAgICAgICAgfSxcclxuICAgICAgICAgIC8vIOWkhOeQhuWuouaIt+err+aWsOaWh+S7tuS4iuS8oOaXtu+8jOmcgOimgeiwg+eUqOWQjuWPsOWkhOeQhueahOWcsOWdgCwg5b+F5aGrXHJcbiAgICAgICAgICB1cGxvYWRVcmw6ICcnLFxyXG4gICAgICAgICAgLy8g5aSE55CG5a6i5oi356uv5Y6f5pyJ5paH5Lu25pu05paw5pe255qE5ZCO5Y+w5aSE55CG5Zyw5Z2A77yM5b+F5aGrXHJcbiAgICAgICAgICB1cGRhdGVVcmw6ICcnLFxyXG4gICAgICAgICAgLy8g5b2T5a6i5oi356uv5Y6f5pyJ5paH5Lu25Yig6Zmk5pe255qE5ZCO5Y+w5aSE55CG5Zyw5Z2A77yM5b+F5aGrXHJcbiAgICAgICAgICByZW1vdmVVcmw6ICcnLFxyXG4gICAgICAgICAgLy8g5Yid5aeL5YyW5a6i5oi356uv5LiK5Lyg5paH5Lu277yM5LuO5ZCO5Y+w6I635Y+W5paH5Lu255qE5Zyw5Z2ALCDlj6/pgInvvIzlvZPmraTlj4LmlbDkuLrnqbrml7bvvIzpu5jorqTlt7LkuIrkvKDnmoTmlofku7bkuLrnqbpcclxuICAgICAgICAgIGluaXRVcmw6ICcnXHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfSxcclxuICBkYXRhICgpIHtcclxuICAgIHJldHVybiB7XHJcbiAgICAgIHZjaHJJbmZvOiB7fSxcclxuICAgICAgQ05vZGVJbWdlQ291bnQ6IDAsXHJcbiAgICAgIEFsbEltZ2VDb3VudDogMFxyXG4gICAgfVxyXG4gIH0sXHJcbiAgd2F0Y2g6IHtcclxuICAgIGN1cnJlbnROb2RlOiBmdW5jdGlvbiAobmV3dmFsLCBvbGR2YWwpIHtcclxuICAgICAgaWYgKG5ld3ZhbCA9PT0gJzAnKSB7XHJcbiAgICAgICAgdGhpcy50YWJDaGFuZ2UoJ2FsbFZpZXcnKVxyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIHRoaXMudGFiQ2hhbmdlKCdkZXRhaWxWaWV3JylcclxuICAgICAgfVxyXG4gICAgICB0aGlzLnNob3dJbWdsaXN0KG5ld3ZhbClcclxuICAgICAgdGhpcy51cGRhdGFJbWdDb3VudCgpXHJcbiAgICB9XHJcbiAgfSxcclxuICBtb3VudGVkOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAvLyByZXF1aXJlKCdAL2NvbXBvbmVudHMvd2VidXBsb2FkZXIvd2VidXBsb2FkZXItMC4xLjUvZXh0ZW5kLXdlYnVwbG9hZGVyLmpzJylcclxuICAgIC8vIOiOt+WPlnVybOS4iueahOWPguaVsFxyXG4gICAgdmFyIF90aGlzID0gdGhpc1xyXG4gICAgX3RoaXMuaW5pdFdlYlVwbG9hZGVyKClcclxuICAgIHdpbmRvdy5vbnJlc2l6ZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgX3RoaXMuc2hvd0ltZ2xpc3QoX3RoaXMuY3VycmVudE5vZGUpXHJcbiAgICB9XHJcbiAgfSxcclxuICBtZXRob2RzOiB7XHJcbiAgICBpbml0V2ViVXBsb2FkZXI6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgdmFyIF90aGlzID0gdGhpc1xyXG4gICAgICAvKiBlc2xpbnQtZGlzYWJsZSAqL1xyXG4gICAgICBpZiAoIXRoaXMudXBsb2FkcHJvcHMpIHtcclxuICAgICAgICBjb25zb2xlLmxvZyhcIuivt+mFjee9ruWlvV90aGlzLnVwbG9hZHByb3BzXCIpO1xyXG4gICAgICAgICQoXCIjZG5kQXJlYSBwXCIpLmh0bWwoXCLor7fphY3nva7lpb11cGxvYWRwcm9wc1wiKTtcclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgIH1cclxuICAgICAgaWYgKCF0aGlzLnVwbG9hZHByb3BzLmNvbmZpZyB8fCAhdGhpcy51cGxvYWRwcm9wcy5jb25maWcud3JhcElkKSB7XHJcbiAgICAgICAgY29uc29sZS5sb2coXCLor7fphY3nva7lpb11cGxvYWRwcm9wcy5jb25maWcud3JhcElkXCIpO1xyXG4gICAgICAgICQoXCIjZG5kQXJlYSBwXCIpLmh0bWwoXCLor7fphY3nva7lpb11cGxvYWRwcm9wcy5jb25maWcud3JhcElkXCIpO1xyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgfVxyXG4gICAgICBpZiAoIV90aGlzLnVwbG9hZHByb3BzLnVwbG9hZFVybCkge1xyXG4gICAgICAgIGNvbnNvbGUubG9nKFwi6K+36YWN572u5aW9X3RoaXMudXBsb2FkcHJvcHMudXBsb2FkVXJsXCIpO1xyXG4gICAgICAgICQoXCIjZG5kQXJlYSBwXCIpLmh0bWwoXCLor7fphY3nva7lpb11cGxvYWRwcm9wcy51cGxvYWRVcmxcIik7XHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICB9XHJcbiAgICAgIGlmICghX3RoaXMudXBsb2FkcHJvcHMudXBkYXRlVXJsKSB7XHJcbiAgICAgICAgY29uc29sZS5sb2coXCLor7fphY3nva7lpb1fdGhpcy51cGxvYWRwcm9wcy51cGRhdGVVcmxcIik7XHJcbiAgICAgICAgJChcIiNkbmRBcmVhIHBcIikuaHRtbChcIuivt+mFjee9ruWlvXVwbG9hZHByb3BzLnVwZGF0ZVVybFwiKTtcclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgIH1cclxuICAgICAgaWYgKCFfdGhpcy51cGxvYWRwcm9wcy5yZW1vdmVVcmwpIHtcclxuICAgICAgICBjb25zb2xlLmxvZyhcIuivt+mFjee9ruWlvV90aGlzLnVwbG9hZHByb3BzLnJlbW92ZVVybFwiKTtcclxuICAgICAgICAkKFwiI2RuZEFyZWEgcFwiKS5odG1sKFwi6K+36YWN572u5aW9dXBsb2FkcHJvcHMucmVtb3ZlVXJsXCIpO1xyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgfVxyXG4gICAgICB2YXIgZGlzWCA9IDA7XHJcbiAgICAgIHZhciBkaXNZID0gMDtcclxuICAgICAgdmFyIG1pblppbmRleCA9IDE7XHJcbiAgICAgIHZhciBvcmlnaW47XHJcbiAgICAgIHZhciBpc19tb3ZlaW5nID0gZmFsc2U7XHJcbiAgICAgIHZhciAkd3JhcCA9ICQoXCIjXCIgKyBfdGhpcy51cGxvYWRwcm9wcy5jb25maWcud3JhcElkKTtcclxuICAgICAgLyogdmFyICRxdWV1ZSA9ICQoJzx1bCBjbGFzcz1cImZpbGVsaXN0XCI+PC91bD4nKS5hcHBlbmRUbyhcclxuICAgICAgICAkd3JhcC5maW5kKFwiLnF1ZXVlTGlzdFwiKVxyXG4gICAgICApOyAqL1xyXG4gICAgICB2YXIgJHF1ZXVlID0gJChcIi5maWxlbGlzdFwiKTtcclxuICAgICAgdmFyICRzdGF0dXNCYXIgPSAkd3JhcC5maW5kKFwiLnN0YXR1c0JhclwiKTtcclxuICAgICAgdmFyICRpbmZvID0gJHN0YXR1c0Jhci5maW5kKFwiLmluZm9cIik7XHJcbiAgICAgIHZhciAkdXBsb2FkID0gJHdyYXAuZmluZChcIi51cGxvYWRCdG5cIik7XHJcbiAgICAgIHZhciAkcGxhY2VIb2xkZXIgPSAkd3JhcC5maW5kKFwiLnBsYWNlaG9sZGVyXCIpO1xyXG4gICAgICB2YXIgJHByb2dyZXNzID0gJHN0YXR1c0Jhci5maW5kKFwiLnByb2dyZXNzXCIpLmhpZGUoKTtcclxuICAgICAgdmFyIGZpbGVDb3VudCA9IDA7XHJcbiAgICAgIHZhciBmaWxlU2l6ZSA9IDA7XHJcbiAgICAgIHZhciBzdGF0ZSA9IFwicGVkZGluZ1wiO1xyXG4gICAgICB2YXIgcGVyY2VudGFnZXMgPSB7fTtcclxuICAgICAgdmFyIHN1cHBvcnRUcmFuc2l0aW9uID0gKGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIHZhciBzID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInBcIikuc3R5bGUsXHJcbiAgICAgICAgICByID1cclxuICAgICAgICAgICAgXCJ0cmFuc2l0aW9uXCIgaW4gcyB8fFxyXG4gICAgICAgICAgICBcIldlYmtpdFRyYW5zaXRpb25cIiBpbiBzIHx8XHJcbiAgICAgICAgICAgIFwiTW96VHJhbnNpdGlvblwiIGluIHMgfHxcclxuICAgICAgICAgICAgXCJtc1RyYW5zaXRpb25cIiBpbiBzIHx8XHJcbiAgICAgICAgICAgIFwiT1RyYW5zaXRpb25cIiBpbiBzO1xyXG4gICAgICAgIHMgPSBudWxsO1xyXG4gICAgICAgIC8vcmV0dXJuIHI7ICAvL+aaguaXtuWFiOWGmeatuyAg5Lul5ZCO6YGH5Yiw6Zeu6aKY5YaN6LCD6K+VIHdxZFxyXG4gICAgICAgIHJldHVybiB0cnVlXHJcbiAgICAgIH0pKCk7XHJcbiAgICAgIC8vIOS8mOWMlnJldGluYSwg5ZyocmV0aW5h5LiL6L+Z5Liq5YC85pivMlxyXG4gICAgICB2YXIgcmF0aW8gPSB3aW5kb3cuZGV2aWNlUGl4ZWxSYXRpbyB8fCAxO1xyXG4gICAgICAvLyDnvKnnlaXlm77lpKflsI9cclxuICAgICAgdmFyIHRodW1ibmFpbFdpZHRoID0gX3RoaXMudXBsb2FkcHJvcHMuY29uZmlnLnRodW1iV2lkdGggfHwgMTEwO1xyXG4gICAgICB0aHVtYm5haWxXaWR0aCAqPSByYXRpbztcclxuICAgICAgdmFyIHRodW1ibmFpbEhlaWdodCA9IF90aGlzLnVwbG9hZHByb3BzLmNvbmZpZy50aHVtYkhlaWdodCB8fCAxMTA7XHJcbiAgICAgIHRodW1ibmFpbEhlaWdodCAqPSByYXRpbztcclxuICAgICAgdmFyIHVwbG9hZGVyID0gV2ViVXBsb2FkZXIuY3JlYXRlKHtcclxuICAgICAgICBzd2Y6IFwiaHR0cDovL2Nkbi5zdGF0aWNmaWxlLm9yZy93ZWJ1cGxvYWRlci8wLjEuMC9VcGxvYWRlci5zd2ZcIiwgLy9yZXF1aXJlKCdAL2NvbXBvbmVudHMvd2VidXBsb2FkZXIvd2VidXBsb2FkZXItMC4xLjUvVXBsb2FkZXIuc3dmJylcclxuICAgICAgICBzZXJ2ZXI6IF90aGlzLnVwbG9hZHByb3BzLnVwbG9hZFVybCxcclxuICAgICAgICBwaWNrOiB7XHJcbiAgICAgICAgICBpZDogXCIjZmlsZVBpY2tlclwiLFxyXG4gICAgICAgICAgbGFiZWw6IFwi54K55Ye76YCJ5oup5Zu+54mHXCJcclxuICAgICAgICB9LFxyXG4gICAgICAgIGRuZDogXCIucXVldWVMaXN0XCIsXHJcbiAgICAgICAgcGFzdGU6IGRvY3VtZW50LmJvZHksXHJcbiAgICAgICAgYWNjZXB0OiB7XHJcbiAgICAgICAgICB0aXRsZTogXCJJbWFnZXNcIixcclxuICAgICAgICAgIGV4dGVuc2lvbnM6IF90aGlzLnVwbG9hZHByb3BzLmNvbmZpZy5maWxlZm9ybWF0LFxyXG4gICAgICAgICAgbWltZVR5cGVzOiBcIipcIlxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgcmVzaXplOiBmYWxzZSxcclxuICAgICAgICBkaXNhYmxlR2xvYmFsRG5kOiB0cnVlLFxyXG4gICAgICAgIGNodW5rZWQ6IHRydWUsXHJcbiAgICAgICAgZmlsZU51bUxpbWl0OiA5OTk5XHJcbiAgICAgIH0pO1xyXG5cclxuICAgICAgZnVuY3Rpb24gc2V0RHJhZ0V2ZW50KCkge1xyXG4gICAgICAgICQodGhpcykub24oXCJkcm9wXCIsIGZ1bmN0aW9uKGUpIHtcclxuICAgICAgICAgIHZhciAkZnJvbSA9ICQob3JpZ2luKS5wYXJlbnRzKFwibGlcIik7XHJcbiAgICAgICAgICB2YXIgJHRvID0gJChlLnRhcmdldCkucGFyZW50cyhcImxpXCIpO1xyXG4gICAgICAgICAgdmFyIG9yaWdpbl9wb3MgPSAkZnJvbS5wb3NpdGlvbigpO1xyXG4gICAgICAgICAgdmFyIHRhcmdldF9wb3MgPSAkdG8ucG9zaXRpb24oKTtcclxuICAgICAgICAgIHZhciBmcm9tX3NvcnQgPSAkZnJvbS5hdHRyKFwiZGF0YS1zb3J0XCIpO1xyXG4gICAgICAgICAgdmFyIHRvX3NvcnQgPSAkdG8uYXR0cihcImRhdGEtc29ydFwiKTtcclxuXHJcbiAgICAgICAgICAkZnJvbS5hZGRDbGFzcyhcIm1vdmVcIikuYW5pbWF0ZSh0YXJnZXRfcG9zLCBcImZhc3RcIiwgZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgICQodGhpcykucmVtb3ZlQ2xhc3MoXCJtb3ZlXCIpO1xyXG4gICAgICAgICAgfSkuYXR0cihcImRhdGEtc29ydFwiLCB0b19zb3J0KTtcclxuXHJcbiAgICAgICAgICAkdG8uYWRkQ2xhc3MoXCJtb3ZlXCIpLmFuaW1hdGUob3JpZ2luX3BvcywgXCJmYXN0XCIsIGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICAkKHRoaXMpLnJlbW92ZUNsYXNzKFwibW92ZVwiKTtcclxuICAgICAgICAgIH0pLmF0dHIoXCJkYXRhLXNvcnRcIiwgZnJvbV9zb3J0KTtcclxuICAgICAgICB9KVxyXG4gICAgICAgICAgLm9uKFwiZHJhZ3N0YXJ0XCIsIGZ1bmN0aW9uKGUpIHtcclxuICAgICAgICAgICAgaWYgKGlzX21vdmVpbmcpIHtcclxuICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaXNfbW92ZWluZyA9IHRydWU7XHJcbiAgICAgICAgICAgIGUub3JpZ2luYWxFdmVudC5kYXRhVHJhbnNmZXIuZWZmZWN0QWxsb3dkID0gXCJtb3ZlXCI7XHJcbiAgICAgICAgICAgIG9yaWdpbiA9IHRoaXM7XHJcbiAgICAgICAgICB9KVxyXG4gICAgICAgICAgLm9uKFwiZHJhZ292ZXJcIiwgZnVuY3Rpb24oZSkge1xyXG4gICAgICAgICAgICBpZiAoZS5wcmV2ZW50RGVmYXVsdCkgZS5wcmV2ZW50RGVmYXVsdCgpO1xyXG4gICAgICAgICAgICBpc19tb3ZlaW5nID0gZmFsc2U7XHJcbiAgICAgICAgICAgIGUub3JpZ2luYWxFdmVudC5kYXRhVHJhbnNmZXIuZHJvcEVmZmVjdCA9IFwibW92ZVwiO1xyXG4gICAgICAgICAgfSk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIC8v5pu05paw5pyN5Yqh56uv6ZmE5Lu2XHJcbiAgICAgIGZ1bmN0aW9uIHVwZGF0ZVNlcnZlckZpbGVzKCkge1xyXG4gICAgICAgIHZhciBwb3N0RGF0YSA9IHt9O1xyXG4gICAgICAgICQoJ1tkYXRhLXNyYz1cInNlcnZlclwiXScpLmVhY2goZnVuY3Rpb24oaW5kZXgsIG9iaikge1xyXG4gICAgICAgICAgcG9zdERhdGFbJChvYmopLmF0dHIoXCJkYXRhLWtleVwiKV0gPSAkKG9iaikuYXR0cihcImRhdGEtc29ydFwiKTtcclxuICAgICAgICB9KTtcclxuICAgICAgICAkLmFqYXgoe1xyXG4gICAgICAgICAgdHlwZTogXCJwb3N0XCIsXHJcbiAgICAgICAgICB1cmw6IF90aGlzLnVwbG9hZHByb3BzLnVwZGF0ZVVybCxcclxuICAgICAgICAgIGRhdGE6IHBvc3REYXRhLFxyXG4gICAgICAgICAgZGF0YVR5cGU6IFwianNvblwiLFxyXG4gICAgICAgICAgc3VjY2VzczogZnVuY3Rpb24oZGF0YSkge1xyXG4gICAgICAgICAgICAvL3NldFN0YXRlKCdmaW5pc2gnKTtcclxuICAgICAgICAgICAgYWxlcnQoXCLmm7TmlrDmiJDlip9cIik7XHJcbiAgICAgICAgICAgICR1cGxvYWQucmVtb3ZlQ2xhc3MoXCJkaXNhYmxlZFwiKTtcclxuICAgICAgICAgICAgc2V0U3RhdGUoXCJyZWFkeVwiKTtcclxuICAgICAgICAgICAgdXBsb2FkZXIucmVzZXQoKTtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgICAgfVxyXG5cclxuICAgICAgLy/liKDpmaTmnI3liqHnq6/pmYTku7ZcclxuICAgICAgZnVuY3Rpb24gcmVtb3ZlU2VydmVyRmlsZShmaWxlLGRhdGEsYSxiKSB7XHJcbiAgICAgICAgdmFyIHNlbmREYXRhID0ge1xyXG4gICAgICAgICAgJ3NlcnZpY2UnOiAnSW1nQ29tbW9uU2VydmljZScsXHJcbiAgICAgICAgICAnbWV0aG9kJzogJ2RlbGV0ZUltYWdlJyxcclxuICAgICAgICAgICdGX0lNR19JTkZPUyc6IFtcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICdGX1BLRVknOiBmaWxlLkZfUEtFWSxcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgXVxyXG4gICAgICAgIH1cclxuICAgICAgICAkLmFqYXgoe1xyXG4gICAgICAgICAgdXJsOiBwcm9jZXNzLmVudi5CQVNFX0FQSSArICcvY29tbUFjdGlvbi5kbycsXHJcbiAgICAgICAgICB0eXBlOiAnUE9TVCcsXHJcbiAgICAgICAgICBkYXRhOiB7IGpzb25kYXRhOiBKU09OLnN0cmluZ2lmeShzZW5kRGF0YSkgfSxcclxuICAgICAgICAgIGRhdGFUeXBlOiAnanNvbicsXHJcbiAgICAgICAgICBhc3luYzogZmFsc2UsXHJcbiAgICAgICAgICBzdWNjZXNzOiBmdW5jdGlvbihkYXRhKSB7XHJcbiAgICAgICAgICAgIGlmIChkYXRhLkZfQ09ERSA9PT0gJzAnKSB7XHJcbiAgICAgICAgICAgICAgZmlsZUNvdW50LS07XHJcbiAgICAgICAgICAgICAgdXBkYXRlU3RhdHVzKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdmFyIHRleHQgPSBkYXRhLkZfTUVTU0FHRVxyXG4gICAgICAgICAgICBfdGhpcy4kaW5mbyh7XHJcbiAgICAgICAgICAgICAgdGl0bGU6ICfmj5DnpLonLFxyXG4gICAgICAgICAgICAgIG9rVGV4dDogJ+ehruiupCcsXHJcbiAgICAgICAgICAgICAgY29udGVudDogdGV4dFxyXG4gICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICAvLyBfdGhpcy4kcm91dGVyLmdvKDApIC8vIOWIt+aWsOW9k+WJjemhtemdolxyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH0pXHJcbiAgICAgICAgLyogJC5hamF4KHtcclxuICAgICAgICAgIHR5cGU6IFwiZ2V0XCIsXHJcbiAgICAgICAgICB1cmw6IF90aGlzLnVwbG9hZHByb3BzLnJlbW92ZVVybCxcclxuICAgICAgICAgIGRhdGE6IHsgaWQ6IGZpbGUubmFtZSB9LFxyXG4gICAgICAgICAgZGF0YVR5cGU6IFwianNvblwiLFxyXG4gICAgICAgICAgc3VjY2VzczogZnVuY3Rpb24oZGF0YSkge1xyXG4gICAgICAgICAgICBmaWxlQ291bnQtLTtcclxuICAgICAgICAgICAgdXBkYXRlU3RhdHVzKCk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfSk7ICovXHJcbiAgICAgIH1cclxuXHJcbiAgICAgIC8v5Yid5aeL5YyW5pyN5Yqh56uv6ZmE5Lu2XHJcbiAgICAgIGZ1bmN0aW9uIGluaXRTZXJ2ZXJGaWxlKCkge1xyXG4gICAgICAgIGlmIChfdGhpcy51cGxvYWRwcm9wcy5pbml0VXJsKSB7XHJcbiAgICAgICAgICAkLmVhY2goX3RoaXMuaW5pdGZpbGVzLGZ1bmN0aW9uKGssZmwpe1xyXG4gICAgICAgICAgICAkLmVhY2goZmwuRl9BVFRBQ0hTLGZ1bmN0aW9uKGluZGV4LGZpbGUpe1xyXG4gICAgICAgICAgICAgIGZpbGUuRl9GSUxFX1RQID0gZmlsZS5GX0ZJTEVfVFAudG9Mb3dlckNhc2UoKVxyXG4gICAgICAgICAgICAgIHZhciBzcmMgPSBcIlwiLy/lm77niYflnLDlnYBcclxuICAgICAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAgICAgc3JjID0gJC5pbkFycmF5KGZpbGUuRl9GSUxFX1RQLCBVdGlsLmltZ1N1ZmZpeCkgIT09IC0xP1V0aWwuY3JlYXRlSW1nVXJsKGZpbGUuRl9BVFRfU1RPX0tFWSk6cmVxdWlyZSgnQC9hc3NldHMvaW1hZ2V2aWV3L3N1ZmZpeC8nICsgZmlsZS5GX0ZJTEVfVFAgKyAnLnBuZycpXHJcbiAgICAgICAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgICAgICAgICAgIHNyYyA9ICQuaW5BcnJheShmaWxlLkZfRklMRV9UUCwgVXRpbC5pbWdTdWZmaXgpICE9PSAtMT9VdGlsLmNyZWF0ZUltZ1VybChmaWxlLkZfQVRUX1NUT19LRVkpOnJlcXVpcmUoJ0AvYXNzZXRzL2ltYWdldmlldy9zdWZmaXgvb3RoZXIucG5nJylcclxuICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgdmFyIG9iaiAgPSB7XHJcbiAgICAgICAgICAgICAgICBpZDpcIlNWUl9GSUxFX1wiICsgaW5kZXgsXHJcbiAgICAgICAgICAgICAgICBzcmM6J3NlcnZlcicsXHJcbiAgICAgICAgICAgICAgICBuYW1lOmZpbGUuRl9BVFRfVElUTEUsXHJcbiAgICAgICAgICAgICAgICBwYXRoIDogc3JjLFxyXG4gICAgICAgICAgICAgICAgcm90YXRpb246MCxcclxuICAgICAgICAgICAgICAgIHNpemU6cGFyc2VGbG9hdChmaWxlLkZfQVRUX1NJWkUpLFxyXG4gICAgICAgICAgICAgICAgdHlwZTpmaWxlLkZfRklMRV9UUCxcclxuICAgICAgICAgICAgICAgIEZfRklMRV9UUDpmaWxlLkZfRklMRV9UUCxcclxuICAgICAgICAgICAgICAgIEZfUEtFWTpmaWxlLkZfUEtFWSxcclxuICAgICAgICAgICAgICAgIEZfUEFSRU5UOmZpbGUuRl9QQVJFTlQsXHJcbiAgICAgICAgICAgICAgICBGX0lNR19DT0RFOmZsLkZfSU1HX0NPREUsXHJcbiAgICAgICAgICAgICAgICBGX1JPVEFURTpmbC5GX1JPVEFURS8v5peL6L2s5bqm5pWwXHJcbiAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgIGZpbGVRdWV1ZShvYmopO1xyXG4gICAgICAgICAgICB9KVxyXG4gICAgICAgICAgfSlcclxuICAgICAgICAgIF90aGlzLnNob3dJbWdsaXN0KF90aGlzLmN1cnJlbnROb2RlKVxyXG4gICAgICAgICAgLyogdmFyIGxlbiA9IGRhdGEubGVuZ3RoO1xyXG4gICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcclxuICAgICAgICAgICAgICAgIGRhdGFbaV0uc3JjID0gXCJzZXJ2ZXJcIjtcclxuICAgICAgICAgICAgICAgIGRhdGFbaV0uaWQgPSBcIlNWUl9GSUxFX1wiICsgaTtcclxuICAgICAgICAgICAgICAgIGRhdGFbaV0ucm90YXRpb24gPSAwO1xyXG4gICAgICAgICAgICAgICAgZmlsZVF1ZXVlKGRhdGFbaV0pO1xyXG4gICAgICAgICAgICAgIH0gKi9cclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIC8v5re75Yqg6ZmE5Lu25Yiwd2VidXBsb2FkZXLkuK1cclxuICAgICAgZnVuY3Rpb24gYWRkRmlsZShmaWxlKSB7XHJcbiAgICAgICAgdmFyIGRhdGF0eXBlID0gX3RoaXMuY3VycmVudE5vZGVcclxuICAgICAgICBmaWxlLkZfUk9UQVRFID0gZmlsZS5GX1JPVEFURXx8MFxyXG4gICAgICAgIGlmKGZpbGUuc3JjID09PSAnc2VydmVyJyl7XHJcbiAgICAgICAgICBkYXRhdHlwZSA9IGZpbGUuRl9QQVJFTlRcclxuICAgICAgICB9ZWxzZXtcclxuICAgICAgICAgIGZpbGUuRl9JTUdfVFlQRSA9IGRhdGF0eXBlXHJcbiAgICAgICAgfVxyXG4gICAgICAgICQuZWFjaChfdGhpcy5pbml0ZmlsZXMsZnVuY3Rpb24oayx2KXtcclxuICAgICAgICAgIGlmKHYua2V5ID09PSBkYXRhdHlwZSl7XHJcbiAgICAgICAgICAgIGZpbGUuRl9JTUdfQ09ERSA9IHYuRl9JTUdfQ09ERVxyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH0pXHJcbiAgICAgICAgdmFyIGluZGV4ID0gJHF1ZXVlLmZpbmQoXCJsaVtkYXRhLXR5cGU9J1wiICsgZGF0YXR5cGUgKyBcIiddXCIpLmxlbmd0aDtcclxuICAgICAgICAvKiB2YXIgaW1nTGVmdCA9IGluZGV4ICogKHRodW1ibmFpbFdpZHRoICsgMTApO1xyXG4gICAgICAgIHZhciBpbWdUb3AgPSAwO1xyXG4gICAgICAgIHZhciB3cmFwSGVpZ2h0ID0gdGh1bWJuYWlsSGVpZ2h0ICsgMjA7XHJcbiAgICAgICAgdmFyIHdyYXBXaWR0aCA9ICRxdWV1ZS53aWR0aCgpO1xyXG4gICAgICAgIGlmIChpbWdMZWZ0ICsgKHRodW1ibmFpbFdpZHRoICsgMTApID49IHdyYXBXaWR0aCkge1xyXG4gICAgICAgICAgaW1nVG9wID1cclxuICAgICAgICAgICAgcGFyc2VJbnQoKGltZ0xlZnQgKyAodGh1bWJuYWlsV2lkdGggKyAxMCkpIC8gd3JhcFdpZHRoKSAqXHJcbiAgICAgICAgICAgICh0aHVtYm5haWxIZWlnaHQgKyAxMCk7XHJcbiAgICAgICAgICB3cmFwSGVpZ2h0ID0gaW1nVG9wICsgd3JhcEhlaWdodDtcclxuICAgICAgICAgIGltZ0xlZnQgPVxyXG4gICAgICAgICAgICAoaW5kZXggJSBwYXJzZUludCh3cmFwV2lkdGggLyAodGh1bWJuYWlsV2lkdGggKyAxMCkpKSAqXHJcbiAgICAgICAgICAgICh0aHVtYm5haWxXaWR0aCArIDEwKTtcclxuICAgICAgICB9ICovXHJcblxyXG4gICAgICAgICQoXCIudmNocmltYWdlIC5taWRkbGVcIikuY3NzKFwib3ZlcmZsb3cteVwiLFwiaGlkZGVuXCIpXHJcbiAgICAgICAgJChcIi52Y2hyaW1hZ2UgLmNhdGVnb3J5LXZpZXdcIikuY3NzKFwib3ZlcmZsb3cteVwiLFwiaGlkZGVuXCIpXHJcbiAgICAgICAgdmFyIGxpSGVpZ2h0ID0gdGh1bWJuYWlsSGVpZ2h0KzI1O1xyXG4gICAgICAgIHZhciB3cmFwV2lkdGggPSAkcXVldWUud2lkdGgoKTtcclxuICAgICAgICB2YXIgd3JhcEhlaWdodCA9IGxpSGVpZ2h0ICsgMjA7XHJcbiAgICAgICAgdmFyIGltZ051bSA9IHBhcnNlSW50KHdyYXBXaWR0aCAvICh0aHVtYm5haWxXaWR0aCArIDEwKSkgLy8g5q+P6KGM5pyJ5Yeg5byg5Zu+54mHXHJcbiAgICAgICAgdmFyIGltZ1RvcCA9IDBcclxuICAgICAgICB2YXIgaW1nTGVmdCA9IGluZGV4ICogKHRodW1ibmFpbFdpZHRoICsgMTApXHJcbiAgICAgICAgaWYgKGluZGV4ICsgMSA+IGltZ051bSkge1xyXG4gICAgICAgICAgaW1nVG9wID0gcGFyc2VJbnQoaW5kZXggLyBpbWdOdW0pICogKGxpSGVpZ2h0KzEwKVxyXG4gICAgICAgICAgaW1nTGVmdCA9IChpbmRleCAlIGltZ051bSkgKiAodGh1bWJuYWlsV2lkdGggKyAxMClcclxuICAgICAgICAgIHdyYXBIZWlnaHQgPSBpbWdUb3AgKyBsaUhlaWdodCArIDEwXHJcbiAgICAgICAgfVxyXG5cclxuXHJcbiAgICAgICAgJHF1ZXVlLmhlaWdodCh3cmFwSGVpZ2h0KTtcclxuICAgICAgICB2YXIgJGxpID0gJChcclxuICAgICAgICAgICAgJzxsaSBkYXRhLWtleT1cIicgK1xyXG4gICAgICAgICAgICAgIGZpbGUua2V5ICtcclxuICAgICAgICAgICAgICAnXCIgIGRhdGEtc3JjPVwiJyArXHJcbiAgICAgICAgICAgICAgZmlsZS5zcmMgK1xyXG4gICAgICAgICAgICAgICdcIiBkYXRhLXNvcnQ9XCInICtcclxuICAgICAgICAgICAgICBpbmRleCArXHJcbiAgICAgICAgICAgICAgICdcIiBkYXRhLWRlZz1cIicgK1xyXG4gICAgICAgICAgICAgIGZpbGUuRl9ST1RBVEUgK1xyXG4gICAgICAgICAgICAgICdcIiBkYXRhLXR5cGU9XCInICtcclxuICAgICAgICAgICAgICBkYXRhdHlwZSArXHJcbiAgICAgICAgICAgICAgJ1wiIGRyYWdnYWJsZT1cInRydWVcIiBpZD1cIicgK1xyXG4gICAgICAgICAgICAgIGZpbGUuaWQgK1xyXG4gICAgICAgICAgICAgICdcIiBzdHlsZT1cInBvc2l0aW9uOmFic29sdXRlO21hcmdpbjowO2N1cnNvcjptb3ZlO3dpZHRoOicgK1xyXG4gICAgICAgICAgICAgIHRodW1ibmFpbFdpZHRoICtcclxuICAgICAgICAgICAgICBcInB4O2hlaWdodDpcIiArXHJcbiAgICAgICAgICAgICAgbGlIZWlnaHQgK1xyXG4gICAgICAgICAgICAgIFwicHg7bGVmdDpcIiArXHJcbiAgICAgICAgICAgICAgaW1nTGVmdCArXHJcbiAgICAgICAgICAgICAgXCJweDt0b3A6XCIgK1xyXG4gICAgICAgICAgICAgIGltZ1RvcCArXHJcbiAgICAgICAgICAgICAgJ3B4XCI+JyArXHJcbiAgICAgICAgICAgICAgJzxwIGNsYXNzPVwiaW1nV3JhcFwiPjwvcD4nICtcclxuICAgICAgICAgICAgICAnPHAgY2xhc3M9XCJ0aXRsZVwiPicgK1xyXG4gICAgICAgICAgICAgIGZpbGUubmFtZSArXHJcbiAgICAgICAgICAgICAgXCI8L3A+XCIgK1xyXG4gICAgICAgICAgICAgICc8cCBjbGFzcz1cInByb2dyZXNzXCI+PHNwYW4+PC9zcGFuPjwvcD4nICtcclxuICAgICAgICAgICAgICBcIjwvbGk+XCJcclxuICAgICAgICAgICksXHJcbiAgICAgICAgICAkYnRucyA9ICQoXHJcbiAgICAgICAgICAgICc8ZGl2IGNsYXNzPVwiZmlsZS1wYW5lbFwiPicgKyAnPHNwYW4gY2xhc3M9XCJjYW5jZWxcIj7liKDpmaQ8L3NwYW4+JytcclxuICAgICAgICAgICAgJzxzcGFuIGNsYXNzPVwicm90YXRlUmlnaHRcIj7lkJHlj7Pml4vovaw8L3NwYW4+JyArXHJcbiAgICAgICAgICAgICc8c3BhbiBjbGFzcz1cInJvdGF0ZUxlZnRcIj7lkJHlt6bml4vovaw8L3NwYW4+PC9kaXY+J1xyXG4gICAgICAgICAgKS5hcHBlbmRUbygkbGkpLFxyXG4gICAgICAgICAgJHByb2dlc3MgPSAkbGkuZmluZChcInAucHJvZ3Jlc3Mgc3BhblwiKSxcclxuICAgICAgICAgICR3cmFwID0gJGxpLmZpbmQoXCJwLmltZ1dyYXBcIiksXHJcbiAgICAgICAgICAkaW5mbyA9ICQoJzxwIGNsYXNzPVwiZXJyb3JcIj48L3A+JyksXHJcbiAgICAgICAgICBzaG93RXJyb3IgPSBmdW5jdGlvbihjb2RlKSB7XHJcbiAgICAgICAgICAgIHZhciB0ZXh0ID0gXCJcIlxyXG4gICAgICAgICAgICBzd2l0Y2ggKGNvZGUpIHtcclxuICAgICAgICAgICAgICBjYXNlIFwiZXhjZWVkX3NpemVcIjpcclxuICAgICAgICAgICAgICAgIHRleHQgPSBcIuaWh+acrOWkp+Wwj+i2heWHulwiO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgY2FzZSBcImludGVycnVwdFwiOlxyXG4gICAgICAgICAgICAgICAgdGV4dCA9IFwi5LiK5Lyg5pqC5YGcXCI7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgICAgICAgdGV4dCA9IFwi5LiK5Lyg5aSx6LSlXCI7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAkaW5mby50ZXh0KHRleHQpLmFwcGVuZFRvKCRsaSk7XHJcbiAgICAgICAgICB9O1xyXG4gICAgICAgICAgaWYgKHN1cHBvcnRUcmFuc2l0aW9uKSB7XHJcbiAgICAgICAgICAgIHZhciBkZWdzID0gXCJyb3RhdGUoXCIgKyBmaWxlLnJvdGF0aW9ufHwwICsgXCJkZWcpXCI7XHJcbiAgICAgICAgICAgICAgJHdyYXAuY3NzKHtcclxuICAgICAgICAgICAgICAgIFwiLXdlYmtpdC10cmFuc2Zvcm1cIjogZGVncyxcclxuICAgICAgICAgICAgICAgIFwiLW1vcy10cmFuc2Zvcm1cIjogZGVncyxcclxuICAgICAgICAgICAgICAgIFwiLW8tdHJhbnNmb3JtXCI6IGRlZ3MsXHJcbiAgICAgICAgICAgICAgICB0cmFuc2Zvcm06IGRlZ3NcclxuICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgIC8v5Zu+54mH54K55Ye75LqL5Lu2XHJcbiAgICAgICAgICAkbGkub24oXCJjbGlja1wiLGZ1bmN0aW9uKCl7XHJcbiAgICAgICAgICAgIHZhciBmaWxlID0gJCh0aGlzKS5kYXRhKFwiZmlsZWluZm9cIilcclxuICAgICAgICAgICAgX3RoaXMuJGVtaXQoXCJpbWFnZUNsaWNrXCIsZmlsZSlcclxuICAgICAgICAgIH0pXHJcbiAgICAgICAgICBpZiAoZmlsZS5zcmMgPT0gXCJjbGllbnRcIikge1xyXG4gICAgICAgICAgICBpZiAoZmlsZS5nZXRTdGF0dXMoKSA9PSBcImludmFsaWRcIikge1xyXG4gICAgICAgICAgICAgIHNob3dFcnJvcihmaWxlLnN0YXR1c1RleHQpO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICR3cmFwLnRleHQoXCLpooTop4jkuK1cIik7XHJcbiAgICAgICAgICAgICAgdXBsb2FkZXIubWFrZVRodW1iKFxyXG4gICAgICAgICAgICAgICAgZmlsZSxcclxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uKGVycm9yLCBzcmMpIHtcclxuICAgICAgICAgICAgICAgICAgaWYgKGVycm9yKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLyogJHdyYXAudGV4dChcIuS4jeiDvemihOiniFwiKTtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm47ICovXHJcbiAgICAgICAgICAgICAgICAgICAgZmlsZS5GX0ZJTEVfVFAgPSBmaWxlLmV4dC50b0xvd2VyQ2FzZSgpXHJcbiAgICAgICAgICAgICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgICAgICAgICAgIHNyYyA9ICQuaW5BcnJheShmaWxlLkZfRklMRV9UUCwgVXRpbC5pbWdTdWZmaXgpICE9PSAtMT9VdGlsLmNyZWF0ZUltZ1VybChmaWxlLkZfQVRUX1NUT19LRVkpOnJlcXVpcmUoJ0AvYXNzZXRzL2ltYWdldmlldy9zdWZmaXgvJyArIGZpbGUuZXh0ICsgJy5wbmcnKVxyXG4gICAgICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICBzcmMgPSAkLmluQXJyYXkoZmlsZS5GX0ZJTEVfVFAsIFV0aWwuaW1nU3VmZml4KSAhPT0gLTE/VXRpbC5jcmVhdGVJbWdVcmwoZmlsZS5GX0FUVF9TVE9fS0VZKTpyZXF1aXJlKCdAL2Fzc2V0cy9pbWFnZXZpZXcvc3VmZml4L290aGVyLnBuZycpXHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgIGZpbGUucGF0aCA9IHNyYztcclxuICAgICAgICAgICAgICAgICAgdmFyIGltZyA9ICQoJzxpbWcgZHJhZ2dhYmxlPVwidHJ1ZVwiIHN0eWxlPVwid2lkdGg6Jyt0aHVtYm5haWxXaWR0aCsncHg7aGVpZ2h0OicrdGh1bWJuYWlsSGVpZ2h0KydweFwiIHNyYz1cIicgKyBzcmMgKyAnXCI+Jyk7XHJcbiAgICAgICAgICAgICAgICAgIGltZy5iaW5kKFwibG9hZFwiLCBzZXREcmFnRXZlbnQpO1xyXG4gICAgICAgICAgICAgICAgICAkd3JhcC5lbXB0eSgpLmFwcGVuZChpbWcpO1xyXG4gICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgIDAuOCxcclxuICAgICAgICAgICAgICAgIDAuOFxyXG4gICAgICAgICAgICAgICAgLyogdGh1bWJuYWlsV2lkdGgsXHJcbiAgICAgICAgICAgICAgICB0aHVtYm5haWxIZWlnaHQgKi9cclxuICAgICAgICAgICAgICApO1xyXG4gICAgICAgICAgICAgIHBlcmNlbnRhZ2VzW2ZpbGUuaWRdID0gW2ZpbGVTaXplLCAwXTtcclxuICAgICAgICAgICAgICBmaWxlLnJvdGF0aW9uID0gMDtcclxuICAgICAgICAgIH1cclxuICAgICAgICAgIGZpbGUub24oXCJzdGF0dXNjaGFuZ2VcIiwgZnVuY3Rpb24oY3VyLCBwcmV2KSB7XHJcbiAgICAgICAgICAgIGlmIChwcmV2ID09IFwicHJvZ3Jlc3NcIikge1xyXG4gICAgICAgICAgICAgICRwcm9ncmVzcy5oaWRlKCkud2lkdGgoMCk7XHJcbiAgICAgICAgICAgIH0gZWxzZSBpZiAocHJldiA9PSBcInF1ZXVlZFwiKSB7XHJcbiAgICAgICAgICAgICAgLy93cWQgMjAxOTA1MDfms6jph4ogIOS4iuS8oOaIkOWKn+WQjui/mOWFgeiuuOWIoOmZpFxyXG4gICAgICAgICAgICAgIC8vJGxpLm9mZignbW91c2VlbnRlciBtb3VzZWxlYXZlJyk7XHJcbiAgICAgICAgICAgICAgLy8kYnRucy5yZW1vdmUoKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgaWYgKGN1ciA9PSBcImVycm9yXCIgfHwgY3VyID09IFwiaW52YWxpZFwiKSB7XHJcbiAgICAgICAgICAgICAgc2hvd0Vycm9yKGZpbGUuc3RhdHVzVGV4dCk7XHJcbiAgICAgICAgICAgICAgcGVyY2VudGFnZXNbZmlsZS5pZF1bMV0gPSAxO1xyXG4gICAgICAgICAgICB9IGVsc2UgaWYgKGN1ciA9PSBcImludGVycnVwdFwiKSB7XHJcbiAgICAgICAgICAgICAgc2hvd0Vycm9yKFwiaW50ZXJydXB0XCIpO1xyXG4gICAgICAgICAgICB9IGVsc2UgaWYgKGN1ciA9PSBcInF1ZXVlZFwiKSB7XHJcbiAgICAgICAgICAgICAgcGVyY2VudGFnZXNbZmlsZS5pZF1bMV0gPSAwO1xyXG4gICAgICAgICAgICB9IGVsc2UgaWYgKGN1ciA9PSBcInByb2dyZXNzXCIpIHtcclxuICAgICAgICAgICAgICAkaW5mby5yZW1vdmUoKTtcclxuICAgICAgICAgICAgICAkcHJvZ3Jlc3MuY3NzKFwiZGlzcGxheVwiLCBcImJsb2NrXCIpO1xyXG4gICAgICAgICAgICB9IGVsc2UgaWYgKGN1ciA9PSBcImNvbXBsZXRlXCIpIHtcclxuICAgICAgICAgICAgICAkbGkuYXBwZW5kKCc8c3BhbiBjbGFzcz1cInN1Y2Nlc3NcIj48L3NwYW4+Jyk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICRsaS5yZW1vdmVDbGFzcyhcInN0YXRlLVwiICsgcHJldikuYWRkQ2xhc3MoXCJzdGF0ZS1cIiArIGN1cik7XHJcbiAgICAgICAgICAgIHVwZGF0ZVN0YXR1cygpO1xyXG4gICAgICAgICAgfSk7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIHZhciBpbWcgPSAkKCc8aW1nIGRyYWdnYWJsZT1cInRydWVcIiBzdHlsZT1cIndpZHRoOicrdGh1bWJuYWlsV2lkdGgrJ3B4O2hlaWdodDonK3RodW1ibmFpbEhlaWdodCsncHhcIiBzcmM9XCInICsgZmlsZS5wYXRoICsgJ1wiPicpO1xyXG4gICAgICAgICAgaW1nLmJpbmQoXCJsb2FkXCIsIHNldERyYWdFdmVudCk7XHJcbiAgICAgICAgICAkd3JhcC5lbXB0eSgpLmFwcGVuZChpbWcpO1xyXG4gICAgICAgICAgJGxpLmFwcGVuZCgnPHNwYW4gY2xhc3M9XCJzdWNjZXNzXCI+PC9zcGFuPicpO1xyXG4gICAgICAgICAgICQoXCIudmNocmltYWdlIC5taWRkbGVcIikuY3NzKFwib3ZlcmZsb3cteVwiLFwiYXV0b1wiKVxyXG4gICAgICAgICAgJChcIi52Y2hyaW1hZ2UgLmNhdGVnb3J5LXZpZXdcIikuY3NzKFwib3ZlcmZsb3cteVwiLFwiYXV0b1wiKVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgJGxpLm9uKFwibW91c2VlbnRlclwiLCBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICRidG5zLnN0b3AoKS5hbmltYXRlKHsgaGVpZ2h0OiAzMCB9KTtcclxuICAgICAgICB9KTtcclxuICAgICAgICAkbGkub24oXCJtb3VzZWxlYXZlXCIsIGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgJGJ0bnMuc3RvcCgpLmFuaW1hdGUoeyBoZWlnaHQ6IDAgfSk7XHJcbiAgICAgICAgfSk7XHJcblxyXG4gICAgICAgICRidG5zLm9uKFwiY2xpY2tcIiwgXCJzcGFuXCIsIGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgdmFyIGluZGV4ID0gJCh0aGlzKS5pbmRleCgpLFxyXG4gICAgICAgICAgICBkZWc7XHJcblxyXG4gICAgICAgICAgc3dpdGNoIChpbmRleCkge1xyXG4gICAgICAgICAgICBjYXNlIDA6XHJcbiAgICAgICAgICAgICAgLy/kv67mlLnliKDpmaTlkI7pnaLmiYDmnInlm77niYfnmoTkvY3nva5cclxuICAgICAgICAgICAgICB2YXIgYWxsSW1ncyA9IHt9O1xyXG4gICAgICAgICAgICAgIHZhciBkZWxfc29ydCA9IHBhcnNlSW50KCQoXCIjXCIgKyBmaWxlLmlkKS5hdHRyKFwiZGF0YS1zb3J0XCIpKTtcclxuICAgICAgICAgICAgICAkcXVldWUuZmluZChcImxpXCIpLmVhY2goZnVuY3Rpb24oaW5kZXgsIG9iaikge1xyXG4gICAgICAgICAgICAgICAgaWYgKCQob2JqKS5hdHRyKFwiZGF0YS1zb3J0XCIpID4gZGVsX3NvcnQpIHtcclxuICAgICAgICAgICAgICAgICAgdmFyIHNvcnQgPSBwYXJzZUludCgkKG9iaikuYXR0cihcImRhdGEtc29ydFwiKSk7XHJcbiAgICAgICAgICAgICAgICAgIHZhciAkcHJldk9iaiA9ICQoXCJsaVtkYXRhLXNvcnQ9XCIgKyAoc29ydCAtIDEpICsgXCJdXCIpO1xyXG4gICAgICAgICAgICAgICAgICBpZiAoJHByZXZPYmopIHtcclxuICAgICAgICAgICAgICAgICAgICBhbGxJbWdzWyQob2JqKS5hdHRyKFwiaWRcIildID0gJHByZXZPYmoucG9zaXRpb24oKTtcclxuICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgIGZvciAodmFyIGsgaW4gYWxsSW1ncykge1xyXG4gICAgICAgICAgICAgICAgdmFyIHNvcnQgPSBwYXJzZUludCgkKFwiI1wiICsgaykuYXR0cihcImRhdGEtc29ydFwiKSk7XHJcbiAgICAgICAgICAgICAgICAkKFwiI1wiICsgaylcclxuICAgICAgICAgICAgICAgICAgLmF0dHIoXCJkYXRhLXNvcnRcIiwgc29ydCAtIDEpXHJcbiAgICAgICAgICAgICAgICAgIC5jc3Moe1xyXG4gICAgICAgICAgICAgICAgICAgIGxlZnQ6IGFsbEltZ3Nba10ubGVmdCArIFwicHhcIixcclxuICAgICAgICAgICAgICAgICAgICB0b3A6IGFsbEltZ3Nba10udG9wICsgXCJweFwiXHJcbiAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICBhbGxJbWdzID0gbnVsbDtcclxuICAgICAgICAgICAgICBpZiAoZmlsZS5zcmMgPT0gXCJjbGllbnRcIikgdXBsb2FkZXIucmVtb3ZlRmlsZShmaWxlKTtcclxuICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHJlbW92ZVNlcnZlckZpbGUoZmlsZSk7XHJcbiAgICAgICAgICAgICAgICAkKFwiI1wiICsgZmlsZS5pZCkucmVtb3ZlKCk7XHJcbiAgICAgICAgICAgICAgICBfdGhpcy51cGRhdGFJbWdDb3VudCgpXHJcbiAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgIF90aGlzLnNob3dJbWdsaXN0KF90aGlzLmN1cnJlbnROb2RlKVxyXG4gICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgY2FzZSAxOlxyXG4gICAgICAgICAgICAgIGZpbGUucm90YXRpb24gKz0gOTA7XHJcbiAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIGNhc2UgMjpcclxuICAgICAgICAgICAgICBmaWxlLnJvdGF0aW9uIC09IDkwO1xyXG4gICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgfVxyXG5cclxuICAgICAgICAgIGlmIChzdXBwb3J0VHJhbnNpdGlvbikge1xyXG4gICAgICAgICAgICBkZWcgPSBcInJvdGF0ZShcIiArIGZpbGUucm90YXRpb24gKyBcImRlZylcIjtcclxuICAgICAgICAgICAgJHdyYXAuY3NzKHtcclxuICAgICAgICAgICAgICBcIi13ZWJraXQtdHJhbnNmb3JtXCI6IGRlZyxcclxuICAgICAgICAgICAgICBcIi1tb3MtdHJhbnNmb3JtXCI6IGRlZyxcclxuICAgICAgICAgICAgICBcIi1vLXRyYW5zZm9ybVwiOiBkZWcsXHJcbiAgICAgICAgICAgICAgdHJhbnNmb3JtOiBkZWdcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICR3cmFwLnBhcmVudCgpLmF0dHIoXCJkYXRhLWRlZ1wiLGZpbGUucm90YXRpb24pXHJcbiAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgICRsaS5hcHBlbmRUbygkcXVldWUpO1xyXG4gICAgICAgICRsaS5kYXRhKFwiZmlsZWluZm9cIixmaWxlKVxyXG4gICAgICAgIF90aGlzLnVwZGF0YUltZ0NvdW50KClcclxuICAgICAgfVxyXG4gICAgICAvL+WIoOmZpHdlYnVwbG9hZOS4reeahOWbvueJh1xyXG4gICAgICBmdW5jdGlvbiByZW1vdmVGaWxlKGZpbGUpIHtcclxuICAgICAgICB2YXIgJGxpID0gJChcIiNcIiArIGZpbGUuaWQpO1xyXG4gICAgICAgIGRlbGV0ZSBwZXJjZW50YWdlc1tmaWxlLmlkXTtcclxuICAgICAgICB1cGRhdGVUb3RhbFByb2dyZXNzKCk7XHJcbiAgICAgICAgJGxpLm9mZigpLmZpbmQoXCIuZmlsZS1wYW5lbFwiKS5vZmYoKS5lbmQoKS5yZW1vdmUoKTtcclxuICAgICAgICBfdGhpcy51cGRhdGFJbWdDb3VudCgpXHJcbiAgICAgIH1cclxuXHJcbiAgICAgIC8v5pu05pawd2VidXBsb2FkZXLkuK3lm77niYfkuIrkvKDnmoTov5vluqZcclxuICAgICAgZnVuY3Rpb24gdXBkYXRlVG90YWxQcm9ncmVzcygpIHtcclxuICAgICAgICB2YXIgbG9hZGVkID0gMCxcclxuICAgICAgICAgIHRvdGFsID0gMCxcclxuICAgICAgICAgIHNwYW5zID0gJHByb2dyZXNzLmNoaWxkcmVuKCksXHJcbiAgICAgICAgICBwZXJjZW50O1xyXG5cclxuICAgICAgICAkLmVhY2gocGVyY2VudGFnZXMsIGZ1bmN0aW9uKGssIHYpIHtcclxuICAgICAgICAgIHRvdGFsICs9IHZbMF07XHJcbiAgICAgICAgICBsb2FkZWQgKz0gdlswXSAqIHZbMV07XHJcbiAgICAgICAgfSk7XHJcblxyXG4gICAgICAgIHBlcmNlbnQgPSB0b3RhbCA/IGxvYWRlZCAvIHRvdGFsIDogMDtcclxuXHJcbiAgICAgICAgc3BhbnMuZXEoMCkudGV4dChNYXRoLnJvdW5kKHBlcmNlbnQgKiAxMDApICsgXCIlXCIpO1xyXG4gICAgICAgIHNwYW5zLmVxKDEpLmNzcyhcIndpZHRoXCIsIE1hdGgucm91bmQocGVyY2VudCAqIDEwMCkgKyBcIiVcIik7XHJcbiAgICAgICAgdXBkYXRlU3RhdHVzKCk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIC8v5pu05pawd2VidXBsb2FkZXLkuK3nmoTnirbmgIFcclxuICAgICAgZnVuY3Rpb24gdXBkYXRlU3RhdHVzKCkge1xyXG4gICAgICAgIHZhciB0ZXh0ID0gXCJcIixcclxuICAgICAgICAgIHN0YXRzO1xyXG4gICAgICAgIGlmIChzdGF0ZSA9PSBcInJlYWR5XCIpIHtcclxuICAgICAgICAgIHRleHQgPVxyXG4gICAgICAgICAgICBcIuWFsVwiICtcclxuICAgICAgICAgICAgV2ViVXBsb2FkZXIuZm9ybWF0U2l6ZShmaWxlU2l6ZSkgK1xyXG4gICAgICAgICAgICBcIi5cIjtcclxuICAgICAgICB9IGVsc2UgaWYgKHN0YXRlID09IFwiY29uZmlybVwiKSB7XHJcbiAgICAgICAgICBzdGF0cyA9IHVwbG9hZGVyLmdldFN0YXRzKCk7XHJcbiAgICAgICAgICBpZiAoc3RhdHMudXBsb2FkRmFpbE51bSkge1xyXG4gICAgICAgICAgICB0ZXh0ID1cclxuICAgICAgICAgICAgICBcIuS4iuS8oOaIkOWKn1wiICtcclxuICAgICAgICAgICAgICBzdGF0cy5zdWNjZXNzTnVtICtcclxuICAgICAgICAgICAgICBcIuW8oOW9seWDj++8jOS4iuS8oOWksei0pTpcIiArXHJcbiAgICAgICAgICAgICAgc3RhdHMudXBsb2FkRmFpbE51bSArXHJcbiAgICAgICAgICAgICAgLy8n5byg54Wn54mH5LiK5Lyg5aSx6LSlLDxhIGNsYXNzPVwicmV0cnlcIiBocmVmPVwiI1wiPumHjeaWsOS4iuS8oDwvYT7lpLHotKXlm77niYfmiJY8YSBjbGFzcz1cImlnbm9yZVwiIGhyZWY9XCIjXCI+5b+955WlPC9hPic7XHJcbiAgICAgICAgICAgICAgJ+W8oOW9seWDj++8jDxhIGNsYXNzPVwicmV0cnlcIiBocmVmPVwiI1wiPumHjeaWsOS4iuS8oDwvYT7lpLHotKXlvbHlg48nO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICBzdGF0cyA9IHVwbG9hZGVyLmdldFN0YXRzKCk7XHJcbiAgICAgICAgICB0ZXh0ID1cclxuICAgICAgICAgICAgXCLlhbFcIiArXHJcbiAgICAgICAgICAgIGZpbGVDb3VudCArXHJcbiAgICAgICAgICAgIFwi5bygKFwiICtcclxuICAgICAgICAgICAgV2ViVXBsb2FkZXIuZm9ybWF0U2l6ZShmaWxlU2l6ZSkgK1xyXG4gICAgICAgICAgICBcIinvvIzlt7LkuIrkvKBcIiArXHJcbiAgICAgICAgICAgIHN0YXRzLnN1Y2Nlc3NOdW0gK1xyXG4gICAgICAgICAgICBcIuW8oFwiO1xyXG4gICAgICAgICAgaWYgKHN0YXRzLnVwbG9hZEZhaWxOdW0pIHtcclxuICAgICAgICAgICAgdGV4dCArPSBcIizlpLHotKVcIiArIHN0YXRzLnVwbG9hZEZhaWxOdW0gKyBcIuW8oFwiO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICAkaW5mby5odG1sKHRleHQpO1xyXG4gICAgICB9XHJcblxyXG4gICAgICAvL+iuvue9rndlYnVwbG9hZGVy55qE54q25oCBXHJcbiAgICAgIGZ1bmN0aW9uIHNldFN0YXRlKHZhbCkge1xyXG4gICAgICAgIHZhciBmaWxlLCBzdGF0cztcclxuICAgICAgICBpZiAodmFsID09IHN0YXRlKSB7XHJcbiAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgICR1cGxvYWQucmVtb3ZlQ2xhc3MoXCJzdGF0ZS1cIiArIHN0YXRlKTtcclxuICAgICAgICAkdXBsb2FkLmFkZENsYXNzKFwic3RhdGUtXCIgKyB2YWwpO1xyXG4gICAgICAgIHN0YXRlID0gdmFsO1xyXG5cclxuICAgICAgICBzd2l0Y2ggKHN0YXRlKSB7XHJcbiAgICAgICAgICBjYXNlIFwicGVkZGluZ1wiOlxyXG4gICAgICAgICAgICAkcGxhY2VIb2xkZXIucmVtb3ZlQ2xhc3MoXCJlbGVtZW50LWludmlzaWJsZVwiKTtcclxuICAgICAgICAgICAgJHF1ZXVlLnBhcmVudCgpLnJlbW92ZUNsYXNzKFwiZmlsbGVkXCIpO1xyXG4gICAgICAgICAgICAkcXVldWUuaGlkZSgpO1xyXG4gICAgICAgICAgICAkc3RhdHVzQmFyLmFkZENsYXNzKFwiZWxlbWVudC1pbnZpc2libGVcIik7XHJcbiAgICAgICAgICAgIHVwbG9hZGVyLnJlZnJlc2goKTtcclxuICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICBjYXNlIFwicmVhZHlcIjpcclxuICAgICAgICAgICAgJHBsYWNlSG9sZGVyLmFkZENsYXNzKFwiZWxlbWVudC1pbnZpc2libGVcIik7XHJcbiAgICAgICAgICAgICQoXCIjZmlsZVBpY2tlcjJcIikucmVtb3ZlQ2xhc3MoXCJlbGVtZW50LWludmlzaWJsZVwiKTtcclxuICAgICAgICAgICAgJHF1ZXVlLnBhcmVudCgpLmFkZENsYXNzKFwiZmlsbGVkXCIpO1xyXG4gICAgICAgICAgICAkcXVldWUuc2hvdygpO1xyXG4gICAgICAgICAgICAkc3RhdHVzQmFyLnJlbW92ZUNsYXNzKFwiZWxlbWVudC1pbnZpc2libGVcIik7XHJcbiAgICAgICAgICAgIHVwbG9hZGVyLnJlZnJlc2goKTtcclxuICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICBjYXNlIFwidXBsb2FkaW5nXCI6XHJcbiAgICAgICAgICAgICQoXCJmaWxlUGlja2VyMlwiKS5hZGRDbGFzcyhcImVsZW1lbnQtaW52aXNpYmxlXCIpO1xyXG4gICAgICAgICAgICAkcHJvZ3Jlc3Muc2hvdygpO1xyXG4gICAgICAgICAgICAkdXBsb2FkLnRleHQoXCLmmoLlgZzkuIrkvKBcIik7XHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgY2FzZSBcInBhdXNlZFwiOlxyXG4gICAgICAgICAgICAkcHJvZ3Jlc3Muc2hvdygpO1xyXG4gICAgICAgICAgICAkdXBsb2FkLnRleHQoXCLnu6fnu63kuIrkvKBcIik7XHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgY2FzZSBcImNvbmZpcm1cIjpcclxuICAgICAgICAgICAgJHByb2dyZXNzLmhpZGUoKTtcclxuICAgICAgICAgICAgLy93cWQgMjAxOTA1MDgg5rOo6YeKXHJcbiAgICAgICAgICAgIC8vICR1cGxvYWQudGV4dCgn5byA5aeL5LiK5LygJykuYWRkQ2xhc3MoJ2Rpc2FibGVkJyk7XHJcbiAgICAgICAgICAgICR1cGxvYWQudGV4dChcIuW8gOWni+S4iuS8oFwiKTtcclxuICAgICAgICAgICAgc3RhdHMgPSB1cGxvYWRlci5nZXRTdGF0cygpO1xyXG4gICAgICAgICAgICBpZiAoc3RhdHMuc3VjY2Vzc051bSAmJiAhc3RhdHMudXBsb2FkRmFpbE51bSkge1xyXG4gICAgICAgICAgICAgIC8vd3FkIDIwMTkwNTA4IOazqOmHilxyXG4gICAgICAgICAgICAgIC8vc2V0U3RhdGUoICdmaW5pc2gnICk7XHJcbiAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgY2FzZSBcImZpbmlzaFwiOlxyXG4gICAgICAgICAgICBzdGF0cyA9IHVwbG9hZGVyLmdldFN0YXRzKCk7XHJcbiAgICAgICAgICAgIGlmIChzdGF0cy5zdWNjZXNzTnVtKSB7XHJcbiAgICAgICAgICAgICAgYWxlcnQoXCLkuIrkvKDmiJDlip9cIik7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgc3RhdGUgPSBcImRvbmVcIjtcclxuICAgICAgICAgICAgICBsb2NhdGlvbi5yZWxvYWQoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBicmVhaztcclxuICAgICAgICB9XHJcbiAgICAgICAgdXBkYXRlU3RhdHVzKCk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIC8v5paH5Lu25Yqg5YWl5Yiwd2VidXBsb2FkZXLkuK3nmoTpmJ/liJdcclxuICAgICAgZnVuY3Rpb24gZmlsZVF1ZXVlKGZpbGUpIHtcclxuICAgICAgICBmaWxlLnNyYyA9IGZpbGUuc3JjIHx8IFwiY2xpZW50XCI7XHJcbiAgICAgICAgZmlsZUNvdW50Kys7XHJcbiAgICAgICAgZmlsZVNpemUgKz0gZmlsZS5zaXplO1xyXG5cclxuICAgICAgICBpZiAoZmlsZUNvdW50ID09IDEpIHtcclxuICAgICAgICAgICRwbGFjZUhvbGRlci5hZGRDbGFzcyhcImVsZW1lbnQtaW52aXNpYmxlXCIpO1xyXG4gICAgICAgICAgJHN0YXR1c0Jhci5zaG93KCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBhZGRGaWxlKGZpbGUpO1xyXG4gICAgICAgIHNldFN0YXRlKFwicmVhZHlcIik7XHJcbiAgICAgICAgdXBkYXRlVG90YWxQcm9ncmVzcygpO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBpZiAoIVdlYlVwbG9hZGVyLlVwbG9hZGVyLnN1cHBvcnQoKSkge1xyXG4gICAgICAgIGNvbnNvbGUubG9nKFwiV2ViVXBsb2FkZXIg5LiN5pSv5oyBXCIpO1xyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIldlYlVwbG9hZGVyIGRvZXMgbm90IHN1cHBvcnRcIik7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHVwbG9hZGVyLmFkZEJ1dHRvbih7XHJcbiAgICAgICAgaWQ6IFwiI2ZpbGVQaWNrZXIyXCIsXHJcbiAgICAgICAgbGFiZWw6IFwi57un57ut5re75YqgXCJcclxuICAgICAgfSk7XHJcblxyXG4gICAgICB1cGxvYWRlci5vbihcInVwbG9hZFByb2dyZXNzXCIsIGZ1bmN0aW9uKGZpbGUsIHBlcmNlbnRhZ2UpIHtcclxuICAgICAgICB2YXIgJGxpID0gJChcIiNcIiArIGZpbGUuaWQpLFxyXG4gICAgICAgICAgJHBlcmNlbnQgPSAkbGkuZmluZChcIi5wcm9ncmVzcyBzcGFuXCIpO1xyXG4gICAgICAgICRwZXJjZW50LmNzcyh7XCJ3aWR0aFwiOiBwZXJjZW50YWdlICogMTAwICsgXCIlXCIsXCJkaXNwbGF5XCI6XCJub25lXCJ9KVxyXG4gICAgICAgIHVwZGF0ZVRvdGFsUHJvZ3Jlc3MoKTtcclxuICAgICAgfSk7XHJcblxyXG4gICAgICB1cGxvYWRlci5vbihcImZpbGVRdWV1ZWRcIiwgZmlsZVF1ZXVlKTtcclxuXHJcbiAgICAgIHVwbG9hZGVyLm9uKFwiZmlsZURlcXVldWVkXCIsIGZ1bmN0aW9uKGZpbGUpIHtcclxuICAgICAgICBmaWxlQ291bnQtLTtcclxuICAgICAgICBmaWxlU2l6ZSAtPSBmaWxlLnNpemU7XHJcbiAgICAgICAgaWYgKCFmaWxlQ291bnQpIHtcclxuICAgICAgICAgIHNldFN0YXRlKFwicGVkZGluZ1wiKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmVtb3ZlRmlsZShmaWxlKTtcclxuICAgICAgICB1cGRhdGVUb3RhbFByb2dyZXNzKCk7XHJcbiAgICAgIH0pO1xyXG5cclxuICAgICAgdXBsb2FkZXIub24oXCJ1cGxvYWRTdWNjZXNzXCIsIGZ1bmN0aW9uKGZpbGUsIGRhdGEpIHtcclxuICAgICAgICBpZiAoZGF0YS5GX0NPREUgPT09IFwiMFwiKSB7XHJcbiAgICAgICAgICAkKFwiI1wiICsgZmlsZS5pZClcclxuICAgICAgICAgICAgLmZpbmQoXCJwLnN0YXRlXCIpXHJcbiAgICAgICAgICAgIC50ZXh0KFwi5bey5LiK5LygXCIpO1xyXG4gICAgICAgIH1cclxuICAgICAgfSk7XHJcblxyXG4gICAgICB1cGxvYWRlci5vbihcInVwbG9hZEVycm9yXCIsIGZ1bmN0aW9uKGZpbGUsIGIpIHtcclxuICAgICAgICBjb25zb2xlLmxvZyhmaWxlLmlkICsgXCLkuIrkvKDlh7rplJlcIik7XHJcbiAgICAgIH0pO1xyXG5cclxuICAgICAgdXBsb2FkZXIub24oXCJ1cGxvYWRDb21wbGV0ZVwiLCBmdW5jdGlvbihmaWxlLCBhLCBiKSB7XHJcbiAgICAgICAgJChcIiNcIiArIGZpbGUuaWQpXHJcbiAgICAgICAgICAuZmluZChcInAuc3RhdGVcIilcclxuICAgICAgICAgIC5mYWRlT3V0KCk7XHJcbiAgICAgIH0pO1xyXG5cclxuICAgICAgdXBsb2FkZXIub24oXCJhbGxcIiwgZnVuY3Rpb24odHlwZSkge1xyXG4gICAgICAgIGlmICh0eXBlID09IFwidXBsb2FkRmluaXNoZWRcIikge1xyXG4gICAgICAgICAgc2V0U3RhdGUoXCJjb25maXJtXCIpO1xyXG4gICAgICAgIH0gZWxzZSBpZiAodHlwZSA9PSBcInN0YXJ0VXBsb2FkXCIpIHtcclxuICAgICAgICAgIHNldFN0YXRlKFwidXBsb2FkaW5nXCIpO1xyXG4gICAgICAgIH0gZWxzZSBpZiAodHlwZSA9PSBcInN0b3BVcGxvYWRcIikge1xyXG4gICAgICAgICAgc2V0U3RhdGUoXCJwYXVzZWRcIik7XHJcbiAgICAgICAgfVxyXG4gICAgICB9KTtcclxuXHJcbiAgICAgIHVwbG9hZGVyLm9uKFwidXBsb2FkQmVmb3JlU2VuZFwiLCBmdW5jdGlvbihibG9jaywgZGF0YSkge1xyXG4gICAgICAgIGRhdGEuc29ydCA9ICQoXCIjXCIgKyBkYXRhLmlkKS5hdHRyKFwiZGF0YS1zb3J0XCIpO1xyXG4gICAgICAgIHZhciBmaWxlID0gJChcIiNcIiArIGRhdGEuaWQpLmRhdGEoXCJmaWxlaW5mb1wiKVxyXG4gICAgICAgIHZhciBvYmogPSB7XHJcbiAgICAgICAgICBcIkZfQVBQX0lEXCI6IFwiVEFJS0FOR1wiLC8v5p2l5rqQ57O757uf5qCH6K+GXHJcbiAgICAgICAgICBcIkZfQUNDRVNTX1RPS0VOXCI6IFwiXCIsXHJcbiAgICAgICAgICBcIkZfVVNFUl9JRFwiOiBcInRpYW5tZW5nXCIsLy/mk43kvZzkurpcclxuICAgICAgICAgIFwiRl9VU0VSX05BTUVcIjpcIlwiLC8v5pON5L2c5Lq65ZCN56ewXHJcbiAgICAgICAgICBcIkZfTkVFRF9BUFBMWVwiOiBcIjFcIiwgIC8v5piv5ZCm6ZyA6KaB55Sz6K+3IOm7mOiupDFcclxuICAgICAgICAgIFwiRl9CSUxMX0lEXCI6XCJMS1JMMjAxODEyMTEwMDE0XCIsLy/ljZXmja7nvJblj7dcclxuICAgICAgICAgIFwiRl9CSUxMX1RZUEVcIjpcIlRURlNfSlNfTEtSTERcIiwvL+WNleaNruexu+Wei1xyXG4gICAgICAgICAgXCJGX0JJWl9UWVBFXCI6XCJUVEZTX0pTX0xLUkxEXCIsLy/kuJrliqHnsbvlnotcclxuICAgICAgICAgIFwiRl9BTVRcIjpcIlwiLC8v6YeR6aKdXHJcbiAgICAgICAgICBcIkZfQ1VSUlwiOlwiXCIsLy/luIHnp41cclxuICAgICAgICAgIFwiRl9TQ19DT0RFXCI6XCJcIiwvL+WFseS6q+S4reW/g1xyXG4gICAgICAgICAgXCJGX1BPT0xfSURcIjpcIlwiLC8v5Lia5Yqh5rGgXHJcbiAgICAgICAgICBcIkZfQVRUX1RZUEVcIjpcIjBcIiwvL+S4iuS8oOaWueW8jyAw5pmu6YCa5LiK5LygIDEg6ZuG5Lit5omr5o+PXHJcbiAgICAgICAgICBcIkZfQVBQTFlfRklMRVNcIjogW1xyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgXCJGX1RZUEVcIjogXCIwXCIsXHJcbiAgICAgICAgICAgICAgXCJGX09CSkVDVFwiOiBcIjEyMzQ1Njc4OTBcIixcclxuICAgICAgICAgICAgICBcIkZfSU1HX0NPREVcIjpmaWxlLkZfSU1HX0NPREUsLy/lvbHlg4/lhbPplK7noIFcclxuICAgICAgICAgICAgICBcIkZfSU1HX1RZUEVcIjpmaWxlLkZfSU1HX1RZUEUsLy/lvbHlg4/nsbvliKtcclxuICAgICAgICAgICAgICBcIkZfRklMRVNcIjogW1xyXG4gICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICBcIkZfRklMRV9OQU1FXCI6IGRhdGEubmFtZSxcclxuICAgICAgICAgICAgICAgICAgXCJGX0ZJTEVfTkFNRTFcIjogZGF0YS5uYW1lLFxyXG4gICAgICAgICAgICAgICAgICBcIkZfRklMRV9QQVRIXCI6IFwiXCIsXHJcbiAgICAgICAgICAgICAgICAgIFwiRl9GSUxFX1NJWkVcIjogZGF0YS5zaXplLFxyXG4gICAgICAgICAgICAgICAgICBcIkZfRklMRV9NRDVcIjogXCJcIixcclxuICAgICAgICAgICAgICAgICAgXCJGX1VQTE9BRF9aSVBcIjogXCJcIixcclxuICAgICAgICAgICAgICAgICAgXCJGX0VOQ1JZUFRcIjogXCJcIixcclxuICAgICAgICAgICAgICAgICAgXCJGX0VOQ1JZUFRfS0VZXCI6IFwiXCIsXHJcbiAgICAgICAgICAgICAgICAgIFwiRl9CSVpfSU5GT1wiOlwiXCIsLy/mkZjopoFcclxuICAgICAgICAgICAgICAgICAgXCJGX09QRVJfVFlQRVwiOlwiXCIsLy/mk43kvZznsbvlnosg6buY6K6k56m66KGo56S65Yi25Y2V5Lq65LiK5LygIDHooajnpLrlrqHmibnkurrliqDmibnms6jmiJbnvJbovpHlm77niYdcclxuICAgICAgICAgICAgICAgICAgXCJGX09SSUdfSU1HX0tFWVwiOiBcIlwiLC8v5a6h5om55Lq657yW6L6R5Y+K5om55rOo5Zu+54mH5pe25pyJ55SoXHJcbiAgICAgICAgICAgICAgICAgIFwiRl9OT0RFX0lEXCI6XCJcIiwvL+etvuaJueiKgueCuVxyXG4gICAgICAgICAgICAgICAgICBcIkZfTk9ERV9OQU1FXCI6XCJcIiwvL+etvuaJueiKgueCueWQjeensFxyXG4gICAgICAgICAgICAgICAgICBcIkZfU0lHTl9VU1JfTkFNRVwiOlwiXCIsLy/nrb7mibnkurrlkI3np7BcclxuICAgICAgICAgICAgICAgICAgXCJGX1NJR05fTk9URVwiOlwiXCIsLy/nrb7mibnlhoXlrrlcclxuICAgICAgICAgICAgICAgICAgXCJGX09QX0FDVElPTlwiOlwiXCIsLy/mk43kvZzliqjkvZxcclxuICAgICAgICAgICAgICAgICAgXCJGX1JPVEFURVwiOmZpbGUucm90YXRpb24sLy/ml4vovazluqbmlbBcclxuICAgICAgICAgICAgICAgICAgXCJGX0ZJTEVfT1JERVJcIjokKFwiI1wiICsgZGF0YS5pZCkuYXR0cihcImRhdGEtc29ydFwiKSwvL+aYvuekuuW6j+WPt1xyXG4gICAgICAgICAgICAgICAgICBcIkZfSVNISURFXCI6XCIwXCIsLy/mmK/lkKbpmpDol4/vvJox5piv77yMMOWQplxyXG4gICAgICAgICAgICAgICAgICBcIkZfUklTS19UWVBFXCI6XCJcIi8v6aOO6Zmp57G75YirXHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgXVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICBdXHJcbiAgICAgICAgfVxyXG4gICAgICAgIGRhdGEuanNvbmRhdGEgPSBKU09OLnN0cmluZ2lmeShvYmopO1xyXG4gICAgICAgIHZhciAkbGkgPSAkKFwiI1wiICsgZGF0YS5pZCksXHJcbiAgICAgICAgICAkcGVyY2VudCA9ICRsaS5maW5kKFwiLnByb2dyZXNzIHNwYW5cIik7XHJcbiAgICAgICAgJHBlcmNlbnQuY3NzKHtcIndpZHRoXCI6IFwiMTAwJVwiLFwiZGlzcGxheVwiOlwiYmxvY2tcIn0pXHJcbiAgICAgIH0pO1xyXG5cclxuICAgICAgJHVwbG9hZC5vbihcImNsaWNrXCIsIGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIHVwbG9hZGVyLnNvcnQoZnVuY3Rpb24ob2JqMSwgb2JqMikge1xyXG4gICAgICAgICAgcmV0dXJuICQoXCIjXCIgKyBvYmoxLmlkKS5hdHRyKFwiZGF0YS1zb3J0XCIpID4gJChcIiNcIiArIG9iajIuaWQpID8gLTEgOiAxO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIGlmICgkKHRoaXMpLmhhc0NsYXNzKFwiZGlzYWJsZWRcIikpIHtcclxuICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHN0YXRlID09IFwicmVhZHlcIikge1xyXG4gICAgICAgICAgaWYgKHVwbG9hZGVyLmdldEZpbGVzKCkubGVuZ3RoIDwgMSkgdXBkYXRlU2VydmVyRmlsZXMoKTtcclxuICAgICAgICAgIGVsc2UgdXBsb2FkZXIudXBsb2FkKCk7XHJcbiAgICAgICAgfSBlbHNlIGlmIChzdGF0ZSA9PSBcInBhdXNlZFwiKSB7XHJcbiAgICAgICAgICB1cGxvYWRlci51cGxvYWQoKTtcclxuICAgICAgICB9IGVsc2UgaWYgKHN0YXRlID09IFwidXBsb2FkaW5nXCIpIHtcclxuICAgICAgICAgIHVwbG9hZGVyLnN0b3AoKTtcclxuICAgICAgICB9XHJcbiAgICAgIH0pO1xyXG5cclxuICAgICAgJGluZm8ub24oXCJjbGlja1wiLCBcIi5yZXRyeVwiLCBmdW5jdGlvbigpIHtcclxuICAgICAgICB1cGxvYWRlci5yZXRyeSgpO1xyXG4gICAgICB9KTtcclxuXHJcbiAgICAgICRpbmZvLm9uKFwiY2xpY2tcIiwgXCIuaWdub3JlXCIsIGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIGFsZXJ0KFwidG9kb1wiKTtcclxuICAgICAgfSk7XHJcblxyXG4gICAgICAkdXBsb2FkLmFkZENsYXNzKFwic3RhdGUtXCIgKyBzdGF0ZSk7XHJcbiAgICAgIHVwZGF0ZVRvdGFsUHJvZ3Jlc3MoKTtcclxuXHJcbiAgICAgIGluaXRTZXJ2ZXJGaWxlKCk7XHJcbiAgICB9LFxyXG4gICAgLyogZXNsaW50LWVuYWJsZSAqL1xyXG4gICAgc2hvd0ltZ2xpc3Q6IGZ1bmN0aW9uICh0eXBlKSB7XHJcbiAgICAgICQoXCIuZmlsZWxpc3Q+bGlbZGF0YS10eXBlIT0nXCIgKyB0eXBlICsgXCInXVwiKS5oaWRlKClcclxuICAgICAgJChcIi5maWxlbGlzdD5saVtkYXRhLXR5cGU9J1wiICsgdHlwZSArIFwiJ11cIikuc2hvdygpXHJcbiAgICAgICQoJy52Y2hyaW1hZ2UgLm1pZGRsZScpLmNzcygnb3ZlcmZsb3cteScsICdoaWRkZW4nKVxyXG4gICAgICAkKCcudmNocmltYWdlIC5jYXRlZ29yeS12aWV3JykuY3NzKCdvdmVyZmxvdy15JywgJ2hpZGRlbicpXHJcbiAgICAgIC8vIOmHjeaWsOiuoeeul+WbvueJh+eahOS9jee9rlxyXG4gICAgICB2YXIgJHF1ZXVlID0gJCgnLmZpbGVsaXN0JylcclxuICAgICAgLy8g5LyY5YyWcmV0aW5hLCDlnKhyZXRpbmHkuIvov5nkuKrlgLzmmK8yXHJcbiAgICAgIHZhciByYXRpbyA9IHdpbmRvdy5kZXZpY2VQaXhlbFJhdGlvIHx8IDFcclxuICAgICAgLy8g57yp55Wl5Zu+5aSn5bCPXHJcbiAgICAgIHZhciB0aHVtYm5haWxXaWR0aCA9IHRoaXMudXBsb2FkcHJvcHMuY29uZmlnLnRodW1iV2lkdGggfHwgMTEwXHJcbiAgICAgIHRodW1ibmFpbFdpZHRoICo9IHJhdGlvXHJcbiAgICAgIHZhciB0aHVtYm5haWxIZWlnaHQgPSB0aGlzLnVwbG9hZHByb3BzLmNvbmZpZy50aHVtYkhlaWdodCB8fCAxMTBcclxuICAgICAgdGh1bWJuYWlsSGVpZ2h0ID0gdGh1bWJuYWlsSGVpZ2h0ICsgMjVcclxuICAgICAgdGh1bWJuYWlsSGVpZ2h0ICo9IHJhdGlvXHJcbiAgICAgIHZhciB3cmFwSGVpZ2h0ID0gdGh1bWJuYWlsSGVpZ2h0ICsgMTBcclxuICAgICAgdmFyIHdyYXBXaWR0aCA9ICRxdWV1ZS53aWR0aCgpXHJcbiAgICAgIHZhciBpbWdOdW0gPSBwYXJzZUludCh3cmFwV2lkdGggLyAodGh1bWJuYWlsV2lkdGggKyAxMCkpIC8vIOavj+ihjOacieWHoOW8oOWbvueJh1xyXG4gICAgICAkKFwiLmZpbGVsaXN0PmxpW2RhdGEtdHlwZT0nXCIgKyB0eXBlICsgXCInXVwiKS5lYWNoKGZ1bmN0aW9uIChpbmRleCwgdikge1xyXG4gICAgICAgIHZhciBpbWdUb3AgPSAwXHJcbiAgICAgICAgdmFyIGltZ0xlZnQgPSBpbmRleCAqICh0aHVtYm5haWxXaWR0aCArIDEwKVxyXG4gICAgICAgIGlmIChpbmRleCArIDEgPiBpbWdOdW0pIHtcclxuICAgICAgICAgIGltZ1RvcCA9IHBhcnNlSW50KGluZGV4IC8gaW1nTnVtKSAqICh0aHVtYm5haWxIZWlnaHQgKyAxMClcclxuICAgICAgICAgIGltZ0xlZnQgPSAoaW5kZXggJSBpbWdOdW0pICogKHRodW1ibmFpbFdpZHRoICsgMTApXHJcbiAgICAgICAgICB3cmFwSGVpZ2h0ID0gaW1nVG9wICsgdGh1bWJuYWlsSGVpZ2h0ICsgMTBcclxuICAgICAgICB9XHJcbiAgICAgICAgJCh0aGlzKS5jc3MoeyBsZWZ0OiBpbWdMZWZ0ICsgJ3B4JywgdG9wOiBpbWdUb3AgKyAncHgnIH0pXHJcbiAgICAgIH0pXHJcbiAgICAgICRxdWV1ZS5jc3MoJ2hlaWdodCcsIHdyYXBIZWlnaHQgKyAncHgnKVxyXG4gICAgICAkKCcudmNocmltYWdlIC5taWRkbGUnKS5jc3MoJ292ZXJmbG93LXknLCAnYXV0bycpXHJcbiAgICAgICQoJy52Y2hyaW1hZ2UgLmNhdGVnb3J5LXZpZXcnKS5jc3MoJ292ZXJmbG93LXknLCAnYXV0bycpXHJcbiAgICB9LFxyXG4gICAgLy8gdGFi6aG1562+54K55Ye7XHJcbiAgICB0YWJDaGFuZ2U6IGZ1bmN0aW9uIChyZWYpIHtcclxuICAgICAgJCh0aGlzLiRyZWZzW3JlZl0pLmFkZENsYXNzKCd0YWItYWN0aXZlJykuc2libGluZ3MoKS5yZW1vdmVDbGFzcygndGFiLWFjdGl2ZScpXHJcbiAgICAgIGlmIChyZWYgPT09ICdhbGxWaWV3Jykge1xyXG4gICAgICAgICQoJy5xdWV1ZUFsbExpc3QnKS5zaG93KCkuZW1wdHkoKVxyXG4gICAgICAgICQoJy5pbWdXcmFwIGltZycpLmNsb25lKCkuYXBwZW5kVG8oJCgnLnF1ZXVlQWxsTGlzdCcpKVxyXG4gICAgICAgICQoJy5xdWV1ZUxpc3QnKS5oaWRlKClcclxuICAgICAgICAkKCcucXVldWVBbGxMaXN0IGltZycpLmNzcygnbWFyZ2luJywgJzEwcHgnKVxyXG4gICAgICAgIHRoaXMuQWxsSW1nZUNvdW50ID0gJCgnLnF1ZXVlQWxsTGlzdCBpbWcnKS5sZW5ndGhcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICAkKCcucXVldWVMaXN0Jykuc2hvdygpXHJcbiAgICAgICAgJCgnLnF1ZXVlQWxsTGlzdCcpLmhpZGUoKVxyXG4gICAgICB9XHJcbiAgICB9LFxyXG4gICAgdXBkYXRhSW1nQ291bnQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgdmFyICRxdWV1ZSA9ICQoJy5maWxlbGlzdCcpXHJcbiAgICAgIHZhciBjb3VudCA9ICRxdWV1ZS5maW5kKFwibGlbZGF0YS10eXBlPSdcIiArIHRoaXMuY3VycmVudE5vZGUgKyBcIiddXCIpLmxlbmd0aFxyXG4gICAgICB0aGlzLkNOb2RlSW1nZUNvdW50ID0gY291bnRcclxuICAgICAgdGhpcy4kZW1pdCgnQ05vZGVJbWdlQ291bnQnLCBjb3VudClcclxuICAgICAgdmFyIGFsbENvdW50ID0gJHF1ZXVlLmZpbmQoJ2xpJykubGVuZ3RoXHJcbiAgICAgIHRoaXMuQWxsSW1nZUNvdW50ID0gYWxsQ291bnRcclxuICAgIH1cclxuICB9XHJcbn1cclxuPC9zY3JpcHQ+XHJcbjxzdHlsZSBzY29wZWQ+XHJcbiAgLnRhYi12aWV3IGRpdntcclxuICAgIHBhZGRpbmc6IDAgMjBweDtcclxuICAgIGN1cnNvcjogcG9pbnRlcjtcclxuICB9XHJcbiAgLnRhYi12aWV3IC50YWItYWN0aXZle1xyXG4gICAgYm9yZGVyLWJvdHRvbTogMnB4IHNvbGlkICMxMDk0ZmE7XHJcbiAgfVxyXG48L3N0eWxlPlxyXG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gc3JjL2NvbXBvbmVudHMvd2VidXBsb2FkZXIvdXBsb2FkLnZ1ZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///33\n");

/***/ }),
/* 34 */
/***/ (function(module, exports) {

eval("module.exports = function escape(url) {\n    if (typeof url !== 'string') {\n        return url\n    }\n    // If url is already wrapped in quotes, remove them\n    if (/^['\"].*['\"]$/.test(url)) {\n        url = url.slice(1, -1);\n    }\n    // Should url be wrapped?\n    // See https://drafts.csswg.org/css-values-3/#urls\n    if (/[\"'() \\t\\n]/.test(url)) {\n        return '\"' + url.replace(/\"/g, '\\\\\"').replace(/\\n/g, '\\\\n') + '\"'\n    }\n\n    return url\n}\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9saWIvdXJsL2VzY2FwZS5qcz85MzExIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EiLCJmaWxlIjoiMzQuanMiLCJzb3VyY2VzQ29udGVudCI6WyJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGVzY2FwZSh1cmwpIHtcbiAgICBpZiAodHlwZW9mIHVybCAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgcmV0dXJuIHVybFxuICAgIH1cbiAgICAvLyBJZiB1cmwgaXMgYWxyZWFkeSB3cmFwcGVkIGluIHF1b3RlcywgcmVtb3ZlIHRoZW1cbiAgICBpZiAoL15bJ1wiXS4qWydcIl0kLy50ZXN0KHVybCkpIHtcbiAgICAgICAgdXJsID0gdXJsLnNsaWNlKDEsIC0xKTtcbiAgICB9XG4gICAgLy8gU2hvdWxkIHVybCBiZSB3cmFwcGVkP1xuICAgIC8vIFNlZSBodHRwczovL2RyYWZ0cy5jc3N3Zy5vcmcvY3NzLXZhbHVlcy0zLyN1cmxzXG4gICAgaWYgKC9bXCInKCkgXFx0XFxuXS8udGVzdCh1cmwpKSB7XG4gICAgICAgIHJldHVybiAnXCInICsgdXJsLnJlcGxhY2UoL1wiL2csICdcXFxcXCInKS5yZXBsYWNlKC9cXG4vZywgJ1xcXFxuJykgKyAnXCInXG4gICAgfVxuXG4gICAgcmV0dXJuIHVybFxufVxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9saWIvdXJsL2VzY2FwZS5qc1xuLy8gbW9kdWxlIGlkID0gMzRcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///34\n");

/***/ }),
/* 35 */
/***/ (function(module, exports) {

eval("module.exports = \"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABEAAAAQCAYAAADwMZRfAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAA2hpVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuMy1jMDExIDY2LjE0NTY2MSwgMjAxMi8wMi8wNi0xNDo1NjoyNyAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wTU09Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9tbS8iIHhtbG5zOnN0UmVmPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvc1R5cGUvUmVzb3VyY2VSZWYjIiB4bWxuczp4bXA9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC8iIHhtcE1NOk9yaWdpbmFsRG9jdW1lbnRJRD0ieG1wLmRpZDowMjgwMTE3NDA3MjA2ODExODA4M0E4MzgzMTAzRTZGOSIgeG1wTU06RG9jdW1lbnRJRD0ieG1wLmRpZDpCRjFGMDIxRDFEMEIxMUUzQUExRkU5NjcxMEMxOEM3QyIgeG1wTU06SW5zdGFuY2VJRD0ieG1wLmlpZDpCRjFGMDIxQzFEMEIxMUUzQUExRkU5NjcxMEMxOEM3QyIgeG1wOkNyZWF0b3JUb29sPSJBZG9iZSBQaG90b3Nob3AgQ1M2IChNYWNpbnRvc2gpIj4gPHhtcE1NOkRlcml2ZWRGcm9tIHN0UmVmOmluc3RhbmNlSUQ9InhtcC5paWQ6MDQ4MDExNzQwNzIwNjgxMTgwODNBODM4MzEwM0U2RjkiIHN0UmVmOmRvY3VtZW50SUQ9InhtcC5kaWQ6MDI4MDExNzQwNzIwNjgxMTgwODNBODM4MzEwM0U2RjkiLz4gPC9yZGY6RGVzY3JpcHRpb24+IDwvcmRmOlJERj4gPC94OnhtcG1ldGE+IDw/eHBhY2tldCBlbmQ9InIiPz62XI8XAAABI0lEQVR42oSTf0vDMBCGkyajTBmOwXR+Bb//9/EvnT+GTkXGbJv4XImlS3MuEK5prs+99ya1IYQ7a+3cTEfouu6euM83yDfsGb7t11XbtltiLEAqkm+IzpQqJECfyGLP/CglVlV1SVjn72OM/RxXi0lNKHDYttfEetyKqJA4QFI80OOromZG2ORKTnL+3qPmhc2jAloSFucgMn40k5HukxqX+5FD5NjeSPhS1CyArXI/JhAxuWmarVEcliOniJ8UyHvk+RtFOwVUO+c2RUh+DfDmSTwqgYCsaO3i5J6Y8jgCelZu8gzQrQg7BzFAdlQ7KCZfAVoO6/y4Rv0HTH5Qaljv/aBGVZJ+sk9MfleKzMVkEfEvRO4DbT2S2Comr2mt/hVgANU+nayGWj9TAAAAAElFTkSuQmCC\"\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvY29tcG9uZW50cy93ZWJ1cGxvYWRlci9pbWFnZXMvcHJvZ3Jlc3MucG5nP2RjMTAiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEsaUNBQWlDIiwiZmlsZSI6IjM1LmpzIiwic291cmNlc0NvbnRlbnQiOlsibW9kdWxlLmV4cG9ydHMgPSBcImRhdGE6aW1hZ2UvcG5nO2Jhc2U2NCxpVkJPUncwS0dnb0FBQUFOU1VoRVVnQUFBQkVBQUFBUUNBWUFBQUR3TVpSZkFBQUFHWFJGV0hSVGIyWjBkMkZ5WlFCQlpHOWlaU0JKYldGblpWSmxZV1I1Y2NsbFBBQUFBMmhwVkZoMFdFMU1PbU52YlM1aFpHOWlaUzU0YlhBQUFBQUFBRHcvZUhCaFkydGxkQ0JpWldkcGJqMGk3N3UvSWlCcFpEMGlWelZOTUUxd1EyVm9hVWg2Y21WVGVrNVVZM3ByWXpsa0lqOCtJRHg0T25odGNHMWxkR0VnZUcxc2JuTTZlRDBpWVdSdlltVTZibk02YldWMFlTOGlJSGc2ZUcxd2RHczlJa0ZrYjJKbElGaE5VQ0JEYjNKbElEVXVNeTFqTURFeElEWTJMakUwTlRZMk1Td2dNakF4TWk4d01pOHdOaTB4TkRvMU5qb3lOeUFnSUNBZ0lDQWdJajRnUEhKa1pqcFNSRVlnZUcxc2JuTTZjbVJtUFNKb2RIUndPaTh2ZDNkM0xuY3pMbTl5Wnk4eE9UazVMekF5THpJeUxYSmtaaTF6ZVc1MFlYZ3Ribk1qSWo0Z1BISmtaanBFWlhOamNtbHdkR2x2YmlCeVpHWTZZV0p2ZFhROUlpSWdlRzFzYm5NNmVHMXdUVTA5SW1oMGRIQTZMeTl1Y3k1aFpHOWlaUzVqYjIwdmVHRndMekV1TUM5dGJTOGlJSGh0Ykc1ek9uTjBVbVZtUFNKb2RIUndPaTh2Ym5NdVlXUnZZbVV1WTI5dEwzaGhjQzh4TGpBdmMxUjVjR1V2VW1WemIzVnlZMlZTWldZaklpQjRiV3h1Y3pwNGJYQTlJbWgwZEhBNkx5OXVjeTVoWkc5aVpTNWpiMjB2ZUdGd0x6RXVNQzhpSUhodGNFMU5Pazl5YVdkcGJtRnNSRzlqZFcxbGJuUkpSRDBpZUcxd0xtUnBaRG93TWpnd01URTNOREEzTWpBMk9ERXhPREE0TTBFNE16Z3pNVEF6UlRaR09TSWdlRzF3VFUwNlJHOWpkVzFsYm5SSlJEMGllRzF3TG1ScFpEcENSakZHTURJeFJERkVNRUl4TVVVelFVRXhSa1U1TmpjeE1FTXhPRU0zUXlJZ2VHMXdUVTA2U1c1emRHRnVZMlZKUkQwaWVHMXdMbWxwWkRwQ1JqRkdNREl4UXpGRU1FSXhNVVV6UVVFeFJrVTVOamN4TUVNeE9FTTNReUlnZUcxd09rTnlaV0YwYjNKVWIyOXNQU0pCWkc5aVpTQlFhRzkwYjNOb2IzQWdRMU0ySUNoTllXTnBiblJ2YzJncElqNGdQSGh0Y0UxTk9rUmxjbWwyWldSR2NtOXRJSE4wVW1WbU9tbHVjM1JoYm1ObFNVUTlJbmh0Y0M1cGFXUTZNRFE0TURFeE56UXdOekl3TmpneE1UZ3dPRE5CT0RNNE16RXdNMFUyUmpraUlITjBVbVZtT21SdlkzVnRaVzUwU1VROUluaHRjQzVrYVdRNk1ESTRNREV4TnpRd056SXdOamd4TVRnd09ETkJPRE00TXpFd00wVTJSamtpTHo0Z1BDOXlaR1k2UkdWelkzSnBjSFJwYjI0K0lEd3ZjbVJtT2xKRVJqNGdQQzk0T25odGNHMWxkR0UrSUR3L2VIQmhZMnRsZENCbGJtUTlJbklpUHo2MlhJOFhBQUFCSTBsRVFWUjQyb1NUZjB2RE1CQ0dreWFqVEJtT3dYUitCYi8vOS9Fdm5UK0dUa1hHYkp2NFhJbWxTM011RUs1cHJzKzk5eWExSVlRN2ErM2NURWZvdXU2ZXVNODN5RGZzR2I3dDExWGJ0bHRpTEVBcWttK0l6cFFxSkVDZnlHTFAvQ2dsVmxWMVNWam43Mk9NL1J4WGkwbE5LSERZdHRmRWV0eUtxSkE0UUZJODBPT3JvbVpHMk9SS1RuTCszcVBtaGMyakFsb1NGdWNnTW40MGs1SHVreHFYKzVGRDVOamVTUGhTMUN5QXJYSS9KaEF4dVdtYXJWRWNsaU9uaUo4VXlIdmsrUnRGT3dWVU8rYzJSVWgrRGZEbVNUd3FnWUNzYU8zaTVKNlk4amdDZWxadThnelFyUWc3QnpGQWRsUTdLQ1pmQVZvTzYveTRSdjBIVEg1UWFsanYvYUJHVlpKK3NrOU1mbGVLek1Wa0VmRXZSTzREYlQyUzJDb21yMm10L2hWZ0FOVStuYXlHV2o5VEFBQUFBRWxGVGtTdVFtQ0NcIlxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vc3JjL2NvbXBvbmVudHMvd2VidXBsb2FkZXIvaW1hZ2VzL3Byb2dyZXNzLnBuZ1xuLy8gbW9kdWxlIGlkID0gMzVcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///35\n");

/***/ }),
/* 36 */
/***/ (function(module, exports, __webpack_require__) {

eval("module.exports = !__webpack_require__(5) && !__webpack_require__(13)(function () {\n  return Object.defineProperty(__webpack_require__(37)('div'), 'a', { get: function () { return 7; } }).a != 7;\n});\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2llOC1kb20tZGVmaW5lLmpzPzQ5ZjAiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEsa0JBQWtCLG1CQUFPLENBQUMsQ0FBZ0IsTUFBTSxtQkFBTyxDQUFDLEVBQVU7QUFDbEUsK0JBQStCLG1CQUFPLENBQUMsRUFBZSxnQkFBZ0IsbUJBQW1CLFVBQVUsRUFBRSxFQUFFO0FBQ3ZHLENBQUMiLCJmaWxlIjoiMzYuanMiLCJzb3VyY2VzQ29udGVudCI6WyJtb2R1bGUuZXhwb3J0cyA9ICFyZXF1aXJlKCcuL19kZXNjcmlwdG9ycycpICYmICFyZXF1aXJlKCcuL19mYWlscycpKGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShyZXF1aXJlKCcuL19kb20tY3JlYXRlJykoJ2RpdicpLCAnYScsIHsgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiA3OyB9IH0pLmEgIT0gNztcbn0pO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2llOC1kb20tZGVmaW5lLmpzXG4vLyBtb2R1bGUgaWQgPSAzNlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///36\n");

/***/ }),
/* 37 */
/***/ (function(module, exports, __webpack_require__) {

eval("var isObject = __webpack_require__(8);\nvar document = __webpack_require__(0).document;\n// typeof document.createElement is 'object' in old IE\nvar is = isObject(document) && isObject(document.createElement);\nmodule.exports = function (it) {\n  return is ? document.createElement(it) : {};\n};\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2RvbS1jcmVhdGUuanM/MzhkZCJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSxlQUFlLG1CQUFPLENBQUMsQ0FBYztBQUNyQyxlQUFlLG1CQUFPLENBQUMsQ0FBVztBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBIiwiZmlsZSI6IjM3LmpzIiwic291cmNlc0NvbnRlbnQiOlsidmFyIGlzT2JqZWN0ID0gcmVxdWlyZSgnLi9faXMtb2JqZWN0Jyk7XG52YXIgZG9jdW1lbnQgPSByZXF1aXJlKCcuL19nbG9iYWwnKS5kb2N1bWVudDtcbi8vIHR5cGVvZiBkb2N1bWVudC5jcmVhdGVFbGVtZW50IGlzICdvYmplY3QnIGluIG9sZCBJRVxudmFyIGlzID0gaXNPYmplY3QoZG9jdW1lbnQpICYmIGlzT2JqZWN0KGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaXQpIHtcbiAgcmV0dXJuIGlzID8gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChpdCkgOiB7fTtcbn07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fZG9tLWNyZWF0ZS5qc1xuLy8gbW9kdWxlIGlkID0gMzdcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///37\n");

/***/ }),
/* 38 */
/***/ (function(module, exports, __webpack_require__) {

eval("var has = __webpack_require__(1);\nvar toIObject = __webpack_require__(6);\nvar arrayIndexOf = __webpack_require__(75)(false);\nvar IE_PROTO = __webpack_require__(23)('IE_PROTO');\n\nmodule.exports = function (object, names) {\n  var O = toIObject(object);\n  var i = 0;\n  var result = [];\n  var key;\n  for (key in O) if (key != IE_PROTO) has(O, key) && result.push(key);\n  // Don't enum bug & hidden keys\n  while (names.length > i) if (has(O, key = names[i++])) {\n    ~arrayIndexOf(result, key) || result.push(key);\n  }\n  return result;\n};\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX29iamVjdC1rZXlzLWludGVybmFsLmpzPzIxYjgiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEsVUFBVSxtQkFBTyxDQUFDLENBQVE7QUFDMUIsZ0JBQWdCLG1CQUFPLENBQUMsQ0FBZTtBQUN2QyxtQkFBbUIsbUJBQU8sQ0FBQyxFQUFtQjtBQUM5QyxlQUFlLG1CQUFPLENBQUMsRUFBZTs7QUFFdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwiZmlsZSI6IjM4LmpzIiwic291cmNlc0NvbnRlbnQiOlsidmFyIGhhcyA9IHJlcXVpcmUoJy4vX2hhcycpO1xudmFyIHRvSU9iamVjdCA9IHJlcXVpcmUoJy4vX3RvLWlvYmplY3QnKTtcbnZhciBhcnJheUluZGV4T2YgPSByZXF1aXJlKCcuL19hcnJheS1pbmNsdWRlcycpKGZhbHNlKTtcbnZhciBJRV9QUk9UTyA9IHJlcXVpcmUoJy4vX3NoYXJlZC1rZXknKSgnSUVfUFJPVE8nKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAob2JqZWN0LCBuYW1lcykge1xuICB2YXIgTyA9IHRvSU9iamVjdChvYmplY3QpO1xuICB2YXIgaSA9IDA7XG4gIHZhciByZXN1bHQgPSBbXTtcbiAgdmFyIGtleTtcbiAgZm9yIChrZXkgaW4gTykgaWYgKGtleSAhPSBJRV9QUk9UTykgaGFzKE8sIGtleSkgJiYgcmVzdWx0LnB1c2goa2V5KTtcbiAgLy8gRG9uJ3QgZW51bSBidWcgJiBoaWRkZW4ga2V5c1xuICB3aGlsZSAobmFtZXMubGVuZ3RoID4gaSkgaWYgKGhhcyhPLCBrZXkgPSBuYW1lc1tpKytdKSkge1xuICAgIH5hcnJheUluZGV4T2YocmVzdWx0LCBrZXkpIHx8IHJlc3VsdC5wdXNoKGtleSk7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fb2JqZWN0LWtleXMtaW50ZXJuYWwuanNcbi8vIG1vZHVsZSBpZCA9IDM4XG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///38\n");

/***/ }),
/* 39 */
/***/ (function(module, exports) {

eval("var toString = {}.toString;\n\nmodule.exports = function (it) {\n  return toString.call(it).slice(8, -1);\n};\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2NvZi5qcz80N2QzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBLGlCQUFpQjs7QUFFakI7QUFDQTtBQUNBIiwiZmlsZSI6IjM5LmpzIiwic291cmNlc0NvbnRlbnQiOlsidmFyIHRvU3RyaW5nID0ge30udG9TdHJpbmc7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGl0KSB7XG4gIHJldHVybiB0b1N0cmluZy5jYWxsKGl0KS5zbGljZSg4LCAtMSk7XG59O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2NvZi5qc1xuLy8gbW9kdWxlIGlkID0gMzlcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///39\n");

/***/ }),
/* 40 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar LIBRARY = __webpack_require__(15);\nvar $export = __webpack_require__(17);\nvar redefine = __webpack_require__(41);\nvar hide = __webpack_require__(3);\nvar Iterators = __webpack_require__(26);\nvar $iterCreate = __webpack_require__(84);\nvar setToStringTag = __webpack_require__(27);\nvar getPrototypeOf = __webpack_require__(85);\nvar ITERATOR = __webpack_require__(7)('iterator');\nvar BUGGY = !([].keys && 'next' in [].keys()); // Safari has buggy iterators w/o `next`\nvar FF_ITERATOR = '@@iterator';\nvar KEYS = 'keys';\nvar VALUES = 'values';\n\nvar returnThis = function () { return this; };\n\nmodule.exports = function (Base, NAME, Constructor, next, DEFAULT, IS_SET, FORCED) {\n  $iterCreate(Constructor, NAME, next);\n  var getMethod = function (kind) {\n    if (!BUGGY && kind in proto) return proto[kind];\n    switch (kind) {\n      case KEYS: return function keys() { return new Constructor(this, kind); };\n      case VALUES: return function values() { return new Constructor(this, kind); };\n    } return function entries() { return new Constructor(this, kind); };\n  };\n  var TAG = NAME + ' Iterator';\n  var DEF_VALUES = DEFAULT == VALUES;\n  var VALUES_BUG = false;\n  var proto = Base.prototype;\n  var $native = proto[ITERATOR] || proto[FF_ITERATOR] || DEFAULT && proto[DEFAULT];\n  var $default = $native || getMethod(DEFAULT);\n  var $entries = DEFAULT ? !DEF_VALUES ? $default : getMethod('entries') : undefined;\n  var $anyNative = NAME == 'Array' ? proto.entries || $native : $native;\n  var methods, key, IteratorPrototype;\n  // Fix native\n  if ($anyNative) {\n    IteratorPrototype = getPrototypeOf($anyNative.call(new Base()));\n    if (IteratorPrototype !== Object.prototype && IteratorPrototype.next) {\n      // Set @@toStringTag to native iterators\n      setToStringTag(IteratorPrototype, TAG, true);\n      // fix for some old engines\n      if (!LIBRARY && typeof IteratorPrototype[ITERATOR] != 'function') hide(IteratorPrototype, ITERATOR, returnThis);\n    }\n  }\n  // fix Array#{values, @@iterator}.name in V8 / FF\n  if (DEF_VALUES && $native && $native.name !== VALUES) {\n    VALUES_BUG = true;\n    $default = function values() { return $native.call(this); };\n  }\n  // Define iterator\n  if ((!LIBRARY || FORCED) && (BUGGY || VALUES_BUG || !proto[ITERATOR])) {\n    hide(proto, ITERATOR, $default);\n  }\n  // Plug for library\n  Iterators[NAME] = $default;\n  Iterators[TAG] = returnThis;\n  if (DEFAULT) {\n    methods = {\n      values: DEF_VALUES ? $default : getMethod(VALUES),\n      keys: IS_SET ? $default : getMethod(KEYS),\n      entries: $entries\n    };\n    if (FORCED) for (key in methods) {\n      if (!(key in proto)) redefine(proto, key, methods[key]);\n    } else $export($export.P + $export.F * (BUGGY || VALUES_BUG), NAME, methods);\n  }\n  return methods;\n};\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2l0ZXItZGVmaW5lLmpzP2JjODAiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQWE7QUFDYixjQUFjLG1CQUFPLENBQUMsRUFBWTtBQUNsQyxjQUFjLG1CQUFPLENBQUMsRUFBVztBQUNqQyxlQUFlLG1CQUFPLENBQUMsRUFBYTtBQUNwQyxXQUFXLG1CQUFPLENBQUMsQ0FBUztBQUM1QixnQkFBZ0IsbUJBQU8sQ0FBQyxFQUFjO0FBQ3RDLGtCQUFrQixtQkFBTyxDQUFDLEVBQWdCO0FBQzFDLHFCQUFxQixtQkFBTyxDQUFDLEVBQXNCO0FBQ25ELHFCQUFxQixtQkFBTyxDQUFDLEVBQWU7QUFDNUMsZUFBZSxtQkFBTyxDQUFDLENBQVE7QUFDL0IsOENBQThDO0FBQzlDO0FBQ0E7QUFDQTs7QUFFQSw4QkFBOEIsYUFBYTs7QUFFM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QyxvQ0FBb0M7QUFDN0UsNkNBQTZDLG9DQUFvQztBQUNqRixLQUFLLDRCQUE0QixvQ0FBb0M7QUFDckU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixtQkFBbUI7QUFDbkM7QUFDQTtBQUNBLGtDQUFrQywyQkFBMkI7QUFDN0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBIiwiZmlsZSI6IjQwLmpzIiwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xudmFyIExJQlJBUlkgPSByZXF1aXJlKCcuL19saWJyYXJ5Jyk7XG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xudmFyIHJlZGVmaW5lID0gcmVxdWlyZSgnLi9fcmVkZWZpbmUnKTtcbnZhciBoaWRlID0gcmVxdWlyZSgnLi9faGlkZScpO1xudmFyIEl0ZXJhdG9ycyA9IHJlcXVpcmUoJy4vX2l0ZXJhdG9ycycpO1xudmFyICRpdGVyQ3JlYXRlID0gcmVxdWlyZSgnLi9faXRlci1jcmVhdGUnKTtcbnZhciBzZXRUb1N0cmluZ1RhZyA9IHJlcXVpcmUoJy4vX3NldC10by1zdHJpbmctdGFnJyk7XG52YXIgZ2V0UHJvdG90eXBlT2YgPSByZXF1aXJlKCcuL19vYmplY3QtZ3BvJyk7XG52YXIgSVRFUkFUT1IgPSByZXF1aXJlKCcuL193a3MnKSgnaXRlcmF0b3InKTtcbnZhciBCVUdHWSA9ICEoW10ua2V5cyAmJiAnbmV4dCcgaW4gW10ua2V5cygpKTsgLy8gU2FmYXJpIGhhcyBidWdneSBpdGVyYXRvcnMgdy9vIGBuZXh0YFxudmFyIEZGX0lURVJBVE9SID0gJ0BAaXRlcmF0b3InO1xudmFyIEtFWVMgPSAna2V5cyc7XG52YXIgVkFMVUVTID0gJ3ZhbHVlcyc7XG5cbnZhciByZXR1cm5UaGlzID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpczsgfTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoQmFzZSwgTkFNRSwgQ29uc3RydWN0b3IsIG5leHQsIERFRkFVTFQsIElTX1NFVCwgRk9SQ0VEKSB7XG4gICRpdGVyQ3JlYXRlKENvbnN0cnVjdG9yLCBOQU1FLCBuZXh0KTtcbiAgdmFyIGdldE1ldGhvZCA9IGZ1bmN0aW9uIChraW5kKSB7XG4gICAgaWYgKCFCVUdHWSAmJiBraW5kIGluIHByb3RvKSByZXR1cm4gcHJvdG9ba2luZF07XG4gICAgc3dpdGNoIChraW5kKSB7XG4gICAgICBjYXNlIEtFWVM6IHJldHVybiBmdW5jdGlvbiBrZXlzKCkgeyByZXR1cm4gbmV3IENvbnN0cnVjdG9yKHRoaXMsIGtpbmQpOyB9O1xuICAgICAgY2FzZSBWQUxVRVM6IHJldHVybiBmdW5jdGlvbiB2YWx1ZXMoKSB7IHJldHVybiBuZXcgQ29uc3RydWN0b3IodGhpcywga2luZCk7IH07XG4gICAgfSByZXR1cm4gZnVuY3Rpb24gZW50cmllcygpIHsgcmV0dXJuIG5ldyBDb25zdHJ1Y3Rvcih0aGlzLCBraW5kKTsgfTtcbiAgfTtcbiAgdmFyIFRBRyA9IE5BTUUgKyAnIEl0ZXJhdG9yJztcbiAgdmFyIERFRl9WQUxVRVMgPSBERUZBVUxUID09IFZBTFVFUztcbiAgdmFyIFZBTFVFU19CVUcgPSBmYWxzZTtcbiAgdmFyIHByb3RvID0gQmFzZS5wcm90b3R5cGU7XG4gIHZhciAkbmF0aXZlID0gcHJvdG9bSVRFUkFUT1JdIHx8IHByb3RvW0ZGX0lURVJBVE9SXSB8fCBERUZBVUxUICYmIHByb3RvW0RFRkFVTFRdO1xuICB2YXIgJGRlZmF1bHQgPSAkbmF0aXZlIHx8IGdldE1ldGhvZChERUZBVUxUKTtcbiAgdmFyICRlbnRyaWVzID0gREVGQVVMVCA/ICFERUZfVkFMVUVTID8gJGRlZmF1bHQgOiBnZXRNZXRob2QoJ2VudHJpZXMnKSA6IHVuZGVmaW5lZDtcbiAgdmFyICRhbnlOYXRpdmUgPSBOQU1FID09ICdBcnJheScgPyBwcm90by5lbnRyaWVzIHx8ICRuYXRpdmUgOiAkbmF0aXZlO1xuICB2YXIgbWV0aG9kcywga2V5LCBJdGVyYXRvclByb3RvdHlwZTtcbiAgLy8gRml4IG5hdGl2ZVxuICBpZiAoJGFueU5hdGl2ZSkge1xuICAgIEl0ZXJhdG9yUHJvdG90eXBlID0gZ2V0UHJvdG90eXBlT2YoJGFueU5hdGl2ZS5jYWxsKG5ldyBCYXNlKCkpKTtcbiAgICBpZiAoSXRlcmF0b3JQcm90b3R5cGUgIT09IE9iamVjdC5wcm90b3R5cGUgJiYgSXRlcmF0b3JQcm90b3R5cGUubmV4dCkge1xuICAgICAgLy8gU2V0IEBAdG9TdHJpbmdUYWcgdG8gbmF0aXZlIGl0ZXJhdG9yc1xuICAgICAgc2V0VG9TdHJpbmdUYWcoSXRlcmF0b3JQcm90b3R5cGUsIFRBRywgdHJ1ZSk7XG4gICAgICAvLyBmaXggZm9yIHNvbWUgb2xkIGVuZ2luZXNcbiAgICAgIGlmICghTElCUkFSWSAmJiB0eXBlb2YgSXRlcmF0b3JQcm90b3R5cGVbSVRFUkFUT1JdICE9ICdmdW5jdGlvbicpIGhpZGUoSXRlcmF0b3JQcm90b3R5cGUsIElURVJBVE9SLCByZXR1cm5UaGlzKTtcbiAgICB9XG4gIH1cbiAgLy8gZml4IEFycmF5I3t2YWx1ZXMsIEBAaXRlcmF0b3J9Lm5hbWUgaW4gVjggLyBGRlxuICBpZiAoREVGX1ZBTFVFUyAmJiAkbmF0aXZlICYmICRuYXRpdmUubmFtZSAhPT0gVkFMVUVTKSB7XG4gICAgVkFMVUVTX0JVRyA9IHRydWU7XG4gICAgJGRlZmF1bHQgPSBmdW5jdGlvbiB2YWx1ZXMoKSB7IHJldHVybiAkbmF0aXZlLmNhbGwodGhpcyk7IH07XG4gIH1cbiAgLy8gRGVmaW5lIGl0ZXJhdG9yXG4gIGlmICgoIUxJQlJBUlkgfHwgRk9SQ0VEKSAmJiAoQlVHR1kgfHwgVkFMVUVTX0JVRyB8fCAhcHJvdG9bSVRFUkFUT1JdKSkge1xuICAgIGhpZGUocHJvdG8sIElURVJBVE9SLCAkZGVmYXVsdCk7XG4gIH1cbiAgLy8gUGx1ZyBmb3IgbGlicmFyeVxuICBJdGVyYXRvcnNbTkFNRV0gPSAkZGVmYXVsdDtcbiAgSXRlcmF0b3JzW1RBR10gPSByZXR1cm5UaGlzO1xuICBpZiAoREVGQVVMVCkge1xuICAgIG1ldGhvZHMgPSB7XG4gICAgICB2YWx1ZXM6IERFRl9WQUxVRVMgPyAkZGVmYXVsdCA6IGdldE1ldGhvZChWQUxVRVMpLFxuICAgICAga2V5czogSVNfU0VUID8gJGRlZmF1bHQgOiBnZXRNZXRob2QoS0VZUyksXG4gICAgICBlbnRyaWVzOiAkZW50cmllc1xuICAgIH07XG4gICAgaWYgKEZPUkNFRCkgZm9yIChrZXkgaW4gbWV0aG9kcykge1xuICAgICAgaWYgKCEoa2V5IGluIHByb3RvKSkgcmVkZWZpbmUocHJvdG8sIGtleSwgbWV0aG9kc1trZXldKTtcbiAgICB9IGVsc2UgJGV4cG9ydCgkZXhwb3J0LlAgKyAkZXhwb3J0LkYgKiAoQlVHR1kgfHwgVkFMVUVTX0JVRyksIE5BTUUsIG1ldGhvZHMpO1xuICB9XG4gIHJldHVybiBtZXRob2RzO1xufTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19pdGVyLWRlZmluZS5qc1xuLy8gbW9kdWxlIGlkID0gNDBcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///40\n");

/***/ }),
/* 41 */
/***/ (function(module, exports, __webpack_require__) {

eval("module.exports = __webpack_require__(3);\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX3JlZGVmaW5lLmpzP2YzY2QiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEsaUJBQWlCLG1CQUFPLENBQUMsQ0FBUyIsImZpbGUiOiI0MS5qcyIsInNvdXJjZXNDb250ZW50IjpbIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9faGlkZScpO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX3JlZGVmaW5lLmpzXG4vLyBtb2R1bGUgaWQgPSA0MVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///41\n");

/***/ }),
/* 42 */
/***/ (function(module, exports, __webpack_require__) {

eval("// 7.1.13 ToObject(argument)\nvar defined = __webpack_require__(21);\nmodule.exports = function (it) {\n  return Object(defined(it));\n};\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX3RvLW9iamVjdC5qcz9iMDFkIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0EsY0FBYyxtQkFBTyxDQUFDLEVBQVk7QUFDbEM7QUFDQTtBQUNBIiwiZmlsZSI6IjQyLmpzIiwic291cmNlc0NvbnRlbnQiOlsiLy8gNy4xLjEzIFRvT2JqZWN0KGFyZ3VtZW50KVxudmFyIGRlZmluZWQgPSByZXF1aXJlKCcuL19kZWZpbmVkJyk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpdCkge1xuICByZXR1cm4gT2JqZWN0KGRlZmluZWQoaXQpKTtcbn07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fdG8tb2JqZWN0LmpzXG4vLyBtb2R1bGUgaWQgPSA0MlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///42\n");

/***/ }),
/* 43 */
/***/ (function(module, exports) {

eval("exports.f = Object.getOwnPropertySymbols;\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX29iamVjdC1nb3BzLmpzP2Q2NDQiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEiLCJmaWxlIjoiNDMuanMiLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnRzLmYgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX29iamVjdC1nb3BzLmpzXG4vLyBtb2R1bGUgaWQgPSA0M1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///43\n");

/***/ }),
/* 44 */
/***/ (function(module, exports, __webpack_require__) {

eval("// 19.1.2.7 / 15.2.3.4 Object.getOwnPropertyNames(O)\nvar $keys = __webpack_require__(38);\nvar hiddenKeys = __webpack_require__(25).concat('length', 'prototype');\n\nexports.f = Object.getOwnPropertyNames || function getOwnPropertyNames(O) {\n  return $keys(O, hiddenKeys);\n};\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX29iamVjdC1nb3BuLmpzPzlmNDQiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQSxZQUFZLG1CQUFPLENBQUMsRUFBeUI7QUFDN0MsaUJBQWlCLG1CQUFPLENBQUMsRUFBa0I7O0FBRTNDO0FBQ0E7QUFDQSIsImZpbGUiOiI0NC5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8vIDE5LjEuMi43IC8gMTUuMi4zLjQgT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMoTylcbnZhciAka2V5cyA9IHJlcXVpcmUoJy4vX29iamVjdC1rZXlzLWludGVybmFsJyk7XG52YXIgaGlkZGVuS2V5cyA9IHJlcXVpcmUoJy4vX2VudW0tYnVnLWtleXMnKS5jb25jYXQoJ2xlbmd0aCcsICdwcm90b3R5cGUnKTtcblxuZXhwb3J0cy5mID0gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMgfHwgZnVuY3Rpb24gZ2V0T3duUHJvcGVydHlOYW1lcyhPKSB7XG4gIHJldHVybiAka2V5cyhPLCBoaWRkZW5LZXlzKTtcbn07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fb2JqZWN0LWdvcG4uanNcbi8vIG1vZHVsZSBpZCA9IDQ0XG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///44\n");

/***/ }),
/* 45 */
/***/ (function(module, exports, __webpack_require__) {

eval("var map = {\n\t\"./doc.png\": 102,\n\t\"./docx.png\": 103,\n\t\"./other.png\": 31,\n\t\"./pdf.png\": 104,\n\t\"./ppt.png\": 105,\n\t\"./pptx.png\": 106,\n\t\"./rar.png\": 107,\n\t\"./txt.png\": 108,\n\t\"./xls.png\": 109,\n\t\"./xlsx.png\": 110,\n\t\"./zip.png\": 111\n};\nfunction webpackContext(req) {\n\treturn __webpack_require__(webpackContextResolve(req));\n};\nfunction webpackContextResolve(req) {\n\tvar id = map[req];\n\tif(!(id + 1)) // check for number or string\n\t\tthrow new Error(\"Cannot find module '\" + req + \"'.\");\n\treturn id;\n};\nwebpackContext.keys = function webpackContextKeys() {\n\treturn Object.keys(map);\n};\nwebpackContext.resolve = webpackContextResolve;\nmodule.exports = webpackContext;\nwebpackContext.id = 45;\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvYXNzZXRzL2ltYWdldmlldy9zdWZmaXggXlxcLlxcLy4qXFwucG5nJD9jN2NlIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwiZmlsZSI6IjQ1LmpzIiwic291cmNlc0NvbnRlbnQiOlsidmFyIG1hcCA9IHtcblx0XCIuL2RvYy5wbmdcIjogMTAyLFxuXHRcIi4vZG9jeC5wbmdcIjogMTAzLFxuXHRcIi4vb3RoZXIucG5nXCI6IDMxLFxuXHRcIi4vcGRmLnBuZ1wiOiAxMDQsXG5cdFwiLi9wcHQucG5nXCI6IDEwNSxcblx0XCIuL3BwdHgucG5nXCI6IDEwNixcblx0XCIuL3Jhci5wbmdcIjogMTA3LFxuXHRcIi4vdHh0LnBuZ1wiOiAxMDgsXG5cdFwiLi94bHMucG5nXCI6IDEwOSxcblx0XCIuL3hsc3gucG5nXCI6IDExMCxcblx0XCIuL3ppcC5wbmdcIjogMTExXG59O1xuZnVuY3Rpb24gd2VicGFja0NvbnRleHQocmVxKSB7XG5cdHJldHVybiBfX3dlYnBhY2tfcmVxdWlyZV9fKHdlYnBhY2tDb250ZXh0UmVzb2x2ZShyZXEpKTtcbn07XG5mdW5jdGlvbiB3ZWJwYWNrQ29udGV4dFJlc29sdmUocmVxKSB7XG5cdHZhciBpZCA9IG1hcFtyZXFdO1xuXHRpZighKGlkICsgMSkpIC8vIGNoZWNrIGZvciBudW1iZXIgb3Igc3RyaW5nXG5cdFx0dGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IGZpbmQgbW9kdWxlICdcIiArIHJlcSArIFwiJy5cIik7XG5cdHJldHVybiBpZDtcbn07XG53ZWJwYWNrQ29udGV4dC5rZXlzID0gZnVuY3Rpb24gd2VicGFja0NvbnRleHRLZXlzKCkge1xuXHRyZXR1cm4gT2JqZWN0LmtleXMobWFwKTtcbn07XG53ZWJwYWNrQ29udGV4dC5yZXNvbHZlID0gd2VicGFja0NvbnRleHRSZXNvbHZlO1xubW9kdWxlLmV4cG9ydHMgPSB3ZWJwYWNrQ29udGV4dDtcbndlYnBhY2tDb250ZXh0LmlkID0gNDU7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9zcmMvYXNzZXRzL2ltYWdldmlldy9zdWZmaXggXlxcLlxcLy4qXFwucG5nJFxuLy8gbW9kdWxlIGlkID0gNDVcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///45\n");

/***/ }),
/* 46 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("Object.defineProperty(__webpack_exports__, \"__esModule\", { value: true });\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__components_webuploader_upload__ = __webpack_require__(47);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_vue__ = __webpack_require__(113);\n\n\n\n__WEBPACK_IMPORTED_MODULE_0__components_webuploader_upload__[\"a\" /* default */].install = function (Vue) {\n  if (!Vue) {\n    window.Vue = Vue = __WEBPACK_IMPORTED_MODULE_1_vue__[\"a\" /* default */];\n  }\n  Vue.component(__WEBPACK_IMPORTED_MODULE_0__components_webuploader_upload__[\"a\" /* default */].name, __WEBPACK_IMPORTED_MODULE_0__components_webuploader_upload__[\"a\" /* default */]);\n};\n/* harmony default export */ __webpack_exports__[\"default\"] = (__WEBPACK_IMPORTED_MODULE_0__components_webuploader_upload__[\"a\" /* default */]);\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9pbmRleC5qcz8yNjQ1Il0sIm5hbWVzIjpbIkZpbGVVcGxvYWQiLCJpbnN0YWxsIiwiVnVlIiwid2luZG93IiwiX1Z1ZSIsImNvbXBvbmVudCIsIm5hbWUiXSwibWFwcGluZ3MiOiJBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7O0FBRUFBLCtFQUFVQSxDQUFDQyxPQUFYLEdBQXFCLGVBQU87QUFDNUIsTUFBSSxDQUFDQyxHQUFMLEVBQVU7QUFDVkMsV0FBT0QsR0FBUCxHQUFhQSxNQUFNRSxvREFBbkI7QUFDQztBQUNERixNQUFJRyxTQUFKLENBQWNMLCtFQUFVQSxDQUFDTSxJQUF6QixFQUErQk4sK0VBQS9CO0FBQ0MsQ0FMRDtBQU1lQSw4SUFBZiIsImZpbGUiOiI0Ni5qcyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBGaWxlVXBsb2FkIGZyb20gJ0AvY29tcG9uZW50cy93ZWJ1cGxvYWRlci91cGxvYWQnXHJcbmltcG9ydCBfVnVlIGZyb20gJ3Z1ZSdcclxuXHJcbkZpbGVVcGxvYWQuaW5zdGFsbCA9IFZ1ZSA9PiB7XHJcbmlmICghVnVlKSB7XHJcbndpbmRvdy5WdWUgPSBWdWUgPSBfVnVlXHJcbn1cclxuVnVlLmNvbXBvbmVudChGaWxlVXBsb2FkLm5hbWUsIEZpbGVVcGxvYWQpXHJcbn1cclxuZXhwb3J0IGRlZmF1bHQgRmlsZVVwbG9hZDtcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9pbmRleC5qcyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///46\n");

/***/ }),
/* 47 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__babel_loader_node_modules_vue_loader_lib_selector_type_script_index_0_upload_vue__ = __webpack_require__(33);\n/* unused harmony namespace reexport */\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__node_modules_vue_loader_lib_template_compiler_index_id_data_v_3151a9fe_hasScoped_true_buble_transforms_node_modules_vue_loader_lib_selector_type_template_index_0_upload_vue__ = __webpack_require__(112);\nvar disposed = false\nfunction injectStyle (ssrContext) {\n  if (disposed) return\n  __webpack_require__(48)\n}\nvar normalizeComponent = __webpack_require__(51)\n/* script */\n\n\n/* template */\n\n/* template functional */\nvar __vue_template_functional__ = false\n/* styles */\nvar __vue_styles__ = injectStyle\n/* scopeId */\nvar __vue_scopeId__ = \"data-v-3151a9fe\"\n/* moduleIdentifier (server only) */\nvar __vue_module_identifier__ = null\nvar Component = normalizeComponent(\n  __WEBPACK_IMPORTED_MODULE_0__babel_loader_node_modules_vue_loader_lib_selector_type_script_index_0_upload_vue__[\"a\" /* default */],\n  __WEBPACK_IMPORTED_MODULE_1__node_modules_vue_loader_lib_template_compiler_index_id_data_v_3151a9fe_hasScoped_true_buble_transforms_node_modules_vue_loader_lib_selector_type_template_index_0_upload_vue__[\"a\" /* default */],\n  __vue_template_functional__,\n  __vue_styles__,\n  __vue_scopeId__,\n  __vue_module_identifier__\n)\nComponent.options.__file = \"src/components/webuploader/upload.vue\"\n\n/* hot reload */\nif (false) {(function () {\n  var hotAPI = require(\"vue-hot-reload-api\")\n  hotAPI.install(require(\"vue\"), false)\n  if (!hotAPI.compatible) return\n  module.hot.accept()\n  if (!module.hot.data) {\n    hotAPI.createRecord(\"data-v-3151a9fe\", Component.options)\n  } else {\n    hotAPI.reload(\"data-v-3151a9fe\", Component.options)\n  }\n  module.hot.dispose(function (data) {\n    disposed = true\n  })\n})()}\n\n/* harmony default export */ __webpack_exports__[\"a\"] = (Component.exports);\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvY29tcG9uZW50cy93ZWJ1cGxvYWRlci91cGxvYWQudnVlP2FmODgiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0EsRUFBRSxtQkFBTyxDQUFDLEVBQXNRO0FBQ2hSO0FBQ0EseUJBQXlCLG1CQUFPLENBQUMsRUFBNEQ7QUFDN0Y7QUFDNkc7QUFDYTtBQUMxSDtBQUM0UDtBQUM1UDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFLGtJQUFjO0FBQ2hCLEVBQUUsOE5BQWdCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLElBQUksS0FBVSxHQUFHO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxDQUFDOztBQUVjLDBFQUFpQiIsImZpbGUiOiI0Ny5qcyIsInNvdXJjZXNDb250ZW50IjpbInZhciBkaXNwb3NlZCA9IGZhbHNlXG5mdW5jdGlvbiBpbmplY3RTdHlsZSAoc3NyQ29udGV4dCkge1xuICBpZiAoZGlzcG9zZWQpIHJldHVyblxuICByZXF1aXJlKFwiISF2dWUtc3R5bGUtbG9hZGVyIWNzcy1sb2FkZXI/c291cmNlTWFwIS4uLy4uLy4uL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9zdHlsZS1jb21waWxlci9pbmRleD97XFxcInZ1ZVxcXCI6dHJ1ZSxcXFwiaWRcXFwiOlxcXCJkYXRhLXYtMzE1MWE5ZmVcXFwiLFxcXCJzY29wZWRcXFwiOnRydWUsXFxcImhhc0lubGluZUNvbmZpZ1xcXCI6ZmFsc2V9IS4uLy4uLy4uL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9zZWxlY3Rvcj90eXBlPXN0eWxlcyZpbmRleD0wIS4vdXBsb2FkLnZ1ZVwiKVxufVxudmFyIG5vcm1hbGl6ZUNvbXBvbmVudCA9IHJlcXVpcmUoXCIhLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL2NvbXBvbmVudC1ub3JtYWxpemVyXCIpXG4vKiBzY3JpcHQgKi9cbmV4cG9ydCAqIGZyb20gXCIhIWJhYmVsLWxvYWRlciEuLi8uLi8uLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvc2VsZWN0b3I/dHlwZT1zY3JpcHQmaW5kZXg9MCEuL3VwbG9hZC52dWVcIlxuaW1wb3J0IF9fdnVlX3NjcmlwdF9fIGZyb20gXCIhIWJhYmVsLWxvYWRlciEuLi8uLi8uLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvc2VsZWN0b3I/dHlwZT1zY3JpcHQmaW5kZXg9MCEuL3VwbG9hZC52dWVcIlxuLyogdGVtcGxhdGUgKi9cbmltcG9ydCBfX3Z1ZV90ZW1wbGF0ZV9fIGZyb20gXCIhIS4uLy4uLy4uL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi90ZW1wbGF0ZS1jb21waWxlci9pbmRleD97XFxcImlkXFxcIjpcXFwiZGF0YS12LTMxNTFhOWZlXFxcIixcXFwiaGFzU2NvcGVkXFxcIjp0cnVlLFxcXCJidWJsZVxcXCI6e1xcXCJ0cmFuc2Zvcm1zXFxcIjp7fX19IS4uLy4uLy4uL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9zZWxlY3Rvcj90eXBlPXRlbXBsYXRlJmluZGV4PTAhLi91cGxvYWQudnVlXCJcbi8qIHRlbXBsYXRlIGZ1bmN0aW9uYWwgKi9cbnZhciBfX3Z1ZV90ZW1wbGF0ZV9mdW5jdGlvbmFsX18gPSBmYWxzZVxuLyogc3R5bGVzICovXG52YXIgX192dWVfc3R5bGVzX18gPSBpbmplY3RTdHlsZVxuLyogc2NvcGVJZCAqL1xudmFyIF9fdnVlX3Njb3BlSWRfXyA9IFwiZGF0YS12LTMxNTFhOWZlXCJcbi8qIG1vZHVsZUlkZW50aWZpZXIgKHNlcnZlciBvbmx5KSAqL1xudmFyIF9fdnVlX21vZHVsZV9pZGVudGlmaWVyX18gPSBudWxsXG52YXIgQ29tcG9uZW50ID0gbm9ybWFsaXplQ29tcG9uZW50KFxuICBfX3Z1ZV9zY3JpcHRfXyxcbiAgX192dWVfdGVtcGxhdGVfXyxcbiAgX192dWVfdGVtcGxhdGVfZnVuY3Rpb25hbF9fLFxuICBfX3Z1ZV9zdHlsZXNfXyxcbiAgX192dWVfc2NvcGVJZF9fLFxuICBfX3Z1ZV9tb2R1bGVfaWRlbnRpZmllcl9fXG4pXG5Db21wb25lbnQub3B0aW9ucy5fX2ZpbGUgPSBcInNyYy9jb21wb25lbnRzL3dlYnVwbG9hZGVyL3VwbG9hZC52dWVcIlxuXG4vKiBob3QgcmVsb2FkICovXG5pZiAobW9kdWxlLmhvdCkgeyhmdW5jdGlvbiAoKSB7XG4gIHZhciBob3RBUEkgPSByZXF1aXJlKFwidnVlLWhvdC1yZWxvYWQtYXBpXCIpXG4gIGhvdEFQSS5pbnN0YWxsKHJlcXVpcmUoXCJ2dWVcIiksIGZhbHNlKVxuICBpZiAoIWhvdEFQSS5jb21wYXRpYmxlKSByZXR1cm5cbiAgbW9kdWxlLmhvdC5hY2NlcHQoKVxuICBpZiAoIW1vZHVsZS5ob3QuZGF0YSkge1xuICAgIGhvdEFQSS5jcmVhdGVSZWNvcmQoXCJkYXRhLXYtMzE1MWE5ZmVcIiwgQ29tcG9uZW50Lm9wdGlvbnMpXG4gIH0gZWxzZSB7XG4gICAgaG90QVBJLnJlbG9hZChcImRhdGEtdi0zMTUxYTlmZVwiLCBDb21wb25lbnQub3B0aW9ucylcbiAgfVxuICBtb2R1bGUuaG90LmRpc3Bvc2UoZnVuY3Rpb24gKGRhdGEpIHtcbiAgICBkaXNwb3NlZCA9IHRydWVcbiAgfSlcbn0pKCl9XG5cbmV4cG9ydCBkZWZhdWx0IENvbXBvbmVudC5leHBvcnRzXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL3NyYy9jb21wb25lbnRzL3dlYnVwbG9hZGVyL3VwbG9hZC52dWVcbi8vIG1vZHVsZSBpZCA9IDQ3XG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///47\n");

/***/ }),
/* 48 */
/***/ (function(module, exports, __webpack_require__) {

eval("// style-loader: Adds some css to the DOM by adding a <style> tag\n\n// load the styles\nvar content = __webpack_require__(49);\nif(typeof content === 'string') content = [[module.i, content, '']];\nif(content.locals) module.exports = content.locals;\n// add the styles to the DOM\nvar update = __webpack_require__(10)(\"39c02478\", content, false, {});\n// Hot Module Replacement\nif(false) {\n // When the styles change, update the <style> tags\n if(!content.locals) {\n   module.hot.accept(\"!!../../../node_modules/css-loader/index.js?sourceMap!../../../node_modules/vue-loader/lib/style-compiler/index.js?{\\\"vue\\\":true,\\\"id\\\":\\\"data-v-3151a9fe\\\",\\\"scoped\\\":true,\\\"hasInlineConfig\\\":false}!../../../node_modules/vue-loader/lib/selector.js?type=styles&index=0!./upload.vue\", function() {\n     var newContent = require(\"!!../../../node_modules/css-loader/index.js?sourceMap!../../../node_modules/vue-loader/lib/style-compiler/index.js?{\\\"vue\\\":true,\\\"id\\\":\\\"data-v-3151a9fe\\\",\\\"scoped\\\":true,\\\"hasInlineConfig\\\":false}!../../../node_modules/vue-loader/lib/selector.js?type=styles&index=0!./upload.vue\");\n     if(typeof newContent === 'string') newContent = [[module.id, newContent, '']];\n     update(newContent);\n   });\n }\n // When the module is disposed, remove the <style> tags\n module.hot.dispose(function() { update(); });\n}\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvY29tcG9uZW50cy93ZWJ1cGxvYWRlci91cGxvYWQudnVlP2RkOTAiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7O0FBRUE7QUFDQSxjQUFjLG1CQUFPLENBQUMsRUFBMFI7QUFDaFQsNENBQTRDLFFBQVM7QUFDckQ7QUFDQTtBQUNBLGFBQWEsbUJBQU8sQ0FBQyxFQUFnRSxnQ0FBZ0M7QUFDckg7QUFDQSxHQUFHLEtBQVU7QUFDYjtBQUNBO0FBQ0EsMElBQTBJLGtGQUFrRjtBQUM1TixtSkFBbUosa0ZBQWtGO0FBQ3JPO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLGdDQUFnQyxVQUFVLEVBQUU7QUFDNUMiLCJmaWxlIjoiNDguanMiLCJzb3VyY2VzQ29udGVudCI6WyIvLyBzdHlsZS1sb2FkZXI6IEFkZHMgc29tZSBjc3MgdG8gdGhlIERPTSBieSBhZGRpbmcgYSA8c3R5bGU+IHRhZ1xuXG4vLyBsb2FkIHRoZSBzdHlsZXNcbnZhciBjb250ZW50ID0gcmVxdWlyZShcIiEhLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvaW5kZXguanM/c291cmNlTWFwIS4uLy4uLy4uL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9zdHlsZS1jb21waWxlci9pbmRleC5qcz97XFxcInZ1ZVxcXCI6dHJ1ZSxcXFwiaWRcXFwiOlxcXCJkYXRhLXYtMzE1MWE5ZmVcXFwiLFxcXCJzY29wZWRcXFwiOnRydWUsXFxcImhhc0lubGluZUNvbmZpZ1xcXCI6ZmFsc2V9IS4uLy4uLy4uL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9zZWxlY3Rvci5qcz90eXBlPXN0eWxlcyZpbmRleD0wIS4vdXBsb2FkLnZ1ZVwiKTtcbmlmKHR5cGVvZiBjb250ZW50ID09PSAnc3RyaW5nJykgY29udGVudCA9IFtbbW9kdWxlLmlkLCBjb250ZW50LCAnJ11dO1xuaWYoY29udGVudC5sb2NhbHMpIG1vZHVsZS5leHBvcnRzID0gY29udGVudC5sb2NhbHM7XG4vLyBhZGQgdGhlIHN0eWxlcyB0byB0aGUgRE9NXG52YXIgdXBkYXRlID0gcmVxdWlyZShcIiEuLi8uLi8uLi9ub2RlX21vZHVsZXMvdnVlLXN0eWxlLWxvYWRlci9saWIvYWRkU3R5bGVzQ2xpZW50LmpzXCIpKFwiMzljMDI0NzhcIiwgY29udGVudCwgZmFsc2UsIHt9KTtcbi8vIEhvdCBNb2R1bGUgUmVwbGFjZW1lbnRcbmlmKG1vZHVsZS5ob3QpIHtcbiAvLyBXaGVuIHRoZSBzdHlsZXMgY2hhbmdlLCB1cGRhdGUgdGhlIDxzdHlsZT4gdGFnc1xuIGlmKCFjb250ZW50LmxvY2Fscykge1xuICAgbW9kdWxlLmhvdC5hY2NlcHQoXCIhIS4uLy4uLy4uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2luZGV4LmpzP3NvdXJjZU1hcCEuLi8uLi8uLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvc3R5bGUtY29tcGlsZXIvaW5kZXguanM/e1xcXCJ2dWVcXFwiOnRydWUsXFxcImlkXFxcIjpcXFwiZGF0YS12LTMxNTFhOWZlXFxcIixcXFwic2NvcGVkXFxcIjp0cnVlLFxcXCJoYXNJbmxpbmVDb25maWdcXFwiOmZhbHNlfSEuLi8uLi8uLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvc2VsZWN0b3IuanM/dHlwZT1zdHlsZXMmaW5kZXg9MCEuL3VwbG9hZC52dWVcIiwgZnVuY3Rpb24oKSB7XG4gICAgIHZhciBuZXdDb250ZW50ID0gcmVxdWlyZShcIiEhLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvaW5kZXguanM/c291cmNlTWFwIS4uLy4uLy4uL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9zdHlsZS1jb21waWxlci9pbmRleC5qcz97XFxcInZ1ZVxcXCI6dHJ1ZSxcXFwiaWRcXFwiOlxcXCJkYXRhLXYtMzE1MWE5ZmVcXFwiLFxcXCJzY29wZWRcXFwiOnRydWUsXFxcImhhc0lubGluZUNvbmZpZ1xcXCI6ZmFsc2V9IS4uLy4uLy4uL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9zZWxlY3Rvci5qcz90eXBlPXN0eWxlcyZpbmRleD0wIS4vdXBsb2FkLnZ1ZVwiKTtcbiAgICAgaWYodHlwZW9mIG5ld0NvbnRlbnQgPT09ICdzdHJpbmcnKSBuZXdDb250ZW50ID0gW1ttb2R1bGUuaWQsIG5ld0NvbnRlbnQsICcnXV07XG4gICAgIHVwZGF0ZShuZXdDb250ZW50KTtcbiAgIH0pO1xuIH1cbiAvLyBXaGVuIHRoZSBtb2R1bGUgaXMgZGlzcG9zZWQsIHJlbW92ZSB0aGUgPHN0eWxlPiB0YWdzXG4gbW9kdWxlLmhvdC5kaXNwb3NlKGZ1bmN0aW9uKCkgeyB1cGRhdGUoKTsgfSk7XG59XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvdnVlLXN0eWxlLWxvYWRlciEuL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyP3NvdXJjZU1hcCEuL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9zdHlsZS1jb21waWxlcj97XCJ2dWVcIjp0cnVlLFwiaWRcIjpcImRhdGEtdi0zMTUxYTlmZVwiLFwic2NvcGVkXCI6dHJ1ZSxcImhhc0lubGluZUNvbmZpZ1wiOmZhbHNlfSEuL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9zZWxlY3Rvci5qcz90eXBlPXN0eWxlcyZpbmRleD0wIS4vc3JjL2NvbXBvbmVudHMvd2VidXBsb2FkZXIvdXBsb2FkLnZ1ZVxuLy8gbW9kdWxlIGlkID0gNDhcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///48\n");

/***/ }),
/* 49 */
/***/ (function(module, exports, __webpack_require__) {

eval("exports = module.exports = __webpack_require__(9)(true);\n// imports\n\n\n// module\nexports.push([module.i, \"\\n.tab-view div[data-v-3151a9fe]{\\n  padding: 0 20px;\\n  cursor: pointer;\\n}\\n.tab-view .tab-active[data-v-3151a9fe]{\\n  border-bottom: 2px solid #1094fa;\\n}\\n\", \"\", {\"version\":3,\"sources\":[\"E:/webwork/vuecomponents/FileUpload/src/components/webuploader/src/components/webuploader/upload.vue\"],\"names\":[],\"mappings\":\";AAs5BA;EACA,gBAAA;EACA,gBAAA;CACA;AACA;EACA,iCAAA;CACA\",\"file\":\"upload.vue\",\"sourcesContent\":[\"<template>\\r\\n  <div>\\r\\n    <div class=\\\"page-container\\\">\\r\\n      <div id=\\\"uploader\\\">\\r\\n        <div class=\\\"statusBar\\\" style=\\\"display:none\\\">\\r\\n          <div class=\\\"tab-view\\\">\\r\\n            <div ref=\\\"detailView\\\" style=\\\"float:left\\\" class=\\\"tab-active\\\" @click=\\\"tabChange('detailView')\\\">分类展示\\r\\n              {{ CNodeImgeCount }}\\r\\n            </div>\\r\\n            <div v-if=\\\"uploadprops.config.shwoAlllist\\\" ref=\\\"allView\\\" style=\\\"float:left\\\" @click=\\\"tabChange('allView')\\\">全部展示{{ AllImgeCount }}</div>\\r\\n            <div style=\\\"clear:both\\\"/>\\r\\n          </div>\\r\\n          <div class=\\\"btns\\\">\\r\\n            <div class=\\\"progress\\\">\\r\\n              <span class=\\\"text\\\">0%</span>\\r\\n              <span class=\\\"percentage\\\"/>\\r\\n            </div>\\r\\n            <div class=\\\"info\\\">共 5 张</div>\\r\\n            <div id=\\\"filePicker2\\\"/>\\r\\n            <div class=\\\"uploadBtn\\\">开始上传</div>\\r\\n          </div>\\r\\n        </div>\\r\\n        <div class=\\\"queueList\\\">\\r\\n          <div id=\\\"dndArea\\\" class=\\\"placeholder\\\">\\r\\n            <div id=\\\"filePicker\\\"/>\\r\\n            <p>或将照片拖到这里{{ currentNode }}</p>\\r\\n          </div>\\r\\n          <ul class=\\\"filelist\\\" style=\\\"height: 135px;\\\"/>\\r\\n        </div>\\r\\n        <div class=\\\"queueAllList\\\"/>\\r\\n      </div>\\r\\n    </div>\\r\\n  </div>\\r\\n</template>\\r\\n<script>\\r\\nimport Util from '@/utils/util.js'\\r\\nrequire('@/components/webuploader/css/demo.css')\\r\\nrequire('@/components/webuploader/css/style.css')\\r\\nrequire('@/components/webuploader/webuploader-0.1.5/webuploader.css')\\r\\nvar $ = require('jquery')\\r\\nwindow.$ = $\\r\\nwindow.jQuery = $\\r\\nrequire('@/components/webuploader/webuploader-0.1.5/webuploader.js')\\r\\n\\r\\n$(function () {})\\r\\nexport default {\\r\\n  name: 'FileUpload',\\r\\n  props: {\\r\\n    currentNode: {// 当前选中分类\\r\\n      type: String,\\r\\n      default: ''\\r\\n    },\\r\\n    initfiles: {// 初始文件信息\\r\\n      type: Array,\\r\\n      default: function () {\\r\\n        return []\\r\\n      }\\r\\n    },\\r\\n    uploadprops: {\\r\\n      type: Object,\\r\\n      default: function () {\\r\\n        return {\\r\\n          config: {\\r\\n            thumbWidth: 125, // 缩略图宽度，可省略，默认为110\\r\\n            thumbHeight: 125, // 缩略图高度，可省略，默认为110\\r\\n            wrapId: 'uploader', // 必填\\r\\n            shwoAlllist: false, // 是否显示全部图片标签页\\r\\n            fileformat: 'gif,jpg,jpeg,png,zip,pdf,xlsx,xls,doc,docx,ppt,rar'// 允许上传的文件格式\\r\\n          },\\r\\n          // 处理客户端新文件上传时，需要调用后台处理的地址, 必填\\r\\n          uploadUrl: '',\\r\\n          // 处理客户端原有文件更新时的后台处理地址，必填\\r\\n          updateUrl: '',\\r\\n          // 当客户端原有文件删除时的后台处理地址，必填\\r\\n          removeUrl: '',\\r\\n          // 初始化客户端上传文件，从后台获取文件的地址, 可选，当此参数为空时，默认已上传的文件为空\\r\\n          initUrl: ''\\r\\n        }\\r\\n      }\\r\\n    }\\r\\n  },\\r\\n  data () {\\r\\n    return {\\r\\n      vchrInfo: {},\\r\\n      CNodeImgeCount: 0,\\r\\n      AllImgeCount: 0\\r\\n    }\\r\\n  },\\r\\n  watch: {\\r\\n    currentNode: function (newval, oldval) {\\r\\n      if (newval === '0') {\\r\\n        this.tabChange('allView')\\r\\n      } else {\\r\\n        this.tabChange('detailView')\\r\\n      }\\r\\n      this.showImglist(newval)\\r\\n      this.updataImgCount()\\r\\n    }\\r\\n  },\\r\\n  mounted: function () {\\r\\n    // require('@/components/webuploader/webuploader-0.1.5/extend-webuploader.js')\\r\\n    // 获取url上的参数\\r\\n    var _this = this\\r\\n    _this.initWebUploader()\\r\\n    window.onresize = function () {\\r\\n      _this.showImglist(_this.currentNode)\\r\\n    }\\r\\n  },\\r\\n  methods: {\\r\\n    initWebUploader: function () {\\r\\n      var _this = this\\r\\n      /* eslint-disable */\\r\\n      if (!this.uploadprops) {\\r\\n        console.log(\\\"请配置好_this.uploadprops\\\");\\r\\n        $(\\\"#dndArea p\\\").html(\\\"请配置好uploadprops\\\");\\r\\n        return false;\\r\\n      }\\r\\n      if (!this.uploadprops.config || !this.uploadprops.config.wrapId) {\\r\\n        console.log(\\\"请配置好uploadprops.config.wrapId\\\");\\r\\n        $(\\\"#dndArea p\\\").html(\\\"请配置好uploadprops.config.wrapId\\\");\\r\\n        return false;\\r\\n      }\\r\\n      if (!_this.uploadprops.uploadUrl) {\\r\\n        console.log(\\\"请配置好_this.uploadprops.uploadUrl\\\");\\r\\n        $(\\\"#dndArea p\\\").html(\\\"请配置好uploadprops.uploadUrl\\\");\\r\\n        return false;\\r\\n      }\\r\\n      if (!_this.uploadprops.updateUrl) {\\r\\n        console.log(\\\"请配置好_this.uploadprops.updateUrl\\\");\\r\\n        $(\\\"#dndArea p\\\").html(\\\"请配置好uploadprops.updateUrl\\\");\\r\\n        return false;\\r\\n      }\\r\\n      if (!_this.uploadprops.removeUrl) {\\r\\n        console.log(\\\"请配置好_this.uploadprops.removeUrl\\\");\\r\\n        $(\\\"#dndArea p\\\").html(\\\"请配置好uploadprops.removeUrl\\\");\\r\\n        return false;\\r\\n      }\\r\\n      var disX = 0;\\r\\n      var disY = 0;\\r\\n      var minZindex = 1;\\r\\n      var origin;\\r\\n      var is_moveing = false;\\r\\n      var $wrap = $(\\\"#\\\" + _this.uploadprops.config.wrapId);\\r\\n      /* var $queue = $('<ul class=\\\"filelist\\\"></ul>').appendTo(\\r\\n        $wrap.find(\\\".queueList\\\")\\r\\n      ); */\\r\\n      var $queue = $(\\\".filelist\\\");\\r\\n      var $statusBar = $wrap.find(\\\".statusBar\\\");\\r\\n      var $info = $statusBar.find(\\\".info\\\");\\r\\n      var $upload = $wrap.find(\\\".uploadBtn\\\");\\r\\n      var $placeHolder = $wrap.find(\\\".placeholder\\\");\\r\\n      var $progress = $statusBar.find(\\\".progress\\\").hide();\\r\\n      var fileCount = 0;\\r\\n      var fileSize = 0;\\r\\n      var state = \\\"pedding\\\";\\r\\n      var percentages = {};\\r\\n      var supportTransition = (function() {\\r\\n        var s = document.createElement(\\\"p\\\").style,\\r\\n          r =\\r\\n            \\\"transition\\\" in s ||\\r\\n            \\\"WebkitTransition\\\" in s ||\\r\\n            \\\"MozTransition\\\" in s ||\\r\\n            \\\"msTransition\\\" in s ||\\r\\n            \\\"OTransition\\\" in s;\\r\\n        s = null;\\r\\n        //return r;  //暂时先写死  以后遇到问题再调试 wqd\\r\\n        return true\\r\\n      })();\\r\\n      // 优化retina, 在retina下这个值是2\\r\\n      var ratio = window.devicePixelRatio || 1;\\r\\n      // 缩略图大小\\r\\n      var thumbnailWidth = _this.uploadprops.config.thumbWidth || 110;\\r\\n      thumbnailWidth *= ratio;\\r\\n      var thumbnailHeight = _this.uploadprops.config.thumbHeight || 110;\\r\\n      thumbnailHeight *= ratio;\\r\\n      var uploader = WebUploader.create({\\r\\n        swf: \\\"http://cdn.staticfile.org/webuploader/0.1.0/Uploader.swf\\\", //require('@/components/webuploader/webuploader-0.1.5/Uploader.swf')\\r\\n        server: _this.uploadprops.uploadUrl,\\r\\n        pick: {\\r\\n          id: \\\"#filePicker\\\",\\r\\n          label: \\\"点击选择图片\\\"\\r\\n        },\\r\\n        dnd: \\\".queueList\\\",\\r\\n        paste: document.body,\\r\\n        accept: {\\r\\n          title: \\\"Images\\\",\\r\\n          extensions: _this.uploadprops.config.fileformat,\\r\\n          mimeTypes: \\\"*\\\"\\r\\n        },\\r\\n        resize: false,\\r\\n        disableGlobalDnd: true,\\r\\n        chunked: true,\\r\\n        fileNumLimit: 9999\\r\\n      });\\r\\n\\r\\n      function setDragEvent() {\\r\\n        $(this).on(\\\"drop\\\", function(e) {\\r\\n          var $from = $(origin).parents(\\\"li\\\");\\r\\n          var $to = $(e.target).parents(\\\"li\\\");\\r\\n          var origin_pos = $from.position();\\r\\n          var target_pos = $to.position();\\r\\n          var from_sort = $from.attr(\\\"data-sort\\\");\\r\\n          var to_sort = $to.attr(\\\"data-sort\\\");\\r\\n\\r\\n          $from.addClass(\\\"move\\\").animate(target_pos, \\\"fast\\\", function() {\\r\\n            $(this).removeClass(\\\"move\\\");\\r\\n          }).attr(\\\"data-sort\\\", to_sort);\\r\\n\\r\\n          $to.addClass(\\\"move\\\").animate(origin_pos, \\\"fast\\\", function() {\\r\\n            $(this).removeClass(\\\"move\\\");\\r\\n          }).attr(\\\"data-sort\\\", from_sort);\\r\\n        })\\r\\n          .on(\\\"dragstart\\\", function(e) {\\r\\n            if (is_moveing) {\\r\\n              return false;\\r\\n            }\\r\\n            is_moveing = true;\\r\\n            e.originalEvent.dataTransfer.effectAllowd = \\\"move\\\";\\r\\n            origin = this;\\r\\n          })\\r\\n          .on(\\\"dragover\\\", function(e) {\\r\\n            if (e.preventDefault) e.preventDefault();\\r\\n            is_moveing = false;\\r\\n            e.originalEvent.dataTransfer.dropEffect = \\\"move\\\";\\r\\n          });\\r\\n      }\\r\\n\\r\\n      //更新服务端附件\\r\\n      function updateServerFiles() {\\r\\n        var postData = {};\\r\\n        $('[data-src=\\\"server\\\"]').each(function(index, obj) {\\r\\n          postData[$(obj).attr(\\\"data-key\\\")] = $(obj).attr(\\\"data-sort\\\");\\r\\n        });\\r\\n        $.ajax({\\r\\n          type: \\\"post\\\",\\r\\n          url: _this.uploadprops.updateUrl,\\r\\n          data: postData,\\r\\n          dataType: \\\"json\\\",\\r\\n          success: function(data) {\\r\\n            //setState('finish');\\r\\n            alert(\\\"更新成功\\\");\\r\\n            $upload.removeClass(\\\"disabled\\\");\\r\\n            setState(\\\"ready\\\");\\r\\n            uploader.reset();\\r\\n          }\\r\\n        });\\r\\n      }\\r\\n\\r\\n      //删除服务端附件\\r\\n      function removeServerFile(file,data,a,b) {\\r\\n        var sendData = {\\r\\n          'service': 'ImgCommonService',\\r\\n          'method': 'deleteImage',\\r\\n          'F_IMG_INFOS': [\\r\\n            {\\r\\n              'F_PKEY': file.F_PKEY,\\r\\n            }\\r\\n          ]\\r\\n        }\\r\\n        $.ajax({\\r\\n          url: process.env.BASE_API + '/commAction.do',\\r\\n          type: 'POST',\\r\\n          data: { jsondata: JSON.stringify(sendData) },\\r\\n          dataType: 'json',\\r\\n          async: false,\\r\\n          success: function(data) {\\r\\n            if (data.F_CODE === '0') {\\r\\n              fileCount--;\\r\\n              updateStatus();\\r\\n            }\\r\\n            var text = data.F_MESSAGE\\r\\n            _this.$info({\\r\\n              title: '提示',\\r\\n              okText: '确认',\\r\\n              content: text\\r\\n            })\\r\\n            // _this.$router.go(0) // 刷新当前页面\\r\\n          }\\r\\n        })\\r\\n        /* $.ajax({\\r\\n          type: \\\"get\\\",\\r\\n          url: _this.uploadprops.removeUrl,\\r\\n          data: { id: file.name },\\r\\n          dataType: \\\"json\\\",\\r\\n          success: function(data) {\\r\\n            fileCount--;\\r\\n            updateStatus();\\r\\n          }\\r\\n        }); */\\r\\n      }\\r\\n\\r\\n      //初始化服务端附件\\r\\n      function initServerFile() {\\r\\n        if (_this.uploadprops.initUrl) {\\r\\n          $.each(_this.initfiles,function(k,fl){\\r\\n            $.each(fl.F_ATTACHS,function(index,file){\\r\\n              file.F_FILE_TP = file.F_FILE_TP.toLowerCase()\\r\\n              var src = \\\"\\\"//图片地址\\r\\n              try {\\r\\n                src = $.inArray(file.F_FILE_TP, Util.imgSuffix) !== -1?Util.createImgUrl(file.F_ATT_STO_KEY):require('@/assets/imageview/suffix/' + file.F_FILE_TP + '.png')\\r\\n              } catch (error) {\\r\\n                src = $.inArray(file.F_FILE_TP, Util.imgSuffix) !== -1?Util.createImgUrl(file.F_ATT_STO_KEY):require('@/assets/imageview/suffix/other.png')\\r\\n              }\\r\\n              var obj  = {\\r\\n                id:\\\"SVR_FILE_\\\" + index,\\r\\n                src:'server',\\r\\n                name:file.F_ATT_TITLE,\\r\\n                path : src,\\r\\n                rotation:0,\\r\\n                size:parseFloat(file.F_ATT_SIZE),\\r\\n                type:file.F_FILE_TP,\\r\\n                F_FILE_TP:file.F_FILE_TP,\\r\\n                F_PKEY:file.F_PKEY,\\r\\n                F_PARENT:file.F_PARENT,\\r\\n                F_IMG_CODE:fl.F_IMG_CODE,\\r\\n                F_ROTATE:fl.F_ROTATE//旋转度数\\r\\n              }\\r\\n              fileQueue(obj);\\r\\n            })\\r\\n          })\\r\\n          _this.showImglist(_this.currentNode)\\r\\n          /* var len = data.length;\\r\\n              for (var i = 0; i < len; i++) {\\r\\n                data[i].src = \\\"server\\\";\\r\\n                data[i].id = \\\"SVR_FILE_\\\" + i;\\r\\n                data[i].rotation = 0;\\r\\n                fileQueue(data[i]);\\r\\n              } */\\r\\n        }\\r\\n      }\\r\\n\\r\\n      //添加附件到webuploader中\\r\\n      function addFile(file) {\\r\\n        var datatype = _this.currentNode\\r\\n        file.F_ROTATE = file.F_ROTATE||0\\r\\n        if(file.src === 'server'){\\r\\n          datatype = file.F_PARENT\\r\\n        }else{\\r\\n          file.F_IMG_TYPE = datatype\\r\\n        }\\r\\n        $.each(_this.initfiles,function(k,v){\\r\\n          if(v.key === datatype){\\r\\n            file.F_IMG_CODE = v.F_IMG_CODE\\r\\n          }\\r\\n        })\\r\\n        var index = $queue.find(\\\"li[data-type='\\\" + datatype + \\\"']\\\").length;\\r\\n        /* var imgLeft = index * (thumbnailWidth + 10);\\r\\n        var imgTop = 0;\\r\\n        var wrapHeight = thumbnailHeight + 20;\\r\\n        var wrapWidth = $queue.width();\\r\\n        if (imgLeft + (thumbnailWidth + 10) >= wrapWidth) {\\r\\n          imgTop =\\r\\n            parseInt((imgLeft + (thumbnailWidth + 10)) / wrapWidth) *\\r\\n            (thumbnailHeight + 10);\\r\\n          wrapHeight = imgTop + wrapHeight;\\r\\n          imgLeft =\\r\\n            (index % parseInt(wrapWidth / (thumbnailWidth + 10))) *\\r\\n            (thumbnailWidth + 10);\\r\\n        } */\\r\\n\\r\\n        $(\\\".vchrimage .middle\\\").css(\\\"overflow-y\\\",\\\"hidden\\\")\\r\\n        $(\\\".vchrimage .category-view\\\").css(\\\"overflow-y\\\",\\\"hidden\\\")\\r\\n        var liHeight = thumbnailHeight+25;\\r\\n        var wrapWidth = $queue.width();\\r\\n        var wrapHeight = liHeight + 20;\\r\\n        var imgNum = parseInt(wrapWidth / (thumbnailWidth + 10)) // 每行有几张图片\\r\\n        var imgTop = 0\\r\\n        var imgLeft = index * (thumbnailWidth + 10)\\r\\n        if (index + 1 > imgNum) {\\r\\n          imgTop = parseInt(index / imgNum) * (liHeight+10)\\r\\n          imgLeft = (index % imgNum) * (thumbnailWidth + 10)\\r\\n          wrapHeight = imgTop + liHeight + 10\\r\\n        }\\r\\n\\r\\n\\r\\n        $queue.height(wrapHeight);\\r\\n        var $li = $(\\r\\n            '<li data-key=\\\"' +\\r\\n              file.key +\\r\\n              '\\\"  data-src=\\\"' +\\r\\n              file.src +\\r\\n              '\\\" data-sort=\\\"' +\\r\\n              index +\\r\\n               '\\\" data-deg=\\\"' +\\r\\n              file.F_ROTATE +\\r\\n              '\\\" data-type=\\\"' +\\r\\n              datatype +\\r\\n              '\\\" draggable=\\\"true\\\" id=\\\"' +\\r\\n              file.id +\\r\\n              '\\\" style=\\\"position:absolute;margin:0;cursor:move;width:' +\\r\\n              thumbnailWidth +\\r\\n              \\\"px;height:\\\" +\\r\\n              liHeight +\\r\\n              \\\"px;left:\\\" +\\r\\n              imgLeft +\\r\\n              \\\"px;top:\\\" +\\r\\n              imgTop +\\r\\n              'px\\\">' +\\r\\n              '<p class=\\\"imgWrap\\\"></p>' +\\r\\n              '<p class=\\\"title\\\">' +\\r\\n              file.name +\\r\\n              \\\"</p>\\\" +\\r\\n              '<p class=\\\"progress\\\"><span></span></p>' +\\r\\n              \\\"</li>\\\"\\r\\n          ),\\r\\n          $btns = $(\\r\\n            '<div class=\\\"file-panel\\\">' + '<span class=\\\"cancel\\\">删除</span>'+\\r\\n            '<span class=\\\"rotateRight\\\">向右旋转</span>' +\\r\\n            '<span class=\\\"rotateLeft\\\">向左旋转</span></div>'\\r\\n          ).appendTo($li),\\r\\n          $progess = $li.find(\\\"p.progress span\\\"),\\r\\n          $wrap = $li.find(\\\"p.imgWrap\\\"),\\r\\n          $info = $('<p class=\\\"error\\\"></p>'),\\r\\n          showError = function(code) {\\r\\n            var text = \\\"\\\"\\r\\n            switch (code) {\\r\\n              case \\\"exceed_size\\\":\\r\\n                text = \\\"文本大小超出\\\";\\r\\n                break;\\r\\n              case \\\"interrupt\\\":\\r\\n                text = \\\"上传暂停\\\";\\r\\n                break;\\r\\n              default:\\r\\n                text = \\\"上传失败\\\";\\r\\n                break;\\r\\n            }\\r\\n            $info.text(text).appendTo($li);\\r\\n          };\\r\\n          if (supportTransition) {\\r\\n            var degs = \\\"rotate(\\\" + file.rotation||0 + \\\"deg)\\\";\\r\\n              $wrap.css({\\r\\n                \\\"-webkit-transform\\\": degs,\\r\\n                \\\"-mos-transform\\\": degs,\\r\\n                \\\"-o-transform\\\": degs,\\r\\n                transform: degs\\r\\n              });\\r\\n            }\\r\\n           //图片点击事件\\r\\n          $li.on(\\\"click\\\",function(){\\r\\n            var file = $(this).data(\\\"fileinfo\\\")\\r\\n            _this.$emit(\\\"imageClick\\\",file)\\r\\n          })\\r\\n          if (file.src == \\\"client\\\") {\\r\\n            if (file.getStatus() == \\\"invalid\\\") {\\r\\n              showError(file.statusText);\\r\\n            } else {\\r\\n              $wrap.text(\\\"预览中\\\");\\r\\n              uploader.makeThumb(\\r\\n                file,\\r\\n                function(error, src) {\\r\\n                  if (error) {\\r\\n                    /* $wrap.text(\\\"不能预览\\\");\\r\\n                    return; */\\r\\n                    file.F_FILE_TP = file.ext.toLowerCase()\\r\\n                    try {\\r\\n                      src = $.inArray(file.F_FILE_TP, Util.imgSuffix) !== -1?Util.createImgUrl(file.F_ATT_STO_KEY):require('@/assets/imageview/suffix/' + file.ext + '.png')\\r\\n                    } catch (error) {\\r\\n                      src = $.inArray(file.F_FILE_TP, Util.imgSuffix) !== -1?Util.createImgUrl(file.F_ATT_STO_KEY):require('@/assets/imageview/suffix/other.png')\\r\\n                    }\\r\\n                  }\\r\\n                  file.path = src;\\r\\n                  var img = $('<img draggable=\\\"true\\\" style=\\\"width:'+thumbnailWidth+'px;height:'+thumbnailHeight+'px\\\" src=\\\"' + src + '\\\">');\\r\\n                  img.bind(\\\"load\\\", setDragEvent);\\r\\n                  $wrap.empty().append(img);\\r\\n                },\\r\\n                0.8,\\r\\n                0.8\\r\\n                /* thumbnailWidth,\\r\\n                thumbnailHeight */\\r\\n              );\\r\\n              percentages[file.id] = [fileSize, 0];\\r\\n              file.rotation = 0;\\r\\n          }\\r\\n          file.on(\\\"statuschange\\\", function(cur, prev) {\\r\\n            if (prev == \\\"progress\\\") {\\r\\n              $progress.hide().width(0);\\r\\n            } else if (prev == \\\"queued\\\") {\\r\\n              //wqd 20190507注释  上传成功后还允许删除\\r\\n              //$li.off('mouseenter mouseleave');\\r\\n              //$btns.remove();\\r\\n            }\\r\\n\\r\\n            if (cur == \\\"error\\\" || cur == \\\"invalid\\\") {\\r\\n              showError(file.statusText);\\r\\n              percentages[file.id][1] = 1;\\r\\n            } else if (cur == \\\"interrupt\\\") {\\r\\n              showError(\\\"interrupt\\\");\\r\\n            } else if (cur == \\\"queued\\\") {\\r\\n              percentages[file.id][1] = 0;\\r\\n            } else if (cur == \\\"progress\\\") {\\r\\n              $info.remove();\\r\\n              $progress.css(\\\"display\\\", \\\"block\\\");\\r\\n            } else if (cur == \\\"complete\\\") {\\r\\n              $li.append('<span class=\\\"success\\\"></span>');\\r\\n            }\\r\\n\\r\\n            $li.removeClass(\\\"state-\\\" + prev).addClass(\\\"state-\\\" + cur);\\r\\n            updateStatus();\\r\\n          });\\r\\n        } else {\\r\\n          var img = $('<img draggable=\\\"true\\\" style=\\\"width:'+thumbnailWidth+'px;height:'+thumbnailHeight+'px\\\" src=\\\"' + file.path + '\\\">');\\r\\n          img.bind(\\\"load\\\", setDragEvent);\\r\\n          $wrap.empty().append(img);\\r\\n          $li.append('<span class=\\\"success\\\"></span>');\\r\\n           $(\\\".vchrimage .middle\\\").css(\\\"overflow-y\\\",\\\"auto\\\")\\r\\n          $(\\\".vchrimage .category-view\\\").css(\\\"overflow-y\\\",\\\"auto\\\")\\r\\n        }\\r\\n\\r\\n        $li.on(\\\"mouseenter\\\", function() {\\r\\n          $btns.stop().animate({ height: 30 });\\r\\n        });\\r\\n        $li.on(\\\"mouseleave\\\", function() {\\r\\n          $btns.stop().animate({ height: 0 });\\r\\n        });\\r\\n\\r\\n        $btns.on(\\\"click\\\", \\\"span\\\", function() {\\r\\n          var index = $(this).index(),\\r\\n            deg;\\r\\n\\r\\n          switch (index) {\\r\\n            case 0:\\r\\n              //修改删除后面所有图片的位置\\r\\n              var allImgs = {};\\r\\n              var del_sort = parseInt($(\\\"#\\\" + file.id).attr(\\\"data-sort\\\"));\\r\\n              $queue.find(\\\"li\\\").each(function(index, obj) {\\r\\n                if ($(obj).attr(\\\"data-sort\\\") > del_sort) {\\r\\n                  var sort = parseInt($(obj).attr(\\\"data-sort\\\"));\\r\\n                  var $prevObj = $(\\\"li[data-sort=\\\" + (sort - 1) + \\\"]\\\");\\r\\n                  if ($prevObj) {\\r\\n                    allImgs[$(obj).attr(\\\"id\\\")] = $prevObj.position();\\r\\n                  }\\r\\n                }\\r\\n              });\\r\\n              for (var k in allImgs) {\\r\\n                var sort = parseInt($(\\\"#\\\" + k).attr(\\\"data-sort\\\"));\\r\\n                $(\\\"#\\\" + k)\\r\\n                  .attr(\\\"data-sort\\\", sort - 1)\\r\\n                  .css({\\r\\n                    left: allImgs[k].left + \\\"px\\\",\\r\\n                    top: allImgs[k].top + \\\"px\\\"\\r\\n                  });\\r\\n              }\\r\\n              allImgs = null;\\r\\n              if (file.src == \\\"client\\\") uploader.removeFile(file);\\r\\n              else {\\r\\n                removeServerFile(file);\\r\\n                $(\\\"#\\\" + file.id).remove();\\r\\n                _this.updataImgCount()\\r\\n              }\\r\\n              _this.showImglist(_this.currentNode)\\r\\n              return;\\r\\n            case 1:\\r\\n              file.rotation += 90;\\r\\n              break;\\r\\n            case 2:\\r\\n              file.rotation -= 90;\\r\\n              break;\\r\\n          }\\r\\n\\r\\n          if (supportTransition) {\\r\\n            deg = \\\"rotate(\\\" + file.rotation + \\\"deg)\\\";\\r\\n            $wrap.css({\\r\\n              \\\"-webkit-transform\\\": deg,\\r\\n              \\\"-mos-transform\\\": deg,\\r\\n              \\\"-o-transform\\\": deg,\\r\\n              transform: deg\\r\\n            });\\r\\n            $wrap.parent().attr(\\\"data-deg\\\",file.rotation)\\r\\n          } else {\\r\\n          }\\r\\n        });\\r\\n        $li.appendTo($queue);\\r\\n        $li.data(\\\"fileinfo\\\",file)\\r\\n        _this.updataImgCount()\\r\\n      }\\r\\n      //删除webupload中的图片\\r\\n      function removeFile(file) {\\r\\n        var $li = $(\\\"#\\\" + file.id);\\r\\n        delete percentages[file.id];\\r\\n        updateTotalProgress();\\r\\n        $li.off().find(\\\".file-panel\\\").off().end().remove();\\r\\n        _this.updataImgCount()\\r\\n      }\\r\\n\\r\\n      //更新webuploader中图片上传的进度\\r\\n      function updateTotalProgress() {\\r\\n        var loaded = 0,\\r\\n          total = 0,\\r\\n          spans = $progress.children(),\\r\\n          percent;\\r\\n\\r\\n        $.each(percentages, function(k, v) {\\r\\n          total += v[0];\\r\\n          loaded += v[0] * v[1];\\r\\n        });\\r\\n\\r\\n        percent = total ? loaded / total : 0;\\r\\n\\r\\n        spans.eq(0).text(Math.round(percent * 100) + \\\"%\\\");\\r\\n        spans.eq(1).css(\\\"width\\\", Math.round(percent * 100) + \\\"%\\\");\\r\\n        updateStatus();\\r\\n      }\\r\\n\\r\\n      //更新webuploader中的状态\\r\\n      function updateStatus() {\\r\\n        var text = \\\"\\\",\\r\\n          stats;\\r\\n        if (state == \\\"ready\\\") {\\r\\n          text =\\r\\n            \\\"共\\\" +\\r\\n            WebUploader.formatSize(fileSize) +\\r\\n            \\\".\\\";\\r\\n        } else if (state == \\\"confirm\\\") {\\r\\n          stats = uploader.getStats();\\r\\n          if (stats.uploadFailNum) {\\r\\n            text =\\r\\n              \\\"上传成功\\\" +\\r\\n              stats.successNum +\\r\\n              \\\"张影像，上传失败:\\\" +\\r\\n              stats.uploadFailNum +\\r\\n              //'张照片上传失败,<a class=\\\"retry\\\" href=\\\"#\\\">重新上传</a>失败图片或<a class=\\\"ignore\\\" href=\\\"#\\\">忽略</a>';\\r\\n              '张影像，<a class=\\\"retry\\\" href=\\\"#\\\">重新上传</a>失败影像';\\r\\n          }\\r\\n        } else {\\r\\n          stats = uploader.getStats();\\r\\n          text =\\r\\n            \\\"共\\\" +\\r\\n            fileCount +\\r\\n            \\\"张(\\\" +\\r\\n            WebUploader.formatSize(fileSize) +\\r\\n            \\\")，已上传\\\" +\\r\\n            stats.successNum +\\r\\n            \\\"张\\\";\\r\\n          if (stats.uploadFailNum) {\\r\\n            text += \\\",失败\\\" + stats.uploadFailNum + \\\"张\\\";\\r\\n          }\\r\\n        }\\r\\n        $info.html(text);\\r\\n      }\\r\\n\\r\\n      //设置webuploader的状态\\r\\n      function setState(val) {\\r\\n        var file, stats;\\r\\n        if (val == state) {\\r\\n          return;\\r\\n        }\\r\\n        $upload.removeClass(\\\"state-\\\" + state);\\r\\n        $upload.addClass(\\\"state-\\\" + val);\\r\\n        state = val;\\r\\n\\r\\n        switch (state) {\\r\\n          case \\\"pedding\\\":\\r\\n            $placeHolder.removeClass(\\\"element-invisible\\\");\\r\\n            $queue.parent().removeClass(\\\"filled\\\");\\r\\n            $queue.hide();\\r\\n            $statusBar.addClass(\\\"element-invisible\\\");\\r\\n            uploader.refresh();\\r\\n            break;\\r\\n          case \\\"ready\\\":\\r\\n            $placeHolder.addClass(\\\"element-invisible\\\");\\r\\n            $(\\\"#filePicker2\\\").removeClass(\\\"element-invisible\\\");\\r\\n            $queue.parent().addClass(\\\"filled\\\");\\r\\n            $queue.show();\\r\\n            $statusBar.removeClass(\\\"element-invisible\\\");\\r\\n            uploader.refresh();\\r\\n            break;\\r\\n          case \\\"uploading\\\":\\r\\n            $(\\\"filePicker2\\\").addClass(\\\"element-invisible\\\");\\r\\n            $progress.show();\\r\\n            $upload.text(\\\"暂停上传\\\");\\r\\n            break;\\r\\n          case \\\"paused\\\":\\r\\n            $progress.show();\\r\\n            $upload.text(\\\"继续上传\\\");\\r\\n            break;\\r\\n          case \\\"confirm\\\":\\r\\n            $progress.hide();\\r\\n            //wqd 20190508 注释\\r\\n            // $upload.text('开始上传').addClass('disabled');\\r\\n            $upload.text(\\\"开始上传\\\");\\r\\n            stats = uploader.getStats();\\r\\n            if (stats.successNum && !stats.uploadFailNum) {\\r\\n              //wqd 20190508 注释\\r\\n              //setState( 'finish' );\\r\\n              return;\\r\\n            }\\r\\n            break;\\r\\n          case \\\"finish\\\":\\r\\n            stats = uploader.getStats();\\r\\n            if (stats.successNum) {\\r\\n              alert(\\\"上传成功\\\");\\r\\n            } else {\\r\\n              state = \\\"done\\\";\\r\\n              location.reload();\\r\\n            }\\r\\n            break;\\r\\n        }\\r\\n        updateStatus();\\r\\n      }\\r\\n\\r\\n      //文件加入到webuploader中的队列\\r\\n      function fileQueue(file) {\\r\\n        file.src = file.src || \\\"client\\\";\\r\\n        fileCount++;\\r\\n        fileSize += file.size;\\r\\n\\r\\n        if (fileCount == 1) {\\r\\n          $placeHolder.addClass(\\\"element-invisible\\\");\\r\\n          $statusBar.show();\\r\\n        }\\r\\n\\r\\n        addFile(file);\\r\\n        setState(\\\"ready\\\");\\r\\n        updateTotalProgress();\\r\\n      }\\r\\n\\r\\n      if (!WebUploader.Uploader.support()) {\\r\\n        console.log(\\\"WebUploader 不支持\\\");\\r\\n        throw new Error(\\\"WebUploader does not support\\\");\\r\\n      }\\r\\n\\r\\n      uploader.addButton({\\r\\n        id: \\\"#filePicker2\\\",\\r\\n        label: \\\"继续添加\\\"\\r\\n      });\\r\\n\\r\\n      uploader.on(\\\"uploadProgress\\\", function(file, percentage) {\\r\\n        var $li = $(\\\"#\\\" + file.id),\\r\\n          $percent = $li.find(\\\".progress span\\\");\\r\\n        $percent.css({\\\"width\\\": percentage * 100 + \\\"%\\\",\\\"display\\\":\\\"none\\\"})\\r\\n        updateTotalProgress();\\r\\n      });\\r\\n\\r\\n      uploader.on(\\\"fileQueued\\\", fileQueue);\\r\\n\\r\\n      uploader.on(\\\"fileDequeued\\\", function(file) {\\r\\n        fileCount--;\\r\\n        fileSize -= file.size;\\r\\n        if (!fileCount) {\\r\\n          setState(\\\"pedding\\\");\\r\\n        }\\r\\n        removeFile(file);\\r\\n        updateTotalProgress();\\r\\n      });\\r\\n\\r\\n      uploader.on(\\\"uploadSuccess\\\", function(file, data) {\\r\\n        if (data.F_CODE === \\\"0\\\") {\\r\\n          $(\\\"#\\\" + file.id)\\r\\n            .find(\\\"p.state\\\")\\r\\n            .text(\\\"已上传\\\");\\r\\n        }\\r\\n      });\\r\\n\\r\\n      uploader.on(\\\"uploadError\\\", function(file, b) {\\r\\n        console.log(file.id + \\\"上传出错\\\");\\r\\n      });\\r\\n\\r\\n      uploader.on(\\\"uploadComplete\\\", function(file, a, b) {\\r\\n        $(\\\"#\\\" + file.id)\\r\\n          .find(\\\"p.state\\\")\\r\\n          .fadeOut();\\r\\n      });\\r\\n\\r\\n      uploader.on(\\\"all\\\", function(type) {\\r\\n        if (type == \\\"uploadFinished\\\") {\\r\\n          setState(\\\"confirm\\\");\\r\\n        } else if (type == \\\"startUpload\\\") {\\r\\n          setState(\\\"uploading\\\");\\r\\n        } else if (type == \\\"stopUpload\\\") {\\r\\n          setState(\\\"paused\\\");\\r\\n        }\\r\\n      });\\r\\n\\r\\n      uploader.on(\\\"uploadBeforeSend\\\", function(block, data) {\\r\\n        data.sort = $(\\\"#\\\" + data.id).attr(\\\"data-sort\\\");\\r\\n        var file = $(\\\"#\\\" + data.id).data(\\\"fileinfo\\\")\\r\\n        var obj = {\\r\\n          \\\"F_APP_ID\\\": \\\"TAIKANG\\\",//来源系统标识\\r\\n          \\\"F_ACCESS_TOKEN\\\": \\\"\\\",\\r\\n          \\\"F_USER_ID\\\": \\\"tianmeng\\\",//操作人\\r\\n          \\\"F_USER_NAME\\\":\\\"\\\",//操作人名称\\r\\n          \\\"F_NEED_APPLY\\\": \\\"1\\\",  //是否需要申请 默认1\\r\\n          \\\"F_BILL_ID\\\":\\\"LKRL201812110014\\\",//单据编号\\r\\n          \\\"F_BILL_TYPE\\\":\\\"TTFS_JS_LKRLD\\\",//单据类型\\r\\n          \\\"F_BIZ_TYPE\\\":\\\"TTFS_JS_LKRLD\\\",//业务类型\\r\\n          \\\"F_AMT\\\":\\\"\\\",//金额\\r\\n          \\\"F_CURR\\\":\\\"\\\",//币种\\r\\n          \\\"F_SC_CODE\\\":\\\"\\\",//共享中心\\r\\n          \\\"F_POOL_ID\\\":\\\"\\\",//业务池\\r\\n          \\\"F_ATT_TYPE\\\":\\\"0\\\",//上传方式 0普通上传 1 集中扫描\\r\\n          \\\"F_APPLY_FILES\\\": [\\r\\n            {\\r\\n              \\\"F_TYPE\\\": \\\"0\\\",\\r\\n              \\\"F_OBJECT\\\": \\\"1234567890\\\",\\r\\n              \\\"F_IMG_CODE\\\":file.F_IMG_CODE,//影像关键码\\r\\n              \\\"F_IMG_TYPE\\\":file.F_IMG_TYPE,//影像类别\\r\\n              \\\"F_FILES\\\": [\\r\\n                {\\r\\n                  \\\"F_FILE_NAME\\\": data.name,\\r\\n                  \\\"F_FILE_NAME1\\\": data.name,\\r\\n                  \\\"F_FILE_PATH\\\": \\\"\\\",\\r\\n                  \\\"F_FILE_SIZE\\\": data.size,\\r\\n                  \\\"F_FILE_MD5\\\": \\\"\\\",\\r\\n                  \\\"F_UPLOAD_ZIP\\\": \\\"\\\",\\r\\n                  \\\"F_ENCRYPT\\\": \\\"\\\",\\r\\n                  \\\"F_ENCRYPT_KEY\\\": \\\"\\\",\\r\\n                  \\\"F_BIZ_INFO\\\":\\\"\\\",//摘要\\r\\n                  \\\"F_OPER_TYPE\\\":\\\"\\\",//操作类型 默认空表示制单人上传 1表示审批人加批注或编辑图片\\r\\n                  \\\"F_ORIG_IMG_KEY\\\": \\\"\\\",//审批人编辑及批注图片时有用\\r\\n                  \\\"F_NODE_ID\\\":\\\"\\\",//签批节点\\r\\n                  \\\"F_NODE_NAME\\\":\\\"\\\",//签批节点名称\\r\\n                  \\\"F_SIGN_USR_NAME\\\":\\\"\\\",//签批人名称\\r\\n                  \\\"F_SIGN_NOTE\\\":\\\"\\\",//签批内容\\r\\n                  \\\"F_OP_ACTION\\\":\\\"\\\",//操作动作\\r\\n                  \\\"F_ROTATE\\\":file.rotation,//旋转度数\\r\\n                  \\\"F_FILE_ORDER\\\":$(\\\"#\\\" + data.id).attr(\\\"data-sort\\\"),//显示序号\\r\\n                  \\\"F_ISHIDE\\\":\\\"0\\\",//是否隐藏：1是，0否\\r\\n                  \\\"F_RISK_TYPE\\\":\\\"\\\"//风险类别\\r\\n                }\\r\\n              ]\\r\\n            }\\r\\n          ]\\r\\n        }\\r\\n        data.jsondata = JSON.stringify(obj);\\r\\n        var $li = $(\\\"#\\\" + data.id),\\r\\n          $percent = $li.find(\\\".progress span\\\");\\r\\n        $percent.css({\\\"width\\\": \\\"100%\\\",\\\"display\\\":\\\"block\\\"})\\r\\n      });\\r\\n\\r\\n      $upload.on(\\\"click\\\", function() {\\r\\n        uploader.sort(function(obj1, obj2) {\\r\\n          return $(\\\"#\\\" + obj1.id).attr(\\\"data-sort\\\") > $(\\\"#\\\" + obj2.id) ? -1 : 1;\\r\\n        });\\r\\n        if ($(this).hasClass(\\\"disabled\\\")) {\\r\\n          return false;\\r\\n        }\\r\\n        if (state == \\\"ready\\\") {\\r\\n          if (uploader.getFiles().length < 1) updateServerFiles();\\r\\n          else uploader.upload();\\r\\n        } else if (state == \\\"paused\\\") {\\r\\n          uploader.upload();\\r\\n        } else if (state == \\\"uploading\\\") {\\r\\n          uploader.stop();\\r\\n        }\\r\\n      });\\r\\n\\r\\n      $info.on(\\\"click\\\", \\\".retry\\\", function() {\\r\\n        uploader.retry();\\r\\n      });\\r\\n\\r\\n      $info.on(\\\"click\\\", \\\".ignore\\\", function() {\\r\\n        alert(\\\"todo\\\");\\r\\n      });\\r\\n\\r\\n      $upload.addClass(\\\"state-\\\" + state);\\r\\n      updateTotalProgress();\\r\\n\\r\\n      initServerFile();\\r\\n    },\\r\\n    /* eslint-enable */\\r\\n    showImglist: function (type) {\\r\\n      $(\\\".filelist>li[data-type!='\\\" + type + \\\"']\\\").hide()\\r\\n      $(\\\".filelist>li[data-type='\\\" + type + \\\"']\\\").show()\\r\\n      $('.vchrimage .middle').css('overflow-y', 'hidden')\\r\\n      $('.vchrimage .category-view').css('overflow-y', 'hidden')\\r\\n      // 重新计算图片的位置\\r\\n      var $queue = $('.filelist')\\r\\n      // 优化retina, 在retina下这个值是2\\r\\n      var ratio = window.devicePixelRatio || 1\\r\\n      // 缩略图大小\\r\\n      var thumbnailWidth = this.uploadprops.config.thumbWidth || 110\\r\\n      thumbnailWidth *= ratio\\r\\n      var thumbnailHeight = this.uploadprops.config.thumbHeight || 110\\r\\n      thumbnailHeight = thumbnailHeight + 25\\r\\n      thumbnailHeight *= ratio\\r\\n      var wrapHeight = thumbnailHeight + 10\\r\\n      var wrapWidth = $queue.width()\\r\\n      var imgNum = parseInt(wrapWidth / (thumbnailWidth + 10)) // 每行有几张图片\\r\\n      $(\\\".filelist>li[data-type='\\\" + type + \\\"']\\\").each(function (index, v) {\\r\\n        var imgTop = 0\\r\\n        var imgLeft = index * (thumbnailWidth + 10)\\r\\n        if (index + 1 > imgNum) {\\r\\n          imgTop = parseInt(index / imgNum) * (thumbnailHeight + 10)\\r\\n          imgLeft = (index % imgNum) * (thumbnailWidth + 10)\\r\\n          wrapHeight = imgTop + thumbnailHeight + 10\\r\\n        }\\r\\n        $(this).css({ left: imgLeft + 'px', top: imgTop + 'px' })\\r\\n      })\\r\\n      $queue.css('height', wrapHeight + 'px')\\r\\n      $('.vchrimage .middle').css('overflow-y', 'auto')\\r\\n      $('.vchrimage .category-view').css('overflow-y', 'auto')\\r\\n    },\\r\\n    // tab页签点击\\r\\n    tabChange: function (ref) {\\r\\n      $(this.$refs[ref]).addClass('tab-active').siblings().removeClass('tab-active')\\r\\n      if (ref === 'allView') {\\r\\n        $('.queueAllList').show().empty()\\r\\n        $('.imgWrap img').clone().appendTo($('.queueAllList'))\\r\\n        $('.queueList').hide()\\r\\n        $('.queueAllList img').css('margin', '10px')\\r\\n        this.AllImgeCount = $('.queueAllList img').length\\r\\n      } else {\\r\\n        $('.queueList').show()\\r\\n        $('.queueAllList').hide()\\r\\n      }\\r\\n    },\\r\\n    updataImgCount: function () {\\r\\n      var $queue = $('.filelist')\\r\\n      var count = $queue.find(\\\"li[data-type='\\\" + this.currentNode + \\\"']\\\").length\\r\\n      this.CNodeImgeCount = count\\r\\n      this.$emit('CNodeImgeCount', count)\\r\\n      var allCount = $queue.find('li').length\\r\\n      this.AllImgeCount = allCount\\r\\n    }\\r\\n  }\\r\\n}\\r\\n</script>\\r\\n<style scoped>\\r\\n  .tab-view div{\\r\\n    padding: 0 20px;\\r\\n    cursor: pointer;\\r\\n  }\\r\\n  .tab-view .tab-active{\\r\\n    border-bottom: 2px solid #1094fa;\\r\\n  }\\r\\n</style>\\r\\n\"],\"sourceRoot\":\"\"}]);\n\n// exports\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvY29tcG9uZW50cy93ZWJ1cGxvYWRlci91cGxvYWQudnVlP2VlOTMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEsMkJBQTJCLG1CQUFPLENBQUMsQ0FBa0Q7QUFDckY7OztBQUdBO0FBQ0EsY0FBYyxRQUFTLG9DQUFvQyxvQkFBb0Isb0JBQW9CLEdBQUcseUNBQXlDLHFDQUFxQyxHQUFHLFVBQVUsdUpBQXVKLE9BQU8sV0FBVyxXQUFXLEtBQUssS0FBSyxXQUFXLHNYQUFzWCxrQkFBa0IsOEpBQThKLGdCQUFnQixzbEJBQXNsQixlQUFlLG1GQUFtRiw4ZkFBOGYscUJBQXFCLHVDQUF1QyxzQkFBc0IsOERBQThELHFCQUFxQiwrREFBK0QsZ0NBQWdDLFNBQVMsdUJBQXVCLHVEQUF1RCxvQkFBb0IsdUJBQXVCLCtTQUErUyxpVEFBaVQsV0FBVyxTQUFTLE9BQU8sZ0JBQWdCLGdCQUFnQixzQkFBc0IsK0RBQStELE9BQU8sZUFBZSxnREFBZ0QsK0JBQStCLGdEQUFnRCxPQUFPLG1EQUFtRCwwRUFBMEUsT0FBTyw2QkFBNkIsd01BQXdNLHVEQUF1RCxPQUFPLGlCQUFpQixzQ0FBc0MsMEZBQTBGLG1EQUFtRCx3REFBd0QseUJBQXlCLFdBQVcsNEVBQTRFLDJEQUEyRCxzRUFBc0UseUJBQXlCLFdBQVcsNkNBQTZDLDZEQUE2RCxrRUFBa0UseUJBQXlCLFdBQVcsNkNBQTZDLDZEQUE2RCxrRUFBa0UseUJBQXlCLFdBQVcsNkNBQTZDLDZEQUE2RCxrRUFBa0UseUJBQXlCLFdBQVcsdUJBQXVCLHVCQUF1Qiw0QkFBNEIscUJBQXFCLGlDQUFpQyxpRUFBaUUsdUhBQXVILDJDQUEyQyxzREFBc0QsaURBQWlELG1EQUFtRCwwREFBMEQsZ0VBQWdFLDRCQUE0QiwyQkFBMkIsa0NBQWtDLCtCQUErQiwrQ0FBK0MsaVJBQWlSLHFCQUFxQix1QkFBdUIsMERBQTBELElBQUksdUZBQXVGLDRGQUE0RixrQ0FBa0MsNEVBQTRFLG1DQUFtQyw2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VyxFQUFFLDhEQUE4RCw0Q0FBNEMsV0FBVyxFQUFFLG9FQUFvRSx1RkFBdUYsV0FBVyxFQUFFLG1EQUFtRCw2Q0FBNkMsb0NBQW9DLGFBQWEsb0NBQW9DLHNDQUFzQyxhQUFhLG1DQUFtQyxtQ0FBbUMsYUFBYSxXQUFXLEVBQUUsdUVBQXVFLCtEQUErRCxtRkFBbUYsK25CQUErbkIsdVBBQXVQLHNpQ0FBc2lDLG9DQUFvQyw0QkFBNEIsZ0RBQWdELCtGQUErRiwwQkFBMEIsMENBQTBDLFlBQVksRUFBRSxnREFBZ0QsZ0RBQWdELDBGQUEwRixhQUFhLEVBQUUsaURBQWlELDJCQUEyQixhQUFhLHFDQUFxQyxzRUFBc0UscUNBQXFDLGFBQWEsZ0NBQWdDLGdDQUFnQyxhQUFhLG1DQUFtQyw4QkFBOEIsYUFBYSxXQUFXLEVBQUUsMERBQTBELDZCQUE2QixXQUFXLEVBQUUsMkRBQTJELDRCQUE0QixXQUFXLEVBQUUsbURBQW1ELGdDQUFnQywrQkFBK0IsU0FBUyxrRUFBa0UsazZCQUFrNkIsc0hBQXNILDZNQUE2TSx5QkFBeUIsMkNBQTJDLFlBQVksd0xBQXdMLHNEQUFzRCwwSEFBMEgsaVJBQWlSLE9BQU8sa0ZBQWtGLFNBQVMsc0NBQXNDLCtTQUErUyxPQUFPLEtBQUssbURBQW1ELHdCQUF3Qix3QkFBd0IsT0FBTyw0QkFBNEIseUNBQXlDLE9BQU8sbUNBQW1DOztBQUV4L2lDIiwiZmlsZSI6IjQ5LmpzIiwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2xpYi9jc3MtYmFzZS5qc1wiKSh0cnVlKTtcbi8vIGltcG9ydHNcblxuXG4vLyBtb2R1bGVcbmV4cG9ydHMucHVzaChbbW9kdWxlLmlkLCBcIlxcbi50YWItdmlldyBkaXZbZGF0YS12LTMxNTFhOWZlXXtcXG4gIHBhZGRpbmc6IDAgMjBweDtcXG4gIGN1cnNvcjogcG9pbnRlcjtcXG59XFxuLnRhYi12aWV3IC50YWItYWN0aXZlW2RhdGEtdi0zMTUxYTlmZV17XFxuICBib3JkZXItYm90dG9tOiAycHggc29saWQgIzEwOTRmYTtcXG59XFxuXCIsIFwiXCIsIHtcInZlcnNpb25cIjozLFwic291cmNlc1wiOltcIkU6L3dlYndvcmsvdnVlY29tcG9uZW50cy9GaWxlVXBsb2FkL3NyYy9jb21wb25lbnRzL3dlYnVwbG9hZGVyL3NyYy9jb21wb25lbnRzL3dlYnVwbG9hZGVyL3VwbG9hZC52dWVcIl0sXCJuYW1lc1wiOltdLFwibWFwcGluZ3NcIjpcIjtBQXM1QkE7RUFDQSxnQkFBQTtFQUNBLGdCQUFBO0NBQ0E7QUFDQTtFQUNBLGlDQUFBO0NBQ0FcIixcImZpbGVcIjpcInVwbG9hZC52dWVcIixcInNvdXJjZXNDb250ZW50XCI6W1wiPHRlbXBsYXRlPlxcclxcbiAgPGRpdj5cXHJcXG4gICAgPGRpdiBjbGFzcz1cXFwicGFnZS1jb250YWluZXJcXFwiPlxcclxcbiAgICAgIDxkaXYgaWQ9XFxcInVwbG9hZGVyXFxcIj5cXHJcXG4gICAgICAgIDxkaXYgY2xhc3M9XFxcInN0YXR1c0JhclxcXCIgc3R5bGU9XFxcImRpc3BsYXk6bm9uZVxcXCI+XFxyXFxuICAgICAgICAgIDxkaXYgY2xhc3M9XFxcInRhYi12aWV3XFxcIj5cXHJcXG4gICAgICAgICAgICA8ZGl2IHJlZj1cXFwiZGV0YWlsVmlld1xcXCIgc3R5bGU9XFxcImZsb2F0OmxlZnRcXFwiIGNsYXNzPVxcXCJ0YWItYWN0aXZlXFxcIiBAY2xpY2s9XFxcInRhYkNoYW5nZSgnZGV0YWlsVmlldycpXFxcIj7liIbnsbvlsZXnpLpcXHJcXG4gICAgICAgICAgICAgIHt7IENOb2RlSW1nZUNvdW50IH19XFxyXFxuICAgICAgICAgICAgPC9kaXY+XFxyXFxuICAgICAgICAgICAgPGRpdiB2LWlmPVxcXCJ1cGxvYWRwcm9wcy5jb25maWcuc2h3b0FsbGxpc3RcXFwiIHJlZj1cXFwiYWxsVmlld1xcXCIgc3R5bGU9XFxcImZsb2F0OmxlZnRcXFwiIEBjbGljaz1cXFwidGFiQ2hhbmdlKCdhbGxWaWV3JylcXFwiPuWFqOmDqOWxleekunt7IEFsbEltZ2VDb3VudCB9fTwvZGl2PlxcclxcbiAgICAgICAgICAgIDxkaXYgc3R5bGU9XFxcImNsZWFyOmJvdGhcXFwiLz5cXHJcXG4gICAgICAgICAgPC9kaXY+XFxyXFxuICAgICAgICAgIDxkaXYgY2xhc3M9XFxcImJ0bnNcXFwiPlxcclxcbiAgICAgICAgICAgIDxkaXYgY2xhc3M9XFxcInByb2dyZXNzXFxcIj5cXHJcXG4gICAgICAgICAgICAgIDxzcGFuIGNsYXNzPVxcXCJ0ZXh0XFxcIj4wJTwvc3Bhbj5cXHJcXG4gICAgICAgICAgICAgIDxzcGFuIGNsYXNzPVxcXCJwZXJjZW50YWdlXFxcIi8+XFxyXFxuICAgICAgICAgICAgPC9kaXY+XFxyXFxuICAgICAgICAgICAgPGRpdiBjbGFzcz1cXFwiaW5mb1xcXCI+5YWxIDUg5bygPC9kaXY+XFxyXFxuICAgICAgICAgICAgPGRpdiBpZD1cXFwiZmlsZVBpY2tlcjJcXFwiLz5cXHJcXG4gICAgICAgICAgICA8ZGl2IGNsYXNzPVxcXCJ1cGxvYWRCdG5cXFwiPuW8gOWni+S4iuS8oDwvZGl2PlxcclxcbiAgICAgICAgICA8L2Rpdj5cXHJcXG4gICAgICAgIDwvZGl2PlxcclxcbiAgICAgICAgPGRpdiBjbGFzcz1cXFwicXVldWVMaXN0XFxcIj5cXHJcXG4gICAgICAgICAgPGRpdiBpZD1cXFwiZG5kQXJlYVxcXCIgY2xhc3M9XFxcInBsYWNlaG9sZGVyXFxcIj5cXHJcXG4gICAgICAgICAgICA8ZGl2IGlkPVxcXCJmaWxlUGlja2VyXFxcIi8+XFxyXFxuICAgICAgICAgICAgPHA+5oiW5bCG54Wn54mH5ouW5Yiw6L+Z6YeMe3sgY3VycmVudE5vZGUgfX08L3A+XFxyXFxuICAgICAgICAgIDwvZGl2PlxcclxcbiAgICAgICAgICA8dWwgY2xhc3M9XFxcImZpbGVsaXN0XFxcIiBzdHlsZT1cXFwiaGVpZ2h0OiAxMzVweDtcXFwiLz5cXHJcXG4gICAgICAgIDwvZGl2PlxcclxcbiAgICAgICAgPGRpdiBjbGFzcz1cXFwicXVldWVBbGxMaXN0XFxcIi8+XFxyXFxuICAgICAgPC9kaXY+XFxyXFxuICAgIDwvZGl2PlxcclxcbiAgPC9kaXY+XFxyXFxuPC90ZW1wbGF0ZT5cXHJcXG48c2NyaXB0PlxcclxcbmltcG9ydCBVdGlsIGZyb20gJ0AvdXRpbHMvdXRpbC5qcydcXHJcXG5yZXF1aXJlKCdAL2NvbXBvbmVudHMvd2VidXBsb2FkZXIvY3NzL2RlbW8uY3NzJylcXHJcXG5yZXF1aXJlKCdAL2NvbXBvbmVudHMvd2VidXBsb2FkZXIvY3NzL3N0eWxlLmNzcycpXFxyXFxucmVxdWlyZSgnQC9jb21wb25lbnRzL3dlYnVwbG9hZGVyL3dlYnVwbG9hZGVyLTAuMS41L3dlYnVwbG9hZGVyLmNzcycpXFxyXFxudmFyICQgPSByZXF1aXJlKCdqcXVlcnknKVxcclxcbndpbmRvdy4kID0gJFxcclxcbndpbmRvdy5qUXVlcnkgPSAkXFxyXFxucmVxdWlyZSgnQC9jb21wb25lbnRzL3dlYnVwbG9hZGVyL3dlYnVwbG9hZGVyLTAuMS41L3dlYnVwbG9hZGVyLmpzJylcXHJcXG5cXHJcXG4kKGZ1bmN0aW9uICgpIHt9KVxcclxcbmV4cG9ydCBkZWZhdWx0IHtcXHJcXG4gIG5hbWU6ICdGaWxlVXBsb2FkJyxcXHJcXG4gIHByb3BzOiB7XFxyXFxuICAgIGN1cnJlbnROb2RlOiB7Ly8g5b2T5YmN6YCJ5Lit5YiG57G7XFxyXFxuICAgICAgdHlwZTogU3RyaW5nLFxcclxcbiAgICAgIGRlZmF1bHQ6ICcnXFxyXFxuICAgIH0sXFxyXFxuICAgIGluaXRmaWxlczogey8vIOWIneWni+aWh+S7tuS/oeaBr1xcclxcbiAgICAgIHR5cGU6IEFycmF5LFxcclxcbiAgICAgIGRlZmF1bHQ6IGZ1bmN0aW9uICgpIHtcXHJcXG4gICAgICAgIHJldHVybiBbXVxcclxcbiAgICAgIH1cXHJcXG4gICAgfSxcXHJcXG4gICAgdXBsb2FkcHJvcHM6IHtcXHJcXG4gICAgICB0eXBlOiBPYmplY3QsXFxyXFxuICAgICAgZGVmYXVsdDogZnVuY3Rpb24gKCkge1xcclxcbiAgICAgICAgcmV0dXJuIHtcXHJcXG4gICAgICAgICAgY29uZmlnOiB7XFxyXFxuICAgICAgICAgICAgdGh1bWJXaWR0aDogMTI1LCAvLyDnvKnnlaXlm77lrr3luqbvvIzlj6/nnIHnlaXvvIzpu5jorqTkuLoxMTBcXHJcXG4gICAgICAgICAgICB0aHVtYkhlaWdodDogMTI1LCAvLyDnvKnnlaXlm77pq5jluqbvvIzlj6/nnIHnlaXvvIzpu5jorqTkuLoxMTBcXHJcXG4gICAgICAgICAgICB3cmFwSWQ6ICd1cGxvYWRlcicsIC8vIOW/heWhq1xcclxcbiAgICAgICAgICAgIHNod29BbGxsaXN0OiBmYWxzZSwgLy8g5piv5ZCm5pi+56S65YWo6YOo5Zu+54mH5qCH562+6aG1XFxyXFxuICAgICAgICAgICAgZmlsZWZvcm1hdDogJ2dpZixqcGcsanBlZyxwbmcsemlwLHBkZix4bHN4LHhscyxkb2MsZG9jeCxwcHQscmFyJy8vIOWFgeiuuOS4iuS8oOeahOaWh+S7tuagvOW8j1xcclxcbiAgICAgICAgICB9LFxcclxcbiAgICAgICAgICAvLyDlpITnkIblrqLmiLfnq6/mlrDmlofku7bkuIrkvKDml7bvvIzpnIDopoHosIPnlKjlkI7lj7DlpITnkIbnmoTlnLDlnYAsIOW/heWhq1xcclxcbiAgICAgICAgICB1cGxvYWRVcmw6ICcnLFxcclxcbiAgICAgICAgICAvLyDlpITnkIblrqLmiLfnq6/ljp/mnInmlofku7bmm7TmlrDml7bnmoTlkI7lj7DlpITnkIblnLDlnYDvvIzlv4XloatcXHJcXG4gICAgICAgICAgdXBkYXRlVXJsOiAnJyxcXHJcXG4gICAgICAgICAgLy8g5b2T5a6i5oi356uv5Y6f5pyJ5paH5Lu25Yig6Zmk5pe255qE5ZCO5Y+w5aSE55CG5Zyw5Z2A77yM5b+F5aGrXFxyXFxuICAgICAgICAgIHJlbW92ZVVybDogJycsXFxyXFxuICAgICAgICAgIC8vIOWIneWni+WMluWuouaIt+err+S4iuS8oOaWh+S7tu+8jOS7juWQjuWPsOiOt+WPluaWh+S7tueahOWcsOWdgCwg5Y+v6YCJ77yM5b2T5q2k5Y+C5pWw5Li656m65pe277yM6buY6K6k5bey5LiK5Lyg55qE5paH5Lu25Li656m6XFxyXFxuICAgICAgICAgIGluaXRVcmw6ICcnXFxyXFxuICAgICAgICB9XFxyXFxuICAgICAgfVxcclxcbiAgICB9XFxyXFxuICB9LFxcclxcbiAgZGF0YSAoKSB7XFxyXFxuICAgIHJldHVybiB7XFxyXFxuICAgICAgdmNockluZm86IHt9LFxcclxcbiAgICAgIENOb2RlSW1nZUNvdW50OiAwLFxcclxcbiAgICAgIEFsbEltZ2VDb3VudDogMFxcclxcbiAgICB9XFxyXFxuICB9LFxcclxcbiAgd2F0Y2g6IHtcXHJcXG4gICAgY3VycmVudE5vZGU6IGZ1bmN0aW9uIChuZXd2YWwsIG9sZHZhbCkge1xcclxcbiAgICAgIGlmIChuZXd2YWwgPT09ICcwJykge1xcclxcbiAgICAgICAgdGhpcy50YWJDaGFuZ2UoJ2FsbFZpZXcnKVxcclxcbiAgICAgIH0gZWxzZSB7XFxyXFxuICAgICAgICB0aGlzLnRhYkNoYW5nZSgnZGV0YWlsVmlldycpXFxyXFxuICAgICAgfVxcclxcbiAgICAgIHRoaXMuc2hvd0ltZ2xpc3QobmV3dmFsKVxcclxcbiAgICAgIHRoaXMudXBkYXRhSW1nQ291bnQoKVxcclxcbiAgICB9XFxyXFxuICB9LFxcclxcbiAgbW91bnRlZDogZnVuY3Rpb24gKCkge1xcclxcbiAgICAvLyByZXF1aXJlKCdAL2NvbXBvbmVudHMvd2VidXBsb2FkZXIvd2VidXBsb2FkZXItMC4xLjUvZXh0ZW5kLXdlYnVwbG9hZGVyLmpzJylcXHJcXG4gICAgLy8g6I635Y+WdXJs5LiK55qE5Y+C5pWwXFxyXFxuICAgIHZhciBfdGhpcyA9IHRoaXNcXHJcXG4gICAgX3RoaXMuaW5pdFdlYlVwbG9hZGVyKClcXHJcXG4gICAgd2luZG93Lm9ucmVzaXplID0gZnVuY3Rpb24gKCkge1xcclxcbiAgICAgIF90aGlzLnNob3dJbWdsaXN0KF90aGlzLmN1cnJlbnROb2RlKVxcclxcbiAgICB9XFxyXFxuICB9LFxcclxcbiAgbWV0aG9kczoge1xcclxcbiAgICBpbml0V2ViVXBsb2FkZXI6IGZ1bmN0aW9uICgpIHtcXHJcXG4gICAgICB2YXIgX3RoaXMgPSB0aGlzXFxyXFxuICAgICAgLyogZXNsaW50LWRpc2FibGUgKi9cXHJcXG4gICAgICBpZiAoIXRoaXMudXBsb2FkcHJvcHMpIHtcXHJcXG4gICAgICAgIGNvbnNvbGUubG9nKFxcXCLor7fphY3nva7lpb1fdGhpcy51cGxvYWRwcm9wc1xcXCIpO1xcclxcbiAgICAgICAgJChcXFwiI2RuZEFyZWEgcFxcXCIpLmh0bWwoXFxcIuivt+mFjee9ruWlvXVwbG9hZHByb3BzXFxcIik7XFxyXFxuICAgICAgICByZXR1cm4gZmFsc2U7XFxyXFxuICAgICAgfVxcclxcbiAgICAgIGlmICghdGhpcy51cGxvYWRwcm9wcy5jb25maWcgfHwgIXRoaXMudXBsb2FkcHJvcHMuY29uZmlnLndyYXBJZCkge1xcclxcbiAgICAgICAgY29uc29sZS5sb2coXFxcIuivt+mFjee9ruWlvXVwbG9hZHByb3BzLmNvbmZpZy53cmFwSWRcXFwiKTtcXHJcXG4gICAgICAgICQoXFxcIiNkbmRBcmVhIHBcXFwiKS5odG1sKFxcXCLor7fphY3nva7lpb11cGxvYWRwcm9wcy5jb25maWcud3JhcElkXFxcIik7XFxyXFxuICAgICAgICByZXR1cm4gZmFsc2U7XFxyXFxuICAgICAgfVxcclxcbiAgICAgIGlmICghX3RoaXMudXBsb2FkcHJvcHMudXBsb2FkVXJsKSB7XFxyXFxuICAgICAgICBjb25zb2xlLmxvZyhcXFwi6K+36YWN572u5aW9X3RoaXMudXBsb2FkcHJvcHMudXBsb2FkVXJsXFxcIik7XFxyXFxuICAgICAgICAkKFxcXCIjZG5kQXJlYSBwXFxcIikuaHRtbChcXFwi6K+36YWN572u5aW9dXBsb2FkcHJvcHMudXBsb2FkVXJsXFxcIik7XFxyXFxuICAgICAgICByZXR1cm4gZmFsc2U7XFxyXFxuICAgICAgfVxcclxcbiAgICAgIGlmICghX3RoaXMudXBsb2FkcHJvcHMudXBkYXRlVXJsKSB7XFxyXFxuICAgICAgICBjb25zb2xlLmxvZyhcXFwi6K+36YWN572u5aW9X3RoaXMudXBsb2FkcHJvcHMudXBkYXRlVXJsXFxcIik7XFxyXFxuICAgICAgICAkKFxcXCIjZG5kQXJlYSBwXFxcIikuaHRtbChcXFwi6K+36YWN572u5aW9dXBsb2FkcHJvcHMudXBkYXRlVXJsXFxcIik7XFxyXFxuICAgICAgICByZXR1cm4gZmFsc2U7XFxyXFxuICAgICAgfVxcclxcbiAgICAgIGlmICghX3RoaXMudXBsb2FkcHJvcHMucmVtb3ZlVXJsKSB7XFxyXFxuICAgICAgICBjb25zb2xlLmxvZyhcXFwi6K+36YWN572u5aW9X3RoaXMudXBsb2FkcHJvcHMucmVtb3ZlVXJsXFxcIik7XFxyXFxuICAgICAgICAkKFxcXCIjZG5kQXJlYSBwXFxcIikuaHRtbChcXFwi6K+36YWN572u5aW9dXBsb2FkcHJvcHMucmVtb3ZlVXJsXFxcIik7XFxyXFxuICAgICAgICByZXR1cm4gZmFsc2U7XFxyXFxuICAgICAgfVxcclxcbiAgICAgIHZhciBkaXNYID0gMDtcXHJcXG4gICAgICB2YXIgZGlzWSA9IDA7XFxyXFxuICAgICAgdmFyIG1pblppbmRleCA9IDE7XFxyXFxuICAgICAgdmFyIG9yaWdpbjtcXHJcXG4gICAgICB2YXIgaXNfbW92ZWluZyA9IGZhbHNlO1xcclxcbiAgICAgIHZhciAkd3JhcCA9ICQoXFxcIiNcXFwiICsgX3RoaXMudXBsb2FkcHJvcHMuY29uZmlnLndyYXBJZCk7XFxyXFxuICAgICAgLyogdmFyICRxdWV1ZSA9ICQoJzx1bCBjbGFzcz1cXFwiZmlsZWxpc3RcXFwiPjwvdWw+JykuYXBwZW5kVG8oXFxyXFxuICAgICAgICAkd3JhcC5maW5kKFxcXCIucXVldWVMaXN0XFxcIilcXHJcXG4gICAgICApOyAqL1xcclxcbiAgICAgIHZhciAkcXVldWUgPSAkKFxcXCIuZmlsZWxpc3RcXFwiKTtcXHJcXG4gICAgICB2YXIgJHN0YXR1c0JhciA9ICR3cmFwLmZpbmQoXFxcIi5zdGF0dXNCYXJcXFwiKTtcXHJcXG4gICAgICB2YXIgJGluZm8gPSAkc3RhdHVzQmFyLmZpbmQoXFxcIi5pbmZvXFxcIik7XFxyXFxuICAgICAgdmFyICR1cGxvYWQgPSAkd3JhcC5maW5kKFxcXCIudXBsb2FkQnRuXFxcIik7XFxyXFxuICAgICAgdmFyICRwbGFjZUhvbGRlciA9ICR3cmFwLmZpbmQoXFxcIi5wbGFjZWhvbGRlclxcXCIpO1xcclxcbiAgICAgIHZhciAkcHJvZ3Jlc3MgPSAkc3RhdHVzQmFyLmZpbmQoXFxcIi5wcm9ncmVzc1xcXCIpLmhpZGUoKTtcXHJcXG4gICAgICB2YXIgZmlsZUNvdW50ID0gMDtcXHJcXG4gICAgICB2YXIgZmlsZVNpemUgPSAwO1xcclxcbiAgICAgIHZhciBzdGF0ZSA9IFxcXCJwZWRkaW5nXFxcIjtcXHJcXG4gICAgICB2YXIgcGVyY2VudGFnZXMgPSB7fTtcXHJcXG4gICAgICB2YXIgc3VwcG9ydFRyYW5zaXRpb24gPSAoZnVuY3Rpb24oKSB7XFxyXFxuICAgICAgICB2YXIgcyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXFxcInBcXFwiKS5zdHlsZSxcXHJcXG4gICAgICAgICAgciA9XFxyXFxuICAgICAgICAgICAgXFxcInRyYW5zaXRpb25cXFwiIGluIHMgfHxcXHJcXG4gICAgICAgICAgICBcXFwiV2Via2l0VHJhbnNpdGlvblxcXCIgaW4gcyB8fFxcclxcbiAgICAgICAgICAgIFxcXCJNb3pUcmFuc2l0aW9uXFxcIiBpbiBzIHx8XFxyXFxuICAgICAgICAgICAgXFxcIm1zVHJhbnNpdGlvblxcXCIgaW4gcyB8fFxcclxcbiAgICAgICAgICAgIFxcXCJPVHJhbnNpdGlvblxcXCIgaW4gcztcXHJcXG4gICAgICAgIHMgPSBudWxsO1xcclxcbiAgICAgICAgLy9yZXR1cm4gcjsgIC8v5pqC5pe25YWI5YaZ5q27ICDku6XlkI7pgYfliLDpl67popjlho3osIPor5Ugd3FkXFxyXFxuICAgICAgICByZXR1cm4gdHJ1ZVxcclxcbiAgICAgIH0pKCk7XFxyXFxuICAgICAgLy8g5LyY5YyWcmV0aW5hLCDlnKhyZXRpbmHkuIvov5nkuKrlgLzmmK8yXFxyXFxuICAgICAgdmFyIHJhdGlvID0gd2luZG93LmRldmljZVBpeGVsUmF0aW8gfHwgMTtcXHJcXG4gICAgICAvLyDnvKnnlaXlm77lpKflsI9cXHJcXG4gICAgICB2YXIgdGh1bWJuYWlsV2lkdGggPSBfdGhpcy51cGxvYWRwcm9wcy5jb25maWcudGh1bWJXaWR0aCB8fCAxMTA7XFxyXFxuICAgICAgdGh1bWJuYWlsV2lkdGggKj0gcmF0aW87XFxyXFxuICAgICAgdmFyIHRodW1ibmFpbEhlaWdodCA9IF90aGlzLnVwbG9hZHByb3BzLmNvbmZpZy50aHVtYkhlaWdodCB8fCAxMTA7XFxyXFxuICAgICAgdGh1bWJuYWlsSGVpZ2h0ICo9IHJhdGlvO1xcclxcbiAgICAgIHZhciB1cGxvYWRlciA9IFdlYlVwbG9hZGVyLmNyZWF0ZSh7XFxyXFxuICAgICAgICBzd2Y6IFxcXCJodHRwOi8vY2RuLnN0YXRpY2ZpbGUub3JnL3dlYnVwbG9hZGVyLzAuMS4wL1VwbG9hZGVyLnN3ZlxcXCIsIC8vcmVxdWlyZSgnQC9jb21wb25lbnRzL3dlYnVwbG9hZGVyL3dlYnVwbG9hZGVyLTAuMS41L1VwbG9hZGVyLnN3ZicpXFxyXFxuICAgICAgICBzZXJ2ZXI6IF90aGlzLnVwbG9hZHByb3BzLnVwbG9hZFVybCxcXHJcXG4gICAgICAgIHBpY2s6IHtcXHJcXG4gICAgICAgICAgaWQ6IFxcXCIjZmlsZVBpY2tlclxcXCIsXFxyXFxuICAgICAgICAgIGxhYmVsOiBcXFwi54K55Ye76YCJ5oup5Zu+54mHXFxcIlxcclxcbiAgICAgICAgfSxcXHJcXG4gICAgICAgIGRuZDogXFxcIi5xdWV1ZUxpc3RcXFwiLFxcclxcbiAgICAgICAgcGFzdGU6IGRvY3VtZW50LmJvZHksXFxyXFxuICAgICAgICBhY2NlcHQ6IHtcXHJcXG4gICAgICAgICAgdGl0bGU6IFxcXCJJbWFnZXNcXFwiLFxcclxcbiAgICAgICAgICBleHRlbnNpb25zOiBfdGhpcy51cGxvYWRwcm9wcy5jb25maWcuZmlsZWZvcm1hdCxcXHJcXG4gICAgICAgICAgbWltZVR5cGVzOiBcXFwiKlxcXCJcXHJcXG4gICAgICAgIH0sXFxyXFxuICAgICAgICByZXNpemU6IGZhbHNlLFxcclxcbiAgICAgICAgZGlzYWJsZUdsb2JhbERuZDogdHJ1ZSxcXHJcXG4gICAgICAgIGNodW5rZWQ6IHRydWUsXFxyXFxuICAgICAgICBmaWxlTnVtTGltaXQ6IDk5OTlcXHJcXG4gICAgICB9KTtcXHJcXG5cXHJcXG4gICAgICBmdW5jdGlvbiBzZXREcmFnRXZlbnQoKSB7XFxyXFxuICAgICAgICAkKHRoaXMpLm9uKFxcXCJkcm9wXFxcIiwgZnVuY3Rpb24oZSkge1xcclxcbiAgICAgICAgICB2YXIgJGZyb20gPSAkKG9yaWdpbikucGFyZW50cyhcXFwibGlcXFwiKTtcXHJcXG4gICAgICAgICAgdmFyICR0byA9ICQoZS50YXJnZXQpLnBhcmVudHMoXFxcImxpXFxcIik7XFxyXFxuICAgICAgICAgIHZhciBvcmlnaW5fcG9zID0gJGZyb20ucG9zaXRpb24oKTtcXHJcXG4gICAgICAgICAgdmFyIHRhcmdldF9wb3MgPSAkdG8ucG9zaXRpb24oKTtcXHJcXG4gICAgICAgICAgdmFyIGZyb21fc29ydCA9ICRmcm9tLmF0dHIoXFxcImRhdGEtc29ydFxcXCIpO1xcclxcbiAgICAgICAgICB2YXIgdG9fc29ydCA9ICR0by5hdHRyKFxcXCJkYXRhLXNvcnRcXFwiKTtcXHJcXG5cXHJcXG4gICAgICAgICAgJGZyb20uYWRkQ2xhc3MoXFxcIm1vdmVcXFwiKS5hbmltYXRlKHRhcmdldF9wb3MsIFxcXCJmYXN0XFxcIiwgZnVuY3Rpb24oKSB7XFxyXFxuICAgICAgICAgICAgJCh0aGlzKS5yZW1vdmVDbGFzcyhcXFwibW92ZVxcXCIpO1xcclxcbiAgICAgICAgICB9KS5hdHRyKFxcXCJkYXRhLXNvcnRcXFwiLCB0b19zb3J0KTtcXHJcXG5cXHJcXG4gICAgICAgICAgJHRvLmFkZENsYXNzKFxcXCJtb3ZlXFxcIikuYW5pbWF0ZShvcmlnaW5fcG9zLCBcXFwiZmFzdFxcXCIsIGZ1bmN0aW9uKCkge1xcclxcbiAgICAgICAgICAgICQodGhpcykucmVtb3ZlQ2xhc3MoXFxcIm1vdmVcXFwiKTtcXHJcXG4gICAgICAgICAgfSkuYXR0cihcXFwiZGF0YS1zb3J0XFxcIiwgZnJvbV9zb3J0KTtcXHJcXG4gICAgICAgIH0pXFxyXFxuICAgICAgICAgIC5vbihcXFwiZHJhZ3N0YXJ0XFxcIiwgZnVuY3Rpb24oZSkge1xcclxcbiAgICAgICAgICAgIGlmIChpc19tb3ZlaW5nKSB7XFxyXFxuICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XFxyXFxuICAgICAgICAgICAgfVxcclxcbiAgICAgICAgICAgIGlzX21vdmVpbmcgPSB0cnVlO1xcclxcbiAgICAgICAgICAgIGUub3JpZ2luYWxFdmVudC5kYXRhVHJhbnNmZXIuZWZmZWN0QWxsb3dkID0gXFxcIm1vdmVcXFwiO1xcclxcbiAgICAgICAgICAgIG9yaWdpbiA9IHRoaXM7XFxyXFxuICAgICAgICAgIH0pXFxyXFxuICAgICAgICAgIC5vbihcXFwiZHJhZ292ZXJcXFwiLCBmdW5jdGlvbihlKSB7XFxyXFxuICAgICAgICAgICAgaWYgKGUucHJldmVudERlZmF1bHQpIGUucHJldmVudERlZmF1bHQoKTtcXHJcXG4gICAgICAgICAgICBpc19tb3ZlaW5nID0gZmFsc2U7XFxyXFxuICAgICAgICAgICAgZS5vcmlnaW5hbEV2ZW50LmRhdGFUcmFuc2Zlci5kcm9wRWZmZWN0ID0gXFxcIm1vdmVcXFwiO1xcclxcbiAgICAgICAgICB9KTtcXHJcXG4gICAgICB9XFxyXFxuXFxyXFxuICAgICAgLy/mm7TmlrDmnI3liqHnq6/pmYTku7ZcXHJcXG4gICAgICBmdW5jdGlvbiB1cGRhdGVTZXJ2ZXJGaWxlcygpIHtcXHJcXG4gICAgICAgIHZhciBwb3N0RGF0YSA9IHt9O1xcclxcbiAgICAgICAgJCgnW2RhdGEtc3JjPVxcXCJzZXJ2ZXJcXFwiXScpLmVhY2goZnVuY3Rpb24oaW5kZXgsIG9iaikge1xcclxcbiAgICAgICAgICBwb3N0RGF0YVskKG9iaikuYXR0cihcXFwiZGF0YS1rZXlcXFwiKV0gPSAkKG9iaikuYXR0cihcXFwiZGF0YS1zb3J0XFxcIik7XFxyXFxuICAgICAgICB9KTtcXHJcXG4gICAgICAgICQuYWpheCh7XFxyXFxuICAgICAgICAgIHR5cGU6IFxcXCJwb3N0XFxcIixcXHJcXG4gICAgICAgICAgdXJsOiBfdGhpcy51cGxvYWRwcm9wcy51cGRhdGVVcmwsXFxyXFxuICAgICAgICAgIGRhdGE6IHBvc3REYXRhLFxcclxcbiAgICAgICAgICBkYXRhVHlwZTogXFxcImpzb25cXFwiLFxcclxcbiAgICAgICAgICBzdWNjZXNzOiBmdW5jdGlvbihkYXRhKSB7XFxyXFxuICAgICAgICAgICAgLy9zZXRTdGF0ZSgnZmluaXNoJyk7XFxyXFxuICAgICAgICAgICAgYWxlcnQoXFxcIuabtOaWsOaIkOWKn1xcXCIpO1xcclxcbiAgICAgICAgICAgICR1cGxvYWQucmVtb3ZlQ2xhc3MoXFxcImRpc2FibGVkXFxcIik7XFxyXFxuICAgICAgICAgICAgc2V0U3RhdGUoXFxcInJlYWR5XFxcIik7XFxyXFxuICAgICAgICAgICAgdXBsb2FkZXIucmVzZXQoKTtcXHJcXG4gICAgICAgICAgfVxcclxcbiAgICAgICAgfSk7XFxyXFxuICAgICAgfVxcclxcblxcclxcbiAgICAgIC8v5Yig6Zmk5pyN5Yqh56uv6ZmE5Lu2XFxyXFxuICAgICAgZnVuY3Rpb24gcmVtb3ZlU2VydmVyRmlsZShmaWxlLGRhdGEsYSxiKSB7XFxyXFxuICAgICAgICB2YXIgc2VuZERhdGEgPSB7XFxyXFxuICAgICAgICAgICdzZXJ2aWNlJzogJ0ltZ0NvbW1vblNlcnZpY2UnLFxcclxcbiAgICAgICAgICAnbWV0aG9kJzogJ2RlbGV0ZUltYWdlJyxcXHJcXG4gICAgICAgICAgJ0ZfSU1HX0lORk9TJzogW1xcclxcbiAgICAgICAgICAgIHtcXHJcXG4gICAgICAgICAgICAgICdGX1BLRVknOiBmaWxlLkZfUEtFWSxcXHJcXG4gICAgICAgICAgICB9XFxyXFxuICAgICAgICAgIF1cXHJcXG4gICAgICAgIH1cXHJcXG4gICAgICAgICQuYWpheCh7XFxyXFxuICAgICAgICAgIHVybDogcHJvY2Vzcy5lbnYuQkFTRV9BUEkgKyAnL2NvbW1BY3Rpb24uZG8nLFxcclxcbiAgICAgICAgICB0eXBlOiAnUE9TVCcsXFxyXFxuICAgICAgICAgIGRhdGE6IHsganNvbmRhdGE6IEpTT04uc3RyaW5naWZ5KHNlbmREYXRhKSB9LFxcclxcbiAgICAgICAgICBkYXRhVHlwZTogJ2pzb24nLFxcclxcbiAgICAgICAgICBhc3luYzogZmFsc2UsXFxyXFxuICAgICAgICAgIHN1Y2Nlc3M6IGZ1bmN0aW9uKGRhdGEpIHtcXHJcXG4gICAgICAgICAgICBpZiAoZGF0YS5GX0NPREUgPT09ICcwJykge1xcclxcbiAgICAgICAgICAgICAgZmlsZUNvdW50LS07XFxyXFxuICAgICAgICAgICAgICB1cGRhdGVTdGF0dXMoKTtcXHJcXG4gICAgICAgICAgICB9XFxyXFxuICAgICAgICAgICAgdmFyIHRleHQgPSBkYXRhLkZfTUVTU0FHRVxcclxcbiAgICAgICAgICAgIF90aGlzLiRpbmZvKHtcXHJcXG4gICAgICAgICAgICAgIHRpdGxlOiAn5o+Q56S6JyxcXHJcXG4gICAgICAgICAgICAgIG9rVGV4dDogJ+ehruiupCcsXFxyXFxuICAgICAgICAgICAgICBjb250ZW50OiB0ZXh0XFxyXFxuICAgICAgICAgICAgfSlcXHJcXG4gICAgICAgICAgICAvLyBfdGhpcy4kcm91dGVyLmdvKDApIC8vIOWIt+aWsOW9k+WJjemhtemdolxcclxcbiAgICAgICAgICB9XFxyXFxuICAgICAgICB9KVxcclxcbiAgICAgICAgLyogJC5hamF4KHtcXHJcXG4gICAgICAgICAgdHlwZTogXFxcImdldFxcXCIsXFxyXFxuICAgICAgICAgIHVybDogX3RoaXMudXBsb2FkcHJvcHMucmVtb3ZlVXJsLFxcclxcbiAgICAgICAgICBkYXRhOiB7IGlkOiBmaWxlLm5hbWUgfSxcXHJcXG4gICAgICAgICAgZGF0YVR5cGU6IFxcXCJqc29uXFxcIixcXHJcXG4gICAgICAgICAgc3VjY2VzczogZnVuY3Rpb24oZGF0YSkge1xcclxcbiAgICAgICAgICAgIGZpbGVDb3VudC0tO1xcclxcbiAgICAgICAgICAgIHVwZGF0ZVN0YXR1cygpO1xcclxcbiAgICAgICAgICB9XFxyXFxuICAgICAgICB9KTsgKi9cXHJcXG4gICAgICB9XFxyXFxuXFxyXFxuICAgICAgLy/liJ3lp4vljJbmnI3liqHnq6/pmYTku7ZcXHJcXG4gICAgICBmdW5jdGlvbiBpbml0U2VydmVyRmlsZSgpIHtcXHJcXG4gICAgICAgIGlmIChfdGhpcy51cGxvYWRwcm9wcy5pbml0VXJsKSB7XFxyXFxuICAgICAgICAgICQuZWFjaChfdGhpcy5pbml0ZmlsZXMsZnVuY3Rpb24oayxmbCl7XFxyXFxuICAgICAgICAgICAgJC5lYWNoKGZsLkZfQVRUQUNIUyxmdW5jdGlvbihpbmRleCxmaWxlKXtcXHJcXG4gICAgICAgICAgICAgIGZpbGUuRl9GSUxFX1RQID0gZmlsZS5GX0ZJTEVfVFAudG9Mb3dlckNhc2UoKVxcclxcbiAgICAgICAgICAgICAgdmFyIHNyYyA9IFxcXCJcXFwiLy/lm77niYflnLDlnYBcXHJcXG4gICAgICAgICAgICAgIHRyeSB7XFxyXFxuICAgICAgICAgICAgICAgIHNyYyA9ICQuaW5BcnJheShmaWxlLkZfRklMRV9UUCwgVXRpbC5pbWdTdWZmaXgpICE9PSAtMT9VdGlsLmNyZWF0ZUltZ1VybChmaWxlLkZfQVRUX1NUT19LRVkpOnJlcXVpcmUoJ0AvYXNzZXRzL2ltYWdldmlldy9zdWZmaXgvJyArIGZpbGUuRl9GSUxFX1RQICsgJy5wbmcnKVxcclxcbiAgICAgICAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcXHJcXG4gICAgICAgICAgICAgICAgc3JjID0gJC5pbkFycmF5KGZpbGUuRl9GSUxFX1RQLCBVdGlsLmltZ1N1ZmZpeCkgIT09IC0xP1V0aWwuY3JlYXRlSW1nVXJsKGZpbGUuRl9BVFRfU1RPX0tFWSk6cmVxdWlyZSgnQC9hc3NldHMvaW1hZ2V2aWV3L3N1ZmZpeC9vdGhlci5wbmcnKVxcclxcbiAgICAgICAgICAgICAgfVxcclxcbiAgICAgICAgICAgICAgdmFyIG9iaiAgPSB7XFxyXFxuICAgICAgICAgICAgICAgIGlkOlxcXCJTVlJfRklMRV9cXFwiICsgaW5kZXgsXFxyXFxuICAgICAgICAgICAgICAgIHNyYzonc2VydmVyJyxcXHJcXG4gICAgICAgICAgICAgICAgbmFtZTpmaWxlLkZfQVRUX1RJVExFLFxcclxcbiAgICAgICAgICAgICAgICBwYXRoIDogc3JjLFxcclxcbiAgICAgICAgICAgICAgICByb3RhdGlvbjowLFxcclxcbiAgICAgICAgICAgICAgICBzaXplOnBhcnNlRmxvYXQoZmlsZS5GX0FUVF9TSVpFKSxcXHJcXG4gICAgICAgICAgICAgICAgdHlwZTpmaWxlLkZfRklMRV9UUCxcXHJcXG4gICAgICAgICAgICAgICAgRl9GSUxFX1RQOmZpbGUuRl9GSUxFX1RQLFxcclxcbiAgICAgICAgICAgICAgICBGX1BLRVk6ZmlsZS5GX1BLRVksXFxyXFxuICAgICAgICAgICAgICAgIEZfUEFSRU5UOmZpbGUuRl9QQVJFTlQsXFxyXFxuICAgICAgICAgICAgICAgIEZfSU1HX0NPREU6ZmwuRl9JTUdfQ09ERSxcXHJcXG4gICAgICAgICAgICAgICAgRl9ST1RBVEU6ZmwuRl9ST1RBVEUvL+aXi+i9rOW6puaVsFxcclxcbiAgICAgICAgICAgICAgfVxcclxcbiAgICAgICAgICAgICAgZmlsZVF1ZXVlKG9iaik7XFxyXFxuICAgICAgICAgICAgfSlcXHJcXG4gICAgICAgICAgfSlcXHJcXG4gICAgICAgICAgX3RoaXMuc2hvd0ltZ2xpc3QoX3RoaXMuY3VycmVudE5vZGUpXFxyXFxuICAgICAgICAgIC8qIHZhciBsZW4gPSBkYXRhLmxlbmd0aDtcXHJcXG4gICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcXHJcXG4gICAgICAgICAgICAgICAgZGF0YVtpXS5zcmMgPSBcXFwic2VydmVyXFxcIjtcXHJcXG4gICAgICAgICAgICAgICAgZGF0YVtpXS5pZCA9IFxcXCJTVlJfRklMRV9cXFwiICsgaTtcXHJcXG4gICAgICAgICAgICAgICAgZGF0YVtpXS5yb3RhdGlvbiA9IDA7XFxyXFxuICAgICAgICAgICAgICAgIGZpbGVRdWV1ZShkYXRhW2ldKTtcXHJcXG4gICAgICAgICAgICAgIH0gKi9cXHJcXG4gICAgICAgIH1cXHJcXG4gICAgICB9XFxyXFxuXFxyXFxuICAgICAgLy/mt7vliqDpmYTku7bliLB3ZWJ1cGxvYWRlcuS4rVxcclxcbiAgICAgIGZ1bmN0aW9uIGFkZEZpbGUoZmlsZSkge1xcclxcbiAgICAgICAgdmFyIGRhdGF0eXBlID0gX3RoaXMuY3VycmVudE5vZGVcXHJcXG4gICAgICAgIGZpbGUuRl9ST1RBVEUgPSBmaWxlLkZfUk9UQVRFfHwwXFxyXFxuICAgICAgICBpZihmaWxlLnNyYyA9PT0gJ3NlcnZlcicpe1xcclxcbiAgICAgICAgICBkYXRhdHlwZSA9IGZpbGUuRl9QQVJFTlRcXHJcXG4gICAgICAgIH1lbHNle1xcclxcbiAgICAgICAgICBmaWxlLkZfSU1HX1RZUEUgPSBkYXRhdHlwZVxcclxcbiAgICAgICAgfVxcclxcbiAgICAgICAgJC5lYWNoKF90aGlzLmluaXRmaWxlcyxmdW5jdGlvbihrLHYpe1xcclxcbiAgICAgICAgICBpZih2LmtleSA9PT0gZGF0YXR5cGUpe1xcclxcbiAgICAgICAgICAgIGZpbGUuRl9JTUdfQ09ERSA9IHYuRl9JTUdfQ09ERVxcclxcbiAgICAgICAgICB9XFxyXFxuICAgICAgICB9KVxcclxcbiAgICAgICAgdmFyIGluZGV4ID0gJHF1ZXVlLmZpbmQoXFxcImxpW2RhdGEtdHlwZT0nXFxcIiArIGRhdGF0eXBlICsgXFxcIiddXFxcIikubGVuZ3RoO1xcclxcbiAgICAgICAgLyogdmFyIGltZ0xlZnQgPSBpbmRleCAqICh0aHVtYm5haWxXaWR0aCArIDEwKTtcXHJcXG4gICAgICAgIHZhciBpbWdUb3AgPSAwO1xcclxcbiAgICAgICAgdmFyIHdyYXBIZWlnaHQgPSB0aHVtYm5haWxIZWlnaHQgKyAyMDtcXHJcXG4gICAgICAgIHZhciB3cmFwV2lkdGggPSAkcXVldWUud2lkdGgoKTtcXHJcXG4gICAgICAgIGlmIChpbWdMZWZ0ICsgKHRodW1ibmFpbFdpZHRoICsgMTApID49IHdyYXBXaWR0aCkge1xcclxcbiAgICAgICAgICBpbWdUb3AgPVxcclxcbiAgICAgICAgICAgIHBhcnNlSW50KChpbWdMZWZ0ICsgKHRodW1ibmFpbFdpZHRoICsgMTApKSAvIHdyYXBXaWR0aCkgKlxcclxcbiAgICAgICAgICAgICh0aHVtYm5haWxIZWlnaHQgKyAxMCk7XFxyXFxuICAgICAgICAgIHdyYXBIZWlnaHQgPSBpbWdUb3AgKyB3cmFwSGVpZ2h0O1xcclxcbiAgICAgICAgICBpbWdMZWZ0ID1cXHJcXG4gICAgICAgICAgICAoaW5kZXggJSBwYXJzZUludCh3cmFwV2lkdGggLyAodGh1bWJuYWlsV2lkdGggKyAxMCkpKSAqXFxyXFxuICAgICAgICAgICAgKHRodW1ibmFpbFdpZHRoICsgMTApO1xcclxcbiAgICAgICAgfSAqL1xcclxcblxcclxcbiAgICAgICAgJChcXFwiLnZjaHJpbWFnZSAubWlkZGxlXFxcIikuY3NzKFxcXCJvdmVyZmxvdy15XFxcIixcXFwiaGlkZGVuXFxcIilcXHJcXG4gICAgICAgICQoXFxcIi52Y2hyaW1hZ2UgLmNhdGVnb3J5LXZpZXdcXFwiKS5jc3MoXFxcIm92ZXJmbG93LXlcXFwiLFxcXCJoaWRkZW5cXFwiKVxcclxcbiAgICAgICAgdmFyIGxpSGVpZ2h0ID0gdGh1bWJuYWlsSGVpZ2h0KzI1O1xcclxcbiAgICAgICAgdmFyIHdyYXBXaWR0aCA9ICRxdWV1ZS53aWR0aCgpO1xcclxcbiAgICAgICAgdmFyIHdyYXBIZWlnaHQgPSBsaUhlaWdodCArIDIwO1xcclxcbiAgICAgICAgdmFyIGltZ051bSA9IHBhcnNlSW50KHdyYXBXaWR0aCAvICh0aHVtYm5haWxXaWR0aCArIDEwKSkgLy8g5q+P6KGM5pyJ5Yeg5byg5Zu+54mHXFxyXFxuICAgICAgICB2YXIgaW1nVG9wID0gMFxcclxcbiAgICAgICAgdmFyIGltZ0xlZnQgPSBpbmRleCAqICh0aHVtYm5haWxXaWR0aCArIDEwKVxcclxcbiAgICAgICAgaWYgKGluZGV4ICsgMSA+IGltZ051bSkge1xcclxcbiAgICAgICAgICBpbWdUb3AgPSBwYXJzZUludChpbmRleCAvIGltZ051bSkgKiAobGlIZWlnaHQrMTApXFxyXFxuICAgICAgICAgIGltZ0xlZnQgPSAoaW5kZXggJSBpbWdOdW0pICogKHRodW1ibmFpbFdpZHRoICsgMTApXFxyXFxuICAgICAgICAgIHdyYXBIZWlnaHQgPSBpbWdUb3AgKyBsaUhlaWdodCArIDEwXFxyXFxuICAgICAgICB9XFxyXFxuXFxyXFxuXFxyXFxuICAgICAgICAkcXVldWUuaGVpZ2h0KHdyYXBIZWlnaHQpO1xcclxcbiAgICAgICAgdmFyICRsaSA9ICQoXFxyXFxuICAgICAgICAgICAgJzxsaSBkYXRhLWtleT1cXFwiJyArXFxyXFxuICAgICAgICAgICAgICBmaWxlLmtleSArXFxyXFxuICAgICAgICAgICAgICAnXFxcIiAgZGF0YS1zcmM9XFxcIicgK1xcclxcbiAgICAgICAgICAgICAgZmlsZS5zcmMgK1xcclxcbiAgICAgICAgICAgICAgJ1xcXCIgZGF0YS1zb3J0PVxcXCInICtcXHJcXG4gICAgICAgICAgICAgIGluZGV4ICtcXHJcXG4gICAgICAgICAgICAgICAnXFxcIiBkYXRhLWRlZz1cXFwiJyArXFxyXFxuICAgICAgICAgICAgICBmaWxlLkZfUk9UQVRFICtcXHJcXG4gICAgICAgICAgICAgICdcXFwiIGRhdGEtdHlwZT1cXFwiJyArXFxyXFxuICAgICAgICAgICAgICBkYXRhdHlwZSArXFxyXFxuICAgICAgICAgICAgICAnXFxcIiBkcmFnZ2FibGU9XFxcInRydWVcXFwiIGlkPVxcXCInICtcXHJcXG4gICAgICAgICAgICAgIGZpbGUuaWQgK1xcclxcbiAgICAgICAgICAgICAgJ1xcXCIgc3R5bGU9XFxcInBvc2l0aW9uOmFic29sdXRlO21hcmdpbjowO2N1cnNvcjptb3ZlO3dpZHRoOicgK1xcclxcbiAgICAgICAgICAgICAgdGh1bWJuYWlsV2lkdGggK1xcclxcbiAgICAgICAgICAgICAgXFxcInB4O2hlaWdodDpcXFwiICtcXHJcXG4gICAgICAgICAgICAgIGxpSGVpZ2h0ICtcXHJcXG4gICAgICAgICAgICAgIFxcXCJweDtsZWZ0OlxcXCIgK1xcclxcbiAgICAgICAgICAgICAgaW1nTGVmdCArXFxyXFxuICAgICAgICAgICAgICBcXFwicHg7dG9wOlxcXCIgK1xcclxcbiAgICAgICAgICAgICAgaW1nVG9wICtcXHJcXG4gICAgICAgICAgICAgICdweFxcXCI+JyArXFxyXFxuICAgICAgICAgICAgICAnPHAgY2xhc3M9XFxcImltZ1dyYXBcXFwiPjwvcD4nICtcXHJcXG4gICAgICAgICAgICAgICc8cCBjbGFzcz1cXFwidGl0bGVcXFwiPicgK1xcclxcbiAgICAgICAgICAgICAgZmlsZS5uYW1lICtcXHJcXG4gICAgICAgICAgICAgIFxcXCI8L3A+XFxcIiArXFxyXFxuICAgICAgICAgICAgICAnPHAgY2xhc3M9XFxcInByb2dyZXNzXFxcIj48c3Bhbj48L3NwYW4+PC9wPicgK1xcclxcbiAgICAgICAgICAgICAgXFxcIjwvbGk+XFxcIlxcclxcbiAgICAgICAgICApLFxcclxcbiAgICAgICAgICAkYnRucyA9ICQoXFxyXFxuICAgICAgICAgICAgJzxkaXYgY2xhc3M9XFxcImZpbGUtcGFuZWxcXFwiPicgKyAnPHNwYW4gY2xhc3M9XFxcImNhbmNlbFxcXCI+5Yig6ZmkPC9zcGFuPicrXFxyXFxuICAgICAgICAgICAgJzxzcGFuIGNsYXNzPVxcXCJyb3RhdGVSaWdodFxcXCI+5ZCR5Y+z5peL6L2sPC9zcGFuPicgK1xcclxcbiAgICAgICAgICAgICc8c3BhbiBjbGFzcz1cXFwicm90YXRlTGVmdFxcXCI+5ZCR5bem5peL6L2sPC9zcGFuPjwvZGl2PidcXHJcXG4gICAgICAgICAgKS5hcHBlbmRUbygkbGkpLFxcclxcbiAgICAgICAgICAkcHJvZ2VzcyA9ICRsaS5maW5kKFxcXCJwLnByb2dyZXNzIHNwYW5cXFwiKSxcXHJcXG4gICAgICAgICAgJHdyYXAgPSAkbGkuZmluZChcXFwicC5pbWdXcmFwXFxcIiksXFxyXFxuICAgICAgICAgICRpbmZvID0gJCgnPHAgY2xhc3M9XFxcImVycm9yXFxcIj48L3A+JyksXFxyXFxuICAgICAgICAgIHNob3dFcnJvciA9IGZ1bmN0aW9uKGNvZGUpIHtcXHJcXG4gICAgICAgICAgICB2YXIgdGV4dCA9IFxcXCJcXFwiXFxyXFxuICAgICAgICAgICAgc3dpdGNoIChjb2RlKSB7XFxyXFxuICAgICAgICAgICAgICBjYXNlIFxcXCJleGNlZWRfc2l6ZVxcXCI6XFxyXFxuICAgICAgICAgICAgICAgIHRleHQgPSBcXFwi5paH5pys5aSn5bCP6LaF5Ye6XFxcIjtcXHJcXG4gICAgICAgICAgICAgICAgYnJlYWs7XFxyXFxuICAgICAgICAgICAgICBjYXNlIFxcXCJpbnRlcnJ1cHRcXFwiOlxcclxcbiAgICAgICAgICAgICAgICB0ZXh0ID0gXFxcIuS4iuS8oOaaguWBnFxcXCI7XFxyXFxuICAgICAgICAgICAgICAgIGJyZWFrO1xcclxcbiAgICAgICAgICAgICAgZGVmYXVsdDpcXHJcXG4gICAgICAgICAgICAgICAgdGV4dCA9IFxcXCLkuIrkvKDlpLHotKVcXFwiO1xcclxcbiAgICAgICAgICAgICAgICBicmVhaztcXHJcXG4gICAgICAgICAgICB9XFxyXFxuICAgICAgICAgICAgJGluZm8udGV4dCh0ZXh0KS5hcHBlbmRUbygkbGkpO1xcclxcbiAgICAgICAgICB9O1xcclxcbiAgICAgICAgICBpZiAoc3VwcG9ydFRyYW5zaXRpb24pIHtcXHJcXG4gICAgICAgICAgICB2YXIgZGVncyA9IFxcXCJyb3RhdGUoXFxcIiArIGZpbGUucm90YXRpb258fDAgKyBcXFwiZGVnKVxcXCI7XFxyXFxuICAgICAgICAgICAgICAkd3JhcC5jc3Moe1xcclxcbiAgICAgICAgICAgICAgICBcXFwiLXdlYmtpdC10cmFuc2Zvcm1cXFwiOiBkZWdzLFxcclxcbiAgICAgICAgICAgICAgICBcXFwiLW1vcy10cmFuc2Zvcm1cXFwiOiBkZWdzLFxcclxcbiAgICAgICAgICAgICAgICBcXFwiLW8tdHJhbnNmb3JtXFxcIjogZGVncyxcXHJcXG4gICAgICAgICAgICAgICAgdHJhbnNmb3JtOiBkZWdzXFxyXFxuICAgICAgICAgICAgICB9KTtcXHJcXG4gICAgICAgICAgICB9XFxyXFxuICAgICAgICAgICAvL+WbvueJh+eCueWHu+S6i+S7tlxcclxcbiAgICAgICAgICAkbGkub24oXFxcImNsaWNrXFxcIixmdW5jdGlvbigpe1xcclxcbiAgICAgICAgICAgIHZhciBmaWxlID0gJCh0aGlzKS5kYXRhKFxcXCJmaWxlaW5mb1xcXCIpXFxyXFxuICAgICAgICAgICAgX3RoaXMuJGVtaXQoXFxcImltYWdlQ2xpY2tcXFwiLGZpbGUpXFxyXFxuICAgICAgICAgIH0pXFxyXFxuICAgICAgICAgIGlmIChmaWxlLnNyYyA9PSBcXFwiY2xpZW50XFxcIikge1xcclxcbiAgICAgICAgICAgIGlmIChmaWxlLmdldFN0YXR1cygpID09IFxcXCJpbnZhbGlkXFxcIikge1xcclxcbiAgICAgICAgICAgICAgc2hvd0Vycm9yKGZpbGUuc3RhdHVzVGV4dCk7XFxyXFxuICAgICAgICAgICAgfSBlbHNlIHtcXHJcXG4gICAgICAgICAgICAgICR3cmFwLnRleHQoXFxcIumihOiniOS4rVxcXCIpO1xcclxcbiAgICAgICAgICAgICAgdXBsb2FkZXIubWFrZVRodW1iKFxcclxcbiAgICAgICAgICAgICAgICBmaWxlLFxcclxcbiAgICAgICAgICAgICAgICBmdW5jdGlvbihlcnJvciwgc3JjKSB7XFxyXFxuICAgICAgICAgICAgICAgICAgaWYgKGVycm9yKSB7XFxyXFxuICAgICAgICAgICAgICAgICAgICAvKiAkd3JhcC50ZXh0KFxcXCLkuI3og73pooTop4hcXFwiKTtcXHJcXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjsgKi9cXHJcXG4gICAgICAgICAgICAgICAgICAgIGZpbGUuRl9GSUxFX1RQID0gZmlsZS5leHQudG9Mb3dlckNhc2UoKVxcclxcbiAgICAgICAgICAgICAgICAgICAgdHJ5IHtcXHJcXG4gICAgICAgICAgICAgICAgICAgICAgc3JjID0gJC5pbkFycmF5KGZpbGUuRl9GSUxFX1RQLCBVdGlsLmltZ1N1ZmZpeCkgIT09IC0xP1V0aWwuY3JlYXRlSW1nVXJsKGZpbGUuRl9BVFRfU1RPX0tFWSk6cmVxdWlyZSgnQC9hc3NldHMvaW1hZ2V2aWV3L3N1ZmZpeC8nICsgZmlsZS5leHQgKyAnLnBuZycpXFxyXFxuICAgICAgICAgICAgICAgICAgICB9IGNhdGNoIChlcnJvcikge1xcclxcbiAgICAgICAgICAgICAgICAgICAgICBzcmMgPSAkLmluQXJyYXkoZmlsZS5GX0ZJTEVfVFAsIFV0aWwuaW1nU3VmZml4KSAhPT0gLTE/VXRpbC5jcmVhdGVJbWdVcmwoZmlsZS5GX0FUVF9TVE9fS0VZKTpyZXF1aXJlKCdAL2Fzc2V0cy9pbWFnZXZpZXcvc3VmZml4L290aGVyLnBuZycpXFxyXFxuICAgICAgICAgICAgICAgICAgICB9XFxyXFxuICAgICAgICAgICAgICAgICAgfVxcclxcbiAgICAgICAgICAgICAgICAgIGZpbGUucGF0aCA9IHNyYztcXHJcXG4gICAgICAgICAgICAgICAgICB2YXIgaW1nID0gJCgnPGltZyBkcmFnZ2FibGU9XFxcInRydWVcXFwiIHN0eWxlPVxcXCJ3aWR0aDonK3RodW1ibmFpbFdpZHRoKydweDtoZWlnaHQ6Jyt0aHVtYm5haWxIZWlnaHQrJ3B4XFxcIiBzcmM9XFxcIicgKyBzcmMgKyAnXFxcIj4nKTtcXHJcXG4gICAgICAgICAgICAgICAgICBpbWcuYmluZChcXFwibG9hZFxcXCIsIHNldERyYWdFdmVudCk7XFxyXFxuICAgICAgICAgICAgICAgICAgJHdyYXAuZW1wdHkoKS5hcHBlbmQoaW1nKTtcXHJcXG4gICAgICAgICAgICAgICAgfSxcXHJcXG4gICAgICAgICAgICAgICAgMC44LFxcclxcbiAgICAgICAgICAgICAgICAwLjhcXHJcXG4gICAgICAgICAgICAgICAgLyogdGh1bWJuYWlsV2lkdGgsXFxyXFxuICAgICAgICAgICAgICAgIHRodW1ibmFpbEhlaWdodCAqL1xcclxcbiAgICAgICAgICAgICAgKTtcXHJcXG4gICAgICAgICAgICAgIHBlcmNlbnRhZ2VzW2ZpbGUuaWRdID0gW2ZpbGVTaXplLCAwXTtcXHJcXG4gICAgICAgICAgICAgIGZpbGUucm90YXRpb24gPSAwO1xcclxcbiAgICAgICAgICB9XFxyXFxuICAgICAgICAgIGZpbGUub24oXFxcInN0YXR1c2NoYW5nZVxcXCIsIGZ1bmN0aW9uKGN1ciwgcHJldikge1xcclxcbiAgICAgICAgICAgIGlmIChwcmV2ID09IFxcXCJwcm9ncmVzc1xcXCIpIHtcXHJcXG4gICAgICAgICAgICAgICRwcm9ncmVzcy5oaWRlKCkud2lkdGgoMCk7XFxyXFxuICAgICAgICAgICAgfSBlbHNlIGlmIChwcmV2ID09IFxcXCJxdWV1ZWRcXFwiKSB7XFxyXFxuICAgICAgICAgICAgICAvL3dxZCAyMDE5MDUwN+azqOmHiiAg5LiK5Lyg5oiQ5Yqf5ZCO6L+Y5YWB6K645Yig6ZmkXFxyXFxuICAgICAgICAgICAgICAvLyRsaS5vZmYoJ21vdXNlZW50ZXIgbW91c2VsZWF2ZScpO1xcclxcbiAgICAgICAgICAgICAgLy8kYnRucy5yZW1vdmUoKTtcXHJcXG4gICAgICAgICAgICB9XFxyXFxuXFxyXFxuICAgICAgICAgICAgaWYgKGN1ciA9PSBcXFwiZXJyb3JcXFwiIHx8IGN1ciA9PSBcXFwiaW52YWxpZFxcXCIpIHtcXHJcXG4gICAgICAgICAgICAgIHNob3dFcnJvcihmaWxlLnN0YXR1c1RleHQpO1xcclxcbiAgICAgICAgICAgICAgcGVyY2VudGFnZXNbZmlsZS5pZF1bMV0gPSAxO1xcclxcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoY3VyID09IFxcXCJpbnRlcnJ1cHRcXFwiKSB7XFxyXFxuICAgICAgICAgICAgICBzaG93RXJyb3IoXFxcImludGVycnVwdFxcXCIpO1xcclxcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoY3VyID09IFxcXCJxdWV1ZWRcXFwiKSB7XFxyXFxuICAgICAgICAgICAgICBwZXJjZW50YWdlc1tmaWxlLmlkXVsxXSA9IDA7XFxyXFxuICAgICAgICAgICAgfSBlbHNlIGlmIChjdXIgPT0gXFxcInByb2dyZXNzXFxcIikge1xcclxcbiAgICAgICAgICAgICAgJGluZm8ucmVtb3ZlKCk7XFxyXFxuICAgICAgICAgICAgICAkcHJvZ3Jlc3MuY3NzKFxcXCJkaXNwbGF5XFxcIiwgXFxcImJsb2NrXFxcIik7XFxyXFxuICAgICAgICAgICAgfSBlbHNlIGlmIChjdXIgPT0gXFxcImNvbXBsZXRlXFxcIikge1xcclxcbiAgICAgICAgICAgICAgJGxpLmFwcGVuZCgnPHNwYW4gY2xhc3M9XFxcInN1Y2Nlc3NcXFwiPjwvc3Bhbj4nKTtcXHJcXG4gICAgICAgICAgICB9XFxyXFxuXFxyXFxuICAgICAgICAgICAgJGxpLnJlbW92ZUNsYXNzKFxcXCJzdGF0ZS1cXFwiICsgcHJldikuYWRkQ2xhc3MoXFxcInN0YXRlLVxcXCIgKyBjdXIpO1xcclxcbiAgICAgICAgICAgIHVwZGF0ZVN0YXR1cygpO1xcclxcbiAgICAgICAgICB9KTtcXHJcXG4gICAgICAgIH0gZWxzZSB7XFxyXFxuICAgICAgICAgIHZhciBpbWcgPSAkKCc8aW1nIGRyYWdnYWJsZT1cXFwidHJ1ZVxcXCIgc3R5bGU9XFxcIndpZHRoOicrdGh1bWJuYWlsV2lkdGgrJ3B4O2hlaWdodDonK3RodW1ibmFpbEhlaWdodCsncHhcXFwiIHNyYz1cXFwiJyArIGZpbGUucGF0aCArICdcXFwiPicpO1xcclxcbiAgICAgICAgICBpbWcuYmluZChcXFwibG9hZFxcXCIsIHNldERyYWdFdmVudCk7XFxyXFxuICAgICAgICAgICR3cmFwLmVtcHR5KCkuYXBwZW5kKGltZyk7XFxyXFxuICAgICAgICAgICRsaS5hcHBlbmQoJzxzcGFuIGNsYXNzPVxcXCJzdWNjZXNzXFxcIj48L3NwYW4+Jyk7XFxyXFxuICAgICAgICAgICAkKFxcXCIudmNocmltYWdlIC5taWRkbGVcXFwiKS5jc3MoXFxcIm92ZXJmbG93LXlcXFwiLFxcXCJhdXRvXFxcIilcXHJcXG4gICAgICAgICAgJChcXFwiLnZjaHJpbWFnZSAuY2F0ZWdvcnktdmlld1xcXCIpLmNzcyhcXFwib3ZlcmZsb3cteVxcXCIsXFxcImF1dG9cXFwiKVxcclxcbiAgICAgICAgfVxcclxcblxcclxcbiAgICAgICAgJGxpLm9uKFxcXCJtb3VzZWVudGVyXFxcIiwgZnVuY3Rpb24oKSB7XFxyXFxuICAgICAgICAgICRidG5zLnN0b3AoKS5hbmltYXRlKHsgaGVpZ2h0OiAzMCB9KTtcXHJcXG4gICAgICAgIH0pO1xcclxcbiAgICAgICAgJGxpLm9uKFxcXCJtb3VzZWxlYXZlXFxcIiwgZnVuY3Rpb24oKSB7XFxyXFxuICAgICAgICAgICRidG5zLnN0b3AoKS5hbmltYXRlKHsgaGVpZ2h0OiAwIH0pO1xcclxcbiAgICAgICAgfSk7XFxyXFxuXFxyXFxuICAgICAgICAkYnRucy5vbihcXFwiY2xpY2tcXFwiLCBcXFwic3BhblxcXCIsIGZ1bmN0aW9uKCkge1xcclxcbiAgICAgICAgICB2YXIgaW5kZXggPSAkKHRoaXMpLmluZGV4KCksXFxyXFxuICAgICAgICAgICAgZGVnO1xcclxcblxcclxcbiAgICAgICAgICBzd2l0Y2ggKGluZGV4KSB7XFxyXFxuICAgICAgICAgICAgY2FzZSAwOlxcclxcbiAgICAgICAgICAgICAgLy/kv67mlLnliKDpmaTlkI7pnaLmiYDmnInlm77niYfnmoTkvY3nva5cXHJcXG4gICAgICAgICAgICAgIHZhciBhbGxJbWdzID0ge307XFxyXFxuICAgICAgICAgICAgICB2YXIgZGVsX3NvcnQgPSBwYXJzZUludCgkKFxcXCIjXFxcIiArIGZpbGUuaWQpLmF0dHIoXFxcImRhdGEtc29ydFxcXCIpKTtcXHJcXG4gICAgICAgICAgICAgICRxdWV1ZS5maW5kKFxcXCJsaVxcXCIpLmVhY2goZnVuY3Rpb24oaW5kZXgsIG9iaikge1xcclxcbiAgICAgICAgICAgICAgICBpZiAoJChvYmopLmF0dHIoXFxcImRhdGEtc29ydFxcXCIpID4gZGVsX3NvcnQpIHtcXHJcXG4gICAgICAgICAgICAgICAgICB2YXIgc29ydCA9IHBhcnNlSW50KCQob2JqKS5hdHRyKFxcXCJkYXRhLXNvcnRcXFwiKSk7XFxyXFxuICAgICAgICAgICAgICAgICAgdmFyICRwcmV2T2JqID0gJChcXFwibGlbZGF0YS1zb3J0PVxcXCIgKyAoc29ydCAtIDEpICsgXFxcIl1cXFwiKTtcXHJcXG4gICAgICAgICAgICAgICAgICBpZiAoJHByZXZPYmopIHtcXHJcXG4gICAgICAgICAgICAgICAgICAgIGFsbEltZ3NbJChvYmopLmF0dHIoXFxcImlkXFxcIildID0gJHByZXZPYmoucG9zaXRpb24oKTtcXHJcXG4gICAgICAgICAgICAgICAgICB9XFxyXFxuICAgICAgICAgICAgICAgIH1cXHJcXG4gICAgICAgICAgICAgIH0pO1xcclxcbiAgICAgICAgICAgICAgZm9yICh2YXIgayBpbiBhbGxJbWdzKSB7XFxyXFxuICAgICAgICAgICAgICAgIHZhciBzb3J0ID0gcGFyc2VJbnQoJChcXFwiI1xcXCIgKyBrKS5hdHRyKFxcXCJkYXRhLXNvcnRcXFwiKSk7XFxyXFxuICAgICAgICAgICAgICAgICQoXFxcIiNcXFwiICsgaylcXHJcXG4gICAgICAgICAgICAgICAgICAuYXR0cihcXFwiZGF0YS1zb3J0XFxcIiwgc29ydCAtIDEpXFxyXFxuICAgICAgICAgICAgICAgICAgLmNzcyh7XFxyXFxuICAgICAgICAgICAgICAgICAgICBsZWZ0OiBhbGxJbWdzW2tdLmxlZnQgKyBcXFwicHhcXFwiLFxcclxcbiAgICAgICAgICAgICAgICAgICAgdG9wOiBhbGxJbWdzW2tdLnRvcCArIFxcXCJweFxcXCJcXHJcXG4gICAgICAgICAgICAgICAgICB9KTtcXHJcXG4gICAgICAgICAgICAgIH1cXHJcXG4gICAgICAgICAgICAgIGFsbEltZ3MgPSBudWxsO1xcclxcbiAgICAgICAgICAgICAgaWYgKGZpbGUuc3JjID09IFxcXCJjbGllbnRcXFwiKSB1cGxvYWRlci5yZW1vdmVGaWxlKGZpbGUpO1xcclxcbiAgICAgICAgICAgICAgZWxzZSB7XFxyXFxuICAgICAgICAgICAgICAgIHJlbW92ZVNlcnZlckZpbGUoZmlsZSk7XFxyXFxuICAgICAgICAgICAgICAgICQoXFxcIiNcXFwiICsgZmlsZS5pZCkucmVtb3ZlKCk7XFxyXFxuICAgICAgICAgICAgICAgIF90aGlzLnVwZGF0YUltZ0NvdW50KClcXHJcXG4gICAgICAgICAgICAgIH1cXHJcXG4gICAgICAgICAgICAgIF90aGlzLnNob3dJbWdsaXN0KF90aGlzLmN1cnJlbnROb2RlKVxcclxcbiAgICAgICAgICAgICAgcmV0dXJuO1xcclxcbiAgICAgICAgICAgIGNhc2UgMTpcXHJcXG4gICAgICAgICAgICAgIGZpbGUucm90YXRpb24gKz0gOTA7XFxyXFxuICAgICAgICAgICAgICBicmVhaztcXHJcXG4gICAgICAgICAgICBjYXNlIDI6XFxyXFxuICAgICAgICAgICAgICBmaWxlLnJvdGF0aW9uIC09IDkwO1xcclxcbiAgICAgICAgICAgICAgYnJlYWs7XFxyXFxuICAgICAgICAgIH1cXHJcXG5cXHJcXG4gICAgICAgICAgaWYgKHN1cHBvcnRUcmFuc2l0aW9uKSB7XFxyXFxuICAgICAgICAgICAgZGVnID0gXFxcInJvdGF0ZShcXFwiICsgZmlsZS5yb3RhdGlvbiArIFxcXCJkZWcpXFxcIjtcXHJcXG4gICAgICAgICAgICAkd3JhcC5jc3Moe1xcclxcbiAgICAgICAgICAgICAgXFxcIi13ZWJraXQtdHJhbnNmb3JtXFxcIjogZGVnLFxcclxcbiAgICAgICAgICAgICAgXFxcIi1tb3MtdHJhbnNmb3JtXFxcIjogZGVnLFxcclxcbiAgICAgICAgICAgICAgXFxcIi1vLXRyYW5zZm9ybVxcXCI6IGRlZyxcXHJcXG4gICAgICAgICAgICAgIHRyYW5zZm9ybTogZGVnXFxyXFxuICAgICAgICAgICAgfSk7XFxyXFxuICAgICAgICAgICAgJHdyYXAucGFyZW50KCkuYXR0cihcXFwiZGF0YS1kZWdcXFwiLGZpbGUucm90YXRpb24pXFxyXFxuICAgICAgICAgIH0gZWxzZSB7XFxyXFxuICAgICAgICAgIH1cXHJcXG4gICAgICAgIH0pO1xcclxcbiAgICAgICAgJGxpLmFwcGVuZFRvKCRxdWV1ZSk7XFxyXFxuICAgICAgICAkbGkuZGF0YShcXFwiZmlsZWluZm9cXFwiLGZpbGUpXFxyXFxuICAgICAgICBfdGhpcy51cGRhdGFJbWdDb3VudCgpXFxyXFxuICAgICAgfVxcclxcbiAgICAgIC8v5Yig6Zmkd2VidXBsb2Fk5Lit55qE5Zu+54mHXFxyXFxuICAgICAgZnVuY3Rpb24gcmVtb3ZlRmlsZShmaWxlKSB7XFxyXFxuICAgICAgICB2YXIgJGxpID0gJChcXFwiI1xcXCIgKyBmaWxlLmlkKTtcXHJcXG4gICAgICAgIGRlbGV0ZSBwZXJjZW50YWdlc1tmaWxlLmlkXTtcXHJcXG4gICAgICAgIHVwZGF0ZVRvdGFsUHJvZ3Jlc3MoKTtcXHJcXG4gICAgICAgICRsaS5vZmYoKS5maW5kKFxcXCIuZmlsZS1wYW5lbFxcXCIpLm9mZigpLmVuZCgpLnJlbW92ZSgpO1xcclxcbiAgICAgICAgX3RoaXMudXBkYXRhSW1nQ291bnQoKVxcclxcbiAgICAgIH1cXHJcXG5cXHJcXG4gICAgICAvL+abtOaWsHdlYnVwbG9hZGVy5Lit5Zu+54mH5LiK5Lyg55qE6L+b5bqmXFxyXFxuICAgICAgZnVuY3Rpb24gdXBkYXRlVG90YWxQcm9ncmVzcygpIHtcXHJcXG4gICAgICAgIHZhciBsb2FkZWQgPSAwLFxcclxcbiAgICAgICAgICB0b3RhbCA9IDAsXFxyXFxuICAgICAgICAgIHNwYW5zID0gJHByb2dyZXNzLmNoaWxkcmVuKCksXFxyXFxuICAgICAgICAgIHBlcmNlbnQ7XFxyXFxuXFxyXFxuICAgICAgICAkLmVhY2gocGVyY2VudGFnZXMsIGZ1bmN0aW9uKGssIHYpIHtcXHJcXG4gICAgICAgICAgdG90YWwgKz0gdlswXTtcXHJcXG4gICAgICAgICAgbG9hZGVkICs9IHZbMF0gKiB2WzFdO1xcclxcbiAgICAgICAgfSk7XFxyXFxuXFxyXFxuICAgICAgICBwZXJjZW50ID0gdG90YWwgPyBsb2FkZWQgLyB0b3RhbCA6IDA7XFxyXFxuXFxyXFxuICAgICAgICBzcGFucy5lcSgwKS50ZXh0KE1hdGgucm91bmQocGVyY2VudCAqIDEwMCkgKyBcXFwiJVxcXCIpO1xcclxcbiAgICAgICAgc3BhbnMuZXEoMSkuY3NzKFxcXCJ3aWR0aFxcXCIsIE1hdGgucm91bmQocGVyY2VudCAqIDEwMCkgKyBcXFwiJVxcXCIpO1xcclxcbiAgICAgICAgdXBkYXRlU3RhdHVzKCk7XFxyXFxuICAgICAgfVxcclxcblxcclxcbiAgICAgIC8v5pu05pawd2VidXBsb2FkZXLkuK3nmoTnirbmgIFcXHJcXG4gICAgICBmdW5jdGlvbiB1cGRhdGVTdGF0dXMoKSB7XFxyXFxuICAgICAgICB2YXIgdGV4dCA9IFxcXCJcXFwiLFxcclxcbiAgICAgICAgICBzdGF0cztcXHJcXG4gICAgICAgIGlmIChzdGF0ZSA9PSBcXFwicmVhZHlcXFwiKSB7XFxyXFxuICAgICAgICAgIHRleHQgPVxcclxcbiAgICAgICAgICAgIFxcXCLlhbFcXFwiICtcXHJcXG4gICAgICAgICAgICBXZWJVcGxvYWRlci5mb3JtYXRTaXplKGZpbGVTaXplKSArXFxyXFxuICAgICAgICAgICAgXFxcIi5cXFwiO1xcclxcbiAgICAgICAgfSBlbHNlIGlmIChzdGF0ZSA9PSBcXFwiY29uZmlybVxcXCIpIHtcXHJcXG4gICAgICAgICAgc3RhdHMgPSB1cGxvYWRlci5nZXRTdGF0cygpO1xcclxcbiAgICAgICAgICBpZiAoc3RhdHMudXBsb2FkRmFpbE51bSkge1xcclxcbiAgICAgICAgICAgIHRleHQgPVxcclxcbiAgICAgICAgICAgICAgXFxcIuS4iuS8oOaIkOWKn1xcXCIgK1xcclxcbiAgICAgICAgICAgICAgc3RhdHMuc3VjY2Vzc051bSArXFxyXFxuICAgICAgICAgICAgICBcXFwi5byg5b2x5YOP77yM5LiK5Lyg5aSx6LSlOlxcXCIgK1xcclxcbiAgICAgICAgICAgICAgc3RhdHMudXBsb2FkRmFpbE51bSArXFxyXFxuICAgICAgICAgICAgICAvLyflvKDnhafniYfkuIrkvKDlpLHotKUsPGEgY2xhc3M9XFxcInJldHJ5XFxcIiBocmVmPVxcXCIjXFxcIj7ph43mlrDkuIrkvKA8L2E+5aSx6LSl5Zu+54mH5oiWPGEgY2xhc3M9XFxcImlnbm9yZVxcXCIgaHJlZj1cXFwiI1xcXCI+5b+955WlPC9hPic7XFxyXFxuICAgICAgICAgICAgICAn5byg5b2x5YOP77yMPGEgY2xhc3M9XFxcInJldHJ5XFxcIiBocmVmPVxcXCIjXFxcIj7ph43mlrDkuIrkvKA8L2E+5aSx6LSl5b2x5YOPJztcXHJcXG4gICAgICAgICAgfVxcclxcbiAgICAgICAgfSBlbHNlIHtcXHJcXG4gICAgICAgICAgc3RhdHMgPSB1cGxvYWRlci5nZXRTdGF0cygpO1xcclxcbiAgICAgICAgICB0ZXh0ID1cXHJcXG4gICAgICAgICAgICBcXFwi5YWxXFxcIiArXFxyXFxuICAgICAgICAgICAgZmlsZUNvdW50ICtcXHJcXG4gICAgICAgICAgICBcXFwi5bygKFxcXCIgK1xcclxcbiAgICAgICAgICAgIFdlYlVwbG9hZGVyLmZvcm1hdFNpemUoZmlsZVNpemUpICtcXHJcXG4gICAgICAgICAgICBcXFwiKe+8jOW3suS4iuS8oFxcXCIgK1xcclxcbiAgICAgICAgICAgIHN0YXRzLnN1Y2Nlc3NOdW0gK1xcclxcbiAgICAgICAgICAgIFxcXCLlvKBcXFwiO1xcclxcbiAgICAgICAgICBpZiAoc3RhdHMudXBsb2FkRmFpbE51bSkge1xcclxcbiAgICAgICAgICAgIHRleHQgKz0gXFxcIizlpLHotKVcXFwiICsgc3RhdHMudXBsb2FkRmFpbE51bSArIFxcXCLlvKBcXFwiO1xcclxcbiAgICAgICAgICB9XFxyXFxuICAgICAgICB9XFxyXFxuICAgICAgICAkaW5mby5odG1sKHRleHQpO1xcclxcbiAgICAgIH1cXHJcXG5cXHJcXG4gICAgICAvL+iuvue9rndlYnVwbG9hZGVy55qE54q25oCBXFxyXFxuICAgICAgZnVuY3Rpb24gc2V0U3RhdGUodmFsKSB7XFxyXFxuICAgICAgICB2YXIgZmlsZSwgc3RhdHM7XFxyXFxuICAgICAgICBpZiAodmFsID09IHN0YXRlKSB7XFxyXFxuICAgICAgICAgIHJldHVybjtcXHJcXG4gICAgICAgIH1cXHJcXG4gICAgICAgICR1cGxvYWQucmVtb3ZlQ2xhc3MoXFxcInN0YXRlLVxcXCIgKyBzdGF0ZSk7XFxyXFxuICAgICAgICAkdXBsb2FkLmFkZENsYXNzKFxcXCJzdGF0ZS1cXFwiICsgdmFsKTtcXHJcXG4gICAgICAgIHN0YXRlID0gdmFsO1xcclxcblxcclxcbiAgICAgICAgc3dpdGNoIChzdGF0ZSkge1xcclxcbiAgICAgICAgICBjYXNlIFxcXCJwZWRkaW5nXFxcIjpcXHJcXG4gICAgICAgICAgICAkcGxhY2VIb2xkZXIucmVtb3ZlQ2xhc3MoXFxcImVsZW1lbnQtaW52aXNpYmxlXFxcIik7XFxyXFxuICAgICAgICAgICAgJHF1ZXVlLnBhcmVudCgpLnJlbW92ZUNsYXNzKFxcXCJmaWxsZWRcXFwiKTtcXHJcXG4gICAgICAgICAgICAkcXVldWUuaGlkZSgpO1xcclxcbiAgICAgICAgICAgICRzdGF0dXNCYXIuYWRkQ2xhc3MoXFxcImVsZW1lbnQtaW52aXNpYmxlXFxcIik7XFxyXFxuICAgICAgICAgICAgdXBsb2FkZXIucmVmcmVzaCgpO1xcclxcbiAgICAgICAgICAgIGJyZWFrO1xcclxcbiAgICAgICAgICBjYXNlIFxcXCJyZWFkeVxcXCI6XFxyXFxuICAgICAgICAgICAgJHBsYWNlSG9sZGVyLmFkZENsYXNzKFxcXCJlbGVtZW50LWludmlzaWJsZVxcXCIpO1xcclxcbiAgICAgICAgICAgICQoXFxcIiNmaWxlUGlja2VyMlxcXCIpLnJlbW92ZUNsYXNzKFxcXCJlbGVtZW50LWludmlzaWJsZVxcXCIpO1xcclxcbiAgICAgICAgICAgICRxdWV1ZS5wYXJlbnQoKS5hZGRDbGFzcyhcXFwiZmlsbGVkXFxcIik7XFxyXFxuICAgICAgICAgICAgJHF1ZXVlLnNob3coKTtcXHJcXG4gICAgICAgICAgICAkc3RhdHVzQmFyLnJlbW92ZUNsYXNzKFxcXCJlbGVtZW50LWludmlzaWJsZVxcXCIpO1xcclxcbiAgICAgICAgICAgIHVwbG9hZGVyLnJlZnJlc2goKTtcXHJcXG4gICAgICAgICAgICBicmVhaztcXHJcXG4gICAgICAgICAgY2FzZSBcXFwidXBsb2FkaW5nXFxcIjpcXHJcXG4gICAgICAgICAgICAkKFxcXCJmaWxlUGlja2VyMlxcXCIpLmFkZENsYXNzKFxcXCJlbGVtZW50LWludmlzaWJsZVxcXCIpO1xcclxcbiAgICAgICAgICAgICRwcm9ncmVzcy5zaG93KCk7XFxyXFxuICAgICAgICAgICAgJHVwbG9hZC50ZXh0KFxcXCLmmoLlgZzkuIrkvKBcXFwiKTtcXHJcXG4gICAgICAgICAgICBicmVhaztcXHJcXG4gICAgICAgICAgY2FzZSBcXFwicGF1c2VkXFxcIjpcXHJcXG4gICAgICAgICAgICAkcHJvZ3Jlc3Muc2hvdygpO1xcclxcbiAgICAgICAgICAgICR1cGxvYWQudGV4dChcXFwi57un57ut5LiK5LygXFxcIik7XFxyXFxuICAgICAgICAgICAgYnJlYWs7XFxyXFxuICAgICAgICAgIGNhc2UgXFxcImNvbmZpcm1cXFwiOlxcclxcbiAgICAgICAgICAgICRwcm9ncmVzcy5oaWRlKCk7XFxyXFxuICAgICAgICAgICAgLy93cWQgMjAxOTA1MDgg5rOo6YeKXFxyXFxuICAgICAgICAgICAgLy8gJHVwbG9hZC50ZXh0KCflvIDlp4vkuIrkvKAnKS5hZGRDbGFzcygnZGlzYWJsZWQnKTtcXHJcXG4gICAgICAgICAgICAkdXBsb2FkLnRleHQoXFxcIuW8gOWni+S4iuS8oFxcXCIpO1xcclxcbiAgICAgICAgICAgIHN0YXRzID0gdXBsb2FkZXIuZ2V0U3RhdHMoKTtcXHJcXG4gICAgICAgICAgICBpZiAoc3RhdHMuc3VjY2Vzc051bSAmJiAhc3RhdHMudXBsb2FkRmFpbE51bSkge1xcclxcbiAgICAgICAgICAgICAgLy93cWQgMjAxOTA1MDgg5rOo6YeKXFxyXFxuICAgICAgICAgICAgICAvL3NldFN0YXRlKCAnZmluaXNoJyApO1xcclxcbiAgICAgICAgICAgICAgcmV0dXJuO1xcclxcbiAgICAgICAgICAgIH1cXHJcXG4gICAgICAgICAgICBicmVhaztcXHJcXG4gICAgICAgICAgY2FzZSBcXFwiZmluaXNoXFxcIjpcXHJcXG4gICAgICAgICAgICBzdGF0cyA9IHVwbG9hZGVyLmdldFN0YXRzKCk7XFxyXFxuICAgICAgICAgICAgaWYgKHN0YXRzLnN1Y2Nlc3NOdW0pIHtcXHJcXG4gICAgICAgICAgICAgIGFsZXJ0KFxcXCLkuIrkvKDmiJDlip9cXFwiKTtcXHJcXG4gICAgICAgICAgICB9IGVsc2Uge1xcclxcbiAgICAgICAgICAgICAgc3RhdGUgPSBcXFwiZG9uZVxcXCI7XFxyXFxuICAgICAgICAgICAgICBsb2NhdGlvbi5yZWxvYWQoKTtcXHJcXG4gICAgICAgICAgICB9XFxyXFxuICAgICAgICAgICAgYnJlYWs7XFxyXFxuICAgICAgICB9XFxyXFxuICAgICAgICB1cGRhdGVTdGF0dXMoKTtcXHJcXG4gICAgICB9XFxyXFxuXFxyXFxuICAgICAgLy/mlofku7bliqDlhaXliLB3ZWJ1cGxvYWRlcuS4reeahOmYn+WIl1xcclxcbiAgICAgIGZ1bmN0aW9uIGZpbGVRdWV1ZShmaWxlKSB7XFxyXFxuICAgICAgICBmaWxlLnNyYyA9IGZpbGUuc3JjIHx8IFxcXCJjbGllbnRcXFwiO1xcclxcbiAgICAgICAgZmlsZUNvdW50Kys7XFxyXFxuICAgICAgICBmaWxlU2l6ZSArPSBmaWxlLnNpemU7XFxyXFxuXFxyXFxuICAgICAgICBpZiAoZmlsZUNvdW50ID09IDEpIHtcXHJcXG4gICAgICAgICAgJHBsYWNlSG9sZGVyLmFkZENsYXNzKFxcXCJlbGVtZW50LWludmlzaWJsZVxcXCIpO1xcclxcbiAgICAgICAgICAkc3RhdHVzQmFyLnNob3coKTtcXHJcXG4gICAgICAgIH1cXHJcXG5cXHJcXG4gICAgICAgIGFkZEZpbGUoZmlsZSk7XFxyXFxuICAgICAgICBzZXRTdGF0ZShcXFwicmVhZHlcXFwiKTtcXHJcXG4gICAgICAgIHVwZGF0ZVRvdGFsUHJvZ3Jlc3MoKTtcXHJcXG4gICAgICB9XFxyXFxuXFxyXFxuICAgICAgaWYgKCFXZWJVcGxvYWRlci5VcGxvYWRlci5zdXBwb3J0KCkpIHtcXHJcXG4gICAgICAgIGNvbnNvbGUubG9nKFxcXCJXZWJVcGxvYWRlciDkuI3mlK/mjIFcXFwiKTtcXHJcXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcXFwiV2ViVXBsb2FkZXIgZG9lcyBub3Qgc3VwcG9ydFxcXCIpO1xcclxcbiAgICAgIH1cXHJcXG5cXHJcXG4gICAgICB1cGxvYWRlci5hZGRCdXR0b24oe1xcclxcbiAgICAgICAgaWQ6IFxcXCIjZmlsZVBpY2tlcjJcXFwiLFxcclxcbiAgICAgICAgbGFiZWw6IFxcXCLnu6fnu63mt7vliqBcXFwiXFxyXFxuICAgICAgfSk7XFxyXFxuXFxyXFxuICAgICAgdXBsb2FkZXIub24oXFxcInVwbG9hZFByb2dyZXNzXFxcIiwgZnVuY3Rpb24oZmlsZSwgcGVyY2VudGFnZSkge1xcclxcbiAgICAgICAgdmFyICRsaSA9ICQoXFxcIiNcXFwiICsgZmlsZS5pZCksXFxyXFxuICAgICAgICAgICRwZXJjZW50ID0gJGxpLmZpbmQoXFxcIi5wcm9ncmVzcyBzcGFuXFxcIik7XFxyXFxuICAgICAgICAkcGVyY2VudC5jc3Moe1xcXCJ3aWR0aFxcXCI6IHBlcmNlbnRhZ2UgKiAxMDAgKyBcXFwiJVxcXCIsXFxcImRpc3BsYXlcXFwiOlxcXCJub25lXFxcIn0pXFxyXFxuICAgICAgICB1cGRhdGVUb3RhbFByb2dyZXNzKCk7XFxyXFxuICAgICAgfSk7XFxyXFxuXFxyXFxuICAgICAgdXBsb2FkZXIub24oXFxcImZpbGVRdWV1ZWRcXFwiLCBmaWxlUXVldWUpO1xcclxcblxcclxcbiAgICAgIHVwbG9hZGVyLm9uKFxcXCJmaWxlRGVxdWV1ZWRcXFwiLCBmdW5jdGlvbihmaWxlKSB7XFxyXFxuICAgICAgICBmaWxlQ291bnQtLTtcXHJcXG4gICAgICAgIGZpbGVTaXplIC09IGZpbGUuc2l6ZTtcXHJcXG4gICAgICAgIGlmICghZmlsZUNvdW50KSB7XFxyXFxuICAgICAgICAgIHNldFN0YXRlKFxcXCJwZWRkaW5nXFxcIik7XFxyXFxuICAgICAgICB9XFxyXFxuICAgICAgICByZW1vdmVGaWxlKGZpbGUpO1xcclxcbiAgICAgICAgdXBkYXRlVG90YWxQcm9ncmVzcygpO1xcclxcbiAgICAgIH0pO1xcclxcblxcclxcbiAgICAgIHVwbG9hZGVyLm9uKFxcXCJ1cGxvYWRTdWNjZXNzXFxcIiwgZnVuY3Rpb24oZmlsZSwgZGF0YSkge1xcclxcbiAgICAgICAgaWYgKGRhdGEuRl9DT0RFID09PSBcXFwiMFxcXCIpIHtcXHJcXG4gICAgICAgICAgJChcXFwiI1xcXCIgKyBmaWxlLmlkKVxcclxcbiAgICAgICAgICAgIC5maW5kKFxcXCJwLnN0YXRlXFxcIilcXHJcXG4gICAgICAgICAgICAudGV4dChcXFwi5bey5LiK5LygXFxcIik7XFxyXFxuICAgICAgICB9XFxyXFxuICAgICAgfSk7XFxyXFxuXFxyXFxuICAgICAgdXBsb2FkZXIub24oXFxcInVwbG9hZEVycm9yXFxcIiwgZnVuY3Rpb24oZmlsZSwgYikge1xcclxcbiAgICAgICAgY29uc29sZS5sb2coZmlsZS5pZCArIFxcXCLkuIrkvKDlh7rplJlcXFwiKTtcXHJcXG4gICAgICB9KTtcXHJcXG5cXHJcXG4gICAgICB1cGxvYWRlci5vbihcXFwidXBsb2FkQ29tcGxldGVcXFwiLCBmdW5jdGlvbihmaWxlLCBhLCBiKSB7XFxyXFxuICAgICAgICAkKFxcXCIjXFxcIiArIGZpbGUuaWQpXFxyXFxuICAgICAgICAgIC5maW5kKFxcXCJwLnN0YXRlXFxcIilcXHJcXG4gICAgICAgICAgLmZhZGVPdXQoKTtcXHJcXG4gICAgICB9KTtcXHJcXG5cXHJcXG4gICAgICB1cGxvYWRlci5vbihcXFwiYWxsXFxcIiwgZnVuY3Rpb24odHlwZSkge1xcclxcbiAgICAgICAgaWYgKHR5cGUgPT0gXFxcInVwbG9hZEZpbmlzaGVkXFxcIikge1xcclxcbiAgICAgICAgICBzZXRTdGF0ZShcXFwiY29uZmlybVxcXCIpO1xcclxcbiAgICAgICAgfSBlbHNlIGlmICh0eXBlID09IFxcXCJzdGFydFVwbG9hZFxcXCIpIHtcXHJcXG4gICAgICAgICAgc2V0U3RhdGUoXFxcInVwbG9hZGluZ1xcXCIpO1xcclxcbiAgICAgICAgfSBlbHNlIGlmICh0eXBlID09IFxcXCJzdG9wVXBsb2FkXFxcIikge1xcclxcbiAgICAgICAgICBzZXRTdGF0ZShcXFwicGF1c2VkXFxcIik7XFxyXFxuICAgICAgICB9XFxyXFxuICAgICAgfSk7XFxyXFxuXFxyXFxuICAgICAgdXBsb2FkZXIub24oXFxcInVwbG9hZEJlZm9yZVNlbmRcXFwiLCBmdW5jdGlvbihibG9jaywgZGF0YSkge1xcclxcbiAgICAgICAgZGF0YS5zb3J0ID0gJChcXFwiI1xcXCIgKyBkYXRhLmlkKS5hdHRyKFxcXCJkYXRhLXNvcnRcXFwiKTtcXHJcXG4gICAgICAgIHZhciBmaWxlID0gJChcXFwiI1xcXCIgKyBkYXRhLmlkKS5kYXRhKFxcXCJmaWxlaW5mb1xcXCIpXFxyXFxuICAgICAgICB2YXIgb2JqID0ge1xcclxcbiAgICAgICAgICBcXFwiRl9BUFBfSURcXFwiOiBcXFwiVEFJS0FOR1xcXCIsLy/mnaXmupDns7vnu5/moIfor4ZcXHJcXG4gICAgICAgICAgXFxcIkZfQUNDRVNTX1RPS0VOXFxcIjogXFxcIlxcXCIsXFxyXFxuICAgICAgICAgIFxcXCJGX1VTRVJfSURcXFwiOiBcXFwidGlhbm1lbmdcXFwiLC8v5pON5L2c5Lq6XFxyXFxuICAgICAgICAgIFxcXCJGX1VTRVJfTkFNRVxcXCI6XFxcIlxcXCIsLy/mk43kvZzkurrlkI3np7BcXHJcXG4gICAgICAgICAgXFxcIkZfTkVFRF9BUFBMWVxcXCI6IFxcXCIxXFxcIiwgIC8v5piv5ZCm6ZyA6KaB55Sz6K+3IOm7mOiupDFcXHJcXG4gICAgICAgICAgXFxcIkZfQklMTF9JRFxcXCI6XFxcIkxLUkwyMDE4MTIxMTAwMTRcXFwiLC8v5Y2V5o2u57yW5Y+3XFxyXFxuICAgICAgICAgIFxcXCJGX0JJTExfVFlQRVxcXCI6XFxcIlRURlNfSlNfTEtSTERcXFwiLC8v5Y2V5o2u57G75Z6LXFxyXFxuICAgICAgICAgIFxcXCJGX0JJWl9UWVBFXFxcIjpcXFwiVFRGU19KU19MS1JMRFxcXCIsLy/kuJrliqHnsbvlnotcXHJcXG4gICAgICAgICAgXFxcIkZfQU1UXFxcIjpcXFwiXFxcIiwvL+mHkeminVxcclxcbiAgICAgICAgICBcXFwiRl9DVVJSXFxcIjpcXFwiXFxcIiwvL+W4geenjVxcclxcbiAgICAgICAgICBcXFwiRl9TQ19DT0RFXFxcIjpcXFwiXFxcIiwvL+WFseS6q+S4reW/g1xcclxcbiAgICAgICAgICBcXFwiRl9QT09MX0lEXFxcIjpcXFwiXFxcIiwvL+S4muWKoeaxoFxcclxcbiAgICAgICAgICBcXFwiRl9BVFRfVFlQRVxcXCI6XFxcIjBcXFwiLC8v5LiK5Lyg5pa55byPIDDmma7pgJrkuIrkvKAgMSDpm4bkuK3miavmj49cXHJcXG4gICAgICAgICAgXFxcIkZfQVBQTFlfRklMRVNcXFwiOiBbXFxyXFxuICAgICAgICAgICAge1xcclxcbiAgICAgICAgICAgICAgXFxcIkZfVFlQRVxcXCI6IFxcXCIwXFxcIixcXHJcXG4gICAgICAgICAgICAgIFxcXCJGX09CSkVDVFxcXCI6IFxcXCIxMjM0NTY3ODkwXFxcIixcXHJcXG4gICAgICAgICAgICAgIFxcXCJGX0lNR19DT0RFXFxcIjpmaWxlLkZfSU1HX0NPREUsLy/lvbHlg4/lhbPplK7noIFcXHJcXG4gICAgICAgICAgICAgIFxcXCJGX0lNR19UWVBFXFxcIjpmaWxlLkZfSU1HX1RZUEUsLy/lvbHlg4/nsbvliKtcXHJcXG4gICAgICAgICAgICAgIFxcXCJGX0ZJTEVTXFxcIjogW1xcclxcbiAgICAgICAgICAgICAgICB7XFxyXFxuICAgICAgICAgICAgICAgICAgXFxcIkZfRklMRV9OQU1FXFxcIjogZGF0YS5uYW1lLFxcclxcbiAgICAgICAgICAgICAgICAgIFxcXCJGX0ZJTEVfTkFNRTFcXFwiOiBkYXRhLm5hbWUsXFxyXFxuICAgICAgICAgICAgICAgICAgXFxcIkZfRklMRV9QQVRIXFxcIjogXFxcIlxcXCIsXFxyXFxuICAgICAgICAgICAgICAgICAgXFxcIkZfRklMRV9TSVpFXFxcIjogZGF0YS5zaXplLFxcclxcbiAgICAgICAgICAgICAgICAgIFxcXCJGX0ZJTEVfTUQ1XFxcIjogXFxcIlxcXCIsXFxyXFxuICAgICAgICAgICAgICAgICAgXFxcIkZfVVBMT0FEX1pJUFxcXCI6IFxcXCJcXFwiLFxcclxcbiAgICAgICAgICAgICAgICAgIFxcXCJGX0VOQ1JZUFRcXFwiOiBcXFwiXFxcIixcXHJcXG4gICAgICAgICAgICAgICAgICBcXFwiRl9FTkNSWVBUX0tFWVxcXCI6IFxcXCJcXFwiLFxcclxcbiAgICAgICAgICAgICAgICAgIFxcXCJGX0JJWl9JTkZPXFxcIjpcXFwiXFxcIiwvL+aRmOimgVxcclxcbiAgICAgICAgICAgICAgICAgIFxcXCJGX09QRVJfVFlQRVxcXCI6XFxcIlxcXCIsLy/mk43kvZznsbvlnosg6buY6K6k56m66KGo56S65Yi25Y2V5Lq65LiK5LygIDHooajnpLrlrqHmibnkurrliqDmibnms6jmiJbnvJbovpHlm77niYdcXHJcXG4gICAgICAgICAgICAgICAgICBcXFwiRl9PUklHX0lNR19LRVlcXFwiOiBcXFwiXFxcIiwvL+WuoeaJueS6uue8lui+keWPiuaJueazqOWbvueJh+aXtuacieeUqFxcclxcbiAgICAgICAgICAgICAgICAgIFxcXCJGX05PREVfSURcXFwiOlxcXCJcXFwiLC8v562+5om56IqC54K5XFxyXFxuICAgICAgICAgICAgICAgICAgXFxcIkZfTk9ERV9OQU1FXFxcIjpcXFwiXFxcIiwvL+etvuaJueiKgueCueWQjeensFxcclxcbiAgICAgICAgICAgICAgICAgIFxcXCJGX1NJR05fVVNSX05BTUVcXFwiOlxcXCJcXFwiLC8v562+5om55Lq65ZCN56ewXFxyXFxuICAgICAgICAgICAgICAgICAgXFxcIkZfU0lHTl9OT1RFXFxcIjpcXFwiXFxcIiwvL+etvuaJueWGheWuuVxcclxcbiAgICAgICAgICAgICAgICAgIFxcXCJGX09QX0FDVElPTlxcXCI6XFxcIlxcXCIsLy/mk43kvZzliqjkvZxcXHJcXG4gICAgICAgICAgICAgICAgICBcXFwiRl9ST1RBVEVcXFwiOmZpbGUucm90YXRpb24sLy/ml4vovazluqbmlbBcXHJcXG4gICAgICAgICAgICAgICAgICBcXFwiRl9GSUxFX09SREVSXFxcIjokKFxcXCIjXFxcIiArIGRhdGEuaWQpLmF0dHIoXFxcImRhdGEtc29ydFxcXCIpLC8v5pi+56S65bqP5Y+3XFxyXFxuICAgICAgICAgICAgICAgICAgXFxcIkZfSVNISURFXFxcIjpcXFwiMFxcXCIsLy/mmK/lkKbpmpDol4/vvJox5piv77yMMOWQplxcclxcbiAgICAgICAgICAgICAgICAgIFxcXCJGX1JJU0tfVFlQRVxcXCI6XFxcIlxcXCIvL+mjjumZqeexu+WIq1xcclxcbiAgICAgICAgICAgICAgICB9XFxyXFxuICAgICAgICAgICAgICBdXFxyXFxuICAgICAgICAgICAgfVxcclxcbiAgICAgICAgICBdXFxyXFxuICAgICAgICB9XFxyXFxuICAgICAgICBkYXRhLmpzb25kYXRhID0gSlNPTi5zdHJpbmdpZnkob2JqKTtcXHJcXG4gICAgICAgIHZhciAkbGkgPSAkKFxcXCIjXFxcIiArIGRhdGEuaWQpLFxcclxcbiAgICAgICAgICAkcGVyY2VudCA9ICRsaS5maW5kKFxcXCIucHJvZ3Jlc3Mgc3BhblxcXCIpO1xcclxcbiAgICAgICAgJHBlcmNlbnQuY3NzKHtcXFwid2lkdGhcXFwiOiBcXFwiMTAwJVxcXCIsXFxcImRpc3BsYXlcXFwiOlxcXCJibG9ja1xcXCJ9KVxcclxcbiAgICAgIH0pO1xcclxcblxcclxcbiAgICAgICR1cGxvYWQub24oXFxcImNsaWNrXFxcIiwgZnVuY3Rpb24oKSB7XFxyXFxuICAgICAgICB1cGxvYWRlci5zb3J0KGZ1bmN0aW9uKG9iajEsIG9iajIpIHtcXHJcXG4gICAgICAgICAgcmV0dXJuICQoXFxcIiNcXFwiICsgb2JqMS5pZCkuYXR0cihcXFwiZGF0YS1zb3J0XFxcIikgPiAkKFxcXCIjXFxcIiArIG9iajIuaWQpID8gLTEgOiAxO1xcclxcbiAgICAgICAgfSk7XFxyXFxuICAgICAgICBpZiAoJCh0aGlzKS5oYXNDbGFzcyhcXFwiZGlzYWJsZWRcXFwiKSkge1xcclxcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XFxyXFxuICAgICAgICB9XFxyXFxuICAgICAgICBpZiAoc3RhdGUgPT0gXFxcInJlYWR5XFxcIikge1xcclxcbiAgICAgICAgICBpZiAodXBsb2FkZXIuZ2V0RmlsZXMoKS5sZW5ndGggPCAxKSB1cGRhdGVTZXJ2ZXJGaWxlcygpO1xcclxcbiAgICAgICAgICBlbHNlIHVwbG9hZGVyLnVwbG9hZCgpO1xcclxcbiAgICAgICAgfSBlbHNlIGlmIChzdGF0ZSA9PSBcXFwicGF1c2VkXFxcIikge1xcclxcbiAgICAgICAgICB1cGxvYWRlci51cGxvYWQoKTtcXHJcXG4gICAgICAgIH0gZWxzZSBpZiAoc3RhdGUgPT0gXFxcInVwbG9hZGluZ1xcXCIpIHtcXHJcXG4gICAgICAgICAgdXBsb2FkZXIuc3RvcCgpO1xcclxcbiAgICAgICAgfVxcclxcbiAgICAgIH0pO1xcclxcblxcclxcbiAgICAgICRpbmZvLm9uKFxcXCJjbGlja1xcXCIsIFxcXCIucmV0cnlcXFwiLCBmdW5jdGlvbigpIHtcXHJcXG4gICAgICAgIHVwbG9hZGVyLnJldHJ5KCk7XFxyXFxuICAgICAgfSk7XFxyXFxuXFxyXFxuICAgICAgJGluZm8ub24oXFxcImNsaWNrXFxcIiwgXFxcIi5pZ25vcmVcXFwiLCBmdW5jdGlvbigpIHtcXHJcXG4gICAgICAgIGFsZXJ0KFxcXCJ0b2RvXFxcIik7XFxyXFxuICAgICAgfSk7XFxyXFxuXFxyXFxuICAgICAgJHVwbG9hZC5hZGRDbGFzcyhcXFwic3RhdGUtXFxcIiArIHN0YXRlKTtcXHJcXG4gICAgICB1cGRhdGVUb3RhbFByb2dyZXNzKCk7XFxyXFxuXFxyXFxuICAgICAgaW5pdFNlcnZlckZpbGUoKTtcXHJcXG4gICAgfSxcXHJcXG4gICAgLyogZXNsaW50LWVuYWJsZSAqL1xcclxcbiAgICBzaG93SW1nbGlzdDogZnVuY3Rpb24gKHR5cGUpIHtcXHJcXG4gICAgICAkKFxcXCIuZmlsZWxpc3Q+bGlbZGF0YS10eXBlIT0nXFxcIiArIHR5cGUgKyBcXFwiJ11cXFwiKS5oaWRlKClcXHJcXG4gICAgICAkKFxcXCIuZmlsZWxpc3Q+bGlbZGF0YS10eXBlPSdcXFwiICsgdHlwZSArIFxcXCInXVxcXCIpLnNob3coKVxcclxcbiAgICAgICQoJy52Y2hyaW1hZ2UgLm1pZGRsZScpLmNzcygnb3ZlcmZsb3cteScsICdoaWRkZW4nKVxcclxcbiAgICAgICQoJy52Y2hyaW1hZ2UgLmNhdGVnb3J5LXZpZXcnKS5jc3MoJ292ZXJmbG93LXknLCAnaGlkZGVuJylcXHJcXG4gICAgICAvLyDph43mlrDorqHnrpflm77niYfnmoTkvY3nva5cXHJcXG4gICAgICB2YXIgJHF1ZXVlID0gJCgnLmZpbGVsaXN0JylcXHJcXG4gICAgICAvLyDkvJjljJZyZXRpbmEsIOWcqHJldGluYeS4i+i/meS4quWAvOaYrzJcXHJcXG4gICAgICB2YXIgcmF0aW8gPSB3aW5kb3cuZGV2aWNlUGl4ZWxSYXRpbyB8fCAxXFxyXFxuICAgICAgLy8g57yp55Wl5Zu+5aSn5bCPXFxyXFxuICAgICAgdmFyIHRodW1ibmFpbFdpZHRoID0gdGhpcy51cGxvYWRwcm9wcy5jb25maWcudGh1bWJXaWR0aCB8fCAxMTBcXHJcXG4gICAgICB0aHVtYm5haWxXaWR0aCAqPSByYXRpb1xcclxcbiAgICAgIHZhciB0aHVtYm5haWxIZWlnaHQgPSB0aGlzLnVwbG9hZHByb3BzLmNvbmZpZy50aHVtYkhlaWdodCB8fCAxMTBcXHJcXG4gICAgICB0aHVtYm5haWxIZWlnaHQgPSB0aHVtYm5haWxIZWlnaHQgKyAyNVxcclxcbiAgICAgIHRodW1ibmFpbEhlaWdodCAqPSByYXRpb1xcclxcbiAgICAgIHZhciB3cmFwSGVpZ2h0ID0gdGh1bWJuYWlsSGVpZ2h0ICsgMTBcXHJcXG4gICAgICB2YXIgd3JhcFdpZHRoID0gJHF1ZXVlLndpZHRoKClcXHJcXG4gICAgICB2YXIgaW1nTnVtID0gcGFyc2VJbnQod3JhcFdpZHRoIC8gKHRodW1ibmFpbFdpZHRoICsgMTApKSAvLyDmr4/ooYzmnInlh6DlvKDlm77niYdcXHJcXG4gICAgICAkKFxcXCIuZmlsZWxpc3Q+bGlbZGF0YS10eXBlPSdcXFwiICsgdHlwZSArIFxcXCInXVxcXCIpLmVhY2goZnVuY3Rpb24gKGluZGV4LCB2KSB7XFxyXFxuICAgICAgICB2YXIgaW1nVG9wID0gMFxcclxcbiAgICAgICAgdmFyIGltZ0xlZnQgPSBpbmRleCAqICh0aHVtYm5haWxXaWR0aCArIDEwKVxcclxcbiAgICAgICAgaWYgKGluZGV4ICsgMSA+IGltZ051bSkge1xcclxcbiAgICAgICAgICBpbWdUb3AgPSBwYXJzZUludChpbmRleCAvIGltZ051bSkgKiAodGh1bWJuYWlsSGVpZ2h0ICsgMTApXFxyXFxuICAgICAgICAgIGltZ0xlZnQgPSAoaW5kZXggJSBpbWdOdW0pICogKHRodW1ibmFpbFdpZHRoICsgMTApXFxyXFxuICAgICAgICAgIHdyYXBIZWlnaHQgPSBpbWdUb3AgKyB0aHVtYm5haWxIZWlnaHQgKyAxMFxcclxcbiAgICAgICAgfVxcclxcbiAgICAgICAgJCh0aGlzKS5jc3MoeyBsZWZ0OiBpbWdMZWZ0ICsgJ3B4JywgdG9wOiBpbWdUb3AgKyAncHgnIH0pXFxyXFxuICAgICAgfSlcXHJcXG4gICAgICAkcXVldWUuY3NzKCdoZWlnaHQnLCB3cmFwSGVpZ2h0ICsgJ3B4JylcXHJcXG4gICAgICAkKCcudmNocmltYWdlIC5taWRkbGUnKS5jc3MoJ292ZXJmbG93LXknLCAnYXV0bycpXFxyXFxuICAgICAgJCgnLnZjaHJpbWFnZSAuY2F0ZWdvcnktdmlldycpLmNzcygnb3ZlcmZsb3cteScsICdhdXRvJylcXHJcXG4gICAgfSxcXHJcXG4gICAgLy8gdGFi6aG1562+54K55Ye7XFxyXFxuICAgIHRhYkNoYW5nZTogZnVuY3Rpb24gKHJlZikge1xcclxcbiAgICAgICQodGhpcy4kcmVmc1tyZWZdKS5hZGRDbGFzcygndGFiLWFjdGl2ZScpLnNpYmxpbmdzKCkucmVtb3ZlQ2xhc3MoJ3RhYi1hY3RpdmUnKVxcclxcbiAgICAgIGlmIChyZWYgPT09ICdhbGxWaWV3Jykge1xcclxcbiAgICAgICAgJCgnLnF1ZXVlQWxsTGlzdCcpLnNob3coKS5lbXB0eSgpXFxyXFxuICAgICAgICAkKCcuaW1nV3JhcCBpbWcnKS5jbG9uZSgpLmFwcGVuZFRvKCQoJy5xdWV1ZUFsbExpc3QnKSlcXHJcXG4gICAgICAgICQoJy5xdWV1ZUxpc3QnKS5oaWRlKClcXHJcXG4gICAgICAgICQoJy5xdWV1ZUFsbExpc3QgaW1nJykuY3NzKCdtYXJnaW4nLCAnMTBweCcpXFxyXFxuICAgICAgICB0aGlzLkFsbEltZ2VDb3VudCA9ICQoJy5xdWV1ZUFsbExpc3QgaW1nJykubGVuZ3RoXFxyXFxuICAgICAgfSBlbHNlIHtcXHJcXG4gICAgICAgICQoJy5xdWV1ZUxpc3QnKS5zaG93KClcXHJcXG4gICAgICAgICQoJy5xdWV1ZUFsbExpc3QnKS5oaWRlKClcXHJcXG4gICAgICB9XFxyXFxuICAgIH0sXFxyXFxuICAgIHVwZGF0YUltZ0NvdW50OiBmdW5jdGlvbiAoKSB7XFxyXFxuICAgICAgdmFyICRxdWV1ZSA9ICQoJy5maWxlbGlzdCcpXFxyXFxuICAgICAgdmFyIGNvdW50ID0gJHF1ZXVlLmZpbmQoXFxcImxpW2RhdGEtdHlwZT0nXFxcIiArIHRoaXMuY3VycmVudE5vZGUgKyBcXFwiJ11cXFwiKS5sZW5ndGhcXHJcXG4gICAgICB0aGlzLkNOb2RlSW1nZUNvdW50ID0gY291bnRcXHJcXG4gICAgICB0aGlzLiRlbWl0KCdDTm9kZUltZ2VDb3VudCcsIGNvdW50KVxcclxcbiAgICAgIHZhciBhbGxDb3VudCA9ICRxdWV1ZS5maW5kKCdsaScpLmxlbmd0aFxcclxcbiAgICAgIHRoaXMuQWxsSW1nZUNvdW50ID0gYWxsQ291bnRcXHJcXG4gICAgfVxcclxcbiAgfVxcclxcbn1cXHJcXG48L3NjcmlwdD5cXHJcXG48c3R5bGUgc2NvcGVkPlxcclxcbiAgLnRhYi12aWV3IGRpdntcXHJcXG4gICAgcGFkZGluZzogMCAyMHB4O1xcclxcbiAgICBjdXJzb3I6IHBvaW50ZXI7XFxyXFxuICB9XFxyXFxuICAudGFiLXZpZXcgLnRhYi1hY3RpdmV7XFxyXFxuICAgIGJvcmRlci1ib3R0b206IDJweCBzb2xpZCAjMTA5NGZhO1xcclxcbiAgfVxcclxcbjwvc3R5bGU+XFxyXFxuXCJdLFwic291cmNlUm9vdFwiOlwiXCJ9XSk7XG5cbi8vIGV4cG9ydHNcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXI/c291cmNlTWFwIS4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL3N0eWxlLWNvbXBpbGVyP3tcInZ1ZVwiOnRydWUsXCJpZFwiOlwiZGF0YS12LTMxNTFhOWZlXCIsXCJzY29wZWRcIjp0cnVlLFwiaGFzSW5saW5lQ29uZmlnXCI6ZmFsc2V9IS4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL3NlbGVjdG9yLmpzP3R5cGU9c3R5bGVzJmluZGV4PTAhLi9zcmMvY29tcG9uZW50cy93ZWJ1cGxvYWRlci91cGxvYWQudnVlXG4vLyBtb2R1bGUgaWQgPSA0OVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///49\n");

/***/ }),
/* 50 */
/***/ (function(module, exports) {

eval("/**\n * Translates the list format produced by css-loader into something\n * easier to manipulate.\n */\nmodule.exports = function listToStyles (parentId, list) {\n  var styles = []\n  var newStyles = {}\n  for (var i = 0; i < list.length; i++) {\n    var item = list[i]\n    var id = item[0]\n    var css = item[1]\n    var media = item[2]\n    var sourceMap = item[3]\n    var part = {\n      id: parentId + ':' + i,\n      css: css,\n      media: media,\n      sourceMap: sourceMap\n    }\n    if (!newStyles[id]) {\n      styles.push(newStyles[id] = { id: id, parts: [part] })\n    } else {\n      newStyles[id].parts.push(part)\n    }\n  }\n  return styles\n}\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvdnVlLXN0eWxlLWxvYWRlci9saWIvbGlzdFRvU3R5bGVzLmpzP2I1MzUiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsaUJBQWlCO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQyx3QkFBd0I7QUFDM0QsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJmaWxlIjoiNTAuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIFRyYW5zbGF0ZXMgdGhlIGxpc3QgZm9ybWF0IHByb2R1Y2VkIGJ5IGNzcy1sb2FkZXIgaW50byBzb21ldGhpbmdcbiAqIGVhc2llciB0byBtYW5pcHVsYXRlLlxuICovXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGxpc3RUb1N0eWxlcyAocGFyZW50SWQsIGxpc3QpIHtcbiAgdmFyIHN0eWxlcyA9IFtdXG4gIHZhciBuZXdTdHlsZXMgPSB7fVxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxpc3QubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgaXRlbSA9IGxpc3RbaV1cbiAgICB2YXIgaWQgPSBpdGVtWzBdXG4gICAgdmFyIGNzcyA9IGl0ZW1bMV1cbiAgICB2YXIgbWVkaWEgPSBpdGVtWzJdXG4gICAgdmFyIHNvdXJjZU1hcCA9IGl0ZW1bM11cbiAgICB2YXIgcGFydCA9IHtcbiAgICAgIGlkOiBwYXJlbnRJZCArICc6JyArIGksXG4gICAgICBjc3M6IGNzcyxcbiAgICAgIG1lZGlhOiBtZWRpYSxcbiAgICAgIHNvdXJjZU1hcDogc291cmNlTWFwXG4gICAgfVxuICAgIGlmICghbmV3U3R5bGVzW2lkXSkge1xuICAgICAgc3R5bGVzLnB1c2gobmV3U3R5bGVzW2lkXSA9IHsgaWQ6IGlkLCBwYXJ0czogW3BhcnRdIH0pXG4gICAgfSBlbHNlIHtcbiAgICAgIG5ld1N0eWxlc1tpZF0ucGFydHMucHVzaChwYXJ0KVxuICAgIH1cbiAgfVxuICByZXR1cm4gc3R5bGVzXG59XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy92dWUtc3R5bGUtbG9hZGVyL2xpYi9saXN0VG9TdHlsZXMuanNcbi8vIG1vZHVsZSBpZCA9IDUwXG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///50\n");

/***/ }),
/* 51 */
/***/ (function(module, exports) {

eval("/* globals __VUE_SSR_CONTEXT__ */\n\n// IMPORTANT: Do NOT use ES2015 features in this file.\n// This module is a runtime utility for cleaner component module output and will\n// be included in the final webpack user bundle.\n\nmodule.exports = function normalizeComponent (\n  rawScriptExports,\n  compiledTemplate,\n  functionalTemplate,\n  injectStyles,\n  scopeId,\n  moduleIdentifier /* server only */\n) {\n  var esModule\n  var scriptExports = rawScriptExports = rawScriptExports || {}\n\n  // ES6 modules interop\n  var type = typeof rawScriptExports.default\n  if (type === 'object' || type === 'function') {\n    esModule = rawScriptExports\n    scriptExports = rawScriptExports.default\n  }\n\n  // Vue.extend constructor export interop\n  var options = typeof scriptExports === 'function'\n    ? scriptExports.options\n    : scriptExports\n\n  // render functions\n  if (compiledTemplate) {\n    options.render = compiledTemplate.render\n    options.staticRenderFns = compiledTemplate.staticRenderFns\n    options._compiled = true\n  }\n\n  // functional template\n  if (functionalTemplate) {\n    options.functional = true\n  }\n\n  // scopedId\n  if (scopeId) {\n    options._scopeId = scopeId\n  }\n\n  var hook\n  if (moduleIdentifier) { // server build\n    hook = function (context) {\n      // 2.3 injection\n      context =\n        context || // cached call\n        (this.$vnode && this.$vnode.ssrContext) || // stateful\n        (this.parent && this.parent.$vnode && this.parent.$vnode.ssrContext) // functional\n      // 2.2 with runInNewContext: true\n      if (!context && typeof __VUE_SSR_CONTEXT__ !== 'undefined') {\n        context = __VUE_SSR_CONTEXT__\n      }\n      // inject component styles\n      if (injectStyles) {\n        injectStyles.call(this, context)\n      }\n      // register component module identifier for async chunk inferrence\n      if (context && context._registeredComponents) {\n        context._registeredComponents.add(moduleIdentifier)\n      }\n    }\n    // used by ssr in case component is cached and beforeCreate\n    // never gets called\n    options._ssrRegister = hook\n  } else if (injectStyles) {\n    hook = injectStyles\n  }\n\n  if (hook) {\n    var functional = options.functional\n    var existing = functional\n      ? options.render\n      : options.beforeCreate\n\n    if (!functional) {\n      // inject component registration as beforeCreate hook\n      options.beforeCreate = existing\n        ? [].concat(existing, hook)\n        : [hook]\n    } else {\n      // for template-only hot-reload because in that case the render fn doesn't\n      // go through the normalizer\n      options._injectStyles = hook\n      // register for functioal component in vue file\n      options.render = function renderWithStyleInjection (h, context) {\n        hook.call(context)\n        return existing(h, context)\n      }\n    }\n  }\n\n  return {\n    esModule: esModule,\n    exports: scriptExports,\n    options: options\n  }\n}\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvY29tcG9uZW50LW5vcm1hbGl6ZXIuanM/NTU0ZiJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJmaWxlIjoiNTEuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvKiBnbG9iYWxzIF9fVlVFX1NTUl9DT05URVhUX18gKi9cblxuLy8gSU1QT1JUQU5UOiBEbyBOT1QgdXNlIEVTMjAxNSBmZWF0dXJlcyBpbiB0aGlzIGZpbGUuXG4vLyBUaGlzIG1vZHVsZSBpcyBhIHJ1bnRpbWUgdXRpbGl0eSBmb3IgY2xlYW5lciBjb21wb25lbnQgbW9kdWxlIG91dHB1dCBhbmQgd2lsbFxuLy8gYmUgaW5jbHVkZWQgaW4gdGhlIGZpbmFsIHdlYnBhY2sgdXNlciBidW5kbGUuXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gbm9ybWFsaXplQ29tcG9uZW50IChcbiAgcmF3U2NyaXB0RXhwb3J0cyxcbiAgY29tcGlsZWRUZW1wbGF0ZSxcbiAgZnVuY3Rpb25hbFRlbXBsYXRlLFxuICBpbmplY3RTdHlsZXMsXG4gIHNjb3BlSWQsXG4gIG1vZHVsZUlkZW50aWZpZXIgLyogc2VydmVyIG9ubHkgKi9cbikge1xuICB2YXIgZXNNb2R1bGVcbiAgdmFyIHNjcmlwdEV4cG9ydHMgPSByYXdTY3JpcHRFeHBvcnRzID0gcmF3U2NyaXB0RXhwb3J0cyB8fCB7fVxuXG4gIC8vIEVTNiBtb2R1bGVzIGludGVyb3BcbiAgdmFyIHR5cGUgPSB0eXBlb2YgcmF3U2NyaXB0RXhwb3J0cy5kZWZhdWx0XG4gIGlmICh0eXBlID09PSAnb2JqZWN0JyB8fCB0eXBlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgZXNNb2R1bGUgPSByYXdTY3JpcHRFeHBvcnRzXG4gICAgc2NyaXB0RXhwb3J0cyA9IHJhd1NjcmlwdEV4cG9ydHMuZGVmYXVsdFxuICB9XG5cbiAgLy8gVnVlLmV4dGVuZCBjb25zdHJ1Y3RvciBleHBvcnQgaW50ZXJvcFxuICB2YXIgb3B0aW9ucyA9IHR5cGVvZiBzY3JpcHRFeHBvcnRzID09PSAnZnVuY3Rpb24nXG4gICAgPyBzY3JpcHRFeHBvcnRzLm9wdGlvbnNcbiAgICA6IHNjcmlwdEV4cG9ydHNcblxuICAvLyByZW5kZXIgZnVuY3Rpb25zXG4gIGlmIChjb21waWxlZFRlbXBsYXRlKSB7XG4gICAgb3B0aW9ucy5yZW5kZXIgPSBjb21waWxlZFRlbXBsYXRlLnJlbmRlclxuICAgIG9wdGlvbnMuc3RhdGljUmVuZGVyRm5zID0gY29tcGlsZWRUZW1wbGF0ZS5zdGF0aWNSZW5kZXJGbnNcbiAgICBvcHRpb25zLl9jb21waWxlZCA9IHRydWVcbiAgfVxuXG4gIC8vIGZ1bmN0aW9uYWwgdGVtcGxhdGVcbiAgaWYgKGZ1bmN0aW9uYWxUZW1wbGF0ZSkge1xuICAgIG9wdGlvbnMuZnVuY3Rpb25hbCA9IHRydWVcbiAgfVxuXG4gIC8vIHNjb3BlZElkXG4gIGlmIChzY29wZUlkKSB7XG4gICAgb3B0aW9ucy5fc2NvcGVJZCA9IHNjb3BlSWRcbiAgfVxuXG4gIHZhciBob29rXG4gIGlmIChtb2R1bGVJZGVudGlmaWVyKSB7IC8vIHNlcnZlciBidWlsZFxuICAgIGhvb2sgPSBmdW5jdGlvbiAoY29udGV4dCkge1xuICAgICAgLy8gMi4zIGluamVjdGlvblxuICAgICAgY29udGV4dCA9XG4gICAgICAgIGNvbnRleHQgfHwgLy8gY2FjaGVkIGNhbGxcbiAgICAgICAgKHRoaXMuJHZub2RlICYmIHRoaXMuJHZub2RlLnNzckNvbnRleHQpIHx8IC8vIHN0YXRlZnVsXG4gICAgICAgICh0aGlzLnBhcmVudCAmJiB0aGlzLnBhcmVudC4kdm5vZGUgJiYgdGhpcy5wYXJlbnQuJHZub2RlLnNzckNvbnRleHQpIC8vIGZ1bmN0aW9uYWxcbiAgICAgIC8vIDIuMiB3aXRoIHJ1bkluTmV3Q29udGV4dDogdHJ1ZVxuICAgICAgaWYgKCFjb250ZXh0ICYmIHR5cGVvZiBfX1ZVRV9TU1JfQ09OVEVYVF9fICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICBjb250ZXh0ID0gX19WVUVfU1NSX0NPTlRFWFRfX1xuICAgICAgfVxuICAgICAgLy8gaW5qZWN0IGNvbXBvbmVudCBzdHlsZXNcbiAgICAgIGlmIChpbmplY3RTdHlsZXMpIHtcbiAgICAgICAgaW5qZWN0U3R5bGVzLmNhbGwodGhpcywgY29udGV4dClcbiAgICAgIH1cbiAgICAgIC8vIHJlZ2lzdGVyIGNvbXBvbmVudCBtb2R1bGUgaWRlbnRpZmllciBmb3IgYXN5bmMgY2h1bmsgaW5mZXJyZW5jZVxuICAgICAgaWYgKGNvbnRleHQgJiYgY29udGV4dC5fcmVnaXN0ZXJlZENvbXBvbmVudHMpIHtcbiAgICAgICAgY29udGV4dC5fcmVnaXN0ZXJlZENvbXBvbmVudHMuYWRkKG1vZHVsZUlkZW50aWZpZXIpXG4gICAgICB9XG4gICAgfVxuICAgIC8vIHVzZWQgYnkgc3NyIGluIGNhc2UgY29tcG9uZW50IGlzIGNhY2hlZCBhbmQgYmVmb3JlQ3JlYXRlXG4gICAgLy8gbmV2ZXIgZ2V0cyBjYWxsZWRcbiAgICBvcHRpb25zLl9zc3JSZWdpc3RlciA9IGhvb2tcbiAgfSBlbHNlIGlmIChpbmplY3RTdHlsZXMpIHtcbiAgICBob29rID0gaW5qZWN0U3R5bGVzXG4gIH1cblxuICBpZiAoaG9vaykge1xuICAgIHZhciBmdW5jdGlvbmFsID0gb3B0aW9ucy5mdW5jdGlvbmFsXG4gICAgdmFyIGV4aXN0aW5nID0gZnVuY3Rpb25hbFxuICAgICAgPyBvcHRpb25zLnJlbmRlclxuICAgICAgOiBvcHRpb25zLmJlZm9yZUNyZWF0ZVxuXG4gICAgaWYgKCFmdW5jdGlvbmFsKSB7XG4gICAgICAvLyBpbmplY3QgY29tcG9uZW50IHJlZ2lzdHJhdGlvbiBhcyBiZWZvcmVDcmVhdGUgaG9va1xuICAgICAgb3B0aW9ucy5iZWZvcmVDcmVhdGUgPSBleGlzdGluZ1xuICAgICAgICA/IFtdLmNvbmNhdChleGlzdGluZywgaG9vaylcbiAgICAgICAgOiBbaG9va11cbiAgICB9IGVsc2Uge1xuICAgICAgLy8gZm9yIHRlbXBsYXRlLW9ubHkgaG90LXJlbG9hZCBiZWNhdXNlIGluIHRoYXQgY2FzZSB0aGUgcmVuZGVyIGZuIGRvZXNuJ3RcbiAgICAgIC8vIGdvIHRocm91Z2ggdGhlIG5vcm1hbGl6ZXJcbiAgICAgIG9wdGlvbnMuX2luamVjdFN0eWxlcyA9IGhvb2tcbiAgICAgIC8vIHJlZ2lzdGVyIGZvciBmdW5jdGlvYWwgY29tcG9uZW50IGluIHZ1ZSBmaWxlXG4gICAgICBvcHRpb25zLnJlbmRlciA9IGZ1bmN0aW9uIHJlbmRlcldpdGhTdHlsZUluamVjdGlvbiAoaCwgY29udGV4dCkge1xuICAgICAgICBob29rLmNhbGwoY29udGV4dClcbiAgICAgICAgcmV0dXJuIGV4aXN0aW5nKGgsIGNvbnRleHQpXG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHtcbiAgICBlc01vZHVsZTogZXNNb2R1bGUsXG4gICAgZXhwb3J0czogc2NyaXB0RXhwb3J0cyxcbiAgICBvcHRpb25zOiBvcHRpb25zXG4gIH1cbn1cblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL2NvbXBvbmVudC1ub3JtYWxpemVyLmpzXG4vLyBtb2R1bGUgaWQgPSA1MVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///51\n");

/***/ }),
/* 52 */
/***/ (function(module, exports, __webpack_require__) {

eval("module.exports = { \"default\": __webpack_require__(53), __esModule: true };\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvYmFiZWwtcnVudGltZS9jb3JlLWpzL2pzb24vc3RyaW5naWZ5LmpzPzlhZjEiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEsa0JBQWtCLFlBQVksbUJBQU8sQ0FBQyxFQUFtQyIsImZpbGUiOiI1Mi5qcyIsInNvdXJjZXNDb250ZW50IjpbIm1vZHVsZS5leHBvcnRzID0geyBcImRlZmF1bHRcIjogcmVxdWlyZShcImNvcmUtanMvbGlicmFyeS9mbi9qc29uL3N0cmluZ2lmeVwiKSwgX19lc01vZHVsZTogdHJ1ZSB9O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2JhYmVsLXJ1bnRpbWUvY29yZS1qcy9qc29uL3N0cmluZ2lmeS5qc1xuLy8gbW9kdWxlIGlkID0gNTJcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///52\n");

/***/ }),
/* 53 */
/***/ (function(module, exports, __webpack_require__) {

eval("var core = __webpack_require__(2);\nvar $JSON = core.JSON || (core.JSON = { stringify: JSON.stringify });\nmodule.exports = function stringify(it) { // eslint-disable-line no-unused-vars\n  return $JSON.stringify.apply($JSON, arguments);\n};\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L2ZuL2pzb24vc3RyaW5naWZ5LmpzP2FhNDIiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEsV0FBVyxtQkFBTyxDQUFDLENBQXFCO0FBQ3hDLHVDQUF1Qyw0QkFBNEI7QUFDbkUseUNBQXlDO0FBQ3pDO0FBQ0EiLCJmaWxlIjoiNTMuanMiLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgY29yZSA9IHJlcXVpcmUoJy4uLy4uL21vZHVsZXMvX2NvcmUnKTtcbnZhciAkSlNPTiA9IGNvcmUuSlNPTiB8fCAoY29yZS5KU09OID0geyBzdHJpbmdpZnk6IEpTT04uc3RyaW5naWZ5IH0pO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBzdHJpbmdpZnkoaXQpIHsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bnVzZWQtdmFyc1xuICByZXR1cm4gJEpTT04uc3RyaW5naWZ5LmFwcGx5KCRKU09OLCBhcmd1bWVudHMpO1xufTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9mbi9qc29uL3N0cmluZ2lmeS5qc1xuLy8gbW9kdWxlIGlkID0gNTNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///53\n");

/***/ }),
/* 54 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("/* WEBPACK VAR INJECTION */(function(process) {var Util = {\n  imgSuffix: ['jpg', 'png', 'gif', 'jpeg'], // 常用图片后缀\n  // 数组对象根据某个key相同合并分组\n  arr2GroupArray: function arr2GroupArray(arr, field) {\n    var map = {};\n    var dest = [];\n    for (var i = 0; i < arr.length; i++) {\n      var ai = arr[i];\n      if (!map[ai[field]]) {\n        dest.push({\n          key: ai[field],\n          data: [ai]\n        });\n        map[ai[[field]]] = ai;\n      } else {\n        for (var j = 0; j < dest.length; j++) {\n          var dj = dest[j];\n          if (dj.key === ai[field]) {\n            dj.data.push(ai);\n            break;\n          }\n        }\n      }\n    }\n    return dest;\n  },\n  // 金额保留2位小数 千分位\n  moneyFormat: function moneyFormat(val) {\n    var num = parseFloat(val).toFixed(2) + ''; // 保留两位小数\n    return num.replace(/(\\d{1,3})(?=(\\d{3})+(?:$|\\.))/g, '$1,');\n  },\n\n  // 格式化时间\n  timeFormat: function timeFormat(val) {\n    return val.substr(0, 4) + '-' + val.substr(4, 2) + '-' + val.substr(6, 2) + ' ' + val.substr(8, 2) + ':' + val.substr(10, 2) + ':' + val.substr(12, 2);\n  },\n\n  // 格式化时间\n  dateFormat: function dateFormat(val) {\n    return val === '' ? '' : val.substr(0, 4) + '-' + val.substr(4, 2) + '-' + val.substr(6, 2);\n  },\n\n  // 生成影像地址\n  createImgUrl: function createImgUrl(F_ATT_STO_KEY) {\n    if (F_ATT_STO_KEY !== '' || F_ATT_STO_KEY !== undefined) {\n      var imgurl = process.env.BASE_API + '/fileTransferDownloadAction.do?F_APP_ID=CPEFSS&F_NEED_APPLY=1&F_STORE_KEY=';\n      return imgurl + F_ATT_STO_KEY;\n    }\n  }\n};\n/* harmony default export */ __webpack_exports__[\"a\"] = (Util);\n/* WEBPACK VAR INJECTION */}.call(__webpack_exports__, __webpack_require__(11)))\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvdXRpbHMvdXRpbC5qcz9hMDViIl0sIm5hbWVzIjpbIlV0aWwiLCJpbWdTdWZmaXgiLCJhcnIyR3JvdXBBcnJheSIsImFyciIsImZpZWxkIiwibWFwIiwiZGVzdCIsImkiLCJsZW5ndGgiLCJhaSIsInB1c2giLCJrZXkiLCJkYXRhIiwiaiIsImRqIiwibW9uZXlGb3JtYXQiLCJ2YWwiLCJudW0iLCJwYXJzZUZsb2F0IiwidG9GaXhlZCIsInJlcGxhY2UiLCJ0aW1lRm9ybWF0Iiwic3Vic3RyIiwiZGF0ZUZvcm1hdCIsImNyZWF0ZUltZ1VybCIsIkZfQVRUX1NUT19LRVkiLCJ1bmRlZmluZWQiLCJpbWd1cmwiLCJwcm9jZXNzIiwiZW52IiwiQkFTRV9BUEkiXSwibWFwcGluZ3MiOiJBQUFBLG1EQUFJQSxPQUFPO0FBQ1RDLGFBQVcsQ0FBQyxLQUFELEVBQVEsS0FBUixFQUFlLEtBQWYsRUFBc0IsTUFBdEIsQ0FERixFQUNpQztBQUMxQztBQUNBQyxrQkFBZ0Isd0JBQVVDLEdBQVYsRUFBZUMsS0FBZixFQUFzQjtBQUNwQyxRQUFJQyxNQUFNLEVBQVY7QUFDQSxRQUFJQyxPQUFPLEVBQVg7QUFDQSxTQUFLLElBQUlDLElBQUksQ0FBYixFQUFnQkEsSUFBSUosSUFBSUssTUFBeEIsRUFBZ0NELEdBQWhDLEVBQXFDO0FBQ25DLFVBQUlFLEtBQUtOLElBQUlJLENBQUosQ0FBVDtBQUNBLFVBQUksQ0FBQ0YsSUFBSUksR0FBR0wsS0FBSCxDQUFKLENBQUwsRUFBcUI7QUFDbkJFLGFBQUtJLElBQUwsQ0FBVTtBQUNSQyxlQUFLRixHQUFHTCxLQUFILENBREc7QUFFUlEsZ0JBQU0sQ0FBQ0gsRUFBRDtBQUZFLFNBQVY7QUFJQUosWUFBSUksR0FBRyxDQUFDTCxLQUFELENBQUgsQ0FBSixJQUFtQkssRUFBbkI7QUFDRCxPQU5ELE1BTU87QUFDTCxhQUFLLElBQUlJLElBQUksQ0FBYixFQUFnQkEsSUFBSVAsS0FBS0UsTUFBekIsRUFBaUNLLEdBQWpDLEVBQXNDO0FBQ3BDLGNBQUlDLEtBQUtSLEtBQUtPLENBQUwsQ0FBVDtBQUNBLGNBQUlDLEdBQUdILEdBQUgsS0FBV0YsR0FBR0wsS0FBSCxDQUFmLEVBQTBCO0FBQ3hCVSxlQUFHRixJQUFILENBQVFGLElBQVIsQ0FBYUQsRUFBYjtBQUNBO0FBQ0Q7QUFDRjtBQUNGO0FBQ0Y7QUFDRCxXQUFPSCxJQUFQO0FBQ0QsR0F6QlE7QUEwQlQ7QUFDQVMsYUEzQlMsdUJBMkJJQyxHQTNCSixFQTJCUztBQUNoQixRQUFJQyxNQUFNQyxXQUFXRixHQUFYLEVBQWdCRyxPQUFoQixDQUF3QixDQUF4QixJQUE2QixFQUF2QyxDQURnQixDQUMwQjtBQUMxQyxXQUFPRixJQUFJRyxPQUFKLENBQVksZ0NBQVosRUFBOEMsS0FBOUMsQ0FBUDtBQUNELEdBOUJROztBQStCVDtBQUNBQyxZQWhDUyxzQkFnQ0dMLEdBaENILEVBZ0NRO0FBQ2YsV0FBT0EsSUFBSU0sTUFBSixDQUFXLENBQVgsRUFBYyxDQUFkLElBQW1CLEdBQW5CLEdBQXlCTixJQUFJTSxNQUFKLENBQVcsQ0FBWCxFQUFjLENBQWQsQ0FBekIsR0FBNEMsR0FBNUMsR0FBa0ROLElBQUlNLE1BQUosQ0FBVyxDQUFYLEVBQWMsQ0FBZCxDQUFsRCxHQUFxRSxHQUFyRSxHQUEyRU4sSUFBSU0sTUFBSixDQUFXLENBQVgsRUFBYyxDQUFkLENBQTNFLEdBQThGLEdBQTlGLEdBQW9HTixJQUFJTSxNQUFKLENBQVcsRUFBWCxFQUFlLENBQWYsQ0FBcEcsR0FBd0gsR0FBeEgsR0FBOEhOLElBQUlNLE1BQUosQ0FBVyxFQUFYLEVBQWUsQ0FBZixDQUFySTtBQUNELEdBbENROztBQW1DVDtBQUNBQyxZQXBDUyxzQkFvQ0dQLEdBcENILEVBb0NRO0FBQ2YsV0FBT0EsUUFBUSxFQUFSLEdBQWEsRUFBYixHQUFrQkEsSUFBSU0sTUFBSixDQUFXLENBQVgsRUFBYyxDQUFkLElBQW1CLEdBQW5CLEdBQXlCTixJQUFJTSxNQUFKLENBQVcsQ0FBWCxFQUFjLENBQWQsQ0FBekIsR0FBNEMsR0FBNUMsR0FBa0ROLElBQUlNLE1BQUosQ0FBVyxDQUFYLEVBQWMsQ0FBZCxDQUEzRTtBQUNELEdBdENROztBQXVDVDtBQUNBRSxnQkFBYyxzQkFBVUMsYUFBVixFQUF5QjtBQUNyQyxRQUFJQSxrQkFBa0IsRUFBbEIsSUFBd0JBLGtCQUFrQkMsU0FBOUMsRUFBeUQ7QUFDdkQsVUFBSUMsU0FBU0MsUUFBUUMsR0FBUixDQUFZQyxRQUFaLEdBQXVCLDRFQUFwQztBQUNBLGFBQU9ILFNBQVNGLGFBQWhCO0FBQ0Q7QUFDRjtBQTdDUSxDQUFYO0FBK0NlekIsNkRBQWYsRSIsImZpbGUiOiI1NC5qcyIsInNvdXJjZXNDb250ZW50IjpbInZhciBVdGlsID0ge1xyXG4gIGltZ1N1ZmZpeDogWydqcGcnLCAncG5nJywgJ2dpZicsICdqcGVnJ10sIC8vIOW4uOeUqOWbvueJh+WQjue8gFxyXG4gIC8vIOaVsOe7hOWvueixoeagueaNruafkOS4qmtleeebuOWQjOWQiOW5tuWIhue7hFxyXG4gIGFycjJHcm91cEFycmF5OiBmdW5jdGlvbiAoYXJyLCBmaWVsZCkge1xyXG4gICAgdmFyIG1hcCA9IHt9XHJcbiAgICB2YXIgZGVzdCA9IFtdXHJcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFyci5sZW5ndGg7IGkrKykge1xyXG4gICAgICB2YXIgYWkgPSBhcnJbaV1cclxuICAgICAgaWYgKCFtYXBbYWlbZmllbGRdXSkge1xyXG4gICAgICAgIGRlc3QucHVzaCh7XHJcbiAgICAgICAgICBrZXk6IGFpW2ZpZWxkXSxcclxuICAgICAgICAgIGRhdGE6IFthaV1cclxuICAgICAgICB9KVxyXG4gICAgICAgIG1hcFthaVtbZmllbGRdXV0gPSBhaVxyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgZGVzdC5sZW5ndGg7IGorKykge1xyXG4gICAgICAgICAgdmFyIGRqID0gZGVzdFtqXVxyXG4gICAgICAgICAgaWYgKGRqLmtleSA9PT0gYWlbZmllbGRdKSB7XHJcbiAgICAgICAgICAgIGRqLmRhdGEucHVzaChhaSlcclxuICAgICAgICAgICAgYnJlYWtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiBkZXN0XHJcbiAgfSxcclxuICAvLyDph5Hpop3kv53nlZky5L2N5bCP5pWwIOWNg+WIhuS9jVxyXG4gIG1vbmV5Rm9ybWF0ICh2YWwpIHtcclxuICAgIHZhciBudW0gPSBwYXJzZUZsb2F0KHZhbCkudG9GaXhlZCgyKSArICcnIC8vIOS/neeVmeS4pOS9jeWwj+aVsFxyXG4gICAgcmV0dXJuIG51bS5yZXBsYWNlKC8oXFxkezEsM30pKD89KFxcZHszfSkrKD86JHxcXC4pKS9nLCAnJDEsJylcclxuICB9LFxyXG4gIC8vIOagvOW8j+WMluaXtumXtFxyXG4gIHRpbWVGb3JtYXQgKHZhbCkge1xyXG4gICAgcmV0dXJuIHZhbC5zdWJzdHIoMCwgNCkgKyAnLScgKyB2YWwuc3Vic3RyKDQsIDIpICsgJy0nICsgdmFsLnN1YnN0cig2LCAyKSArICcgJyArIHZhbC5zdWJzdHIoOCwgMikgKyAnOicgKyB2YWwuc3Vic3RyKDEwLCAyKSArICc6JyArIHZhbC5zdWJzdHIoMTIsIDIpXHJcbiAgfSxcclxuICAvLyDmoLzlvI/ljJbml7bpl7RcclxuICBkYXRlRm9ybWF0ICh2YWwpIHtcclxuICAgIHJldHVybiB2YWwgPT09ICcnID8gJycgOiB2YWwuc3Vic3RyKDAsIDQpICsgJy0nICsgdmFsLnN1YnN0cig0LCAyKSArICctJyArIHZhbC5zdWJzdHIoNiwgMilcclxuICB9LFxyXG4gIC8vIOeUn+aIkOW9seWDj+WcsOWdgFxyXG4gIGNyZWF0ZUltZ1VybDogZnVuY3Rpb24gKEZfQVRUX1NUT19LRVkpIHtcclxuICAgIGlmIChGX0FUVF9TVE9fS0VZICE9PSAnJyB8fCBGX0FUVF9TVE9fS0VZICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgdmFyIGltZ3VybCA9IHByb2Nlc3MuZW52LkJBU0VfQVBJICsgJy9maWxlVHJhbnNmZXJEb3dubG9hZEFjdGlvbi5kbz9GX0FQUF9JRD1DUEVGU1MmRl9ORUVEX0FQUExZPTEmRl9TVE9SRV9LRVk9J1xyXG4gICAgICByZXR1cm4gaW1ndXJsICsgRl9BVFRfU1RPX0tFWVxyXG4gICAgfVxyXG4gIH1cclxufVxyXG5leHBvcnQgZGVmYXVsdCBVdGlsXHJcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy91dGlscy91dGlsLmpzIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///54\n");

/***/ }),
/* 55 */
/***/ (function(module, exports, __webpack_require__) {

eval("// style-loader: Adds some css to the DOM by adding a <style> tag\n\n// load the styles\nvar content = __webpack_require__(56);\nif(typeof content === 'string') content = [[module.i, content, '']];\nif(content.locals) module.exports = content.locals;\n// add the styles to the DOM\nvar update = __webpack_require__(10)(\"122a771a\", content, false, {});\n// Hot Module Replacement\nif(false) {\n // When the styles change, update the <style> tags\n if(!content.locals) {\n   module.hot.accept(\"!!../../../../node_modules/css-loader/index.js!./demo.css\", function() {\n     var newContent = require(\"!!../../../../node_modules/css-loader/index.js!./demo.css\");\n     if(typeof newContent === 'string') newContent = [[module.id, newContent, '']];\n     update(newContent);\n   });\n }\n // When the module is disposed, remove the <style> tags\n module.hot.dispose(function() { update(); });\n}\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvY29tcG9uZW50cy93ZWJ1cGxvYWRlci9jc3MvZGVtby5jc3M/Y2M3MCJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTs7QUFFQTtBQUNBLGNBQWMsbUJBQU8sQ0FBQyxFQUEyRDtBQUNqRiw0Q0FBNEMsUUFBUztBQUNyRDtBQUNBO0FBQ0EsYUFBYSxtQkFBTyxDQUFDLEVBQW1FLGdDQUFnQztBQUN4SDtBQUNBLEdBQUcsS0FBVTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0EsZ0NBQWdDLFVBQVUsRUFBRTtBQUM1QyIsImZpbGUiOiI1NS5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8vIHN0eWxlLWxvYWRlcjogQWRkcyBzb21lIGNzcyB0byB0aGUgRE9NIGJ5IGFkZGluZyBhIDxzdHlsZT4gdGFnXG5cbi8vIGxvYWQgdGhlIHN0eWxlc1xudmFyIGNvbnRlbnQgPSByZXF1aXJlKFwiISEuLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9pbmRleC5qcyEuL2RlbW8uY3NzXCIpO1xuaWYodHlwZW9mIGNvbnRlbnQgPT09ICdzdHJpbmcnKSBjb250ZW50ID0gW1ttb2R1bGUuaWQsIGNvbnRlbnQsICcnXV07XG5pZihjb250ZW50LmxvY2FscykgbW9kdWxlLmV4cG9ydHMgPSBjb250ZW50LmxvY2Fscztcbi8vIGFkZCB0aGUgc3R5bGVzIHRvIHRoZSBET01cbnZhciB1cGRhdGUgPSByZXF1aXJlKFwiIS4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy92dWUtc3R5bGUtbG9hZGVyL2xpYi9hZGRTdHlsZXNDbGllbnQuanNcIikoXCIxMjJhNzcxYVwiLCBjb250ZW50LCBmYWxzZSwge30pO1xuLy8gSG90IE1vZHVsZSBSZXBsYWNlbWVudFxuaWYobW9kdWxlLmhvdCkge1xuIC8vIFdoZW4gdGhlIHN0eWxlcyBjaGFuZ2UsIHVwZGF0ZSB0aGUgPHN0eWxlPiB0YWdzXG4gaWYoIWNvbnRlbnQubG9jYWxzKSB7XG4gICBtb2R1bGUuaG90LmFjY2VwdChcIiEhLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvaW5kZXguanMhLi9kZW1vLmNzc1wiLCBmdW5jdGlvbigpIHtcbiAgICAgdmFyIG5ld0NvbnRlbnQgPSByZXF1aXJlKFwiISEuLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9pbmRleC5qcyEuL2RlbW8uY3NzXCIpO1xuICAgICBpZih0eXBlb2YgbmV3Q29udGVudCA9PT0gJ3N0cmluZycpIG5ld0NvbnRlbnQgPSBbW21vZHVsZS5pZCwgbmV3Q29udGVudCwgJyddXTtcbiAgICAgdXBkYXRlKG5ld0NvbnRlbnQpO1xuICAgfSk7XG4gfVxuIC8vIFdoZW4gdGhlIG1vZHVsZSBpcyBkaXNwb3NlZCwgcmVtb3ZlIHRoZSA8c3R5bGU+IHRhZ3NcbiBtb2R1bGUuaG90LmRpc3Bvc2UoZnVuY3Rpb24oKSB7IHVwZGF0ZSgpOyB9KTtcbn1cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL3NyYy9jb21wb25lbnRzL3dlYnVwbG9hZGVyL2Nzcy9kZW1vLmNzc1xuLy8gbW9kdWxlIGlkID0gNTVcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///55\n");

/***/ }),
/* 56 */
/***/ (function(module, exports, __webpack_require__) {

eval("var escape = __webpack_require__(34);\nexports = module.exports = __webpack_require__(9)(false);\n// imports\n\n\n// module\nexports.push([module.i, \"#container { color: #838383; font-size: 12px; }\\r\\n#uploader .queueList { border: 2px dashed #e6e6e6; }\\r\\n#uploader .queueList.filled { margin: 0; border: 1px dashed #00000017;border-top: none; }\\r\\n#uploader .queueList.webuploader-dnd-over { }\\r\\n#uploader p { margin: 0; }\\r\\n.element-invisible { position: absolute !important; clip: rect(1px 1px 1px 1px); /* IE6, IE7 */ clip: rect(1px,1px,1px,1px);display: none }\\r\\n#uploader .placeholder {padding-top: 170px; text-align: center; background: url(\" + escape(__webpack_require__(57)) + \") center 93px no-repeat; color: #cccccc; font-size: 18px; position: relative; }\\r\\n#uploader .placeholder .webuploader-pick { font-size: 18px; background: #00b7ee; border-radius: 3px; line-height: 44px; padding: 0 30px;  *width: 120px;\\r\\ncolor: #fff; display: inline-block; margin: 0 auto 20px auto; cursor: pointer; box-shadow: 0 1px 1px rgba(0, 0, 0, 0.1); }\\r\\n#uploader .placeholder .webuploader-pick-hover { background: #00a2d4; }\\r\\n#uploader .placeholder .flashTip { color: #666666; font-size: 12px; position: absolute; width: 100%; text-align: center; bottom: 20px; }\\r\\n#uploader .placeholder .flashTip a { color: #0785d1; text-decoration: none; }\\r\\n#uploader .placeholder .flashTip a:hover { text-decoration: underline; }\\r\\n#uploader .filelist { list-style: none; margin: 0; padding: 0; position: relative; margin: 10px; }\\r\\n#uploader .filelist:after { content: ''; display: block; width: 0; height: 0; overflow: hidden; clear: both; }\\r\\nul.filelist .active { border: 1px dashed red; }\\r\\n*[draggable=true] { -moz-user-select: none; -khtml-user-drag: element; cursor: move; }\\r\\n *:-khtml-drag {\\r\\n background-color:rgab(238, 238, 238, 0.5);\\r\\n}\\r\\nul.filelist li.move { -webkit-transform: scale3d(1.1, 1.1, 1.1); }\\r\\n#uploader .filelist li { text-align: center; margin: 0 8px 20px 0; position: relative; display: inline; float: left; overflow: hidden; font-size: 12px; }\\r\\nul.filelist li:hover { border-color: #9a9fa4; box-shadow: 0 0 6px 0 rgba(0, 0, 0, 0.85); }\\r\\n#uploader .filelist li p.log { position: relative; top: -45px; }\\r\\n#uploader .filelist li p.title { \\r\\n    position: absolute;\\r\\n    bottom: 2px;\\r\\n    width: 100%;\\r\\n    overflow: hidden;\\r\\n    white-space: nowrap;\\r\\n    text-overflow: ellipsis;\\r\\n    text-align: center;\\r\\n    font-size: 14px;\\r\\n    color: #005193;\\r\\n    font-weight: 500;\\r\\n}\\r\\n#uploader .filelist li p.progress { position: absolute; width: 100%; bottom: 0; left: 0; height: 8px; overflow: hidden; z-index: 50; margin: 0; border-radius: 0; background: none; -webkit-box-shadow: 0 0 0; }\\r\\n#uploader .filelist li p.progress span { display: none; overflow: hidden; width: 0; height: 100%; background: #1483d8 url(\" + escape(__webpack_require__(35)) + \") repeat-x; -webit-transition: width 200ms linear; -moz-transition: width 200ms linear; -o-transition: width 200ms linear; -ms-transition: width 200ms linear; transition: width 200ms linear; -webkit-animation: progressmove 2s linear infinite; -moz-animation: progressmove 2s linear infinite; -o-animation: progressmove 2s linear infinite; -ms-animation: progressmove 2s linear infinite; animation: progressmove 2s linear infinite; -webkit-transform: translateZ(0); }\\r\\n @-webkit-keyframes progressmove {\\r\\n 0% {\\r\\n background-position: 0 0;\\r\\n}\\r\\n 100% {\\r\\n background-position: 17px 0;\\r\\n}\\r\\n}\\r\\n@-moz-keyframes progressmove {\\r\\n 0% {\\r\\n background-position: 0 0;\\r\\n}\\r\\n 100% {\\r\\n background-position: 17px 0;\\r\\n}\\r\\n}\\r\\n@keyframes progressmove {\\r\\n 0% {\\r\\n background-position: 0 0;\\r\\n}\\r\\n 100% {\\r\\n background-position: 17px 0;\\r\\n}\\r\\n}\\r\\n#uploader .filelist li {margin:6px}\\r\\n#uploader .filelist li p.imgWrap { position: relative; line-height: 110px; vertical-align: middle; overflow: hidden; -webkit-transform-origin: 50% 50%; -moz-transform-origin: 50% 50%; -o-transform-origin: 50% 50%; -ms-transform-origin: 50% 50%; transform-origin: 50% 50%; -webit-transition: 200ms ease-out; -moz-transition: 200ms ease-out; -o-transition: 200ms ease-out; -ms-transition: 200ms ease-out; transition: 200ms ease-out; }\\r\\n#uploader .filelist li img { width: 100%; }\\r\\n#uploader .filelist li p.error { background: #f43838; color: #fff; position: absolute; bottom: 0; left: 0; height: 28px; line-height: 28px; width: 100%; z-index: 100; }\\r\\n#uploader .filelist li .success { display: block; position: absolute; left: 0; bottom: 25px; height: 40px; width: 100%; z-index: 200; background: url(\" + escape(__webpack_require__(58)) + \") no-repeat right bottom; }\\r\\n#uploader .filelist div.file-panel { position: absolute; height: 0;  filter: progid:DXImageTransform.Microsoft.gradient(GradientType=0, startColorstr='#80000000', endColorstr='#80000000')\\\\0;\\r\\nbackground: rgba( 0, 0, 0, 0.5 ); width: 100%; top: 0; left: 0; overflow: hidden; z-index: 300; }\\r\\n#uploader .filelist div.file-panel span { width: 24px; height: 24px; display: inline; float: right; text-indent: -9999px; overflow: hidden; background: url(\" + escape(__webpack_require__(59)) + \") no-repeat; margin: 5px 1px 1px; cursor: pointer; }\\r\\n#uploader .filelist div.file-panel span.rotateLeft { background-position: 0 -24px; }\\r\\n#uploader .filelist div.file-panel span.rotateLeft:hover { background-position: 0 0; }\\r\\n#uploader .filelist div.file-panel span.rotateRight { background-position: -24px -24px; }\\r\\n#uploader .filelist div.file-panel span.rotateRight:hover { background-position: -24px 0; }\\r\\n#uploader .filelist div.file-panel span.cancel { background-position: -48px -24px; }\\r\\n#uploader .filelist div.file-panel span.cancel:hover { background-position: -48px 0; }\\r\\n#uploader .statusBar {  border-bottom: 1px solid #dadada; padding: 0 20px; line-height: 40px; vertical-align: middle; position: relative; }\\r\\n#uploader .statusBar .progress { \\r\\n    border: 1px solid #1483d8;\\r\\n    width: 198px;\\r\\n    background: #fff;\\r\\n    /* height: 18px; */\\r\\n    position: absolute;\\r\\n    display: inline-block;\\r\\n    text-align: center;\\r\\n    line-height: 20px;\\r\\n    color: #6dbfff;\\r\\n    position: relative;\\r\\n    margin: 4px 10px 0 0;\\r\\n    float: left;\\r\\n}\\r\\n#uploader .statusBar .progress span.percentage { width: 0; height: 100%; left: 0; top: 0; background: #1483d8; position: absolute; }\\r\\n#uploader .statusBar .progress span.text { position: relative; z-index: 10; }\\r\\n#uploader .statusBar .info { display: inline-block; font-size: 14px; color: #666666;float: left }\\r\\n#uploader .statusBar .btns { position: absolute; top: 0px; right: 20px; line-height: 30px; }\\r\\n#filePicker2 { display: inline-block; float: left; }\\r\\n#uploader .statusBar .btns .webuploader-pick, #uploader .statusBar .btns .uploadBtn, #uploader .statusBar .btns .uploadBtn.state-uploading, #uploader .statusBar .btns .uploadBtn.state-paused { background: #ffffff; border: 1px solid #cfcfcf; color: #565656; padding: 0 18px; display: inline-block; border-radius: 3px; margin-left: 10px; cursor: pointer; font-size: 14px; float: left; }\\r\\n#uploader .statusBar .btns .webuploader-pick-hover, #uploader .statusBar .btns .uploadBtn:hover, #uploader .statusBar .btns .uploadBtn.state-uploading:hover, #uploader .statusBar .btns .uploadBtn.state-paused:hover { background: #f0f0f0; }\\r\\n#uploader .statusBar .btns .uploadBtn { background: #00b7ee; color: #fff; border-color: transparent; }\\r\\n#uploader .statusBar .btns .uploadBtn:hover { background: #00a2d4; }\\r\\n#uploader .statusBar .btns .uploadBtn.disabled { pointer-events: none; opacity: 0.6; }\\r\\n\", \"\"]);\n\n// exports\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvY29tcG9uZW50cy93ZWJ1cGxvYWRlci9jc3MvZGVtby5jc3M/N2E5MSJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSxhQUFhLG1CQUFPLENBQUMsRUFBdUQ7QUFDNUUsMkJBQTJCLG1CQUFPLENBQUMsQ0FBcUQ7QUFDeEY7OztBQUdBO0FBQ0EsY0FBYyxRQUFTLGVBQWUsZ0JBQWdCLGlCQUFpQixFQUFFLDBCQUEwQiw0QkFBNEIsRUFBRSxpQ0FBaUMsV0FBVyw4QkFBOEIsaUJBQWlCLEVBQUUsK0NBQStDLEVBQUUsaUJBQWlCLFdBQVcsRUFBRSx3QkFBd0IsK0JBQStCLDZCQUE2Qiw0Q0FBNEMsZUFBZSw0QkFBNEIsbUJBQW1CLG9CQUFvQiw0QkFBNEIsbUJBQU8sQ0FBQyxFQUFxQiw4QkFBOEIsZ0JBQWdCLGlCQUFpQixvQkFBb0IsRUFBRSw4Q0FBOEMsaUJBQWlCLHFCQUFxQixvQkFBb0IsbUJBQW1CLGlCQUFpQixnQkFBZ0IsZ0JBQWdCLHVCQUF1QiwwQkFBMEIsaUJBQWlCLDBDQUEwQyxFQUFFLG9EQUFvRCxxQkFBcUIsRUFBRSxzQ0FBc0MsZ0JBQWdCLGlCQUFpQixvQkFBb0IsYUFBYSxvQkFBb0IsY0FBYyxFQUFFLHdDQUF3QyxnQkFBZ0IsdUJBQXVCLEVBQUUsOENBQThDLDRCQUE0QixFQUFFLHlCQUF5QixrQkFBa0IsV0FBVyxZQUFZLG9CQUFvQixjQUFjLEVBQUUsK0JBQStCLGFBQWEsZ0JBQWdCLFVBQVUsV0FBVyxrQkFBa0IsYUFBYSxFQUFFLHlCQUF5Qix3QkFBd0IsRUFBRSx1QkFBdUIsd0JBQXdCLDJCQUEyQixjQUFjLEVBQUUsb0JBQW9CLCtDQUErQyxLQUFLLHlCQUF5QiwyQ0FBMkMsRUFBRSw0QkFBNEIsb0JBQW9CLHNCQUFzQixvQkFBb0IsaUJBQWlCLGFBQWEsa0JBQWtCLGlCQUFpQixFQUFFLDBCQUEwQix1QkFBdUIsMkNBQTJDLEVBQUUsa0NBQWtDLG9CQUFvQixZQUFZLEVBQUUsb0NBQW9DLDRCQUE0QixvQkFBb0Isb0JBQW9CLHlCQUF5Qiw0QkFBNEIsZ0NBQWdDLDJCQUEyQix3QkFBd0IsdUJBQXVCLHlCQUF5QixLQUFLLHVDQUF1QyxvQkFBb0IsYUFBYSxXQUFXLFNBQVMsYUFBYSxrQkFBa0IsYUFBYSxXQUFXLGtCQUFrQixrQkFBa0IsMkJBQTJCLEVBQUUsNENBQTRDLGVBQWUsa0JBQWtCLFVBQVUsY0FBYyxvQ0FBb0MsbUJBQU8sQ0FBQyxFQUF3QixpQkFBaUIsdUNBQXVDLHFDQUFxQyxtQ0FBbUMsb0NBQW9DLGdDQUFnQyxvREFBb0QsaURBQWlELCtDQUErQyxnREFBZ0QsNENBQTRDLGtDQUFrQyxFQUFFLHNDQUFzQyxTQUFTLDhCQUE4QixLQUFLLFdBQVcsaUNBQWlDLEtBQUssS0FBSyxrQ0FBa0MsU0FBUyw4QkFBOEIsS0FBSyxXQUFXLGlDQUFpQyxLQUFLLEtBQUssNkJBQTZCLFNBQVMsOEJBQThCLEtBQUssV0FBVyxpQ0FBaUMsS0FBSyxLQUFLLDRCQUE0QixXQUFXLHNDQUFzQyxvQkFBb0Isb0JBQW9CLHdCQUF3QixrQkFBa0IsbUNBQW1DLGdDQUFnQyw4QkFBOEIsK0JBQStCLDJCQUEyQixtQ0FBbUMsaUNBQWlDLCtCQUErQixnQ0FBZ0MsNEJBQTRCLEVBQUUsZ0NBQWdDLGFBQWEsRUFBRSxvQ0FBb0MscUJBQXFCLGFBQWEsb0JBQW9CLFdBQVcsU0FBUyxjQUFjLG1CQUFtQixhQUFhLGNBQWMsRUFBRSxxQ0FBcUMsZ0JBQWdCLG9CQUFvQixTQUFTLGNBQWMsY0FBYyxhQUFhLGNBQWMsNEJBQTRCLG1CQUFPLENBQUMsRUFBdUIsK0JBQStCLEVBQUUsd0NBQXdDLG9CQUFvQixXQUFXLDRIQUE0SCxxQ0FBcUMsYUFBYSxRQUFRLFNBQVMsa0JBQWtCLGNBQWMsRUFBRSw2Q0FBNkMsYUFBYSxjQUFjLGlCQUFpQixjQUFjLHNCQUFzQixrQkFBa0IsNEJBQTRCLG1CQUFPLENBQUMsRUFBcUIsa0JBQWtCLHFCQUFxQixpQkFBaUIsRUFBRSx3REFBd0QsOEJBQThCLEVBQUUsOERBQThELDBCQUEwQixFQUFFLHlEQUF5RCxrQ0FBa0MsRUFBRSwrREFBK0QsOEJBQThCLEVBQUUsb0RBQW9ELGtDQUFrQyxFQUFFLDBEQUEwRCw4QkFBOEIsRUFBRSwwQkFBMEIsbUNBQW1DLGlCQUFpQixtQkFBbUIsd0JBQXdCLG9CQUFvQixFQUFFLG9DQUFvQyxtQ0FBbUMscUJBQXFCLHlCQUF5Qix3QkFBd0IsOEJBQThCLDhCQUE4QiwyQkFBMkIsMEJBQTBCLHVCQUF1QiwyQkFBMkIsNkJBQTZCLG9CQUFvQixLQUFLLG9EQUFvRCxVQUFVLGNBQWMsU0FBUyxRQUFRLHFCQUFxQixvQkFBb0IsRUFBRSw4Q0FBOEMsb0JBQW9CLGFBQWEsRUFBRSxnQ0FBZ0MsdUJBQXVCLGlCQUFpQixnQkFBZ0IsYUFBYSxnQ0FBZ0Msb0JBQW9CLFVBQVUsYUFBYSxtQkFBbUIsRUFBRSxrQkFBa0IsdUJBQXVCLGFBQWEsRUFBRSxvTUFBb00scUJBQXFCLDJCQUEyQixnQkFBZ0IsaUJBQWlCLHVCQUF1QixvQkFBb0IsbUJBQW1CLGlCQUFpQixpQkFBaUIsYUFBYSxFQUFFLDROQUE0TixxQkFBcUIsRUFBRSwyQ0FBMkMscUJBQXFCLGFBQWEsMkJBQTJCLEVBQUUsaURBQWlELHFCQUFxQixFQUFFLG9EQUFvRCxzQkFBc0IsY0FBYyxFQUFFOztBQUVyNE8iLCJmaWxlIjoiNTYuanMiLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgZXNjYXBlID0gcmVxdWlyZShcIi4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2xpYi91cmwvZXNjYXBlLmpzXCIpO1xuZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcIi4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2xpYi9jc3MtYmFzZS5qc1wiKShmYWxzZSk7XG4vLyBpbXBvcnRzXG5cblxuLy8gbW9kdWxlXG5leHBvcnRzLnB1c2goW21vZHVsZS5pZCwgXCIjY29udGFpbmVyIHsgY29sb3I6ICM4MzgzODM7IGZvbnQtc2l6ZTogMTJweDsgfVxcclxcbiN1cGxvYWRlciAucXVldWVMaXN0IHsgYm9yZGVyOiAycHggZGFzaGVkICNlNmU2ZTY7IH1cXHJcXG4jdXBsb2FkZXIgLnF1ZXVlTGlzdC5maWxsZWQgeyBtYXJnaW46IDA7IGJvcmRlcjogMXB4IGRhc2hlZCAjMDAwMDAwMTc7Ym9yZGVyLXRvcDogbm9uZTsgfVxcclxcbiN1cGxvYWRlciAucXVldWVMaXN0LndlYnVwbG9hZGVyLWRuZC1vdmVyIHsgfVxcclxcbiN1cGxvYWRlciBwIHsgbWFyZ2luOiAwOyB9XFxyXFxuLmVsZW1lbnQtaW52aXNpYmxlIHsgcG9zaXRpb246IGFic29sdXRlICFpbXBvcnRhbnQ7IGNsaXA6IHJlY3QoMXB4IDFweCAxcHggMXB4KTsgLyogSUU2LCBJRTcgKi8gY2xpcDogcmVjdCgxcHgsMXB4LDFweCwxcHgpO2Rpc3BsYXk6IG5vbmUgfVxcclxcbiN1cGxvYWRlciAucGxhY2Vob2xkZXIge3BhZGRpbmctdG9wOiAxNzBweDsgdGV4dC1hbGlnbjogY2VudGVyOyBiYWNrZ3JvdW5kOiB1cmwoXCIgKyBlc2NhcGUocmVxdWlyZShcIi4uL2ltYWdlcy9pbWFnZS5wbmdcIikpICsgXCIpIGNlbnRlciA5M3B4IG5vLXJlcGVhdDsgY29sb3I6ICNjY2NjY2M7IGZvbnQtc2l6ZTogMThweDsgcG9zaXRpb246IHJlbGF0aXZlOyB9XFxyXFxuI3VwbG9hZGVyIC5wbGFjZWhvbGRlciAud2VidXBsb2FkZXItcGljayB7IGZvbnQtc2l6ZTogMThweDsgYmFja2dyb3VuZDogIzAwYjdlZTsgYm9yZGVyLXJhZGl1czogM3B4OyBsaW5lLWhlaWdodDogNDRweDsgcGFkZGluZzogMCAzMHB4OyAgKndpZHRoOiAxMjBweDtcXHJcXG5jb2xvcjogI2ZmZjsgZGlzcGxheTogaW5saW5lLWJsb2NrOyBtYXJnaW46IDAgYXV0byAyMHB4IGF1dG87IGN1cnNvcjogcG9pbnRlcjsgYm94LXNoYWRvdzogMCAxcHggMXB4IHJnYmEoMCwgMCwgMCwgMC4xKTsgfVxcclxcbiN1cGxvYWRlciAucGxhY2Vob2xkZXIgLndlYnVwbG9hZGVyLXBpY2staG92ZXIgeyBiYWNrZ3JvdW5kOiAjMDBhMmQ0OyB9XFxyXFxuI3VwbG9hZGVyIC5wbGFjZWhvbGRlciAuZmxhc2hUaXAgeyBjb2xvcjogIzY2NjY2NjsgZm9udC1zaXplOiAxMnB4OyBwb3NpdGlvbjogYWJzb2x1dGU7IHdpZHRoOiAxMDAlOyB0ZXh0LWFsaWduOiBjZW50ZXI7IGJvdHRvbTogMjBweDsgfVxcclxcbiN1cGxvYWRlciAucGxhY2Vob2xkZXIgLmZsYXNoVGlwIGEgeyBjb2xvcjogIzA3ODVkMTsgdGV4dC1kZWNvcmF0aW9uOiBub25lOyB9XFxyXFxuI3VwbG9hZGVyIC5wbGFjZWhvbGRlciAuZmxhc2hUaXAgYTpob3ZlciB7IHRleHQtZGVjb3JhdGlvbjogdW5kZXJsaW5lOyB9XFxyXFxuI3VwbG9hZGVyIC5maWxlbGlzdCB7IGxpc3Qtc3R5bGU6IG5vbmU7IG1hcmdpbjogMDsgcGFkZGluZzogMDsgcG9zaXRpb246IHJlbGF0aXZlOyBtYXJnaW46IDEwcHg7IH1cXHJcXG4jdXBsb2FkZXIgLmZpbGVsaXN0OmFmdGVyIHsgY29udGVudDogJyc7IGRpc3BsYXk6IGJsb2NrOyB3aWR0aDogMDsgaGVpZ2h0OiAwOyBvdmVyZmxvdzogaGlkZGVuOyBjbGVhcjogYm90aDsgfVxcclxcbnVsLmZpbGVsaXN0IC5hY3RpdmUgeyBib3JkZXI6IDFweCBkYXNoZWQgcmVkOyB9XFxyXFxuKltkcmFnZ2FibGU9dHJ1ZV0geyAtbW96LXVzZXItc2VsZWN0OiBub25lOyAta2h0bWwtdXNlci1kcmFnOiBlbGVtZW50OyBjdXJzb3I6IG1vdmU7IH1cXHJcXG4gKjota2h0bWwtZHJhZyB7XFxyXFxuIGJhY2tncm91bmQtY29sb3I6cmdhYigyMzgsIDIzOCwgMjM4LCAwLjUpO1xcclxcbn1cXHJcXG51bC5maWxlbGlzdCBsaS5tb3ZlIHsgLXdlYmtpdC10cmFuc2Zvcm06IHNjYWxlM2QoMS4xLCAxLjEsIDEuMSk7IH1cXHJcXG4jdXBsb2FkZXIgLmZpbGVsaXN0IGxpIHsgdGV4dC1hbGlnbjogY2VudGVyOyBtYXJnaW46IDAgOHB4IDIwcHggMDsgcG9zaXRpb246IHJlbGF0aXZlOyBkaXNwbGF5OiBpbmxpbmU7IGZsb2F0OiBsZWZ0OyBvdmVyZmxvdzogaGlkZGVuOyBmb250LXNpemU6IDEycHg7IH1cXHJcXG51bC5maWxlbGlzdCBsaTpob3ZlciB7IGJvcmRlci1jb2xvcjogIzlhOWZhNDsgYm94LXNoYWRvdzogMCAwIDZweCAwIHJnYmEoMCwgMCwgMCwgMC44NSk7IH1cXHJcXG4jdXBsb2FkZXIgLmZpbGVsaXN0IGxpIHAubG9nIHsgcG9zaXRpb246IHJlbGF0aXZlOyB0b3A6IC00NXB4OyB9XFxyXFxuI3VwbG9hZGVyIC5maWxlbGlzdCBsaSBwLnRpdGxlIHsgXFxyXFxuICAgIHBvc2l0aW9uOiBhYnNvbHV0ZTtcXHJcXG4gICAgYm90dG9tOiAycHg7XFxyXFxuICAgIHdpZHRoOiAxMDAlO1xcclxcbiAgICBvdmVyZmxvdzogaGlkZGVuO1xcclxcbiAgICB3aGl0ZS1zcGFjZTogbm93cmFwO1xcclxcbiAgICB0ZXh0LW92ZXJmbG93OiBlbGxpcHNpcztcXHJcXG4gICAgdGV4dC1hbGlnbjogY2VudGVyO1xcclxcbiAgICBmb250LXNpemU6IDE0cHg7XFxyXFxuICAgIGNvbG9yOiAjMDA1MTkzO1xcclxcbiAgICBmb250LXdlaWdodDogNTAwO1xcclxcbn1cXHJcXG4jdXBsb2FkZXIgLmZpbGVsaXN0IGxpIHAucHJvZ3Jlc3MgeyBwb3NpdGlvbjogYWJzb2x1dGU7IHdpZHRoOiAxMDAlOyBib3R0b206IDA7IGxlZnQ6IDA7IGhlaWdodDogOHB4OyBvdmVyZmxvdzogaGlkZGVuOyB6LWluZGV4OiA1MDsgbWFyZ2luOiAwOyBib3JkZXItcmFkaXVzOiAwOyBiYWNrZ3JvdW5kOiBub25lOyAtd2Via2l0LWJveC1zaGFkb3c6IDAgMCAwOyB9XFxyXFxuI3VwbG9hZGVyIC5maWxlbGlzdCBsaSBwLnByb2dyZXNzIHNwYW4geyBkaXNwbGF5OiBub25lOyBvdmVyZmxvdzogaGlkZGVuOyB3aWR0aDogMDsgaGVpZ2h0OiAxMDAlOyBiYWNrZ3JvdW5kOiAjMTQ4M2Q4IHVybChcIiArIGVzY2FwZShyZXF1aXJlKFwiLi4vaW1hZ2VzL3Byb2dyZXNzLnBuZ1wiKSkgKyBcIikgcmVwZWF0LXg7IC13ZWJpdC10cmFuc2l0aW9uOiB3aWR0aCAyMDBtcyBsaW5lYXI7IC1tb3otdHJhbnNpdGlvbjogd2lkdGggMjAwbXMgbGluZWFyOyAtby10cmFuc2l0aW9uOiB3aWR0aCAyMDBtcyBsaW5lYXI7IC1tcy10cmFuc2l0aW9uOiB3aWR0aCAyMDBtcyBsaW5lYXI7IHRyYW5zaXRpb246IHdpZHRoIDIwMG1zIGxpbmVhcjsgLXdlYmtpdC1hbmltYXRpb246IHByb2dyZXNzbW92ZSAycyBsaW5lYXIgaW5maW5pdGU7IC1tb3otYW5pbWF0aW9uOiBwcm9ncmVzc21vdmUgMnMgbGluZWFyIGluZmluaXRlOyAtby1hbmltYXRpb246IHByb2dyZXNzbW92ZSAycyBsaW5lYXIgaW5maW5pdGU7IC1tcy1hbmltYXRpb246IHByb2dyZXNzbW92ZSAycyBsaW5lYXIgaW5maW5pdGU7IGFuaW1hdGlvbjogcHJvZ3Jlc3Ntb3ZlIDJzIGxpbmVhciBpbmZpbml0ZTsgLXdlYmtpdC10cmFuc2Zvcm06IHRyYW5zbGF0ZVooMCk7IH1cXHJcXG4gQC13ZWJraXQta2V5ZnJhbWVzIHByb2dyZXNzbW92ZSB7XFxyXFxuIDAlIHtcXHJcXG4gYmFja2dyb3VuZC1wb3NpdGlvbjogMCAwO1xcclxcbn1cXHJcXG4gMTAwJSB7XFxyXFxuIGJhY2tncm91bmQtcG9zaXRpb246IDE3cHggMDtcXHJcXG59XFxyXFxufVxcclxcbkAtbW96LWtleWZyYW1lcyBwcm9ncmVzc21vdmUge1xcclxcbiAwJSB7XFxyXFxuIGJhY2tncm91bmQtcG9zaXRpb246IDAgMDtcXHJcXG59XFxyXFxuIDEwMCUge1xcclxcbiBiYWNrZ3JvdW5kLXBvc2l0aW9uOiAxN3B4IDA7XFxyXFxufVxcclxcbn1cXHJcXG5Aa2V5ZnJhbWVzIHByb2dyZXNzbW92ZSB7XFxyXFxuIDAlIHtcXHJcXG4gYmFja2dyb3VuZC1wb3NpdGlvbjogMCAwO1xcclxcbn1cXHJcXG4gMTAwJSB7XFxyXFxuIGJhY2tncm91bmQtcG9zaXRpb246IDE3cHggMDtcXHJcXG59XFxyXFxufVxcclxcbiN1cGxvYWRlciAuZmlsZWxpc3QgbGkge21hcmdpbjo2cHh9XFxyXFxuI3VwbG9hZGVyIC5maWxlbGlzdCBsaSBwLmltZ1dyYXAgeyBwb3NpdGlvbjogcmVsYXRpdmU7IGxpbmUtaGVpZ2h0OiAxMTBweDsgdmVydGljYWwtYWxpZ246IG1pZGRsZTsgb3ZlcmZsb3c6IGhpZGRlbjsgLXdlYmtpdC10cmFuc2Zvcm0tb3JpZ2luOiA1MCUgNTAlOyAtbW96LXRyYW5zZm9ybS1vcmlnaW46IDUwJSA1MCU7IC1vLXRyYW5zZm9ybS1vcmlnaW46IDUwJSA1MCU7IC1tcy10cmFuc2Zvcm0tb3JpZ2luOiA1MCUgNTAlOyB0cmFuc2Zvcm0tb3JpZ2luOiA1MCUgNTAlOyAtd2ViaXQtdHJhbnNpdGlvbjogMjAwbXMgZWFzZS1vdXQ7IC1tb3otdHJhbnNpdGlvbjogMjAwbXMgZWFzZS1vdXQ7IC1vLXRyYW5zaXRpb246IDIwMG1zIGVhc2Utb3V0OyAtbXMtdHJhbnNpdGlvbjogMjAwbXMgZWFzZS1vdXQ7IHRyYW5zaXRpb246IDIwMG1zIGVhc2Utb3V0OyB9XFxyXFxuI3VwbG9hZGVyIC5maWxlbGlzdCBsaSBpbWcgeyB3aWR0aDogMTAwJTsgfVxcclxcbiN1cGxvYWRlciAuZmlsZWxpc3QgbGkgcC5lcnJvciB7IGJhY2tncm91bmQ6ICNmNDM4Mzg7IGNvbG9yOiAjZmZmOyBwb3NpdGlvbjogYWJzb2x1dGU7IGJvdHRvbTogMDsgbGVmdDogMDsgaGVpZ2h0OiAyOHB4OyBsaW5lLWhlaWdodDogMjhweDsgd2lkdGg6IDEwMCU7IHotaW5kZXg6IDEwMDsgfVxcclxcbiN1cGxvYWRlciAuZmlsZWxpc3QgbGkgLnN1Y2Nlc3MgeyBkaXNwbGF5OiBibG9jazsgcG9zaXRpb246IGFic29sdXRlOyBsZWZ0OiAwOyBib3R0b206IDI1cHg7IGhlaWdodDogNDBweDsgd2lkdGg6IDEwMCU7IHotaW5kZXg6IDIwMDsgYmFja2dyb3VuZDogdXJsKFwiICsgZXNjYXBlKHJlcXVpcmUoXCIuLi9pbWFnZXMvc3VjY2Vzcy5wbmdcIikpICsgXCIpIG5vLXJlcGVhdCByaWdodCBib3R0b207IH1cXHJcXG4jdXBsb2FkZXIgLmZpbGVsaXN0IGRpdi5maWxlLXBhbmVsIHsgcG9zaXRpb246IGFic29sdXRlOyBoZWlnaHQ6IDA7ICBmaWx0ZXI6IHByb2dpZDpEWEltYWdlVHJhbnNmb3JtLk1pY3Jvc29mdC5ncmFkaWVudChHcmFkaWVudFR5cGU9MCwgc3RhcnRDb2xvcnN0cj0nIzgwMDAwMDAwJywgZW5kQ29sb3JzdHI9JyM4MDAwMDAwMCcpXFxcXDA7XFxyXFxuYmFja2dyb3VuZDogcmdiYSggMCwgMCwgMCwgMC41ICk7IHdpZHRoOiAxMDAlOyB0b3A6IDA7IGxlZnQ6IDA7IG92ZXJmbG93OiBoaWRkZW47IHotaW5kZXg6IDMwMDsgfVxcclxcbiN1cGxvYWRlciAuZmlsZWxpc3QgZGl2LmZpbGUtcGFuZWwgc3BhbiB7IHdpZHRoOiAyNHB4OyBoZWlnaHQ6IDI0cHg7IGRpc3BsYXk6IGlubGluZTsgZmxvYXQ6IHJpZ2h0OyB0ZXh0LWluZGVudDogLTk5OTlweDsgb3ZlcmZsb3c6IGhpZGRlbjsgYmFja2dyb3VuZDogdXJsKFwiICsgZXNjYXBlKHJlcXVpcmUoXCIuLi9pbWFnZXMvaWNvbnMucG5nXCIpKSArIFwiKSBuby1yZXBlYXQ7IG1hcmdpbjogNXB4IDFweCAxcHg7IGN1cnNvcjogcG9pbnRlcjsgfVxcclxcbiN1cGxvYWRlciAuZmlsZWxpc3QgZGl2LmZpbGUtcGFuZWwgc3Bhbi5yb3RhdGVMZWZ0IHsgYmFja2dyb3VuZC1wb3NpdGlvbjogMCAtMjRweDsgfVxcclxcbiN1cGxvYWRlciAuZmlsZWxpc3QgZGl2LmZpbGUtcGFuZWwgc3Bhbi5yb3RhdGVMZWZ0OmhvdmVyIHsgYmFja2dyb3VuZC1wb3NpdGlvbjogMCAwOyB9XFxyXFxuI3VwbG9hZGVyIC5maWxlbGlzdCBkaXYuZmlsZS1wYW5lbCBzcGFuLnJvdGF0ZVJpZ2h0IHsgYmFja2dyb3VuZC1wb3NpdGlvbjogLTI0cHggLTI0cHg7IH1cXHJcXG4jdXBsb2FkZXIgLmZpbGVsaXN0IGRpdi5maWxlLXBhbmVsIHNwYW4ucm90YXRlUmlnaHQ6aG92ZXIgeyBiYWNrZ3JvdW5kLXBvc2l0aW9uOiAtMjRweCAwOyB9XFxyXFxuI3VwbG9hZGVyIC5maWxlbGlzdCBkaXYuZmlsZS1wYW5lbCBzcGFuLmNhbmNlbCB7IGJhY2tncm91bmQtcG9zaXRpb246IC00OHB4IC0yNHB4OyB9XFxyXFxuI3VwbG9hZGVyIC5maWxlbGlzdCBkaXYuZmlsZS1wYW5lbCBzcGFuLmNhbmNlbDpob3ZlciB7IGJhY2tncm91bmQtcG9zaXRpb246IC00OHB4IDA7IH1cXHJcXG4jdXBsb2FkZXIgLnN0YXR1c0JhciB7ICBib3JkZXItYm90dG9tOiAxcHggc29saWQgI2RhZGFkYTsgcGFkZGluZzogMCAyMHB4OyBsaW5lLWhlaWdodDogNDBweDsgdmVydGljYWwtYWxpZ246IG1pZGRsZTsgcG9zaXRpb246IHJlbGF0aXZlOyB9XFxyXFxuI3VwbG9hZGVyIC5zdGF0dXNCYXIgLnByb2dyZXNzIHsgXFxyXFxuICAgIGJvcmRlcjogMXB4IHNvbGlkICMxNDgzZDg7XFxyXFxuICAgIHdpZHRoOiAxOThweDtcXHJcXG4gICAgYmFja2dyb3VuZDogI2ZmZjtcXHJcXG4gICAgLyogaGVpZ2h0OiAxOHB4OyAqL1xcclxcbiAgICBwb3NpdGlvbjogYWJzb2x1dGU7XFxyXFxuICAgIGRpc3BsYXk6IGlubGluZS1ibG9jaztcXHJcXG4gICAgdGV4dC1hbGlnbjogY2VudGVyO1xcclxcbiAgICBsaW5lLWhlaWdodDogMjBweDtcXHJcXG4gICAgY29sb3I6ICM2ZGJmZmY7XFxyXFxuICAgIHBvc2l0aW9uOiByZWxhdGl2ZTtcXHJcXG4gICAgbWFyZ2luOiA0cHggMTBweCAwIDA7XFxyXFxuICAgIGZsb2F0OiBsZWZ0O1xcclxcbn1cXHJcXG4jdXBsb2FkZXIgLnN0YXR1c0JhciAucHJvZ3Jlc3Mgc3Bhbi5wZXJjZW50YWdlIHsgd2lkdGg6IDA7IGhlaWdodDogMTAwJTsgbGVmdDogMDsgdG9wOiAwOyBiYWNrZ3JvdW5kOiAjMTQ4M2Q4OyBwb3NpdGlvbjogYWJzb2x1dGU7IH1cXHJcXG4jdXBsb2FkZXIgLnN0YXR1c0JhciAucHJvZ3Jlc3Mgc3Bhbi50ZXh0IHsgcG9zaXRpb246IHJlbGF0aXZlOyB6LWluZGV4OiAxMDsgfVxcclxcbiN1cGxvYWRlciAuc3RhdHVzQmFyIC5pbmZvIHsgZGlzcGxheTogaW5saW5lLWJsb2NrOyBmb250LXNpemU6IDE0cHg7IGNvbG9yOiAjNjY2NjY2O2Zsb2F0OiBsZWZ0IH1cXHJcXG4jdXBsb2FkZXIgLnN0YXR1c0JhciAuYnRucyB7IHBvc2l0aW9uOiBhYnNvbHV0ZTsgdG9wOiAwcHg7IHJpZ2h0OiAyMHB4OyBsaW5lLWhlaWdodDogMzBweDsgfVxcclxcbiNmaWxlUGlja2VyMiB7IGRpc3BsYXk6IGlubGluZS1ibG9jazsgZmxvYXQ6IGxlZnQ7IH1cXHJcXG4jdXBsb2FkZXIgLnN0YXR1c0JhciAuYnRucyAud2VidXBsb2FkZXItcGljaywgI3VwbG9hZGVyIC5zdGF0dXNCYXIgLmJ0bnMgLnVwbG9hZEJ0biwgI3VwbG9hZGVyIC5zdGF0dXNCYXIgLmJ0bnMgLnVwbG9hZEJ0bi5zdGF0ZS11cGxvYWRpbmcsICN1cGxvYWRlciAuc3RhdHVzQmFyIC5idG5zIC51cGxvYWRCdG4uc3RhdGUtcGF1c2VkIHsgYmFja2dyb3VuZDogI2ZmZmZmZjsgYm9yZGVyOiAxcHggc29saWQgI2NmY2ZjZjsgY29sb3I6ICM1NjU2NTY7IHBhZGRpbmc6IDAgMThweDsgZGlzcGxheTogaW5saW5lLWJsb2NrOyBib3JkZXItcmFkaXVzOiAzcHg7IG1hcmdpbi1sZWZ0OiAxMHB4OyBjdXJzb3I6IHBvaW50ZXI7IGZvbnQtc2l6ZTogMTRweDsgZmxvYXQ6IGxlZnQ7IH1cXHJcXG4jdXBsb2FkZXIgLnN0YXR1c0JhciAuYnRucyAud2VidXBsb2FkZXItcGljay1ob3ZlciwgI3VwbG9hZGVyIC5zdGF0dXNCYXIgLmJ0bnMgLnVwbG9hZEJ0bjpob3ZlciwgI3VwbG9hZGVyIC5zdGF0dXNCYXIgLmJ0bnMgLnVwbG9hZEJ0bi5zdGF0ZS11cGxvYWRpbmc6aG92ZXIsICN1cGxvYWRlciAuc3RhdHVzQmFyIC5idG5zIC51cGxvYWRCdG4uc3RhdGUtcGF1c2VkOmhvdmVyIHsgYmFja2dyb3VuZDogI2YwZjBmMDsgfVxcclxcbiN1cGxvYWRlciAuc3RhdHVzQmFyIC5idG5zIC51cGxvYWRCdG4geyBiYWNrZ3JvdW5kOiAjMDBiN2VlOyBjb2xvcjogI2ZmZjsgYm9yZGVyLWNvbG9yOiB0cmFuc3BhcmVudDsgfVxcclxcbiN1cGxvYWRlciAuc3RhdHVzQmFyIC5idG5zIC51cGxvYWRCdG46aG92ZXIgeyBiYWNrZ3JvdW5kOiAjMDBhMmQ0OyB9XFxyXFxuI3VwbG9hZGVyIC5zdGF0dXNCYXIgLmJ0bnMgLnVwbG9hZEJ0bi5kaXNhYmxlZCB7IHBvaW50ZXItZXZlbnRzOiBub25lOyBvcGFjaXR5OiAwLjY7IH1cXHJcXG5cIiwgXCJcIl0pO1xuXG4vLyBleHBvcnRzXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyIS4vc3JjL2NvbXBvbmVudHMvd2VidXBsb2FkZXIvY3NzL2RlbW8uY3NzXG4vLyBtb2R1bGUgaWQgPSA1NlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///56\n");

/***/ }),
/* 57 */
/***/ (function(module, exports) {

eval("module.exports = \"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAFgAAABLCAIAAAB7tddWAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAyRpVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuMy1jMDExIDY2LjE0NTY2MSwgMjAxMi8wMi8wNi0xNDo1NjoyNyAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvIiB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIgeG1sbnM6c3RSZWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZVJlZiMiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIENTNiAoTWFjaW50b3NoKSIgeG1wTU06SW5zdGFuY2VJRD0ieG1wLmlpZDo1Q0VBNzA0MjEyMDUxMUUzODk2Q0JFM0Q1RjE4QkExQyIgeG1wTU06RG9jdW1lbnRJRD0ieG1wLmRpZDo1Q0VBNzA0MzEyMDUxMUUzODk2Q0JFM0Q1RjE4QkExQyI+IDx4bXBNTTpEZXJpdmVkRnJvbSBzdFJlZjppbnN0YW5jZUlEPSJ4bXAuaWlkOjAzNDA2MkY1MTIwMzExRTM4OTZDQkUzRDVGMThCQTFDIiBzdFJlZjpkb2N1bWVudElEPSJ4bXAuZGlkOjAzNDA2MkY2MTIwMzExRTM4OTZDQkUzRDVGMThCQTFDIi8+IDwvcmRmOkRlc2NyaXB0aW9uPiA8L3JkZjpSREY+IDwveDp4bXBtZXRhPiA8P3hwYWNrZXQgZW5kPSJyIj8+K6izdgAAAvpJREFUeNrsnFmPqkAQhWmX667gEp9c/v+/MkSDG+4LrvdcSYgRbw/0ALZQ9WBUJOn+uqvqHGCG3e93hUJRUoSAQBAIAkEgCASBIBAE4neRicEcII51Xb/dbnjPGOt0OqlUKok7ApN3jIKwY6DUIBAEgkAQCALho/X47TeXy8U0TcuyrtdrZKPs9/v2m8FgINYgf9QX/gTV+Xw2DCNKBJKmxmKxsAVc0kEcDgfyGq8CNp/Pa5qWy+WiHG6v13v7/XPt6Ha7Al5D3HQ1Go1sNkvtU8lkMsmtESSoCASBSFqEW/DQ0tbr9W63O51OKK6FQkFV1XQ6nSwQ0OOTyQSvjknZbDaA0mq1QCQafSFFasxmM4eCE1Do0+lUQrcSFggsPhzq20NgsVqtkpIax+MxMs+C/aXruvMxaonND75J9W5hUWWxuYAVdRfTg8EplUphGJywQPAFuBd5Dlhw/aDwwgVtCDgCdzph1QisG+dosVjkn44WYxjGC4XnvBuNRtvt9gtA2Hv47SGsZKVS4ef8eDzG4vMVCrpSgEU3xPbZbDar1erLl1AQ7XabU8xAAXvB3XffBnIHwkR2QcUYq9fr5XIZOxkTg6BEkeNLKdQF7AWPFBy1AoUmu8RG/HmE91nxM+J/ORIr07VcLvf7feCt+stAQGIBRNJtOJolDAhdj/hXGj5+u+TzIKAF+MbkK00XFta2BhDRUE0/9gv8Elogbu4TBW8+nyPhHSeuaVqtVuNQC6TzyQUCXsg0TbfyAxfIKogr9ynP1GJyYQZ57qbg7AuIRfclKZwSlDqWBQSmxM9zFALYh+fFBwJJSkNgqeFxSrAPw+EQ9QJew7Is2Sj8FgSW2nu1gylYPkKRMsRTA+4IcjA2fxsnDkLOq/IfACFP54uP1yAQBIJAEIh4gWCPkHk+GJ7AjU/fICJ+qlIghEfoDwQMtRjvyLYDRih4rsDT+bBM9tP5kuhrzN++e6SqqvCdYUb/SIO6BoEgEASCQBAIAkEgCEQg8VeAAQAB1bbO2qoeewAAAABJRU5ErkJggg==\"\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvY29tcG9uZW50cy93ZWJ1cGxvYWRlci9pbWFnZXMvaW1hZ2UucG5nP2E5YjMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEsaUNBQWlDIiwiZmlsZSI6IjU3LmpzIiwic291cmNlc0NvbnRlbnQiOlsibW9kdWxlLmV4cG9ydHMgPSBcImRhdGE6aW1hZ2UvcG5nO2Jhc2U2NCxpVkJPUncwS0dnb0FBQUFOU1VoRVVnQUFBRmdBQUFCTENBSUFBQUI3dGRkV0FBQUFHWFJGV0hSVGIyWjBkMkZ5WlFCQlpHOWlaU0JKYldGblpWSmxZV1I1Y2NsbFBBQUFBeVJwVkZoMFdFMU1PbU52YlM1aFpHOWlaUzU0YlhBQUFBQUFBRHcvZUhCaFkydGxkQ0JpWldkcGJqMGk3N3UvSWlCcFpEMGlWelZOTUUxd1EyVm9hVWg2Y21WVGVrNVVZM3ByWXpsa0lqOCtJRHg0T25odGNHMWxkR0VnZUcxc2JuTTZlRDBpWVdSdlltVTZibk02YldWMFlTOGlJSGc2ZUcxd2RHczlJa0ZrYjJKbElGaE5VQ0JEYjNKbElEVXVNeTFqTURFeElEWTJMakUwTlRZMk1Td2dNakF4TWk4d01pOHdOaTB4TkRvMU5qb3lOeUFnSUNBZ0lDQWdJajRnUEhKa1pqcFNSRVlnZUcxc2JuTTZjbVJtUFNKb2RIUndPaTh2ZDNkM0xuY3pMbTl5Wnk4eE9UazVMekF5THpJeUxYSmtaaTF6ZVc1MFlYZ3Ribk1qSWo0Z1BISmtaanBFWlhOamNtbHdkR2x2YmlCeVpHWTZZV0p2ZFhROUlpSWdlRzFzYm5NNmVHMXdQU0pvZEhSd09pOHZibk11WVdSdlltVXVZMjl0TDNoaGNDOHhMakF2SWlCNGJXeHVjenA0YlhCTlRUMGlhSFIwY0RvdkwyNXpMbUZrYjJKbExtTnZiUzk0WVhBdk1TNHdMMjF0THlJZ2VHMXNibk02YzNSU1pXWTlJbWgwZEhBNkx5OXVjeTVoWkc5aVpTNWpiMjB2ZUdGd0x6RXVNQzl6Vkhsd1pTOVNaWE52ZFhKalpWSmxaaU1pSUhodGNEcERjbVZoZEc5eVZHOXZiRDBpUVdSdlltVWdVR2h2ZEc5emFHOXdJRU5UTmlBb1RXRmphVzUwYjNOb0tTSWdlRzF3VFUwNlNXNXpkR0Z1WTJWSlJEMGllRzF3TG1scFpEbzFRMFZCTnpBME1qRXlNRFV4TVVVek9EazJRMEpGTTBRMVJqRTRRa0V4UXlJZ2VHMXdUVTA2Ukc5amRXMWxiblJKUkQwaWVHMXdMbVJwWkRvMVEwVkJOekEwTXpFeU1EVXhNVVV6T0RrMlEwSkZNMFExUmpFNFFrRXhReUkrSUR4NGJYQk5UVHBFWlhKcGRtVmtSbkp2YlNCemRGSmxaanBwYm5OMFlXNWpaVWxFUFNKNGJYQXVhV2xrT2pBek5EQTJNa1kxTVRJd016RXhSVE00T1RaRFFrVXpSRFZHTVRoQ1FURkRJaUJ6ZEZKbFpqcGtiMk4xYldWdWRFbEVQU0o0YlhBdVpHbGtPakF6TkRBMk1rWTJNVEl3TXpFeFJUTTRPVFpEUWtVelJEVkdNVGhDUVRGRElpOCtJRHd2Y21SbU9rUmxjMk55YVhCMGFXOXVQaUE4TDNKa1pqcFNSRVkrSUR3dmVEcDRiWEJ0WlhSaFBpQThQM2h3WVdOclpYUWdaVzVrUFNKeUlqOCtLNml6ZGdBQUF2cEpSRUZVZU5yc25GbVBxa0FRaFdtWDY2N2dFcDljL3YrL01rU0RHKzRMcnZkY1NZZ1Jidy8wQUxaUTlXQlVKT24rdXF2cUhHQ0czZTkzaFVKUlVvU0FRQkFJQWtFZ0NBU0JJQkFFNG5lUmljRWNJSTUxWGIvZGJualBHT3QwT3FsVUtvazdBcE4zaklLd1k2RFVJQkFFZ2tBUUNBTGhvL1g0N1RlWHk4VTBUY3V5cnRkclpLUHM5L3YybThGZ0lOWWdmOVFYL2dUVitYdzJEQ05LQkpLbXhtS3hzQVZjMGtFY0RnZnlHcThDTnAvUGE1cVd5K1dpSEc2djEzdjcvWFB0NkhhN0FsNUQzSFExR28xc05rdnRVOGxrTXNtdEVTU29DQVNCU0ZxRVcvRFEwdGJyOVc2M081MU9LSzZGUWtGVjFYUTZuU3dRME9PVHlRU3Zqa25aYkRhQTBtcTFRQ1FhZlNGRmFzeG1NNGVDRTFEbzArbFVRcmNTRmdnc1BoenEyME5nc1ZxdGtwSWF4K014TXMrQy9hWHJ1dk14YW9uTkQ3NUo5VzVoVVdXeHVZQVZkUmZUZzhFcGxVcGhHSnl3UVBBRnVCZDVEbGh3L2FEd3dnVnRDRGdDZHpwaDFRaXNHK2Rvc1Zqa240NFdZeGpHQzRYbnZCdU5SdHZ0OWd0QTJIdjQ3U0dzWktWUzRlZjhlRHpHNHZNVkNycFNnRVUzeFBiWmJEYXIxZXJMbDFBUTdYYWJVOHhBQVh2QjNYZmZCbklId2tSMlFjVVlxOWZyNVhJWk94a1RnNkJFa2VOTEtkUUY3QVdQRkJ5MUFvVW11OFJHL0htRTkxbnhNK0ovT1JJcjA3VmNMdmY3ZmVDdCtzdEFRR0lCUk5KdE9Kb2xEQWhkai9oWEdqNSt1K1R6SUtBRitNYmtLMDBYRnRhMkJoRFJVRTAvOWd2OEVsb2didTRUQlc4K255UGhIU2V1YVZxdFZ1TlFDNlR6eVFVQ1hzZzBUYmZ5QXhmSUtvZ3I5eW5QMUdKeVlRWjU3cWJnN0F1SVJmY2xLWndTbERxV0JRU214TTl6RkFMWWgrZkZCd0pKU2tOZ3FlRnhTckFQdytFUTlRSmV3N0lzMlNqOEZnU1cybnUxZ3lsWVBrS1JNc1JUQSs0SWNqQTJmeHNuRGtMT3EvSWZBQ0ZQNTR1UDF5QVFCSUpBRUloNGdXQ1BrSGsrR0o3QWpVL2ZJQ0orcWxJZ2hFZm9Ed1FNdFJqdnlMWURSaWg0cnNEVCtiQk05dFA1a3VocnpOKytlNlNxcXZDZFlVYi9TSU82Qm9FZ0VBU0NRQkFJQWtFZ0NFUWc4VmVBQVFBQjFiYk8ycW9lZXdBQUFBQkpSVTVFcmtKZ2dnPT1cIlxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vc3JjL2NvbXBvbmVudHMvd2VidXBsb2FkZXIvaW1hZ2VzL2ltYWdlLnBuZ1xuLy8gbW9kdWxlIGlkID0gNTdcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///57\n");

/***/ }),
/* 58 */
/***/ (function(module, exports) {

eval("module.exports = \"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABkAAAAZCAYAAADE6YVjAAABlElEQVR42rWWO0sDQRRGk8Yi5KHiRixEsdHORnsbLcTSX2Bvm0ZiwCIg2piN8Y2vQiTRwsI0gopiYaOgIoIKIiSFLySNe3c3nzPGiELczCazA18zxT1799wL43I5duCumdQ6/LGPDecYUSieKS0cULVXZwCxnOKNaaN+VcsG4pSXD4jA72UdcEBtnMAjneEpAF5YB6Z8yDh8HFAs/DvSJTsDieYYQA/7VC3DJcuHlJAsHVJKsjyIhWQ5kDKSq4cISFamCV3rhNaFSiCCknuThLVLHT2bFUBEJAdZF7t3BpYvDLQt2oEISlYShMgx4fbNQP+WHSclJNfHC/+cp3hXxzKwTbh6MhlIR2NCFPKP5CArEDrQkb43MLhDaJohtC8RVpiH1I3xR7g1xEIy/+pu1sXsOeE0YyB0qGPkiLD/YKAvZWOERSQ3zxGG9wjXzyYe302MnehfXZWH2NzkBjZNQ2lC4kxH56rIMk7kgnY3ueioZb4wEBYQuLlkr2q9ydXExZ8tXDIrnpVd/AfC30XfkvNOQT4B2PR5xfoTnbwAAAAASUVORK5CYII=\"\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvY29tcG9uZW50cy93ZWJ1cGxvYWRlci9pbWFnZXMvc3VjY2Vzcy5wbmc/YzNlNyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSxpQ0FBaUMiLCJmaWxlIjoiNTguanMiLCJzb3VyY2VzQ29udGVudCI6WyJtb2R1bGUuZXhwb3J0cyA9IFwiZGF0YTppbWFnZS9wbmc7YmFzZTY0LGlWQk9SdzBLR2dvQUFBQU5TVWhFVWdBQUFCa0FBQUFaQ0FZQUFBREU2WVZqQUFBQmxFbEVRVlI0MnJXV08wc0RRUlJHazhZaTVLSGlSaXhFc2RIT1Juc2JMY1RTWDJCdm0wWml3Q0lnMnBpTjhZMnZRaVRSd3NJMGdvcGlZYU9nSW9JS0lpU0ZMeVNOZTNjM256UEdpRUxjekNhekExOHp4VDE3OTl3TDQzSTVkdUN1bWRRNi9MR1BEZWNZVVNpZUtTMGNVTFZYWndDeG5PS05hYU4rVmNzRzRwU1hENGpBNzJVZGNFQnRuTUFqbmVFcEFGNVlCNlo4eURoOEhGQXMvRHZTSlRzRGllWVlRQS83VkMzREpjdUhsSkFzSFZKS3NqeUloV1E1a0RLU3E0Y0lTRmFtQ1YzcmhOYUZTaUNDa251VGhMVkxIVDJiRlVCRUpBZFpGN3QzQnBZdkRMUXQyb0VJU2xZU2hNZ3g0ZmJOUVArV0hTY2xKTmZIQy8rY3AzaFh4ekt3VGJoNk1obElSMk5DRlBLUDVDQXJFRHJRa2I0M01MaERhSm9odEM4UlZwaUgxSTN4UjdnMXhFSXkvK3B1MXNYc09lRTBZeUIwcUdQa2lMRC9ZS0F2WldPRVJTUTN6eEdHOXdqWHp5WWUzMDJNbmVoZlhaV0gyTnprQmpaTlEybEM0a3hINTZySU1rN2tnblkzdWVpb1piNHdFQllRdUxsa3IycTl5ZFhFeFo4dFhESXJucFZkL0FmQzMwWGZrdk5PUVQ0QjJQUjV4Zm9UbmJ3QUFBQUFTVVZPUks1Q1lJST1cIlxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vc3JjL2NvbXBvbmVudHMvd2VidXBsb2FkZXIvaW1hZ2VzL3N1Y2Nlc3MucG5nXG4vLyBtb2R1bGUgaWQgPSA1OFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///58\n");

/***/ }),
/* 59 */
/***/ (function(module, exports) {

eval("module.exports = \"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAEEAAAAoCAYAAAChDJfXAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAA2hpVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuMy1jMDExIDY2LjE0NTY2MSwgMjAxMi8wMi8wNi0xNDo1NjoyNyAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wTU09Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9tbS8iIHhtbG5zOnN0UmVmPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvc1R5cGUvUmVzb3VyY2VSZWYjIiB4bWxuczp4bXA9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC8iIHhtcE1NOk9yaWdpbmFsRG9jdW1lbnRJRD0ieG1wLmRpZDowMTgwMTE3NDA3MjA2ODExODIyQTg3ODcxNkNBOEMyQSIgeG1wTU06RG9jdW1lbnRJRD0ieG1wLmRpZDowNjYxRTBFRjI5MDUxMUUzOERBNkExNjY3QTI5NkMyNyIgeG1wTU06SW5zdGFuY2VJRD0ieG1wLmlpZDowNjYxRTBFRTI5MDUxMUUzOERBNkExNjY3QTI5NkMyNyIgeG1wOkNyZWF0b3JUb29sPSJBZG9iZSBQaG90b3Nob3AgQ1M2IChNYWNpbnRvc2gpIj4gPHhtcE1NOkRlcml2ZWRGcm9tIHN0UmVmOmluc3RhbmNlSUQ9InhtcC5paWQ6NjhDREVCQjAyNjIwNjgxMTgyMkE4Nzg3MTZDQThDMkEiIHN0UmVmOmRvY3VtZW50SUQ9InhtcC5kaWQ6MDE4MDExNzQwNzIwNjgxMTgyMkE4Nzg3MTZDQThDMkEiLz4gPC9yZGY6RGVzY3Jp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\"\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvY29tcG9uZW50cy93ZWJ1cGxvYWRlci9pbWFnZXMvaWNvbnMucG5nPzgwODQiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEsaUNBQWlDIiwiZmlsZSI6IjU5LmpzIiwic291cmNlc0NvbnRlbnQiOlsibW9kdWxlLmV4cG9ydHMgPSBcImRhdGE6aW1hZ2UvcG5nO2Jhc2U2NCxpVkJPUncwS0dnb0FBQUFOU1VoRVVnQUFBRUVBQUFBb0NBWUFBQUNoREpmWEFBQUFHWFJGV0hSVGIyWjBkMkZ5WlFCQlpHOWlaU0JKYldGblpWSmxZV1I1Y2NsbFBBQUFBMmhwVkZoMFdFMU1PbU52YlM1aFpHOWlaUzU0YlhBQUFBQUFBRHcvZUhCaFkydGxkQ0JpWldkcGJqMGk3N3UvSWlCcFpEMGlWelZOTUUxd1EyVm9hVWg2Y21WVGVrNVVZM3ByWXpsa0lqOCtJRHg0T25odGNHMWxkR0VnZUcxc2JuTTZlRDBpWVdSdlltVTZibk02YldWMFlTOGlJSGc2ZUcxd2RHczlJa0ZrYjJKbElGaE5VQ0JEYjNKbElEVXVNeTFqTURFeElEWTJMakUwTlRZMk1Td2dNakF4TWk4d01pOHdOaTB4TkRvMU5qb3lOeUFnSUNBZ0lDQWdJajRnUEhKa1pqcFNSRVlnZUcxc2JuTTZjbVJtUFNKb2RIUndPaTh2ZDNkM0xuY3pMbTl5Wnk4eE9UazVMekF5THpJeUxYSmtaaTF6ZVc1MFlYZ3Ribk1qSWo0Z1BISmtaanBFWlhOamNtbHdkR2x2YmlCeVpHWTZZV0p2ZFhROUlpSWdlRzFzYm5NNmVHMXdUVTA5SW1oMGRIQTZMeTl1Y3k1aFpHOWlaUzVqYjIwdmVHRndMekV1TUM5dGJTOGlJSGh0Ykc1ek9uTjBVbVZtUFNKb2RIUndPaTh2Ym5NdVlXUnZZbVV1WTI5dEwzaGhjQzh4TGpBdmMxUjVjR1V2VW1WemIzVnlZMlZTWldZaklpQjRiV3h1Y3pwNGJYQTlJbWgwZEhBNkx5OXVjeTVoWkc5aVpTNWpiMjB2ZUdGd0x6RXVNQzhpSUhodGNFMU5Pazl5YVdkcGJtRnNSRzlqZFcxbGJuUkpSRDBpZUcxd0xtUnBaRG93TVRnd01URTNOREEzTWpBMk9ERXhPREl5UVRnM09EY3hOa05CT0VNeVFTSWdlRzF3VFUwNlJHOWpkVzFsYm5SSlJEMGllRzF3TG1ScFpEb3dOall4UlRCRlJqSTVNRFV4TVVVek9FUkJOa0V4TmpZM1FUSTVOa015TnlJZ2VHMXdUVTA2U1c1emRHRnVZMlZKUkQwaWVHMXdMbWxwWkRvd05qWXhSVEJGUlRJNU1EVXhNVVV6T0VSQk5rRXhOalkzUVRJNU5rTXlOeUlnZUcxd09rTnlaV0YwYjNKVWIyOXNQU0pCWkc5aVpTQlFhRzkwYjNOb2IzQWdRMU0ySUNoTllXTnBiblJ2YzJncElqNGdQSGh0Y0UxTk9rUmxjbWwyWldSR2NtOXRJSE4wVW1WbU9tbHVjM1JoYm1ObFNVUTlJbmh0Y0M1cGFXUTZOamhEUkVWQ1FqQXlOakl3TmpneE1UZ3lNa0U0TnpnM01UWkRRVGhETWtFaUlITjBVbVZtT21SdlkzVnRaVzUwU1VROUluaHRjQzVrYVdRNk1ERTRNREV4TnpRd056SXdOamd4TVRneU1rRTROemczTVRaRFFUaERNa0VpTHo0Z1BDOXlaR1k2UkdWelkzSnBjSFJwYjI0K0lEd3ZjbVJtT2xKRVJqNGdQQzk0T25odGNHMWxkR0UrSUR3L2VIQmhZMnRsZENCbGJtUTlJbklpUHo3ZkIvdHNBQUFHcEVsRVFWUjQydXhaYTB3Y1ZSUyt1K3l5Z0NEdE5oRkkycVJncW0wMEd6ZEZheG90b2dSc2JBd1M2d05TSTBxc3JVRVRFL3dCUVVObys0Y2ZUY28vUWlXaE5sYmI5RWtrRktocHRScE15UktpRVNXbFRWcE1HeFY1TG0vVzd4dnZyTU13N0E2N3NDVzZKem1ablpuenVQdmRlOCtjbWMrUzN6b21JRzZvNTJ4TmpkaGRYaTZzVnF1SWlZa1Jxc3pPem9xNXVUblIxdFltc3JLeXhNek1qR2c2ZkZpNTUydjVSS3lFdk5UbWRaL0pTZkNJQ0lndExpNk94L2FKaVlsY0hMdWdiME5maHVabzdLNUFUMEhyb0pQaEpuM2w4dlIrQVAwcWdONmhBYm9OUUo4NmVlalEwZnl5c3Njd3JvdTQ3QXdXeTVKWEpWNnJyRlFtVHAwd3lDWEV6dGJiNHQ3WE9EeXJUakFuOXZPbnJNSlNlTlduVENndS9JWGo3d2oyMEdJSllYTVRZQlZnSlhoQ1dRbTdtb2N5RWhNVEc3Ui8zaURIenppa1loeHJqMjhYbHFXQ0lNVVh5RVdUU3dIQjc4bWtCQUEzZnB1ZW5uNS9hR2pvUVRvTURBeHN3UGxidUg0ZDl6ZGlocjdCOVUyaExPK2twS1J1QXNCWWpNblkvS1BNeFp6TWpSeGJPSmFsckdib3FQemp2aUFBQ0ozZEtFQzBXUTJNRWpIVFA4VEd4dmFOajQvei9EYTB3ZVB4dUxDY3ptS0E5MEVhWlhKVHNybTJNd0hnbmFNdll6RFdsMW4yaHVaZFRzWVdUVHVUK3dEQzk4d2R3dTZhOGZsOFp3RGc5RktjYUErL1UxakpNd3RBd0VEdmR6Z2MzSS9iZExlOFhWMWRSVnl1bU0wblVVRDNzWWlhRVpmTDlRN2licUF2WS9TVWJ2VnE3eGUwajI4RFNPM01IV0taMllQWXNWQ0xYTzRCbFhhMHgrODNoV1kyTFNhVGViRktEbUtWZklZQkYzNXg0RUN0eUFwZUUyaXJUQmw4OVFCUVRqOFgzNEZEY2toRnRxSkNZRWI1OHlDMERHbzM0Y1pWVXdPL0NtVjhaaEwxOWZVSkZEUkZiOXk0Y1Y1QnpXTFphbVpMY005Slc3L3ZjZ29Mb3RReXFOMmtqMTNhLzNNK05UWGxyNVQ5L2YwTEladGVzTlZHWUR2QlFGa2xKVUZuanphd3RkTG5XdkhESXlzSWdoK0F3Y0hCamNqM0krclBWYzREanppL0piZkNMUTBRd25BbEVBZythMWtVNCtQampmSW13VG1PaGVWeWZmMVFzRUhTQnJaejlNbHMrQ1ZKUkZoazMrQ2ZhRU1nelFUS3lNZ1FvNk9qeXJaSVQwOS9RWG5PK0h5ZDNPYkJmRmw5WlJQbTkxMXRRaENLNURQekRuUmRFSHVIeldhcmtLZ2VNL3Qwd0d3Y1U2cXd6ZmF4czdMWkVjajJtWlA5NjE3L2R1NU8wWGZDaDg3eWpVaUJjQnlEL0FyTE5TVTFOZlYwQUNBU2NuTnpUOER1VWU0eHRMZDFVR0d5c0I3bFhtUWp4QmpzR3hZRGdHUGdXTmhHbzVkb2pBZ0lYT2JvMlBaaWtIK3dtMHRMUytOTFN5bDB2YlI1QUZyc2Ryczl1SjhQdStHeHNiRmlNMXRCRlJiRXljbkozU3lPak1GWW1PWGluRE4zR1Z2c2JCcFlqL05TNXBZZDVUREdWTHdjZjFEN0lxaHJyZjk5Z2oxLzRVOGhsK29tUEFMWjFXMEowR1ZkUjhFc3dDeDFoL0x1OEdMTHlPYUVoSVJHRE96eEFEbCs5WHE5QmVkeUUzOHlFeE5iUi8wNXp1SzdoSTV4QW9mNGVlOE9rTjRUMWRVdTl2VDRreTNTU0drdnVUUngvZDJXbHBaSGNLazcxRms1bjVmVWMrTHBtQ2NRNnozRXZLS3JHMm9PbDFrQTFPb3Y5U091WnBNQTNLVzkrdVN3eUc3cmZ5MVdFWlVvQ0ZFUW9pQkVRWWlDRUFYQkNBUjBad0xxNXJHcXFrcjVmcUI5L1ZRYkVsNXZibTZtclJnZUhsWnNxY0drczdOVFVmcWhGZmJIV2l3SFkyckhGQkVReUR2dyt4NStaOG92Ulh1aHJXTCtWOW5MOG4zQ3NVeDU5OHVZMmh5dE1qZkhrTWt4U1U0a29CQTA3WGNDMlQxZTBzVldsTmYxM3hmb2I1TXZGV3RKZGxSV1ZocnlEbnlwb2VibDVYMUkzZ0dYUW1XR01xQU5kcnQ5aDBHT0hDckc4SUdRdkVNWUwwelppOXpMRGxnVFZwcDNnQmp5RHN4eEwza0gra2VFZCtDM0NEM3Z3SmlNelJ6TWRhOTRCL3JiREQ1Y0tyd0Qzdi9KVFhab2JpbThnOXZ0dmtiZW9ieThmQit1MVFaTDVuTHgvNHA1dkFOajZjeklPMXdNazNmWUUraWJnUTRBUlMwV3k3enRvQ2Nva25VQStJRWdkeUNURlI0eThXV0pObHJld1FBQUlYTWxHNHdqcUZUTTV4Mm1qQXFpZ2RMdUlQM292K0s4QTIyMHZJTWFoekdYNWZFV0p1K2dhRGk4UTRrSjNxRkV3enZRTjBoc1pRenFJOC9vZmdBUVF1SWRGRFVhaEZuZW9kNEU3MUN2NFIzb3E3L1BITXpGbkVhVEVLNnNDdDVCMnZoNUI4WmdMTVpjVGU4T0lmTU81U1o0Qjlwb2VRY1RYZWM2T1JhT2FYWHpEcWo2ZFdhZURweDVQZS9BV0lzQm9PVWRjUDdmNFIxWUVQVzhBMlBLMkVMbVdzQTdqSXlFejkrYTRSM1VSOXh0Z0xGZDVSMmdSNXhPNXhIZVNFbEowUllXaFhmQXo5NFF4dE1COE53cTc0QWNuNnF4a1V1YlErRWRaS2RxcXZHUk1xSHlEbXZXckxtcGJaTTFRUGhVSUZSS1FWOFllNnRYbUhlQTlFQ0Q4ZzQ0alJqdlFQMWJnQUVBYVBISks4NG5rRFlBQUFBQVNVVk9SSzVDWUlJPVwiXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9zcmMvY29tcG9uZW50cy93ZWJ1cGxvYWRlci9pbWFnZXMvaWNvbnMucG5nXG4vLyBtb2R1bGUgaWQgPSA1OVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///59\n");

/***/ }),
/* 60 */
/***/ (function(module, exports, __webpack_require__) {

eval("// style-loader: Adds some css to the DOM by adding a <style> tag\n\n// load the styles\nvar content = __webpack_require__(61);\nif(typeof content === 'string') content = [[module.i, content, '']];\nif(content.locals) module.exports = content.locals;\n// add the styles to the DOM\nvar update = __webpack_require__(10)(\"291e5d25\", content, false, {});\n// Hot Module Replacement\nif(false) {\n // When the styles change, update the <style> tags\n if(!content.locals) {\n   module.hot.accept(\"!!../../../../node_modules/css-loader/index.js!./style.css\", function() {\n     var newContent = require(\"!!../../../../node_modules/css-loader/index.js!./style.css\");\n     if(typeof newContent === 'string') newContent = [[module.id, newContent, '']];\n     update(newContent);\n   });\n }\n // When the module is disposed, remove the <style> tags\n module.hot.dispose(function() { update(); });\n}\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvY29tcG9uZW50cy93ZWJ1cGxvYWRlci9jc3Mvc3R5bGUuY3NzPzJiODYiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7O0FBRUE7QUFDQSxjQUFjLG1CQUFPLENBQUMsRUFBNEQ7QUFDbEYsNENBQTRDLFFBQVM7QUFDckQ7QUFDQTtBQUNBLGFBQWEsbUJBQU8sQ0FBQyxFQUFtRSxnQ0FBZ0M7QUFDeEg7QUFDQSxHQUFHLEtBQVU7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLGdDQUFnQyxVQUFVLEVBQUU7QUFDNUMiLCJmaWxlIjoiNjAuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvLyBzdHlsZS1sb2FkZXI6IEFkZHMgc29tZSBjc3MgdG8gdGhlIERPTSBieSBhZGRpbmcgYSA8c3R5bGU+IHRhZ1xuXG4vLyBsb2FkIHRoZSBzdHlsZXNcbnZhciBjb250ZW50ID0gcmVxdWlyZShcIiEhLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvaW5kZXguanMhLi9zdHlsZS5jc3NcIik7XG5pZih0eXBlb2YgY29udGVudCA9PT0gJ3N0cmluZycpIGNvbnRlbnQgPSBbW21vZHVsZS5pZCwgY29udGVudCwgJyddXTtcbmlmKGNvbnRlbnQubG9jYWxzKSBtb2R1bGUuZXhwb3J0cyA9IGNvbnRlbnQubG9jYWxzO1xuLy8gYWRkIHRoZSBzdHlsZXMgdG8gdGhlIERPTVxudmFyIHVwZGF0ZSA9IHJlcXVpcmUoXCIhLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZS1zdHlsZS1sb2FkZXIvbGliL2FkZFN0eWxlc0NsaWVudC5qc1wiKShcIjI5MWU1ZDI1XCIsIGNvbnRlbnQsIGZhbHNlLCB7fSk7XG4vLyBIb3QgTW9kdWxlIFJlcGxhY2VtZW50XG5pZihtb2R1bGUuaG90KSB7XG4gLy8gV2hlbiB0aGUgc3R5bGVzIGNoYW5nZSwgdXBkYXRlIHRoZSA8c3R5bGU+IHRhZ3NcbiBpZighY29udGVudC5sb2NhbHMpIHtcbiAgIG1vZHVsZS5ob3QuYWNjZXB0KFwiISEuLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9pbmRleC5qcyEuL3N0eWxlLmNzc1wiLCBmdW5jdGlvbigpIHtcbiAgICAgdmFyIG5ld0NvbnRlbnQgPSByZXF1aXJlKFwiISEuLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9pbmRleC5qcyEuL3N0eWxlLmNzc1wiKTtcbiAgICAgaWYodHlwZW9mIG5ld0NvbnRlbnQgPT09ICdzdHJpbmcnKSBuZXdDb250ZW50ID0gW1ttb2R1bGUuaWQsIG5ld0NvbnRlbnQsICcnXV07XG4gICAgIHVwZGF0ZShuZXdDb250ZW50KTtcbiAgIH0pO1xuIH1cbiAvLyBXaGVuIHRoZSBtb2R1bGUgaXMgZGlzcG9zZWQsIHJlbW92ZSB0aGUgPHN0eWxlPiB0YWdzXG4gbW9kdWxlLmhvdC5kaXNwb3NlKGZ1bmN0aW9uKCkgeyB1cGRhdGUoKTsgfSk7XG59XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9zcmMvY29tcG9uZW50cy93ZWJ1cGxvYWRlci9jc3Mvc3R5bGUuY3NzXG4vLyBtb2R1bGUgaWQgPSA2MFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///60\n");

/***/ }),
/* 61 */
/***/ (function(module, exports, __webpack_require__) {

eval("var escape = __webpack_require__(34);\nexports = module.exports = __webpack_require__(9)(false);\n// imports\n\n\n// module\nexports.push([module.i, \".jumbotron { background: transparent url(\" + escape(__webpack_require__(62)) + \") repeat-x 50% 0%; color: #fff; text-shadow: 1px 1px 1px #3b3262; margin-bottom: 0; }\\r\\n.jumbotron .container { position: relative; }\\r\\n.jumbotron .github-btns { position: absolute; bottom: 0; right: 0; }\\r\\n.fetature { margin-top: 30px; }\\r\\n.page-body { min-height: 450px; }\\r\\n.page-container { margin-top: 10px; }\\r\\n.page-container h1, .page-container h2, .page-container h3 { padding-top: 70px; margin-top: -50px; }\\r\\n\\r\\n@media (min-width: 768px) {\\r\\n.fetature .row .col-lg-4 { min-height: 250px; }\\r\\n}\\r\\n.footer { width: 100%; overflow: hidden; color: #f2f2f2; background: #212121; margin-top: 50px; }\\r\\n.footer-fixed-bottom { position: fixed; bottom: 0; }\\r\\n.footer a { color: #f2f2f2; }\\r\\n.footer .footer-inner { margin: 15px; }\\r\\n.wu-example { position: relative; padding: 45px 15px 15px; margin: 15px 0; background-color: #fafafa; box-shadow: inset 0 3px 6px rgba(0, 0, 0, .05); border-color: #e5e5e5 #eee #eee; border-style: solid; border-width: 1px 0; }\\r\\n.wu-example:after { content: \\\"\\\\793A\\\\4F8B\\\"; position: absolute; top: 15px; left: 15px; font-size: 12px; font-weight: bold; color: #bbb; text-transform: uppercase; letter-spacing: 1px; }\\r\\n\\r\\n@media (min-width: 768px) {\\r\\n.bs-example { margin-left: 0; margin-right: 0; background-color: #fff; border-width: 1px; border-color: #ddd; border-radius: 4px 4px 0 0; box-shadow: none; }\\r\\n}\\r\\n.post-toc { margin-top: 30px; margin-bottom: 30px; padding-top: 10px; padding-bottom: 10px; text-shadow: 0 1px 0 #fff; background-color: #f7f5fa; border-radius: 5px; }\\r\\n.post-toc .nav > li > a { display: block; color: #716b7a; padding: 5px 20px; }\\r\\n.post-toc .nav .nav > li > a { padding-top: 3px; padding-bottom: 3px; padding-left: 30px; font-size: 90%; }\\r\\n.post-toc.affix { position: static; }\\r\\n.post-toc .nav .nav { display: none; margin-bottom: 8px; }\\r\\n\\r\\n@media (min-width: 992px) {\\r\\n.post-toc.affix { position: fixed; width: 213px; top: 50px; }\\r\\n.post-toc .nav > .active > ul { display: block; }\\r\\n}\\r\\n\\r\\n@media (min-width: 1200px) {\\r\\n.post-toc.affix { width: 263px; }\\r\\n.post-toc .nav > .active > ul { display: block; }\\r\\n}\\r\\n.post-toc .nav > .active > a, .post-toc .nav > .active:hover > a, .post-toc .nav > .active:focus > a { font-weight: bold; color: #563d7c; background-color: transparent; border-right: 1px solid #563d7c; }\\r\\n.friends-links { margin: 0; padding: 0; list-style: none; }\\r\\n.weixin { text-align: center; display: inline-block; }\\r\\n.weixin img { width: 80px; }\\r\\n/********************************\\r\\n*\\r\\n*  COMMENTS\\r\\n*\\r\\n********************************/\\r\\n\\r\\n\\r\\n.comment { background-color: transparent; border-color: #CACACA; border-style: solid; border-width: 1px; color: black; display: block; margin-bottom: 10px; margin-top: 10px; padding: 0px; width: 100%; }\\r\\n.comment .commentheader { border-bottom-color: #CACACA; border-bottom-style: solid; border-bottom-width: 1px; color: black; background-image: -webkit-linear-gradient(#F8F8F8, #E1E1E1); background-image: -moz-linear-gradient(#F8F8F8, #E1E1E1); color: black; display: block; float: left; font-family: helvetica, arial, freesans, clean, sans-serif; font-size: 12px; font-style: normal; font-variant: normal; font-weight: normal; height: 33px; line-height: 33px; margin: 0px; overflow-x: hidden; overflow-y: hidden; padding: 0px; text-overflow: ellipsis; text-shadow: rgba(255, 255, 255, 0.699219) 1px 1px 0px; white-space: nowrap; width: 100%; }\\r\\n.comment .commentheader .commentgravatar { background-attachment: scroll; background-clip: border-box; background-color: white; background-image: none; background-origin: padding-box; border-color: #C8C8C8; border-style: solid; border-width: 1px; color: black; display: inline-block; float: none; font-family: helvetica, arial, freesans, clean, sans-serif; font-size: 1px; font-style: normal; font-variant: normal; font-weight: normal; height: 24px; line-height: 1px; margin-left: 5px; margin-right: 3px; margin-top: -2px; overflow-x: visible; overflow-y: visible; padding: 1px; text-overflow: clip; text-shadow: rgba(255, 255, 255, 0.699219) 1px 1px 0px; vertical-align: middle; white-space: nowrap; width: 24px; }\\r\\n.comment .commentheader a:link { text-decoration: none; }\\r\\n.comment .commentheader a:hover { border-bottom: 1px solid; }\\r\\n.comment .commentheader .commentuser { background-color: transparent; color: black; display: inline; float: none; font-family: helvetica, arial, freesans, clean, sans-serif; font-size: 12px; font-style: normal; font-variant: normal; font-weight: bold; height: 0px; line-height: 16px; margin-left: 5px; margin-right: 10px; overflow-x: visible; overflow-y: visible; padding: 0px; text-overflow: clip; text-shadow: rgba(255, 255, 255, 0.699219) 1px 1px 0px; white-space: nowrap; width: 0px; }\\r\\n.comment .commentheader .commentdate { background-color: transparent; color: #777; display: inline; float: none; font-family: helvetica, arial, freesans, clean, sans-serif; font-size: 11px; font-style: normal; font-variant: normal; font-weight: normal; height: 0px; line-height: 33px; margin: 0px; overflow-x: visible; overflow-y: visible; padding: 0px; text-overflow: clip; text-shadow: rgba(255, 255, 255, 0.699219) 1px 1px 0px; white-space: nowrap; width: 20em; }\\r\\n.comment .commentbody { background-attachment: scroll; background-clip: border-box; background-color: transparent; background-image: none; background-origin: padding-box; color: #333; display: block; margin-bottom: 1em; margin-left: 1em; margin-right: 1em; margin-top: 40px; overflow-x: visible; overflow-y: visible; padding: 0em; position: static; width: 96%; word-wrap: break-word; }\\r\\n.comment .commentbody p { margin-bottom: 0.5em; margin-top: 0.5em; margin-left: 0em; margin-right: 0em; }\\r\\n.comment .commentbody pre { border: 0px solid #ddd; background-color: #eef; padding: 0 .4em; }\\r\\n.comment .commentbody pre code { border: 0px solid #ddd; }\\r\\n.comment .commentbody code { border: 1px solid #ddd; background-color: #eef; font-size: 85%; padding: 0 .2em; }\\r\\n/*demo样式*/\\r\\n#picker { display: inline-block; line-height: 1.428571429; vertical-align: middle; margin: 0 12px 0 0; }\\r\\n#picker .webuploader-pick { padding: 6px 12px; display: block; }\\r\\n#uploader-demo .thumbnail { width: 110px; height: 110px; }\\r\\n#uploader-demo .thumbnail img { width: 100%; }\\r\\n.uploader-list { width: 100%; overflow: hidden; }\\r\\n.file-item { float: left; position: relative; margin: 0 20px 20px 0; padding: 4px; }\\r\\n.file-item .error { position: absolute; top: 4px; left: 4px; right: 4px; background: red; color: white; text-align: center; height: 20px; font-size: 14px; line-height: 23px; }\\r\\n.file-item .info { position: absolute; left: 4px; bottom: 4px; right: 4px; height: 20px; line-height: 20px; text-indent: 5px; background: rgba(0, 0, 0, 0.6); color: white; overflow: hidden; white-space: nowrap; text-overflow : ellipsis; font-size: 12px; z-index: 10; }\\r\\n.upload-state-done:after { content: \\\"\\\\F00C\\\"; font-family: FontAwesome; font-style: normal; font-weight: normal; line-height: 1; -webkit-font-smoothing: antialiased; -moz-osx-font-smoothing: grayscale; font-size: 32px; position: absolute; bottom: 0; right: 4px; color: #4cae4c; z-index: 99; }\\r\\n.file-item .progress { position: absolute; right: 4px; bottom: 4px; height: 3px; left: 4px; height: 4px; overflow: hidden; z-index: 15; margin: 0; padding: 0; border-radius: 0; background: transparent; }\\r\\n.file-item .progress span { display: block; overflow: hidden; width: 0; height: 100%; background: #d14 url(\" + escape(__webpack_require__(35)) + \") repeat-x; -webit-transition: width 200ms linear; -moz-transition: width 200ms linear; -o-transition: width 200ms linear; -ms-transition: width 200ms linear; transition: width 200ms linear; -webkit-animation: progressmove 2s linear infinite; -moz-animation: progressmove 2s linear infinite; -o-animation: progressmove 2s linear infinite; -ms-animation: progressmove 2s linear infinite; animation: progressmove 2s linear infinite; -webkit-transform: translateZ(0); }\\r\\n@-webkit-keyframes progressmove {\\r\\n 0% {\\r\\n background-position: 0 0;\\r\\n}\\r\\n 100% {\\r\\n background-position: 17px 0;\\r\\n}\\r\\n}\\r\\n@-moz-keyframes progressmove {\\r\\n 0% {\\r\\n background-position: 0 0;\\r\\n}\\r\\n 100% {\\r\\n background-position: 17px 0;\\r\\n}\\r\\n}\\r\\n@keyframes progressmove {\\r\\n 0% {\\r\\n background-position: 0 0;\\r\\n}\\r\\n 100% {\\r\\n background-position: 17px 0;\\r\\n}\\r\\n}\\r\\na.travis { position: relative; top: -4px; right: 15px; }\\r\\n\", \"\"]);\n\n// exports\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvY29tcG9uZW50cy93ZWJ1cGxvYWRlci9jc3Mvc3R5bGUuY3NzPzcwZjEiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEsYUFBYSxtQkFBTyxDQUFDLEVBQXVEO0FBQzVFLDJCQUEyQixtQkFBTyxDQUFDLENBQXFEO0FBQ3hGOzs7QUFHQTtBQUNBLGNBQWMsUUFBUyxlQUFlLHdDQUF3QyxtQkFBTyxDQUFDLEVBQWtCLHdCQUF3QixhQUFhLGtDQUFrQyxrQkFBa0IsRUFBRSwyQkFBMkIsb0JBQW9CLEVBQUUsNkJBQTZCLG9CQUFvQixXQUFXLFVBQVUsRUFBRSxlQUFlLGtCQUFrQixFQUFFLGdCQUFnQixtQkFBbUIsRUFBRSxxQkFBcUIsa0JBQWtCLEVBQUUsZ0VBQWdFLG1CQUFtQixtQkFBbUIsRUFBRSxtQ0FBbUMsOEJBQThCLG1CQUFtQixFQUFFLEtBQUssYUFBYSxhQUFhLGtCQUFrQixnQkFBZ0IscUJBQXFCLGtCQUFrQixFQUFFLDBCQUEwQixpQkFBaUIsV0FBVyxFQUFFLGVBQWUsZ0JBQWdCLEVBQUUsMkJBQTJCLGNBQWMsRUFBRSxpQkFBaUIsb0JBQW9CLHlCQUF5QixnQkFBZ0IsMkJBQTJCLGdEQUFnRCxpQ0FBaUMscUJBQXFCLHFCQUFxQixFQUFFLHVCQUF1QiwyQkFBMkIsb0JBQW9CLFdBQVcsWUFBWSxpQkFBaUIsbUJBQW1CLGFBQWEsMkJBQTJCLHFCQUFxQixFQUFFLG1DQUFtQyxpQkFBaUIsZ0JBQWdCLGlCQUFpQix3QkFBd0IsbUJBQW1CLG9CQUFvQiw0QkFBNEIsa0JBQWtCLEVBQUUsS0FBSyxlQUFlLGtCQUFrQixxQkFBcUIsbUJBQW1CLHNCQUFzQiwyQkFBMkIsMkJBQTJCLG9CQUFvQixFQUFFLDZCQUE2QixnQkFBZ0IsZ0JBQWdCLG1CQUFtQixFQUFFLGtDQUFrQyxrQkFBa0IscUJBQXFCLG9CQUFvQixnQkFBZ0IsRUFBRSxxQkFBcUIsa0JBQWtCLEVBQUUseUJBQXlCLGVBQWUsb0JBQW9CLEVBQUUs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QixpQkFBaUIsdUNBQXVDLHFDQUFxQyxtQ0FBbUMsb0NBQW9DLGdDQUFnQyxvREFBb0QsaURBQWlELCtDQUErQyxnREFBZ0QsNENBQTRDLGtDQUFrQyxFQUFFLHFDQUFxQyxTQUFTLDhCQUE4QixLQUFLLFdBQVcsaUNBQWlDLEtBQUssS0FBSyxrQ0FBa0MsU0FBUyw4QkFBOEIsS0FBSyxXQUFXLGlDQUFpQyxLQUFLLEtBQUssNkJBQTZCLFNBQVMsOEJBQThCLEtBQUssV0FBVyxpQ0FBaUMsS0FBSyxLQUFLLGNBQWMsb0JBQW9CLFdBQVcsYUFBYSxFQUFFOztBQUV2NlEiLCJmaWxlIjoiNjEuanMiLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgZXNjYXBlID0gcmVxdWlyZShcIi4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2xpYi91cmwvZXNjYXBlLmpzXCIpO1xuZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcIi4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2xpYi9jc3MtYmFzZS5qc1wiKShmYWxzZSk7XG4vLyBpbXBvcnRzXG5cblxuLy8gbW9kdWxlXG5leHBvcnRzLnB1c2goW21vZHVsZS5pZCwgXCIuanVtYm90cm9uIHsgYmFja2dyb3VuZDogdHJhbnNwYXJlbnQgdXJsKFwiICsgZXNjYXBlKHJlcXVpcmUoXCIuLi9pbWFnZXMvYmcucG5nXCIpKSArIFwiKSByZXBlYXQteCA1MCUgMCU7IGNvbG9yOiAjZmZmOyB0ZXh0LXNoYWRvdzogMXB4IDFweCAxcHggIzNiMzI2MjsgbWFyZ2luLWJvdHRvbTogMDsgfVxcclxcbi5qdW1ib3Ryb24gLmNvbnRhaW5lciB7IHBvc2l0aW9uOiByZWxhdGl2ZTsgfVxcclxcbi5qdW1ib3Ryb24gLmdpdGh1Yi1idG5zIHsgcG9zaXRpb246IGFic29sdXRlOyBib3R0b206IDA7IHJpZ2h0OiAwOyB9XFxyXFxuLmZldGF0dXJlIHsgbWFyZ2luLXRvcDogMzBweDsgfVxcclxcbi5wYWdlLWJvZHkgeyBtaW4taGVpZ2h0OiA0NTBweDsgfVxcclxcbi5wYWdlLWNvbnRhaW5lciB7IG1hcmdpbi10b3A6IDEwcHg7IH1cXHJcXG4ucGFnZS1jb250YWluZXIgaDEsIC5wYWdlLWNvbnRhaW5lciBoMiwgLnBhZ2UtY29udGFpbmVyIGgzIHsgcGFkZGluZy10b3A6IDcwcHg7IG1hcmdpbi10b3A6IC01MHB4OyB9XFxyXFxuXFxyXFxuQG1lZGlhIChtaW4td2lkdGg6IDc2OHB4KSB7XFxyXFxuLmZldGF0dXJlIC5yb3cgLmNvbC1sZy00IHsgbWluLWhlaWdodDogMjUwcHg7IH1cXHJcXG59XFxyXFxuLmZvb3RlciB7IHdpZHRoOiAxMDAlOyBvdmVyZmxvdzogaGlkZGVuOyBjb2xvcjogI2YyZjJmMjsgYmFja2dyb3VuZDogIzIxMjEyMTsgbWFyZ2luLXRvcDogNTBweDsgfVxcclxcbi5mb290ZXItZml4ZWQtYm90dG9tIHsgcG9zaXRpb246IGZpeGVkOyBib3R0b206IDA7IH1cXHJcXG4uZm9vdGVyIGEgeyBjb2xvcjogI2YyZjJmMjsgfVxcclxcbi5mb290ZXIgLmZvb3Rlci1pbm5lciB7IG1hcmdpbjogMTVweDsgfVxcclxcbi53dS1leGFtcGxlIHsgcG9zaXRpb246IHJlbGF0aXZlOyBwYWRkaW5nOiA0NXB4IDE1cHggMTVweDsgbWFyZ2luOiAxNXB4IDA7IGJhY2tncm91bmQtY29sb3I6ICNmYWZhZmE7IGJveC1zaGFkb3c6IGluc2V0IDAgM3B4IDZweCByZ2JhKDAsIDAsIDAsIC4wNSk7IGJvcmRlci1jb2xvcjogI2U1ZTVlNSAjZWVlICNlZWU7IGJvcmRlci1zdHlsZTogc29saWQ7IGJvcmRlci13aWR0aDogMXB4IDA7IH1cXHJcXG4ud3UtZXhhbXBsZTphZnRlciB7IGNvbnRlbnQ6IFxcXCJcXFxcNzkzQVxcXFw0RjhCXFxcIjsgcG9zaXRpb246IGFic29sdXRlOyB0b3A6IDE1cHg7IGxlZnQ6IDE1cHg7IGZvbnQtc2l6ZTogMTJweDsgZm9udC13ZWlnaHQ6IGJvbGQ7IGNvbG9yOiAjYmJiOyB0ZXh0LXRyYW5zZm9ybTogdXBwZXJjYXNlOyBsZXR0ZXItc3BhY2luZzogMXB4OyB9XFxyXFxuXFxyXFxuQG1lZGlhIChtaW4td2lkdGg6IDc2OHB4KSB7XFxyXFxuLmJzLWV4YW1wbGUgeyBtYXJnaW4tbGVmdDogMDsgbWFyZ2luLXJpZ2h0OiAwOyBiYWNrZ3JvdW5kLWNvbG9yOiAjZmZmOyBib3JkZXItd2lkdGg6IDFweDsgYm9yZGVyLWNvbG9yOiAjZGRkOyBib3JkZXItcmFkaXVzOiA0cHggNHB4IDAgMDsgYm94LXNoYWRvdzogbm9uZTsgfVxcclxcbn1cXHJcXG4ucG9zdC10b2MgeyBtYXJnaW4tdG9wOiAzMHB4OyBtYXJnaW4tYm90dG9tOiAzMHB4OyBwYWRkaW5nLXRvcDogMTBweDsgcGFkZGluZy1ib3R0b206IDEwcHg7IHRleHQtc2hhZG93OiAwIDFweCAwICNmZmY7IGJhY2tncm91bmQtY29sb3I6ICNmN2Y1ZmE7IGJvcmRlci1yYWRpdXM6IDVweDsgfVxcclxcbi5wb3N0LXRvYyAubmF2ID4gbGkgPiBhIHsgZGlzcGxheTogYmxvY2s7IGNvbG9yOiAjNzE2YjdhOyBwYWRkaW5nOiA1cHggMjBweDsgfVxcclxcbi5wb3N0LXRvYyAubmF2IC5uYXYgPiBsaSA+IGEgeyBwYWRkaW5nLXRvcDogM3B4OyBwYWRkaW5nLWJvdHRvbTogM3B4OyBwYWRkaW5nLWxlZnQ6IDMwcHg7IGZvbnQtc2l6ZTogOTAlOyB9XFxyXFxuLnBvc3QtdG9jLmFmZml4IHsgcG9zaXRpb246IHN0YXRpYzsgfVxcclxcbi5wb3N0LXRvYyAubmF2IC5uYXYgeyBkaXNwbGF5OiBub25lOyBtYXJnaW4tYm90dG9tOiA4cHg7IH1cXHJcXG5cXHJcXG5AbWVkaWEgKG1pbi13aWR0aDogOTkycHgpIHtcXHJcXG4ucG9zdC10b2MuYWZmaXggeyBwb3NpdGlvbjogZml4ZWQ7IHdpZHRoOiAyMTNweDsgdG9wOiA1MHB4OyB9XFxyXFxuLnBvc3QtdG9jIC5uYXYgPiAuYWN0aXZlID4gdWwgeyBkaXNwbGF5OiBibG9jazsgfVxcclxcbn1cXHJcXG5cXHJcXG5AbWVkaWEgKG1pbi13aWR0aDogMTIwMHB4KSB7XFxyXFxuLnBvc3QtdG9jLmFmZml4IHsgd2lkdGg6IDI2M3B4OyB9XFxyXFxuLnBvc3QtdG9jIC5uYXYgPiAuYWN0aXZlID4gdWwgeyBkaXNwbGF5OiBibG9jazsgfVxcclxcbn1cXHJcXG4ucG9zdC10b2MgLm5hdiA+IC5hY3RpdmUgPiBhLCAucG9zdC10b2MgLm5hdiA+IC5hY3RpdmU6aG92ZXIgPiBhLCAucG9zdC10b2MgLm5hdiA+IC5hY3RpdmU6Zm9jdXMgPiBhIHsgZm9udC13ZWlnaHQ6IGJvbGQ7IGNvbG9yOiAjNTYzZDdjOyBiYWNrZ3JvdW5kLWNvbG9yOiB0cmFuc3BhcmVudDsgYm9yZGVyLXJpZ2h0OiAxcHggc29saWQgIzU2M2Q3YzsgfVxcclxcbi5mcmllbmRzLWxpbmtzIHsgbWFyZ2luOiAwOyBwYWRkaW5nOiAwOyBsaXN0LXN0eWxlOiBub25lOyB9XFxyXFxuLndlaXhpbiB7IHRleHQtYWxpZ246IGNlbnRlcjsgZGlzcGxheTogaW5saW5lLWJsb2NrOyB9XFxyXFxuLndlaXhpbiBpbWcgeyB3aWR0aDogODBweDsgfVxcclxcbi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxcclxcbipcXHJcXG4qICBDT01NRU5UU1xcclxcbipcXHJcXG4qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cXHJcXG5cXHJcXG5cXHJcXG4uY29tbWVudCB7IGJhY2tncm91bmQtY29sb3I6IHRyYW5zcGFyZW50OyBib3JkZXItY29sb3I6ICNDQUNBQ0E7IGJvcmRlci1zdHlsZTogc29saWQ7IGJvcmRlci13aWR0aDogMXB4OyBjb2xvcjogYmxhY2s7IGRpc3BsYXk6IGJsb2NrOyBtYXJnaW4tYm90dG9tOiAxMHB4OyBtYXJnaW4tdG9wOiAxMHB4OyBwYWRkaW5nOiAwcHg7IHdpZHRoOiAxMDAlOyB9XFxyXFxuLmNvbW1lbnQgLmNvbW1lbnRoZWFkZXIgeyBib3JkZXItYm90dG9tLWNvbG9yOiAjQ0FDQUNBOyBib3JkZXItYm90dG9tLXN0eWxlOiBzb2xpZDsgYm9yZGVyLWJvdHRvbS13aWR0aDogMXB4OyBjb2xvcjogYmxhY2s7IGJhY2tncm91bmQtaW1hZ2U6IC13ZWJraXQtbGluZWFyLWdyYWRpZW50KCNGOEY4RjgsICNFMUUxRTEpOyBiYWNrZ3JvdW5kLWltYWdlOiAtbW96LWxpbmVhci1ncmFkaWVudCgjRjhGOEY4LCAjRTFFMUUxKTsgY29sb3I6IGJsYWNrOyBkaXNwbGF5OiBibG9jazsgZmxvYXQ6IGxlZnQ7IGZvbnQtZmFtaWx5OiBoZWx2ZXRpY2EsIGFyaWFsLCBmcmVlc2FucywgY2xlYW4sIHNhbnMtc2VyaWY7IGZvbnQtc2l6ZTogMTJweDsgZm9udC1zdHlsZTogbm9ybWFsOyBmb250LXZhcmlhbnQ6IG5vcm1hbDsgZm9udC13ZWlnaHQ6IG5vcm1hbDsgaGVpZ2h0OiAzM3B4OyBsaW5lLWhlaWdodDogMzNweDsgbWFyZ2luOiAwcHg7IG92ZXJmbG93LXg6IGhpZGRlbjsgb3ZlcmZsb3cteTogaGlkZGVuOyBwYWRkaW5nOiAwcHg7IHRleHQtb3ZlcmZsb3c6IGVsbGlwc2lzOyB0ZXh0LXNoYWRvdzogcmdiYSgyNTUsIDI1NSwgMjU1LCAwLjY5OTIxOSkgMXB4IDFweCAwcHg7IHdoaXRlLXNwYWNlOiBub3dyYXA7IHdpZHRoOiAxMDAlOyB9XFxyXFxuLmNvbW1lbnQgLmNvbW1lbnRoZWFkZXIgLmNvbW1lbnRncmF2YXRhciB7IGJhY2tncm91bmQtYXR0YWNobWVudDogc2Nyb2xsOyBiYWNrZ3JvdW5kLWNsaXA6IGJvcmRlci1ib3g7IGJhY2tncm91bmQtY29sb3I6IHdoaXRlOyBiYWNrZ3JvdW5kLWltYWdlOiBub25lOyBiYWNrZ3JvdW5kLW9yaWdpbjogcGFkZGluZy1ib3g7IGJvcmRlci1jb2xvcjogI0M4QzhDODsgYm9yZGVyLXN0eWxlOiBzb2xpZDsgYm9yZGVyLXdpZHRoOiAxcHg7IGNvbG9yOiBibGFjazsgZGlzcGxheTogaW5saW5lLWJsb2NrOyBmbG9hdDogbm9uZTsgZm9udC1mYW1pbHk6IGhlbHZldGljYSwgYXJpYWwsIGZyZWVzYW5zLCBjbGVhbiwgc2Fucy1zZXJpZjsgZm9udC1zaXplOiAxcHg7IGZvbnQtc3R5bGU6IG5vcm1hbDsgZm9udC12YXJpYW50OiBub3JtYWw7IGZvbnQtd2VpZ2h0OiBub3JtYWw7IGhlaWdodDogMjRweDsgbGluZS1oZWlnaHQ6IDFweDsgbWFyZ2luLWxlZnQ6IDVweDsgbWFyZ2luLXJpZ2h0OiAzcHg7IG1hcmdpbi10b3A6IC0ycHg7IG92ZXJmbG93LXg6IHZpc2libGU7IG92ZXJmbG93LXk6IHZpc2libGU7IHBhZGRpbmc6IDFweDsgdGV4dC1vdmVyZmxvdzogY2xpcDsgdGV4dC1zaGFkb3c6IHJnYmEoMjU1LCAyNTUsIDI1NSwgMC42OTkyMTkpIDFweCAxcHggMHB4OyB2ZXJ0aWNhbC1hbGlnbjogbWlkZGxlOyB3aGl0ZS1zcGFjZTogbm93cmFwOyB3aWR0aDogMjRweDsgfVxcclxcbi5jb21tZW50IC5jb21tZW50aGVhZGVyIGE6bGluayB7IHRleHQtZGVjb3JhdGlvbjogbm9uZTsgfVxcclxcbi5jb21tZW50IC5jb21tZW50aGVhZGVyIGE6aG92ZXIgeyBib3JkZXItYm90dG9tOiAxcHggc29saWQ7IH1cXHJcXG4uY29tbWVudCAuY29tbWVudGhlYWRlciAuY29tbWVudHVzZXIgeyBiYWNrZ3JvdW5kLWNvbG9yOiB0cmFuc3BhcmVudDsgY29sb3I6IGJsYWNrOyBkaXNwbGF5OiBpbmxpbmU7IGZsb2F0OiBub25lOyBmb250LWZhbWlseTogaGVsdmV0aWNhLCBhcmlhbCwgZnJlZXNhbnMsIGNsZWFuLCBzYW5zLXNlcmlmOyBmb250LXNpemU6IDEycHg7IGZvbnQtc3R5bGU6IG5vcm1hbDsgZm9udC12YXJpYW50OiBub3JtYWw7IGZvbnQtd2VpZ2h0OiBib2xkOyBoZWlnaHQ6IDBweDsgbGluZS1oZWlnaHQ6IDE2cHg7IG1hcmdpbi1sZWZ0OiA1cHg7IG1hcmdpbi1yaWdodDogMTBweDsgb3ZlcmZsb3cteDogdmlzaWJsZTsgb3ZlcmZsb3cteTogdmlzaWJsZTsgcGFkZGluZzogMHB4OyB0ZXh0LW92ZXJmbG93OiBjbGlwOyB0ZXh0LXNoYWRvdzogcmdiYSgyNTUsIDI1NSwgMjU1LCAwLjY5OTIxOSkgMXB4IDFweCAwcHg7IHdoaXRlLXNwYWNlOiBub3dyYXA7IHdpZHRoOiAwcHg7IH1cXHJcXG4uY29tbWVudCAuY29tbWVudGhlYWRlciAuY29tbWVudGRhdGUgeyBiYWNrZ3JvdW5kLWNvbG9yOiB0cmFuc3BhcmVudDsgY29sb3I6ICM3Nzc7IGRpc3BsYXk6IGlubGluZTsgZmxvYXQ6IG5vbmU7IGZvbnQtZmFtaWx5OiBoZWx2ZXRpY2EsIGFyaWFsLCBmcmVlc2FucywgY2xlYW4sIHNhbnMtc2VyaWY7IGZvbnQtc2l6ZTogMTFweDsgZm9udC1zdHlsZTogbm9ybWFsOyBmb250LXZhcmlhbnQ6IG5vcm1hbDsgZm9udC13ZWlnaHQ6IG5vcm1hbDsgaGVpZ2h0OiAwcHg7IGxpbmUtaGVpZ2h0OiAzM3B4OyBtYXJnaW46IDBweDsgb3ZlcmZsb3cteDogdmlzaWJsZTsgb3ZlcmZsb3cteTogdmlzaWJsZTsgcGFkZGluZzogMHB4OyB0ZXh0LW92ZXJmbG93OiBjbGlwOyB0ZXh0LXNoYWRvdzogcmdiYSgyNTUsIDI1NSwgMjU1LCAwLjY5OTIxOSkgMXB4IDFweCAwcHg7IHdoaXRlLXNwYWNlOiBub3dyYXA7IHdpZHRoOiAyMGVtOyB9XFxyXFxuLmNvbW1lbnQgLmNvbW1lbnRib2R5IHsgYmFja2dyb3VuZC1hdHRhY2htZW50OiBzY3JvbGw7IGJhY2tncm91bmQtY2xpcDogYm9yZGVyLWJveDsgYmFja2dyb3VuZC1jb2xvcjogdHJhbnNwYXJlbnQ7IGJhY2tncm91bmQtaW1hZ2U6IG5vbmU7IGJhY2tncm91bmQtb3JpZ2luOiBwYWRkaW5nLWJveDsgY29sb3I6ICMzMzM7IGRpc3BsYXk6IGJsb2NrOyBtYXJnaW4tYm90dG9tOiAxZW07IG1hcmdpbi1sZWZ0OiAxZW07IG1hcmdpbi1yaWdodDogMWVtOyBtYXJnaW4tdG9wOiA0MHB4OyBvdmVyZmxvdy14OiB2aXNpYmxlOyBvdmVyZmxvdy15OiB2aXNpYmxlOyBwYWRkaW5nOiAwZW07IHBvc2l0aW9uOiBzdGF0aWM7IHdpZHRoOiA5NiU7IHdvcmQtd3JhcDogYnJlYWstd29yZDsgfVxcclxcbi5jb21tZW50IC5jb21tZW50Ym9keSBwIHsgbWFyZ2luLWJvdHRvbTogMC41ZW07IG1hcmdpbi10b3A6IDAuNWVtOyBtYXJnaW4tbGVmdDogMGVtOyBtYXJnaW4tcmlnaHQ6IDBlbTsgfVxcclxcbi5jb21tZW50IC5jb21tZW50Ym9keSBwcmUgeyBib3JkZXI6IDBweCBzb2xpZCAjZGRkOyBiYWNrZ3JvdW5kLWNvbG9yOiAjZWVmOyBwYWRkaW5nOiAwIC40ZW07IH1cXHJcXG4uY29tbWVudCAuY29tbWVudGJvZHkgcHJlIGNvZGUgeyBib3JkZXI6IDBweCBzb2xpZCAjZGRkOyB9XFxyXFxuLmNvbW1lbnQgLmNvbW1lbnRib2R5IGNvZGUgeyBib3JkZXI6IDFweCBzb2xpZCAjZGRkOyBiYWNrZ3JvdW5kLWNvbG9yOiAjZWVmOyBmb250LXNpemU6IDg1JTsgcGFkZGluZzogMCAuMmVtOyB9XFxyXFxuLypkZW1v5qC35byPKi9cXHJcXG4jcGlja2VyIHsgZGlzcGxheTogaW5saW5lLWJsb2NrOyBsaW5lLWhlaWdodDogMS40Mjg1NzE0Mjk7IHZlcnRpY2FsLWFsaWduOiBtaWRkbGU7IG1hcmdpbjogMCAxMnB4IDAgMDsgfVxcclxcbiNwaWNrZXIgLndlYnVwbG9hZGVyLXBpY2sgeyBwYWRkaW5nOiA2cHggMTJweDsgZGlzcGxheTogYmxvY2s7IH1cXHJcXG4jdXBsb2FkZXItZGVtbyAudGh1bWJuYWlsIHsgd2lkdGg6IDExMHB4OyBoZWlnaHQ6IDExMHB4OyB9XFxyXFxuI3VwbG9hZGVyLWRlbW8gLnRodW1ibmFpbCBpbWcgeyB3aWR0aDogMTAwJTsgfVxcclxcbi51cGxvYWRlci1saXN0IHsgd2lkdGg6IDEwMCU7IG92ZXJmbG93OiBoaWRkZW47IH1cXHJcXG4uZmlsZS1pdGVtIHsgZmxvYXQ6IGxlZnQ7IHBvc2l0aW9uOiByZWxhdGl2ZTsgbWFyZ2luOiAwIDIwcHggMjBweCAwOyBwYWRkaW5nOiA0cHg7IH1cXHJcXG4uZmlsZS1pdGVtIC5lcnJvciB7IHBvc2l0aW9uOiBhYnNvbHV0ZTsgdG9wOiA0cHg7IGxlZnQ6IDRweDsgcmlnaHQ6IDRweDsgYmFja2dyb3VuZDogcmVkOyBjb2xvcjogd2hpdGU7IHRleHQtYWxpZ246IGNlbnRlcjsgaGVpZ2h0OiAyMHB4OyBmb250LXNpemU6IDE0cHg7IGxpbmUtaGVpZ2h0OiAyM3B4OyB9XFxyXFxuLmZpbGUtaXRlbSAuaW5mbyB7IHBvc2l0aW9uOiBhYnNvbHV0ZTsgbGVmdDogNHB4OyBib3R0b206IDRweDsgcmlnaHQ6IDRweDsgaGVpZ2h0OiAyMHB4OyBsaW5lLWhlaWdodDogMjBweDsgdGV4dC1pbmRlbnQ6IDVweDsgYmFja2dyb3VuZDogcmdiYSgwLCAwLCAwLCAwLjYpOyBjb2xvcjogd2hpdGU7IG92ZXJmbG93OiBoaWRkZW47IHdoaXRlLXNwYWNlOiBub3dyYXA7IHRleHQtb3ZlcmZsb3cgOiBlbGxpcHNpczsgZm9udC1zaXplOiAxMnB4OyB6LWluZGV4OiAxMDsgfVxcclxcbi51cGxvYWQtc3RhdGUtZG9uZTphZnRlciB7IGNvbnRlbnQ6IFxcXCJcXFxcRjAwQ1xcXCI7IGZvbnQtZmFtaWx5OiBGb250QXdlc29tZTsgZm9udC1zdHlsZTogbm9ybWFsOyBmb250LXdlaWdodDogbm9ybWFsOyBsaW5lLWhlaWdodDogMTsgLXdlYmtpdC1mb250LXNtb290aGluZzogYW50aWFsaWFzZWQ7IC1tb3otb3N4LWZvbnQtc21vb3RoaW5nOiBncmF5c2NhbGU7IGZvbnQtc2l6ZTogMzJweDsgcG9zaXRpb246IGFic29sdXRlOyBib3R0b206IDA7IHJpZ2h0OiA0cHg7IGNvbG9yOiAjNGNhZTRjOyB6LWluZGV4OiA5OTsgfVxcclxcbi5maWxlLWl0ZW0gLnByb2dyZXNzIHsgcG9zaXRpb246IGFic29sdXRlOyByaWdodDogNHB4OyBib3R0b206IDRweDsgaGVpZ2h0OiAzcHg7IGxlZnQ6IDRweDsgaGVpZ2h0OiA0cHg7IG92ZXJmbG93OiBoaWRkZW47IHotaW5kZXg6IDE1OyBtYXJnaW46IDA7IHBhZGRpbmc6IDA7IGJvcmRlci1yYWRpdXM6IDA7IGJhY2tncm91bmQ6IHRyYW5zcGFyZW50OyB9XFxyXFxuLmZpbGUtaXRlbSAucHJvZ3Jlc3Mgc3BhbiB7IGRpc3BsYXk6IGJsb2NrOyBvdmVyZmxvdzogaGlkZGVuOyB3aWR0aDogMDsgaGVpZ2h0OiAxMDAlOyBiYWNrZ3JvdW5kOiAjZDE0IHVybChcIiArIGVzY2FwZShyZXF1aXJlKFwiLi4vaW1hZ2VzL3Byb2dyZXNzLnBuZ1wiKSkgKyBcIikgcmVwZWF0LXg7IC13ZWJpdC10cmFuc2l0aW9uOiB3aWR0aCAyMDBtcyBsaW5lYXI7IC1tb3otdHJhbnNpdGlvbjogd2lkdGggMjAwbXMgbGluZWFyOyAtby10cmFuc2l0aW9uOiB3aWR0aCAyMDBtcyBsaW5lYXI7IC1tcy10cmFuc2l0aW9uOiB3aWR0aCAyMDBtcyBsaW5lYXI7IHRyYW5zaXRpb246IHdpZHRoIDIwMG1zIGxpbmVhcjsgLXdlYmtpdC1hbmltYXRpb246IHByb2dyZXNzbW92ZSAycyBsaW5lYXIgaW5maW5pdGU7IC1tb3otYW5pbWF0aW9uOiBwcm9ncmVzc21vdmUgMnMgbGluZWFyIGluZmluaXRlOyAtby1hbmltYXRpb246IHByb2dyZXNzbW92ZSAycyBsaW5lYXIgaW5maW5pdGU7IC1tcy1hbmltYXRpb246IHByb2dyZXNzbW92ZSAycyBsaW5lYXIgaW5maW5pdGU7IGFuaW1hdGlvbjogcHJvZ3Jlc3Ntb3ZlIDJzIGxpbmVhciBpbmZpbml0ZTsgLXdlYmtpdC10cmFuc2Zvcm06IHRyYW5zbGF0ZVooMCk7IH1cXHJcXG5ALXdlYmtpdC1rZXlmcmFtZXMgcHJvZ3Jlc3Ntb3ZlIHtcXHJcXG4gMCUge1xcclxcbiBiYWNrZ3JvdW5kLXBvc2l0aW9uOiAwIDA7XFxyXFxufVxcclxcbiAxMDAlIHtcXHJcXG4gYmFja2dyb3VuZC1wb3NpdGlvbjogMTdweCAwO1xcclxcbn1cXHJcXG59XFxyXFxuQC1tb3ota2V5ZnJhbWVzIHByb2dyZXNzbW92ZSB7XFxyXFxuIDAlIHtcXHJcXG4gYmFja2dyb3VuZC1wb3NpdGlvbjogMCAwO1xcclxcbn1cXHJcXG4gMTAwJSB7XFxyXFxuIGJhY2tncm91bmQtcG9zaXRpb246IDE3cHggMDtcXHJcXG59XFxyXFxufVxcclxcbkBrZXlmcmFtZXMgcHJvZ3Jlc3Ntb3ZlIHtcXHJcXG4gMCUge1xcclxcbiBiYWNrZ3JvdW5kLXBvc2l0aW9uOiAwIDA7XFxyXFxufVxcclxcbiAxMDAlIHtcXHJcXG4gYmFja2dyb3VuZC1wb3NpdGlvbjogMTdweCAwO1xcclxcbn1cXHJcXG59XFxyXFxuYS50cmF2aXMgeyBwb3NpdGlvbjogcmVsYXRpdmU7IHRvcDogLTRweDsgcmlnaHQ6IDE1cHg7IH1cXHJcXG5cIiwgXCJcIl0pO1xuXG4vLyBleHBvcnRzXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyIS4vc3JjL2NvbXBvbmVudHMvd2VidXBsb2FkZXIvY3NzL3N0eWxlLmNzc1xuLy8gbW9kdWxlIGlkID0gNjFcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///61\n");

/***/ }),
/* 62 */
/***/ (function(module, exports) {

eval("module.exports = \"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAG4AAABuCAIAAABJObGsAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAyRpVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuMy1jMDExIDY2LjE0NTY2MSwgMjAxMi8wMi8wNi0xNDo1NjoyNyAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvIiB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIgeG1sbnM6c3RSZWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZVJlZiMiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIENTNiAoTWFjaW50b3NoKSIgeG1wTU06SW5zdGFuY2VJRD0ieG1wLmlpZDowMzQwNjJFRjEyMDMxMUUzODk2Q0JFM0Q1RjE4QkExQyIgeG1wTU06RG9jdW1lbnRJRD0ieG1wLmRpZDowMzQwNjJGMDEyMDMxMUUzODk2Q0JFM0Q1RjE4QkExQyI+IDx4bXBNTTpEZXJpdmVkRnJvbSBzdFJlZjppbnN0YW5jZUlEPSJ4bXAuaWlkOjAzNDA2MkVEMTIwMzExRTM4OTZDQkUzRDVGMThCQTFDIiBzdFJlZjpkb2N1bWVudElEPSJ4bXAuZGlkOjAzNDA2MkVFMTIwMzExRTM4OTZDQkUzRDVGMThCQTFDIi8+IDwvcmRmOkRlc2NyaXB0aW9uPiA8L3JkZjpSREY+IDwveDp4bXBtZXRhPiA8P3hwYWNrZXQgZW5kPSJyIj8+Phg2/QAAB5VJREFUeNrsXdFu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\"\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvY29tcG9uZW50cy93ZWJ1cGxvYWRlci9pbWFnZXMvYmcucG5nPzQxMTAiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEsaUNBQWlDIiwiZmlsZSI6IjYyLmpzIiwic291cmNlc0NvbnRlbnQiOlsibW9kdWxlLmV4cG9ydHMgPSBcImRhdGE6aW1hZ2UvcG5nO2Jhc2U2NCxpVkJPUncwS0dnb0FBQUFOU1VoRVVnQUFBRzRBQUFCdUNBSUFBQUJKT2JHc0FBQUFHWFJGV0hSVGIyWjBkMkZ5WlFCQlpHOWlaU0JKYldGblpWSmxZV1I1Y2NsbFBBQUFBeVJwVkZoMFdFMU1PbU52YlM1aFpHOWlaUzU0YlhBQUFBQUFBRHcvZUhCaFkydGxkQ0JpWldkcGJqMGk3N3UvSWlCcFpEMGlWelZOTUUxd1EyVm9hVWg2Y21WVGVrNVVZM3ByWXpsa0lqOCtJRHg0T25odGNHMWxkR0VnZUcxc2JuTTZlRDBpWVdSdlltVTZibk02YldWMFlTOGlJSGc2ZUcxd2RHczlJa0ZrYjJKbElGaE5VQ0JEYjNKbElEVXVNeTFqTURFeElEWTJMakUwTlRZMk1Td2dNakF4TWk4d01pOHdOaTB4TkRvMU5qb3lOeUFnSUNBZ0lDQWdJajRnUEhKa1pqcFNSRVlnZUcxc2JuTTZjbVJtUFNKb2RIUndPaTh2ZDNkM0xuY3pMbTl5Wnk4eE9UazVMekF5THpJeUxYSmtaaTF6ZVc1MFlYZ3Ribk1qSWo0Z1BISmtaanBFWlhOamNtbHdkR2x2YmlCeVpHWTZZV0p2ZFhROUlpSWdlRzFzYm5NNmVHMXdQU0pvZEhSd09pOHZibk11WVdSdlltVXVZMjl0TDNoaGNDOHhMakF2SWlCNGJXeHVjenA0YlhCTlRUMGlhSFIwY0RvdkwyNXpMbUZrYjJKbExtTnZiUzk0WVhBdk1TNHdMMjF0THlJZ2VHMXNibk02YzNSU1pXWTlJbWgwZEhBNkx5OXVjeTVoWkc5aVpTNWpiMjB2ZUdGd0x6RXVNQzl6Vkhsd1pTOVNaWE52ZFhKalpWSmxaaU1pSUhodGNEcERjbVZoZEc5eVZHOXZiRDBpUVdSdlltVWdVR2h2ZEc5emFHOXdJRU5UTmlBb1RXRmphVzUwYjNOb0tTSWdlRzF3VFUwNlNXNXpkR0Z1WTJWSlJEMGllRzF3TG1scFpEb3dNelF3TmpKRlJqRXlNRE14TVVVek9EazJRMEpGTTBRMVJqRTRRa0V4UXlJZ2VHMXdUVTA2Ukc5amRXMWxiblJKUkQwaWVHMXdMbVJwWkRvd016UXdOakpHTURFeU1ETXhNVVV6T0RrMlEwSkZNMFExUmpFNFFrRXhReUkrSUR4NGJYQk5UVHBFWlhKcGRtVmtSbkp2YlNCemRGSmxaanBwYm5OMFlXNWpaVWxFUFNKNGJYQXVhV2xrT2pBek5EQTJNa1ZFTVRJd016RXhSVE00T1RaRFFrVXpSRFZHTVRoQ1FURkRJaUJ6ZEZKbFpqcGtiMk4xYldWdWRFbEVQU0o0YlhBdVpHbGtPakF6TkRBMk1rVkZNVEl3TXpFeFJUTTRPVFpEUWtVelJEVkdNVGhDUVRGRElpOCtJRHd2Y21SbU9rUmxjMk55YVhCMGFXOXVQaUE4TDNKa1pqcFNSRVkrSUR3dmVEcDRiWEJ0WlhSaFBpQThQM2h3WVdOclpYUWdaVzVrUFNKeUlqOCtQaGcyL1FBQUI1VkpSRUZVZU5yc1hkRnU0ekFNU3czL3dQYi92N2p0RTNiRjdkQmxqaVdSbEp6dWdOekRJVWhUeDZzVm1xUms1L2IrL3I1dDI4dkx5LzMvajQrUHgvSDkvTzEyTzU2L0gzOStmcjYrdmg3UFU4ZGY5L1hiUWZyZ1hGTnliTFYvN0gvYmR2L3UvZHZJZi91dmhGL2ZYM0Q3K3krOFpuLys4ZEg5NFBIUnRCSDV6OEg3Zjd6MTdldGpNQmJrTVV6Rzh2UzdRai8zN2JEOUNhOXZ4OTkrK0xHcHNYVml4UGxJYTFab2NQK1Z4L0VRNytGM3JXdjZFMk1rYzkrd0Q4T3hnOHY3OHdoMlc5YzBIQnI4OGNrRVhTYW05dDJ3THJCd21jVkh2NUVKVm1ad1pJak44UHpKbUp2Qit2QzRUY2RoT3VaV2tGcno2WEErSEY1dy9KZUd2OVg0SGs4dDN0SXQ3RGlPajRWTkNBWWhZN3N1MWtCOGQ2NEorM2IvYnN2d3IyU0FaSGdmeFdlUnJnN1BJdlUzZm4zM0d5dFpYSnZPcHdqV1dQT3BOZjlXWVIvYjV0RFBNSzViK1BPSDV3ZU1RK0lsSEg4aDNxZjNjckF2YkdjVU0xR1hDS3kwNGxURHhQTTF1TmJuUzROZkd2elM0SmNHdnpUNHBjRXZEWDVwOEV1RFh4cjgwdUNYQnI4MCtLWEJxelQ0Y2R4Q1BURFY0SUptQjl1WDUzSEhLNUNmQ1lmYmRpY1dxRGgxeHArTmQ0cmJndGdYOHBEOTh6UThXNmljbS9KS2VheHdqWEdPcms5aUx2WGNOR3JpbTQ2VnhTdXJDT0EwdUVCK3VvaG1UczkzZkp4bFhHUGpMdG1IVUZNdnFqZHF5RGhYNFpFenoxcnh2b0szT21GTzNYcmdLZ0ZXc2o2UWc2M2xmdVVUdFhtQWxTRU9naUJDelgxSVVEZ2NJTHhHQ0M2WmJOenV2emNiZDB0eDh6ZDRQQTRuY2Rwc0NFOUVjakxuV0phVTc4MWk2TlNhd2prSndTdEI3Q2poZW9qK3JZckhxdXRieGpmVzVMTXdYMVB4em9vbzltR3krdCtkbURxWlk4cTVRSUVETE9HVlFueFpVeDdMU2RucEV2SHpNem5MNmQrRlkvRy9XRTNxNWZJNDBuS0hGUGF4dmxTb2tYcko1Q3ZZZ2hUNFdoNGlJbVlvdm9IRXRkVmdMNHdqTnE0enRSSmdQTEtZem5xdkpsWTZlVFZFRHlEYWRob3ZpSjV4K2hENmpLelBBSFptd05OSmJxY0tCL2R4S3ZEVDh2emlDazhveU8wTXNVbkZtaFduSUdBaFdsdkdiaWN2WDFLdjBRVit4Mm9QcTAwRUs0YzRrdlVQeTFzUlRqMzByU1U5NUpEaU9mTXB3bUd0dUtZa2pWQXpSRkdGcndNOXQ3UGFCMXBSTDFmaW1kWnI4TERlTU9uOVVIN1ZDaTJQNUs4Z0RYN2tpZE1ZS2RGSXg3a2VhUk92YlVJNFE3SjI3bjVOdHpCTDhJUkt4Qkl5dHlJeFl2bndJSmVZMXIwSGRFWEw3V1Q4elNUbXl0eVE3UnZvcTA1NFpaWDl4OUpBMlY1a05Ra1NqMndlL3dldnJPWDliSjQ2WDN0V1dFK2M5SmxhY3QyTHhSL1p1WDZxL2RtNHNPNVY1Wm43ZGMvbnJkc3ByTkhROVA3cS9HV3JyWlZBZkdrV3k2cjAvdXE2ais1enliQVd2Y3JUTG1uVDh0dnhtdk5Nblh4elBFY1dINm02Mjh5Y0R0YUdJUHE5NUprWS9jcHlMZ2xpbWZWTWxIaUxTVDZ3Q2V0MmhCb2RSQmRQdlJrclJ2YlhWSG1MR1o3STRteG5heEo5VDdNcWxtdlh4Q0xhUDg4VG1oQjZKVGxyaEs4VmVvdVdIcGQ5eitPek1zL3RQS3NtYlZIZUVaL3JCYjMvdUtiaFBqa290S205Q2hDUGttMEg4VFRCZGJtSS8vVDRxSVByeU5qNklUWTNqYlN6TWZ0dWFIM0w4TitPOERJUXkwSmVDZktFc0IxaEg0VXF6dXZVZ0h6WERHVThtQktjUFdHZmc0MnNHNlc0YXFQbUwydE9aK2xiMVhwRTVCcmtYcGJtb1o2UEx0UTJJblhhaGJVZWlJN09QeCtzbHo3aGxXQTlEZXRqeS9YcVlOR2x4VEhDNTRQMXQzQThKV3FHQkh3cFdYdUJyQjgvWVUvcU1ONTdPTld5dVRxVzRzbUI3R2o1S2gwVmR1TUhyNnhhSHl1c3l6NWhqUmk3OW9iRitoOTdzZzErekFyL09SeFA1THNzdDkzN3AxYWUzZEZweWlNWTVzSExZNVBGeENvK1dMaStLTURLRmFVL2xKNFYvRVRFQTBlNHNLekJmdmlWU2V6NFg0NkYvQldyOTFzK3A2RnBEd2Vua0d0WUw4cnk2aEZlZ1paUHlWaTVZdjc5RFczS3oxOHJpY2ZNTW1wNVRpK2tHU1ZiZnZSRjR5eGM3K3ZvRS9abXNiVFpCdXlCdFRucndRV2VLTWVSVThSUjRxc2plM3lBSE5QS29jLzNaQ3RjbXlqcnFETzlTellIR2Z1VkpmdWNXRGtUYTErQkVwREY1M0V3MWFPUjAxNVZzdzNtdGNPOCtRcmRBdFk4eWZtcmVSNDg5TXlURzJkVXJTOWsxNjFQWTFOWUMrVGNTRjhQTG52cGhUNk5mUDBLejcreG5ONlBVN1ptRERRMEVjNkErRG9aelI1cjhEUFhyeUo0eXI0VHdxcmpXYlJYQVlHVmxIMjlZcDRWSG83TVBvVklqZ2o4UTA3eUs1UHhzdlQ5QUVJTlBMRi9aWEp2aytuZ3Mzc0poS0VLN3EySjVQZGw3M1hmZnY4bCs1YXpXQW5pZGUwNk9MLzlWbFh2c01La3lYanlHNytuZ2x4WEJPMmRJYXhabEhVNnUxOTZabzVtYyt0SSt4M0hJNnMrSE5uWHA2cllLRGxIVXdsRjFqOHR3MHByalNPeTlwSEZ1Nm82a2RxNW9RcytOcUxaMmRvTktoY2tGOGJuYy9vZXphajFLeGZ0VmJFbGF0WEs5MCtLYTlHdE9najJIU0lsL3JtVEkyUjFDTHNuRzdqOThLU2ZiMjl2ejlxelpUdHJ2ZTZLZFpielBEaWxFOWpBWk9zWjJmdXVXTCtJK0dRcERWNzQzckdOV1E5eHNyNldqeHYrMnp2MWpGT01BL2NVdFBpQXM3UUN4N0toYm0zcE95ZjZpdmZacnFpalRPNEpRK1Z0TkQzZWhKb0wyVWRKNW54QzdFdjY4S0huNUs4QjV2ektaTjZ4SkFaWDU4RXIzK01JK2pFVVptWHlqb0wzODVSM0FQYU1KK1RzTjc1VnYvczcrUnhzNi9jMjZHemdJTzhKRmZhSlptbG02RE95ejRyd0xxc0J1LzhJTUFCdE81Qk92czR1RFFBQUFBQkpSVTVFcmtKZ2dnPT1cIlxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vc3JjL2NvbXBvbmVudHMvd2VidXBsb2FkZXIvaW1hZ2VzL2JnLnBuZ1xuLy8gbW9kdWxlIGlkID0gNjJcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///62\n");

/***/ }),
/* 63 */
/***/ (function(module, exports, __webpack_require__) {

eval("// style-loader: Adds some css to the DOM by adding a <style> tag\n\n// load the styles\nvar content = __webpack_require__(64);\nif(typeof content === 'string') content = [[module.i, content, '']];\nif(content.locals) module.exports = content.locals;\n// add the styles to the DOM\nvar update = __webpack_require__(10)(\"bec4c71e\", content, false, {});\n// Hot Module Replacement\nif(false) {\n // When the styles change, update the <style> tags\n if(!content.locals) {\n   module.hot.accept(\"!!../../../../node_modules/css-loader/index.js!./webuploader.css\", function() {\n     var newContent = require(\"!!../../../../node_modules/css-loader/index.js!./webuploader.css\");\n     if(typeof newContent === 'string') newContent = [[module.id, newContent, '']];\n     update(newContent);\n   });\n }\n // When the module is disposed, remove the <style> tags\n module.hot.dispose(function() { update(); });\n}\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvY29tcG9uZW50cy93ZWJ1cGxvYWRlci93ZWJ1cGxvYWRlci0wLjEuNS93ZWJ1cGxvYWRlci5jc3M/Njk4NSJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTs7QUFFQTtBQUNBLGNBQWMsbUJBQU8sQ0FBQyxFQUFrRTtBQUN4Riw0Q0FBNEMsUUFBUztBQUNyRDtBQUNBO0FBQ0EsYUFBYSxtQkFBTyxDQUFDLEVBQW1FLGdDQUFnQztBQUN4SDtBQUNBLEdBQUcsS0FBVTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0EsZ0NBQWdDLFVBQVUsRUFBRTtBQUM1QyIsImZpbGUiOiI2My5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8vIHN0eWxlLWxvYWRlcjogQWRkcyBzb21lIGNzcyB0byB0aGUgRE9NIGJ5IGFkZGluZyBhIDxzdHlsZT4gdGFnXG5cbi8vIGxvYWQgdGhlIHN0eWxlc1xudmFyIGNvbnRlbnQgPSByZXF1aXJlKFwiISEuLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9pbmRleC5qcyEuL3dlYnVwbG9hZGVyLmNzc1wiKTtcbmlmKHR5cGVvZiBjb250ZW50ID09PSAnc3RyaW5nJykgY29udGVudCA9IFtbbW9kdWxlLmlkLCBjb250ZW50LCAnJ11dO1xuaWYoY29udGVudC5sb2NhbHMpIG1vZHVsZS5leHBvcnRzID0gY29udGVudC5sb2NhbHM7XG4vLyBhZGQgdGhlIHN0eWxlcyB0byB0aGUgRE9NXG52YXIgdXBkYXRlID0gcmVxdWlyZShcIiEuLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvdnVlLXN0eWxlLWxvYWRlci9saWIvYWRkU3R5bGVzQ2xpZW50LmpzXCIpKFwiYmVjNGM3MWVcIiwgY29udGVudCwgZmFsc2UsIHt9KTtcbi8vIEhvdCBNb2R1bGUgUmVwbGFjZW1lbnRcbmlmKG1vZHVsZS5ob3QpIHtcbiAvLyBXaGVuIHRoZSBzdHlsZXMgY2hhbmdlLCB1cGRhdGUgdGhlIDxzdHlsZT4gdGFnc1xuIGlmKCFjb250ZW50LmxvY2Fscykge1xuICAgbW9kdWxlLmhvdC5hY2NlcHQoXCIhIS4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2luZGV4LmpzIS4vd2VidXBsb2FkZXIuY3NzXCIsIGZ1bmN0aW9uKCkge1xuICAgICB2YXIgbmV3Q29udGVudCA9IHJlcXVpcmUoXCIhIS4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2luZGV4LmpzIS4vd2VidXBsb2FkZXIuY3NzXCIpO1xuICAgICBpZih0eXBlb2YgbmV3Q29udGVudCA9PT0gJ3N0cmluZycpIG5ld0NvbnRlbnQgPSBbW21vZHVsZS5pZCwgbmV3Q29udGVudCwgJyddXTtcbiAgICAgdXBkYXRlKG5ld0NvbnRlbnQpO1xuICAgfSk7XG4gfVxuIC8vIFdoZW4gdGhlIG1vZHVsZSBpcyBkaXNwb3NlZCwgcmVtb3ZlIHRoZSA8c3R5bGU+IHRhZ3NcbiBtb2R1bGUuaG90LmRpc3Bvc2UoZnVuY3Rpb24oKSB7IHVwZGF0ZSgpOyB9KTtcbn1cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL3NyYy9jb21wb25lbnRzL3dlYnVwbG9hZGVyL3dlYnVwbG9hZGVyLTAuMS41L3dlYnVwbG9hZGVyLmNzc1xuLy8gbW9kdWxlIGlkID0gNjNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///63\n");

/***/ }),
/* 64 */
/***/ (function(module, exports, __webpack_require__) {

eval("exports = module.exports = __webpack_require__(9)(false);\n// imports\n\n\n// module\nexports.push([module.i, \".webuploader-container { position: relative; }\\r\\n.webuploader-element-invisible { position: absolute !important; clip: rect(1px 1px 1px 1px); /* IE6, IE7 */ clip: rect(1px,1px,1px,1px); }\\r\\n.webuploader-pick { position: relative; display: inline-block; cursor: pointer; background: #00b7ee; padding: 10px 15px; color: #fff; text-align: center; border-radius: 3px; overflow: hidden; }\\r\\n.webuploader-pick-hover { background: #00a2d4; }\\r\\n.webuploader-pick-disable { opacity: 0.6; pointer-events: none; }\\r\\n\", \"\"]);\n\n// exports\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvY29tcG9uZW50cy93ZWJ1cGxvYWRlci93ZWJ1cGxvYWRlci0wLjEuNS93ZWJ1cGxvYWRlci5jc3M/MWVlMSJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSwyQkFBMkIsbUJBQU8sQ0FBQyxDQUFxRDtBQUN4Rjs7O0FBR0E7QUFDQSxjQUFjLFFBQVMsMkJBQTJCLG9CQUFvQixFQUFFLG9DQUFvQywrQkFBK0IsNkJBQTZCLDRDQUE0QyxFQUFFLHVCQUF1QixvQkFBb0IsdUJBQXVCLGlCQUFpQixxQkFBcUIsb0JBQW9CLGFBQWEsb0JBQW9CLG9CQUFvQixrQkFBa0IsRUFBRSw2QkFBNkIscUJBQXFCLEVBQUUsK0JBQStCLGNBQWMsc0JBQXNCLEVBQUU7O0FBRXBoQiIsImZpbGUiOiI2NC5qcyIsInNvdXJjZXNDb250ZW50IjpbImV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCIuLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9saWIvY3NzLWJhc2UuanNcIikoZmFsc2UpO1xuLy8gaW1wb3J0c1xuXG5cbi8vIG1vZHVsZVxuZXhwb3J0cy5wdXNoKFttb2R1bGUuaWQsIFwiLndlYnVwbG9hZGVyLWNvbnRhaW5lciB7IHBvc2l0aW9uOiByZWxhdGl2ZTsgfVxcclxcbi53ZWJ1cGxvYWRlci1lbGVtZW50LWludmlzaWJsZSB7IHBvc2l0aW9uOiBhYnNvbHV0ZSAhaW1wb3J0YW50OyBjbGlwOiByZWN0KDFweCAxcHggMXB4IDFweCk7IC8qIElFNiwgSUU3ICovIGNsaXA6IHJlY3QoMXB4LDFweCwxcHgsMXB4KTsgfVxcclxcbi53ZWJ1cGxvYWRlci1waWNrIHsgcG9zaXRpb246IHJlbGF0aXZlOyBkaXNwbGF5OiBpbmxpbmUtYmxvY2s7IGN1cnNvcjogcG9pbnRlcjsgYmFja2dyb3VuZDogIzAwYjdlZTsgcGFkZGluZzogMTBweCAxNXB4OyBjb2xvcjogI2ZmZjsgdGV4dC1hbGlnbjogY2VudGVyOyBib3JkZXItcmFkaXVzOiAzcHg7IG92ZXJmbG93OiBoaWRkZW47IH1cXHJcXG4ud2VidXBsb2FkZXItcGljay1ob3ZlciB7IGJhY2tncm91bmQ6ICMwMGEyZDQ7IH1cXHJcXG4ud2VidXBsb2FkZXItcGljay1kaXNhYmxlIHsgb3BhY2l0eTogMC42OyBwb2ludGVyLWV2ZW50czogbm9uZTsgfVxcclxcblwiLCBcIlwiXSk7XG5cbi8vIGV4cG9ydHNcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIhLi9zcmMvY29tcG9uZW50cy93ZWJ1cGxvYWRlci93ZWJ1cGxvYWRlci0wLjEuNS93ZWJ1cGxvYWRlci5jc3Ncbi8vIG1vZHVsZSBpZCA9IDY0XG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///64\n");

/***/ }),
/* 65 */
/***/ (function(module, exports, __webpack_require__) {

eval("var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*!\n * jQuery JavaScript Library v3.4.1\n * https://jquery.com/\n *\n * Includes Sizzle.js\n * https://sizzlejs.com/\n *\n * Copyright JS Foundation and other contributors\n * Released under the MIT license\n * https://jquery.org/license\n *\n * Date: 2019-05-01T21:04Z\n */\n( function( global, factory ) {\n\n\t\"use strict\";\n\n\tif ( typeof module === \"object\" && typeof module.exports === \"object\" ) {\n\n\t\t// For CommonJS and CommonJS-like environments where a proper `window`\n\t\t// is present, execute the factory and get jQuery.\n\t\t// For environments that do not have a `window` with a `document`\n\t\t// (such as Node.js), expose a factory as module.exports.\n\t\t// This accentuates the need for the creation of a real `window`.\n\t\t// e.g. var jQuery = require(\"jquery\")(window);\n\t\t// See ticket #14549 for more info.\n\t\tmodule.exports = global.document ?\n\t\t\tfactory( global, true ) :\n\t\t\tfunction( w ) {\n\t\t\t\tif ( !w.document ) {\n\t\t\t\t\tthrow new Error( \"jQuery requires a window with a document\" );\n\t\t\t\t}\n\t\t\t\treturn factory( w );\n\t\t\t};\n\t} else {\n\t\tfactory( global );\n\t}\n\n// Pass this if window is not defined yet\n} )( typeof window !== \"undefined\" ? window : this, function( window, noGlobal ) {\n\n// Edge <= 12 - 13+, Firefox <=18 - 45+, IE 10 - 11, Safari 5.1 - 9+, iOS 6 - 9.1\n// throw exceptions when non-strict code (e.g., ASP.NET 4.5) accesses strict mode\n// arguments.callee.caller (trac-13335). But as of jQuery 3.0 (2016), strict mode should be common\n// enough that all such attempts are guarded in a try block.\n\"use strict\";\n\nvar arr = [];\n\nvar document = window.document;\n\nvar getProto = Object.getPrototypeOf;\n\nvar slice = arr.slice;\n\nvar concat = arr.concat;\n\nvar push = arr.push;\n\nvar indexOf = arr.indexOf;\n\nvar class2type = {};\n\nvar toString = class2type.toString;\n\nvar hasOwn = class2type.hasOwnProperty;\n\nvar fnToString = hasOwn.toString;\n\nvar ObjectFunctionString = fnToString.call( Object );\n\nvar support = {};\n\nvar isFunction = function isFunction( obj ) {\n\n      // Support: Chrome <=57, Firefox <=52\n      // In some browsers, typeof returns \"function\" for HTML <object> elements\n      // (i.e., `typeof document.createElement( \"object\" ) === \"function\"`).\n      // We don't want to classify *any* DOM node as a function.\n      return typeof obj === \"function\" && typeof obj.nodeType !== \"number\";\n  };\n\n\nvar isWindow = function isWindow( obj ) {\n\t\treturn obj != null && obj === obj.window;\n\t};\n\n\n\n\n\tvar preservedScriptAttributes = {\n\t\ttype: true,\n\t\tsrc: true,\n\t\tnonce: true,\n\t\tnoModule: true\n\t};\n\n\tfunction DOMEval( code, node, doc ) {\n\t\tdoc = doc || document;\n\n\t\tvar i, val,\n\t\t\tscript = doc.createElement( \"script\" );\n\n\t\tscript.text = code;\n\t\tif ( node ) {\n\t\t\tfor ( i in preservedScriptAttributes ) {\n\n\t\t\t\t// Support: Firefox 64+, Edge 18+\n\t\t\t\t// Some browsers don't support the \"nonce\" property on scripts.\n\t\t\t\t// On the other hand, just using `getAttribute` is not enough as\n\t\t\t\t// the `nonce` attribute is reset to an empty string whenever it\n\t\t\t\t// becomes browsing-context connected.\n\t\t\t\t// See https://github.com/whatwg/html/issues/2369\n\t\t\t\t// See https://html.spec.whatwg.org/#nonce-attributes\n\t\t\t\t// The `node.getAttribute` check was added for the sake of\n\t\t\t\t// `jQuery.globalEval` so that it can fake a nonce-containing node\n\t\t\t\t// via an object.\n\t\t\t\tval = node[ i ] || node.getAttribute && node.getAttribute( i );\n\t\t\t\tif ( val ) {\n\t\t\t\t\tscript.setAttribute( i, val );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tdoc.head.appendChild( script ).parentNode.removeChild( script );\n\t}\n\n\nfunction toType( obj ) {\n\tif ( obj == null ) {\n\t\treturn obj + \"\";\n\t}\n\n\t// Support: Android <=2.3 only (functionish RegExp)\n\treturn typeof obj === \"object\" || typeof obj === \"function\" ?\n\t\tclass2type[ toString.call( obj ) ] || \"object\" :\n\t\ttypeof obj;\n}\n/* global Symbol */\n// Defining this global in .eslintrc.json would create a danger of using the global\n// unguarded in another place, it seems safer to define global only for this module\n\n\n\nvar\n\tversion = \"3.4.1\",\n\n\t// Define a local copy of jQuery\n\tjQuery = function( selector, context ) {\n\n\t\t// The jQuery object is actually just the init constructor 'enhanced'\n\t\t// Need init if jQuery is called (just allow error to be thrown if not included)\n\t\treturn new jQuery.fn.init( selector, context );\n\t},\n\n\t// Support: Android <=4.0 only\n\t// Make sure we trim BOM and NBSP\n\trtrim = /^[\\s\\uFEFF\\xA0]+|[\\s\\uFEFF\\xA0]+$/g;\n\njQuery.fn = jQuery.prototype = {\n\n\t// The current version of jQuery being used\n\tjquery: version,\n\n\tconstructor: jQuery,\n\n\t// The default length of a jQuery object is 0\n\tlength: 0,\n\n\ttoArray: function() {\n\t\treturn slice.call( this );\n\t},\n\n\t// Get the Nth element in the matched element set OR\n\t// Get the whole matched element set as a clean array\n\tget: function( num ) {\n\n\t\t// Return all the elements in a clean array\n\t\tif ( num == null ) {\n\t\t\treturn slice.call( this );\n\t\t}\n\n\t\t// Return just the one element from the set\n\t\treturn num < 0 ? this[ num + this.length ] : this[ num ];\n\t},\n\n\t// Take an array of elements and push it onto the stack\n\t// (returning the new matched element set)\n\tpushStack: function( elems ) {\n\n\t\t// Build a new jQuery matched element set\n\t\tvar ret = jQuery.merge( this.constructor(), elems );\n\n\t\t// Add the old object onto the stack (as a reference)\n\t\tret.prevObject = this;\n\n\t\t// Return the newly-formed element set\n\t\treturn ret;\n\t},\n\n\t// Execute a callback for every element in the matched set.\n\teach: function( callback ) {\n\t\treturn jQuery.each( this, callback );\n\t},\n\n\tmap: function( callback ) {\n\t\treturn this.pushStack( jQuery.map( this, function( elem, i ) {\n\t\t\treturn callback.call( elem, i, elem );\n\t\t} ) );\n\t},\n\n\tslice: function() {\n\t\treturn this.pushStack( slice.apply( this, arguments ) );\n\t},\n\n\tfirst: function() {\n\t\treturn this.eq( 0 );\n\t},\n\n\tlast: function() {\n\t\treturn this.eq( -1 );\n\t},\n\n\teq: function( i ) {\n\t\tvar len = this.length,\n\t\t\tj = +i + ( i < 0 ? len : 0 );\n\t\treturn this.pushStack( j >= 0 && j < len ? [ this[ j ] ] : [] );\n\t},\n\n\tend: function() {\n\t\treturn this.prevObject || this.constructor();\n\t},\n\n\t// For internal use only.\n\t// Behaves like an Array's method, not like a jQuery method.\n\tpush: push,\n\tsort: arr.sort,\n\tsplice: arr.splice\n};\n\njQuery.extend = jQuery.fn.extend = function() {\n\tvar options, name, src, copy, copyIsArray, clone,\n\t\ttarget = arguments[ 0 ] || {},\n\t\ti = 1,\n\t\tlength = arguments.length,\n\t\tdeep = false;\n\n\t// Handle a deep copy situation\n\tif ( typeof target === \"boolean\" ) {\n\t\tdeep = target;\n\n\t\t// Skip the boolean and the target\n\t\ttarget = arguments[ i ] || {};\n\t\ti++;\n\t}\n\n\t// Handle case when target is a string or something (possible in deep copy)\n\tif ( typeof target !== \"object\" && !isFunction( target ) ) {\n\t\ttarget = {};\n\t}\n\n\t// Extend jQuery itself if only one argument is passed\n\tif ( i === length ) {\n\t\ttarget = this;\n\t\ti--;\n\t}\n\n\tfor ( ; i < length; i++ ) {\n\n\t\t// Only deal with non-null/undefined values\n\t\tif ( ( options = arguments[ i ] ) != null ) {\n\n\t\t\t// Extend the base object\n\t\t\tfor ( name in options ) {\n\t\t\t\tcopy = options[ name ];\n\n\t\t\t\t// Prevent Object.prototype pollution\n\t\t\t\t// Prevent never-ending loop\n\t\t\t\tif ( name === \"__proto__\" || target === copy ) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\t// Recurse if we're merging plain objects or arrays\n\t\t\t\tif ( deep && copy && ( jQuery.isPlainObject( copy ) ||\n\t\t\t\t\t( copyIsArray = Array.isArray( copy ) ) ) ) {\n\t\t\t\t\tsrc = target[ name ];\n\n\t\t\t\t\t// Ensure proper type for the source value\n\t\t\t\t\tif ( copyIsArray && !Array.isArray( src ) ) {\n\t\t\t\t\t\tclone = [];\n\t\t\t\t\t} else if ( !copyIsArray && !jQuery.isPlainObject( src ) ) {\n\t\t\t\t\t\tclone = {};\n\t\t\t\t\t} else {\n\t\t\t\t\t\tclone = src;\n\t\t\t\t\t}\n\t\t\t\t\tcopyIsArray = false;\n\n\t\t\t\t\t// Never move original objects, clone them\n\t\t\t\t\ttarget[ name ] = jQuery.extend( deep, clone, copy );\n\n\t\t\t\t// Don't bring in undefined values\n\t\t\t\t} else if ( copy !== undefined ) {\n\t\t\t\t\ttarget[ name ] = copy;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t// Return the modified object\n\treturn target;\n};\n\njQuery.extend( {\n\n\t// Unique for each copy of jQuery on the page\n\texpando: \"jQuery\" + ( version + Math.random() ).replace( /\\D/g, \"\" ),\n\n\t// Assume jQuery is ready without the ready module\n\tisReady: true,\n\n\terror: function( msg ) {\n\t\tthrow new Error( msg );\n\t},\n\n\tnoop: function() {},\n\n\tisPlainObject: function( obj ) {\n\t\tvar proto, Ctor;\n\n\t\t// Detect obvious negatives\n\t\t// Use toString instead of jQuery.type to catch host objects\n\t\tif ( !obj || toString.call( obj ) !== \"[object Object]\" ) {\n\t\t\treturn false;\n\t\t}\n\n\t\tproto = getProto( obj );\n\n\t\t// Objects with no prototype (e.g., `Object.create( null )`) are plain\n\t\tif ( !proto ) {\n\t\t\treturn true;\n\t\t}\n\n\t\t// Objects with prototype are plain iff they were constructed by a global Object function\n\t\tCtor = hasOwn.call( proto, \"constructor\" ) && proto.constructor;\n\t\treturn typeof Ctor === \"function\" && fnToString.call( Ctor ) === ObjectFunctionString;\n\t},\n\n\tisEmptyObject: function( obj ) {\n\t\tvar name;\n\n\t\tfor ( name in obj ) {\n\t\t\treturn false;\n\t\t}\n\t\treturn true;\n\t},\n\n\t// Evaluates a script in a global context\n\tglobalEval: function( code, options ) {\n\t\tDOMEval( code, { nonce: options && options.nonce } );\n\t},\n\n\teach: function( obj, callback ) {\n\t\tvar length, i = 0;\n\n\t\tif ( isArrayLike( obj ) ) {\n\t\t\tlength = obj.length;\n\t\t\tfor ( ; i < length; i++ ) {\n\t\t\t\tif ( callback.call( obj[ i ], i, obj[ i ] ) === false ) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tfor ( i in obj ) {\n\t\t\t\tif ( callback.call( obj[ i ], i, obj[ i ] ) === false ) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn obj;\n\t},\n\n\t// Support: Android <=4.0 only\n\ttrim: function( text ) {\n\t\treturn text == null ?\n\t\t\t\"\" :\n\t\t\t( text + \"\" ).replace( rtrim, \"\" );\n\t},\n\n\t// results is for internal usage only\n\tmakeArray: function( arr, results ) {\n\t\tvar ret = results || [];\n\n\t\tif ( arr != null ) {\n\t\t\tif ( isArrayLike( Object( arr ) ) ) {\n\t\t\t\tjQuery.merge( ret,\n\t\t\t\t\ttypeof arr === \"string\" ?\n\t\t\t\t\t[ arr ] : arr\n\t\t\t\t);\n\t\t\t} else {\n\t\t\t\tpush.call( ret, arr );\n\t\t\t}\n\t\t}\n\n\t\treturn ret;\n\t},\n\n\tinArray: function( elem, arr, i ) {\n\t\treturn arr == null ? -1 : indexOf.call( arr, elem, i );\n\t},\n\n\t// Support: Android <=4.0 only, PhantomJS 1 only\n\t// push.apply(_, arraylike) throws on ancient WebKit\n\tmerge: function( first, second ) {\n\t\tvar len = +second.length,\n\t\t\tj = 0,\n\t\t\ti = first.length;\n\n\t\tfor ( ; j < len; j++ ) {\n\t\t\tfirst[ i++ ] = second[ j ];\n\t\t}\n\n\t\tfirst.length = i;\n\n\t\treturn first;\n\t},\n\n\tgrep: function( elems, callback, invert ) {\n\t\tvar callbackInverse,\n\t\t\tmatches = [],\n\t\t\ti = 0,\n\t\t\tlength = elems.length,\n\t\t\tcallbackExpect = !invert;\n\n\t\t// Go through the array, only saving the items\n\t\t// that pass the validator function\n\t\tfor ( ; i < length; i++ ) {\n\t\t\tcallbackInverse = !callback( elems[ i ], i );\n\t\t\tif ( callbackInverse !== callbackExpect ) {\n\t\t\t\tmatches.push( elems[ i ] );\n\t\t\t}\n\t\t}\n\n\t\treturn matches;\n\t},\n\n\t// arg is for internal usage only\n\tmap: function( elems, callback, arg ) {\n\t\tvar length, value,\n\t\t\ti = 0,\n\t\t\tret = [];\n\n\t\t// Go through the array, translating each of the items to their new values\n\t\tif ( isArrayLike( elems ) ) {\n\t\t\tlength = elems.length;\n\t\t\tfor ( ; i < length; i++ ) {\n\t\t\t\tvalue = callback( elems[ i ], i, arg );\n\n\t\t\t\tif ( value != null ) {\n\t\t\t\t\tret.push( value );\n\t\t\t\t}\n\t\t\t}\n\n\t\t// Go through every key on the object,\n\t\t} else {\n\t\t\tfor ( i in elems ) {\n\t\t\t\tvalue = callback( elems[ i ], i, arg );\n\n\t\t\t\tif ( value != null ) {\n\t\t\t\t\tret.push( value );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Flatten any nested arrays\n\t\treturn concat.apply( [], ret );\n\t},\n\n\t// A global GUID counter for objects\n\tguid: 1,\n\n\t// jQuery.support is not used in Core but other projects attach their\n\t// properties to it so it needs to exist.\n\tsupport: support\n} );\n\nif ( typeof Symbol === \"function\" ) {\n\tjQuery.fn[ Symbol.iterator ] = arr[ Symbol.iterator ];\n}\n\n// Populate the class2type map\njQuery.each( \"Boolean Number String Function Array Date RegExp Object Error Symbol\".split( \" \" ),\nfunction( i, name ) {\n\tclass2type[ \"[object \" + name + \"]\" ] = name.toLowerCase();\n} );\n\nfunction isArrayLike( obj ) {\n\n\t// Support: real iOS 8.2 only (not reproducible in simulator)\n\t// `in` check used to prevent JIT error (gh-2145)\n\t// hasOwn isn't used here due to false negatives\n\t// regarding Nodelist length in IE\n\tvar length = !!obj && \"length\" in obj && obj.length,\n\t\ttype = toType( obj );\n\n\tif ( isFunction( obj ) || isWindow( obj ) ) {\n\t\treturn false;\n\t}\n\n\treturn type === \"array\" || length === 0 ||\n\t\ttypeof length === \"number\" && length > 0 && ( length - 1 ) in obj;\n}\nvar Sizzle =\n/*!\n * Sizzle CSS Selector Engine v2.3.4\n * https://sizzlejs.com/\n *\n * Copyright JS Foundation and other contributors\n * Released under the MIT license\n * https://js.foundation/\n *\n * Date: 2019-04-08\n */\n(function( window ) {\n\nvar i,\n\tsupport,\n\tExpr,\n\tgetText,\n\tisXML,\n\ttokenize,\n\tcompile,\n\tselect,\n\toutermostContext,\n\tsortInput,\n\thasDuplicate,\n\n\t// Local document vars\n\tsetDocument,\n\tdocument,\n\tdocElem,\n\tdocumentIsHTML,\n\trbuggyQSA,\n\trbuggyMatches,\n\tmatches,\n\tcontains,\n\n\t// Instance-specific data\n\texpando = \"sizzle\" + 1 * new Date(),\n\tpreferredDoc = window.document,\n\tdirruns = 0,\n\tdone = 0,\n\tclassCache = createCache(),\n\ttokenCache = createCache(),\n\tcompilerCache = createCache(),\n\tnonnativeSelectorCache = createCache(),\n\tsortOrder = function( a, b ) {\n\t\tif ( a === b ) {\n\t\t\thasDuplicate = true;\n\t\t}\n\t\treturn 0;\n\t},\n\n\t// Instance methods\n\thasOwn = ({}).hasOwnProperty,\n\tarr = [],\n\tpop = arr.pop,\n\tpush_native = arr.push,\n\tpush = arr.push,\n\tslice = arr.slice,\n\t// Use a stripped-down indexOf as it's faster than native\n\t// https://jsperf.com/thor-indexof-vs-for/5\n\tindexOf = function( list, elem ) {\n\t\tvar i = 0,\n\t\t\tlen = list.length;\n\t\tfor ( ; i < len; i++ ) {\n\t\t\tif ( list[i] === elem ) {\n\t\t\t\treturn i;\n\t\t\t}\n\t\t}\n\t\treturn -1;\n\t},\n\n\tbooleans = \"checked|selected|async|autofocus|autoplay|controls|defer|disabled|hidden|ismap|loop|multiple|open|readonly|required|scoped\",\n\n\t// Regular expressions\n\n\t// http://www.w3.org/TR/css3-selectors/#whitespace\n\twhitespace = \"[\\\\x20\\\\t\\\\r\\\\n\\\\f]\",\n\n\t// http://www.w3.org/TR/CSS21/syndata.html#value-def-identifier\n\tidentifier = \"(?:\\\\\\\\.|[\\\\w-]|[^\\0-\\\\xa0])+\",\n\n\t// Attribute selectors: http://www.w3.org/TR/selectors/#attribute-selectors\n\tattributes = \"\\\\[\" + whitespace + \"*(\" + identifier + \")(?:\" + whitespace +\n\t\t// Operator (capture 2)\n\t\t\"*([*^$|!~]?=)\" + whitespace +\n\t\t// \"Attribute values must be CSS identifiers [capture 5] or strings [capture 3 or capture 4]\"\n\t\t\"*(?:'((?:\\\\\\\\.|[^\\\\\\\\'])*)'|\\\"((?:\\\\\\\\.|[^\\\\\\\\\\\"])*)\\\"|(\" + identifier + \"))|)\" + whitespace +\n\t\t\"*\\\\]\",\n\n\tpseudos = \":(\" + identifier + \")(?:\\\\((\" +\n\t\t// To reduce the number of selectors needing tokenize in the preFilter, prefer arguments:\n\t\t// 1. quoted (capture 3; capture 4 or capture 5)\n\t\t\"('((?:\\\\\\\\.|[^\\\\\\\\'])*)'|\\\"((?:\\\\\\\\.|[^\\\\\\\\\\\"])*)\\\")|\" +\n\t\t// 2. simple (capture 6)\n\t\t\"((?:\\\\\\\\.|[^\\\\\\\\()[\\\\]]|\" + attributes + \")*)|\" +\n\t\t// 3. anything else (capture 2)\n\t\t\".*\" +\n\t\t\")\\\\)|)\",\n\n\t// Leading and non-escaped trailing whitespace, capturing some non-whitespace characters preceding the latter\n\trwhitespace = new RegExp( whitespace + \"+\", \"g\" ),\n\trtrim = new RegExp( \"^\" + whitespace + \"+|((?:^|[^\\\\\\\\])(?:\\\\\\\\.)*)\" + whitespace + \"+$\", \"g\" ),\n\n\trcomma = new RegExp( \"^\" + whitespace + \"*,\" + whitespace + \"*\" ),\n\trcombinators = new RegExp( \"^\" + whitespace + \"*([>+~]|\" + whitespace + \")\" + whitespace + \"*\" ),\n\trdescend = new RegExp( whitespace + \"|>\" ),\n\n\trpseudo = new RegExp( pseudos ),\n\tridentifier = new RegExp( \"^\" + identifier + \"$\" ),\n\n\tmatchExpr = {\n\t\t\"ID\": new RegExp( \"^#(\" + identifier + \")\" ),\n\t\t\"CLASS\": new RegExp( \"^\\\\.(\" + identifier + \")\" ),\n\t\t\"TAG\": new RegExp( \"^(\" + identifier + \"|[*])\" ),\n\t\t\"ATTR\": new RegExp( \"^\" + attributes ),\n\t\t\"PSEUDO\": new RegExp( \"^\" + pseudos ),\n\t\t\"CHILD\": new RegExp( \"^:(only|first|last|nth|nth-last)-(child|of-type)(?:\\\\(\" + whitespace +\n\t\t\t\"*(even|odd|(([+-]|)(\\\\d*)n|)\" + whitespace + \"*(?:([+-]|)\" + whitespace +\n\t\t\t\"*(\\\\d+)|))\" + whitespace + \"*\\\\)|)\", \"i\" ),\n\t\t\"bool\": new RegExp( \"^(?:\" + booleans + \")$\", \"i\" ),\n\t\t// For use in libraries implementing .is()\n\t\t// We use this for POS matching in `select`\n\t\t\"needsContext\": new RegExp( \"^\" + whitespace + \"*[>+~]|:(even|odd|eq|gt|lt|nth|first|last)(?:\\\\(\" +\n\t\t\twhitespace + \"*((?:-\\\\d)?\\\\d*)\" + whitespace + \"*\\\\)|)(?=[^-]|$)\", \"i\" )\n\t},\n\n\trhtml = /HTML$/i,\n\trinputs = /^(?:input|select|textarea|button)$/i,\n\trheader = /^h\\d$/i,\n\n\trnative = /^[^{]+\\{\\s*\\[native \\w/,\n\n\t// Easily-parseable/retrievable ID or TAG or CLASS selectors\n\trquickExpr = /^(?:#([\\w-]+)|(\\w+)|\\.([\\w-]+))$/,\n\n\trsibling = /[+~]/,\n\n\t// CSS escapes\n\t// http://www.w3.org/TR/CSS21/syndata.html#escaped-characters\n\trunescape = new RegExp( \"\\\\\\\\([\\\\da-f]{1,6}\" + whitespace + \"?|(\" + whitespace + \")|.)\", \"ig\" ),\n\tfunescape = function( _, escaped, escapedWhitespace ) {\n\t\tvar high = \"0x\" + escaped - 0x10000;\n\t\t// NaN means non-codepoint\n\t\t// Support: Firefox<24\n\t\t// Workaround erroneous numeric interpretation of +\"0x\"\n\t\treturn high !== high || escapedWhitespace ?\n\t\t\tescaped :\n\t\t\thigh < 0 ?\n\t\t\t\t// BMP codepoint\n\t\t\t\tString.fromCharCode( high + 0x10000 ) :\n\t\t\t\t// Supplemental Plane codepoint (surrogate pair)\n\t\t\t\tString.fromCharCode( high >> 10 | 0xD800, high & 0x3FF | 0xDC00 );\n\t},\n\n\t// CSS string/identifier serialization\n\t// https://drafts.csswg.org/cssom/#common-serializing-idioms\n\trcssescape = /([\\0-\\x1f\\x7f]|^-?\\d)|^-$|[^\\0-\\x1f\\x7f-\\uFFFF\\w-]/g,\n\tfcssescape = function( ch, asCodePoint ) {\n\t\tif ( asCodePoint ) {\n\n\t\t\t// U+0000 NULL becomes U+FFFD REPLACEMENT CHARACTER\n\t\t\tif ( ch === \"\\0\" ) {\n\t\t\t\treturn \"\\uFFFD\";\n\t\t\t}\n\n\t\t\t// Control characters and (dependent upon position) numbers get escaped as code points\n\t\t\treturn ch.slice( 0, -1 ) + \"\\\\\" + ch.charCodeAt( ch.length - 1 ).toString( 16 ) + \" \";\n\t\t}\n\n\t\t// Other potentially-special ASCII characters get backslash-escaped\n\t\treturn \"\\\\\" + ch;\n\t},\n\n\t// Used for iframes\n\t// See setDocument()\n\t// Removing the function wrapper causes a \"Permission Denied\"\n\t// error in IE\n\tunloadHandler = function() {\n\t\tsetDocument();\n\t},\n\n\tinDisabledFieldset = addCombinator(\n\t\tfunction( elem ) {\n\t\t\treturn elem.disabled === true && elem.nodeName.toLowerCase() === \"fieldset\";\n\t\t},\n\t\t{ dir: \"parentNode\", next: \"legend\" }\n\t);\n\n// Optimize for push.apply( _, NodeList )\ntry {\n\tpush.apply(\n\t\t(arr = slice.call( preferredDoc.childNodes )),\n\t\tpreferredDoc.childNodes\n\t);\n\t// Support: Android<4.0\n\t// Detect silently failing push.apply\n\tarr[ preferredDoc.childNodes.length ].nodeType;\n} catch ( e ) {\n\tpush = { apply: arr.length ?\n\n\t\t// Leverage slice if possible\n\t\tfunction( target, els ) {\n\t\t\tpush_native.apply( target, slice.call(els) );\n\t\t} :\n\n\t\t// Support: IE<9\n\t\t// Otherwise append directly\n\t\tfunction( target, els ) {\n\t\t\tvar j = target.length,\n\t\t\t\ti = 0;\n\t\t\t// Can't trust NodeList.length\n\t\t\twhile ( (target[j++] = els[i++]) ) {}\n\t\t\ttarget.length = j - 1;\n\t\t}\n\t};\n}\n\nfunction Sizzle( selector, context, results, seed ) {\n\tvar m, i, elem, nid, match, groups, newSelector,\n\t\tnewContext = context && context.ownerDocument,\n\n\t\t// nodeType defaults to 9, since context defaults to document\n\t\tnodeType = context ? context.nodeType : 9;\n\n\tresults = results || [];\n\n\t// Return early from calls with invalid selector or context\n\tif ( typeof selector !== \"string\" || !selector ||\n\t\tnodeType !== 1 && nodeType !== 9 && nodeType !== 11 ) {\n\n\t\treturn results;\n\t}\n\n\t// Try to shortcut find operations (as opposed to filters) in HTML documents\n\tif ( !seed ) {\n\n\t\tif ( ( context ? context.ownerDocument || context : preferredDoc ) !== document ) {\n\t\t\tsetDocument( context );\n\t\t}\n\t\tcontext = context || document;\n\n\t\tif ( documentIsHTML ) {\n\n\t\t\t// If the selector is sufficiently simple, try using a \"get*By*\" DOM method\n\t\t\t// (excepting DocumentFragment context, where the methods don't exist)\n\t\t\tif ( nodeType !== 11 && (match = rquickExpr.exec( selector )) ) {\n\n\t\t\t\t// ID selector\n\t\t\t\tif ( (m = match[1]) ) {\n\n\t\t\t\t\t// Document context\n\t\t\t\t\tif ( nodeType === 9 ) {\n\t\t\t\t\t\tif ( (elem = context.getElementById( m )) ) {\n\n\t\t\t\t\t\t\t// Support: IE, Opera, Webkit\n\t\t\t\t\t\t\t// TODO: identify versions\n\t\t\t\t\t\t\t// getElementById can match elements by name instead of ID\n\t\t\t\t\t\t\tif ( elem.id === m ) {\n\t\t\t\t\t\t\t\tresults.push( elem );\n\t\t\t\t\t\t\t\treturn results;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\treturn results;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t// Element context\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\t// Support: IE, Opera, Webkit\n\t\t\t\t\t\t// TODO: identify versions\n\t\t\t\t\t\t// getElementById can match elements by name instead of ID\n\t\t\t\t\t\tif ( newContext && (elem = newContext.getElementById( m )) &&\n\t\t\t\t\t\t\tcontains( context, elem ) &&\n\t\t\t\t\t\t\telem.id === m ) {\n\n\t\t\t\t\t\t\tresults.push( elem );\n\t\t\t\t\t\t\treturn results;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t// Type selector\n\t\t\t\t} else if ( match[2] ) {\n\t\t\t\t\tpush.apply( results, context.getElementsByTagName( selector ) );\n\t\t\t\t\treturn results;\n\n\t\t\t\t// Class selector\n\t\t\t\t} else if ( (m = match[3]) && support.getElementsByClassName &&\n\t\t\t\t\tcontext.getElementsByClassName ) {\n\n\t\t\t\t\tpush.apply( results, context.getElementsByClassName( m ) );\n\t\t\t\t\treturn results;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Take advantage of querySelectorAll\n\t\t\tif ( support.qsa &&\n\t\t\t\t!nonnativeSelectorCache[ selector + \" \" ] &&\n\t\t\t\t(!rbuggyQSA || !rbuggyQSA.test( selector )) &&\n\n\t\t\t\t// Support: IE 8 only\n\t\t\t\t// Exclude object elements\n\t\t\t\t(nodeType !== 1 || context.nodeName.toLowerCase() !== \"object\") ) {\n\n\t\t\t\tnewSelector = selector;\n\t\t\t\tnewContext = context;\n\n\t\t\t\t// qSA considers elements outside a scoping root when evaluating child or\n\t\t\t\t// descendant combinators, which is not what we want.\n\t\t\t\t// In such cases, we work around the behavior by prefixing every selector in the\n\t\t\t\t// list with an ID selector referencing the scope context.\n\t\t\t\t// Thanks to Andrew Dupont for this technique.\n\t\t\t\tif ( nodeType === 1 && rdescend.test( selector ) ) {\n\n\t\t\t\t\t// Capture the context ID, setting it first if necessary\n\t\t\t\t\tif ( (nid = context.getAttribute( \"id\" )) ) {\n\t\t\t\t\t\tnid = nid.replace( rcssescape, fcssescape );\n\t\t\t\t\t} else {\n\t\t\t\t\t\tcontext.setAttribute( \"id\", (nid = expando) );\n\t\t\t\t\t}\n\n\t\t\t\t\t// Prefix every selector in the list\n\t\t\t\t\tgroups = tokenize( selector );\n\t\t\t\t\ti = groups.length;\n\t\t\t\t\twhile ( i-- ) {\n\t\t\t\t\t\tgroups[i] = \"#\" + nid + \" \" + toSelector( groups[i] );\n\t\t\t\t\t}\n\t\t\t\t\tnewSelector = groups.join( \",\" );\n\n\t\t\t\t\t// Expand context for sibling selectors\n\t\t\t\t\tnewContext = rsibling.test( selector ) && testContext( context.parentNode ) ||\n\t\t\t\t\t\tcontext;\n\t\t\t\t}\n\n\t\t\t\ttry {\n\t\t\t\t\tpush.apply( results,\n\t\t\t\t\t\tnewContext.querySelectorAll( newSelector )\n\t\t\t\t\t);\n\t\t\t\t\treturn results;\n\t\t\t\t} catch ( qsaError ) {\n\t\t\t\t\tnonnativeSelectorCache( selector, true );\n\t\t\t\t} finally {\n\t\t\t\t\tif ( nid === expando ) {\n\t\t\t\t\t\tcontext.removeAttribute( \"id\" );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t// All others\n\treturn select( selector.replace( rtrim, \"$1\" ), context, results, seed );\n}\n\n/**\n * Create key-value caches of limited size\n * @returns {function(string, object)} Returns the Object data after storing it on itself with\n *\tproperty name the (space-suffixed) string and (if the cache is larger than Expr.cacheLength)\n *\tdeleting the oldest entry\n */\nfunction createCache() {\n\tvar keys = [];\n\n\tfunction cache( key, value ) {\n\t\t// Use (key + \" \") to avoid collision with native prototype properties (see Issue #157)\n\t\tif ( keys.push( key + \" \" ) > Expr.cacheLength ) {\n\t\t\t// Only keep the most recent entries\n\t\t\tdelete cache[ keys.shift() ];\n\t\t}\n\t\treturn (cache[ key + \" \" ] = value);\n\t}\n\treturn cache;\n}\n\n/**\n * Mark a function for special use by Sizzle\n * @param {Function} fn The function to mark\n */\nfunction markFunction( fn ) {\n\tfn[ expando ] = true;\n\treturn fn;\n}\n\n/**\n * Support testing using an element\n * @param {Function} fn Passed the created element and returns a boolean result\n */\nfunction assert( fn ) {\n\tvar el = document.createElement(\"fieldset\");\n\n\ttry {\n\t\treturn !!fn( el );\n\t} catch (e) {\n\t\treturn false;\n\t} finally {\n\t\t// Remove from its parent by default\n\t\tif ( el.parentNode ) {\n\t\t\tel.parentNode.removeChild( el );\n\t\t}\n\t\t// release memory in IE\n\t\tel = null;\n\t}\n}\n\n/**\n * Adds the same handler for all of the specified attrs\n * @param {String} attrs Pipe-separated list of attributes\n * @param {Function} handler The method that will be applied\n */\nfunction addHandle( attrs, handler ) {\n\tvar arr = attrs.split(\"|\"),\n\t\ti = arr.length;\n\n\twhile ( i-- ) {\n\t\tExpr.attrHandle[ arr[i] ] = handler;\n\t}\n}\n\n/**\n * Checks document order of two siblings\n * @param {Element} a\n * @param {Element} b\n * @returns {Number} Returns less than 0 if a precedes b, greater than 0 if a follows b\n */\nfunction siblingCheck( a, b ) {\n\tvar cur = b && a,\n\t\tdiff = cur && a.nodeType === 1 && b.nodeType === 1 &&\n\t\t\ta.sourceIndex - b.sourceIndex;\n\n\t// Use IE sourceIndex if available on both nodes\n\tif ( diff ) {\n\t\treturn diff;\n\t}\n\n\t// Check if b follows a\n\tif ( cur ) {\n\t\twhile ( (cur = cur.nextSibling) ) {\n\t\t\tif ( cur === b ) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn a ? 1 : -1;\n}\n\n/**\n * Returns a function to use in pseudos for input types\n * @param {String} type\n */\nfunction createInputPseudo( type ) {\n\treturn function( elem ) {\n\t\tvar name = elem.nodeName.toLowerCase();\n\t\treturn name === \"input\" && elem.type === type;\n\t};\n}\n\n/**\n * Returns a function to use in pseudos for buttons\n * @param {String} type\n */\nfunction createButtonPseudo( type ) {\n\treturn function( elem ) {\n\t\tvar name = elem.nodeName.toLowerCase();\n\t\treturn (name === \"input\" || name === \"button\") && elem.type === type;\n\t};\n}\n\n/**\n * Returns a function to use in pseudos for :enabled/:disabled\n * @param {Boolean} disabled true for :disabled; false for :enabled\n */\nfunction createDisabledPseudo( disabled ) {\n\n\t// Known :disabled false positives: fieldset[disabled] > legend:nth-of-type(n+2) :can-disable\n\treturn function( elem ) {\n\n\t\t// Only certain elements can match :enabled or :disabled\n\t\t// https://html.spec.whatwg.org/multipage/scripting.html#selector-enabled\n\t\t// https://html.spec.whatwg.org/multipage/scripting.html#selector-disabled\n\t\tif ( \"form\" in elem ) {\n\n\t\t\t// Check for inherited disabledness on relevant non-disabled elements:\n\t\t\t// * listed form-associated elements in a disabled fieldset\n\t\t\t//   https://html.spec.whatwg.org/multipage/forms.html#category-listed\n\t\t\t//   https://html.spec.whatwg.org/multipage/forms.html#concept-fe-disabled\n\t\t\t// * option elements in a disabled optgroup\n\t\t\t//   https://html.spec.whatwg.org/multipage/forms.html#concept-option-disabled\n\t\t\t// All such elements have a \"form\" property.\n\t\t\tif ( elem.parentNode && elem.disabled === false ) {\n\n\t\t\t\t// Option elements defer to a parent optgroup if present\n\t\t\t\tif ( \"label\" in elem ) {\n\t\t\t\t\tif ( \"label\" in elem.parentNode ) {\n\t\t\t\t\t\treturn elem.parentNode.disabled === disabled;\n\t\t\t\t\t} else {\n\t\t\t\t\t\treturn elem.disabled === disabled;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// Support: IE 6 - 11\n\t\t\t\t// Use the isDisabled shortcut property to check for disabled fieldset ancestors\n\t\t\t\treturn elem.isDisabled === disabled ||\n\n\t\t\t\t\t// Where there is no isDisabled, check manually\n\t\t\t\t\t/* jshint -W018 */\n\t\t\t\t\telem.isDisabled !== !disabled &&\n\t\t\t\t\t\tinDisabledFieldset( elem ) === disabled;\n\t\t\t}\n\n\t\t\treturn elem.disabled === disabled;\n\n\t\t// Try to winnow out elements that can't be disabled before trusting the disabled property.\n\t\t// Some victims get caught in our net (label, legend, menu, track), but it shouldn't\n\t\t// even exist on them, let alone have a boolean value.\n\t\t} else if ( \"label\" in elem ) {\n\t\t\treturn elem.disabled === disabled;\n\t\t}\n\n\t\t// Remaining elements are neither :enabled nor :disabled\n\t\treturn false;\n\t};\n}\n\n/**\n * Returns a function to use in pseudos for positionals\n * @param {Function} fn\n */\nfunction createPositionalPseudo( fn ) {\n\treturn markFunction(function( argument ) {\n\t\targument = +argument;\n\t\treturn markFunction(function( seed, matches ) {\n\t\t\tvar j,\n\t\t\t\tmatchIndexes = fn( [], seed.length, argument ),\n\t\t\t\ti = matchIndexes.length;\n\n\t\t\t// Match elements found at the specified indexes\n\t\t\twhile ( i-- ) {\n\t\t\t\tif ( seed[ (j = matchIndexes[i]) ] ) {\n\t\t\t\t\tseed[j] = !(matches[j] = seed[j]);\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t});\n}\n\n/**\n * Checks a node for validity as a Sizzle context\n * @param {Element|Object=} context\n * @returns {Element|Object|Boolean} The input node if acceptable, otherwise a falsy value\n */\nfunction testContext( context ) {\n\treturn context && typeof context.getElementsByTagName !== \"undefined\" && context;\n}\n\n// Expose support vars for convenience\nsupport = Sizzle.support = {};\n\n/**\n * Detects XML nodes\n * @param {Element|Object} elem An element or a document\n * @returns {Boolean} True iff elem is a non-HTML XML node\n */\nisXML = Sizzle.isXML = function( elem ) {\n\tvar namespace = elem.namespaceURI,\n\t\tdocElem = (elem.ownerDocument || elem).documentElement;\n\n\t// Support: IE <=8\n\t// Assume HTML when documentElement doesn't yet exist, such as inside loading iframes\n\t// https://bugs.jquery.com/ticket/4833\n\treturn !rhtml.test( namespace || docElem && docElem.nodeName || \"HTML\" );\n};\n\n/**\n * Sets document-related variables once based on the current document\n * @param {Element|Object} [doc] An element or document object to use to set the document\n * @returns {Object} Returns the current document\n */\nsetDocument = Sizzle.setDocument = function( node ) {\n\tvar hasCompare, subWindow,\n\t\tdoc = node ? node.ownerDocument || node : preferredDoc;\n\n\t// Return early if doc is invalid or already selected\n\tif ( doc === document || doc.nodeType !== 9 || !doc.documentElement ) {\n\t\treturn document;\n\t}\n\n\t// Update global variables\n\tdocument = doc;\n\tdocElem = document.documentElement;\n\tdocumentIsHTML = !isXML( document );\n\n\t// Support: IE 9-11, Edge\n\t// Accessing iframe documents after unload throws \"permission denied\" errors (jQuery #13936)\n\tif ( preferredDoc !== document &&\n\t\t(subWindow = document.defaultView) && subWindow.top !== subWindow ) {\n\n\t\t// Support: IE 11, Edge\n\t\tif ( subWindow.addEventListener ) {\n\t\t\tsubWindow.addEventListener( \"unload\", unloadHandler, false );\n\n\t\t// Support: IE 9 - 10 only\n\t\t} else if ( subWindow.attachEvent ) {\n\t\t\tsubWindow.attachEvent( \"onunload\", unloadHandler );\n\t\t}\n\t}\n\n\t/* Attributes\n\t---------------------------------------------------------------------- */\n\n\t// Support: IE<8\n\t// Verify that getAttribute really returns attributes and not properties\n\t// (excepting IE8 booleans)\n\tsupport.attributes = assert(function( el ) {\n\t\tel.className = \"i\";\n\t\treturn !el.getAttribute(\"className\");\n\t});\n\n\t/* getElement(s)By*\n\t---------------------------------------------------------------------- */\n\n\t// Check if getElementsByTagName(\"*\") returns only elements\n\tsupport.getElementsByTagName = assert(function( el ) {\n\t\tel.appendChild( document.createComment(\"\") );\n\t\treturn !el.getElementsByTagName(\"*\").length;\n\t});\n\n\t// Support: IE<9\n\tsupport.getElementsByClassName = rnative.test( document.getElementsByClassName );\n\n\t// Support: IE<10\n\t// Check if getElementById returns elements by name\n\t// The broken getElementById methods don't pick up programmatically-set names,\n\t// so use a roundabout getElementsByName test\n\tsupport.getById = assert(function( el ) {\n\t\tdocElem.appendChild( el ).id = expando;\n\t\treturn !document.getElementsByName || !document.getElementsByName( expando ).length;\n\t});\n\n\t// ID filter and find\n\tif ( support.getById ) {\n\t\tExpr.filter[\"ID\"] = function( id ) {\n\t\t\tvar attrId = id.replace( runescape, funescape );\n\t\t\treturn function( elem ) {\n\t\t\t\treturn elem.getAttribute(\"id\") === attrId;\n\t\t\t};\n\t\t};\n\t\tExpr.find[\"ID\"] = function( id, context ) {\n\t\t\tif ( typeof context.getElementById !== \"undefined\" && documentIsHTML ) {\n\t\t\t\tvar elem = context.getElementById( id );\n\t\t\t\treturn elem ? [ elem ] : [];\n\t\t\t}\n\t\t};\n\t} else {\n\t\tExpr.filter[\"ID\"] =  function( id ) {\n\t\t\tvar attrId = id.replace( runescape, funescape );\n\t\t\treturn function( elem ) {\n\t\t\t\tvar node = typeof elem.getAttributeNode !== \"undefined\" &&\n\t\t\t\t\telem.getAttributeNode(\"id\");\n\t\t\t\treturn node && node.value === attrId;\n\t\t\t};\n\t\t};\n\n\t\t// Support: IE 6 - 7 only\n\t\t// getElementById is not reliable as a find shortcut\n\t\tExpr.find[\"ID\"] = function( id, context ) {\n\t\t\tif ( typeof context.getElementById !== \"undefined\" && documentIsHTML ) {\n\t\t\t\tvar node, i, elems,\n\t\t\t\t\telem = context.getElementById( id );\n\n\t\t\t\tif ( elem ) {\n\n\t\t\t\t\t// Verify the id attribute\n\t\t\t\t\tnode = elem.getAttributeNode(\"id\");\n\t\t\t\t\tif ( node && node.value === id ) {\n\t\t\t\t\t\treturn [ elem ];\n\t\t\t\t\t}\n\n\t\t\t\t\t// Fall back on getElementsByName\n\t\t\t\t\telems = context.getElementsByName( id );\n\t\t\t\t\ti = 0;\n\t\t\t\t\twhile ( (elem = elems[i++]) ) {\n\t\t\t\t\t\tnode = elem.getAttributeNode(\"id\");\n\t\t\t\t\t\tif ( node && node.value === id ) {\n\t\t\t\t\t\t\treturn [ elem ];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\treturn [];\n\t\t\t}\n\t\t};\n\t}\n\n\t// Tag\n\tExpr.find[\"TAG\"] = support.getElementsByTagName ?\n\t\tfunction( tag, context ) {\n\t\t\tif ( typeof context.getElementsByTagName !== \"undefined\" ) {\n\t\t\t\treturn context.getElementsByTagName( tag );\n\n\t\t\t// DocumentFragment nodes don't have gEBTN\n\t\t\t} else if ( support.qsa ) {\n\t\t\t\treturn context.querySelectorAll( tag );\n\t\t\t}\n\t\t} :\n\n\t\tfunction( tag, context ) {\n\t\t\tvar elem,\n\t\t\t\ttmp = [],\n\t\t\t\ti = 0,\n\t\t\t\t// By happy coincidence, a (broken) gEBTN appears on DocumentFragment nodes too\n\t\t\t\tresults = context.getElementsByTagName( tag );\n\n\t\t\t// Filter out possible comments\n\t\t\tif ( tag === \"*\" ) {\n\t\t\t\twhile ( (elem = results[i++]) ) {\n\t\t\t\t\tif ( elem.nodeType === 1 ) {\n\t\t\t\t\t\ttmp.push( elem );\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\treturn tmp;\n\t\t\t}\n\t\t\treturn results;\n\t\t};\n\n\t// Class\n\tExpr.find[\"CLASS\"] = support.getElementsByClassName && function( className, context ) {\n\t\tif ( typeof context.getElementsByClassName !== \"undefined\" && documentIsHTML ) {\n\t\t\treturn context.getElementsByClassName( className );\n\t\t}\n\t};\n\n\t/* QSA/matchesSelector\n\t---------------------------------------------------------------------- */\n\n\t// QSA and matchesSelector support\n\n\t// matchesSelector(:active) reports false when true (IE9/Opera 11.5)\n\trbuggyMatches = [];\n\n\t// qSa(:focus) reports false when true (Chrome 21)\n\t// We allow this because of a bug in IE8/9 that throws an error\n\t// whenever `document.activeElement` is accessed on an iframe\n\t// So, we allow :focus to pass through QSA all the time to avoid the IE error\n\t// See https://bugs.jquery.com/ticket/13378\n\trbuggyQSA = [];\n\n\tif ( (support.qsa = rnative.test( document.querySelectorAll )) ) {\n\t\t// Build QSA regex\n\t\t// Regex strategy adopted from Diego Perini\n\t\tassert(function( el ) {\n\t\t\t// Select is set to empty string on purpose\n\t\t\t// This is to test IE's treatment of not explicitly\n\t\t\t// setting a boolean content attribute,\n\t\t\t// since its presence should be enough\n\t\t\t// https://bugs.jquery.com/ticket/12359\n\t\t\tdocElem.appendChild( el ).innerHTML = \"<a id='\" + expando + \"'></a>\" +\n\t\t\t\t\"<select id='\" + expando + \"-\\r\\\\' msallowcapture=''>\" +\n\t\t\t\t\"<option selected=''></option></select>\";\n\n\t\t\t// Support: IE8, Opera 11-12.16\n\t\t\t// Nothing should be selected when empty strings follow ^= or $= or *=\n\t\t\t// The test attribute must be unknown in Opera but \"safe\" for WinRT\n\t\t\t// https://msdn.microsoft.com/en-us/library/ie/hh465388.aspx#attribute_section\n\t\t\tif ( el.querySelectorAll(\"[msallowcapture^='']\").length ) {\n\t\t\t\trbuggyQSA.push( \"[*^$]=\" + whitespace + \"*(?:''|\\\"\\\")\" );\n\t\t\t}\n\n\t\t\t// Support: IE8\n\t\t\t// Boolean attributes and \"value\" are not treated correctly\n\t\t\tif ( !el.querySelectorAll(\"[selected]\").length ) {\n\t\t\t\trbuggyQSA.push( \"\\\\[\" + whitespace + \"*(?:value|\" + booleans + \")\" );\n\t\t\t}\n\n\t\t\t// Support: Chrome<29, Android<4.4, Safari<7.0+, iOS<7.0+, PhantomJS<1.9.8+\n\t\t\tif ( !el.querySelectorAll( \"[id~=\" + expando + \"-]\" ).length ) {\n\t\t\t\trbuggyQSA.push(\"~=\");\n\t\t\t}\n\n\t\t\t// Webkit/Opera - :checked should return selected option elements\n\t\t\t// http://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked\n\t\t\t// IE8 throws error here and will not see later tests\n\t\t\tif ( !el.querySelectorAll(\":checked\").length ) {\n\t\t\t\trbuggyQSA.push(\":checked\");\n\t\t\t}\n\n\t\t\t// Support: Safari 8+, iOS 8+\n\t\t\t// https://bugs.webkit.org/show_bug.cgi?id=136851\n\t\t\t// In-page `selector#id sibling-combinator selector` fails\n\t\t\tif ( !el.querySelectorAll( \"a#\" + expando + \"+*\" ).length ) {\n\t\t\t\trbuggyQSA.push(\".#.+[+~]\");\n\t\t\t}\n\t\t});\n\n\t\tassert(function( el ) {\n\t\t\tel.innerHTML = \"<a href='' disabled='disabled'></a>\" +\n\t\t\t\t\"<select disabled='disabled'><option/></select>\";\n\n\t\t\t// Support: Windows 8 Native Apps\n\t\t\t// The type and name attributes are restricted during .innerHTML assignment\n\t\t\tvar input = document.createElement(\"input\");\n\t\t\tinput.setAttribute( \"type\", \"hidden\" );\n\t\t\tel.appendChild( input ).setAttribute( \"name\", \"D\" );\n\n\t\t\t// Support: IE8\n\t\t\t// Enforce case-sensitivity of name attribute\n\t\t\tif ( el.querySelectorAll(\"[name=d]\").length ) {\n\t\t\t\trbuggyQSA.push( \"name\" + whitespace + \"*[*^$|!~]?=\" );\n\t\t\t}\n\n\t\t\t// FF 3.5 - :enabled/:disabled and hidden elements (hidden elements are still enabled)\n\t\t\t// IE8 throws error here and will not see later tests\n\t\t\tif ( el.querySelectorAll(\":enabled\").length !== 2 ) {\n\t\t\t\trbuggyQSA.push( \":enabled\", \":disabled\" );\n\t\t\t}\n\n\t\t\t// Support: IE9-11+\n\t\t\t// IE's :disabled selector does not pick up the children of disabled fieldsets\n\t\t\tdocElem.appendChild( el ).disabled = true;\n\t\t\tif ( el.querySelectorAll(\":disabled\").length !== 2 ) {\n\t\t\t\trbuggyQSA.push( \":enabled\", \":disabled\" );\n\t\t\t}\n\n\t\t\t// Opera 10-11 does not throw on post-comma invalid pseudos\n\t\t\tel.querySelectorAll(\"*,:x\");\n\t\t\trbuggyQSA.push(\",.*:\");\n\t\t});\n\t}\n\n\tif ( (support.matchesSelector = rnative.test( (matches = docElem.matches ||\n\t\tdocElem.webkitMatchesSelector ||\n\t\tdocElem.mozMatchesSelector ||\n\t\tdocElem.oMatchesSelector ||\n\t\tdocElem.msMatchesSelector) )) ) {\n\n\t\tassert(function( el ) {\n\t\t\t// Check to see if it's possible to do matchesSelector\n\t\t\t// on a disconnected node (IE 9)\n\t\t\tsupport.disconnectedMatch = matches.call( el, \"*\" );\n\n\t\t\t// This should fail with an exception\n\t\t\t// Gecko does not error, returns false instead\n\t\t\tmatches.call( el, \"[s!='']:x\" );\n\t\t\trbuggyMatches.push( \"!=\", pseudos );\n\t\t});\n\t}\n\n\trbuggyQSA = rbuggyQSA.length && new RegExp( rbuggyQSA.join(\"|\") );\n\trbuggyMatches = rbuggyMatches.length && new RegExp( rbuggyMatches.join(\"|\") );\n\n\t/* Contains\n\t---------------------------------------------------------------------- */\n\thasCompare = rnative.test( docElem.compareDocumentPosition );\n\n\t// Element contains another\n\t// Purposefully self-exclusive\n\t// As in, an element does not contain itself\n\tcontains = hasCompare || rnative.test( docElem.contains ) ?\n\t\tfunction( a, b ) {\n\t\t\tvar adown = a.nodeType === 9 ? a.documentElement : a,\n\t\t\t\tbup = b && b.parentNode;\n\t\t\treturn a === bup || !!( bup && bup.nodeType === 1 && (\n\t\t\t\tadown.contains ?\n\t\t\t\t\tadown.contains( bup ) :\n\t\t\t\t\ta.compareDocumentPosition && a.compareDocumentPosition( bup ) & 16\n\t\t\t));\n\t\t} :\n\t\tfunction( a, b ) {\n\t\t\tif ( b ) {\n\t\t\t\twhile ( (b = b.parentNode) ) {\n\t\t\t\t\tif ( b === a ) {\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn false;\n\t\t};\n\n\t/* Sorting\n\t---------------------------------------------------------------------- */\n\n\t// Document order sorting\n\tsortOrder = hasCompare ?\n\tfunction( a, b ) {\n\n\t\t// Flag for duplicate removal\n\t\tif ( a === b ) {\n\t\t\thasDuplicate = true;\n\t\t\treturn 0;\n\t\t}\n\n\t\t// Sort on method existence if only one input has compareDocumentPosition\n\t\tvar compare = !a.compareDocumentPosition - !b.compareDocumentPosition;\n\t\tif ( compare ) {\n\t\t\treturn compare;\n\t\t}\n\n\t\t// Calculate position if both inputs belong to the same document\n\t\tcompare = ( a.ownerDocument || a ) === ( b.ownerDocument || b ) ?\n\t\t\ta.compareDocumentPosition( b ) :\n\n\t\t\t// Otherwise we know they are disconnected\n\t\t\t1;\n\n\t\t// Disconnected nodes\n\t\tif ( compare & 1 ||\n\t\t\t(!support.sortDetached && b.compareDocumentPosition( a ) === compare) ) {\n\n\t\t\t// Choose the first element that is related to our preferred document\n\t\t\tif ( a === document || a.ownerDocument === preferredDoc && contains(preferredDoc, a) ) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tif ( b === document || b.ownerDocument === preferredDoc && contains(preferredDoc, b) ) {\n\t\t\t\treturn 1;\n\t\t\t}\n\n\t\t\t// Maintain original order\n\t\t\treturn sortInput ?\n\t\t\t\t( indexOf( sortInput, a ) - indexOf( sortInput, b ) ) :\n\t\t\t\t0;\n\t\t}\n\n\t\treturn compare & 4 ? -1 : 1;\n\t} :\n\tfunction( a, b ) {\n\t\t// Exit early if the nodes are identical\n\t\tif ( a === b ) {\n\t\t\thasDuplicate = true;\n\t\t\treturn 0;\n\t\t}\n\n\t\tvar cur,\n\t\t\ti = 0,\n\t\t\taup = a.parentNode,\n\t\t\tbup = b.parentNode,\n\t\t\tap = [ a ],\n\t\t\tbp = [ b ];\n\n\t\t// Parentless nodes are either documents or disconnected\n\t\tif ( !aup || !bup ) {\n\t\t\treturn a === document ? -1 :\n\t\t\t\tb === document ? 1 :\n\t\t\t\taup ? -1 :\n\t\t\t\tbup ? 1 :\n\t\t\t\tsortInput ?\n\t\t\t\t( indexOf( sortInput, a ) - indexOf( sortInput, b ) ) :\n\t\t\t\t0;\n\n\t\t// If the nodes are siblings, we can do a quick check\n\t\t} else if ( aup === bup ) {\n\t\t\treturn siblingCheck( a, b );\n\t\t}\n\n\t\t// Otherwise we need full lists of their ancestors for comparison\n\t\tcur = a;\n\t\twhile ( (cur = cur.parentNode) ) {\n\t\t\tap.unshift( cur );\n\t\t}\n\t\tcur = b;\n\t\twhile ( (cur = cur.parentNode) ) {\n\t\t\tbp.unshift( cur );\n\t\t}\n\n\t\t// Walk down the tree looking for a discrepancy\n\t\twhile ( ap[i] === bp[i] ) {\n\t\t\ti++;\n\t\t}\n\n\t\treturn i ?\n\t\t\t// Do a sibling check if the nodes have a common ancestor\n\t\t\tsiblingCheck( ap[i], bp[i] ) :\n\n\t\t\t// Otherwise nodes in our document sort first\n\t\t\tap[i] === preferredDoc ? -1 :\n\t\t\tbp[i] === preferredDoc ? 1 :\n\t\t\t0;\n\t};\n\n\treturn document;\n};\n\nSizzle.matches = function( expr, elements ) {\n\treturn Sizzle( expr, null, null, elements );\n};\n\nSizzle.matchesSelector = function( elem, expr ) {\n\t// Set document vars if needed\n\tif ( ( elem.ownerDocument || elem ) !== document ) {\n\t\tsetDocument( elem );\n\t}\n\n\tif ( support.matchesSelector && documentIsHTML &&\n\t\t!nonnativeSelectorCache[ expr + \" \" ] &&\n\t\t( !rbuggyMatches || !rbuggyMatches.test( expr ) ) &&\n\t\t( !rbuggyQSA     || !rbuggyQSA.test( expr ) ) ) {\n\n\t\ttry {\n\t\t\tvar ret = matches.call( elem, expr );\n\n\t\t\t// IE 9's matchesSelector returns false on disconnected nodes\n\t\t\tif ( ret || support.disconnectedMatch ||\n\t\t\t\t\t// As well, disconnected nodes are said to be in a document\n\t\t\t\t\t// fragment in IE 9\n\t\t\t\t\telem.document && elem.document.nodeType !== 11 ) {\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t} catch (e) {\n\t\t\tnonnativeSelectorCache( expr, true );\n\t\t}\n\t}\n\n\treturn Sizzle( expr, document, null, [ elem ] ).length > 0;\n};\n\nSizzle.contains = function( context, elem ) {\n\t// Set document vars if needed\n\tif ( ( context.ownerDocument || context ) !== document ) {\n\t\tsetDocument( context );\n\t}\n\treturn contains( context, elem );\n};\n\nSizzle.attr = function( elem, name ) {\n\t// Set document vars if needed\n\tif ( ( elem.ownerDocument || elem ) !== document ) {\n\t\tsetDocument( elem );\n\t}\n\n\tvar fn = Expr.attrHandle[ name.toLowerCase() ],\n\t\t// Don't get fooled by Object.prototype properties (jQuery #13807)\n\t\tval = fn && hasOwn.call( Expr.attrHandle, name.toLowerCase() ) ?\n\t\t\tfn( elem, name, !documentIsHTML ) :\n\t\t\tundefined;\n\n\treturn val !== undefined ?\n\t\tval :\n\t\tsupport.attributes || !documentIsHTML ?\n\t\t\telem.getAttribute( name ) :\n\t\t\t(val = elem.getAttributeNode(name)) && val.specified ?\n\t\t\t\tval.value :\n\t\t\t\tnull;\n};\n\nSizzle.escape = function( sel ) {\n\treturn (sel + \"\").replace( rcssescape, fcssescape );\n};\n\nSizzle.error = function( msg ) {\n\tthrow new Error( \"Syntax error, unrecognized expression: \" + msg );\n};\n\n/**\n * Document sorting and removing duplicates\n * @param {ArrayLike} results\n */\nSizzle.uniqueSort = function( results ) {\n\tvar elem,\n\t\tduplicates = [],\n\t\tj = 0,\n\t\ti = 0;\n\n\t// Unless we *know* we can detect duplicates, assume their presence\n\thasDuplicate = !support.detectDuplicates;\n\tsortInput = !support.sortStable && results.slice( 0 );\n\tresults.sort( sortOrder );\n\n\tif ( hasDuplicate ) {\n\t\twhile ( (elem = results[i++]) ) {\n\t\t\tif ( elem === results[ i ] ) {\n\t\t\t\tj = duplicates.push( i );\n\t\t\t}\n\t\t}\n\t\twhile ( j-- ) {\n\t\t\tresults.splice( duplicates[ j ], 1 );\n\t\t}\n\t}\n\n\t// Clear input after sorting to release objects\n\t// See https://github.com/jquery/sizzle/pull/225\n\tsortInput = null;\n\n\treturn results;\n};\n\n/**\n * Utility function for retrieving the text value of an array of DOM nodes\n * @param {Array|Element} elem\n */\ngetText = Sizzle.getText = function( elem ) {\n\tvar node,\n\t\tret = \"\",\n\t\ti = 0,\n\t\tnodeType = elem.nodeType;\n\n\tif ( !nodeType ) {\n\t\t// If no nodeType, this is expected to be an array\n\t\twhile ( (node = elem[i++]) ) {\n\t\t\t// Do not traverse comment nodes\n\t\t\tret += getText( node );\n\t\t}\n\t} else if ( nodeType === 1 || nodeType === 9 || nodeType === 11 ) {\n\t\t// Use textContent for elements\n\t\t// innerText usage removed for consistency of new lines (jQuery #11153)\n\t\tif ( typeof elem.textContent === \"string\" ) {\n\t\t\treturn elem.textContent;\n\t\t} else {\n\t\t\t// Traverse its children\n\t\t\tfor ( elem = elem.firstChild; elem; elem = elem.nextSibling ) {\n\t\t\t\tret += getText( elem );\n\t\t\t}\n\t\t}\n\t} else if ( nodeType === 3 || nodeType === 4 ) {\n\t\treturn elem.nodeValue;\n\t}\n\t// Do not include comment or processing instruction nodes\n\n\treturn ret;\n};\n\nExpr = Sizzle.selectors = {\n\n\t// Can be adjusted by the user\n\tcacheLength: 50,\n\n\tcreatePseudo: markFunction,\n\n\tmatch: matchExpr,\n\n\tattrHandle: {},\n\n\tfind: {},\n\n\trelative: {\n\t\t\">\": { dir: \"parentNode\", first: true },\n\t\t\" \": { dir: \"parentNode\" },\n\t\t\"+\": { dir: \"previousSibling\", first: true },\n\t\t\"~\": { dir: \"previousSibling\" }\n\t},\n\n\tpreFilter: {\n\t\t\"ATTR\": function( match ) {\n\t\t\tmatch[1] = match[1].replace( runescape, funescape );\n\n\t\t\t// Move the given value to match[3] whether quoted or unquoted\n\t\t\tmatch[3] = ( match[3] || match[4] || match[5] || \"\" ).replace( runescape, funescape );\n\n\t\t\tif ( match[2] === \"~=\" ) {\n\t\t\t\tmatch[3] = \" \" + match[3] + \" \";\n\t\t\t}\n\n\t\t\treturn match.slice( 0, 4 );\n\t\t},\n\n\t\t\"CHILD\": function( match ) {\n\t\t\t/* matches from matchExpr[\"CHILD\"]\n\t\t\t\t1 type (only|nth|...)\n\t\t\t\t2 what (child|of-type)\n\t\t\t\t3 argument (even|odd|\\d*|\\d*n([+-]\\d+)?|...)\n\t\t\t\t4 xn-component of xn+y argument ([+-]?\\d*n|)\n\t\t\t\t5 sign of xn-component\n\t\t\t\t6 x of xn-component\n\t\t\t\t7 sign of y-component\n\t\t\t\t8 y of y-component\n\t\t\t*/\n\t\t\tmatch[1] = match[1].toLowerCase();\n\n\t\t\tif ( match[1].slice( 0, 3 ) === \"nth\" ) {\n\t\t\t\t// nth-* requires argument\n\t\t\t\tif ( !match[3] ) {\n\t\t\t\t\tSizzle.error( match[0] );\n\t\t\t\t}\n\n\t\t\t\t// numeric x and y parameters for Expr.filter.CHILD\n\t\t\t\t// remember that false/true cast respectively to 0/1\n\t\t\t\tmatch[4] = +( match[4] ? match[5] + (match[6] || 1) : 2 * ( match[3] === \"even\" || match[3] === \"odd\" ) );\n\t\t\t\tmatch[5] = +( ( match[7] + match[8] ) || match[3] === \"odd\" );\n\n\t\t\t// other types prohibit arguments\n\t\t\t} else if ( match[3] ) {\n\t\t\t\tSizzle.error( match[0] );\n\t\t\t}\n\n\t\t\treturn match;\n\t\t},\n\n\t\t\"PSEUDO\": function( match ) {\n\t\t\tvar excess,\n\t\t\t\tunquoted = !match[6] && match[2];\n\n\t\t\tif ( matchExpr[\"CHILD\"].test( match[0] ) ) {\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\t// Accept quoted arguments as-is\n\t\t\tif ( match[3] ) {\n\t\t\t\tmatch[2] = match[4] || match[5] || \"\";\n\n\t\t\t// Strip excess characters from unquoted arguments\n\t\t\t} else if ( unquoted && rpseudo.test( unquoted ) &&\n\t\t\t\t// Get excess from tokenize (recursively)\n\t\t\t\t(excess = tokenize( unquoted, true )) &&\n\t\t\t\t// advance to the next closing parenthesis\n\t\t\t\t(excess = unquoted.indexOf( \")\", unquoted.length - excess ) - unquoted.length) ) {\n\n\t\t\t\t// excess is a negative index\n\t\t\t\tmatch[0] = match[0].slice( 0, excess );\n\t\t\t\tmatch[2] = unquoted.slice( 0, excess );\n\t\t\t}\n\n\t\t\t// Return only captures needed by the pseudo filter method (type and argument)\n\t\t\treturn match.slice( 0, 3 );\n\t\t}\n\t},\n\n\tfilter: {\n\n\t\t\"TAG\": function( nodeNameSelector ) {\n\t\t\tvar nodeName = nodeNameSelector.replace( runescape, funescape ).toLowerCase();\n\t\t\treturn nodeNameSelector === \"*\" ?\n\t\t\t\tfunction() { return true; } :\n\t\t\t\tfunction( elem ) {\n\t\t\t\t\treturn elem.nodeName && elem.nodeName.toLowerCase() === nodeName;\n\t\t\t\t};\n\t\t},\n\n\t\t\"CLASS\": function( className ) {\n\t\t\tvar pattern = classCache[ className + \" \" ];\n\n\t\t\treturn pattern ||\n\t\t\t\t(pattern = new RegExp( \"(^|\" + whitespace + \")\" + className + \"(\" + whitespace + \"|$)\" )) &&\n\t\t\t\tclassCache( className, function( elem ) {\n\t\t\t\t\treturn pattern.test( typeof elem.className === \"string\" && elem.className || typeof elem.getAttribute !== \"undefined\" && elem.getAttribute(\"class\") || \"\" );\n\t\t\t\t});\n\t\t},\n\n\t\t\"ATTR\": function( name, operator, check ) {\n\t\t\treturn function( elem ) {\n\t\t\t\tvar result = Sizzle.attr( elem, name );\n\n\t\t\t\tif ( result == null ) {\n\t\t\t\t\treturn operator === \"!=\";\n\t\t\t\t}\n\t\t\t\tif ( !operator ) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\n\t\t\t\tresult += \"\";\n\n\t\t\t\treturn operator === \"=\" ? result === check :\n\t\t\t\t\toperator === \"!=\" ? result !== check :\n\t\t\t\t\toperator === \"^=\" ? check && result.indexOf( check ) === 0 :\n\t\t\t\t\toperator === \"*=\" ? check && result.indexOf( check ) > -1 :\n\t\t\t\t\toperator === \"$=\" ? check && result.slice( -check.length ) === check :\n\t\t\t\t\toperator === \"~=\" ? ( \" \" + result.replace( rwhitespace, \" \" ) + \" \" ).indexOf( check ) > -1 :\n\t\t\t\t\toperator === \"|=\" ? result === check || result.slice( 0, check.length + 1 ) === check + \"-\" :\n\t\t\t\t\tfalse;\n\t\t\t};\n\t\t},\n\n\t\t\"CHILD\": function( type, what, argument, first, last ) {\n\t\t\tvar simple = type.slice( 0, 3 ) !== \"nth\",\n\t\t\t\tforward = type.slice( -4 ) !== \"last\",\n\t\t\t\tofType = what === \"of-type\";\n\n\t\t\treturn first === 1 && last === 0 ?\n\n\t\t\t\t// Shortcut for :nth-*(n)\n\t\t\t\tfunction( elem ) {\n\t\t\t\t\treturn !!elem.parentNode;\n\t\t\t\t} :\n\n\t\t\t\tfunction( elem, context, xml ) {\n\t\t\t\t\tvar cache, uniqueCache, outerCache, node, nodeIndex, start,\n\t\t\t\t\t\tdir = simple !== forward ? \"nextSibling\" : \"previousSibling\",\n\t\t\t\t\t\tparent = elem.parentNode,\n\t\t\t\t\t\tname = ofType && elem.nodeName.toLowerCase(),\n\t\t\t\t\t\tuseCache = !xml && !ofType,\n\t\t\t\t\t\tdiff = false;\n\n\t\t\t\t\tif ( parent ) {\n\n\t\t\t\t\t\t// :(first|last|only)-(child|of-type)\n\t\t\t\t\t\tif ( simple ) {\n\t\t\t\t\t\t\twhile ( dir ) {\n\t\t\t\t\t\t\t\tnode = elem;\n\t\t\t\t\t\t\t\twhile ( (node = node[ dir ]) ) {\n\t\t\t\t\t\t\t\t\tif ( ofType ?\n\t\t\t\t\t\t\t\t\t\tnode.nodeName.toLowerCase() === name :\n\t\t\t\t\t\t\t\t\t\tnode.nodeType === 1 ) {\n\n\t\t\t\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t// Reverse direction for :only-* (if we haven't yet done so)\n\t\t\t\t\t\t\t\tstart = dir = type === \"only\" && !start && \"nextSibling\";\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tstart = [ forward ? parent.firstChild : parent.lastChild ];\n\n\t\t\t\t\t\t// non-xml :nth-child(...) stores cache data on `parent`\n\t\t\t\t\t\tif ( forward && useCache ) {\n\n\t\t\t\t\t\t\t// Seek `elem` from a previously-cached index\n\n\t\t\t\t\t\t\t// ...in a gzip-friendly way\n\t\t\t\t\t\t\tnode = parent;\n\t\t\t\t\t\t\touterCache = node[ expando ] || (node[ expando ] = {});\n\n\t\t\t\t\t\t\t// Support: IE <9 only\n\t\t\t\t\t\t\t// Defend against cloned attroperties (jQuery gh-1709)\n\t\t\t\t\t\t\tuniqueCache = outerCache[ node.uniqueID ] ||\n\t\t\t\t\t\t\t\t(outerCache[ node.uniqueID ] = {});\n\n\t\t\t\t\t\t\tcache = uniqueCache[ type ] || [];\n\t\t\t\t\t\t\tnodeIndex = cache[ 0 ] === dirruns && cache[ 1 ];\n\t\t\t\t\t\t\tdiff = nodeIndex && cache[ 2 ];\n\t\t\t\t\t\t\tnode = nodeIndex && parent.childNodes[ nodeIndex ];\n\n\t\t\t\t\t\t\twhile ( (node = ++nodeIndex && node && node[ dir ] ||\n\n\t\t\t\t\t\t\t\t// Fallback to seeking `elem` from the start\n\t\t\t\t\t\t\t\t(diff = nodeIndex = 0) || start.pop()) ) {\n\n\t\t\t\t\t\t\t\t// When found, cache indexes on `parent` and break\n\t\t\t\t\t\t\t\tif ( node.nodeType === 1 && ++diff && node === elem ) {\n\t\t\t\t\t\t\t\t\tuniqueCache[ type ] = [ dirruns, nodeIndex, diff ];\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t// Use previously-cached element index if available\n\t\t\t\t\t\t\tif ( useCache ) {\n\t\t\t\t\t\t\t\t// ...in a gzip-friendly way\n\t\t\t\t\t\t\t\tnode = elem;\n\t\t\t\t\t\t\t\touterCache = node[ expando ] || (node[ expando ] = {});\n\n\t\t\t\t\t\t\t\t// Support: IE <9 only\n\t\t\t\t\t\t\t\t// Defend against cloned attroperties (jQuery gh-1709)\n\t\t\t\t\t\t\t\tuniqueCache = outerCache[ node.uniqueID ] ||\n\t\t\t\t\t\t\t\t\t(outerCache[ node.uniqueID ] = {});\n\n\t\t\t\t\t\t\t\tcache = uniqueCache[ type ] || [];\n\t\t\t\t\t\t\t\tnodeIndex = cache[ 0 ] === dirruns && cache[ 1 ];\n\t\t\t\t\t\t\t\tdiff = nodeIndex;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t// xml :nth-child(...)\n\t\t\t\t\t\t\t// or :nth-last-child(...) or :nth(-last)?-of-type(...)\n\t\t\t\t\t\t\tif ( diff === false ) {\n\t\t\t\t\t\t\t\t// Use the same loop as above to seek `elem` from the start\n\t\t\t\t\t\t\t\twhile ( (node = ++nodeIndex && node && node[ dir ] ||\n\t\t\t\t\t\t\t\t\t(diff = nodeIndex = 0) || start.pop()) ) {\n\n\t\t\t\t\t\t\t\t\tif ( ( ofType ?\n\t\t\t\t\t\t\t\t\t\tnode.nodeName.toLowerCase() === name :\n\t\t\t\t\t\t\t\t\t\tnode.nodeType === 1 ) &&\n\t\t\t\t\t\t\t\t\t\t++diff ) {\n\n\t\t\t\t\t\t\t\t\t\t// Cache the index of each encountered element\n\t\t\t\t\t\t\t\t\t\tif ( useCache ) {\n\t\t\t\t\t\t\t\t\t\t\touterCache = node[ expando ] || (node[ expando ] = {});\n\n\t\t\t\t\t\t\t\t\t\t\t// Support: IE <9 only\n\t\t\t\t\t\t\t\t\t\t\t// Defend against cloned attroperties (jQuery gh-1709)\n\t\t\t\t\t\t\t\t\t\t\tuniqueCache = outerCache[ node.uniqueID ] ||\n\t\t\t\t\t\t\t\t\t\t\t\t(outerCache[ node.uniqueID ] = {});\n\n\t\t\t\t\t\t\t\t\t\t\tuniqueCache[ type ] = [ dirruns, diff ];\n\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t\tif ( node === elem ) {\n\t\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// Incorporate the offset, then check against cycle size\n\t\t\t\t\t\tdiff -= last;\n\t\t\t\t\t\treturn diff === first || ( diff % first === 0 && diff / first >= 0 );\n\t\t\t\t\t}\n\t\t\t\t};\n\t\t},\n\n\t\t\"PSEUDO\": function( pseudo, argument ) {\n\t\t\t// pseudo-class names are case-insensitive\n\t\t\t// http://www.w3.org/TR/selectors/#pseudo-classes\n\t\t\t// Prioritize by case sensitivity in case custom pseudos are added with uppercase letters\n\t\t\t// Remember that setFilters inherits from pseudos\n\t\t\tvar args,\n\t\t\t\tfn = Expr.pseudos[ pseudo ] || Expr.setFilters[ pseudo.toLowerCase() ] ||\n\t\t\t\t\tSizzle.error( \"unsupported pseudo: \" + pseudo );\n\n\t\t\t// The user may use createPseudo to indicate that\n\t\t\t// arguments are needed to create the filter function\n\t\t\t// just as Sizzle does\n\t\t\tif ( fn[ expando ] ) {\n\t\t\t\treturn fn( argument );\n\t\t\t}\n\n\t\t\t// But maintain support for old signatures\n\t\t\tif ( fn.length > 1 ) {\n\t\t\t\targs = [ pseudo, pseudo, \"\", argument ];\n\t\t\t\treturn Expr.setFilters.hasOwnProperty( pseudo.toLowerCase() ) ?\n\t\t\t\t\tmarkFunction(function( seed, matches ) {\n\t\t\t\t\t\tvar idx,\n\t\t\t\t\t\t\tmatched = fn( seed, argument ),\n\t\t\t\t\t\t\ti = matched.length;\n\t\t\t\t\t\twhile ( i-- ) {\n\t\t\t\t\t\t\tidx = indexOf( seed, matched[i] );\n\t\t\t\t\t\t\tseed[ idx ] = !( matches[ idx ] = matched[i] );\n\t\t\t\t\t\t}\n\t\t\t\t\t}) :\n\t\t\t\t\tfunction( elem ) {\n\t\t\t\t\t\treturn fn( elem, 0, args );\n\t\t\t\t\t};\n\t\t\t}\n\n\t\t\treturn fn;\n\t\t}\n\t},\n\n\tpseudos: {\n\t\t// Potentially complex pseudos\n\t\t\"not\": markFunction(function( selector ) {\n\t\t\t// Trim the selector passed to compile\n\t\t\t// to avoid treating leading and trailing\n\t\t\t// spaces as combinators\n\t\t\tvar input = [],\n\t\t\t\tresults = [],\n\t\t\t\tmatcher = compile( selector.replace( rtrim, \"$1\" ) );\n\n\t\t\treturn matcher[ expando ] ?\n\t\t\t\tmarkFunction(function( seed, matches, context, xml ) {\n\t\t\t\t\tvar elem,\n\t\t\t\t\t\tunmatched = matcher( seed, null, xml, [] ),\n\t\t\t\t\t\ti = seed.length;\n\n\t\t\t\t\t// Match elements unmatched by `matcher`\n\t\t\t\t\twhile ( i-- ) {\n\t\t\t\t\t\tif ( (elem = unmatched[i]) ) {\n\t\t\t\t\t\t\tseed[i] = !(matches[i] = elem);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}) :\n\t\t\t\tfunction( elem, context, xml ) {\n\t\t\t\t\tinput[0] = elem;\n\t\t\t\t\tmatcher( input, null, xml, results );\n\t\t\t\t\t// Don't keep the element (issue #299)\n\t\t\t\t\tinput[0] = null;\n\t\t\t\t\treturn !results.pop();\n\t\t\t\t};\n\t\t}),\n\n\t\t\"has\": markFunction(function( selector ) {\n\t\t\treturn function( elem ) {\n\t\t\t\treturn Sizzle( selector, elem ).length > 0;\n\t\t\t};\n\t\t}),\n\n\t\t\"contains\": markFunction(function( text ) {\n\t\t\ttext = text.replace( runescape, funescape );\n\t\t\treturn function( elem ) {\n\t\t\t\treturn ( elem.textContent || getText( elem ) ).indexOf( text ) > -1;\n\t\t\t};\n\t\t}),\n\n\t\t// \"Whether an element is represented by a :lang() selector\n\t\t// is based solely on the element's language value\n\t\t// being equal to the identifier C,\n\t\t// or beginning with the identifier C immediately followed by \"-\".\n\t\t// The matching of C against the element's language value is performed case-insensitively.\n\t\t// The identifier C does not have to be a valid language name.\"\n\t\t// http://www.w3.org/TR/selectors/#lang-pseudo\n\t\t\"lang\": markFunction( function( lang ) {\n\t\t\t// lang value must be a valid identifier\n\t\t\tif ( !ridentifier.test(lang || \"\") ) {\n\t\t\t\tSizzle.error( \"unsupported lang: \" + lang );\n\t\t\t}\n\t\t\tlang = lang.replace( runescape, funescape ).toLowerCase();\n\t\t\treturn function( elem ) {\n\t\t\t\tvar elemLang;\n\t\t\t\tdo {\n\t\t\t\t\tif ( (elemLang = documentIsHTML ?\n\t\t\t\t\t\telem.lang :\n\t\t\t\t\t\telem.getAttribute(\"xml:lang\") || elem.getAttribute(\"lang\")) ) {\n\n\t\t\t\t\t\telemLang = elemLang.toLowerCase();\n\t\t\t\t\t\treturn elemLang === lang || elemLang.indexOf( lang + \"-\" ) === 0;\n\t\t\t\t\t}\n\t\t\t\t} while ( (elem = elem.parentNode) && elem.nodeType === 1 );\n\t\t\t\treturn false;\n\t\t\t};\n\t\t}),\n\n\t\t// Miscellaneous\n\t\t\"target\": function( elem ) {\n\t\t\tvar hash = window.location && window.location.hash;\n\t\t\treturn hash && hash.slice( 1 ) === elem.id;\n\t\t},\n\n\t\t\"root\": function( elem ) {\n\t\t\treturn elem === docElem;\n\t\t},\n\n\t\t\"focus\": function( elem ) {\n\t\t\treturn elem === document.activeElement && (!document.hasFocus || document.hasFocus()) && !!(elem.type || elem.href || ~elem.tabIndex);\n\t\t},\n\n\t\t// Boolean properties\n\t\t\"enabled\": createDisabledPseudo( false ),\n\t\t\"disabled\": createDisabledPseudo( true ),\n\n\t\t\"checked\": function( elem ) {\n\t\t\t// In CSS3, :checked should return both checked and selected elements\n\t\t\t// http://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked\n\t\t\tvar nodeName = elem.nodeName.toLowerCase();\n\t\t\treturn (nodeName === \"input\" && !!elem.checked) || (nodeName === \"option\" && !!elem.selected);\n\t\t},\n\n\t\t\"selected\": function( elem ) {\n\t\t\t// Accessing this property makes selected-by-default\n\t\t\t// options in Safari work properly\n\t\t\tif ( elem.parentNode ) {\n\t\t\t\telem.parentNode.selectedIndex;\n\t\t\t}\n\n\t\t\treturn elem.selected === true;\n\t\t},\n\n\t\t// Contents\n\t\t\"empty\": function( elem ) {\n\t\t\t// http://www.w3.org/TR/selectors/#empty-pseudo\n\t\t\t// :empty is negated by element (1) or content nodes (text: 3; cdata: 4; entity ref: 5),\n\t\t\t//   but not by others (comment: 8; processing instruction: 7; etc.)\n\t\t\t// nodeType < 6 works because attributes (2) do not appear as children\n\t\t\tfor ( elem = elem.firstChild; elem; elem = elem.nextSibling ) {\n\t\t\t\tif ( elem.nodeType < 6 ) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn true;\n\t\t},\n\n\t\t\"parent\": function( elem ) {\n\t\t\treturn !Expr.pseudos[\"empty\"]( elem );\n\t\t},\n\n\t\t// Element/input types\n\t\t\"header\": function( elem ) {\n\t\t\treturn rheader.test( elem.nodeName );\n\t\t},\n\n\t\t\"input\": function( elem ) {\n\t\t\treturn rinputs.test( elem.nodeName );\n\t\t},\n\n\t\t\"button\": function( elem ) {\n\t\t\tvar name = elem.nodeName.toLowerCase();\n\t\t\treturn name === \"input\" && elem.type === \"button\" || name === \"button\";\n\t\t},\n\n\t\t\"text\": function( elem ) {\n\t\t\tvar attr;\n\t\t\treturn elem.nodeName.toLowerCase() === \"input\" &&\n\t\t\t\telem.type === \"text\" &&\n\n\t\t\t\t// Support: IE<8\n\t\t\t\t// New HTML5 attribute values (e.g., \"search\") appear with elem.type === \"text\"\n\t\t\t\t( (attr = elem.getAttribute(\"type\")) == null || attr.toLowerCase() === \"text\" );\n\t\t},\n\n\t\t// Position-in-collection\n\t\t\"first\": createPositionalPseudo(function() {\n\t\t\treturn [ 0 ];\n\t\t}),\n\n\t\t\"last\": createPositionalPseudo(function( matchIndexes, length ) {\n\t\t\treturn [ length - 1 ];\n\t\t}),\n\n\t\t\"eq\": createPositionalPseudo(function( matchIndexes, length, argument ) {\n\t\t\treturn [ argument < 0 ? argument + length : argument ];\n\t\t}),\n\n\t\t\"even\": createPositionalPseudo(function( matchIndexes, length ) {\n\t\t\tvar i = 0;\n\t\t\tfor ( ; i < length; i += 2 ) {\n\t\t\t\tmatchIndexes.push( i );\n\t\t\t}\n\t\t\treturn matchIndexes;\n\t\t}),\n\n\t\t\"odd\": createPositionalPseudo(function( matchIndexes, length ) {\n\t\t\tvar i = 1;\n\t\t\tfor ( ; i < length; i += 2 ) {\n\t\t\t\tmatchIndexes.push( i );\n\t\t\t}\n\t\t\treturn matchIndexes;\n\t\t}),\n\n\t\t\"lt\": createPositionalPseudo(function( matchIndexes, length, argument ) {\n\t\t\tvar i = argument < 0 ?\n\t\t\t\targument + length :\n\t\t\t\targument > length ?\n\t\t\t\t\tlength :\n\t\t\t\t\targument;\n\t\t\tfor ( ; --i >= 0; ) {\n\t\t\t\tmatchIndexes.push( i );\n\t\t\t}\n\t\t\treturn matchIndexes;\n\t\t}),\n\n\t\t\"gt\": createPositionalPseudo(function( matchIndexes, length, argument ) {\n\t\t\tvar i = argument < 0 ? argument + length : argument;\n\t\t\tfor ( ; ++i < length; ) {\n\t\t\t\tmatchIndexes.push( i );\n\t\t\t}\n\t\t\treturn matchIndexes;\n\t\t})\n\t}\n};\n\nExpr.pseudos[\"nth\"] = Expr.pseudos[\"eq\"];\n\n// Add button/input type pseudos\nfor ( i in { radio: true, checkbox: true, file: true, password: true, image: true } ) {\n\tExpr.pseudos[ i ] = createInputPseudo( i );\n}\nfor ( i in { submit: true, reset: true } ) {\n\tExpr.pseudos[ i ] = createButtonPseudo( i );\n}\n\n// Easy API for creating new setFilters\nfunction setFilters() {}\nsetFilters.prototype = Expr.filters = Expr.pseudos;\nExpr.setFilters = new setFilters();\n\ntokenize = Sizzle.tokenize = function( selector, parseOnly ) {\n\tvar matched, match, tokens, type,\n\t\tsoFar, groups, preFilters,\n\t\tcached = tokenCache[ selector + \" \" ];\n\n\tif ( cached ) {\n\t\treturn parseOnly ? 0 : cached.slice( 0 );\n\t}\n\n\tsoFar = selector;\n\tgroups = [];\n\tpreFilters = Expr.preFilter;\n\n\twhile ( soFar ) {\n\n\t\t// Comma and first run\n\t\tif ( !matched || (match = rcomma.exec( soFar )) ) {\n\t\t\tif ( match ) {\n\t\t\t\t// Don't consume trailing commas as valid\n\t\t\t\tsoFar = soFar.slice( match[0].length ) || soFar;\n\t\t\t}\n\t\t\tgroups.push( (tokens = []) );\n\t\t}\n\n\t\tmatched = false;\n\n\t\t// Combinators\n\t\tif ( (match = rcombinators.exec( soFar )) ) {\n\t\t\tmatched = match.shift();\n\t\t\ttokens.push({\n\t\t\t\tvalue: matched,\n\t\t\t\t// Cast descendant combinators to space\n\t\t\t\ttype: match[0].replace( rtrim, \" \" )\n\t\t\t});\n\t\t\tsoFar = soFar.slice( matched.length );\n\t\t}\n\n\t\t// Filters\n\t\tfor ( type in Expr.filter ) {\n\t\t\tif ( (match = matchExpr[ type ].exec( soFar )) && (!preFilters[ type ] ||\n\t\t\t\t(match = preFilters[ type ]( match ))) ) {\n\t\t\t\tmatched = match.shift();\n\t\t\t\ttokens.push({\n\t\t\t\t\tvalue: matched,\n\t\t\t\t\ttype: type,\n\t\t\t\t\tmatches: match\n\t\t\t\t});\n\t\t\t\tsoFar = soFar.slice( matched.length );\n\t\t\t}\n\t\t}\n\n\t\tif ( !matched ) {\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t// Return the length of the invalid excess\n\t// if we're just parsing\n\t// Otherwise, throw an error or return tokens\n\treturn parseOnly ?\n\t\tsoFar.length :\n\t\tsoFar ?\n\t\t\tSizzle.error( selector ) :\n\t\t\t// Cache the tokens\n\t\t\ttokenCache( selector, groups ).slice( 0 );\n};\n\nfunction toSelector( tokens ) {\n\tvar i = 0,\n\t\tlen = tokens.length,\n\t\tselector = \"\";\n\tfor ( ; i < len; i++ ) {\n\t\tselector += tokens[i].value;\n\t}\n\treturn selector;\n}\n\nfunction addCombinator( matcher, combinator, base ) {\n\tvar dir = combinator.dir,\n\t\tskip = combinator.next,\n\t\tkey = skip || dir,\n\t\tcheckNonElements = base && key === \"parentNode\",\n\t\tdoneName = done++;\n\n\treturn combinator.first ?\n\t\t// Check against closest ancestor/preceding element\n\t\tfunction( elem, context, xml ) {\n\t\t\twhile ( (elem = elem[ dir ]) ) {\n\t\t\t\tif ( elem.nodeType === 1 || checkNonElements ) {\n\t\t\t\t\treturn matcher( elem, context, xml );\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn false;\n\t\t} :\n\n\t\t// Check against all ancestor/preceding elements\n\t\tfunction( elem, context, xml ) {\n\t\t\tvar oldCache, uniqueCache, outerCache,\n\t\t\t\tnewCache = [ dirruns, doneName ];\n\n\t\t\t// We can't set arbitrary data on XML nodes, so they don't benefit from combinator caching\n\t\t\tif ( xml ) {\n\t\t\t\twhile ( (elem = elem[ dir ]) ) {\n\t\t\t\t\tif ( elem.nodeType === 1 || checkNonElements ) {\n\t\t\t\t\t\tif ( matcher( elem, context, xml ) ) {\n\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\twhile ( (elem = elem[ dir ]) ) {\n\t\t\t\t\tif ( elem.nodeType === 1 || checkNonElements ) {\n\t\t\t\t\t\touterCache = elem[ expando ] || (elem[ expando ] = {});\n\n\t\t\t\t\t\t// Support: IE <9 only\n\t\t\t\t\t\t// Defend against cloned attroperties (jQuery gh-1709)\n\t\t\t\t\t\tuniqueCache = outerCache[ elem.uniqueID ] || (outerCache[ elem.uniqueID ] = {});\n\n\t\t\t\t\t\tif ( skip && skip === elem.nodeName.toLowerCase() ) {\n\t\t\t\t\t\t\telem = elem[ dir ] || elem;\n\t\t\t\t\t\t} else if ( (oldCache = uniqueCache[ key ]) &&\n\t\t\t\t\t\t\toldCache[ 0 ] === dirruns && oldCache[ 1 ] === doneName ) {\n\n\t\t\t\t\t\t\t// Assign to newCache so results back-propagate to previous elements\n\t\t\t\t\t\t\treturn (newCache[ 2 ] = oldCache[ 2 ]);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t// Reuse newcache so results back-propagate to previous elements\n\t\t\t\t\t\t\tuniqueCache[ key ] = newCache;\n\n\t\t\t\t\t\t\t// A match means we're done; a fail means we have to keep checking\n\t\t\t\t\t\t\tif ( (newCache[ 2 ] = matcher( elem, context, xml )) ) {\n\t\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn false;\n\t\t};\n}\n\nfunction elementMatcher( matchers ) {\n\treturn matchers.length > 1 ?\n\t\tfunction( elem, context, xml ) {\n\t\t\tvar i = matchers.length;\n\t\t\twhile ( i-- ) {\n\t\t\t\tif ( !matchers[i]( elem, context, xml ) ) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn true;\n\t\t} :\n\t\tmatchers[0];\n}\n\nfunction multipleContexts( selector, contexts, results ) {\n\tvar i = 0,\n\t\tlen = contexts.length;\n\tfor ( ; i < len; i++ ) {\n\t\tSizzle( selector, contexts[i], results );\n\t}\n\treturn results;\n}\n\nfunction condense( unmatched, map, filter, context, xml ) {\n\tvar elem,\n\t\tnewUnmatched = [],\n\t\ti = 0,\n\t\tlen = unmatched.length,\n\t\tmapped = map != null;\n\n\tfor ( ; i < len; i++ ) {\n\t\tif ( (elem = unmatched[i]) ) {\n\t\t\tif ( !filter || filter( elem, context, xml ) ) {\n\t\t\t\tnewUnmatched.push( elem );\n\t\t\t\tif ( mapped ) {\n\t\t\t\t\tmap.push( i );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn newUnmatched;\n}\n\nfunction setMatcher( preFilter, selector, matcher, postFilter, postFinder, postSelector ) {\n\tif ( postFilter && !postFilter[ expando ] ) {\n\t\tpostFilter = setMatcher( postFilter );\n\t}\n\tif ( postFinder && !postFinder[ expando ] ) {\n\t\tpostFinder = setMatcher( postFinder, postSelector );\n\t}\n\treturn markFunction(function( seed, results, context, xml ) {\n\t\tvar temp, i, elem,\n\t\t\tpreMap = [],\n\t\t\tpostMap = [],\n\t\t\tpreexisting = results.length,\n\n\t\t\t// Get initial elements from seed or context\n\t\t\telems = seed || multipleContexts( selector || \"*\", context.nodeType ? [ context ] : context, [] ),\n\n\t\t\t// Prefilter to get matcher input, preserving a map for seed-results synchronization\n\t\t\tmatcherIn = preFilter && ( seed || !selector ) ?\n\t\t\t\tcondense( elems, preMap, preFilter, context, xml ) :\n\t\t\t\telems,\n\n\t\t\tmatcherOut = matcher ?\n\t\t\t\t// If we have a postFinder, or filtered seed, or non-seed postFilter or preexisting results,\n\t\t\t\tpostFinder || ( seed ? preFilter : preexisting || postFilter ) ?\n\n\t\t\t\t\t// ...intermediate processing is necessary\n\t\t\t\t\t[] :\n\n\t\t\t\t\t// ...otherwise use results directly\n\t\t\t\t\tresults :\n\t\t\t\tmatcherIn;\n\n\t\t// Find primary matches\n\t\tif ( matcher ) {\n\t\t\tmatcher( matcherIn, matcherOut, context, xml );\n\t\t}\n\n\t\t// Apply postFilter\n\t\tif ( postFilter ) {\n\t\t\ttemp = condense( matcherOut, postMap );\n\t\t\tpostFilter( temp, [], context, xml );\n\n\t\t\t// Un-match failing elements by moving them back to matcherIn\n\t\t\ti = temp.length;\n\t\t\twhile ( i-- ) {\n\t\t\t\tif ( (elem = temp[i]) ) {\n\t\t\t\t\tmatcherOut[ postMap[i] ] = !(matcherIn[ postMap[i] ] = elem);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif ( seed ) {\n\t\t\tif ( postFinder || preFilter ) {\n\t\t\t\tif ( postFinder ) {\n\t\t\t\t\t// Get the final matcherOut by condensing this intermediate into postFinder contexts\n\t\t\t\t\ttemp = [];\n\t\t\t\t\ti = matcherOut.length;\n\t\t\t\t\twhile ( i-- ) {\n\t\t\t\t\t\tif ( (elem = matcherOut[i]) ) {\n\t\t\t\t\t\t\t// Restore matcherIn since elem is not yet a final match\n\t\t\t\t\t\t\ttemp.push( (matcherIn[i] = elem) );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tpostFinder( null, (matcherOut = []), temp, xml );\n\t\t\t\t}\n\n\t\t\t\t// Move matched elements from seed to results to keep them synchronized\n\t\t\t\ti = matcherOut.length;\n\t\t\t\twhile ( i-- ) {\n\t\t\t\t\tif ( (elem = matcherOut[i]) &&\n\t\t\t\t\t\t(temp = postFinder ? indexOf( seed, elem ) : preMap[i]) > -1 ) {\n\n\t\t\t\t\t\tseed[temp] = !(results[temp] = elem);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t// Add elements to results, through postFinder if defined\n\t\t} else {\n\t\t\tmatcherOut = condense(\n\t\t\t\tmatcherOut === results ?\n\t\t\t\t\tmatcherOut.splice( preexisting, matcherOut.length ) :\n\t\t\t\t\tmatcherOut\n\t\t\t);\n\t\t\tif ( postFinder ) {\n\t\t\t\tpostFinder( null, results, matcherOut, xml );\n\t\t\t} else {\n\t\t\t\tpush.apply( results, matcherOut );\n\t\t\t}\n\t\t}\n\t});\n}\n\nfunction matcherFromTokens( tokens ) {\n\tvar checkContext, matcher, j,\n\t\tlen = tokens.length,\n\t\tleadingRelative = Expr.relative[ tokens[0].type ],\n\t\timplicitRelative = leadingRelative || Expr.relative[\" \"],\n\t\ti = leadingRelative ? 1 : 0,\n\n\t\t// The foundational matcher ensures that elements are reachable from top-level context(s)\n\t\tmatchContext = addCombinator( function( elem ) {\n\t\t\treturn elem === checkContext;\n\t\t}, implicitRelative, true ),\n\t\tmatchAnyContext = addCombinator( function( elem ) {\n\t\t\treturn indexOf( checkContext, elem ) > -1;\n\t\t}, implicitRelative, true ),\n\t\tmatchers = [ function( elem, context, xml ) {\n\t\t\tvar ret = ( !leadingRelative && ( xml || context !== outermostContext ) ) || (\n\t\t\t\t(checkContext = context).nodeType ?\n\t\t\t\t\tmatchContext( elem, context, xml ) :\n\t\t\t\t\tmatchAnyContext( elem, context, xml ) );\n\t\t\t// Avoid hanging onto element (issue #299)\n\t\t\tcheckContext = null;\n\t\t\treturn ret;\n\t\t} ];\n\n\tfor ( ; i < len; i++ ) {\n\t\tif ( (matcher = Expr.relative[ tokens[i].type ]) ) {\n\t\t\tmatchers = [ addCombinator(elementMatcher( matchers ), matcher) ];\n\t\t} else {\n\t\t\tmatcher = Expr.filter[ tokens[i].type ].apply( null, tokens[i].matches );\n\n\t\t\t// Return special upon seeing a positional matcher\n\t\t\tif ( matcher[ expando ] ) {\n\t\t\t\t// Find the next relative operator (if any) for proper handling\n\t\t\t\tj = ++i;\n\t\t\t\tfor ( ; j < len; j++ ) {\n\t\t\t\t\tif ( Expr.relative[ tokens[j].type ] ) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn setMatcher(\n\t\t\t\t\ti > 1 && elementMatcher( matchers ),\n\t\t\t\t\ti > 1 && toSelector(\n\t\t\t\t\t\t// If the preceding token was a descendant combinator, insert an implicit any-element `*`\n\t\t\t\t\t\ttokens.slice( 0, i - 1 ).concat({ value: tokens[ i - 2 ].type === \" \" ? \"*\" : \"\" })\n\t\t\t\t\t).replace( rtrim, \"$1\" ),\n\t\t\t\t\tmatcher,\n\t\t\t\t\ti < j && matcherFromTokens( tokens.slice( i, j ) ),\n\t\t\t\t\tj < len && matcherFromTokens( (tokens = tokens.slice( j )) ),\n\t\t\t\t\tj < len && toSelector( tokens )\n\t\t\t\t);\n\t\t\t}\n\t\t\tmatchers.push( matcher );\n\t\t}\n\t}\n\n\treturn elementMatcher( matchers );\n}\n\nfunction matcherFromGroupMatchers( elementMatchers, setMatchers ) {\n\tvar bySet = setMatchers.length > 0,\n\t\tbyElement = elementMatchers.length > 0,\n\t\tsuperMatcher = function( seed, context, xml, results, outermost ) {\n\t\t\tvar elem, j, matcher,\n\t\t\t\tmatchedCount = 0,\n\t\t\t\ti = \"0\",\n\t\t\t\tunmatched = seed && [],\n\t\t\t\tsetMatched = [],\n\t\t\t\tcontextBackup = outermostContext,\n\t\t\t\t// We must always have either seed elements or outermost context\n\t\t\t\telems = seed || byElement && Expr.find[\"TAG\"]( \"*\", outermost ),\n\t\t\t\t// Use integer dirruns iff this is the outermost matcher\n\t\t\t\tdirrunsUnique = (dirruns += contextBackup == null ? 1 : Math.random() || 0.1),\n\t\t\t\tlen = elems.length;\n\n\t\t\tif ( outermost ) {\n\t\t\t\toutermostContext = context === document || context || outermost;\n\t\t\t}\n\n\t\t\t// Add elements passing elementMatchers directly to results\n\t\t\t// Support: IE<9, Safari\n\t\t\t// Tolerate NodeList properties (IE: \"length\"; Safari: <number>) matching elements by id\n\t\t\tfor ( ; i !== len && (elem = elems[i]) != null; i++ ) {\n\t\t\t\tif ( byElement && elem ) {\n\t\t\t\t\tj = 0;\n\t\t\t\t\tif ( !context && elem.ownerDocument !== document ) {\n\t\t\t\t\t\tsetDocument( elem );\n\t\t\t\t\t\txml = !documentIsHTML;\n\t\t\t\t\t}\n\t\t\t\t\twhile ( (matcher = elementMatchers[j++]) ) {\n\t\t\t\t\t\tif ( matcher( elem, context || document, xml) ) {\n\t\t\t\t\t\t\tresults.push( elem );\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif ( outermost ) {\n\t\t\t\t\t\tdirruns = dirrunsUnique;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// Track unmatched elements for set filters\n\t\t\t\tif ( bySet ) {\n\t\t\t\t\t// They will have gone through all possible matchers\n\t\t\t\t\tif ( (elem = !matcher && elem) ) {\n\t\t\t\t\t\tmatchedCount--;\n\t\t\t\t\t}\n\n\t\t\t\t\t// Lengthen the array for every element, matched or not\n\t\t\t\t\tif ( seed ) {\n\t\t\t\t\t\tunmatched.push( elem );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// `i` is now the count of elements visited above, and adding it to `matchedCount`\n\t\t\t// makes the latter nonnegative.\n\t\t\tmatchedCount += i;\n\n\t\t\t// Apply set filters to unmatched elements\n\t\t\t// NOTE: This can be skipped if there are no unmatched elements (i.e., `matchedCount`\n\t\t\t// equals `i`), unless we didn't visit _any_ elements in the above loop because we have\n\t\t\t// no element matchers and no seed.\n\t\t\t// Incrementing an initially-string \"0\" `i` allows `i` to remain a string only in that\n\t\t\t// case, which will result in a \"00\" `matchedCount` that differs from `i` but is also\n\t\t\t// numerically zero.\n\t\t\tif ( bySet && i !== matchedCount ) {\n\t\t\t\tj = 0;\n\t\t\t\twhile ( (matcher = setMatchers[j++]) ) {\n\t\t\t\t\tmatcher( unmatched, setMatched, context, xml );\n\t\t\t\t}\n\n\t\t\t\tif ( seed ) {\n\t\t\t\t\t// Reintegrate element matches to eliminate the need for sorting\n\t\t\t\t\tif ( matchedCount > 0 ) {\n\t\t\t\t\t\twhile ( i-- ) {\n\t\t\t\t\t\t\tif ( !(unmatched[i] || setMatched[i]) ) {\n\t\t\t\t\t\t\t\tsetMatched[i] = pop.call( results );\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\t// Discard index placeholder values to get only actual matches\n\t\t\t\t\tsetMatched = condense( setMatched );\n\t\t\t\t}\n\n\t\t\t\t// Add matches to results\n\t\t\t\tpush.apply( results, setMatched );\n\n\t\t\t\t// Seedless set matches succeeding multiple successful matchers stipulate sorting\n\t\t\t\tif ( outermost && !seed && setMatched.length > 0 &&\n\t\t\t\t\t( matchedCount + setMatchers.length ) > 1 ) {\n\n\t\t\t\t\tSizzle.uniqueSort( results );\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Override manipulation of globals by nested matchers\n\t\t\tif ( outermost ) {\n\t\t\t\tdirruns = dirrunsUnique;\n\t\t\t\toutermostContext = contextBackup;\n\t\t\t}\n\n\t\t\treturn unmatched;\n\t\t};\n\n\treturn bySet ?\n\t\tmarkFunction( superMatcher ) :\n\t\tsuperMatcher;\n}\n\ncompile = Sizzle.compile = function( selector, match /* Internal Use Only */ ) {\n\tvar i,\n\t\tsetMatchers = [],\n\t\telementMatchers = [],\n\t\tcached = compilerCache[ selector + \" \" ];\n\n\tif ( !cached ) {\n\t\t// Generate a function of recursive functions that can be used to check each element\n\t\tif ( !match ) {\n\t\t\tmatch = tokenize( selector );\n\t\t}\n\t\ti = match.length;\n\t\twhile ( i-- ) {\n\t\t\tcached = matcherFromTokens( match[i] );\n\t\t\tif ( cached[ expando ] ) {\n\t\t\t\tsetMatchers.push( cached );\n\t\t\t} else {\n\t\t\t\telementMatchers.push( cached );\n\t\t\t}\n\t\t}\n\n\t\t// Cache the compiled function\n\t\tcached = compilerCache( selector, matcherFromGroupMatchers( elementMatchers, setMatchers ) );\n\n\t\t// Save selector and tokenization\n\t\tcached.selector = selector;\n\t}\n\treturn cached;\n};\n\n/**\n * A low-level selection function that works with Sizzle's compiled\n *  selector functions\n * @param {String|Function} selector A selector or a pre-compiled\n *  selector function built with Sizzle.compile\n * @param {Element} context\n * @param {Array} [results]\n * @param {Array} [seed] A set of elements to match against\n */\nselect = Sizzle.select = function( selector, context, results, seed ) {\n\tvar i, tokens, token, type, find,\n\t\tcompiled = typeof selector === \"function\" && selector,\n\t\tmatch = !seed && tokenize( (selector = compiled.selector || selector) );\n\n\tresults = results || [];\n\n\t// Try to minimize operations if there is only one selector in the list and no seed\n\t// (the latter of which guarantees us context)\n\tif ( match.length === 1 ) {\n\n\t\t// Reduce context if the leading compound selector is an ID\n\t\ttokens = match[0] = match[0].slice( 0 );\n\t\tif ( tokens.length > 2 && (token = tokens[0]).type === \"ID\" &&\n\t\t\t\tcontext.nodeType === 9 && documentIsHTML && Expr.relative[ tokens[1].type ] ) {\n\n\t\t\tcontext = ( Expr.find[\"ID\"]( token.matches[0].replace(runescape, funescape), context ) || [] )[0];\n\t\t\tif ( !context ) {\n\t\t\t\treturn results;\n\n\t\t\t// Precompiled matchers will still verify ancestry, so step up a level\n\t\t\t} else if ( compiled ) {\n\t\t\t\tcontext = context.parentNode;\n\t\t\t}\n\n\t\t\tselector = selector.slice( tokens.shift().value.length );\n\t\t}\n\n\t\t// Fetch a seed set for right-to-left matching\n\t\ti = matchExpr[\"needsContext\"].test( selector ) ? 0 : tokens.length;\n\t\twhile ( i-- ) {\n\t\t\ttoken = tokens[i];\n\n\t\t\t// Abort if we hit a combinator\n\t\t\tif ( Expr.relative[ (type = token.type) ] ) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif ( (find = Expr.find[ type ]) ) {\n\t\t\t\t// Search, expanding context for leading sibling combinators\n\t\t\t\tif ( (seed = find(\n\t\t\t\t\ttoken.matches[0].replace( runescape, funescape ),\n\t\t\t\t\trsibling.test( tokens[0].type ) && testContext( context.parentNode ) || context\n\t\t\t\t)) ) {\n\n\t\t\t\t\t// If seed is empty or no tokens remain, we can return early\n\t\t\t\t\ttokens.splice( i, 1 );\n\t\t\t\t\tselector = seed.length && toSelector( tokens );\n\t\t\t\t\tif ( !selector ) {\n\t\t\t\t\t\tpush.apply( results, seed );\n\t\t\t\t\t\treturn results;\n\t\t\t\t\t}\n\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t// Compile and execute a filtering function if one is not provided\n\t// Provide `match` to avoid retokenization if we modified the selector above\n\t( compiled || compile( selector, match ) )(\n\t\tseed,\n\t\tcontext,\n\t\t!documentIsHTML,\n\t\tresults,\n\t\t!context || rsibling.test( selector ) && testContext( context.parentNode ) || context\n\t);\n\treturn results;\n};\n\n// One-time assignments\n\n// Sort stability\nsupport.sortStable = expando.split(\"\").sort( sortOrder ).join(\"\") === expando;\n\n// Support: Chrome 14-35+\n// Always assume duplicates if they aren't passed to the comparison function\nsupport.detectDuplicates = !!hasDuplicate;\n\n// Initialize against the default document\nsetDocument();\n\n// Support: Webkit<537.32 - Safari 6.0.3/Chrome 25 (fixed in Chrome 27)\n// Detached nodes confoundingly follow *each other*\nsupport.sortDetached = assert(function( el ) {\n\t// Should return 1, but returns 4 (following)\n\treturn el.compareDocumentPosition( document.createElement(\"fieldset\") ) & 1;\n});\n\n// Support: IE<8\n// Prevent attribute/property \"interpolation\"\n// https://msdn.microsoft.com/en-us/library/ms536429%28VS.85%29.aspx\nif ( !assert(function( el ) {\n\tel.innerHTML = \"<a href='#'></a>\";\n\treturn el.firstChild.getAttribute(\"href\") === \"#\" ;\n}) ) {\n\taddHandle( \"type|href|height|width\", function( elem, name, isXML ) {\n\t\tif ( !isXML ) {\n\t\t\treturn elem.getAttribute( name, name.toLowerCase() === \"type\" ? 1 : 2 );\n\t\t}\n\t});\n}\n\n// Support: IE<9\n// Use defaultValue in place of getAttribute(\"value\")\nif ( !support.attributes || !assert(function( el ) {\n\tel.innerHTML = \"<input/>\";\n\tel.firstChild.setAttribute( \"value\", \"\" );\n\treturn el.firstChild.getAttribute( \"value\" ) === \"\";\n}) ) {\n\taddHandle( \"value\", function( elem, name, isXML ) {\n\t\tif ( !isXML && elem.nodeName.toLowerCase() === \"input\" ) {\n\t\t\treturn elem.defaultValue;\n\t\t}\n\t});\n}\n\n// Support: IE<9\n// Use getAttributeNode to fetch booleans when getAttribute lies\nif ( !assert(function( el ) {\n\treturn el.getAttribute(\"disabled\") == null;\n}) ) {\n\taddHandle( booleans, function( elem, name, isXML ) {\n\t\tvar val;\n\t\tif ( !isXML ) {\n\t\t\treturn elem[ name ] === true ? name.toLowerCase() :\n\t\t\t\t\t(val = elem.getAttributeNode( name )) && val.specified ?\n\t\t\t\t\tval.value :\n\t\t\t\tnull;\n\t\t}\n\t});\n}\n\nreturn Sizzle;\n\n})( window );\n\n\n\njQuery.find = Sizzle;\njQuery.expr = Sizzle.selectors;\n\n// Deprecated\njQuery.expr[ \":\" ] = jQuery.expr.pseudos;\njQuery.uniqueSort = jQuery.unique = Sizzle.uniqueSort;\njQuery.text = Sizzle.getText;\njQuery.isXMLDoc = Sizzle.isXML;\njQuery.contains = Sizzle.contains;\njQuery.escapeSelector = Sizzle.escape;\n\n\n\n\nvar dir = function( elem, dir, until ) {\n\tvar matched = [],\n\t\ttruncate = until !== undefined;\n\n\twhile ( ( elem = elem[ dir ] ) && elem.nodeType !== 9 ) {\n\t\tif ( elem.nodeType === 1 ) {\n\t\t\tif ( truncate && jQuery( elem ).is( until ) ) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tmatched.push( elem );\n\t\t}\n\t}\n\treturn matched;\n};\n\n\nvar siblings = function( n, elem ) {\n\tvar matched = [];\n\n\tfor ( ; n; n = n.nextSibling ) {\n\t\tif ( n.nodeType === 1 && n !== elem ) {\n\t\t\tmatched.push( n );\n\t\t}\n\t}\n\n\treturn matched;\n};\n\n\nvar rneedsContext = jQuery.expr.match.needsContext;\n\n\n\nfunction nodeName( elem, name ) {\n\n  return elem.nodeName && elem.nodeName.toLowerCase() === name.toLowerCase();\n\n};\nvar rsingleTag = ( /^<([a-z][^\\/\\0>:\\x20\\t\\r\\n\\f]*)[\\x20\\t\\r\\n\\f]*\\/?>(?:<\\/\\1>|)$/i );\n\n\n\n// Implement the identical functionality for filter and not\nfunction winnow( elements, qualifier, not ) {\n\tif ( isFunction( qualifier ) ) {\n\t\treturn jQuery.grep( elements, function( elem, i ) {\n\t\t\treturn !!qualifier.call( elem, i, elem ) !== not;\n\t\t} );\n\t}\n\n\t// Single element\n\tif ( qualifier.nodeType ) {\n\t\treturn jQuery.grep( elements, function( elem ) {\n\t\t\treturn ( elem === qualifier ) !== not;\n\t\t} );\n\t}\n\n\t// Arraylike of elements (jQuery, arguments, Array)\n\tif ( typeof qualifier !== \"string\" ) {\n\t\treturn jQuery.grep( elements, function( elem ) {\n\t\t\treturn ( indexOf.call( qualifier, elem ) > -1 ) !== not;\n\t\t} );\n\t}\n\n\t// Filtered directly for both simple and complex selectors\n\treturn jQuery.filter( qualifier, elements, not );\n}\n\njQuery.filter = function( expr, elems, not ) {\n\tvar elem = elems[ 0 ];\n\n\tif ( not ) {\n\t\texpr = \":not(\" + expr + \")\";\n\t}\n\n\tif ( elems.length === 1 && elem.nodeType === 1 ) {\n\t\treturn jQuery.find.matchesSelector( elem, expr ) ? [ elem ] : [];\n\t}\n\n\treturn jQuery.find.matches( expr, jQuery.grep( elems, function( elem ) {\n\t\treturn elem.nodeType === 1;\n\t} ) );\n};\n\njQuery.fn.extend( {\n\tfind: function( selector ) {\n\t\tvar i, ret,\n\t\t\tlen = this.length,\n\t\t\tself = this;\n\n\t\tif ( typeof selector !== \"string\" ) {\n\t\t\treturn this.pushStack( jQuery( selector ).filter( function() {\n\t\t\t\tfor ( i = 0; i < len; i++ ) {\n\t\t\t\t\tif ( jQuery.contains( self[ i ], this ) ) {\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} ) );\n\t\t}\n\n\t\tret = this.pushStack( [] );\n\n\t\tfor ( i = 0; i < len; i++ ) {\n\t\t\tjQuery.find( selector, self[ i ], ret );\n\t\t}\n\n\t\treturn len > 1 ? jQuery.uniqueSort( ret ) : ret;\n\t},\n\tfilter: function( selector ) {\n\t\treturn this.pushStack( winnow( this, selector || [], false ) );\n\t},\n\tnot: function( selector ) {\n\t\treturn this.pushStack( winnow( this, selector || [], true ) );\n\t},\n\tis: function( selector ) {\n\t\treturn !!winnow(\n\t\t\tthis,\n\n\t\t\t// If this is a positional/relative selector, check membership in the returned set\n\t\t\t// so $(\"p:first\").is(\"p:last\") won't return true for a doc with two \"p\".\n\t\t\ttypeof selector === \"string\" && rneedsContext.test( selector ) ?\n\t\t\t\tjQuery( selector ) :\n\t\t\t\tselector || [],\n\t\t\tfalse\n\t\t).length;\n\t}\n} );\n\n\n// Initialize a jQuery object\n\n\n// A central reference to the root jQuery(document)\nvar rootjQuery,\n\n\t// A simple way to check for HTML strings\n\t// Prioritize #id over <tag> to avoid XSS via location.hash (#9521)\n\t// Strict HTML recognition (#11290: must start with <)\n\t// Shortcut simple #id case for speed\n\trquickExpr = /^(?:\\s*(<[\\w\\W]+>)[^>]*|#([\\w-]+))$/,\n\n\tinit = jQuery.fn.init = function( selector, context, root ) {\n\t\tvar match, elem;\n\n\t\t// HANDLE: $(\"\"), $(null), $(undefined), $(false)\n\t\tif ( !selector ) {\n\t\t\treturn this;\n\t\t}\n\n\t\t// Method init() accepts an alternate rootjQuery\n\t\t// so migrate can support jQuery.sub (gh-2101)\n\t\troot = root || rootjQuery;\n\n\t\t// Handle HTML strings\n\t\tif ( typeof selector === \"string\" ) {\n\t\t\tif ( selector[ 0 ] === \"<\" &&\n\t\t\t\tselector[ selector.length - 1 ] === \">\" &&\n\t\t\t\tselector.length >= 3 ) {\n\n\t\t\t\t// Assume that strings that start and end with <> are HTML and skip the regex check\n\t\t\t\tmatch = [ null, selector, null ];\n\n\t\t\t} else {\n\t\t\t\tmatch = rquickExpr.exec( selector );\n\t\t\t}\n\n\t\t\t// Match html or make sure no context is specified for #id\n\t\t\tif ( match && ( match[ 1 ] || !context ) ) {\n\n\t\t\t\t// HANDLE: $(html) -> $(array)\n\t\t\t\tif ( match[ 1 ] ) {\n\t\t\t\t\tcontext = context instanceof jQuery ? context[ 0 ] : context;\n\n\t\t\t\t\t// Option to run scripts is true for back-compat\n\t\t\t\t\t// Intentionally let the error be thrown if parseHTML is not present\n\t\t\t\t\tjQuery.merge( this, jQuery.parseHTML(\n\t\t\t\t\t\tmatch[ 1 ],\n\t\t\t\t\t\tcontext && context.nodeType ? context.ownerDocument || context : document,\n\t\t\t\t\t\ttrue\n\t\t\t\t\t) );\n\n\t\t\t\t\t// HANDLE: $(html, props)\n\t\t\t\t\tif ( rsingleTag.test( match[ 1 ] ) && jQuery.isPlainObject( context ) ) {\n\t\t\t\t\t\tfor ( match in context ) {\n\n\t\t\t\t\t\t\t// Properties of context are called as methods if possible\n\t\t\t\t\t\t\tif ( isFunction( this[ match ] ) ) {\n\t\t\t\t\t\t\t\tthis[ match ]( context[ match ] );\n\n\t\t\t\t\t\t\t// ...and otherwise set as attributes\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tthis.attr( match, context[ match ] );\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\treturn this;\n\n\t\t\t\t// HANDLE: $(#id)\n\t\t\t\t} else {\n\t\t\t\t\telem = document.getElementById( match[ 2 ] );\n\n\t\t\t\t\tif ( elem ) {\n\n\t\t\t\t\t\t// Inject the element directly into the jQuery object\n\t\t\t\t\t\tthis[ 0 ] = elem;\n\t\t\t\t\t\tthis.length = 1;\n\t\t\t\t\t}\n\t\t\t\t\treturn this;\n\t\t\t\t}\n\n\t\t\t// HANDLE: $(expr, $(...))\n\t\t\t} else if ( !context || context.jquery ) {\n\t\t\t\treturn ( context || root ).find( selector );\n\n\t\t\t// HANDLE: $(expr, context)\n\t\t\t// (which is just equivalent to: $(context).find(expr)\n\t\t\t} else {\n\t\t\t\treturn this.constructor( context ).find( selector );\n\t\t\t}\n\n\t\t// HANDLE: $(DOMElement)\n\t\t} else if ( selector.nodeType ) {\n\t\t\tthis[ 0 ] = selector;\n\t\t\tthis.length = 1;\n\t\t\treturn this;\n\n\t\t// HANDLE: $(function)\n\t\t// Shortcut for document ready\n\t\t} else if ( isFunction( selector ) ) {\n\t\t\treturn root.ready !== undefined ?\n\t\t\t\troot.ready( selector ) :\n\n\t\t\t\t// Execute immediately if ready is not present\n\t\t\t\tselector( jQuery );\n\t\t}\n\n\t\treturn jQuery.makeArray( selector, this );\n\t};\n\n// Give the init function the jQuery prototype for later instantiation\ninit.prototype = jQuery.fn;\n\n// Initialize central reference\nrootjQuery = jQuery( document );\n\n\nvar rparentsprev = /^(?:parents|prev(?:Until|All))/,\n\n\t// Methods guaranteed to produce a unique set when starting from a unique set\n\tguaranteedUnique = {\n\t\tchildren: true,\n\t\tcontents: true,\n\t\tnext: true,\n\t\tprev: true\n\t};\n\njQuery.fn.extend( {\n\thas: function( target ) {\n\t\tvar targets = jQuery( target, this ),\n\t\t\tl = targets.length;\n\n\t\treturn this.filter( function() {\n\t\t\tvar i = 0;\n\t\t\tfor ( ; i < l; i++ ) {\n\t\t\t\tif ( jQuery.contains( this, targets[ i ] ) ) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t} );\n\t},\n\n\tclosest: function( selectors, context ) {\n\t\tvar cur,\n\t\t\ti = 0,\n\t\t\tl = this.length,\n\t\t\tmatched = [],\n\t\t\ttargets = typeof selectors !== \"string\" && jQuery( selectors );\n\n\t\t// Positional selectors never match, since there's no _selection_ context\n\t\tif ( !rneedsContext.test( selectors ) ) {\n\t\t\tfor ( ; i < l; i++ ) {\n\t\t\t\tfor ( cur = this[ i ]; cur && cur !== context; cur = cur.parentNode ) {\n\n\t\t\t\t\t// Always skip document fragments\n\t\t\t\t\tif ( cur.nodeType < 11 && ( targets ?\n\t\t\t\t\t\ttargets.index( cur ) > -1 :\n\n\t\t\t\t\t\t// Don't pass non-elements to Sizzle\n\t\t\t\t\t\tcur.nodeType === 1 &&\n\t\t\t\t\t\t\tjQuery.find.matchesSelector( cur, selectors ) ) ) {\n\n\t\t\t\t\t\tmatched.push( cur );\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn this.pushStack( matched.length > 1 ? jQuery.uniqueSort( matched ) : matched );\n\t},\n\n\t// Determine the position of an element within the set\n\tindex: function( elem ) {\n\n\t\t// No argument, return index in parent\n\t\tif ( !elem ) {\n\t\t\treturn ( this[ 0 ] && this[ 0 ].parentNode ) ? this.first().prevAll().length : -1;\n\t\t}\n\n\t\t// Index in selector\n\t\tif ( typeof elem === \"string\" ) {\n\t\t\treturn indexOf.call( jQuery( elem ), this[ 0 ] );\n\t\t}\n\n\t\t// Locate the position of the desired element\n\t\treturn indexOf.call( this,\n\n\t\t\t// If it receives a jQuery object, the first element is used\n\t\t\telem.jquery ? elem[ 0 ] : elem\n\t\t);\n\t},\n\n\tadd: function( selector, context ) {\n\t\treturn this.pushStack(\n\t\t\tjQuery.uniqueSort(\n\t\t\t\tjQuery.merge( this.get(), jQuery( selector, context ) )\n\t\t\t)\n\t\t);\n\t},\n\n\taddBack: function( selector ) {\n\t\treturn this.add( selector == null ?\n\t\t\tthis.prevObject : this.prevObject.filter( selector )\n\t\t);\n\t}\n} );\n\nfunction sibling( cur, dir ) {\n\twhile ( ( cur = cur[ dir ] ) && cur.nodeType !== 1 ) {}\n\treturn cur;\n}\n\njQuery.each( {\n\tparent: function( elem ) {\n\t\tvar parent = elem.parentNode;\n\t\treturn parent && parent.nodeType !== 11 ? parent : null;\n\t},\n\tparents: function( elem ) {\n\t\treturn dir( elem, \"parentNode\" );\n\t},\n\tparentsUntil: function( elem, i, until ) {\n\t\treturn dir( elem, \"parentNode\", until );\n\t},\n\tnext: function( elem ) {\n\t\treturn sibling( elem, \"nextSibling\" );\n\t},\n\tprev: function( elem ) {\n\t\treturn sibling( elem, \"previousSibling\" );\n\t},\n\tnextAll: function( elem ) {\n\t\treturn dir( elem, \"nextSibling\" );\n\t},\n\tprevAll: function( elem ) {\n\t\treturn dir( elem, \"previousSibling\" );\n\t},\n\tnextUntil: function( elem, i, until ) {\n\t\treturn dir( elem, \"nextSibling\", until );\n\t},\n\tprevUntil: function( elem, i, until ) {\n\t\treturn dir( elem, \"previousSibling\", until );\n\t},\n\tsiblings: function( elem ) {\n\t\treturn siblings( ( elem.parentNode || {} ).firstChild, elem );\n\t},\n\tchildren: function( elem ) {\n\t\treturn siblings( elem.firstChild );\n\t},\n\tcontents: function( elem ) {\n\t\tif ( typeof elem.contentDocument !== \"undefined\" ) {\n\t\t\treturn elem.contentDocument;\n\t\t}\n\n\t\t// Support: IE 9 - 11 only, iOS 7 only, Android Browser <=4.3 only\n\t\t// Treat the template element as a regular one in browsers that\n\t\t// don't support it.\n\t\tif ( nodeName( elem, \"template\" ) ) {\n\t\t\telem = elem.content || elem;\n\t\t}\n\n\t\treturn jQuery.merge( [], elem.childNodes );\n\t}\n}, function( name, fn ) {\n\tjQuery.fn[ name ] = function( until, selector ) {\n\t\tvar matched = jQuery.map( this, fn, until );\n\n\t\tif ( name.slice( -5 ) !== \"Until\" ) {\n\t\t\tselector = until;\n\t\t}\n\n\t\tif ( selector && typeof selector === \"string\" ) {\n\t\t\tmatched = jQuery.filter( selector, matched );\n\t\t}\n\n\t\tif ( this.length > 1 ) {\n\n\t\t\t// Remove duplicates\n\t\t\tif ( !guaranteedUnique[ name ] ) {\n\t\t\t\tjQuery.uniqueSort( matched );\n\t\t\t}\n\n\t\t\t// Reverse order for parents* and prev-derivatives\n\t\t\tif ( rparentsprev.test( name ) ) {\n\t\t\t\tmatched.reverse();\n\t\t\t}\n\t\t}\n\n\t\treturn this.pushStack( matched );\n\t};\n} );\nvar rnothtmlwhite = ( /[^\\x20\\t\\r\\n\\f]+/g );\n\n\n\n// Convert String-formatted options into Object-formatted ones\nfunction createOptions( options ) {\n\tvar object = {};\n\tjQuery.each( options.match( rnothtmlwhite ) || [], function( _, flag ) {\n\t\tobject[ flag ] = true;\n\t} );\n\treturn object;\n}\n\n/*\n * Create a callback list using the following parameters:\n *\n *\toptions: an optional list of space-separated options that will change how\n *\t\t\tthe callback list behaves or a more traditional option object\n *\n * By default a callback list will act like an event callback list and can be\n * \"fired\" multiple times.\n *\n * Possible options:\n *\n *\tonce:\t\t\twill ensure the callback list can only be fired once (like a Deferred)\n *\n *\tmemory:\t\t\twill keep track of previous values and will call any callback added\n *\t\t\t\t\tafter the list has been fired right away with the latest \"memorized\"\n *\t\t\t\t\tvalues (like a Deferred)\n *\n *\tunique:\t\t\twill ensure a callback can only be added once (no duplicate in the list)\n *\n *\tstopOnFalse:\tinterrupt callings when a callback returns false\n *\n */\njQuery.Callbacks = function( options ) {\n\n\t// Convert options from String-formatted to Object-formatted if needed\n\t// (we check in cache first)\n\toptions = typeof options === \"string\" ?\n\t\tcreateOptions( options ) :\n\t\tjQuery.extend( {}, options );\n\n\tvar // Flag to know if list is currently firing\n\t\tfiring,\n\n\t\t// Last fire value for non-forgettable lists\n\t\tmemory,\n\n\t\t// Flag to know if list was already fired\n\t\tfired,\n\n\t\t// Flag to prevent firing\n\t\tlocked,\n\n\t\t// Actual callback list\n\t\tlist = [],\n\n\t\t// Queue of execution data for repeatable lists\n\t\tqueue = [],\n\n\t\t// Index of currently firing callback (modified by add/remove as needed)\n\t\tfiringIndex = -1,\n\n\t\t// Fire callbacks\n\t\tfire = function() {\n\n\t\t\t// Enforce single-firing\n\t\t\tlocked = locked || options.once;\n\n\t\t\t// Execute callbacks for all pending executions,\n\t\t\t// respecting firingIndex overrides and runtime changes\n\t\t\tfired = firing = true;\n\t\t\tfor ( ; queue.length; firingIndex = -1 ) {\n\t\t\t\tmemory = queue.shift();\n\t\t\t\twhile ( ++firingIndex < list.length ) {\n\n\t\t\t\t\t// Run callback and check for early termination\n\t\t\t\t\tif ( list[ firingIndex ].apply( memory[ 0 ], memory[ 1 ] ) === false &&\n\t\t\t\t\t\toptions.stopOnFalse ) {\n\n\t\t\t\t\t\t// Jump to end and forget the data so .add doesn't re-fire\n\t\t\t\t\t\tfiringIndex = list.length;\n\t\t\t\t\t\tmemory = false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Forget the data if we're done with it\n\t\t\tif ( !options.memory ) {\n\t\t\t\tmemory = false;\n\t\t\t}\n\n\t\t\tfiring = false;\n\n\t\t\t// Clean up if we're done firing for good\n\t\t\tif ( locked ) {\n\n\t\t\t\t// Keep an empty list if we have data for future add calls\n\t\t\t\tif ( memory ) {\n\t\t\t\t\tlist = [];\n\n\t\t\t\t// Otherwise, this object is spent\n\t\t\t\t} else {\n\t\t\t\t\tlist = \"\";\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\n\t\t// Actual Callbacks object\n\t\tself = {\n\n\t\t\t// Add a callback or a collection of callbacks to the list\n\t\t\tadd: function() {\n\t\t\t\tif ( list ) {\n\n\t\t\t\t\t// If we have memory from a past run, we should fire after adding\n\t\t\t\t\tif ( memory && !firing ) {\n\t\t\t\t\t\tfiringIndex = list.length - 1;\n\t\t\t\t\t\tqueue.push( memory );\n\t\t\t\t\t}\n\n\t\t\t\t\t( function add( args ) {\n\t\t\t\t\t\tjQuery.each( args, function( _, arg ) {\n\t\t\t\t\t\t\tif ( isFunction( arg ) ) {\n\t\t\t\t\t\t\t\tif ( !options.unique || !self.has( arg ) ) {\n\t\t\t\t\t\t\t\t\tlist.push( arg );\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t} else if ( arg && arg.length && toType( arg ) !== \"string\" ) {\n\n\t\t\t\t\t\t\t\t// Inspect recursively\n\t\t\t\t\t\t\t\tadd( arg );\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} );\n\t\t\t\t\t} )( arguments );\n\n\t\t\t\t\tif ( memory && !firing ) {\n\t\t\t\t\t\tfire();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn this;\n\t\t\t},\n\n\t\t\t// Remove a callback from the list\n\t\t\tremove: function() {\n\t\t\t\tjQuery.each( arguments, function( _, arg ) {\n\t\t\t\t\tvar index;\n\t\t\t\t\twhile ( ( index = jQuery.inArray( arg, list, index ) ) > -1 ) {\n\t\t\t\t\t\tlist.splice( index, 1 );\n\n\t\t\t\t\t\t// Handle firing indexes\n\t\t\t\t\t\tif ( index <= firingIndex ) {\n\t\t\t\t\t\t\tfiringIndex--;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} );\n\t\t\t\treturn this;\n\t\t\t},\n\n\t\t\t// Check if a given callback is in the list.\n\t\t\t// If no argument is given, return whether or not list has callbacks attached.\n\t\t\thas: function( fn ) {\n\t\t\t\treturn fn ?\n\t\t\t\t\tjQuery.inArray( fn, list ) > -1 :\n\t\t\t\t\tlist.length > 0;\n\t\t\t},\n\n\t\t\t// Remove all callbacks from the list\n\t\t\tempty: function() {\n\t\t\t\tif ( list ) {\n\t\t\t\t\tlist = [];\n\t\t\t\t}\n\t\t\t\treturn this;\n\t\t\t},\n\n\t\t\t// Disable .fire and .add\n\t\t\t// Abort any current/pending executions\n\t\t\t// Clear all callbacks and values\n\t\t\tdisable: function() {\n\t\t\t\tlocked = queue = [];\n\t\t\t\tlist = memory = \"\";\n\t\t\t\treturn this;\n\t\t\t},\n\t\t\tdisabled: function() {\n\t\t\t\treturn !list;\n\t\t\t},\n\n\t\t\t// Disable .fire\n\t\t\t// Also disable .add unless we have memory (since it would have no effect)\n\t\t\t// Abort any pending executions\n\t\t\tlock: function() {\n\t\t\t\tlocked = queue = [];\n\t\t\t\tif ( !memory && !firing ) {\n\t\t\t\t\tlist = memory = \"\";\n\t\t\t\t}\n\t\t\t\treturn this;\n\t\t\t},\n\t\t\tlocked: function() {\n\t\t\t\treturn !!locked;\n\t\t\t},\n\n\t\t\t// Call all callbacks with the given context and arguments\n\t\t\tfireWith: function( context, args ) {\n\t\t\t\tif ( !locked ) {\n\t\t\t\t\targs = args || [];\n\t\t\t\t\targs = [ context, args.slice ? args.slice() : args ];\n\t\t\t\t\tqueue.push( args );\n\t\t\t\t\tif ( !firing ) {\n\t\t\t\t\t\tfire();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn this;\n\t\t\t},\n\n\t\t\t// Call all the callbacks with the given arguments\n\t\t\tfire: function() {\n\t\t\t\tself.fireWith( this, arguments );\n\t\t\t\treturn this;\n\t\t\t},\n\n\t\t\t// To know if the callbacks have already been called at least once\n\t\t\tfired: function() {\n\t\t\t\treturn !!fired;\n\t\t\t}\n\t\t};\n\n\treturn self;\n};\n\n\nfunction Identity( v ) {\n\treturn v;\n}\nfunction Thrower( ex ) {\n\tthrow ex;\n}\n\nfunction adoptValue( value, resolve, reject, noValue ) {\n\tvar method;\n\n\ttry {\n\n\t\t// Check for promise aspect first to privilege synchronous behavior\n\t\tif ( value && isFunction( ( method = value.promise ) ) ) {\n\t\t\tmethod.call( value ).done( resolve ).fail( reject );\n\n\t\t// Other thenables\n\t\t} else if ( value && isFunction( ( method = value.then ) ) ) {\n\t\t\tmethod.call( value, resolve, reject );\n\n\t\t// Other non-thenables\n\t\t} else {\n\n\t\t\t// Control `resolve` arguments by letting Array#slice cast boolean `noValue` to integer:\n\t\t\t// * false: [ value ].slice( 0 ) => resolve( value )\n\t\t\t// * true: [ value ].slice( 1 ) => resolve()\n\t\t\tresolve.apply( undefined, [ value ].slice( noValue ) );\n\t\t}\n\n\t// For Promises/A+, convert exceptions into rejections\n\t// Since jQuery.when doesn't unwrap thenables, we can skip the extra checks appearing in\n\t// Deferred#then to conditionally suppress rejection.\n\t} catch ( value ) {\n\n\t\t// Support: Android 4.0 only\n\t\t// Strict mode functions invoked without .call/.apply get global-object context\n\t\treject.apply( undefined, [ value ] );\n\t}\n}\n\njQuery.extend( {\n\n\tDeferred: function( func ) {\n\t\tvar tuples = [\n\n\t\t\t\t// action, add listener, callbacks,\n\t\t\t\t// ... .then handlers, argument index, [final state]\n\t\t\t\t[ \"notify\", \"progress\", jQuery.Callbacks( \"memory\" ),\n\t\t\t\t\tjQuery.Callbacks( \"memory\" ), 2 ],\n\t\t\t\t[ \"resolve\", \"done\", jQuery.Callbacks( \"once memory\" ),\n\t\t\t\t\tjQuery.Callbacks( \"once memory\" ), 0, \"resolved\" ],\n\t\t\t\t[ \"reject\", \"fail\", jQuery.Callbacks( \"once memory\" ),\n\t\t\t\t\tjQuery.Callbacks( \"once memory\" ), 1, \"rejected\" ]\n\t\t\t],\n\t\t\tstate = \"pending\",\n\t\t\tpromise = {\n\t\t\t\tstate: function() {\n\t\t\t\t\treturn state;\n\t\t\t\t},\n\t\t\t\talways: function() {\n\t\t\t\t\tdeferred.done( arguments ).fail( arguments );\n\t\t\t\t\treturn this;\n\t\t\t\t},\n\t\t\t\t\"catch\": function( fn ) {\n\t\t\t\t\treturn promise.then( null, fn );\n\t\t\t\t},\n\n\t\t\t\t// Keep pipe for back-compat\n\t\t\t\tpipe: function( /* fnDone, fnFail, fnProgress */ ) {\n\t\t\t\t\tvar fns = arguments;\n\n\t\t\t\t\treturn jQuery.Deferred( function( newDefer ) {\n\t\t\t\t\t\tjQuery.each( tuples, function( i, tuple ) {\n\n\t\t\t\t\t\t\t// Map tuples (progress, done, fail) to arguments (done, fail, progress)\n\t\t\t\t\t\t\tvar fn = isFunction( fns[ tuple[ 4 ] ] ) && fns[ tuple[ 4 ] ];\n\n\t\t\t\t\t\t\t// deferred.progress(function() { bind to newDefer or newDefer.notify })\n\t\t\t\t\t\t\t// deferred.done(function() { bind to newDefer or newDefer.resolve })\n\t\t\t\t\t\t\t// deferred.fail(function() { bind to newDefer or newDefer.reject })\n\t\t\t\t\t\t\tdeferred[ tuple[ 1 ] ]( function() {\n\t\t\t\t\t\t\t\tvar returned = fn && fn.apply( this, arguments );\n\t\t\t\t\t\t\t\tif ( returned && isFunction( returned.promise ) ) {\n\t\t\t\t\t\t\t\t\treturned.promise()\n\t\t\t\t\t\t\t\t\t\t.progress( newDefer.notify )\n\t\t\t\t\t\t\t\t\t\t.done( newDefer.resolve )\n\t\t\t\t\t\t\t\t\t\t.fail( newDefer.reject );\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\tnewDefer[ tuple[ 0 ] + \"With\" ](\n\t\t\t\t\t\t\t\t\t\tthis,\n\t\t\t\t\t\t\t\t\t\tfn ? [ returned ] : arguments\n\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t} );\n\t\t\t\t\t\t} );\n\t\t\t\t\t\tfns = null;\n\t\t\t\t\t} ).promise();\n\t\t\t\t},\n\t\t\t\tthen: function( onFulfilled, onRejected, onProgress ) {\n\t\t\t\t\tvar maxDepth = 0;\n\t\t\t\t\tfunction resolve( depth, deferred, handler, special ) {\n\t\t\t\t\t\treturn function() {\n\t\t\t\t\t\t\tvar that = this,\n\t\t\t\t\t\t\t\targs = arguments,\n\t\t\t\t\t\t\t\tmightThrow = function() {\n\t\t\t\t\t\t\t\t\tvar returned, then;\n\n\t\t\t\t\t\t\t\t\t// Support: Promises/A+ section 2.3.3.3.3\n\t\t\t\t\t\t\t\t\t// https://promisesaplus.com/#point-59\n\t\t\t\t\t\t\t\t\t// Ignore double-resolution attempts\n\t\t\t\t\t\t\t\t\tif ( depth < maxDepth ) {\n\t\t\t\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\treturned = handler.apply( that, args );\n\n\t\t\t\t\t\t\t\t\t// Support: Promises/A+ section 2.3.1\n\t\t\t\t\t\t\t\t\t// https://promisesaplus.com/#point-48\n\t\t\t\t\t\t\t\t\tif ( returned === deferred.promise() ) {\n\t\t\t\t\t\t\t\t\t\tthrow new TypeError( \"Thenable self-resolution\" );\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t// Support: Promises/A+ sections 2.3.3.1, 3.5\n\t\t\t\t\t\t\t\t\t// https://promisesaplus.com/#point-54\n\t\t\t\t\t\t\t\t\t// https://promisesaplus.com/#point-75\n\t\t\t\t\t\t\t\t\t// Retrieve `then` only once\n\t\t\t\t\t\t\t\t\tthen = returned &&\n\n\t\t\t\t\t\t\t\t\t\t// Support: Promises/A+ section 2.3.4\n\t\t\t\t\t\t\t\t\t\t// https://promisesaplus.com/#point-64\n\t\t\t\t\t\t\t\t\t\t// Only check objects and functions for thenability\n\t\t\t\t\t\t\t\t\t\t( typeof returned === \"object\" ||\n\t\t\t\t\t\t\t\t\t\t\ttypeof returned === \"function\" ) &&\n\t\t\t\t\t\t\t\t\t\treturned.then;\n\n\t\t\t\t\t\t\t\t\t// Handle a returned thenable\n\t\t\t\t\t\t\t\t\tif ( isFunction( then ) ) {\n\n\t\t\t\t\t\t\t\t\t\t// Special processors (notify) just wait for resolution\n\t\t\t\t\t\t\t\t\t\tif ( special ) {\n\t\t\t\t\t\t\t\t\t\t\tthen.call(\n\t\t\t\t\t\t\t\t\t\t\t\treturned,\n\t\t\t\t\t\t\t\t\t\t\t\tresolve( maxDepth, deferred, Identity, special ),\n\t\t\t\t\t\t\t\t\t\t\t\tresolve( maxDepth, deferred, Thrower, special )\n\t\t\t\t\t\t\t\t\t\t\t);\n\n\t\t\t\t\t\t\t\t\t\t// Normal processors (resolve) also hook into progress\n\t\t\t\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\t\t\t\t// ...and disregard older resolution values\n\t\t\t\t\t\t\t\t\t\t\tmaxDepth++;\n\n\t\t\t\t\t\t\t\t\t\t\tthen.call(\n\t\t\t\t\t\t\t\t\t\t\t\treturned,\n\t\t\t\t\t\t\t\t\t\t\t\tresolve( maxDepth, deferred, Identity, special ),\n\t\t\t\t\t\t\t\t\t\t\t\tresolve( maxDepth, deferred, Thrower, special ),\n\t\t\t\t\t\t\t\t\t\t\t\tresolve( maxDepth, deferred, Identity,\n\t\t\t\t\t\t\t\t\t\t\t\t\tdeferred.notifyWith )\n\t\t\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t// Handle all other returned values\n\t\t\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\t\t\t// Only substitute handlers pass on context\n\t\t\t\t\t\t\t\t\t\t// and multiple values (non-spec behavior)\n\t\t\t\t\t\t\t\t\t\tif ( handler !== Identity ) {\n\t\t\t\t\t\t\t\t\t\t\tthat = undefined;\n\t\t\t\t\t\t\t\t\t\t\targs = [ returned ];\n\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t\t// Process the value(s)\n\t\t\t\t\t\t\t\t\t\t// Default process is resolve\n\t\t\t\t\t\t\t\t\t\t( special || deferred.resolveWith )( that, args );\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t},\n\n\t\t\t\t\t\t\t\t// Only normal processors (resolve) catch and reject exceptions\n\t\t\t\t\t\t\t\tprocess = special ?\n\t\t\t\t\t\t\t\t\tmightThrow :\n\t\t\t\t\t\t\t\t\tfunction() {\n\t\t\t\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\t\t\t\tmightThrow();\n\t\t\t\t\t\t\t\t\t\t} catch ( e ) {\n\n\t\t\t\t\t\t\t\t\t\t\tif ( jQuery.Deferred.exceptionHook ) {\n\t\t\t\t\t\t\t\t\t\t\t\tjQuery.Deferred.exceptionHook( e,\n\t\t\t\t\t\t\t\t\t\t\t\t\tprocess.stackTrace );\n\t\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t\t\t// Support: Promises/A+ section 2.3.3.3.4.1\n\t\t\t\t\t\t\t\t\t\t\t// https://promisesaplus.com/#point-61\n\t\t\t\t\t\t\t\t\t\t\t// Ignore post-resolution exceptions\n\t\t\t\t\t\t\t\t\t\t\tif ( depth + 1 >= maxDepth ) {\n\n\t\t\t\t\t\t\t\t\t\t\t\t// Only substitute handlers pass on context\n\t\t\t\t\t\t\t\t\t\t\t\t// and multiple values (non-spec behavior)\n\t\t\t\t\t\t\t\t\t\t\t\tif ( handler !== Thrower ) {\n\t\t\t\t\t\t\t\t\t\t\t\t\tthat = undefined;\n\t\t\t\t\t\t\t\t\t\t\t\t\targs = [ e ];\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t\t\t\tdeferred.rejectWith( that, args );\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t};\n\n\t\t\t\t\t\t\t// Support: Promises/A+ section 2.3.3.3.1\n\t\t\t\t\t\t\t// https://promisesaplus.com/#point-57\n\t\t\t\t\t\t\t// Re-resolve promises immediately to dodge false rejection from\n\t\t\t\t\t\t\t// subsequent errors\n\t\t\t\t\t\t\tif ( depth ) {\n\t\t\t\t\t\t\t\tprocess();\n\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\t// Call an optional hook to record the stack, in case of exception\n\t\t\t\t\t\t\t\t// since it's otherwise lost when execution goes async\n\t\t\t\t\t\t\t\tif ( jQuery.Deferred.getStackHook ) {\n\t\t\t\t\t\t\t\t\tprocess.stackTrace = jQuery.Deferred.getStackHook();\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\twindow.setTimeout( process );\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t};\n\t\t\t\t\t}\n\n\t\t\t\t\treturn jQuery.Deferred( function( newDefer ) {\n\n\t\t\t\t\t\t// progress_handlers.add( ... )\n\t\t\t\t\t\ttuples[ 0 ][ 3 ].add(\n\t\t\t\t\t\t\tresolve(\n\t\t\t\t\t\t\t\t0,\n\t\t\t\t\t\t\t\tnewDefer,\n\t\t\t\t\t\t\t\tisFunction( onProgress ) ?\n\t\t\t\t\t\t\t\t\tonProgress :\n\t\t\t\t\t\t\t\t\tIdentity,\n\t\t\t\t\t\t\t\tnewDefer.notifyWith\n\t\t\t\t\t\t\t)\n\t\t\t\t\t\t);\n\n\t\t\t\t\t\t// fulfilled_handlers.add( ... )\n\t\t\t\t\t\ttuples[ 1 ][ 3 ].add(\n\t\t\t\t\t\t\tresolve(\n\t\t\t\t\t\t\t\t0,\n\t\t\t\t\t\t\t\tnewDefer,\n\t\t\t\t\t\t\t\tisFunction( onFulfilled ) ?\n\t\t\t\t\t\t\t\t\tonFulfilled :\n\t\t\t\t\t\t\t\t\tIdentity\n\t\t\t\t\t\t\t)\n\t\t\t\t\t\t);\n\n\t\t\t\t\t\t// rejected_handlers.add( ... )\n\t\t\t\t\t\ttuples[ 2 ][ 3 ].add(\n\t\t\t\t\t\t\tresolve(\n\t\t\t\t\t\t\t\t0,\n\t\t\t\t\t\t\t\tnewDefer,\n\t\t\t\t\t\t\t\tisFunction( onRejected ) ?\n\t\t\t\t\t\t\t\t\tonRejected :\n\t\t\t\t\t\t\t\t\tThrower\n\t\t\t\t\t\t\t)\n\t\t\t\t\t\t);\n\t\t\t\t\t} ).promise();\n\t\t\t\t},\n\n\t\t\t\t// Get a promise for this deferred\n\t\t\t\t// If obj is provided, the promise aspect is added to the object\n\t\t\t\tpromise: function( obj ) {\n\t\t\t\t\treturn obj != null ? jQuery.extend( obj, promise ) : promise;\n\t\t\t\t}\n\t\t\t},\n\t\t\tdeferred = {};\n\n\t\t// Add list-specific methods\n\t\tjQuery.each( tuples, function( i, tuple ) {\n\t\t\tvar list = tuple[ 2 ],\n\t\t\t\tstateString = tuple[ 5 ];\n\n\t\t\t// promise.progress = list.add\n\t\t\t// promise.done = list.add\n\t\t\t// promise.fail = list.add\n\t\t\tpromise[ tuple[ 1 ] ] = list.add;\n\n\t\t\t// Handle state\n\t\t\tif ( stateString ) {\n\t\t\t\tlist.add(\n\t\t\t\t\tfunction() {\n\n\t\t\t\t\t\t// state = \"resolved\" (i.e., fulfilled)\n\t\t\t\t\t\t// state = \"rejected\"\n\t\t\t\t\t\tstate = stateString;\n\t\t\t\t\t},\n\n\t\t\t\t\t// rejected_callbacks.disable\n\t\t\t\t\t// fulfilled_callbacks.disable\n\t\t\t\t\ttuples[ 3 - i ][ 2 ].disable,\n\n\t\t\t\t\t// rejected_handlers.disable\n\t\t\t\t\t// fulfilled_handlers.disable\n\t\t\t\t\ttuples[ 3 - i ][ 3 ].disable,\n\n\t\t\t\t\t// progress_callbacks.lock\n\t\t\t\t\ttuples[ 0 ][ 2 ].lock,\n\n\t\t\t\t\t// progress_handlers.lock\n\t\t\t\t\ttuples[ 0 ][ 3 ].lock\n\t\t\t\t);\n\t\t\t}\n\n\t\t\t// progress_handlers.fire\n\t\t\t// fulfilled_handlers.fire\n\t\t\t// rejected_handlers.fire\n\t\t\tlist.add( tuple[ 3 ].fire );\n\n\t\t\t// deferred.notify = function() { deferred.notifyWith(...) }\n\t\t\t// deferred.resolve = function() { deferred.resolveWith(...) }\n\t\t\t// deferred.reject = function() { deferred.rejectWith(...) }\n\t\t\tdeferred[ tuple[ 0 ] ] = function() {\n\t\t\t\tdeferred[ tuple[ 0 ] + \"With\" ]( this === deferred ? undefined : this, arguments );\n\t\t\t\treturn this;\n\t\t\t};\n\n\t\t\t// deferred.notifyWith = list.fireWith\n\t\t\t// deferred.resolveWith = list.fireWith\n\t\t\t// deferred.rejectWith = list.fireWith\n\t\t\tdeferred[ tuple[ 0 ] + \"With\" ] = list.fireWith;\n\t\t} );\n\n\t\t// Make the deferred a promise\n\t\tpromise.promise( deferred );\n\n\t\t// Call given func if any\n\t\tif ( func ) {\n\t\t\tfunc.call( deferred, deferred );\n\t\t}\n\n\t\t// All done!\n\t\treturn deferred;\n\t},\n\n\t// Deferred helper\n\twhen: function( singleValue ) {\n\t\tvar\n\n\t\t\t// count of uncompleted subordinates\n\t\t\tremaining = arguments.length,\n\n\t\t\t// count of unprocessed arguments\n\t\t\ti = remaining,\n\n\t\t\t// subordinate fulfillment data\n\t\t\tresolveContexts = Array( i ),\n\t\t\tresolveValues = slice.call( arguments ),\n\n\t\t\t// the master Deferred\n\t\t\tmaster = jQuery.Deferred(),\n\n\t\t\t// subordinate callback factory\n\t\t\tupdateFunc = function( i ) {\n\t\t\t\treturn function( value ) {\n\t\t\t\t\tresolveContexts[ i ] = this;\n\t\t\t\t\tresolveValues[ i ] = arguments.length > 1 ? slice.call( arguments ) : value;\n\t\t\t\t\tif ( !( --remaining ) ) {\n\t\t\t\t\t\tmaster.resolveWith( resolveContexts, resolveValues );\n\t\t\t\t\t}\n\t\t\t\t};\n\t\t\t};\n\n\t\t// Single- and empty arguments are adopted like Promise.resolve\n\t\tif ( remaining <= 1 ) {\n\t\t\tadoptValue( singleValue, master.done( updateFunc( i ) ).resolve, master.reject,\n\t\t\t\t!remaining );\n\n\t\t\t// Use .then() to unwrap secondary thenables (cf. gh-3000)\n\t\t\tif ( master.state() === \"pending\" ||\n\t\t\t\tisFunction( resolveValues[ i ] && resolveValues[ i ].then ) ) {\n\n\t\t\t\treturn master.then();\n\t\t\t}\n\t\t}\n\n\t\t// Multiple arguments are aggregated like Promise.all array elements\n\t\twhile ( i-- ) {\n\t\t\tadoptValue( resolveValues[ i ], updateFunc( i ), master.reject );\n\t\t}\n\n\t\treturn master.promise();\n\t}\n} );\n\n\n// These usually indicate a programmer mistake during development,\n// warn about them ASAP rather than swallowing them by default.\nvar rerrorNames = /^(Eval|Internal|Range|Reference|Syntax|Type|URI)Error$/;\n\njQuery.Deferred.exceptionHook = function( error, stack ) {\n\n\t// Support: IE 8 - 9 only\n\t// Console exists when dev tools are open, which can happen at any time\n\tif ( window.console && window.console.warn && error && rerrorNames.test( error.name ) ) {\n\t\twindow.console.warn( \"jQuery.Deferred exception: \" + error.message, error.stack, stack );\n\t}\n};\n\n\n\n\njQuery.readyException = function( error ) {\n\twindow.setTimeout( function() {\n\t\tthrow error;\n\t} );\n};\n\n\n\n\n// The deferred used on DOM ready\nvar readyList = jQuery.Deferred();\n\njQuery.fn.ready = function( fn ) {\n\n\treadyList\n\t\t.then( fn )\n\n\t\t// Wrap jQuery.readyException in a function so that the lookup\n\t\t// happens at the time of error handling instead of callback\n\t\t// registration.\n\t\t.catch( function( error ) {\n\t\t\tjQuery.readyException( error );\n\t\t} );\n\n\treturn this;\n};\n\njQuery.extend( {\n\n\t// Is the DOM ready to be used? Set to true once it occurs.\n\tisReady: false,\n\n\t// A counter to track how many items to wait for before\n\t// the ready event fires. See #6781\n\treadyWait: 1,\n\n\t// Handle when the DOM is ready\n\tready: function( wait ) {\n\n\t\t// Abort if there are pending holds or we're already ready\n\t\tif ( wait === true ? --jQuery.readyWait : jQuery.isReady ) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Remember that the DOM is ready\n\t\tjQuery.isReady = true;\n\n\t\t// If a normal DOM Ready event fired, decrement, and wait if need be\n\t\tif ( wait !== true && --jQuery.readyWait > 0 ) {\n\t\t\treturn;\n\t\t}\n\n\t\t// If there are functions bound, to execute\n\t\treadyList.resolveWith( document, [ jQuery ] );\n\t}\n} );\n\njQuery.ready.then = readyList.then;\n\n// The ready event handler and self cleanup method\nfunction completed() {\n\tdocument.removeEventListener( \"DOMContentLoaded\", completed );\n\twindow.removeEventListener( \"load\", completed );\n\tjQuery.ready();\n}\n\n// Catch cases where $(document).ready() is called\n// after the browser event has already occurred.\n// Support: IE <=9 - 10 only\n// Older IE sometimes signals \"interactive\" too soon\nif ( document.readyState === \"complete\" ||\n\t( document.readyState !== \"loading\" && !document.documentElement.doScroll ) ) {\n\n\t// Handle it asynchronously to allow scripts the opportunity to delay ready\n\twindow.setTimeout( jQuery.ready );\n\n} else {\n\n\t// Use the handy event callback\n\tdocument.addEventListener( \"DOMContentLoaded\", completed );\n\n\t// A fallback to window.onload, that will always work\n\twindow.addEventListener( \"load\", completed );\n}\n\n\n\n\n// Multifunctional method to get and set values of a collection\n// The value/s can optionally be executed if it's a function\nvar access = function( elems, fn, key, value, chainable, emptyGet, raw ) {\n\tvar i = 0,\n\t\tlen = elems.length,\n\t\tbulk = key == null;\n\n\t// Sets many values\n\tif ( toType( key ) === \"object\" ) {\n\t\tchainable = true;\n\t\tfor ( i in key ) {\n\t\t\taccess( elems, fn, i, key[ i ], true, emptyGet, raw );\n\t\t}\n\n\t// Sets one value\n\t} else if ( value !== undefined ) {\n\t\tchainable = true;\n\n\t\tif ( !isFunction( value ) ) {\n\t\t\traw = true;\n\t\t}\n\n\t\tif ( bulk ) {\n\n\t\t\t// Bulk operations run against the entire set\n\t\t\tif ( raw ) {\n\t\t\t\tfn.call( elems, value );\n\t\t\t\tfn = null;\n\n\t\t\t// ...except when executing function values\n\t\t\t} else {\n\t\t\t\tbulk = fn;\n\t\t\t\tfn = function( elem, key, value ) {\n\t\t\t\t\treturn bulk.call( jQuery( elem ), value );\n\t\t\t\t};\n\t\t\t}\n\t\t}\n\n\t\tif ( fn ) {\n\t\t\tfor ( ; i < len; i++ ) {\n\t\t\t\tfn(\n\t\t\t\t\telems[ i ], key, raw ?\n\t\t\t\t\tvalue :\n\t\t\t\t\tvalue.call( elems[ i ], i, fn( elems[ i ], key ) )\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\t}\n\n\tif ( chainable ) {\n\t\treturn elems;\n\t}\n\n\t// Gets\n\tif ( bulk ) {\n\t\treturn fn.call( elems );\n\t}\n\n\treturn len ? fn( elems[ 0 ], key ) : emptyGet;\n};\n\n\n// Matches dashed string for camelizing\nvar rmsPrefix = /^-ms-/,\n\trdashAlpha = /-([a-z])/g;\n\n// Used by camelCase as callback to replace()\nfunction fcamelCase( all, letter ) {\n\treturn letter.toUpperCase();\n}\n\n// Convert dashed to camelCase; used by the css and data modules\n// Support: IE <=9 - 11, Edge 12 - 15\n// Microsoft forgot to hump their vendor prefix (#9572)\nfunction camelCase( string ) {\n\treturn string.replace( rmsPrefix, \"ms-\" ).replace( rdashAlpha, fcamelCase );\n}\nvar acceptData = function( owner ) {\n\n\t// Accepts only:\n\t//  - Node\n\t//    - Node.ELEMENT_NODE\n\t//    - Node.DOCUMENT_NODE\n\t//  - Object\n\t//    - Any\n\treturn owner.nodeType === 1 || owner.nodeType === 9 || !( +owner.nodeType );\n};\n\n\n\n\nfunction Data() {\n\tthis.expando = jQuery.expando + Data.uid++;\n}\n\nData.uid = 1;\n\nData.prototype = {\n\n\tcache: function( owner ) {\n\n\t\t// Check if the owner object already has a cache\n\t\tvar value = owner[ this.expando ];\n\n\t\t// If not, create one\n\t\tif ( !value ) {\n\t\t\tvalue = {};\n\n\t\t\t// We can accept data for non-element nodes in modern browsers,\n\t\t\t// but we should not, see #8335.\n\t\t\t// Always return an empty object.\n\t\t\tif ( acceptData( owner ) ) {\n\n\t\t\t\t// If it is a node unlikely to be stringify-ed or looped over\n\t\t\t\t// use plain assignment\n\t\t\t\tif ( owner.nodeType ) {\n\t\t\t\t\towner[ this.expando ] = value;\n\n\t\t\t\t// Otherwise secure it in a non-enumerable property\n\t\t\t\t// configurable must be true to allow the property to be\n\t\t\t\t// deleted when data is removed\n\t\t\t\t} else {\n\t\t\t\t\tObject.defineProperty( owner, this.expando, {\n\t\t\t\t\t\tvalue: value,\n\t\t\t\t\t\tconfigurable: true\n\t\t\t\t\t} );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn value;\n\t},\n\tset: function( owner, data, value ) {\n\t\tvar prop,\n\t\t\tcache = this.cache( owner );\n\n\t\t// Handle: [ owner, key, value ] args\n\t\t// Always use camelCase key (gh-2257)\n\t\tif ( typeof data === \"string\" ) {\n\t\t\tcache[ camelCase( data ) ] = value;\n\n\t\t// Handle: [ owner, { properties } ] args\n\t\t} else {\n\n\t\t\t// Copy the properties one-by-one to the cache object\n\t\t\tfor ( prop in data ) {\n\t\t\t\tcache[ camelCase( prop ) ] = data[ prop ];\n\t\t\t}\n\t\t}\n\t\treturn cache;\n\t},\n\tget: function( owner, key ) {\n\t\treturn key === undefined ?\n\t\t\tthis.cache( owner ) :\n\n\t\t\t// Always use camelCase key (gh-2257)\n\t\t\towner[ this.expando ] && owner[ this.expando ][ camelCase( key ) ];\n\t},\n\taccess: function( owner, key, value ) {\n\n\t\t// In cases where either:\n\t\t//\n\t\t//   1. No key was specified\n\t\t//   2. A string key was specified, but no value provided\n\t\t//\n\t\t// Take the \"read\" path and allow the get method to determine\n\t\t// which value to return, respectively either:\n\t\t//\n\t\t//   1. The entire cache object\n\t\t//   2. The data stored at the key\n\t\t//\n\t\tif ( key === undefined ||\n\t\t\t\t( ( key && typeof key === \"string\" ) && value === undefined ) ) {\n\n\t\t\treturn this.get( owner, key );\n\t\t}\n\n\t\t// When the key is not a string, or both a key and value\n\t\t// are specified, set or extend (existing objects) with either:\n\t\t//\n\t\t//   1. An object of properties\n\t\t//   2. A key and value\n\t\t//\n\t\tthis.set( owner, key, value );\n\n\t\t// Since the \"set\" path can have two possible entry points\n\t\t// return the expected data based on which path was taken[*]\n\t\treturn value !== undefined ? value : key;\n\t},\n\tremove: function( owner, key ) {\n\t\tvar i,\n\t\t\tcache = owner[ this.expando ];\n\n\t\tif ( cache === undefined ) {\n\t\t\treturn;\n\t\t}\n\n\t\tif ( key !== undefined ) {\n\n\t\t\t// Support array or space separated string of keys\n\t\t\tif ( Array.isArray( key ) ) {\n\n\t\t\t\t// If key is an array of keys...\n\t\t\t\t// We always set camelCase keys, so remove that.\n\t\t\t\tkey = key.map( camelCase );\n\t\t\t} else {\n\t\t\t\tkey = camelCase( key );\n\n\t\t\t\t// If a key with the spaces exists, use it.\n\t\t\t\t// Otherwise, create an array by matching non-whitespace\n\t\t\t\tkey = key in cache ?\n\t\t\t\t\t[ key ] :\n\t\t\t\t\t( key.match( rnothtmlwhite ) || [] );\n\t\t\t}\n\n\t\t\ti = key.length;\n\n\t\t\twhile ( i-- ) {\n\t\t\t\tdelete cache[ key[ i ] ];\n\t\t\t}\n\t\t}\n\n\t\t// Remove the expando if there's no more data\n\t\tif ( key === undefined || jQuery.isEmptyObject( cache ) ) {\n\n\t\t\t// Support: Chrome <=35 - 45\n\t\t\t// Webkit & Blink performance suffers when deleting properties\n\t\t\t// from DOM nodes, so set to undefined instead\n\t\t\t// https://bugs.chromium.org/p/chromium/issues/detail?id=378607 (bug restricted)\n\t\t\tif ( owner.nodeType ) {\n\t\t\t\towner[ this.expando ] = undefined;\n\t\t\t} else {\n\t\t\t\tdelete owner[ this.expando ];\n\t\t\t}\n\t\t}\n\t},\n\thasData: function( owner ) {\n\t\tvar cache = owner[ this.expando ];\n\t\treturn cache !== undefined && !jQuery.isEmptyObject( cache );\n\t}\n};\nvar dataPriv = new Data();\n\nvar dataUser = new Data();\n\n\n\n//\tImplementation Summary\n//\n//\t1. Enforce API surface and semantic compatibility with 1.9.x branch\n//\t2. Improve the module's maintainability by reducing the storage\n//\t\tpaths to a single mechanism.\n//\t3. Use the same single mechanism to support \"private\" and \"user\" data.\n//\t4. _Never_ expose \"private\" data to user code (TODO: Drop _data, _removeData)\n//\t5. Avoid exposing implementation details on user objects (eg. expando properties)\n//\t6. Provide a clear path for implementation upgrade to WeakMap in 2014\n\nvar rbrace = /^(?:\\{[\\w\\W]*\\}|\\[[\\w\\W]*\\])$/,\n\trmultiDash = /[A-Z]/g;\n\nfunction getData( data ) {\n\tif ( data === \"true\" ) {\n\t\treturn true;\n\t}\n\n\tif ( data === \"false\" ) {\n\t\treturn false;\n\t}\n\n\tif ( data === \"null\" ) {\n\t\treturn null;\n\t}\n\n\t// Only convert to a number if it doesn't change the string\n\tif ( data === +data + \"\" ) {\n\t\treturn +data;\n\t}\n\n\tif ( rbrace.test( data ) ) {\n\t\treturn JSON.parse( data );\n\t}\n\n\treturn data;\n}\n\nfunction dataAttr( elem, key, data ) {\n\tvar name;\n\n\t// If nothing was found internally, try to fetch any\n\t// data from the HTML5 data-* attribute\n\tif ( data === undefined && elem.nodeType === 1 ) {\n\t\tname = \"data-\" + key.replace( rmultiDash, \"-$&\" ).toLowerCase();\n\t\tdata = elem.getAttribute( name );\n\n\t\tif ( typeof data === \"string\" ) {\n\t\t\ttry {\n\t\t\t\tdata = getData( data );\n\t\t\t} catch ( e ) {}\n\n\t\t\t// Make sure we set the data so it isn't changed later\n\t\t\tdataUser.set( elem, key, data );\n\t\t} else {\n\t\t\tdata = undefined;\n\t\t}\n\t}\n\treturn data;\n}\n\njQuery.extend( {\n\thasData: function( elem ) {\n\t\treturn dataUser.hasData( elem ) || dataPriv.hasData( elem );\n\t},\n\n\tdata: function( elem, name, data ) {\n\t\treturn dataUser.access( elem, name, data );\n\t},\n\n\tremoveData: function( elem, name ) {\n\t\tdataUser.remove( elem, name );\n\t},\n\n\t// TODO: Now that all calls to _data and _removeData have been replaced\n\t// with direct calls to dataPriv methods, these can be deprecated.\n\t_data: function( elem, name, data ) {\n\t\treturn dataPriv.access( elem, name, data );\n\t},\n\n\t_removeData: function( elem, name ) {\n\t\tdataPriv.remove( elem, name );\n\t}\n} );\n\njQuery.fn.extend( {\n\tdata: function( key, value ) {\n\t\tvar i, name, data,\n\t\t\telem = this[ 0 ],\n\t\t\tattrs = elem && elem.attributes;\n\n\t\t// Gets all values\n\t\tif ( key === undefined ) {\n\t\t\tif ( this.length ) {\n\t\t\t\tdata = dataUser.get( elem );\n\n\t\t\t\tif ( elem.nodeType === 1 && !dataPriv.get( elem, \"hasDataAttrs\" ) ) {\n\t\t\t\t\ti = attrs.length;\n\t\t\t\t\twhile ( i-- ) {\n\n\t\t\t\t\t\t// Support: IE 11 only\n\t\t\t\t\t\t// The attrs elements can be null (#14894)\n\t\t\t\t\t\tif ( attrs[ i ] ) {\n\t\t\t\t\t\t\tname = attrs[ i ].name;\n\t\t\t\t\t\t\tif ( name.indexOf( \"data-\" ) === 0 ) {\n\t\t\t\t\t\t\t\tname = camelCase( name.slice( 5 ) );\n\t\t\t\t\t\t\t\tdataAttr( elem, name, data[ name ] );\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tdataPriv.set( elem, \"hasDataAttrs\", true );\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn data;\n\t\t}\n\n\t\t// Sets multiple values\n\t\tif ( typeof key === \"object\" ) {\n\t\t\treturn this.each( function() {\n\t\t\t\tdataUser.set( this, key );\n\t\t\t} );\n\t\t}\n\n\t\treturn access( this, function( value ) {\n\t\t\tvar data;\n\n\t\t\t// The calling jQuery object (element matches) is not empty\n\t\t\t// (and therefore has an element appears at this[ 0 ]) and the\n\t\t\t// `value` parameter was not undefined. An empty jQuery object\n\t\t\t// will result in `undefined` for elem = this[ 0 ] which will\n\t\t\t// throw an exception if an attempt to read a data cache is made.\n\t\t\tif ( elem && value === undefined ) {\n\n\t\t\t\t// Attempt to get data from the cache\n\t\t\t\t// The key will always be camelCased in Data\n\t\t\t\tdata = dataUser.get( elem, key );\n\t\t\t\tif ( data !== undefined ) {\n\t\t\t\t\treturn data;\n\t\t\t\t}\n\n\t\t\t\t// Attempt to \"discover\" the data in\n\t\t\t\t// HTML5 custom data-* attrs\n\t\t\t\tdata = dataAttr( elem, key );\n\t\t\t\tif ( data !== undefined ) {\n\t\t\t\t\treturn data;\n\t\t\t\t}\n\n\t\t\t\t// We tried really hard, but the data doesn't exist.\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// Set the data...\n\t\t\tthis.each( function() {\n\n\t\t\t\t// We always store the camelCased key\n\t\t\t\tdataUser.set( this, key, value );\n\t\t\t} );\n\t\t}, null, value, arguments.length > 1, null, true );\n\t},\n\n\tremoveData: function( key ) {\n\t\treturn this.each( function() {\n\t\t\tdataUser.remove( this, key );\n\t\t} );\n\t}\n} );\n\n\njQuery.extend( {\n\tqueue: function( elem, type, data ) {\n\t\tvar queue;\n\n\t\tif ( elem ) {\n\t\t\ttype = ( type || \"fx\" ) + \"queue\";\n\t\t\tqueue = dataPriv.get( elem, type );\n\n\t\t\t// Speed up dequeue by getting out quickly if this is just a lookup\n\t\t\tif ( data ) {\n\t\t\t\tif ( !queue || Array.isArray( data ) ) {\n\t\t\t\t\tqueue = dataPriv.access( elem, type, jQuery.makeArray( data ) );\n\t\t\t\t} else {\n\t\t\t\t\tqueue.push( data );\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn queue || [];\n\t\t}\n\t},\n\n\tdequeue: function( elem, type ) {\n\t\ttype = type || \"fx\";\n\n\t\tvar queue = jQuery.queue( elem, type ),\n\t\t\tstartLength = queue.length,\n\t\t\tfn = queue.shift(),\n\t\t\thooks = jQuery._queueHooks( elem, type ),\n\t\t\tnext = function() {\n\t\t\t\tjQuery.dequeue( elem, type );\n\t\t\t};\n\n\t\t// If the fx queue is dequeued, always remove the progress sentinel\n\t\tif ( fn === \"inprogress\" ) {\n\t\t\tfn = queue.shift();\n\t\t\tstartLength--;\n\t\t}\n\n\t\tif ( fn ) {\n\n\t\t\t// Add a progress sentinel to prevent the fx queue from being\n\t\t\t// automatically dequeued\n\t\t\tif ( type === \"fx\" ) {\n\t\t\t\tqueue.unshift( \"inprogress\" );\n\t\t\t}\n\n\t\t\t// Clear up the last queue stop function\n\t\t\tdelete hooks.stop;\n\t\t\tfn.call( elem, next, hooks );\n\t\t}\n\n\t\tif ( !startLength && hooks ) {\n\t\t\thooks.empty.fire();\n\t\t}\n\t},\n\n\t// Not public - generate a queueHooks object, or return the current one\n\t_queueHooks: function( elem, type ) {\n\t\tvar key = type + \"queueHooks\";\n\t\treturn dataPriv.get( elem, key ) || dataPriv.access( elem, key, {\n\t\t\tempty: jQuery.Callbacks( \"once memory\" ).add( function() {\n\t\t\t\tdataPriv.remove( elem, [ type + \"queue\", key ] );\n\t\t\t} )\n\t\t} );\n\t}\n} );\n\njQuery.fn.extend( {\n\tqueue: function( type, data ) {\n\t\tvar setter = 2;\n\n\t\tif ( typeof type !== \"string\" ) {\n\t\t\tdata = type;\n\t\t\ttype = \"fx\";\n\t\t\tsetter--;\n\t\t}\n\n\t\tif ( arguments.length < setter ) {\n\t\t\treturn jQuery.queue( this[ 0 ], type );\n\t\t}\n\n\t\treturn data === undefined ?\n\t\t\tthis :\n\t\t\tthis.each( function() {\n\t\t\t\tvar queue = jQuery.queue( this, type, data );\n\n\t\t\t\t// Ensure a hooks for this queue\n\t\t\t\tjQuery._queueHooks( this, type );\n\n\t\t\t\tif ( type === \"fx\" && queue[ 0 ] !== \"inprogress\" ) {\n\t\t\t\t\tjQuery.dequeue( this, type );\n\t\t\t\t}\n\t\t\t} );\n\t},\n\tdequeue: function( type ) {\n\t\treturn this.each( function() {\n\t\t\tjQuery.dequeue( this, type );\n\t\t} );\n\t},\n\tclearQueue: function( type ) {\n\t\treturn this.queue( type || \"fx\", [] );\n\t},\n\n\t// Get a promise resolved when queues of a certain type\n\t// are emptied (fx is the type by default)\n\tpromise: function( type, obj ) {\n\t\tvar tmp,\n\t\t\tcount = 1,\n\t\t\tdefer = jQuery.Deferred(),\n\t\t\telements = this,\n\t\t\ti = this.length,\n\t\t\tresolve = function() {\n\t\t\t\tif ( !( --count ) ) {\n\t\t\t\t\tdefer.resolveWith( elements, [ elements ] );\n\t\t\t\t}\n\t\t\t};\n\n\t\tif ( typeof type !== \"string\" ) {\n\t\t\tobj = type;\n\t\t\ttype = undefined;\n\t\t}\n\t\ttype = type || \"fx\";\n\n\t\twhile ( i-- ) {\n\t\t\ttmp = dataPriv.get( elements[ i ], type + \"queueHooks\" );\n\t\t\tif ( tmp && tmp.empty ) {\n\t\t\t\tcount++;\n\t\t\t\ttmp.empty.add( resolve );\n\t\t\t}\n\t\t}\n\t\tresolve();\n\t\treturn defer.promise( obj );\n\t}\n} );\nvar pnum = ( /[+-]?(?:\\d*\\.|)\\d+(?:[eE][+-]?\\d+|)/ ).source;\n\nvar rcssNum = new RegExp( \"^(?:([+-])=|)(\" + pnum + \")([a-z%]*)$\", \"i\" );\n\n\nvar cssExpand = [ \"Top\", \"Right\", \"Bottom\", \"Left\" ];\n\nvar documentElement = document.documentElement;\n\n\n\n\tvar isAttached = function( elem ) {\n\t\t\treturn jQuery.contains( elem.ownerDocument, elem );\n\t\t},\n\t\tcomposed = { composed: true };\n\n\t// Support: IE 9 - 11+, Edge 12 - 18+, iOS 10.0 - 10.2 only\n\t// Check attachment across shadow DOM boundaries when possible (gh-3504)\n\t// Support: iOS 10.0-10.2 only\n\t// Early iOS 10 versions support `attachShadow` but not `getRootNode`,\n\t// leading to errors. We need to check for `getRootNode`.\n\tif ( documentElement.getRootNode ) {\n\t\tisAttached = function( elem ) {\n\t\t\treturn jQuery.contains( elem.ownerDocument, elem ) ||\n\t\t\t\telem.getRootNode( composed ) === elem.ownerDocument;\n\t\t};\n\t}\nvar isHiddenWithinTree = function( elem, el ) {\n\n\t\t// isHiddenWithinTree might be called from jQuery#filter function;\n\t\t// in that case, element will be second argument\n\t\telem = el || elem;\n\n\t\t// Inline style trumps all\n\t\treturn elem.style.display === \"none\" ||\n\t\t\telem.style.display === \"\" &&\n\n\t\t\t// Otherwise, check computed style\n\t\t\t// Support: Firefox <=43 - 45\n\t\t\t// Disconnected elements can have computed display: none, so first confirm that elem is\n\t\t\t// in the document.\n\t\t\tisAttached( elem ) &&\n\n\t\t\tjQuery.css( elem, \"display\" ) === \"none\";\n\t};\n\nvar swap = function( elem, options, callback, args ) {\n\tvar ret, name,\n\t\told = {};\n\n\t// Remember the old values, and insert the new ones\n\tfor ( name in options ) {\n\t\told[ name ] = elem.style[ name ];\n\t\telem.style[ name ] = options[ name ];\n\t}\n\n\tret = callback.apply( elem, args || [] );\n\n\t// Revert the old values\n\tfor ( name in options ) {\n\t\telem.style[ name ] = old[ name ];\n\t}\n\n\treturn ret;\n};\n\n\n\n\nfunction adjustCSS( elem, prop, valueParts, tween ) {\n\tvar adjusted, scale,\n\t\tmaxIterations = 20,\n\t\tcurrentValue = tween ?\n\t\t\tfunction() {\n\t\t\t\treturn tween.cur();\n\t\t\t} :\n\t\t\tfunction() {\n\t\t\t\treturn jQuery.css( elem, prop, \"\" );\n\t\t\t},\n\t\tinitial = currentValue(),\n\t\tunit = valueParts && valueParts[ 3 ] || ( jQuery.cssNumber[ prop ] ? \"\" : \"px\" ),\n\n\t\t// Starting value computation is required for potential unit mismatches\n\t\tinitialInUnit = elem.nodeType &&\n\t\t\t( jQuery.cssNumber[ prop ] || unit !== \"px\" && +initial ) &&\n\t\t\trcssNum.exec( jQuery.css( elem, prop ) );\n\n\tif ( initialInUnit && initialInUnit[ 3 ] !== unit ) {\n\n\t\t// Support: Firefox <=54\n\t\t// Halve the iteration target value to prevent interference from CSS upper bounds (gh-2144)\n\t\tinitial = initial / 2;\n\n\t\t// Trust units reported by jQuery.css\n\t\tunit = unit || initialInUnit[ 3 ];\n\n\t\t// Iteratively approximate from a nonzero starting point\n\t\tinitialInUnit = +initial || 1;\n\n\t\twhile ( maxIterations-- ) {\n\n\t\t\t// Evaluate and update our best guess (doubling guesses that zero out).\n\t\t\t// Finish if the scale equals or crosses 1 (making the old*new product non-positive).\n\t\t\tjQuery.style( elem, prop, initialInUnit + unit );\n\t\t\tif ( ( 1 - scale ) * ( 1 - ( scale = currentValue() / initial || 0.5 ) ) <= 0 ) {\n\t\t\t\tmaxIterations = 0;\n\t\t\t}\n\t\t\tinitialInUnit = initialInUnit / scale;\n\n\t\t}\n\n\t\tinitialInUnit = initialInUnit * 2;\n\t\tjQuery.style( elem, prop, initialInUnit + unit );\n\n\t\t// Make sure we update the tween properties later on\n\t\tvalueParts = valueParts || [];\n\t}\n\n\tif ( valueParts ) {\n\t\tinitialInUnit = +initialInUnit || +initial || 0;\n\n\t\t// Apply relative offset (+=/-=) if specified\n\t\tadjusted = valueParts[ 1 ] ?\n\t\t\tinitialInUnit + ( valueParts[ 1 ] + 1 ) * valueParts[ 2 ] :\n\t\t\t+valueParts[ 2 ];\n\t\tif ( tween ) {\n\t\t\ttween.unit = unit;\n\t\t\ttween.start = initialInUnit;\n\t\t\ttween.end = adjusted;\n\t\t}\n\t}\n\treturn adjusted;\n}\n\n\nvar defaultDisplayMap = {};\n\nfunction getDefaultDisplay( elem ) {\n\tvar temp,\n\t\tdoc = elem.ownerDocument,\n\t\tnodeName = elem.nodeName,\n\t\tdisplay = defaultDisplayMap[ nodeName ];\n\n\tif ( display ) {\n\t\treturn display;\n\t}\n\n\ttemp = doc.body.appendChild( doc.createElement( nodeName ) );\n\tdisplay = jQuery.css( temp, \"display\" );\n\n\ttemp.parentNode.removeChild( temp );\n\n\tif ( display === \"none\" ) {\n\t\tdisplay = \"block\";\n\t}\n\tdefaultDisplayMap[ nodeName ] = display;\n\n\treturn display;\n}\n\nfunction showHide( elements, show ) {\n\tvar display, elem,\n\t\tvalues = [],\n\t\tindex = 0,\n\t\tlength = elements.length;\n\n\t// Determine new display value for elements that need to change\n\tfor ( ; index < length; index++ ) {\n\t\telem = elements[ index ];\n\t\tif ( !elem.style ) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tdisplay = elem.style.display;\n\t\tif ( show ) {\n\n\t\t\t// Since we force visibility upon cascade-hidden elements, an immediate (and slow)\n\t\t\t// check is required in this first loop unless we have a nonempty display value (either\n\t\t\t// inline or about-to-be-restored)\n\t\t\tif ( display === \"none\" ) {\n\t\t\t\tvalues[ index ] = dataPriv.get( elem, \"display\" ) || null;\n\t\t\t\tif ( !values[ index ] ) {\n\t\t\t\t\telem.style.display = \"\";\n\t\t\t\t}\n\t\t\t}\n\t\t\tif ( elem.style.display === \"\" && isHiddenWithinTree( elem ) ) {\n\t\t\t\tvalues[ index ] = getDefaultDisplay( elem );\n\t\t\t}\n\t\t} else {\n\t\t\tif ( display !== \"none\" ) {\n\t\t\t\tvalues[ index ] = \"none\";\n\n\t\t\t\t// Remember what we're overwriting\n\t\t\t\tdataPriv.set( elem, \"display\", display );\n\t\t\t}\n\t\t}\n\t}\n\n\t// Set the display of the elements in a second loop to avoid constant reflow\n\tfor ( index = 0; index < length; index++ ) {\n\t\tif ( values[ index ] != null ) {\n\t\t\telements[ index ].style.display = values[ index ];\n\t\t}\n\t}\n\n\treturn elements;\n}\n\njQuery.fn.extend( {\n\tshow: function() {\n\t\treturn showHide( this, true );\n\t},\n\thide: function() {\n\t\treturn showHide( this );\n\t},\n\ttoggle: function( state ) {\n\t\tif ( typeof state === \"boolean\" ) {\n\t\t\treturn state ? this.show() : this.hide();\n\t\t}\n\n\t\treturn this.each( function() {\n\t\t\tif ( isHiddenWithinTree( this ) ) {\n\t\t\t\tjQuery( this ).show();\n\t\t\t} else {\n\t\t\t\tjQuery( this ).hide();\n\t\t\t}\n\t\t} );\n\t}\n} );\nvar rcheckableType = ( /^(?:checkbox|radio)$/i );\n\nvar rtagName = ( /<([a-z][^\\/\\0>\\x20\\t\\r\\n\\f]*)/i );\n\nvar rscriptType = ( /^$|^module$|\\/(?:java|ecma)script/i );\n\n\n\n// We have to close these tags to support XHTML (#13200)\nvar wrapMap = {\n\n\t// Support: IE <=9 only\n\toption: [ 1, \"<select multiple='multiple'>\", \"</select>\" ],\n\n\t// XHTML parsers do not magically insert elements in the\n\t// same way that tag soup parsers do. So we cannot shorten\n\t// this by omitting <tbody> or other required elements.\n\tthead: [ 1, \"<table>\", \"</table>\" ],\n\tcol: [ 2, \"<table><colgroup>\", \"</colgroup></table>\" ],\n\ttr: [ 2, \"<table><tbody>\", \"</tbody></table>\" ],\n\ttd: [ 3, \"<table><tbody><tr>\", \"</tr></tbody></table>\" ],\n\n\t_default: [ 0, \"\", \"\" ]\n};\n\n// Support: IE <=9 only\nwrapMap.optgroup = wrapMap.option;\n\nwrapMap.tbody = wrapMap.tfoot = wrapMap.colgroup = wrapMap.caption = wrapMap.thead;\nwrapMap.th = wrapMap.td;\n\n\nfunction getAll( context, tag ) {\n\n\t// Support: IE <=9 - 11 only\n\t// Use typeof to avoid zero-argument method invocation on host objects (#15151)\n\tvar ret;\n\n\tif ( typeof context.getElementsByTagName !== \"undefined\" ) {\n\t\tret = context.getElementsByTagName( tag || \"*\" );\n\n\t} else if ( typeof context.querySelectorAll !== \"undefined\" ) {\n\t\tret = context.querySelectorAll( tag || \"*\" );\n\n\t} else {\n\t\tret = [];\n\t}\n\n\tif ( tag === undefined || tag && nodeName( context, tag ) ) {\n\t\treturn jQuery.merge( [ context ], ret );\n\t}\n\n\treturn ret;\n}\n\n\n// Mark scripts as having already been evaluated\nfunction setGlobalEval( elems, refElements ) {\n\tvar i = 0,\n\t\tl = elems.length;\n\n\tfor ( ; i < l; i++ ) {\n\t\tdataPriv.set(\n\t\t\telems[ i ],\n\t\t\t\"globalEval\",\n\t\t\t!refElements || dataPriv.get( refElements[ i ], \"globalEval\" )\n\t\t);\n\t}\n}\n\n\nvar rhtml = /<|&#?\\w+;/;\n\nfunction buildFragment( elems, context, scripts, selection, ignored ) {\n\tvar elem, tmp, tag, wrap, attached, j,\n\t\tfragment = context.createDocumentFragment(),\n\t\tnodes = [],\n\t\ti = 0,\n\t\tl = elems.length;\n\n\tfor ( ; i < l; i++ ) {\n\t\telem = elems[ i ];\n\n\t\tif ( elem || elem === 0 ) {\n\n\t\t\t// Add nodes directly\n\t\t\tif ( toType( elem ) === \"object\" ) {\n\n\t\t\t\t// Support: Android <=4.0 only, PhantomJS 1 only\n\t\t\t\t// push.apply(_, arraylike) throws on ancient WebKit\n\t\t\t\tjQuery.merge( nodes, elem.nodeType ? [ elem ] : elem );\n\n\t\t\t// Convert non-html into a text node\n\t\t\t} else if ( !rhtml.test( elem ) ) {\n\t\t\t\tnodes.push( context.createTextNode( elem ) );\n\n\t\t\t// Convert html into DOM nodes\n\t\t\t} else {\n\t\t\t\ttmp = tmp || fragment.appendChild( context.createElement( \"div\" ) );\n\n\t\t\t\t// Deserialize a standard representation\n\t\t\t\ttag = ( rtagName.exec( elem ) || [ \"\", \"\" ] )[ 1 ].toLowerCase();\n\t\t\t\twrap = wrapMap[ tag ] || wrapMap._default;\n\t\t\t\ttmp.innerHTML = wrap[ 1 ] + jQuery.htmlPrefilter( elem ) + wrap[ 2 ];\n\n\t\t\t\t// Descend through wrappers to the right content\n\t\t\t\tj = wrap[ 0 ];\n\t\t\t\twhile ( j-- ) {\n\t\t\t\t\ttmp = tmp.lastChild;\n\t\t\t\t}\n\n\t\t\t\t// Support: Android <=4.0 only, PhantomJS 1 only\n\t\t\t\t// push.apply(_, arraylike) throws on ancient WebKit\n\t\t\t\tjQuery.merge( nodes, tmp.childNodes );\n\n\t\t\t\t// Remember the top-level container\n\t\t\t\ttmp = fragment.firstChild;\n\n\t\t\t\t// Ensure the created nodes are orphaned (#12392)\n\t\t\t\ttmp.textContent = \"\";\n\t\t\t}\n\t\t}\n\t}\n\n\t// Remove wrapper from fragment\n\tfragment.textContent = \"\";\n\n\ti = 0;\n\twhile ( ( elem = nodes[ i++ ] ) ) {\n\n\t\t// Skip elements already in the context collection (trac-4087)\n\t\tif ( selection && jQuery.inArray( elem, selection ) > -1 ) {\n\t\t\tif ( ignored ) {\n\t\t\t\tignored.push( elem );\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\n\t\tattached = isAttached( elem );\n\n\t\t// Append to fragment\n\t\ttmp = getAll( fragment.appendChild( elem ), \"script\" );\n\n\t\t// Preserve script evaluation history\n\t\tif ( attached ) {\n\t\t\tsetGlobalEval( tmp );\n\t\t}\n\n\t\t// Capture executables\n\t\tif ( scripts ) {\n\t\t\tj = 0;\n\t\t\twhile ( ( elem = tmp[ j++ ] ) ) {\n\t\t\t\tif ( rscriptType.test( elem.type || \"\" ) ) {\n\t\t\t\t\tscripts.push( elem );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn fragment;\n}\n\n\n( function() {\n\tvar fragment = document.createDocumentFragment(),\n\t\tdiv = fragment.appendChild( document.createElement( \"div\" ) ),\n\t\tinput = document.createElement( \"input\" );\n\n\t// Support: Android 4.0 - 4.3 only\n\t// Check state lost if the name is set (#11217)\n\t// Support: Windows Web Apps (WWA)\n\t// `name` and `type` must use .setAttribute for WWA (#14901)\n\tinput.setAttribute( \"type\", \"radio\" );\n\tinput.setAttribute( \"checked\", \"checked\" );\n\tinput.setAttribute( \"name\", \"t\" );\n\n\tdiv.appendChild( input );\n\n\t// Support: Android <=4.1 only\n\t// Older WebKit doesn't clone checked state correctly in fragments\n\tsupport.checkClone = div.cloneNode( true ).cloneNode( true ).lastChild.checked;\n\n\t// Support: IE <=11 only\n\t// Make sure textarea (and checkbox) defaultValue is properly cloned\n\tdiv.innerHTML = \"<textarea>x</textarea>\";\n\tsupport.noCloneChecked = !!div.cloneNode( true ).lastChild.defaultValue;\n} )();\n\n\nvar\n\trkeyEvent = /^key/,\n\trmouseEvent = /^(?:mouse|pointer|contextmenu|drag|drop)|click/,\n\trtypenamespace = /^([^.]*)(?:\\.(.+)|)/;\n\nfunction returnTrue() {\n\treturn true;\n}\n\nfunction returnFalse() {\n\treturn false;\n}\n\n// Support: IE <=9 - 11+\n// focus() and blur() are asynchronous, except when they are no-op.\n// So expect focus to be synchronous when the element is already active,\n// and blur to be synchronous when the element is not already active.\n// (focus and blur are always synchronous in other supported browsers,\n// this just defines when we can count on it).\nfunction expectSync( elem, type ) {\n\treturn ( elem === safeActiveElement() ) === ( type === \"focus\" );\n}\n\n// Support: IE <=9 only\n// Accessing document.activeElement can throw unexpectedly\n// https://bugs.jquery.com/ticket/13393\nfunction safeActiveElement() {\n\ttry {\n\t\treturn document.activeElement;\n\t} catch ( err ) { }\n}\n\nfunction on( elem, types, selector, data, fn, one ) {\n\tvar origFn, type;\n\n\t// Types can be a map of types/handlers\n\tif ( typeof types === \"object\" ) {\n\n\t\t// ( types-Object, selector, data )\n\t\tif ( typeof selector !== \"string\" ) {\n\n\t\t\t// ( types-Object, data )\n\t\t\tdata = data || selector;\n\t\t\tselector = undefined;\n\t\t}\n\t\tfor ( type in types ) {\n\t\t\ton( elem, type, selector, data, types[ type ], one );\n\t\t}\n\t\treturn elem;\n\t}\n\n\tif ( data == null && fn == null ) {\n\n\t\t// ( types, fn )\n\t\tfn = selector;\n\t\tdata = selector = undefined;\n\t} else if ( fn == null ) {\n\t\tif ( typeof selector === \"string\" ) {\n\n\t\t\t// ( types, selector, fn )\n\t\t\tfn = data;\n\t\t\tdata = undefined;\n\t\t} else {\n\n\t\t\t// ( types, data, fn )\n\t\t\tfn = data;\n\t\t\tdata = selector;\n\t\t\tselector = undefined;\n\t\t}\n\t}\n\tif ( fn === false ) {\n\t\tfn = returnFalse;\n\t} else if ( !fn ) {\n\t\treturn elem;\n\t}\n\n\tif ( one === 1 ) {\n\t\torigFn = fn;\n\t\tfn = function( event ) {\n\n\t\t\t// Can use an empty set, since event contains the info\n\t\t\tjQuery().off( event );\n\t\t\treturn origFn.apply( this, arguments );\n\t\t};\n\n\t\t// Use same guid so caller can remove using origFn\n\t\tfn.guid = origFn.guid || ( origFn.guid = jQuery.guid++ );\n\t}\n\treturn elem.each( function() {\n\t\tjQuery.event.add( this, types, fn, data, selector );\n\t} );\n}\n\n/*\n * Helper functions for managing events -- not part of the public interface.\n * Props to Dean Edwards' addEvent library for many of the ideas.\n */\njQuery.event = {\n\n\tglobal: {},\n\n\tadd: function( elem, types, handler, data, selector ) {\n\n\t\tvar handleObjIn, eventHandle, tmp,\n\t\t\tevents, t, handleObj,\n\t\t\tspecial, handlers, type, namespaces, origType,\n\t\t\telemData = dataPriv.get( elem );\n\n\t\t// Don't attach events to noData or text/comment nodes (but allow plain objects)\n\t\tif ( !elemData ) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Caller can pass in an object of custom data in lieu of the handler\n\t\tif ( handler.handler ) {\n\t\t\thandleObjIn = handler;\n\t\t\thandler = handleObjIn.handler;\n\t\t\tselector = handleObjIn.selector;\n\t\t}\n\n\t\t// Ensure that invalid selectors throw exceptions at attach time\n\t\t// Evaluate against documentElement in case elem is a non-element node (e.g., document)\n\t\tif ( selector ) {\n\t\t\tjQuery.find.matchesSelector( documentElement, selector );\n\t\t}\n\n\t\t// Make sure that the handler has a unique ID, used to find/remove it later\n\t\tif ( !handler.guid ) {\n\t\t\thandler.guid = jQuery.guid++;\n\t\t}\n\n\t\t// Init the element's event structure and main handler, if this is the first\n\t\tif ( !( events = elemData.events ) ) {\n\t\t\tevents = elemData.events = {};\n\t\t}\n\t\tif ( !( eventHandle = elemData.handle ) ) {\n\t\t\teventHandle = elemData.handle = function( e ) {\n\n\t\t\t\t// Discard the second event of a jQuery.event.trigger() and\n\t\t\t\t// when an event is called after a page has unloaded\n\t\t\t\treturn typeof jQuery !== \"undefined\" && jQuery.event.triggered !== e.type ?\n\t\t\t\t\tjQuery.event.dispatch.apply( elem, arguments ) : undefined;\n\t\t\t};\n\t\t}\n\n\t\t// Handle multiple events separated by a space\n\t\ttypes = ( types || \"\" ).match( rnothtmlwhite ) || [ \"\" ];\n\t\tt = types.length;\n\t\twhile ( t-- ) {\n\t\t\ttmp = rtypenamespace.exec( types[ t ] ) || [];\n\t\t\ttype = origType = tmp[ 1 ];\n\t\t\tnamespaces = ( tmp[ 2 ] || \"\" ).split( \".\" ).sort();\n\n\t\t\t// There *must* be a type, no attaching namespace-only handlers\n\t\t\tif ( !type ) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t// If event changes its type, use the special event handlers for the changed type\n\t\t\tspecial = jQuery.event.special[ type ] || {};\n\n\t\t\t// If selector defined, determine special event api type, otherwise given type\n\t\t\ttype = ( selector ? special.delegateType : special.bindType ) || type;\n\n\t\t\t// Update special based on newly reset type\n\t\t\tspecial = jQuery.event.special[ type ] || {};\n\n\t\t\t// handleObj is passed to all event handlers\n\t\t\thandleObj = jQuery.extend( {\n\t\t\t\ttype: type,\n\t\t\t\torigType: origType,\n\t\t\t\tdata: data,\n\t\t\t\thandler: handler,\n\t\t\t\tguid: handler.guid,\n\t\t\t\tselector: selector,\n\t\t\t\tneedsContext: selector && jQuery.expr.match.needsContext.test( selector ),\n\t\t\t\tnamespace: namespaces.join( \".\" )\n\t\t\t}, handleObjIn );\n\n\t\t\t// Init the event handler queue if we're the first\n\t\t\tif ( !( handlers = events[ type ] ) ) {\n\t\t\t\thandlers = events[ type ] = [];\n\t\t\t\thandlers.delegateCount = 0;\n\n\t\t\t\t// Only use addEventListener if the special events handler returns false\n\t\t\t\tif ( !special.setup ||\n\t\t\t\t\tspecial.setup.call( elem, data, namespaces, eventHandle ) === false ) {\n\n\t\t\t\t\tif ( elem.addEventListener ) {\n\t\t\t\t\t\telem.addEventListener( type, eventHandle );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif ( special.add ) {\n\t\t\t\tspecial.add.call( elem, handleObj );\n\n\t\t\t\tif ( !handleObj.handler.guid ) {\n\t\t\t\t\thandleObj.handler.guid = handler.guid;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Add to the element's handler list, delegates in front\n\t\t\tif ( selector ) {\n\t\t\t\thandlers.splice( handlers.delegateCount++, 0, handleObj );\n\t\t\t} else {\n\t\t\t\thandlers.push( handleObj );\n\t\t\t}\n\n\t\t\t// Keep track of which events have ever been used, for event optimization\n\t\t\tjQuery.event.global[ type ] = true;\n\t\t}\n\n\t},\n\n\t// Detach an event or set of events from an element\n\tremove: function( elem, types, handler, selector, mappedTypes ) {\n\n\t\tvar j, origCount, tmp,\n\t\t\tevents, t, handleObj,\n\t\t\tspecial, handlers, type, namespaces, origType,\n\t\t\telemData = dataPriv.hasData( elem ) && dataPriv.get( elem );\n\n\t\tif ( !elemData || !( events = elemData.events ) ) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Once for each type.namespace in types; type may be omitted\n\t\ttypes = ( types || \"\" ).match( rnothtmlwhite ) || [ \"\" ];\n\t\tt = types.length;\n\t\twhile ( t-- ) {\n\t\t\ttmp = rtypenamespace.exec( types[ t ] ) || [];\n\t\t\ttype = origType = tmp[ 1 ];\n\t\t\tnamespaces = ( tmp[ 2 ] || \"\" ).split( \".\" ).sort();\n\n\t\t\t// Unbind all events (on this namespace, if provided) for the element\n\t\t\tif ( !type ) {\n\t\t\t\tfor ( type in events ) {\n\t\t\t\t\tjQuery.event.remove( elem, type + types[ t ], handler, selector, true );\n\t\t\t\t}\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tspecial = jQuery.event.special[ type ] || {};\n\t\t\ttype = ( selector ? special.delegateType : special.bindType ) || type;\n\t\t\thandlers = events[ type ] || [];\n\t\t\ttmp = tmp[ 2 ] &&\n\t\t\t\tnew RegExp( \"(^|\\\\.)\" + namespaces.join( \"\\\\.(?:.*\\\\.|)\" ) + \"(\\\\.|$)\" );\n\n\t\t\t// Remove matching events\n\t\t\torigCount = j = handlers.length;\n\t\t\twhile ( j-- ) {\n\t\t\t\thandleObj = handlers[ j ];\n\n\t\t\t\tif ( ( mappedTypes || origType === handleObj.origType ) &&\n\t\t\t\t\t( !handler || handler.guid === handleObj.guid ) &&\n\t\t\t\t\t( !tmp || tmp.test( handleObj.namespace ) ) &&\n\t\t\t\t\t( !selector || selector === handleObj.selector ||\n\t\t\t\t\t\tselector === \"**\" && handleObj.selector ) ) {\n\t\t\t\t\thandlers.splice( j, 1 );\n\n\t\t\t\t\tif ( handleObj.selector ) {\n\t\t\t\t\t\thandlers.delegateCount--;\n\t\t\t\t\t}\n\t\t\t\t\tif ( special.remove ) {\n\t\t\t\t\t\tspecial.remove.call( elem, handleObj );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Remove generic event handler if we removed something and no more handlers exist\n\t\t\t// (avoids potential for endless recursion during removal of special event handlers)\n\t\t\tif ( origCount && !handlers.length ) {\n\t\t\t\tif ( !special.teardown ||\n\t\t\t\t\tspecial.teardown.call( elem, namespaces, elemData.handle ) === false ) {\n\n\t\t\t\t\tjQuery.removeEvent( elem, type, elemData.handle );\n\t\t\t\t}\n\n\t\t\t\tdelete events[ type ];\n\t\t\t}\n\t\t}\n\n\t\t// Remove data and the expando if it's no longer used\n\t\tif ( jQuery.isEmptyObject( events ) ) {\n\t\t\tdataPriv.remove( elem, \"handle events\" );\n\t\t}\n\t},\n\n\tdispatch: function( nativeEvent ) {\n\n\t\t// Make a writable jQuery.Event from the native event object\n\t\tvar event = jQuery.event.fix( nativeEvent );\n\n\t\tvar i, j, ret, matched, handleObj, handlerQueue,\n\t\t\targs = new Array( arguments.length ),\n\t\t\thandlers = ( dataPriv.get( this, \"events\" ) || {} )[ event.type ] || [],\n\t\t\tspecial = jQuery.event.special[ event.type ] || {};\n\n\t\t// Use the fix-ed jQuery.Event rather than the (read-only) native event\n\t\targs[ 0 ] = event;\n\n\t\tfor ( i = 1; i < arguments.length; i++ ) {\n\t\t\targs[ i ] = arguments[ i ];\n\t\t}\n\n\t\tevent.delegateTarget = this;\n\n\t\t// Call the preDispatch hook for the mapped type, and let it bail if desired\n\t\tif ( special.preDispatch && special.preDispatch.call( this, event ) === false ) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Determine handlers\n\t\thandlerQueue = jQuery.event.handlers.call( this, event, handlers );\n\n\t\t// Run delegates first; they may want to stop propagation beneath us\n\t\ti = 0;\n\t\twhile ( ( matched = handlerQueue[ i++ ] ) && !event.isPropagationStopped() ) {\n\t\t\tevent.currentTarget = matched.elem;\n\n\t\t\tj = 0;\n\t\t\twhile ( ( handleObj = matched.handlers[ j++ ] ) &&\n\t\t\t\t!event.isImmediatePropagationStopped() ) {\n\n\t\t\t\t// If the event is namespaced, then each handler is only invoked if it is\n\t\t\t\t// specially universal or its namespaces are a superset of the event's.\n\t\t\t\tif ( !event.rnamespace || handleObj.namespace === false ||\n\t\t\t\t\tevent.rnamespace.test( handleObj.namespace ) ) {\n\n\t\t\t\t\tevent.handleObj = handleObj;\n\t\t\t\t\tevent.data = handleObj.data;\n\n\t\t\t\t\tret = ( ( jQuery.event.special[ handleObj.origType ] || {} ).handle ||\n\t\t\t\t\t\thandleObj.handler ).apply( matched.elem, args );\n\n\t\t\t\t\tif ( ret !== undefined ) {\n\t\t\t\t\t\tif ( ( event.result = ret ) === false ) {\n\t\t\t\t\t\t\tevent.preventDefault();\n\t\t\t\t\t\t\tevent.stopPropagation();\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Call the postDispatch hook for the mapped type\n\t\tif ( special.postDispatch ) {\n\t\t\tspecial.postDispatch.call( this, event );\n\t\t}\n\n\t\treturn event.result;\n\t},\n\n\thandlers: function( event, handlers ) {\n\t\tvar i, handleObj, sel, matchedHandlers, matchedSelectors,\n\t\t\thandlerQueue = [],\n\t\t\tdelegateCount = handlers.delegateCount,\n\t\t\tcur = event.target;\n\n\t\t// Find delegate handlers\n\t\tif ( delegateCount &&\n\n\t\t\t// Support: IE <=9\n\t\t\t// Black-hole SVG <use> instance trees (trac-13180)\n\t\t\tcur.nodeType &&\n\n\t\t\t// Support: Firefox <=42\n\t\t\t// Suppress spec-violating clicks indicating a non-primary pointer button (trac-3861)\n\t\t\t// https://www.w3.org/TR/DOM-Level-3-Events/#event-type-click\n\t\t\t// Support: IE 11 only\n\t\t\t// ...but not arrow key \"clicks\" of radio inputs, which can have `button` -1 (gh-2343)\n\t\t\t!( event.type === \"click\" && event.button >= 1 ) ) {\n\n\t\t\tfor ( ; cur !== this; cur = cur.parentNode || this ) {\n\n\t\t\t\t// Don't check non-elements (#13208)\n\t\t\t\t// Don't process clicks on disabled elements (#6911, #8165, #11382, #11764)\n\t\t\t\tif ( cur.nodeType === 1 && !( event.type === \"click\" && cur.disabled === true ) ) {\n\t\t\t\t\tmatchedHandlers = [];\n\t\t\t\t\tmatchedSelectors = {};\n\t\t\t\t\tfor ( i = 0; i < delegateCount; i++ ) {\n\t\t\t\t\t\thandleObj = handlers[ i ];\n\n\t\t\t\t\t\t// Don't conflict with Object.prototype properties (#13203)\n\t\t\t\t\t\tsel = handleObj.selector + \" \";\n\n\t\t\t\t\t\tif ( matchedSelectors[ sel ] === undefined ) {\n\t\t\t\t\t\t\tmatchedSelectors[ sel ] = handleObj.needsContext ?\n\t\t\t\t\t\t\t\tjQuery( sel, this ).index( cur ) > -1 :\n\t\t\t\t\t\t\t\tjQuery.find( sel, this, null, [ cur ] ).length;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif ( matchedSelectors[ sel ] ) {\n\t\t\t\t\t\t\tmatchedHandlers.push( handleObj );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif ( matchedHandlers.length ) {\n\t\t\t\t\t\thandlerQueue.push( { elem: cur, handlers: matchedHandlers } );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Add the remaining (directly-bound) handlers\n\t\tcur = this;\n\t\tif ( delegateCount < handlers.length ) {\n\t\t\thandlerQueue.push( { elem: cur, handlers: handlers.slice( delegateCount ) } );\n\t\t}\n\n\t\treturn handlerQueue;\n\t},\n\n\taddProp: function( name, hook ) {\n\t\tObject.defineProperty( jQuery.Event.prototype, name, {\n\t\t\tenumerable: true,\n\t\t\tconfigurable: true,\n\n\t\t\tget: isFunction( hook ) ?\n\t\t\t\tfunction() {\n\t\t\t\t\tif ( this.originalEvent ) {\n\t\t\t\t\t\t\treturn hook( this.originalEvent );\n\t\t\t\t\t}\n\t\t\t\t} :\n\t\t\t\tfunction() {\n\t\t\t\t\tif ( this.originalEvent ) {\n\t\t\t\t\t\t\treturn this.originalEvent[ name ];\n\t\t\t\t\t}\n\t\t\t\t},\n\n\t\t\tset: function( value ) {\n\t\t\t\tObject.defineProperty( this, name, {\n\t\t\t\t\tenumerable: true,\n\t\t\t\t\tconfigurable: true,\n\t\t\t\t\twritable: true,\n\t\t\t\t\tvalue: value\n\t\t\t\t} );\n\t\t\t}\n\t\t} );\n\t},\n\n\tfix: function( originalEvent ) {\n\t\treturn originalEvent[ jQuery.expando ] ?\n\t\t\toriginalEvent :\n\t\t\tnew jQuery.Event( originalEvent );\n\t},\n\n\tspecial: {\n\t\tload: {\n\n\t\t\t// Prevent triggered image.load events from bubbling to window.load\n\t\t\tnoBubble: true\n\t\t},\n\t\tclick: {\n\n\t\t\t// Utilize native event to ensure correct state for checkable inputs\n\t\t\tsetup: function( data ) {\n\n\t\t\t\t// For mutual compressibility with _default, replace `this` access with a local var.\n\t\t\t\t// `|| data` is dead code meant only to preserve the variable through minification.\n\t\t\t\tvar el = this || data;\n\n\t\t\t\t// Claim the first handler\n\t\t\t\tif ( rcheckableType.test( el.type ) &&\n\t\t\t\t\tel.click && nodeName( el, \"input\" ) ) {\n\n\t\t\t\t\t// dataPriv.set( el, \"click\", ... )\n\t\t\t\t\tleverageNative( el, \"click\", returnTrue );\n\t\t\t\t}\n\n\t\t\t\t// Return false to allow normal processing in the caller\n\t\t\t\treturn false;\n\t\t\t},\n\t\t\ttrigger: function( data ) {\n\n\t\t\t\t// For mutual compressibility with _default, replace `this` access with a local var.\n\t\t\t\t// `|| data` is dead code meant only to preserve the variable through minification.\n\t\t\t\tvar el = this || data;\n\n\t\t\t\t// Force setup before triggering a click\n\t\t\t\tif ( rcheckableType.test( el.type ) &&\n\t\t\t\t\tel.click && nodeName( el, \"input\" ) ) {\n\n\t\t\t\t\tleverageNative( el, \"click\" );\n\t\t\t\t}\n\n\t\t\t\t// Return non-false to allow normal event-path propagation\n\t\t\t\treturn true;\n\t\t\t},\n\n\t\t\t// For cross-browser consistency, suppress native .click() on links\n\t\t\t// Also prevent it if we're currently inside a leveraged native-event stack\n\t\t\t_default: function( event ) {\n\t\t\t\tvar target = event.target;\n\t\t\t\treturn rcheckableType.test( target.type ) &&\n\t\t\t\t\ttarget.click && nodeName( target, \"input\" ) &&\n\t\t\t\t\tdataPriv.get( target, \"click\" ) ||\n\t\t\t\t\tnodeName( target, \"a\" );\n\t\t\t}\n\t\t},\n\n\t\tbeforeunload: {\n\t\t\tpostDispatch: function( event ) {\n\n\t\t\t\t// Support: Firefox 20+\n\t\t\t\t// Firefox doesn't alert if the returnValue field is not set.\n\t\t\t\tif ( event.result !== undefined && event.originalEvent ) {\n\t\t\t\t\tevent.originalEvent.returnValue = event.result;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n};\n\n// Ensure the presence of an event listener that handles manually-triggered\n// synthetic events by interrupting progress until reinvoked in response to\n// *native* events that it fires directly, ensuring that state changes have\n// already occurred before other listeners are invoked.\nfunction leverageNative( el, type, expectSync ) {\n\n\t// Missing expectSync indicates a trigger call, which must force setup through jQuery.event.add\n\tif ( !expectSync ) {\n\t\tif ( dataPriv.get( el, type ) === undefined ) {\n\t\t\tjQuery.event.add( el, type, returnTrue );\n\t\t}\n\t\treturn;\n\t}\n\n\t// Register the controller as a special universal handler for all event namespaces\n\tdataPriv.set( el, type, false );\n\tjQuery.event.add( el, type, {\n\t\tnamespace: false,\n\t\thandler: function( event ) {\n\t\t\tvar notAsync, result,\n\t\t\t\tsaved = dataPriv.get( this, type );\n\n\t\t\tif ( ( event.isTrigger & 1 ) && this[ type ] ) {\n\n\t\t\t\t// Interrupt processing of the outer synthetic .trigger()ed event\n\t\t\t\t// Saved data should be false in such cases, but might be a leftover capture object\n\t\t\t\t// from an async native handler (gh-4350)\n\t\t\t\tif ( !saved.length ) {\n\n\t\t\t\t\t// Store arguments for use when handling the inner native event\n\t\t\t\t\t// There will always be at least one argument (an event object), so this array\n\t\t\t\t\t// will not be confused with a leftover capture object.\n\t\t\t\t\tsaved = slice.call( arguments );\n\t\t\t\t\tdataPriv.set( this, type, saved );\n\n\t\t\t\t\t// Trigger the native event and capture its result\n\t\t\t\t\t// Support: IE <=9 - 11+\n\t\t\t\t\t// focus() and blur() are asynchronous\n\t\t\t\t\tnotAsync = expectSync( this, type );\n\t\t\t\t\tthis[ type ]();\n\t\t\t\t\tresult = dataPriv.get( this, type );\n\t\t\t\t\tif ( saved !== result || notAsync ) {\n\t\t\t\t\t\tdataPriv.set( this, type, false );\n\t\t\t\t\t} else {\n\t\t\t\t\t\tresult = {};\n\t\t\t\t\t}\n\t\t\t\t\tif ( saved !== result ) {\n\n\t\t\t\t\t\t// Cancel the outer synthetic event\n\t\t\t\t\t\tevent.stopImmediatePropagation();\n\t\t\t\t\t\tevent.preventDefault();\n\t\t\t\t\t\treturn result.value;\n\t\t\t\t\t}\n\n\t\t\t\t// If this is an inner synthetic event for an event with a bubbling surrogate\n\t\t\t\t// (focus or blur), assume that the surrogate already propagated from triggering the\n\t\t\t\t// native event and prevent that from happening again here.\n\t\t\t\t// This technically gets the ordering wrong w.r.t. to `.trigger()` (in which the\n\t\t\t\t// bubbling surrogate propagates *after* the non-bubbling base), but that seems\n\t\t\t\t// less bad than duplication.\n\t\t\t\t} else if ( ( jQuery.event.special[ type ] || {} ).delegateType ) {\n\t\t\t\t\tevent.stopPropagation();\n\t\t\t\t}\n\n\t\t\t// If this is a native event triggered above, everything is now in order\n\t\t\t// Fire an inner synthetic event with the original arguments\n\t\t\t} else if ( saved.length ) {\n\n\t\t\t\t// ...and capture the result\n\t\t\t\tdataPriv.set( this, type, {\n\t\t\t\t\tvalue: jQuery.event.trigger(\n\n\t\t\t\t\t\t// Support: IE <=9 - 11+\n\t\t\t\t\t\t// Extend with the prototype to reset the above stopImmediatePropagation()\n\t\t\t\t\t\tjQuery.extend( saved[ 0 ], jQuery.Event.prototype ),\n\t\t\t\t\t\tsaved.slice( 1 ),\n\t\t\t\t\t\tthis\n\t\t\t\t\t)\n\t\t\t\t} );\n\n\t\t\t\t// Abort handling of the native event\n\t\t\t\tevent.stopImmediatePropagation();\n\t\t\t}\n\t\t}\n\t} );\n}\n\njQuery.removeEvent = function( elem, type, handle ) {\n\n\t// This \"if\" is needed for plain objects\n\tif ( elem.removeEventListener ) {\n\t\telem.removeEventListener( type, handle );\n\t}\n};\n\njQuery.Event = function( src, props ) {\n\n\t// Allow instantiation without the 'new' keyword\n\tif ( !( this instanceof jQuery.Event ) ) {\n\t\treturn new jQuery.Event( src, props );\n\t}\n\n\t// Event object\n\tif ( src && src.type ) {\n\t\tthis.originalEvent = src;\n\t\tthis.type = src.type;\n\n\t\t// Events bubbling up the document may have been marked as prevented\n\t\t// by a handler lower down the tree; reflect the correct value.\n\t\tthis.isDefaultPrevented = src.defaultPrevented ||\n\t\t\t\tsrc.defaultPrevented === undefined &&\n\n\t\t\t\t// Support: Android <=2.3 only\n\t\t\t\tsrc.returnValue === false ?\n\t\t\treturnTrue :\n\t\t\treturnFalse;\n\n\t\t// Create target properties\n\t\t// Support: Safari <=6 - 7 only\n\t\t// Target should not be a text node (#504, #13143)\n\t\tthis.target = ( src.target && src.target.nodeType === 3 ) ?\n\t\t\tsrc.target.parentNode :\n\t\t\tsrc.target;\n\n\t\tthis.currentTarget = src.currentTarget;\n\t\tthis.relatedTarget = src.relatedTarget;\n\n\t// Event type\n\t} else {\n\t\tthis.type = src;\n\t}\n\n\t// Put explicitly provided properties onto the event object\n\tif ( props ) {\n\t\tjQuery.extend( this, props );\n\t}\n\n\t// Create a timestamp if incoming event doesn't have one\n\tthis.timeStamp = src && src.timeStamp || Date.now();\n\n\t// Mark it as fixed\n\tthis[ jQuery.expando ] = true;\n};\n\n// jQuery.Event is based on DOM3 Events as specified by the ECMAScript Language Binding\n// https://www.w3.org/TR/2003/WD-DOM-Level-3-Events-20030331/ecma-script-binding.html\njQuery.Event.prototype = {\n\tconstructor: jQuery.Event,\n\tisDefaultPrevented: returnFalse,\n\tisPropagationStopped: returnFalse,\n\tisImmediatePropagationStopped: returnFalse,\n\tisSimulated: false,\n\n\tpreventDefault: function() {\n\t\tvar e = this.originalEvent;\n\n\t\tthis.isDefaultPrevented = returnTrue;\n\n\t\tif ( e && !this.isSimulated ) {\n\t\t\te.preventDefault();\n\t\t}\n\t},\n\tstopPropagation: function() {\n\t\tvar e = this.originalEvent;\n\n\t\tthis.isPropagationStopped = returnTrue;\n\n\t\tif ( e && !this.isSimulated ) {\n\t\t\te.stopPropagation();\n\t\t}\n\t},\n\tstopImmediatePropagation: function() {\n\t\tvar e = this.originalEvent;\n\n\t\tthis.isImmediatePropagationStopped = returnTrue;\n\n\t\tif ( e && !this.isSimulated ) {\n\t\t\te.stopImmediatePropagation();\n\t\t}\n\n\t\tthis.stopPropagation();\n\t}\n};\n\n// Includes all common event props including KeyEvent and MouseEvent specific props\njQuery.each( {\n\taltKey: true,\n\tbubbles: true,\n\tcancelable: true,\n\tchangedTouches: true,\n\tctrlKey: true,\n\tdetail: true,\n\teventPhase: true,\n\tmetaKey: true,\n\tpageX: true,\n\tpageY: true,\n\tshiftKey: true,\n\tview: true,\n\t\"char\": true,\n\tcode: true,\n\tcharCode: true,\n\tkey: true,\n\tkeyCode: true,\n\tbutton: true,\n\tbuttons: true,\n\tclientX: true,\n\tclientY: true,\n\toffsetX: true,\n\toffsetY: true,\n\tpointerId: true,\n\tpointerType: true,\n\tscreenX: true,\n\tscreenY: true,\n\ttargetTouches: true,\n\ttoElement: true,\n\ttouches: true,\n\n\twhich: function( event ) {\n\t\tvar button = event.button;\n\n\t\t// Add which for key events\n\t\tif ( event.which == null && rkeyEvent.test( event.type ) ) {\n\t\t\treturn event.charCode != null ? event.charCode : event.keyCode;\n\t\t}\n\n\t\t// Add which for click: 1 === left; 2 === middle; 3 === right\n\t\tif ( !event.which && button !== undefined && rmouseEvent.test( event.type ) ) {\n\t\t\tif ( button & 1 ) {\n\t\t\t\treturn 1;\n\t\t\t}\n\n\t\t\tif ( button & 2 ) {\n\t\t\t\treturn 3;\n\t\t\t}\n\n\t\t\tif ( button & 4 ) {\n\t\t\t\treturn 2;\n\t\t\t}\n\n\t\t\treturn 0;\n\t\t}\n\n\t\treturn event.which;\n\t}\n}, jQuery.event.addProp );\n\njQuery.each( { focus: \"focusin\", blur: \"focusout\" }, function( type, delegateType ) {\n\tjQuery.event.special[ type ] = {\n\n\t\t// Utilize native event if possible so blur/focus sequence is correct\n\t\tsetup: function() {\n\n\t\t\t// Claim the first handler\n\t\t\t// dataPriv.set( this, \"focus\", ... )\n\t\t\t// dataPriv.set( this, \"blur\", ... )\n\t\t\tleverageNative( this, type, expectSync );\n\n\t\t\t// Return false to allow normal processing in the caller\n\t\t\treturn false;\n\t\t},\n\t\ttrigger: function() {\n\n\t\t\t// Force setup before trigger\n\t\t\tleverageNative( this, type );\n\n\t\t\t// Return non-false to allow normal event-path propagation\n\t\t\treturn true;\n\t\t},\n\n\t\tdelegateType: delegateType\n\t};\n} );\n\n// Create mouseenter/leave events using mouseover/out and event-time checks\n// so that event delegation works in jQuery.\n// Do the same for pointerenter/pointerleave and pointerover/pointerout\n//\n// Support: Safari 7 only\n// Safari sends mouseenter too often; see:\n// https://bugs.chromium.org/p/chromium/issues/detail?id=470258\n// for the description of the bug (it existed in older Chrome versions as well).\njQuery.each( {\n\tmouseenter: \"mouseover\",\n\tmouseleave: \"mouseout\",\n\tpointerenter: \"pointerover\",\n\tpointerleave: \"pointerout\"\n}, function( orig, fix ) {\n\tjQuery.event.special[ orig ] = {\n\t\tdelegateType: fix,\n\t\tbindType: fix,\n\n\t\thandle: function( event ) {\n\t\t\tvar ret,\n\t\t\t\ttarget = this,\n\t\t\t\trelated = event.relatedTarget,\n\t\t\t\thandleObj = event.handleObj;\n\n\t\t\t// For mouseenter/leave call the handler if related is outside the target.\n\t\t\t// NB: No relatedTarget if the mouse left/entered the browser window\n\t\t\tif ( !related || ( related !== target && !jQuery.contains( target, related ) ) ) {\n\t\t\t\tevent.type = handleObj.origType;\n\t\t\t\tret = handleObj.handler.apply( this, arguments );\n\t\t\t\tevent.type = fix;\n\t\t\t}\n\t\t\treturn ret;\n\t\t}\n\t};\n} );\n\njQuery.fn.extend( {\n\n\ton: function( types, selector, data, fn ) {\n\t\treturn on( this, types, selector, data, fn );\n\t},\n\tone: function( types, selector, data, fn ) {\n\t\treturn on( this, types, selector, data, fn, 1 );\n\t},\n\toff: function( types, selector, fn ) {\n\t\tvar handleObj, type;\n\t\tif ( types && types.preventDefault && types.handleObj ) {\n\n\t\t\t// ( event )  dispatched jQuery.Event\n\t\t\thandleObj = types.handleObj;\n\t\t\tjQuery( types.delegateTarget ).off(\n\t\t\t\thandleObj.namespace ?\n\t\t\t\t\thandleObj.origType + \".\" + handleObj.namespace :\n\t\t\t\t\thandleObj.origType,\n\t\t\t\thandleObj.selector,\n\t\t\t\thandleObj.handler\n\t\t\t);\n\t\t\treturn this;\n\t\t}\n\t\tif ( typeof types === \"object\" ) {\n\n\t\t\t// ( types-object [, selector] )\n\t\t\tfor ( type in types ) {\n\t\t\t\tthis.off( type, selector, types[ type ] );\n\t\t\t}\n\t\t\treturn this;\n\t\t}\n\t\tif ( selector === false || typeof selector === \"function\" ) {\n\n\t\t\t// ( types [, fn] )\n\t\t\tfn = selector;\n\t\t\tselector = undefined;\n\t\t}\n\t\tif ( fn === false ) {\n\t\t\tfn = returnFalse;\n\t\t}\n\t\treturn this.each( function() {\n\t\t\tjQuery.event.remove( this, types, fn, selector );\n\t\t} );\n\t}\n} );\n\n\nvar\n\n\t/* eslint-disable max-len */\n\n\t// See https://github.com/eslint/eslint/issues/3229\n\trxhtmlTag = /<(?!area|br|col|embed|hr|img|input|link|meta|param)(([a-z][^\\/\\0>\\x20\\t\\r\\n\\f]*)[^>]*)\\/>/gi,\n\n\t/* eslint-enable */\n\n\t// Support: IE <=10 - 11, Edge 12 - 13 only\n\t// In IE/Edge using regex groups here causes severe slowdowns.\n\t// See https://connect.microsoft.com/IE/feedback/details/1736512/\n\trnoInnerhtml = /<script|<style|<link/i,\n\n\t// checked=\"checked\" or checked\n\trchecked = /checked\\s*(?:[^=]|=\\s*.checked.)/i,\n\trcleanScript = /^\\s*<!(?:\\[CDATA\\[|--)|(?:\\]\\]|--)>\\s*$/g;\n\n// Prefer a tbody over its parent table for containing new rows\nfunction manipulationTarget( elem, content ) {\n\tif ( nodeName( elem, \"table\" ) &&\n\t\tnodeName( content.nodeType !== 11 ? content : content.firstChild, \"tr\" ) ) {\n\n\t\treturn jQuery( elem ).children( \"tbody\" )[ 0 ] || elem;\n\t}\n\n\treturn elem;\n}\n\n// Replace/restore the type attribute of script elements for safe DOM manipulation\nfunction disableScript( elem ) {\n\telem.type = ( elem.getAttribute( \"type\" ) !== null ) + \"/\" + elem.type;\n\treturn elem;\n}\nfunction restoreScript( elem ) {\n\tif ( ( elem.type || \"\" ).slice( 0, 5 ) === \"true/\" ) {\n\t\telem.type = elem.type.slice( 5 );\n\t} else {\n\t\telem.removeAttribute( \"type\" );\n\t}\n\n\treturn elem;\n}\n\nfunction cloneCopyEvent( src, dest ) {\n\tvar i, l, type, pdataOld, pdataCur, udataOld, udataCur, events;\n\n\tif ( dest.nodeType !== 1 ) {\n\t\treturn;\n\t}\n\n\t// 1. Copy private data: events, handlers, etc.\n\tif ( dataPriv.hasData( src ) ) {\n\t\tpdataOld = dataPriv.access( src );\n\t\tpdataCur = dataPriv.set( dest, pdataOld );\n\t\tevents = pdataOld.events;\n\n\t\tif ( events ) {\n\t\t\tdelete pdataCur.handle;\n\t\t\tpdataCur.events = {};\n\n\t\t\tfor ( type in events ) {\n\t\t\t\tfor ( i = 0, l = events[ type ].length; i < l; i++ ) {\n\t\t\t\t\tjQuery.event.add( dest, type, events[ type ][ i ] );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t// 2. Copy user data\n\tif ( dataUser.hasData( src ) ) {\n\t\tudataOld = dataUser.access( src );\n\t\tudataCur = jQuery.extend( {}, udataOld );\n\n\t\tdataUser.set( dest, udataCur );\n\t}\n}\n\n// Fix IE bugs, see support tests\nfunction fixInput( src, dest ) {\n\tvar nodeName = dest.nodeName.toLowerCase();\n\n\t// Fails to persist the checked state of a cloned checkbox or radio button.\n\tif ( nodeName === \"input\" && rcheckableType.test( src.type ) ) {\n\t\tdest.checked = src.checked;\n\n\t// Fails to return the selected option to the default selected state when cloning options\n\t} else if ( nodeName === \"input\" || nodeName === \"textarea\" ) {\n\t\tdest.defaultValue = src.defaultValue;\n\t}\n}\n\nfunction domManip( collection, args, callback, ignored ) {\n\n\t// Flatten any nested arrays\n\targs = concat.apply( [], args );\n\n\tvar fragment, first, scripts, hasScripts, node, doc,\n\t\ti = 0,\n\t\tl = collection.length,\n\t\tiNoClone = l - 1,\n\t\tvalue = args[ 0 ],\n\t\tvalueIsFunction = isFunction( value );\n\n\t// We can't cloneNode fragments that contain checked, in WebKit\n\tif ( valueIsFunction ||\n\t\t\t( l > 1 && typeof value === \"string\" &&\n\t\t\t\t!support.checkClone && rchecked.test( value ) ) ) {\n\t\treturn collection.each( function( index ) {\n\t\t\tvar self = collection.eq( index );\n\t\t\tif ( valueIsFunction ) {\n\t\t\t\targs[ 0 ] = value.call( this, index, self.html() );\n\t\t\t}\n\t\t\tdomManip( self, args, callback, ignored );\n\t\t} );\n\t}\n\n\tif ( l ) {\n\t\tfragment = buildFragment( args, collection[ 0 ].ownerDocument, false, collection, ignored );\n\t\tfirst = fragment.firstChild;\n\n\t\tif ( fragment.childNodes.length === 1 ) {\n\t\t\tfragment = first;\n\t\t}\n\n\t\t// Require either new content or an interest in ignored elements to invoke the callback\n\t\tif ( first || ignored ) {\n\t\t\tscripts = jQuery.map( getAll( fragment, \"script\" ), disableScript );\n\t\t\thasScripts = scripts.length;\n\n\t\t\t// Use the original fragment for the last item\n\t\t\t// instead of the first because it can end up\n\t\t\t// being emptied incorrectly in certain situations (#8070).\n\t\t\tfor ( ; i < l; i++ ) {\n\t\t\t\tnode = fragment;\n\n\t\t\t\tif ( i !== iNoClone ) {\n\t\t\t\t\tnode = jQuery.clone( node, true, true );\n\n\t\t\t\t\t// Keep references to cloned scripts for later restoration\n\t\t\t\t\tif ( hasScripts ) {\n\n\t\t\t\t\t\t// Support: Android <=4.0 only, PhantomJS 1 only\n\t\t\t\t\t\t// push.apply(_, arraylike) throws on ancient WebKit\n\t\t\t\t\t\tjQuery.merge( scripts, getAll( node, \"script\" ) );\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tcallback.call( collection[ i ], node, i );\n\t\t\t}\n\n\t\t\tif ( hasScripts ) {\n\t\t\t\tdoc = scripts[ scripts.length - 1 ].ownerDocument;\n\n\t\t\t\t// Reenable scripts\n\t\t\t\tjQuery.map( scripts, restoreScript );\n\n\t\t\t\t// Evaluate executable scripts on first document insertion\n\t\t\t\tfor ( i = 0; i < hasScripts; i++ ) {\n\t\t\t\t\tnode = scripts[ i ];\n\t\t\t\t\tif ( rscriptType.test( node.type || \"\" ) &&\n\t\t\t\t\t\t!dataPriv.access( node, \"globalEval\" ) &&\n\t\t\t\t\t\tjQuery.contains( doc, node ) ) {\n\n\t\t\t\t\t\tif ( node.src && ( node.type || \"\" ).toLowerCase()  !== \"module\" ) {\n\n\t\t\t\t\t\t\t// Optional AJAX dependency, but won't run scripts if not present\n\t\t\t\t\t\t\tif ( jQuery._evalUrl && !node.noModule ) {\n\t\t\t\t\t\t\t\tjQuery._evalUrl( node.src, {\n\t\t\t\t\t\t\t\t\tnonce: node.nonce || node.getAttribute( \"nonce\" )\n\t\t\t\t\t\t\t\t} );\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tDOMEval( node.textContent.replace( rcleanScript, \"\" ), node, doc );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn collection;\n}\n\nfunction remove( elem, selector, keepData ) {\n\tvar node,\n\t\tnodes = selector ? jQuery.filter( selector, elem ) : elem,\n\t\ti = 0;\n\n\tfor ( ; ( node = nodes[ i ] ) != null; i++ ) {\n\t\tif ( !keepData && node.nodeType === 1 ) {\n\t\t\tjQuery.cleanData( getAll( node ) );\n\t\t}\n\n\t\tif ( node.parentNode ) {\n\t\t\tif ( keepData && isAttached( node ) ) {\n\t\t\t\tsetGlobalEval( getAll( node, \"script\" ) );\n\t\t\t}\n\t\t\tnode.parentNode.removeChild( node );\n\t\t}\n\t}\n\n\treturn elem;\n}\n\njQuery.extend( {\n\thtmlPrefilter: function( html ) {\n\t\treturn html.replace( rxhtmlTag, \"<$1></$2>\" );\n\t},\n\n\tclone: function( elem, dataAndEvents, deepDataAndEvents ) {\n\t\tvar i, l, srcElements, destElements,\n\t\t\tclone = elem.cloneNode( true ),\n\t\t\tinPage = isAttached( elem );\n\n\t\t// Fix IE cloning issues\n\t\tif ( !support.noCloneChecked && ( elem.nodeType === 1 || elem.nodeType === 11 ) &&\n\t\t\t\t!jQuery.isXMLDoc( elem ) ) {\n\n\t\t\t// We eschew Sizzle here for performance reasons: https://jsperf.com/getall-vs-sizzle/2\n\t\t\tdestElements = getAll( clone );\n\t\t\tsrcElements = getAll( elem );\n\n\t\t\tfor ( i = 0, l = srcElements.length; i < l; i++ ) {\n\t\t\t\tfixInput( srcElements[ i ], destElements[ i ] );\n\t\t\t}\n\t\t}\n\n\t\t// Copy the events from the original to the clone\n\t\tif ( dataAndEvents ) {\n\t\t\tif ( deepDataAndEvents ) {\n\t\t\t\tsrcElements = srcElements || getAll( elem );\n\t\t\t\tdestElements = destElements || getAll( clone );\n\n\t\t\t\tfor ( i = 0, l = srcElements.length; i < l; i++ ) {\n\t\t\t\t\tcloneCopyEvent( srcElements[ i ], destElements[ i ] );\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tcloneCopyEvent( elem, clone );\n\t\t\t}\n\t\t}\n\n\t\t// Preserve script evaluation history\n\t\tdestElements = getAll( clone, \"script\" );\n\t\tif ( destElements.length > 0 ) {\n\t\t\tsetGlobalEval( destElements, !inPage && getAll( elem, \"script\" ) );\n\t\t}\n\n\t\t// Return the cloned set\n\t\treturn clone;\n\t},\n\n\tcleanData: function( elems ) {\n\t\tvar data, elem, type,\n\t\t\tspecial = jQuery.event.special,\n\t\t\ti = 0;\n\n\t\tfor ( ; ( elem = elems[ i ] ) !== undefined; i++ ) {\n\t\t\tif ( acceptData( elem ) ) {\n\t\t\t\tif ( ( data = elem[ dataPriv.expando ] ) ) {\n\t\t\t\t\tif ( data.events ) {\n\t\t\t\t\t\tfor ( type in data.events ) {\n\t\t\t\t\t\t\tif ( special[ type ] ) {\n\t\t\t\t\t\t\t\tjQuery.event.remove( elem, type );\n\n\t\t\t\t\t\t\t// This is a shortcut to avoid jQuery.event.remove's overhead\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tjQuery.removeEvent( elem, type, data.handle );\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\t// Support: Chrome <=35 - 45+\n\t\t\t\t\t// Assign undefined instead of using delete, see Data#remove\n\t\t\t\t\telem[ dataPriv.expando ] = undefined;\n\t\t\t\t}\n\t\t\t\tif ( elem[ dataUser.expando ] ) {\n\n\t\t\t\t\t// Support: Chrome <=35 - 45+\n\t\t\t\t\t// Assign undefined instead of using delete, see Data#remove\n\t\t\t\t\telem[ dataUser.expando ] = undefined;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n} );\n\njQuery.fn.extend( {\n\tdetach: function( selector ) {\n\t\treturn remove( this, selector, true );\n\t},\n\n\tremove: function( selector ) {\n\t\treturn remove( this, selector );\n\t},\n\n\ttext: function( value ) {\n\t\treturn access( this, function( value ) {\n\t\t\treturn value === undefined ?\n\t\t\t\tjQuery.text( this ) :\n\t\t\t\tthis.empty().each( function() {\n\t\t\t\t\tif ( this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9 ) {\n\t\t\t\t\t\tthis.textContent = value;\n\t\t\t\t\t}\n\t\t\t\t} );\n\t\t}, null, value, arguments.length );\n\t},\n\n\tappend: function() {\n\t\treturn domManip( this, arguments, function( elem ) {\n\t\t\tif ( this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9 ) {\n\t\t\t\tvar target = manipulationTarget( this, elem );\n\t\t\t\ttarget.appendChild( elem );\n\t\t\t}\n\t\t} );\n\t},\n\n\tprepend: function() {\n\t\treturn domManip( this, arguments, function( elem ) {\n\t\t\tif ( this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9 ) {\n\t\t\t\tvar target = manipulationTarget( this, elem );\n\t\t\t\ttarget.insertBefore( elem, target.firstChild );\n\t\t\t}\n\t\t} );\n\t},\n\n\tbefore: function() {\n\t\treturn domManip( this, arguments, function( elem ) {\n\t\t\tif ( this.parentNode ) {\n\t\t\t\tthis.parentNode.insertBefore( elem, this );\n\t\t\t}\n\t\t} );\n\t},\n\n\tafter: function() {\n\t\treturn domManip( this, arguments, function( elem ) {\n\t\t\tif ( this.parentNode ) {\n\t\t\t\tthis.parentNode.insertBefore( elem, this.nextSibling );\n\t\t\t}\n\t\t} );\n\t},\n\n\tempty: function() {\n\t\tvar elem,\n\t\t\ti = 0;\n\n\t\tfor ( ; ( elem = this[ i ] ) != null; i++ ) {\n\t\t\tif ( elem.nodeType === 1 ) {\n\n\t\t\t\t// Prevent memory leaks\n\t\t\t\tjQuery.cleanData( getAll( elem, false ) );\n\n\t\t\t\t// Remove any remaining nodes\n\t\t\t\telem.textContent = \"\";\n\t\t\t}\n\t\t}\n\n\t\treturn this;\n\t},\n\n\tclone: function( dataAndEvents, deepDataAndEvents ) {\n\t\tdataAndEvents = dataAndEvents == null ? false : dataAndEvents;\n\t\tdeepDataAndEvents = deepDataAndEvents == null ? dataAndEvents : deepDataAndEvents;\n\n\t\treturn this.map( function() {\n\t\t\treturn jQuery.clone( this, dataAndEvents, deepDataAndEvents );\n\t\t} );\n\t},\n\n\thtml: function( value ) {\n\t\treturn access( this, function( value ) {\n\t\t\tvar elem = this[ 0 ] || {},\n\t\t\t\ti = 0,\n\t\t\t\tl = this.length;\n\n\t\t\tif ( value === undefined && elem.nodeType === 1 ) {\n\t\t\t\treturn elem.innerHTML;\n\t\t\t}\n\n\t\t\t// See if we can take a shortcut and just use innerHTML\n\t\t\tif ( typeof value === \"string\" && !rnoInnerhtml.test( value ) &&\n\t\t\t\t!wrapMap[ ( rtagName.exec( value ) || [ \"\", \"\" ] )[ 1 ].toLowerCase() ] ) {\n\n\t\t\t\tvalue = jQuery.htmlPrefilter( value );\n\n\t\t\t\ttry {\n\t\t\t\t\tfor ( ; i < l; i++ ) {\n\t\t\t\t\t\telem = this[ i ] || {};\n\n\t\t\t\t\t\t// Remove element nodes and prevent memory leaks\n\t\t\t\t\t\tif ( elem.nodeType === 1 ) {\n\t\t\t\t\t\t\tjQuery.cleanData( getAll( elem, false ) );\n\t\t\t\t\t\t\telem.innerHTML = value;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\telem = 0;\n\n\t\t\t\t// If using innerHTML throws an exception, use the fallback method\n\t\t\t\t} catch ( e ) {}\n\t\t\t}\n\n\t\t\tif ( elem ) {\n\t\t\t\tthis.empty().append( value );\n\t\t\t}\n\t\t}, null, value, arguments.length );\n\t},\n\n\treplaceWith: function() {\n\t\tvar ignored = [];\n\n\t\t// Make the changes, replacing each non-ignored context element with the new content\n\t\treturn domManip( this, arguments, function( elem ) {\n\t\t\tvar parent = this.parentNode;\n\n\t\t\tif ( jQuery.inArray( this, ignored ) < 0 ) {\n\t\t\t\tjQuery.cleanData( getAll( this ) );\n\t\t\t\tif ( parent ) {\n\t\t\t\t\tparent.replaceChild( elem, this );\n\t\t\t\t}\n\t\t\t}\n\n\t\t// Force callback invocation\n\t\t}, ignored );\n\t}\n} );\n\njQuery.each( {\n\tappendTo: \"append\",\n\tprependTo: \"prepend\",\n\tinsertBefore: \"before\",\n\tinsertAfter: \"after\",\n\treplaceAll: \"replaceWith\"\n}, function( name, original ) {\n\tjQuery.fn[ name ] = function( selector ) {\n\t\tvar elems,\n\t\t\tret = [],\n\t\t\tinsert = jQuery( selector ),\n\t\t\tlast = insert.length - 1,\n\t\t\ti = 0;\n\n\t\tfor ( ; i <= last; i++ ) {\n\t\t\telems = i === last ? this : this.clone( true );\n\t\t\tjQuery( insert[ i ] )[ original ]( elems );\n\n\t\t\t// Support: Android <=4.0 only, PhantomJS 1 only\n\t\t\t// .get() because push.apply(_, arraylike) throws on ancient WebKit\n\t\t\tpush.apply( ret, elems.get() );\n\t\t}\n\n\t\treturn this.pushStack( ret );\n\t};\n} );\nvar rnumnonpx = new RegExp( \"^(\" + pnum + \")(?!px)[a-z%]+$\", \"i\" );\n\nvar getStyles = function( elem ) {\n\n\t\t// Support: IE <=11 only, Firefox <=30 (#15098, #14150)\n\t\t// IE throws on elements created in popups\n\t\t// FF meanwhile throws on frame elements through \"defaultView.getComputedStyle\"\n\t\tvar view = elem.ownerDocument.defaultView;\n\n\t\tif ( !view || !view.opener ) {\n\t\t\tview = window;\n\t\t}\n\n\t\treturn view.getComputedStyle( elem );\n\t};\n\nvar rboxStyle = new RegExp( cssExpand.join( \"|\" ), \"i\" );\n\n\n\n( function() {\n\n\t// Executing both pixelPosition & boxSizingReliable tests require only one layout\n\t// so they're executed at the same time to save the second computation.\n\tfunction computeStyleTests() {\n\n\t\t// This is a singleton, we need to execute it only once\n\t\tif ( !div ) {\n\t\t\treturn;\n\t\t}\n\n\t\tcontainer.style.cssText = \"position:absolute;left:-11111px;width:60px;\" +\n\t\t\t\"margin-top:1px;padding:0;border:0\";\n\t\tdiv.style.cssText =\n\t\t\t\"position:relative;display:block;box-sizing:border-box;overflow:scroll;\" +\n\t\t\t\"margin:auto;border:1px;padding:1px;\" +\n\t\t\t\"width:60%;top:1%\";\n\t\tdocumentElement.appendChild( container ).appendChild( div );\n\n\t\tvar divStyle = window.getComputedStyle( div );\n\t\tpixelPositionVal = divStyle.top !== \"1%\";\n\n\t\t// Support: Android 4.0 - 4.3 only, Firefox <=3 - 44\n\t\treliableMarginLeftVal = roundPixelMeasures( divStyle.marginLeft ) === 12;\n\n\t\t// Support: Android 4.0 - 4.3 only, Safari <=9.1 - 10.1, iOS <=7.0 - 9.3\n\t\t// Some styles come back with percentage values, even though they shouldn't\n\t\tdiv.style.right = \"60%\";\n\t\tpixelBoxStylesVal = roundPixelMeasures( divStyle.right ) === 36;\n\n\t\t// Support: IE 9 - 11 only\n\t\t// Detect misreporting of content dimensions for box-sizing:border-box elements\n\t\tboxSizingReliableVal = roundPixelMeasures( divStyle.width ) === 36;\n\n\t\t// Support: IE 9 only\n\t\t// Detect overflow:scroll screwiness (gh-3699)\n\t\t// Support: Chrome <=64\n\t\t// Don't get tricked when zoom affects offsetWidth (gh-4029)\n\t\tdiv.style.position = \"absolute\";\n\t\tscrollboxSizeVal = roundPixelMeasures( div.offsetWidth / 3 ) === 12;\n\n\t\tdocumentElement.removeChild( container );\n\n\t\t// Nullify the div so it wouldn't be stored in the memory and\n\t\t// it will also be a sign that checks already performed\n\t\tdiv = null;\n\t}\n\n\tfunction roundPixelMeasures( measure ) {\n\t\treturn Math.round( parseFloat( measure ) );\n\t}\n\n\tvar pixelPositionVal, boxSizingReliableVal, scrollboxSizeVal, pixelBoxStylesVal,\n\t\treliableMarginLeftVal,\n\t\tcontainer = document.createElement( \"div\" ),\n\t\tdiv = document.createElement( \"div\" );\n\n\t// Finish early in limited (non-browser) environments\n\tif ( !div.style ) {\n\t\treturn;\n\t}\n\n\t// Support: IE <=9 - 11 only\n\t// Style of cloned element affects source element cloned (#8908)\n\tdiv.style.backgroundClip = \"content-box\";\n\tdiv.cloneNode( true ).style.backgroundClip = \"\";\n\tsupport.clearCloneStyle = div.style.backgroundClip === \"content-box\";\n\n\tjQuery.extend( support, {\n\t\tboxSizingReliable: function() {\n\t\t\tcomputeStyleTests();\n\t\t\treturn boxSizingReliableVal;\n\t\t},\n\t\tpixelBoxStyles: function() {\n\t\t\tcomputeStyleTests();\n\t\t\treturn pixelBoxStylesVal;\n\t\t},\n\t\tpixelPosition: function() {\n\t\t\tcomputeStyleTests();\n\t\t\treturn pixelPositionVal;\n\t\t},\n\t\treliableMarginLeft: function() {\n\t\t\tcomputeStyleTests();\n\t\t\treturn reliableMarginLeftVal;\n\t\t},\n\t\tscrollboxSize: function() {\n\t\t\tcomputeStyleTests();\n\t\t\treturn scrollboxSizeVal;\n\t\t}\n\t} );\n} )();\n\n\nfunction curCSS( elem, name, computed ) {\n\tvar width, minWidth, maxWidth, ret,\n\n\t\t// Support: Firefox 51+\n\t\t// Retrieving style before computed somehow\n\t\t// fixes an issue with getting wrong values\n\t\t// on detached elements\n\t\tstyle = elem.style;\n\n\tcomputed = computed || getStyles( elem );\n\n\t// getPropertyValue is needed for:\n\t//   .css('filter') (IE 9 only, #12537)\n\t//   .css('--customProperty) (#3144)\n\tif ( computed ) {\n\t\tret = computed.getPropertyValue( name ) || computed[ name ];\n\n\t\tif ( ret === \"\" && !isAttached( elem ) ) {\n\t\t\tret = jQuery.style( elem, name );\n\t\t}\n\n\t\t// A tribute to the \"awesome hack by Dean Edwards\"\n\t\t// Android Browser returns percentage for some values,\n\t\t// but width seems to be reliably pixels.\n\t\t// This is against the CSSOM draft spec:\n\t\t// https://drafts.csswg.org/cssom/#resolved-values\n\t\tif ( !support.pixelBoxStyles() && rnumnonpx.test( ret ) && rboxStyle.test( name ) ) {\n\n\t\t\t// Remember the original values\n\t\t\twidth = style.width;\n\t\t\tminWidth = style.minWidth;\n\t\t\tmaxWidth = style.maxWidth;\n\n\t\t\t// Put in the new values to get a computed value out\n\t\t\tstyle.minWidth = style.maxWidth = style.width = ret;\n\t\t\tret = computed.width;\n\n\t\t\t// Revert the changed values\n\t\t\tstyle.width = width;\n\t\t\tstyle.minWidth = minWidth;\n\t\t\tstyle.maxWidth = maxWidth;\n\t\t}\n\t}\n\n\treturn ret !== undefined ?\n\n\t\t// Support: IE <=9 - 11 only\n\t\t// IE returns zIndex value as an integer.\n\t\tret + \"\" :\n\t\tret;\n}\n\n\nfunction addGetHookIf( conditionFn, hookFn ) {\n\n\t// Define the hook, we'll check on the first run if it's really needed.\n\treturn {\n\t\tget: function() {\n\t\t\tif ( conditionFn() ) {\n\n\t\t\t\t// Hook not needed (or it's not possible to use it due\n\t\t\t\t// to missing dependency), remove it.\n\t\t\t\tdelete this.get;\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// Hook needed; redefine it so that the support test is not executed again.\n\t\t\treturn ( this.get = hookFn ).apply( this, arguments );\n\t\t}\n\t};\n}\n\n\nvar cssPrefixes = [ \"Webkit\", \"Moz\", \"ms\" ],\n\temptyStyle = document.createElement( \"div\" ).style,\n\tvendorProps = {};\n\n// Return a vendor-prefixed property or undefined\nfunction vendorPropName( name ) {\n\n\t// Check for vendor prefixed names\n\tvar capName = name[ 0 ].toUpperCase() + name.slice( 1 ),\n\t\ti = cssPrefixes.length;\n\n\twhile ( i-- ) {\n\t\tname = cssPrefixes[ i ] + capName;\n\t\tif ( name in emptyStyle ) {\n\t\t\treturn name;\n\t\t}\n\t}\n}\n\n// Return a potentially-mapped jQuery.cssProps or vendor prefixed property\nfunction finalPropName( name ) {\n\tvar final = jQuery.cssProps[ name ] || vendorProps[ name ];\n\n\tif ( final ) {\n\t\treturn final;\n\t}\n\tif ( name in emptyStyle ) {\n\t\treturn name;\n\t}\n\treturn vendorProps[ name ] = vendorPropName( name ) || name;\n}\n\n\nvar\n\n\t// Swappable if display is none or starts with table\n\t// except \"table\", \"table-cell\", or \"table-caption\"\n\t// See here for display values: https://developer.mozilla.org/en-US/docs/CSS/display\n\trdisplayswap = /^(none|table(?!-c[ea]).+)/,\n\trcustomProp = /^--/,\n\tcssShow = { position: \"absolute\", visibility: \"hidden\", display: \"block\" },\n\tcssNormalTransform = {\n\t\tletterSpacing: \"0\",\n\t\tfontWeight: \"400\"\n\t};\n\nfunction setPositiveNumber( elem, value, subtract ) {\n\n\t// Any relative (+/-) values have already been\n\t// normalized at this point\n\tvar matches = rcssNum.exec( value );\n\treturn matches ?\n\n\t\t// Guard against undefined \"subtract\", e.g., when used as in cssHooks\n\t\tMath.max( 0, matches[ 2 ] - ( subtract || 0 ) ) + ( matches[ 3 ] || \"px\" ) :\n\t\tvalue;\n}\n\nfunction boxModelAdjustment( elem, dimension, box, isBorderBox, styles, computedVal ) {\n\tvar i = dimension === \"width\" ? 1 : 0,\n\t\textra = 0,\n\t\tdelta = 0;\n\n\t// Adjustment may not be necessary\n\tif ( box === ( isBorderBox ? \"border\" : \"content\" ) ) {\n\t\treturn 0;\n\t}\n\n\tfor ( ; i < 4; i += 2 ) {\n\n\t\t// Both box models exclude margin\n\t\tif ( box === \"margin\" ) {\n\t\t\tdelta += jQuery.css( elem, box + cssExpand[ i ], true, styles );\n\t\t}\n\n\t\t// If we get here with a content-box, we're seeking \"padding\" or \"border\" or \"margin\"\n\t\tif ( !isBorderBox ) {\n\n\t\t\t// Add padding\n\t\t\tdelta += jQuery.css( elem, \"padding\" + cssExpand[ i ], true, styles );\n\n\t\t\t// For \"border\" or \"margin\", add border\n\t\t\tif ( box !== \"padding\" ) {\n\t\t\t\tdelta += jQuery.css( elem, \"border\" + cssExpand[ i ] + \"Width\", true, styles );\n\n\t\t\t// But still keep track of it otherwise\n\t\t\t} else {\n\t\t\t\textra += jQuery.css( elem, \"border\" + cssExpand[ i ] + \"Width\", true, styles );\n\t\t\t}\n\n\t\t// If we get here with a border-box (content + padding + border), we're seeking \"content\" or\n\t\t// \"padding\" or \"margin\"\n\t\t} else {\n\n\t\t\t// For \"content\", subtract padding\n\t\t\tif ( box === \"content\" ) {\n\t\t\t\tdelta -= jQuery.css( elem, \"padding\" + cssExpand[ i ], true, styles );\n\t\t\t}\n\n\t\t\t// For \"content\" or \"padding\", subtract border\n\t\t\tif ( box !== \"margin\" ) {\n\t\t\t\tdelta -= jQuery.css( elem, \"border\" + cssExpand[ i ] + \"Width\", true, styles );\n\t\t\t}\n\t\t}\n\t}\n\n\t// Account for positive content-box scroll gutter when requested by providing computedVal\n\tif ( !isBorderBox && computedVal >= 0 ) {\n\n\t\t// offsetWidth/offsetHeight is a rounded sum of content, padding, scroll gutter, and border\n\t\t// Assuming integer scroll gutter, subtract the rest and round down\n\t\tdelta += Math.max( 0, Math.ceil(\n\t\t\telem[ \"offset\" + dimension[ 0 ].toUpperCase() + dimension.slice( 1 ) ] -\n\t\t\tcomputedVal -\n\t\t\tdelta -\n\t\t\textra -\n\t\t\t0.5\n\n\t\t// If offsetWidth/offsetHeight is unknown, then we can't determine content-box scroll gutter\n\t\t// Use an explicit zero to avoid NaN (gh-3964)\n\t\t) ) || 0;\n\t}\n\n\treturn delta;\n}\n\nfunction getWidthOrHeight( elem, dimension, extra ) {\n\n\t// Start with computed style\n\tvar styles = getStyles( elem ),\n\n\t\t// To avoid forcing a reflow, only fetch boxSizing if we need it (gh-4322).\n\t\t// Fake content-box until we know it's needed to know the true value.\n\t\tboxSizingNeeded = !support.boxSizingReliable() || extra,\n\t\tisBorderBox = boxSizingNeeded &&\n\t\t\tjQuery.css( elem, \"boxSizing\", false, styles ) === \"border-box\",\n\t\tvalueIsBorderBox = isBorderBox,\n\n\t\tval = curCSS( elem, dimension, styles ),\n\t\toffsetProp = \"offset\" + dimension[ 0 ].toUpperCase() + dimension.slice( 1 );\n\n\t// Support: Firefox <=54\n\t// Return a confounding non-pixel value or feign ignorance, as appropriate.\n\tif ( rnumnonpx.test( val ) ) {\n\t\tif ( !extra ) {\n\t\t\treturn val;\n\t\t}\n\t\tval = \"auto\";\n\t}\n\n\n\t// Fall back to offsetWidth/offsetHeight when value is \"auto\"\n\t// This happens for inline elements with no explicit setting (gh-3571)\n\t// Support: Android <=4.1 - 4.3 only\n\t// Also use offsetWidth/offsetHeight for misreported inline dimensions (gh-3602)\n\t// Support: IE 9-11 only\n\t// Also use offsetWidth/offsetHeight for when box sizing is unreliable\n\t// We use getClientRects() to check for hidden/disconnected.\n\t// In those cases, the computed value can be trusted to be border-box\n\tif ( ( !support.boxSizingReliable() && isBorderBox ||\n\t\tval === \"auto\" ||\n\t\t!parseFloat( val ) && jQuery.css( elem, \"display\", false, styles ) === \"inline\" ) &&\n\t\telem.getClientRects().length ) {\n\n\t\tisBorderBox = jQuery.css( elem, \"boxSizing\", false, styles ) === \"border-box\";\n\n\t\t// Where available, offsetWidth/offsetHeight approximate border box dimensions.\n\t\t// Where not available (e.g., SVG), assume unreliable box-sizing and interpret the\n\t\t// retrieved value as a content box dimension.\n\t\tvalueIsBorderBox = offsetProp in elem;\n\t\tif ( valueIsBorderBox ) {\n\t\t\tval = elem[ offsetProp ];\n\t\t}\n\t}\n\n\t// Normalize \"\" and auto\n\tval = parseFloat( val ) || 0;\n\n\t// Adjust for the element's box model\n\treturn ( val +\n\t\tboxModelAdjustment(\n\t\t\telem,\n\t\t\tdimension,\n\t\t\textra || ( isBorderBox ? \"border\" : \"content\" ),\n\t\t\tvalueIsBorderBox,\n\t\t\tstyles,\n\n\t\t\t// Provide the current computed size to request scroll gutter calculation (gh-3589)\n\t\t\tval\n\t\t)\n\t) + \"px\";\n}\n\njQuery.extend( {\n\n\t// Add in style property hooks for overriding the default\n\t// behavior of getting and setting a style property\n\tcssHooks: {\n\t\topacity: {\n\t\t\tget: function( elem, computed ) {\n\t\t\t\tif ( computed ) {\n\n\t\t\t\t\t// We should always get a number back from opacity\n\t\t\t\t\tvar ret = curCSS( elem, \"opacity\" );\n\t\t\t\t\treturn ret === \"\" ? \"1\" : ret;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t},\n\n\t// Don't automatically add \"px\" to these possibly-unitless properties\n\tcssNumber: {\n\t\t\"animationIterationCount\": true,\n\t\t\"columnCount\": true,\n\t\t\"fillOpacity\": true,\n\t\t\"flexGrow\": true,\n\t\t\"flexShrink\": true,\n\t\t\"fontWeight\": true,\n\t\t\"gridArea\": true,\n\t\t\"gridColumn\": true,\n\t\t\"gridColumnEnd\": true,\n\t\t\"gridColumnStart\": true,\n\t\t\"gridRow\": true,\n\t\t\"gridRowEnd\": true,\n\t\t\"gridRowStart\": true,\n\t\t\"lineHeight\": true,\n\t\t\"opacity\": true,\n\t\t\"order\": true,\n\t\t\"orphans\": true,\n\t\t\"widows\": true,\n\t\t\"zIndex\": true,\n\t\t\"zoom\": true\n\t},\n\n\t// Add in properties whose names you wish to fix before\n\t// setting or getting the value\n\tcssProps: {},\n\n\t// Get and set the style property on a DOM Node\n\tstyle: function( elem, name, value, extra ) {\n\n\t\t// Don't set styles on text and comment nodes\n\t\tif ( !elem || elem.nodeType === 3 || elem.nodeType === 8 || !elem.style ) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Make sure that we're working with the right name\n\t\tvar ret, type, hooks,\n\t\t\torigName = camelCase( name ),\n\t\t\tisCustomProp = rcustomProp.test( name ),\n\t\t\tstyle = elem.style;\n\n\t\t// Make sure that we're working with the right name. We don't\n\t\t// want to query the value if it is a CSS custom property\n\t\t// since they are user-defined.\n\t\tif ( !isCustomProp ) {\n\t\t\tname = finalPropName( origName );\n\t\t}\n\n\t\t// Gets hook for the prefixed version, then unprefixed version\n\t\thooks = jQuery.cssHooks[ name ] || jQuery.cssHooks[ origName ];\n\n\t\t// Check if we're setting a value\n\t\tif ( value !== undefined ) {\n\t\t\ttype = typeof value;\n\n\t\t\t// Convert \"+=\" or \"-=\" to relative numbers (#7345)\n\t\t\tif ( type === \"string\" && ( ret = rcssNum.exec( value ) ) && ret[ 1 ] ) {\n\t\t\t\tvalue = adjustCSS( elem, name, ret );\n\n\t\t\t\t// Fixes bug #9237\n\t\t\t\ttype = \"number\";\n\t\t\t}\n\n\t\t\t// Make sure that null and NaN values aren't set (#7116)\n\t\t\tif ( value == null || value !== value ) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// If a number was passed in, add the unit (except for certain CSS properties)\n\t\t\t// The isCustomProp check can be removed in jQuery 4.0 when we only auto-append\n\t\t\t// \"px\" to a few hardcoded values.\n\t\t\tif ( type === \"number\" && !isCustomProp ) {\n\t\t\t\tvalue += ret && ret[ 3 ] || ( jQuery.cssNumber[ origName ] ? \"\" : \"px\" );\n\t\t\t}\n\n\t\t\t// background-* props affect original clone's values\n\t\t\tif ( !support.clearCloneStyle && value === \"\" && name.indexOf( \"background\" ) === 0 ) {\n\t\t\t\tstyle[ name ] = \"inherit\";\n\t\t\t}\n\n\t\t\t// If a hook was provided, use that value, otherwise just set the specified value\n\t\t\tif ( !hooks || !( \"set\" in hooks ) ||\n\t\t\t\t( value = hooks.set( elem, value, extra ) ) !== undefined ) {\n\n\t\t\t\tif ( isCustomProp ) {\n\t\t\t\t\tstyle.setProperty( name, value );\n\t\t\t\t} else {\n\t\t\t\t\tstyle[ name ] = value;\n\t\t\t\t}\n\t\t\t}\n\n\t\t} else {\n\n\t\t\t// If a hook was provided get the non-computed value from there\n\t\t\tif ( hooks && \"get\" in hooks &&\n\t\t\t\t( ret = hooks.get( elem, false, extra ) ) !== undefined ) {\n\n\t\t\t\treturn ret;\n\t\t\t}\n\n\t\t\t// Otherwise just get the value from the style object\n\t\t\treturn style[ name ];\n\t\t}\n\t},\n\n\tcss: function( elem, name, extra, styles ) {\n\t\tvar val, num, hooks,\n\t\t\torigName = camelCase( name ),\n\t\t\tisCustomProp = rcustomProp.test( name );\n\n\t\t// Make sure that we're working with the right name. We don't\n\t\t// want to modify the value if it is a CSS custom property\n\t\t// since they are user-defined.\n\t\tif ( !isCustomProp ) {\n\t\t\tname = finalPropName( origName );\n\t\t}\n\n\t\t// Try prefixed name followed by the unprefixed name\n\t\thooks = jQuery.cssHooks[ name ] || jQuery.cssHooks[ origName ];\n\n\t\t// If a hook was provided get the computed value from there\n\t\tif ( hooks && \"get\" in hooks ) {\n\t\t\tval = hooks.get( elem, true, extra );\n\t\t}\n\n\t\t// Otherwise, if a way to get the computed value exists, use that\n\t\tif ( val === undefined ) {\n\t\t\tval = curCSS( elem, name, styles );\n\t\t}\n\n\t\t// Convert \"normal\" to computed value\n\t\tif ( val === \"normal\" && name in cssNormalTransform ) {\n\t\t\tval = cssNormalTransform[ name ];\n\t\t}\n\n\t\t// Make numeric if forced or a qualifier was provided and val looks numeric\n\t\tif ( extra === \"\" || extra ) {\n\t\t\tnum = parseFloat( val );\n\t\t\treturn extra === true || isFinite( num ) ? num || 0 : val;\n\t\t}\n\n\t\treturn val;\n\t}\n} );\n\njQuery.each( [ \"height\", \"width\" ], function( i, dimension ) {\n\tjQuery.cssHooks[ dimension ] = {\n\t\tget: function( elem, computed, extra ) {\n\t\t\tif ( computed ) {\n\n\t\t\t\t// Certain elements can have dimension info if we invisibly show them\n\t\t\t\t// but it must have a current display style that would benefit\n\t\t\t\treturn rdisplayswap.test( jQuery.css( elem, \"display\" ) ) &&\n\n\t\t\t\t\t// Support: Safari 8+\n\t\t\t\t\t// Table columns in Safari have non-zero offsetWidth & zero\n\t\t\t\t\t// getBoundingClientRect().width unless display is changed.\n\t\t\t\t\t// Support: IE <=11 only\n\t\t\t\t\t// Running getBoundingClientRect on a disconnected node\n\t\t\t\t\t// in IE throws an error.\n\t\t\t\t\t( !elem.getClientRects().length || !elem.getBoundingClientRect().width ) ?\n\t\t\t\t\t\tswap( elem, cssShow, function() {\n\t\t\t\t\t\t\treturn getWidthOrHeight( elem, dimension, extra );\n\t\t\t\t\t\t} ) :\n\t\t\t\t\t\tgetWidthOrHeight( elem, dimension, extra );\n\t\t\t}\n\t\t},\n\n\t\tset: function( elem, value, extra ) {\n\t\t\tvar matches,\n\t\t\t\tstyles = getStyles( elem ),\n\n\t\t\t\t// Only read styles.position if the test has a chance to fail\n\t\t\t\t// to avoid forcing a reflow.\n\t\t\t\tscrollboxSizeBuggy = !support.scrollboxSize() &&\n\t\t\t\t\tstyles.position === \"absolute\",\n\n\t\t\t\t// To avoid forcing a reflow, only fetch boxSizing if we need it (gh-3991)\n\t\t\t\tboxSizingNeeded = scrollboxSizeBuggy || extra,\n\t\t\t\tisBorderBox = boxSizingNeeded &&\n\t\t\t\t\tjQuery.css( elem, \"boxSizing\", false, styles ) === \"border-box\",\n\t\t\t\tsubtract = extra ?\n\t\t\t\t\tboxModelAdjustment(\n\t\t\t\t\t\telem,\n\t\t\t\t\t\tdimension,\n\t\t\t\t\t\textra,\n\t\t\t\t\t\tisBorderBox,\n\t\t\t\t\t\tstyles\n\t\t\t\t\t) :\n\t\t\t\t\t0;\n\n\t\t\t// Account for unreliable border-box dimensions by comparing offset* to computed and\n\t\t\t// faking a content-box to get border and padding (gh-3699)\n\t\t\tif ( isBorderBox && scrollboxSizeBuggy ) {\n\t\t\t\tsubtract -= Math.ceil(\n\t\t\t\t\telem[ \"offset\" + dimension[ 0 ].toUpperCase() + dimension.slice( 1 ) ] -\n\t\t\t\t\tparseFloat( styles[ dimension ] ) -\n\t\t\t\t\tboxModelAdjustment( elem, dimension, \"border\", false, styles ) -\n\t\t\t\t\t0.5\n\t\t\t\t);\n\t\t\t}\n\n\t\t\t// Convert to pixels if value adjustment is needed\n\t\t\tif ( subtract && ( matches = rcssNum.exec( value ) ) &&\n\t\t\t\t( matches[ 3 ] || \"px\" ) !== \"px\" ) {\n\n\t\t\t\telem.style[ dimension ] = value;\n\t\t\t\tvalue = jQuery.css( elem, dimension );\n\t\t\t}\n\n\t\t\treturn setPositiveNumber( elem, value, subtract );\n\t\t}\n\t};\n} );\n\njQuery.cssHooks.marginLeft = addGetHookIf( support.reliableMarginLeft,\n\tfunction( elem, computed ) {\n\t\tif ( computed ) {\n\t\t\treturn ( parseFloat( curCSS( elem, \"marginLeft\" ) ) ||\n\t\t\t\telem.getBoundingClientRect().left -\n\t\t\t\t\tswap( elem, { marginLeft: 0 }, function() {\n\t\t\t\t\t\treturn elem.getBoundingClientRect().left;\n\t\t\t\t\t} )\n\t\t\t\t) + \"px\";\n\t\t}\n\t}\n);\n\n// These hooks are used by animate to expand properties\njQuery.each( {\n\tmargin: \"\",\n\tpadding: \"\",\n\tborder: \"Width\"\n}, function( prefix, suffix ) {\n\tjQuery.cssHooks[ prefix + suffix ] = {\n\t\texpand: function( value ) {\n\t\t\tvar i = 0,\n\t\t\t\texpanded = {},\n\n\t\t\t\t// Assumes a single number if not a string\n\t\t\t\tparts = typeof value === \"string\" ? value.split( \" \" ) : [ value ];\n\n\t\t\tfor ( ; i < 4; i++ ) {\n\t\t\t\texpanded[ prefix + cssExpand[ i ] + suffix ] =\n\t\t\t\t\tparts[ i ] || parts[ i - 2 ] || parts[ 0 ];\n\t\t\t}\n\n\t\t\treturn expanded;\n\t\t}\n\t};\n\n\tif ( prefix !== \"margin\" ) {\n\t\tjQuery.cssHooks[ prefix + suffix ].set = setPositiveNumber;\n\t}\n} );\n\njQuery.fn.extend( {\n\tcss: function( name, value ) {\n\t\treturn access( this, function( elem, name, value ) {\n\t\t\tvar styles, len,\n\t\t\t\tmap = {},\n\t\t\t\ti = 0;\n\n\t\t\tif ( Array.isArray( name ) ) {\n\t\t\t\tstyles = getStyles( elem );\n\t\t\t\tlen = name.length;\n\n\t\t\t\tfor ( ; i < len; i++ ) {\n\t\t\t\t\tmap[ name[ i ] ] = jQuery.css( elem, name[ i ], false, styles );\n\t\t\t\t}\n\n\t\t\t\treturn map;\n\t\t\t}\n\n\t\t\treturn value !== undefined ?\n\t\t\t\tjQuery.style( elem, name, value ) :\n\t\t\t\tjQuery.css( elem, name );\n\t\t}, name, value, arguments.length > 1 );\n\t}\n} );\n\n\nfunction Tween( elem, options, prop, end, easing ) {\n\treturn new Tween.prototype.init( elem, options, prop, end, easing );\n}\njQuery.Tween = Tween;\n\nTween.prototype = {\n\tconstructor: Tween,\n\tinit: function( elem, options, prop, end, easing, unit ) {\n\t\tthis.elem = elem;\n\t\tthis.prop = prop;\n\t\tthis.easing = easing || jQuery.easing._default;\n\t\tthis.options = options;\n\t\tthis.start = this.now = this.cur();\n\t\tthis.end = end;\n\t\tthis.unit = unit || ( jQuery.cssNumber[ prop ] ? \"\" : \"px\" );\n\t},\n\tcur: function() {\n\t\tvar hooks = Tween.propHooks[ this.prop ];\n\n\t\treturn hooks && hooks.get ?\n\t\t\thooks.get( this ) :\n\t\t\tTween.propHooks._default.get( this );\n\t},\n\trun: function( percent ) {\n\t\tvar eased,\n\t\t\thooks = Tween.propHooks[ this.prop ];\n\n\t\tif ( this.options.duration ) {\n\t\t\tthis.pos = eased = jQuery.easing[ this.easing ](\n\t\t\t\tpercent, this.options.duration * percent, 0, 1, this.options.duration\n\t\t\t);\n\t\t} else {\n\t\t\tthis.pos = eased = percent;\n\t\t}\n\t\tthis.now = ( this.end - this.start ) * eased + this.start;\n\n\t\tif ( this.options.step ) {\n\t\t\tthis.options.step.call( this.elem, this.now, this );\n\t\t}\n\n\t\tif ( hooks && hooks.set ) {\n\t\t\thooks.set( this );\n\t\t} else {\n\t\t\tTween.propHooks._default.set( this );\n\t\t}\n\t\treturn this;\n\t}\n};\n\nTween.prototype.init.prototype = Tween.prototype;\n\nTween.propHooks = {\n\t_default: {\n\t\tget: function( tween ) {\n\t\t\tvar result;\n\n\t\t\t// Use a property on the element directly when it is not a DOM element,\n\t\t\t// or when there is no matching style property that exists.\n\t\t\tif ( tween.elem.nodeType !== 1 ||\n\t\t\t\ttween.elem[ tween.prop ] != null && tween.elem.style[ tween.prop ] == null ) {\n\t\t\t\treturn tween.elem[ tween.prop ];\n\t\t\t}\n\n\t\t\t// Passing an empty string as a 3rd parameter to .css will automatically\n\t\t\t// attempt a parseFloat and fallback to a string if the parse fails.\n\t\t\t// Simple values such as \"10px\" are parsed to Float;\n\t\t\t// complex values such as \"rotate(1rad)\" are returned as-is.\n\t\t\tresult = jQuery.css( tween.elem, tween.prop, \"\" );\n\n\t\t\t// Empty strings, null, undefined and \"auto\" are converted to 0.\n\t\t\treturn !result || result === \"auto\" ? 0 : result;\n\t\t},\n\t\tset: function( tween ) {\n\n\t\t\t// Use step hook for back compat.\n\t\t\t// Use cssHook if its there.\n\t\t\t// Use .style if available and use plain properties where available.\n\t\t\tif ( jQuery.fx.step[ tween.prop ] ) {\n\t\t\t\tjQuery.fx.step[ tween.prop ]( tween );\n\t\t\t} else if ( tween.elem.nodeType === 1 && (\n\t\t\t\t\tjQuery.cssHooks[ tween.prop ] ||\n\t\t\t\t\ttween.elem.style[ finalPropName( tween.prop ) ] != null ) ) {\n\t\t\t\tjQuery.style( tween.elem, tween.prop, tween.now + tween.unit );\n\t\t\t} else {\n\t\t\t\ttween.elem[ tween.prop ] = tween.now;\n\t\t\t}\n\t\t}\n\t}\n};\n\n// Support: IE <=9 only\n// Panic based approach to setting things on disconnected nodes\nTween.propHooks.scrollTop = Tween.propHooks.scrollLeft = {\n\tset: function( tween ) {\n\t\tif ( tween.elem.nodeType && tween.elem.parentNode ) {\n\t\t\ttween.elem[ tween.prop ] = tween.now;\n\t\t}\n\t}\n};\n\njQuery.easing = {\n\tlinear: function( p ) {\n\t\treturn p;\n\t},\n\tswing: function( p ) {\n\t\treturn 0.5 - Math.cos( p * Math.PI ) / 2;\n\t},\n\t_default: \"swing\"\n};\n\njQuery.fx = Tween.prototype.init;\n\n// Back compat <1.8 extension point\njQuery.fx.step = {};\n\n\n\n\nvar\n\tfxNow, inProgress,\n\trfxtypes = /^(?:toggle|show|hide)$/,\n\trrun = /queueHooks$/;\n\nfunction schedule() {\n\tif ( inProgress ) {\n\t\tif ( document.hidden === false && window.requestAnimationFrame ) {\n\t\t\twindow.requestAnimationFrame( schedule );\n\t\t} else {\n\t\t\twindow.setTimeout( schedule, jQuery.fx.interval );\n\t\t}\n\n\t\tjQuery.fx.tick();\n\t}\n}\n\n// Animations created synchronously will run synchronously\nfunction createFxNow() {\n\twindow.setTimeout( function() {\n\t\tfxNow = undefined;\n\t} );\n\treturn ( fxNow = Date.now() );\n}\n\n// Generate parameters to create a standard animation\nfunction genFx( type, includeWidth ) {\n\tvar which,\n\t\ti = 0,\n\t\tattrs = { height: type };\n\n\t// If we include width, step value is 1 to do all cssExpand values,\n\t// otherwise step value is 2 to skip over Left and Right\n\tincludeWidth = includeWidth ? 1 : 0;\n\tfor ( ; i < 4; i += 2 - includeWidth ) {\n\t\twhich = cssExpand[ i ];\n\t\tattrs[ \"margin\" + which ] = attrs[ \"padding\" + which ] = type;\n\t}\n\n\tif ( includeWidth ) {\n\t\tattrs.opacity = attrs.width = type;\n\t}\n\n\treturn attrs;\n}\n\nfunction createTween( value, prop, animation ) {\n\tvar tween,\n\t\tcollection = ( Animation.tweeners[ prop ] || [] ).concat( Animation.tweeners[ \"*\" ] ),\n\t\tindex = 0,\n\t\tlength = collection.length;\n\tfor ( ; index < length; index++ ) {\n\t\tif ( ( tween = collection[ index ].call( animation, prop, value ) ) ) {\n\n\t\t\t// We're done with this property\n\t\t\treturn tween;\n\t\t}\n\t}\n}\n\nfunction defaultPrefilter( elem, props, opts ) {\n\tvar prop, value, toggle, hooks, oldfire, propTween, restoreDisplay, display,\n\t\tisBox = \"width\" in props || \"height\" in props,\n\t\tanim = this,\n\t\torig = {},\n\t\tstyle = elem.style,\n\t\thidden = elem.nodeType && isHiddenWithinTree( elem ),\n\t\tdataShow = dataPriv.get( elem, \"fxshow\" );\n\n\t// Queue-skipping animations hijack the fx hooks\n\tif ( !opts.queue ) {\n\t\thooks = jQuery._queueHooks( elem, \"fx\" );\n\t\tif ( hooks.unqueued == null ) {\n\t\t\thooks.unqueued = 0;\n\t\t\toldfire = hooks.empty.fire;\n\t\t\thooks.empty.fire = function() {\n\t\t\t\tif ( !hooks.unqueued ) {\n\t\t\t\t\toldfire();\n\t\t\t\t}\n\t\t\t};\n\t\t}\n\t\thooks.unqueued++;\n\n\t\tanim.always( function() {\n\n\t\t\t// Ensure the complete handler is called before this completes\n\t\t\tanim.always( function() {\n\t\t\t\thooks.unqueued--;\n\t\t\t\tif ( !jQuery.queue( elem, \"fx\" ).length ) {\n\t\t\t\t\thooks.empty.fire();\n\t\t\t\t}\n\t\t\t} );\n\t\t} );\n\t}\n\n\t// Detect show/hide animations\n\tfor ( prop in props ) {\n\t\tvalue = props[ prop ];\n\t\tif ( rfxtypes.test( value ) ) {\n\t\t\tdelete props[ prop ];\n\t\t\ttoggle = toggle || value === \"toggle\";\n\t\t\tif ( value === ( hidden ? \"hide\" : \"show\" ) ) {\n\n\t\t\t\t// Pretend to be hidden if this is a \"show\" and\n\t\t\t\t// there is still data from a stopped show/hide\n\t\t\t\tif ( value === \"show\" && dataShow && dataShow[ prop ] !== undefined ) {\n\t\t\t\t\thidden = true;\n\n\t\t\t\t// Ignore all other no-op show/hide data\n\t\t\t\t} else {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\t\t\torig[ prop ] = dataShow && dataShow[ prop ] || jQuery.style( elem, prop );\n\t\t}\n\t}\n\n\t// Bail out if this is a no-op like .hide().hide()\n\tpropTween = !jQuery.isEmptyObject( props );\n\tif ( !propTween && jQuery.isEmptyObject( orig ) ) {\n\t\treturn;\n\t}\n\n\t// Restrict \"overflow\" and \"display\" styles during box animations\n\tif ( isBox && elem.nodeType === 1 ) {\n\n\t\t// Support: IE <=9 - 11, Edge 12 - 15\n\t\t// Record all 3 overflow attributes because IE does not infer the shorthand\n\t\t// from identically-valued overflowX and overflowY and Edge just mirrors\n\t\t// the overflowX value there.\n\t\topts.overflow = [ style.overflow, style.overflowX, style.overflowY ];\n\n\t\t// Identify a display type, preferring old show/hide data over the CSS cascade\n\t\trestoreDisplay = dataShow && dataShow.display;\n\t\tif ( restoreDisplay == null ) {\n\t\t\trestoreDisplay = dataPriv.get( elem, \"display\" );\n\t\t}\n\t\tdisplay = jQuery.css( elem, \"display\" );\n\t\tif ( display === \"none\" ) {\n\t\t\tif ( restoreDisplay ) {\n\t\t\t\tdisplay = restoreDisplay;\n\t\t\t} else {\n\n\t\t\t\t// Get nonempty value(s) by temporarily forcing visibility\n\t\t\t\tshowHide( [ elem ], true );\n\t\t\t\trestoreDisplay = elem.style.display || restoreDisplay;\n\t\t\t\tdisplay = jQuery.css( elem, \"display\" );\n\t\t\t\tshowHide( [ elem ] );\n\t\t\t}\n\t\t}\n\n\t\t// Animate inline elements as inline-block\n\t\tif ( display === \"inline\" || display === \"inline-block\" && restoreDisplay != null ) {\n\t\t\tif ( jQuery.css( elem, \"float\" ) === \"none\" ) {\n\n\t\t\t\t// Restore the original display value at the end of pure show/hide animations\n\t\t\t\tif ( !propTween ) {\n\t\t\t\t\tanim.done( function() {\n\t\t\t\t\t\tstyle.display = restoreDisplay;\n\t\t\t\t\t} );\n\t\t\t\t\tif ( restoreDisplay == null ) {\n\t\t\t\t\t\tdisplay = style.display;\n\t\t\t\t\t\trestoreDisplay = display === \"none\" ? \"\" : display;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tstyle.display = \"inline-block\";\n\t\t\t}\n\t\t}\n\t}\n\n\tif ( opts.overflow ) {\n\t\tstyle.overflow = \"hidden\";\n\t\tanim.always( function() {\n\t\t\tstyle.overflow = opts.overflow[ 0 ];\n\t\t\tstyle.overflowX = opts.overflow[ 1 ];\n\t\t\tstyle.overflowY = opts.overflow[ 2 ];\n\t\t} );\n\t}\n\n\t// Implement show/hide animations\n\tpropTween = false;\n\tfor ( prop in orig ) {\n\n\t\t// General show/hide setup for this element animation\n\t\tif ( !propTween ) {\n\t\t\tif ( dataShow ) {\n\t\t\t\tif ( \"hidden\" in dataShow ) {\n\t\t\t\t\thidden = dataShow.hidden;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tdataShow = dataPriv.access( elem, \"fxshow\", { display: restoreDisplay } );\n\t\t\t}\n\n\t\t\t// Store hidden/visible for toggle so `.stop().toggle()` \"reverses\"\n\t\t\tif ( toggle ) {\n\t\t\t\tdataShow.hidden = !hidden;\n\t\t\t}\n\n\t\t\t// Show elements before animating them\n\t\t\tif ( hidden ) {\n\t\t\t\tshowHide( [ elem ], true );\n\t\t\t}\n\n\t\t\t/* eslint-disable no-loop-func */\n\n\t\t\tanim.done( function() {\n\n\t\t\t/* eslint-enable no-loop-func */\n\n\t\t\t\t// The final step of a \"hide\" animation is actually hiding the element\n\t\t\t\tif ( !hidden ) {\n\t\t\t\t\tshowHide( [ elem ] );\n\t\t\t\t}\n\t\t\t\tdataPriv.remove( elem, \"fxshow\" );\n\t\t\t\tfor ( prop in orig ) {\n\t\t\t\t\tjQuery.style( elem, prop, orig[ prop ] );\n\t\t\t\t}\n\t\t\t} );\n\t\t}\n\n\t\t// Per-property setup\n\t\tpropTween = createTween( hidden ? dataShow[ prop ] : 0, prop, anim );\n\t\tif ( !( prop in dataShow ) ) {\n\t\t\tdataShow[ prop ] = propTween.start;\n\t\t\tif ( hidden ) {\n\t\t\t\tpropTween.end = propTween.start;\n\t\t\t\tpropTween.start = 0;\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunction propFilter( props, specialEasing ) {\n\tvar index, name, easing, value, hooks;\n\n\t// camelCase, specialEasing and expand cssHook pass\n\tfor ( index in props ) {\n\t\tname = camelCase( index );\n\t\teasing = specialEasing[ name ];\n\t\tvalue = props[ index ];\n\t\tif ( Array.isArray( value ) ) {\n\t\t\teasing = value[ 1 ];\n\t\t\tvalue = props[ index ] = value[ 0 ];\n\t\t}\n\n\t\tif ( index !== name ) {\n\t\t\tprops[ name ] = value;\n\t\t\tdelete props[ index ];\n\t\t}\n\n\t\thooks = jQuery.cssHooks[ name ];\n\t\tif ( hooks && \"expand\" in hooks ) {\n\t\t\tvalue = hooks.expand( value );\n\t\t\tdelete props[ name ];\n\n\t\t\t// Not quite $.extend, this won't overwrite existing keys.\n\t\t\t// Reusing 'index' because we have the correct \"name\"\n\t\t\tfor ( index in value ) {\n\t\t\t\tif ( !( index in props ) ) {\n\t\t\t\t\tprops[ index ] = value[ index ];\n\t\t\t\t\tspecialEasing[ index ] = easing;\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tspecialEasing[ name ] = easing;\n\t\t}\n\t}\n}\n\nfunction Animation( elem, properties, options ) {\n\tvar result,\n\t\tstopped,\n\t\tindex = 0,\n\t\tlength = Animation.prefilters.length,\n\t\tdeferred = jQuery.Deferred().always( function() {\n\n\t\t\t// Don't match elem in the :animated selector\n\t\t\tdelete tick.elem;\n\t\t} ),\n\t\ttick = function() {\n\t\t\tif ( stopped ) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tvar currentTime = fxNow || createFxNow(),\n\t\t\t\tremaining = Math.max( 0, animation.startTime + animation.duration - currentTime ),\n\n\t\t\t\t// Support: Android 2.3 only\n\t\t\t\t// Archaic crash bug won't allow us to use `1 - ( 0.5 || 0 )` (#12497)\n\t\t\t\ttemp = remaining / animation.duration || 0,\n\t\t\t\tpercent = 1 - temp,\n\t\t\t\tindex = 0,\n\t\t\t\tlength = animation.tweens.length;\n\n\t\t\tfor ( ; index < length; index++ ) {\n\t\t\t\tanimation.tweens[ index ].run( percent );\n\t\t\t}\n\n\t\t\tdeferred.notifyWith( elem, [ animation, percent, remaining ] );\n\n\t\t\t// If there's more to do, yield\n\t\t\tif ( percent < 1 && length ) {\n\t\t\t\treturn remaining;\n\t\t\t}\n\n\t\t\t// If this was an empty animation, synthesize a final progress notification\n\t\t\tif ( !length ) {\n\t\t\t\tdeferred.notifyWith( elem, [ animation, 1, 0 ] );\n\t\t\t}\n\n\t\t\t// Resolve the animation and report its conclusion\n\t\t\tdeferred.resolveWith( elem, [ animation ] );\n\t\t\treturn false;\n\t\t},\n\t\tanimation = deferred.promise( {\n\t\t\telem: elem,\n\t\t\tprops: jQuery.extend( {}, properties ),\n\t\t\topts: jQuery.extend( true, {\n\t\t\t\tspecialEasing: {},\n\t\t\t\teasing: jQuery.easing._default\n\t\t\t}, options ),\n\t\t\toriginalProperties: properties,\n\t\t\toriginalOptions: options,\n\t\t\tstartTime: fxNow || createFxNow(),\n\t\t\tduration: options.duration,\n\t\t\ttweens: [],\n\t\t\tcreateTween: function( prop, end ) {\n\t\t\t\tvar tween = jQuery.Tween( elem, animation.opts, prop, end,\n\t\t\t\t\t\tanimation.opts.specialEasing[ prop ] || animation.opts.easing );\n\t\t\t\tanimation.tweens.push( tween );\n\t\t\t\treturn tween;\n\t\t\t},\n\t\t\tstop: function( gotoEnd ) {\n\t\t\t\tvar index = 0,\n\n\t\t\t\t\t// If we are going to the end, we want to run all the tweens\n\t\t\t\t\t// otherwise we skip this part\n\t\t\t\t\tlength = gotoEnd ? animation.tweens.length : 0;\n\t\t\t\tif ( stopped ) {\n\t\t\t\t\treturn this;\n\t\t\t\t}\n\t\t\t\tstopped = true;\n\t\t\t\tfor ( ; index < length; index++ ) {\n\t\t\t\t\tanimation.tweens[ index ].run( 1 );\n\t\t\t\t}\n\n\t\t\t\t// Resolve when we played the last frame; otherwise, reject\n\t\t\t\tif ( gotoEnd ) {\n\t\t\t\t\tdeferred.notifyWith( elem, [ animation, 1, 0 ] );\n\t\t\t\t\tdeferred.resolveWith( elem, [ animation, gotoEnd ] );\n\t\t\t\t} else {\n\t\t\t\t\tdeferred.rejectWith( elem, [ animation, gotoEnd ] );\n\t\t\t\t}\n\t\t\t\treturn this;\n\t\t\t}\n\t\t} ),\n\t\tprops = animation.props;\n\n\tpropFilter( props, animation.opts.specialEasing );\n\n\tfor ( ; index < length; index++ ) {\n\t\tresult = Animation.prefilters[ index ].call( animation, elem, props, animation.opts );\n\t\tif ( result ) {\n\t\t\tif ( isFunction( result.stop ) ) {\n\t\t\t\tjQuery._queueHooks( animation.elem, animation.opts.queue ).stop =\n\t\t\t\t\tresult.stop.bind( result );\n\t\t\t}\n\t\t\treturn result;\n\t\t}\n\t}\n\n\tjQuery.map( props, createTween, animation );\n\n\tif ( isFunction( animation.opts.start ) ) {\n\t\tanimation.opts.start.call( elem, animation );\n\t}\n\n\t// Attach callbacks from options\n\tanimation\n\t\t.progress( animation.opts.progress )\n\t\t.done( animation.opts.done, animation.opts.complete )\n\t\t.fail( animation.opts.fail )\n\t\t.always( animation.opts.always );\n\n\tjQuery.fx.timer(\n\t\tjQuery.extend( tick, {\n\t\t\telem: elem,\n\t\t\tanim: animation,\n\t\t\tqueue: animation.opts.queue\n\t\t} )\n\t);\n\n\treturn animation;\n}\n\njQuery.Animation = jQuery.extend( Animation, {\n\n\ttweeners: {\n\t\t\"*\": [ function( prop, value ) {\n\t\t\tvar tween = this.createTween( prop, value );\n\t\t\tadjustCSS( tween.elem, prop, rcssNum.exec( value ), tween );\n\t\t\treturn tween;\n\t\t} ]\n\t},\n\n\ttweener: function( props, callback ) {\n\t\tif ( isFunction( props ) ) {\n\t\t\tcallback = props;\n\t\t\tprops = [ \"*\" ];\n\t\t} else {\n\t\t\tprops = props.match( rnothtmlwhite );\n\t\t}\n\n\t\tvar prop,\n\t\t\tindex = 0,\n\t\t\tlength = props.length;\n\n\t\tfor ( ; index < length; index++ ) {\n\t\t\tprop = props[ index ];\n\t\t\tAnimation.tweeners[ prop ] = Animation.tweeners[ prop ] || [];\n\t\t\tAnimation.tweeners[ prop ].unshift( callback );\n\t\t}\n\t},\n\n\tprefilters: [ defaultPrefilter ],\n\n\tprefilter: function( callback, prepend ) {\n\t\tif ( prepend ) {\n\t\t\tAnimation.prefilters.unshift( callback );\n\t\t} else {\n\t\t\tAnimation.prefilters.push( callback );\n\t\t}\n\t}\n} );\n\njQuery.speed = function( speed, easing, fn ) {\n\tvar opt = speed && typeof speed === \"object\" ? jQuery.extend( {}, speed ) : {\n\t\tcomplete: fn || !fn && easing ||\n\t\t\tisFunction( speed ) && speed,\n\t\tduration: speed,\n\t\teasing: fn && easing || easing && !isFunction( easing ) && easing\n\t};\n\n\t// Go to the end state if fx are off\n\tif ( jQuery.fx.off ) {\n\t\topt.duration = 0;\n\n\t} else {\n\t\tif ( typeof opt.duration !== \"number\" ) {\n\t\t\tif ( opt.duration in jQuery.fx.speeds ) {\n\t\t\t\topt.duration = jQuery.fx.speeds[ opt.duration ];\n\n\t\t\t} else {\n\t\t\t\topt.duration = jQuery.fx.speeds._default;\n\t\t\t}\n\t\t}\n\t}\n\n\t// Normalize opt.queue - true/undefined/null -> \"fx\"\n\tif ( opt.queue == null || opt.queue === true ) {\n\t\topt.queue = \"fx\";\n\t}\n\n\t// Queueing\n\topt.old = opt.complete;\n\n\topt.complete = function() {\n\t\tif ( isFunction( opt.old ) ) {\n\t\t\topt.old.call( this );\n\t\t}\n\n\t\tif ( opt.queue ) {\n\t\t\tjQuery.dequeue( this, opt.queue );\n\t\t}\n\t};\n\n\treturn opt;\n};\n\njQuery.fn.extend( {\n\tfadeTo: function( speed, to, easing, callback ) {\n\n\t\t// Show any hidden elements after setting opacity to 0\n\t\treturn this.filter( isHiddenWithinTree ).css( \"opacity\", 0 ).show()\n\n\t\t\t// Animate to the value specified\n\t\t\t.end().animate( { opacity: to }, speed, easing, callback );\n\t},\n\tanimate: function( prop, speed, easing, callback ) {\n\t\tvar empty = jQuery.isEmptyObject( prop ),\n\t\t\toptall = jQuery.speed( speed, easing, callback ),\n\t\t\tdoAnimation = function() {\n\n\t\t\t\t// Operate on a copy of prop so per-property easing won't be lost\n\t\t\t\tvar anim = Animation( this, jQuery.extend( {}, prop ), optall );\n\n\t\t\t\t// Empty animations, or finishing resolves immediately\n\t\t\t\tif ( empty || dataPriv.get( this, \"finish\" ) ) {\n\t\t\t\t\tanim.stop( true );\n\t\t\t\t}\n\t\t\t};\n\t\t\tdoAnimation.finish = doAnimation;\n\n\t\treturn empty || optall.queue === false ?\n\t\t\tthis.each( doAnimation ) :\n\t\t\tthis.queue( optall.queue, doAnimation );\n\t},\n\tstop: function( type, clearQueue, gotoEnd ) {\n\t\tvar stopQueue = function( hooks ) {\n\t\t\tvar stop = hooks.stop;\n\t\t\tdelete hooks.stop;\n\t\t\tstop( gotoEnd );\n\t\t};\n\n\t\tif ( typeof type !== \"string\" ) {\n\t\t\tgotoEnd = clearQueue;\n\t\t\tclearQueue = type;\n\t\t\ttype = undefined;\n\t\t}\n\t\tif ( clearQueue && type !== false ) {\n\t\t\tthis.queue( type || \"fx\", [] );\n\t\t}\n\n\t\treturn this.each( function() {\n\t\t\tvar dequeue = true,\n\t\t\t\tindex = type != null && type + \"queueHooks\",\n\t\t\t\ttimers = jQuery.timers,\n\t\t\t\tdata = dataPriv.get( this );\n\n\t\t\tif ( index ) {\n\t\t\t\tif ( data[ index ] && data[ index ].stop ) {\n\t\t\t\t\tstopQueue( data[ index ] );\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tfor ( index in data ) {\n\t\t\t\t\tif ( data[ index ] && data[ index ].stop && rrun.test( index ) ) {\n\t\t\t\t\t\tstopQueue( data[ index ] );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfor ( index = timers.length; index--; ) {\n\t\t\t\tif ( timers[ index ].elem === this &&\n\t\t\t\t\t( type == null || timers[ index ].queue === type ) ) {\n\n\t\t\t\t\ttimers[ index ].anim.stop( gotoEnd );\n\t\t\t\t\tdequeue = false;\n\t\t\t\t\ttimers.splice( index, 1 );\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Start the next in the queue if the last step wasn't forced.\n\t\t\t// Timers currently will call their complete callbacks, which\n\t\t\t// will dequeue but only if they were gotoEnd.\n\t\t\tif ( dequeue || !gotoEnd ) {\n\t\t\t\tjQuery.dequeue( this, type );\n\t\t\t}\n\t\t} );\n\t},\n\tfinish: function( type ) {\n\t\tif ( type !== false ) {\n\t\t\ttype = type || \"fx\";\n\t\t}\n\t\treturn this.each( function() {\n\t\t\tvar index,\n\t\t\t\tdata = dataPriv.get( this ),\n\t\t\t\tqueue = data[ type + \"queue\" ],\n\t\t\t\thooks = data[ type + \"queueHooks\" ],\n\t\t\t\ttimers = jQuery.timers,\n\t\t\t\tlength = queue ? queue.length : 0;\n\n\t\t\t// Enable finishing flag on private data\n\t\t\tdata.finish = true;\n\n\t\t\t// Empty the queue first\n\t\t\tjQuery.queue( this, type, [] );\n\n\t\t\tif ( hooks && hooks.stop ) {\n\t\t\t\thooks.stop.call( this, true );\n\t\t\t}\n\n\t\t\t// Look for any active animations, and finish them\n\t\t\tfor ( index = timers.length; index--; ) {\n\t\t\t\tif ( timers[ index ].elem === this && timers[ index ].queue === type ) {\n\t\t\t\t\ttimers[ index ].anim.stop( true );\n\t\t\t\t\ttimers.splice( index, 1 );\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Look for any animations in the old queue and finish them\n\t\t\tfor ( index = 0; index < length; index++ ) {\n\t\t\t\tif ( queue[ index ] && queue[ index ].finish ) {\n\t\t\t\t\tqueue[ index ].finish.call( this );\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Turn off finishing flag\n\t\t\tdelete data.finish;\n\t\t} );\n\t}\n} );\n\njQuery.each( [ \"toggle\", \"show\", \"hide\" ], function( i, name ) {\n\tvar cssFn = jQuery.fn[ name ];\n\tjQuery.fn[ name ] = function( speed, easing, callback ) {\n\t\treturn speed == null || typeof speed === \"boolean\" ?\n\t\t\tcssFn.apply( this, arguments ) :\n\t\t\tthis.animate( genFx( name, true ), speed, easing, callback );\n\t};\n} );\n\n// Generate shortcuts for custom animations\njQuery.each( {\n\tslideDown: genFx( \"show\" ),\n\tslideUp: genFx( \"hide\" ),\n\tslideToggle: genFx( \"toggle\" ),\n\tfadeIn: { opacity: \"show\" },\n\tfadeOut: { opacity: \"hide\" },\n\tfadeToggle: { opacity: \"toggle\" }\n}, function( name, props ) {\n\tjQuery.fn[ name ] = function( speed, easing, callback ) {\n\t\treturn this.animate( props, speed, easing, callback );\n\t};\n} );\n\njQuery.timers = [];\njQuery.fx.tick = function() {\n\tvar timer,\n\t\ti = 0,\n\t\ttimers = jQuery.timers;\n\n\tfxNow = Date.now();\n\n\tfor ( ; i < timers.length; i++ ) {\n\t\ttimer = timers[ i ];\n\n\t\t// Run the timer and safely remove it when done (allowing for external removal)\n\t\tif ( !timer() && timers[ i ] === timer ) {\n\t\t\ttimers.splice( i--, 1 );\n\t\t}\n\t}\n\n\tif ( !timers.length ) {\n\t\tjQuery.fx.stop();\n\t}\n\tfxNow = undefined;\n};\n\njQuery.fx.timer = function( timer ) {\n\tjQuery.timers.push( timer );\n\tjQuery.fx.start();\n};\n\njQuery.fx.interval = 13;\njQuery.fx.start = function() {\n\tif ( inProgress ) {\n\t\treturn;\n\t}\n\n\tinProgress = true;\n\tschedule();\n};\n\njQuery.fx.stop = function() {\n\tinProgress = null;\n};\n\njQuery.fx.speeds = {\n\tslow: 600,\n\tfast: 200,\n\n\t// Default speed\n\t_default: 400\n};\n\n\n// Based off of the plugin by Clint Helfers, with permission.\n// https://web.archive.org/web/20100324014747/http://blindsignals.com/index.php/2009/07/jquery-delay/\njQuery.fn.delay = function( time, type ) {\n\ttime = jQuery.fx ? jQuery.fx.speeds[ time ] || time : time;\n\ttype = type || \"fx\";\n\n\treturn this.queue( type, function( next, hooks ) {\n\t\tvar timeout = window.setTimeout( next, time );\n\t\thooks.stop = function() {\n\t\t\twindow.clearTimeout( timeout );\n\t\t};\n\t} );\n};\n\n\n( function() {\n\tvar input = document.createElement( \"input\" ),\n\t\tselect = document.createElement( \"select\" ),\n\t\topt = select.appendChild( document.createElement( \"option\" ) );\n\n\tinput.type = \"checkbox\";\n\n\t// Support: Android <=4.3 only\n\t// Default value for a checkbox should be \"on\"\n\tsupport.checkOn = input.value !== \"\";\n\n\t// Support: IE <=11 only\n\t// Must access selectedIndex to make default options select\n\tsupport.optSelected = opt.selected;\n\n\t// Support: IE <=11 only\n\t// An input loses its value after becoming a radio\n\tinput = document.createElement( \"input\" );\n\tinput.value = \"t\";\n\tinput.type = \"radio\";\n\tsupport.radioValue = input.value === \"t\";\n} )();\n\n\nvar boolHook,\n\tattrHandle = jQuery.expr.attrHandle;\n\njQuery.fn.extend( {\n\tattr: function( name, value ) {\n\t\treturn access( this, jQuery.attr, name, value, arguments.length > 1 );\n\t},\n\n\tremoveAttr: function( name ) {\n\t\treturn this.each( function() {\n\t\t\tjQuery.removeAttr( this, name );\n\t\t} );\n\t}\n} );\n\njQuery.extend( {\n\tattr: function( elem, name, value ) {\n\t\tvar ret, hooks,\n\t\t\tnType = elem.nodeType;\n\n\t\t// Don't get/set attributes on text, comment and attribute nodes\n\t\tif ( nType === 3 || nType === 8 || nType === 2 ) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Fallback to prop when attributes are not supported\n\t\tif ( typeof elem.getAttribute === \"undefined\" ) {\n\t\t\treturn jQuery.prop( elem, name, value );\n\t\t}\n\n\t\t// Attribute hooks are determined by the lowercase version\n\t\t// Grab necessary hook if one is defined\n\t\tif ( nType !== 1 || !jQuery.isXMLDoc( elem ) ) {\n\t\t\thooks = jQuery.attrHooks[ name.toLowerCase() ] ||\n\t\t\t\t( jQuery.expr.match.bool.test( name ) ? boolHook : undefined );\n\t\t}\n\n\t\tif ( value !== undefined ) {\n\t\t\tif ( value === null ) {\n\t\t\t\tjQuery.removeAttr( elem, name );\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif ( hooks && \"set\" in hooks &&\n\t\t\t\t( ret = hooks.set( elem, value, name ) ) !== undefined ) {\n\t\t\t\treturn ret;\n\t\t\t}\n\n\t\t\telem.setAttribute( name, value + \"\" );\n\t\t\treturn value;\n\t\t}\n\n\t\tif ( hooks && \"get\" in hooks && ( ret = hooks.get( elem, name ) ) !== null ) {\n\t\t\treturn ret;\n\t\t}\n\n\t\tret = jQuery.find.attr( elem, name );\n\n\t\t// Non-existent attributes return null, we normalize to undefined\n\t\treturn ret == null ? undefined : ret;\n\t},\n\n\tattrHooks: {\n\t\ttype: {\n\t\t\tset: function( elem, value ) {\n\t\t\t\tif ( !support.radioValue && value === \"radio\" &&\n\t\t\t\t\tnodeName( elem, \"input\" ) ) {\n\t\t\t\t\tvar val = elem.value;\n\t\t\t\t\telem.setAttribute( \"type\", value );\n\t\t\t\t\tif ( val ) {\n\t\t\t\t\t\telem.value = val;\n\t\t\t\t\t}\n\t\t\t\t\treturn value;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t},\n\n\tremoveAttr: function( elem, value ) {\n\t\tvar name,\n\t\t\ti = 0,\n\n\t\t\t// Attribute names can contain non-HTML whitespace characters\n\t\t\t// https://html.spec.whatwg.org/multipage/syntax.html#attributes-2\n\t\t\tattrNames = value && value.match( rnothtmlwhite );\n\n\t\tif ( attrNames && elem.nodeType === 1 ) {\n\t\t\twhile ( ( name = attrNames[ i++ ] ) ) {\n\t\t\t\telem.removeAttribute( name );\n\t\t\t}\n\t\t}\n\t}\n} );\n\n// Hooks for boolean attributes\nboolHook = {\n\tset: function( elem, value, name ) {\n\t\tif ( value === false ) {\n\n\t\t\t// Remove boolean attributes when set to false\n\t\t\tjQuery.removeAttr( elem, name );\n\t\t} else {\n\t\t\telem.setAttribute( name, name );\n\t\t}\n\t\treturn name;\n\t}\n};\n\njQuery.each( jQuery.expr.match.bool.source.match( /\\w+/g ), function( i, name ) {\n\tvar getter = attrHandle[ name ] || jQuery.find.attr;\n\n\tattrHandle[ name ] = function( elem, name, isXML ) {\n\t\tvar ret, handle,\n\t\t\tlowercaseName = name.toLowerCase();\n\n\t\tif ( !isXML ) {\n\n\t\t\t// Avoid an infinite loop by temporarily removing this function from the getter\n\t\t\thandle = attrHandle[ lowercaseName ];\n\t\t\tattrHandle[ lowercaseName ] = ret;\n\t\t\tret = getter( elem, name, isXML ) != null ?\n\t\t\t\tlowercaseName :\n\t\t\t\tnull;\n\t\t\tattrHandle[ lowercaseName ] = handle;\n\t\t}\n\t\treturn ret;\n\t};\n} );\n\n\n\n\nvar rfocusable = /^(?:input|select|textarea|button)$/i,\n\trclickable = /^(?:a|area)$/i;\n\njQuery.fn.extend( {\n\tprop: function( name, value ) {\n\t\treturn access( this, jQuery.prop, name, value, arguments.length > 1 );\n\t},\n\n\tremoveProp: function( name ) {\n\t\treturn this.each( function() {\n\t\t\tdelete this[ jQuery.propFix[ name ] || name ];\n\t\t} );\n\t}\n} );\n\njQuery.extend( {\n\tprop: function( elem, name, value ) {\n\t\tvar ret, hooks,\n\t\t\tnType = elem.nodeType;\n\n\t\t// Don't get/set properties on text, comment and attribute nodes\n\t\tif ( nType === 3 || nType === 8 || nType === 2 ) {\n\t\t\treturn;\n\t\t}\n\n\t\tif ( nType !== 1 || !jQuery.isXMLDoc( elem ) ) {\n\n\t\t\t// Fix name and attach hooks\n\t\t\tname = jQuery.propFix[ name ] || name;\n\t\t\thooks = jQuery.propHooks[ name ];\n\t\t}\n\n\t\tif ( value !== undefined ) {\n\t\t\tif ( hooks && \"set\" in hooks &&\n\t\t\t\t( ret = hooks.set( elem, value, name ) ) !== undefined ) {\n\t\t\t\treturn ret;\n\t\t\t}\n\n\t\t\treturn ( elem[ name ] = value );\n\t\t}\n\n\t\tif ( hooks && \"get\" in hooks && ( ret = hooks.get( elem, name ) ) !== null ) {\n\t\t\treturn ret;\n\t\t}\n\n\t\treturn elem[ name ];\n\t},\n\n\tpropHooks: {\n\t\ttabIndex: {\n\t\t\tget: function( elem ) {\n\n\t\t\t\t// Support: IE <=9 - 11 only\n\t\t\t\t// elem.tabIndex doesn't always return the\n\t\t\t\t// correct value when it hasn't been explicitly set\n\t\t\t\t// https://web.archive.org/web/20141116233347/http://fluidproject.org/blog/2008/01/09/getting-setting-and-removing-tabindex-values-with-javascript/\n\t\t\t\t// Use proper attribute retrieval(#12072)\n\t\t\t\tvar tabindex = jQuery.find.attr( elem, \"tabindex\" );\n\n\t\t\t\tif ( tabindex ) {\n\t\t\t\t\treturn parseInt( tabindex, 10 );\n\t\t\t\t}\n\n\t\t\t\tif (\n\t\t\t\t\trfocusable.test( elem.nodeName ) ||\n\t\t\t\t\trclickable.test( elem.nodeName ) &&\n\t\t\t\t\telem.href\n\t\t\t\t) {\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\t},\n\n\tpropFix: {\n\t\t\"for\": \"htmlFor\",\n\t\t\"class\": \"className\"\n\t}\n} );\n\n// Support: IE <=11 only\n// Accessing the selectedIndex property\n// forces the browser to respect setting selected\n// on the option\n// The getter ensures a default option is selected\n// when in an optgroup\n// eslint rule \"no-unused-expressions\" is disabled for this code\n// since it considers such accessions noop\nif ( !support.optSelected ) {\n\tjQuery.propHooks.selected = {\n\t\tget: function( elem ) {\n\n\t\t\t/* eslint no-unused-expressions: \"off\" */\n\n\t\t\tvar parent = elem.parentNode;\n\t\t\tif ( parent && parent.parentNode ) {\n\t\t\t\tparent.parentNode.selectedIndex;\n\t\t\t}\n\t\t\treturn null;\n\t\t},\n\t\tset: function( elem ) {\n\n\t\t\t/* eslint no-unused-expressions: \"off\" */\n\n\t\t\tvar parent = elem.parentNode;\n\t\t\tif ( parent ) {\n\t\t\t\tparent.selectedIndex;\n\n\t\t\t\tif ( parent.parentNode ) {\n\t\t\t\t\tparent.parentNode.selectedIndex;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t};\n}\n\njQuery.each( [\n\t\"tabIndex\",\n\t\"readOnly\",\n\t\"maxLength\",\n\t\"cellSpacing\",\n\t\"cellPadding\",\n\t\"rowSpan\",\n\t\"colSpan\",\n\t\"useMap\",\n\t\"frameBorder\",\n\t\"contentEditable\"\n], function() {\n\tjQuery.propFix[ this.toLowerCase() ] = this;\n} );\n\n\n\n\n\t// Strip and collapse whitespace according to HTML spec\n\t// https://infra.spec.whatwg.org/#strip-and-collapse-ascii-whitespace\n\tfunction stripAndCollapse( value ) {\n\t\tvar tokens = value.match( rnothtmlwhite ) || [];\n\t\treturn tokens.join( \" \" );\n\t}\n\n\nfunction getClass( elem ) {\n\treturn elem.getAttribute && elem.getAttribute( \"class\" ) || \"\";\n}\n\nfunction classesToArray( value ) {\n\tif ( Array.isArray( value ) ) {\n\t\treturn value;\n\t}\n\tif ( typeof value === \"string\" ) {\n\t\treturn value.match( rnothtmlwhite ) || [];\n\t}\n\treturn [];\n}\n\njQuery.fn.extend( {\n\taddClass: function( value ) {\n\t\tvar classes, elem, cur, curValue, clazz, j, finalValue,\n\t\t\ti = 0;\n\n\t\tif ( isFunction( value ) ) {\n\t\t\treturn this.each( function( j ) {\n\t\t\t\tjQuery( this ).addClass( value.call( this, j, getClass( this ) ) );\n\t\t\t} );\n\t\t}\n\n\t\tclasses = classesToArray( value );\n\n\t\tif ( classes.length ) {\n\t\t\twhile ( ( elem = this[ i++ ] ) ) {\n\t\t\t\tcurValue = getClass( elem );\n\t\t\t\tcur = elem.nodeType === 1 && ( \" \" + stripAndCollapse( curValue ) + \" \" );\n\n\t\t\t\tif ( cur ) {\n\t\t\t\t\tj = 0;\n\t\t\t\t\twhile ( ( clazz = classes[ j++ ] ) ) {\n\t\t\t\t\t\tif ( cur.indexOf( \" \" + clazz + \" \" ) < 0 ) {\n\t\t\t\t\t\t\tcur += clazz + \" \";\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\t// Only assign if different to avoid unneeded rendering.\n\t\t\t\t\tfinalValue = stripAndCollapse( cur );\n\t\t\t\t\tif ( curValue !== finalValue ) {\n\t\t\t\t\t\telem.setAttribute( \"class\", finalValue );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn this;\n\t},\n\n\tremoveClass: function( value ) {\n\t\tvar classes, elem, cur, curValue, clazz, j, finalValue,\n\t\t\ti = 0;\n\n\t\tif ( isFunction( value ) ) {\n\t\t\treturn this.each( function( j ) {\n\t\t\t\tjQuery( this ).removeClass( value.call( this, j, getClass( this ) ) );\n\t\t\t} );\n\t\t}\n\n\t\tif ( !arguments.length ) {\n\t\t\treturn this.attr( \"class\", \"\" );\n\t\t}\n\n\t\tclasses = classesToArray( value );\n\n\t\tif ( classes.length ) {\n\t\t\twhile ( ( elem = this[ i++ ] ) ) {\n\t\t\t\tcurValue = getClass( elem );\n\n\t\t\t\t// This expression is here for better compressibility (see addClass)\n\t\t\t\tcur = elem.nodeType === 1 && ( \" \" + stripAndCollapse( curValue ) + \" \" );\n\n\t\t\t\tif ( cur ) {\n\t\t\t\t\tj = 0;\n\t\t\t\t\twhile ( ( clazz = classes[ j++ ] ) ) {\n\n\t\t\t\t\t\t// Remove *all* instances\n\t\t\t\t\t\twhile ( cur.indexOf( \" \" + clazz + \" \" ) > -1 ) {\n\t\t\t\t\t\t\tcur = cur.replace( \" \" + clazz + \" \", \" \" );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\t// Only assign if different to avoid unneeded rendering.\n\t\t\t\t\tfinalValue = stripAndCollapse( cur );\n\t\t\t\t\tif ( curValue !== finalValue ) {\n\t\t\t\t\t\telem.setAttribute( \"class\", finalValue );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn this;\n\t},\n\n\ttoggleClass: function( value, stateVal ) {\n\t\tvar type = typeof value,\n\t\t\tisValidValue = type === \"string\" || Array.isArray( value );\n\n\t\tif ( typeof stateVal === \"boolean\" && isValidValue ) {\n\t\t\treturn stateVal ? this.addClass( value ) : this.removeClass( value );\n\t\t}\n\n\t\tif ( isFunction( value ) ) {\n\t\t\treturn this.each( function( i ) {\n\t\t\t\tjQuery( this ).toggleClass(\n\t\t\t\t\tvalue.call( this, i, getClass( this ), stateVal ),\n\t\t\t\t\tstateVal\n\t\t\t\t);\n\t\t\t} );\n\t\t}\n\n\t\treturn this.each( function() {\n\t\t\tvar className, i, self, classNames;\n\n\t\t\tif ( isValidValue ) {\n\n\t\t\t\t// Toggle individual class names\n\t\t\t\ti = 0;\n\t\t\t\tself = jQuery( this );\n\t\t\t\tclassNames = classesToArray( value );\n\n\t\t\t\twhile ( ( className = classNames[ i++ ] ) ) {\n\n\t\t\t\t\t// Check each className given, space separated list\n\t\t\t\t\tif ( self.hasClass( className ) ) {\n\t\t\t\t\t\tself.removeClass( className );\n\t\t\t\t\t} else {\n\t\t\t\t\t\tself.addClass( className );\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t// Toggle whole class name\n\t\t\t} else if ( value === undefined || type === \"boolean\" ) {\n\t\t\t\tclassName = getClass( this );\n\t\t\t\tif ( className ) {\n\n\t\t\t\t\t// Store className if set\n\t\t\t\t\tdataPriv.set( this, \"__className__\", className );\n\t\t\t\t}\n\n\t\t\t\t// If the element has a class name or if we're passed `false`,\n\t\t\t\t// then remove the whole classname (if there was one, the above saved it).\n\t\t\t\t// Otherwise bring back whatever was previously saved (if anything),\n\t\t\t\t// falling back to the empty string if nothing was stored.\n\t\t\t\tif ( this.setAttribute ) {\n\t\t\t\t\tthis.setAttribute( \"class\",\n\t\t\t\t\t\tclassName || value === false ?\n\t\t\t\t\t\t\"\" :\n\t\t\t\t\t\tdataPriv.get( this, \"__className__\" ) || \"\"\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t}\n\t\t} );\n\t},\n\n\thasClass: function( selector ) {\n\t\tvar className, elem,\n\t\t\ti = 0;\n\n\t\tclassName = \" \" + selector + \" \";\n\t\twhile ( ( elem = this[ i++ ] ) ) {\n\t\t\tif ( elem.nodeType === 1 &&\n\t\t\t\t( \" \" + stripAndCollapse( getClass( elem ) ) + \" \" ).indexOf( className ) > -1 ) {\n\t\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\n\t\treturn false;\n\t}\n} );\n\n\n\n\nvar rreturn = /\\r/g;\n\njQuery.fn.extend( {\n\tval: function( value ) {\n\t\tvar hooks, ret, valueIsFunction,\n\t\t\telem = this[ 0 ];\n\n\t\tif ( !arguments.length ) {\n\t\t\tif ( elem ) {\n\t\t\t\thooks = jQuery.valHooks[ elem.type ] ||\n\t\t\t\t\tjQuery.valHooks[ elem.nodeName.toLowerCase() ];\n\n\t\t\t\tif ( hooks &&\n\t\t\t\t\t\"get\" in hooks &&\n\t\t\t\t\t( ret = hooks.get( elem, \"value\" ) ) !== undefined\n\t\t\t\t) {\n\t\t\t\t\treturn ret;\n\t\t\t\t}\n\n\t\t\t\tret = elem.value;\n\n\t\t\t\t// Handle most common string cases\n\t\t\t\tif ( typeof ret === \"string\" ) {\n\t\t\t\t\treturn ret.replace( rreturn, \"\" );\n\t\t\t\t}\n\n\t\t\t\t// Handle cases where value is null/undef or number\n\t\t\t\treturn ret == null ? \"\" : ret;\n\t\t\t}\n\n\t\t\treturn;\n\t\t}\n\n\t\tvalueIsFunction = isFunction( value );\n\n\t\treturn this.each( function( i ) {\n\t\t\tvar val;\n\n\t\t\tif ( this.nodeType !== 1 ) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif ( valueIsFunction ) {\n\t\t\t\tval = value.call( this, i, jQuery( this ).val() );\n\t\t\t} else {\n\t\t\t\tval = value;\n\t\t\t}\n\n\t\t\t// Treat null/undefined as \"\"; convert numbers to string\n\t\t\tif ( val == null ) {\n\t\t\t\tval = \"\";\n\n\t\t\t} else if ( typeof val === \"number\" ) {\n\t\t\t\tval += \"\";\n\n\t\t\t} else if ( Array.isArray( val ) ) {\n\t\t\t\tval = jQuery.map( val, function( value ) {\n\t\t\t\t\treturn value == null ? \"\" : value + \"\";\n\t\t\t\t} );\n\t\t\t}\n\n\t\t\thooks = jQuery.valHooks[ this.type ] || jQuery.valHooks[ this.nodeName.toLowerCase() ];\n\n\t\t\t// If set returns undefined, fall back to normal setting\n\t\t\tif ( !hooks || !( \"set\" in hooks ) || hooks.set( this, val, \"value\" ) === undefined ) {\n\t\t\t\tthis.value = val;\n\t\t\t}\n\t\t} );\n\t}\n} );\n\njQuery.extend( {\n\tvalHooks: {\n\t\toption: {\n\t\t\tget: function( elem ) {\n\n\t\t\t\tvar val = jQuery.find.attr( elem, \"value\" );\n\t\t\t\treturn val != null ?\n\t\t\t\t\tval :\n\n\t\t\t\t\t// Support: IE <=10 - 11 only\n\t\t\t\t\t// option.text throws exceptions (#14686, #14858)\n\t\t\t\t\t// Strip and collapse whitespace\n\t\t\t\t\t// https://html.spec.whatwg.org/#strip-and-collapse-whitespace\n\t\t\t\t\tstripAndCollapse( jQuery.text( elem ) );\n\t\t\t}\n\t\t},\n\t\tselect: {\n\t\t\tget: function( elem ) {\n\t\t\t\tvar value, option, i,\n\t\t\t\t\toptions = elem.options,\n\t\t\t\t\tindex = elem.selectedIndex,\n\t\t\t\t\tone = elem.type === \"select-one\",\n\t\t\t\t\tvalues = one ? null : [],\n\t\t\t\t\tmax = one ? index + 1 : options.length;\n\n\t\t\t\tif ( index < 0 ) {\n\t\t\t\t\ti = max;\n\n\t\t\t\t} else {\n\t\t\t\t\ti = one ? index : 0;\n\t\t\t\t}\n\n\t\t\t\t// Loop through all the selected options\n\t\t\t\tfor ( ; i < max; i++ ) {\n\t\t\t\t\toption = options[ i ];\n\n\t\t\t\t\t// Support: IE <=9 only\n\t\t\t\t\t// IE8-9 doesn't update selected after form reset (#2551)\n\t\t\t\t\tif ( ( option.selected || i === index ) &&\n\n\t\t\t\t\t\t\t// Don't return options that are disabled or in a disabled optgroup\n\t\t\t\t\t\t\t!option.disabled &&\n\t\t\t\t\t\t\t( !option.parentNode.disabled ||\n\t\t\t\t\t\t\t\t!nodeName( option.parentNode, \"optgroup\" ) ) ) {\n\n\t\t\t\t\t\t// Get the specific value for the option\n\t\t\t\t\t\tvalue = jQuery( option ).val();\n\n\t\t\t\t\t\t// We don't need an array for one selects\n\t\t\t\t\t\tif ( one ) {\n\t\t\t\t\t\t\treturn value;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// Multi-Selects return an array\n\t\t\t\t\t\tvalues.push( value );\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\treturn values;\n\t\t\t},\n\n\t\t\tset: function( elem, value ) {\n\t\t\t\tvar optionSet, option,\n\t\t\t\t\toptions = elem.options,\n\t\t\t\t\tvalues = jQuery.makeArray( value ),\n\t\t\t\t\ti = options.length;\n\n\t\t\t\twhile ( i-- ) {\n\t\t\t\t\toption = options[ i ];\n\n\t\t\t\t\t/* eslint-disable no-cond-assign */\n\n\t\t\t\t\tif ( option.selected =\n\t\t\t\t\t\tjQuery.inArray( jQuery.valHooks.option.get( option ), values ) > -1\n\t\t\t\t\t) {\n\t\t\t\t\t\toptionSet = true;\n\t\t\t\t\t}\n\n\t\t\t\t\t/* eslint-enable no-cond-assign */\n\t\t\t\t}\n\n\t\t\t\t// Force browsers to behave consistently when non-matching value is set\n\t\t\t\tif ( !optionSet ) {\n\t\t\t\t\telem.selectedIndex = -1;\n\t\t\t\t}\n\t\t\t\treturn values;\n\t\t\t}\n\t\t}\n\t}\n} );\n\n// Radios and checkboxes getter/setter\njQuery.each( [ \"radio\", \"checkbox\" ], function() {\n\tjQuery.valHooks[ this ] = {\n\t\tset: function( elem, value ) {\n\t\t\tif ( Array.isArray( value ) ) {\n\t\t\t\treturn ( elem.checked = jQuery.inArray( jQuery( elem ).val(), value ) > -1 );\n\t\t\t}\n\t\t}\n\t};\n\tif ( !support.checkOn ) {\n\t\tjQuery.valHooks[ this ].get = function( elem ) {\n\t\t\treturn elem.getAttribute( \"value\" ) === null ? \"on\" : elem.value;\n\t\t};\n\t}\n} );\n\n\n\n\n// Return jQuery for attributes-only inclusion\n\n\nsupport.focusin = \"onfocusin\" in window;\n\n\nvar rfocusMorph = /^(?:focusinfocus|focusoutblur)$/,\n\tstopPropagationCallback = function( e ) {\n\t\te.stopPropagation();\n\t};\n\njQuery.extend( jQuery.event, {\n\n\ttrigger: function( event, data, elem, onlyHandlers ) {\n\n\t\tvar i, cur, tmp, bubbleType, ontype, handle, special, lastElement,\n\t\t\teventPath = [ elem || document ],\n\t\t\ttype = hasOwn.call( event, \"type\" ) ? event.type : event,\n\t\t\tnamespaces = hasOwn.call( event, \"namespace\" ) ? event.namespace.split( \".\" ) : [];\n\n\t\tcur = lastElement = tmp = elem = elem || document;\n\n\t\t// Don't do events on text and comment nodes\n\t\tif ( elem.nodeType === 3 || elem.nodeType === 8 ) {\n\t\t\treturn;\n\t\t}\n\n\t\t// focus/blur morphs to focusin/out; ensure we're not firing them right now\n\t\tif ( rfocusMorph.test( type + jQuery.event.triggered ) ) {\n\t\t\treturn;\n\t\t}\n\n\t\tif ( type.indexOf( \".\" ) > -1 ) {\n\n\t\t\t// Namespaced trigger; create a regexp to match event type in handle()\n\t\t\tnamespaces = type.split( \".\" );\n\t\t\ttype = namespaces.shift();\n\t\t\tnamespaces.sort();\n\t\t}\n\t\tontype = type.indexOf( \":\" ) < 0 && \"on\" + type;\n\n\t\t// Caller can pass in a jQuery.Event object, Object, or just an event type string\n\t\tevent = event[ jQuery.expando ] ?\n\t\t\tevent :\n\t\t\tnew jQuery.Event( type, typeof event === \"object\" && event );\n\n\t\t// Trigger bitmask: & 1 for native handlers; & 2 for jQuery (always true)\n\t\tevent.isTrigger = onlyHandlers ? 2 : 3;\n\t\tevent.namespace = namespaces.join( \".\" );\n\t\tevent.rnamespace = event.namespace ?\n\t\t\tnew RegExp( \"(^|\\\\.)\" + namespaces.join( \"\\\\.(?:.*\\\\.|)\" ) + \"(\\\\.|$)\" ) :\n\t\t\tnull;\n\n\t\t// Clean up the event in case it is being reused\n\t\tevent.result = undefined;\n\t\tif ( !event.target ) {\n\t\t\tevent.target = elem;\n\t\t}\n\n\t\t// Clone any incoming data and prepend the event, creating the handler arg list\n\t\tdata = data == null ?\n\t\t\t[ event ] :\n\t\t\tjQuery.makeArray( data, [ event ] );\n\n\t\t// Allow special events to draw outside the lines\n\t\tspecial = jQuery.event.special[ type ] || {};\n\t\tif ( !onlyHandlers && special.trigger && special.trigger.apply( elem, data ) === false ) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Determine event propagation path in advance, per W3C events spec (#9951)\n\t\t// Bubble up to document, then to window; watch for a global ownerDocument var (#9724)\n\t\tif ( !onlyHandlers && !special.noBubble && !isWindow( elem ) ) {\n\n\t\t\tbubbleType = special.delegateType || type;\n\t\t\tif ( !rfocusMorph.test( bubbleType + type ) ) {\n\t\t\t\tcur = cur.parentNode;\n\t\t\t}\n\t\t\tfor ( ; cur; cur = cur.parentNode ) {\n\t\t\t\teventPath.push( cur );\n\t\t\t\ttmp = cur;\n\t\t\t}\n\n\t\t\t// Only add window if we got to document (e.g., not plain obj or detached DOM)\n\t\t\tif ( tmp === ( elem.ownerDocument || document ) ) {\n\t\t\t\teventPath.push( tmp.defaultView || tmp.parentWindow || window );\n\t\t\t}\n\t\t}\n\n\t\t// Fire handlers on the event path\n\t\ti = 0;\n\t\twhile ( ( cur = eventPath[ i++ ] ) && !event.isPropagationStopped() ) {\n\t\t\tlastElement = cur;\n\t\t\tevent.type = i > 1 ?\n\t\t\t\tbubbleType :\n\t\t\t\tspecial.bindType || type;\n\n\t\t\t// jQuery handler\n\t\t\thandle = ( dataPriv.get( cur, \"events\" ) || {} )[ event.type ] &&\n\t\t\t\tdataPriv.get( cur, \"handle\" );\n\t\t\tif ( handle ) {\n\t\t\t\thandle.apply( cur, data );\n\t\t\t}\n\n\t\t\t// Native handler\n\t\t\thandle = ontype && cur[ ontype ];\n\t\t\tif ( handle && handle.apply && acceptData( cur ) ) {\n\t\t\t\tevent.result = handle.apply( cur, data );\n\t\t\t\tif ( event.result === false ) {\n\t\t\t\t\tevent.preventDefault();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tevent.type = type;\n\n\t\t// If nobody prevented the default action, do it now\n\t\tif ( !onlyHandlers && !event.isDefaultPrevented() ) {\n\n\t\t\tif ( ( !special._default ||\n\t\t\t\tspecial._default.apply( eventPath.pop(), data ) === false ) &&\n\t\t\t\tacceptData( elem ) ) {\n\n\t\t\t\t// Call a native DOM method on the target with the same name as the event.\n\t\t\t\t// Don't do default actions on window, that's where global variables be (#6170)\n\t\t\t\tif ( ontype && isFunction( elem[ type ] ) && !isWindow( elem ) ) {\n\n\t\t\t\t\t// Don't re-trigger an onFOO event when we call its FOO() method\n\t\t\t\t\ttmp = elem[ ontype ];\n\n\t\t\t\t\tif ( tmp ) {\n\t\t\t\t\t\telem[ ontype ] = null;\n\t\t\t\t\t}\n\n\t\t\t\t\t// Prevent re-triggering of the same event, since we already bubbled it above\n\t\t\t\t\tjQuery.event.triggered = type;\n\n\t\t\t\t\tif ( event.isPropagationStopped() ) {\n\t\t\t\t\t\tlastElement.addEventListener( type, stopPropagationCallback );\n\t\t\t\t\t}\n\n\t\t\t\t\telem[ type ]();\n\n\t\t\t\t\tif ( event.isPropagationStopped() ) {\n\t\t\t\t\t\tlastElement.removeEventListener( type, stopPropagationCallback );\n\t\t\t\t\t}\n\n\t\t\t\t\tjQuery.event.triggered = undefined;\n\n\t\t\t\t\tif ( tmp ) {\n\t\t\t\t\t\telem[ ontype ] = tmp;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn event.result;\n\t},\n\n\t// Piggyback on a donor event to simulate a different one\n\t// Used only for `focus(in | out)` events\n\tsimulate: function( type, elem, event ) {\n\t\tvar e = jQuery.extend(\n\t\t\tnew jQuery.Event(),\n\t\t\tevent,\n\t\t\t{\n\t\t\t\ttype: type,\n\t\t\t\tisSimulated: true\n\t\t\t}\n\t\t);\n\n\t\tjQuery.event.trigger( e, null, elem );\n\t}\n\n} );\n\njQuery.fn.extend( {\n\n\ttrigger: function( type, data ) {\n\t\treturn this.each( function() {\n\t\t\tjQuery.event.trigger( type, data, this );\n\t\t} );\n\t},\n\ttriggerHandler: function( type, data ) {\n\t\tvar elem = this[ 0 ];\n\t\tif ( elem ) {\n\t\t\treturn jQuery.event.trigger( type, data, elem, true );\n\t\t}\n\t}\n} );\n\n\n// Support: Firefox <=44\n// Firefox doesn't have focus(in | out) events\n// Related ticket - https://bugzilla.mozilla.org/show_bug.cgi?id=687787\n//\n// Support: Chrome <=48 - 49, Safari <=9.0 - 9.1\n// focus(in | out) events fire after focus & blur events,\n// which is spec violation - http://www.w3.org/TR/DOM-Level-3-Events/#events-focusevent-event-order\n// Related ticket - https://bugs.chromium.org/p/chromium/issues/detail?id=449857\nif ( !support.focusin ) {\n\tjQuery.each( { focus: \"focusin\", blur: \"focusout\" }, function( orig, fix ) {\n\n\t\t// Attach a single capturing handler on the document while someone wants focusin/focusout\n\t\tvar handler = function( event ) {\n\t\t\tjQuery.event.simulate( fix, event.target, jQuery.event.fix( event ) );\n\t\t};\n\n\t\tjQuery.event.special[ fix ] = {\n\t\t\tsetup: function() {\n\t\t\t\tvar doc = this.ownerDocument || this,\n\t\t\t\t\tattaches = dataPriv.access( doc, fix );\n\n\t\t\t\tif ( !attaches ) {\n\t\t\t\t\tdoc.addEventListener( orig, handler, true );\n\t\t\t\t}\n\t\t\t\tdataPriv.access( doc, fix, ( attaches || 0 ) + 1 );\n\t\t\t},\n\t\t\tteardown: function() {\n\t\t\t\tvar doc = this.ownerDocument || this,\n\t\t\t\t\tattaches = dataPriv.access( doc, fix ) - 1;\n\n\t\t\t\tif ( !attaches ) {\n\t\t\t\t\tdoc.removeEventListener( orig, handler, true );\n\t\t\t\t\tdataPriv.remove( doc, fix );\n\n\t\t\t\t} else {\n\t\t\t\t\tdataPriv.access( doc, fix, attaches );\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t} );\n}\nvar location = window.location;\n\nvar nonce = Date.now();\n\nvar rquery = ( /\\?/ );\n\n\n\n// Cross-browser xml parsing\njQuery.parseXML = function( data ) {\n\tvar xml;\n\tif ( !data || typeof data !== \"string\" ) {\n\t\treturn null;\n\t}\n\n\t// Support: IE 9 - 11 only\n\t// IE throws on parseFromString with invalid input.\n\ttry {\n\t\txml = ( new window.DOMParser() ).parseFromString( data, \"text/xml\" );\n\t} catch ( e ) {\n\t\txml = undefined;\n\t}\n\n\tif ( !xml || xml.getElementsByTagName( \"parsererror\" ).length ) {\n\t\tjQuery.error( \"Invalid XML: \" + data );\n\t}\n\treturn xml;\n};\n\n\nvar\n\trbracket = /\\[\\]$/,\n\trCRLF = /\\r?\\n/g,\n\trsubmitterTypes = /^(?:submit|button|image|reset|file)$/i,\n\trsubmittable = /^(?:input|select|textarea|keygen)/i;\n\nfunction buildParams( prefix, obj, traditional, add ) {\n\tvar name;\n\n\tif ( Array.isArray( obj ) ) {\n\n\t\t// Serialize array item.\n\t\tjQuery.each( obj, function( i, v ) {\n\t\t\tif ( traditional || rbracket.test( prefix ) ) {\n\n\t\t\t\t// Treat each array item as a scalar.\n\t\t\t\tadd( prefix, v );\n\n\t\t\t} else {\n\n\t\t\t\t// Item is non-scalar (array or object), encode its numeric index.\n\t\t\t\tbuildParams(\n\t\t\t\t\tprefix + \"[\" + ( typeof v === \"object\" && v != null ? i : \"\" ) + \"]\",\n\t\t\t\t\tv,\n\t\t\t\t\ttraditional,\n\t\t\t\t\tadd\n\t\t\t\t);\n\t\t\t}\n\t\t} );\n\n\t} else if ( !traditional && toType( obj ) === \"object\" ) {\n\n\t\t// Serialize object item.\n\t\tfor ( name in obj ) {\n\t\t\tbuildParams( prefix + \"[\" + name + \"]\", obj[ name ], traditional, add );\n\t\t}\n\n\t} else {\n\n\t\t// Serialize scalar item.\n\t\tadd( prefix, obj );\n\t}\n}\n\n// Serialize an array of form elements or a set of\n// key/values into a query string\njQuery.param = function( a, traditional ) {\n\tvar prefix,\n\t\ts = [],\n\t\tadd = function( key, valueOrFunction ) {\n\n\t\t\t// If value is a function, invoke it and use its return value\n\t\t\tvar value = isFunction( valueOrFunction ) ?\n\t\t\t\tvalueOrFunction() :\n\t\t\t\tvalueOrFunction;\n\n\t\t\ts[ s.length ] = encodeURIComponent( key ) + \"=\" +\n\t\t\t\tencodeURIComponent( value == null ? \"\" : value );\n\t\t};\n\n\tif ( a == null ) {\n\t\treturn \"\";\n\t}\n\n\t// If an array was passed in, assume that it is an array of form elements.\n\tif ( Array.isArray( a ) || ( a.jquery && !jQuery.isPlainObject( a ) ) ) {\n\n\t\t// Serialize the form elements\n\t\tjQuery.each( a, function() {\n\t\t\tadd( this.name, this.value );\n\t\t} );\n\n\t} else {\n\n\t\t// If traditional, encode the \"old\" way (the way 1.3.2 or older\n\t\t// did it), otherwise encode params recursively.\n\t\tfor ( prefix in a ) {\n\t\t\tbuildParams( prefix, a[ prefix ], traditional, add );\n\t\t}\n\t}\n\n\t// Return the resulting serialization\n\treturn s.join( \"&\" );\n};\n\njQuery.fn.extend( {\n\tserialize: function() {\n\t\treturn jQuery.param( this.serializeArray() );\n\t},\n\tserializeArray: function() {\n\t\treturn this.map( function() {\n\n\t\t\t// Can add propHook for \"elements\" to filter or add form elements\n\t\t\tvar elements = jQuery.prop( this, \"elements\" );\n\t\t\treturn elements ? jQuery.makeArray( elements ) : this;\n\t\t} )\n\t\t.filter( function() {\n\t\t\tvar type = this.type;\n\n\t\t\t// Use .is( \":disabled\" ) so that fieldset[disabled] works\n\t\t\treturn this.name && !jQuery( this ).is( \":disabled\" ) &&\n\t\t\t\trsubmittable.test( this.nodeName ) && !rsubmitterTypes.test( type ) &&\n\t\t\t\t( this.checked || !rcheckableType.test( type ) );\n\t\t} )\n\t\t.map( function( i, elem ) {\n\t\t\tvar val = jQuery( this ).val();\n\n\t\t\tif ( val == null ) {\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\tif ( Array.isArray( val ) ) {\n\t\t\t\treturn jQuery.map( val, function( val ) {\n\t\t\t\t\treturn { name: elem.name, value: val.replace( rCRLF, \"\\r\\n\" ) };\n\t\t\t\t} );\n\t\t\t}\n\n\t\t\treturn { name: elem.name, value: val.replace( rCRLF, \"\\r\\n\" ) };\n\t\t} ).get();\n\t}\n} );\n\n\nvar\n\tr20 = /%20/g,\n\trhash = /#.*$/,\n\trantiCache = /([?&])_=[^&]*/,\n\trheaders = /^(.*?):[ \\t]*([^\\r\\n]*)$/mg,\n\n\t// #7653, #8125, #8152: local protocol detection\n\trlocalProtocol = /^(?:about|app|app-storage|.+-extension|file|res|widget):$/,\n\trnoContent = /^(?:GET|HEAD)$/,\n\trprotocol = /^\\/\\//,\n\n\t/* Prefilters\n\t * 1) They are useful to introduce custom dataTypes (see ajax/jsonp.js for an example)\n\t * 2) These are called:\n\t *    - BEFORE asking for a transport\n\t *    - AFTER param serialization (s.data is a string if s.processData is true)\n\t * 3) key is the dataType\n\t * 4) the catchall symbol \"*\" can be used\n\t * 5) execution will start with transport dataType and THEN continue down to \"*\" if needed\n\t */\n\tprefilters = {},\n\n\t/* Transports bindings\n\t * 1) key is the dataType\n\t * 2) the catchall symbol \"*\" can be used\n\t * 3) selection will start with transport dataType and THEN go to \"*\" if needed\n\t */\n\ttransports = {},\n\n\t// Avoid comment-prolog char sequence (#10098); must appease lint and evade compression\n\tallTypes = \"*/\".concat( \"*\" ),\n\n\t// Anchor tag for parsing the document origin\n\toriginAnchor = document.createElement( \"a\" );\n\toriginAnchor.href = location.href;\n\n// Base \"constructor\" for jQuery.ajaxPrefilter and jQuery.ajaxTransport\nfunction addToPrefiltersOrTransports( structure ) {\n\n\t// dataTypeExpression is optional and defaults to \"*\"\n\treturn function( dataTypeExpression, func ) {\n\n\t\tif ( typeof dataTypeExpression !== \"string\" ) {\n\t\t\tfunc = dataTypeExpression;\n\t\t\tdataTypeExpression = \"*\";\n\t\t}\n\n\t\tvar dataType,\n\t\t\ti = 0,\n\t\t\tdataTypes = dataTypeExpression.toLowerCase().match( rnothtmlwhite ) || [];\n\n\t\tif ( isFunction( func ) ) {\n\n\t\t\t// For each dataType in the dataTypeExpression\n\t\t\twhile ( ( dataType = dataTypes[ i++ ] ) ) {\n\n\t\t\t\t// Prepend if requested\n\t\t\t\tif ( dataType[ 0 ] === \"+\" ) {\n\t\t\t\t\tdataType = dataType.slice( 1 ) || \"*\";\n\t\t\t\t\t( structure[ dataType ] = structure[ dataType ] || [] ).unshift( func );\n\n\t\t\t\t// Otherwise append\n\t\t\t\t} else {\n\t\t\t\t\t( structure[ dataType ] = structure[ dataType ] || [] ).push( func );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t};\n}\n\n// Base inspection function for prefilters and transports\nfunction inspectPrefiltersOrTransports( structure, options, originalOptions, jqXHR ) {\n\n\tvar inspected = {},\n\t\tseekingTransport = ( structure === transports );\n\n\tfunction inspect( dataType ) {\n\t\tvar selected;\n\t\tinspected[ dataType ] = true;\n\t\tjQuery.each( structure[ dataType ] || [], function( _, prefilterOrFactory ) {\n\t\t\tvar dataTypeOrTransport = prefilterOrFactory( options, originalOptions, jqXHR );\n\t\t\tif ( typeof dataTypeOrTransport === \"string\" &&\n\t\t\t\t!seekingTransport && !inspected[ dataTypeOrTransport ] ) {\n\n\t\t\t\toptions.dataTypes.unshift( dataTypeOrTransport );\n\t\t\t\tinspect( dataTypeOrTransport );\n\t\t\t\treturn false;\n\t\t\t} else if ( seekingTransport ) {\n\t\t\t\treturn !( selected = dataTypeOrTransport );\n\t\t\t}\n\t\t} );\n\t\treturn selected;\n\t}\n\n\treturn inspect( options.dataTypes[ 0 ] ) || !inspected[ \"*\" ] && inspect( \"*\" );\n}\n\n// A special extend for ajax options\n// that takes \"flat\" options (not to be deep extended)\n// Fixes #9887\nfunction ajaxExtend( target, src ) {\n\tvar key, deep,\n\t\tflatOptions = jQuery.ajaxSettings.flatOptions || {};\n\n\tfor ( key in src ) {\n\t\tif ( src[ key ] !== undefined ) {\n\t\t\t( flatOptions[ key ] ? target : ( deep || ( deep = {} ) ) )[ key ] = src[ key ];\n\t\t}\n\t}\n\tif ( deep ) {\n\t\tjQuery.extend( true, target, deep );\n\t}\n\n\treturn target;\n}\n\n/* Handles responses to an ajax request:\n * - finds the right dataType (mediates between content-type and expected dataType)\n * - returns the corresponding response\n */\nfunction ajaxHandleResponses( s, jqXHR, responses ) {\n\n\tvar ct, type, finalDataType, firstDataType,\n\t\tcontents = s.contents,\n\t\tdataTypes = s.dataTypes;\n\n\t// Remove auto dataType and get content-type in the process\n\twhile ( dataTypes[ 0 ] === \"*\" ) {\n\t\tdataTypes.shift();\n\t\tif ( ct === undefined ) {\n\t\t\tct = s.mimeType || jqXHR.getResponseHeader( \"Content-Type\" );\n\t\t}\n\t}\n\n\t// Check if we're dealing with a known content-type\n\tif ( ct ) {\n\t\tfor ( type in contents ) {\n\t\t\tif ( contents[ type ] && contents[ type ].test( ct ) ) {\n\t\t\t\tdataTypes.unshift( type );\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\t// Check to see if we have a response for the expected dataType\n\tif ( dataTypes[ 0 ] in responses ) {\n\t\tfinalDataType = dataTypes[ 0 ];\n\t} else {\n\n\t\t// Try convertible dataTypes\n\t\tfor ( type in responses ) {\n\t\t\tif ( !dataTypes[ 0 ] || s.converters[ type + \" \" + dataTypes[ 0 ] ] ) {\n\t\t\t\tfinalDataType = type;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif ( !firstDataType ) {\n\t\t\t\tfirstDataType = type;\n\t\t\t}\n\t\t}\n\n\t\t// Or just use first one\n\t\tfinalDataType = finalDataType || firstDataType;\n\t}\n\n\t// If we found a dataType\n\t// We add the dataType to the list if needed\n\t// and return the corresponding response\n\tif ( finalDataType ) {\n\t\tif ( finalDataType !== dataTypes[ 0 ] ) {\n\t\t\tdataTypes.unshift( finalDataType );\n\t\t}\n\t\treturn responses[ finalDataType ];\n\t}\n}\n\n/* Chain conversions given the request and the original response\n * Also sets the responseXXX fields on the jqXHR instance\n */\nfunction ajaxConvert( s, response, jqXHR, isSuccess ) {\n\tvar conv2, current, conv, tmp, prev,\n\t\tconverters = {},\n\n\t\t// Work with a copy of dataTypes in case we need to modify it for conversion\n\t\tdataTypes = s.dataTypes.slice();\n\n\t// Create converters map with lowercased keys\n\tif ( dataTypes[ 1 ] ) {\n\t\tfor ( conv in s.converters ) {\n\t\t\tconverters[ conv.toLowerCase() ] = s.converters[ conv ];\n\t\t}\n\t}\n\n\tcurrent = dataTypes.shift();\n\n\t// Convert to each sequential dataType\n\twhile ( current ) {\n\n\t\tif ( s.responseFields[ current ] ) {\n\t\t\tjqXHR[ s.responseFields[ current ] ] = response;\n\t\t}\n\n\t\t// Apply the dataFilter if provided\n\t\tif ( !prev && isSuccess && s.dataFilter ) {\n\t\t\tresponse = s.dataFilter( response, s.dataType );\n\t\t}\n\n\t\tprev = current;\n\t\tcurrent = dataTypes.shift();\n\n\t\tif ( current ) {\n\n\t\t\t// There's only work to do if current dataType is non-auto\n\t\t\tif ( current === \"*\" ) {\n\n\t\t\t\tcurrent = prev;\n\n\t\t\t// Convert response if prev dataType is non-auto and differs from current\n\t\t\t} else if ( prev !== \"*\" && prev !== current ) {\n\n\t\t\t\t// Seek a direct converter\n\t\t\t\tconv = converters[ prev + \" \" + current ] || converters[ \"* \" + current ];\n\n\t\t\t\t// If none found, seek a pair\n\t\t\t\tif ( !conv ) {\n\t\t\t\t\tfor ( conv2 in converters ) {\n\n\t\t\t\t\t\t// If conv2 outputs current\n\t\t\t\t\t\ttmp = conv2.split( \" \" );\n\t\t\t\t\t\tif ( tmp[ 1 ] === current ) {\n\n\t\t\t\t\t\t\t// If prev can be converted to accepted input\n\t\t\t\t\t\t\tconv = converters[ prev + \" \" + tmp[ 0 ] ] ||\n\t\t\t\t\t\t\t\tconverters[ \"* \" + tmp[ 0 ] ];\n\t\t\t\t\t\t\tif ( conv ) {\n\n\t\t\t\t\t\t\t\t// Condense equivalence converters\n\t\t\t\t\t\t\t\tif ( conv === true ) {\n\t\t\t\t\t\t\t\t\tconv = converters[ conv2 ];\n\n\t\t\t\t\t\t\t\t// Otherwise, insert the intermediate dataType\n\t\t\t\t\t\t\t\t} else if ( converters[ conv2 ] !== true ) {\n\t\t\t\t\t\t\t\t\tcurrent = tmp[ 0 ];\n\t\t\t\t\t\t\t\t\tdataTypes.unshift( tmp[ 1 ] );\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// Apply converter (if not an equivalence)\n\t\t\t\tif ( conv !== true ) {\n\n\t\t\t\t\t// Unless errors are allowed to bubble, catch and return them\n\t\t\t\t\tif ( conv && s.throws ) {\n\t\t\t\t\t\tresponse = conv( response );\n\t\t\t\t\t} else {\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\tresponse = conv( response );\n\t\t\t\t\t\t} catch ( e ) {\n\t\t\t\t\t\t\treturn {\n\t\t\t\t\t\t\t\tstate: \"parsererror\",\n\t\t\t\t\t\t\t\terror: conv ? e : \"No conversion from \" + prev + \" to \" + current\n\t\t\t\t\t\t\t};\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn { state: \"success\", data: response };\n}\n\njQuery.extend( {\n\n\t// Counter for holding the number of active queries\n\tactive: 0,\n\n\t// Last-Modified header cache for next request\n\tlastModified: {},\n\tetag: {},\n\n\tajaxSettings: {\n\t\turl: location.href,\n\t\ttype: \"GET\",\n\t\tisLocal: rlocalProtocol.test( location.protocol ),\n\t\tglobal: true,\n\t\tprocessData: true,\n\t\tasync: true,\n\t\tcontentType: \"application/x-www-form-urlencoded; charset=UTF-8\",\n\n\t\t/*\n\t\ttimeout: 0,\n\t\tdata: null,\n\t\tdataType: null,\n\t\tusername: null,\n\t\tpassword: null,\n\t\tcache: null,\n\t\tthrows: false,\n\t\ttraditional: false,\n\t\theaders: {},\n\t\t*/\n\n\t\taccepts: {\n\t\t\t\"*\": allTypes,\n\t\t\ttext: \"text/plain\",\n\t\t\thtml: \"text/html\",\n\t\t\txml: \"application/xml, text/xml\",\n\t\t\tjson: \"application/json, text/javascript\"\n\t\t},\n\n\t\tcontents: {\n\t\t\txml: /\\bxml\\b/,\n\t\t\thtml: /\\bhtml/,\n\t\t\tjson: /\\bjson\\b/\n\t\t},\n\n\t\tresponseFields: {\n\t\t\txml: \"responseXML\",\n\t\t\ttext: \"responseText\",\n\t\t\tjson: \"responseJSON\"\n\t\t},\n\n\t\t// Data converters\n\t\t// Keys separate source (or catchall \"*\") and destination types with a single space\n\t\tconverters: {\n\n\t\t\t// Convert anything to text\n\t\t\t\"* text\": String,\n\n\t\t\t// Text to html (true = no transformation)\n\t\t\t\"text html\": true,\n\n\t\t\t// Evaluate text as a json expression\n\t\t\t\"text json\": JSON.parse,\n\n\t\t\t// Parse text as xml\n\t\t\t\"text xml\": jQuery.parseXML\n\t\t},\n\n\t\t// For options that shouldn't be deep extended:\n\t\t// you can add your own custom options here if\n\t\t// and when you create one that shouldn't be\n\t\t// deep extended (see ajaxExtend)\n\t\tflatOptions: {\n\t\t\turl: true,\n\t\t\tcontext: true\n\t\t}\n\t},\n\n\t// Creates a full fledged settings object into target\n\t// with both ajaxSettings and settings fields.\n\t// If target is omitted, writes into ajaxSettings.\n\tajaxSetup: function( target, settings ) {\n\t\treturn settings ?\n\n\t\t\t// Building a settings object\n\t\t\tajaxExtend( ajaxExtend( target, jQuery.ajaxSettings ), settings ) :\n\n\t\t\t// Extending ajaxSettings\n\t\t\tajaxExtend( jQuery.ajaxSettings, target );\n\t},\n\n\tajaxPrefilter: addToPrefiltersOrTransports( prefilters ),\n\tajaxTransport: addToPrefiltersOrTransports( transports ),\n\n\t// Main method\n\tajax: function( url, options ) {\n\n\t\t// If url is an object, simulate pre-1.5 signature\n\t\tif ( typeof url === \"object\" ) {\n\t\t\toptions = url;\n\t\t\turl = undefined;\n\t\t}\n\n\t\t// Force options to be an object\n\t\toptions = options || {};\n\n\t\tvar transport,\n\n\t\t\t// URL without anti-cache param\n\t\t\tcacheURL,\n\n\t\t\t// Response headers\n\t\t\tresponseHeadersString,\n\t\t\tresponseHeaders,\n\n\t\t\t// timeout handle\n\t\t\ttimeoutTimer,\n\n\t\t\t// Url cleanup var\n\t\t\turlAnchor,\n\n\t\t\t// Request state (becomes false upon send and true upon completion)\n\t\t\tcompleted,\n\n\t\t\t// To know if global events are to be dispatched\n\t\t\tfireGlobals,\n\n\t\t\t// Loop variable\n\t\t\ti,\n\n\t\t\t// uncached part of the url\n\t\t\tuncached,\n\n\t\t\t// Create the final options object\n\t\t\ts = jQuery.ajaxSetup( {}, options ),\n\n\t\t\t// Callbacks context\n\t\t\tcallbackContext = s.context || s,\n\n\t\t\t// Context for global events is callbackContext if it is a DOM node or jQuery collection\n\t\t\tglobalEventContext = s.context &&\n\t\t\t\t( callbackContext.nodeType || callbackContext.jquery ) ?\n\t\t\t\t\tjQuery( callbackContext ) :\n\t\t\t\t\tjQuery.event,\n\n\t\t\t// Deferreds\n\t\t\tdeferred = jQuery.Deferred(),\n\t\t\tcompleteDeferred = jQuery.Callbacks( \"once memory\" ),\n\n\t\t\t// Status-dependent callbacks\n\t\t\tstatusCode = s.statusCode || {},\n\n\t\t\t// Headers (they are sent all at once)\n\t\t\trequestHeaders = {},\n\t\t\trequestHeadersNames = {},\n\n\t\t\t// Default abort message\n\t\t\tstrAbort = \"canceled\",\n\n\t\t\t// Fake xhr\n\t\t\tjqXHR = {\n\t\t\t\treadyState: 0,\n\n\t\t\t\t// Builds headers hashtable if needed\n\t\t\t\tgetResponseHeader: function( key ) {\n\t\t\t\t\tvar match;\n\t\t\t\t\tif ( completed ) {\n\t\t\t\t\t\tif ( !responseHeaders ) {\n\t\t\t\t\t\t\tresponseHeaders = {};\n\t\t\t\t\t\t\twhile ( ( match = rheaders.exec( responseHeadersString ) ) ) {\n\t\t\t\t\t\t\t\tresponseHeaders[ match[ 1 ].toLowerCase() + \" \" ] =\n\t\t\t\t\t\t\t\t\t( responseHeaders[ match[ 1 ].toLowerCase() + \" \" ] || [] )\n\t\t\t\t\t\t\t\t\t\t.concat( match[ 2 ] );\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tmatch = responseHeaders[ key.toLowerCase() + \" \" ];\n\t\t\t\t\t}\n\t\t\t\t\treturn match == null ? null : match.join( \", \" );\n\t\t\t\t},\n\n\t\t\t\t// Raw string\n\t\t\t\tgetAllResponseHeaders: function() {\n\t\t\t\t\treturn completed ? responseHeadersString : null;\n\t\t\t\t},\n\n\t\t\t\t// Caches the header\n\t\t\t\tsetRequestHeader: function( name, value ) {\n\t\t\t\t\tif ( completed == null ) {\n\t\t\t\t\t\tname = requestHeadersNames[ name.toLowerCase() ] =\n\t\t\t\t\t\t\trequestHeadersNames[ name.toLowerCase() ] || name;\n\t\t\t\t\t\trequestHeaders[ name ] = value;\n\t\t\t\t\t}\n\t\t\t\t\treturn this;\n\t\t\t\t},\n\n\t\t\t\t// Overrides response content-type header\n\t\t\t\toverrideMimeType: function( type ) {\n\t\t\t\t\tif ( completed == null ) {\n\t\t\t\t\t\ts.mimeType = type;\n\t\t\t\t\t}\n\t\t\t\t\treturn this;\n\t\t\t\t},\n\n\t\t\t\t// Status-dependent callbacks\n\t\t\t\tstatusCode: function( map ) {\n\t\t\t\t\tvar code;\n\t\t\t\t\tif ( map ) {\n\t\t\t\t\t\tif ( completed ) {\n\n\t\t\t\t\t\t\t// Execute the appropriate callbacks\n\t\t\t\t\t\t\tjqXHR.always( map[ jqXHR.status ] );\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t// Lazy-add the new callbacks in a way that preserves old ones\n\t\t\t\t\t\t\tfor ( code in map ) {\n\t\t\t\t\t\t\t\tstatusCode[ code ] = [ statusCode[ code ], map[ code ] ];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\treturn this;\n\t\t\t\t},\n\n\t\t\t\t// Cancel the request\n\t\t\t\tabort: function( statusText ) {\n\t\t\t\t\tvar finalText = statusText || strAbort;\n\t\t\t\t\tif ( transport ) {\n\t\t\t\t\t\ttransport.abort( finalText );\n\t\t\t\t\t}\n\t\t\t\t\tdone( 0, finalText );\n\t\t\t\t\treturn this;\n\t\t\t\t}\n\t\t\t};\n\n\t\t// Attach deferreds\n\t\tdeferred.promise( jqXHR );\n\n\t\t// Add protocol if not provided (prefilters might expect it)\n\t\t// Handle falsy url in the settings object (#10093: consistency with old signature)\n\t\t// We also use the url parameter if available\n\t\ts.url = ( ( url || s.url || location.href ) + \"\" )\n\t\t\t.replace( rprotocol, location.protocol + \"//\" );\n\n\t\t// Alias method option to type as per ticket #12004\n\t\ts.type = options.method || options.type || s.method || s.type;\n\n\t\t// Extract dataTypes list\n\t\ts.dataTypes = ( s.dataType || \"*\" ).toLowerCase().match( rnothtmlwhite ) || [ \"\" ];\n\n\t\t// A cross-domain request is in order when the origin doesn't match the current origin.\n\t\tif ( s.crossDomain == null ) {\n\t\t\turlAnchor = document.createElement( \"a\" );\n\n\t\t\t// Support: IE <=8 - 11, Edge 12 - 15\n\t\t\t// IE throws exception on accessing the href property if url is malformed,\n\t\t\t// e.g. http://example.com:80x/\n\t\t\ttry {\n\t\t\t\turlAnchor.href = s.url;\n\n\t\t\t\t// Support: IE <=8 - 11 only\n\t\t\t\t// Anchor's host property isn't correctly set when s.url is relative\n\t\t\t\turlAnchor.href = urlAnchor.href;\n\t\t\t\ts.crossDomain = originAnchor.protocol + \"//\" + originAnchor.host !==\n\t\t\t\t\turlAnchor.protocol + \"//\" + urlAnchor.host;\n\t\t\t} catch ( e ) {\n\n\t\t\t\t// If there is an error parsing the URL, assume it is crossDomain,\n\t\t\t\t// it can be rejected by the transport if it is invalid\n\t\t\t\ts.crossDomain = true;\n\t\t\t}\n\t\t}\n\n\t\t// Convert data if not already a string\n\t\tif ( s.data && s.processData && typeof s.data !== \"string\" ) {\n\t\t\ts.data = jQuery.param( s.data, s.traditional );\n\t\t}\n\n\t\t// Apply prefilters\n\t\tinspectPrefiltersOrTransports( prefilters, s, options, jqXHR );\n\n\t\t// If request was aborted inside a prefilter, stop there\n\t\tif ( completed ) {\n\t\t\treturn jqXHR;\n\t\t}\n\n\t\t// We can fire global events as of now if asked to\n\t\t// Don't fire events if jQuery.event is undefined in an AMD-usage scenario (#15118)\n\t\tfireGlobals = jQuery.event && s.global;\n\n\t\t// Watch for a new set of requests\n\t\tif ( fireGlobals && jQuery.active++ === 0 ) {\n\t\t\tjQuery.event.trigger( \"ajaxStart\" );\n\t\t}\n\n\t\t// Uppercase the type\n\t\ts.type = s.type.toUpperCase();\n\n\t\t// Determine if request has content\n\t\ts.hasContent = !rnoContent.test( s.type );\n\n\t\t// Save the URL in case we're toying with the If-Modified-Since\n\t\t// and/or If-None-Match header later on\n\t\t// Remove hash to simplify url manipulation\n\t\tcacheURL = s.url.replace( rhash, \"\" );\n\n\t\t// More options handling for requests with no content\n\t\tif ( !s.hasContent ) {\n\n\t\t\t// Remember the hash so we can put it back\n\t\t\tuncached = s.url.slice( cacheURL.length );\n\n\t\t\t// If data is available and should be processed, append data to url\n\t\t\tif ( s.data && ( s.processData || typeof s.data === \"string\" ) ) {\n\t\t\t\tcacheURL += ( rquery.test( cacheURL ) ? \"&\" : \"?\" ) + s.data;\n\n\t\t\t\t// #9682: remove data so that it's not used in an eventual retry\n\t\t\t\tdelete s.data;\n\t\t\t}\n\n\t\t\t// Add or update anti-cache param if needed\n\t\t\tif ( s.cache === false ) {\n\t\t\t\tcacheURL = cacheURL.replace( rantiCache, \"$1\" );\n\t\t\t\tuncached = ( rquery.test( cacheURL ) ? \"&\" : \"?\" ) + \"_=\" + ( nonce++ ) + uncached;\n\t\t\t}\n\n\t\t\t// Put hash and anti-cache on the URL that will be requested (gh-1732)\n\t\t\ts.url = cacheURL + uncached;\n\n\t\t// Change '%20' to '+' if this is encoded form body content (gh-2658)\n\t\t} else if ( s.data && s.processData &&\n\t\t\t( s.contentType || \"\" ).indexOf( \"application/x-www-form-urlencoded\" ) === 0 ) {\n\t\t\ts.data = s.data.replace( r20, \"+\" );\n\t\t}\n\n\t\t// Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.\n\t\tif ( s.ifModified ) {\n\t\t\tif ( jQuery.lastModified[ cacheURL ] ) {\n\t\t\t\tjqXHR.setRequestHeader( \"If-Modified-Since\", jQuery.lastModified[ cacheURL ] );\n\t\t\t}\n\t\t\tif ( jQuery.etag[ cacheURL ] ) {\n\t\t\t\tjqXHR.setRequestHeader( \"If-None-Match\", jQuery.etag[ cacheURL ] );\n\t\t\t}\n\t\t}\n\n\t\t// Set the correct header, if data is being sent\n\t\tif ( s.data && s.hasContent && s.contentType !== false || options.contentType ) {\n\t\t\tjqXHR.setRequestHeader( \"Content-Type\", s.contentType );\n\t\t}\n\n\t\t// Set the Accepts header for the server, depending on the dataType\n\t\tjqXHR.setRequestHeader(\n\t\t\t\"Accept\",\n\t\t\ts.dataTypes[ 0 ] && s.accepts[ s.dataTypes[ 0 ] ] ?\n\t\t\t\ts.accepts[ s.dataTypes[ 0 ] ] +\n\t\t\t\t\t( s.dataTypes[ 0 ] !== \"*\" ? \", \" + allTypes + \"; q=0.01\" : \"\" ) :\n\t\t\t\ts.accepts[ \"*\" ]\n\t\t);\n\n\t\t// Check for headers option\n\t\tfor ( i in s.headers ) {\n\t\t\tjqXHR.setRequestHeader( i, s.headers[ i ] );\n\t\t}\n\n\t\t// Allow custom headers/mimetypes and early abort\n\t\tif ( s.beforeSend &&\n\t\t\t( s.beforeSend.call( callbackContext, jqXHR, s ) === false || completed ) ) {\n\n\t\t\t// Abort if not done already and return\n\t\t\treturn jqXHR.abort();\n\t\t}\n\n\t\t// Aborting is no longer a cancellation\n\t\tstrAbort = \"abort\";\n\n\t\t// Install callbacks on deferreds\n\t\tcompleteDeferred.add( s.complete );\n\t\tjqXHR.done( s.success );\n\t\tjqXHR.fail( s.error );\n\n\t\t// Get transport\n\t\ttransport = inspectPrefiltersOrTransports( transports, s, options, jqXHR );\n\n\t\t// If no transport, we auto-abort\n\t\tif ( !transport ) {\n\t\t\tdone( -1, \"No Transport\" );\n\t\t} else {\n\t\t\tjqXHR.readyState = 1;\n\n\t\t\t// Send global event\n\t\t\tif ( fireGlobals ) {\n\t\t\t\tglobalEventContext.trigger( \"ajaxSend\", [ jqXHR, s ] );\n\t\t\t}\n\n\t\t\t// If request was aborted inside ajaxSend, stop there\n\t\t\tif ( completed ) {\n\t\t\t\treturn jqXHR;\n\t\t\t}\n\n\t\t\t// Timeout\n\t\t\tif ( s.async && s.timeout > 0 ) {\n\t\t\t\ttimeoutTimer = window.setTimeout( function() {\n\t\t\t\t\tjqXHR.abort( \"timeout\" );\n\t\t\t\t}, s.timeout );\n\t\t\t}\n\n\t\t\ttry {\n\t\t\t\tcompleted = false;\n\t\t\t\ttransport.send( requestHeaders, done );\n\t\t\t} catch ( e ) {\n\n\t\t\t\t// Rethrow post-completion exceptions\n\t\t\t\tif ( completed ) {\n\t\t\t\t\tthrow e;\n\t\t\t\t}\n\n\t\t\t\t// Propagate others as results\n\t\t\t\tdone( -1, e );\n\t\t\t}\n\t\t}\n\n\t\t// Callback for when everything is done\n\t\tfunction done( status, nativeStatusText, responses, headers ) {\n\t\t\tvar isSuccess, success, error, response, modified,\n\t\t\t\tstatusText = nativeStatusText;\n\n\t\t\t// Ignore repeat invocations\n\t\t\tif ( completed ) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tcompleted = true;\n\n\t\t\t// Clear timeout if it exists\n\t\t\tif ( timeoutTimer ) {\n\t\t\t\twindow.clearTimeout( timeoutTimer );\n\t\t\t}\n\n\t\t\t// Dereference transport for early garbage collection\n\t\t\t// (no matter how long the jqXHR object will be used)\n\t\t\ttransport = undefined;\n\n\t\t\t// Cache response headers\n\t\t\tresponseHeadersString = headers || \"\";\n\n\t\t\t// Set readyState\n\t\t\tjqXHR.readyState = status > 0 ? 4 : 0;\n\n\t\t\t// Determine if successful\n\t\t\tisSuccess = status >= 200 && status < 300 || status === 304;\n\n\t\t\t// Get response data\n\t\t\tif ( responses ) {\n\t\t\t\tresponse = ajaxHandleResponses( s, jqXHR, responses );\n\t\t\t}\n\n\t\t\t// Convert no matter what (that way responseXXX fields are always set)\n\t\t\tresponse = ajaxConvert( s, response, jqXHR, isSuccess );\n\n\t\t\t// If successful, handle type chaining\n\t\t\tif ( isSuccess ) {\n\n\t\t\t\t// Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.\n\t\t\t\tif ( s.ifModified ) {\n\t\t\t\t\tmodified = jqXHR.getResponseHeader( \"Last-Modified\" );\n\t\t\t\t\tif ( modified ) {\n\t\t\t\t\t\tjQuery.lastModified[ cacheURL ] = modified;\n\t\t\t\t\t}\n\t\t\t\t\tmodified = jqXHR.getResponseHeader( \"etag\" );\n\t\t\t\t\tif ( modified ) {\n\t\t\t\t\t\tjQuery.etag[ cacheURL ] = modified;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// if no content\n\t\t\t\tif ( status === 204 || s.type === \"HEAD\" ) {\n\t\t\t\t\tstatusText = \"nocontent\";\n\n\t\t\t\t// if not modified\n\t\t\t\t} else if ( status === 304 ) {\n\t\t\t\t\tstatusText = \"notmodified\";\n\n\t\t\t\t// If we have data, let's convert it\n\t\t\t\t} else {\n\t\t\t\t\tstatusText = response.state;\n\t\t\t\t\tsuccess = response.data;\n\t\t\t\t\terror = response.error;\n\t\t\t\t\tisSuccess = !error;\n\t\t\t\t}\n\t\t\t} else {\n\n\t\t\t\t// Extract error from statusText and normalize for non-aborts\n\t\t\t\terror = statusText;\n\t\t\t\tif ( status || !statusText ) {\n\t\t\t\t\tstatusText = \"error\";\n\t\t\t\t\tif ( status < 0 ) {\n\t\t\t\t\t\tstatus = 0;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Set data for the fake xhr object\n\t\t\tjqXHR.status = status;\n\t\t\tjqXHR.statusText = ( nativeStatusText || statusText ) + \"\";\n\n\t\t\t// Success/Error\n\t\t\tif ( isSuccess ) {\n\t\t\t\tdeferred.resolveWith( callbackContext, [ success, statusText, jqXHR ] );\n\t\t\t} else {\n\t\t\t\tdeferred.rejectWith( callbackContext, [ jqXHR, statusText, error ] );\n\t\t\t}\n\n\t\t\t// Status-dependent callbacks\n\t\t\tjqXHR.statusCode( statusCode );\n\t\t\tstatusCode = undefined;\n\n\t\t\tif ( fireGlobals ) {\n\t\t\t\tglobalEventContext.trigger( isSuccess ? \"ajaxSuccess\" : \"ajaxError\",\n\t\t\t\t\t[ jqXHR, s, isSuccess ? success : error ] );\n\t\t\t}\n\n\t\t\t// Complete\n\t\t\tcompleteDeferred.fireWith( callbackContext, [ jqXHR, statusText ] );\n\n\t\t\tif ( fireGlobals ) {\n\t\t\t\tglobalEventContext.trigger( \"ajaxComplete\", [ jqXHR, s ] );\n\n\t\t\t\t// Handle the global AJAX counter\n\t\t\t\tif ( !( --jQuery.active ) ) {\n\t\t\t\t\tjQuery.event.trigger( \"ajaxStop\" );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn jqXHR;\n\t},\n\n\tgetJSON: function( url, data, callback ) {\n\t\treturn jQuery.get( url, data, callback, \"json\" );\n\t},\n\n\tgetScript: function( url, callback ) {\n\t\treturn jQuery.get( url, undefined, callback, \"script\" );\n\t}\n} );\n\njQuery.each( [ \"get\", \"post\" ], function( i, method ) {\n\tjQuery[ method ] = function( url, data, callback, type ) {\n\n\t\t// Shift arguments if data argument was omitted\n\t\tif ( isFunction( data ) ) {\n\t\t\ttype = type || callback;\n\t\t\tcallback = data;\n\t\t\tdata = undefined;\n\t\t}\n\n\t\t// The url can be an options object (which then must have .url)\n\t\treturn jQuery.ajax( jQuery.extend( {\n\t\t\turl: url,\n\t\t\ttype: method,\n\t\t\tdataType: type,\n\t\t\tdata: data,\n\t\t\tsuccess: callback\n\t\t}, jQuery.isPlainObject( url ) && url ) );\n\t};\n} );\n\n\njQuery._evalUrl = function( url, options ) {\n\treturn jQuery.ajax( {\n\t\turl: url,\n\n\t\t// Make this explicit, since user can override this through ajaxSetup (#11264)\n\t\ttype: \"GET\",\n\t\tdataType: \"script\",\n\t\tcache: true,\n\t\tasync: false,\n\t\tglobal: false,\n\n\t\t// Only evaluate the response if it is successful (gh-4126)\n\t\t// dataFilter is not invoked for failure responses, so using it instead\n\t\t// of the default converter is kludgy but it works.\n\t\tconverters: {\n\t\t\t\"text script\": function() {}\n\t\t},\n\t\tdataFilter: function( response ) {\n\t\t\tjQuery.globalEval( response, options );\n\t\t}\n\t} );\n};\n\n\njQuery.fn.extend( {\n\twrapAll: function( html ) {\n\t\tvar wrap;\n\n\t\tif ( this[ 0 ] ) {\n\t\t\tif ( isFunction( html ) ) {\n\t\t\t\thtml = html.call( this[ 0 ] );\n\t\t\t}\n\n\t\t\t// The elements to wrap the target around\n\t\t\twrap = jQuery( html, this[ 0 ].ownerDocument ).eq( 0 ).clone( true );\n\n\t\t\tif ( this[ 0 ].parentNode ) {\n\t\t\t\twrap.insertBefore( this[ 0 ] );\n\t\t\t}\n\n\t\t\twrap.map( function() {\n\t\t\t\tvar elem = this;\n\n\t\t\t\twhile ( elem.firstElementChild ) {\n\t\t\t\t\telem = elem.firstElementChild;\n\t\t\t\t}\n\n\t\t\t\treturn elem;\n\t\t\t} ).append( this );\n\t\t}\n\n\t\treturn this;\n\t},\n\n\twrapInner: function( html ) {\n\t\tif ( isFunction( html ) ) {\n\t\t\treturn this.each( function( i ) {\n\t\t\t\tjQuery( this ).wrapInner( html.call( this, i ) );\n\t\t\t} );\n\t\t}\n\n\t\treturn this.each( function() {\n\t\t\tvar self = jQuery( this ),\n\t\t\t\tcontents = self.contents();\n\n\t\t\tif ( contents.length ) {\n\t\t\t\tcontents.wrapAll( html );\n\n\t\t\t} else {\n\t\t\t\tself.append( html );\n\t\t\t}\n\t\t} );\n\t},\n\n\twrap: function( html ) {\n\t\tvar htmlIsFunction = isFunction( html );\n\n\t\treturn this.each( function( i ) {\n\t\t\tjQuery( this ).wrapAll( htmlIsFunction ? html.call( this, i ) : html );\n\t\t} );\n\t},\n\n\tunwrap: function( selector ) {\n\t\tthis.parent( selector ).not( \"body\" ).each( function() {\n\t\t\tjQuery( this ).replaceWith( this.childNodes );\n\t\t} );\n\t\treturn this;\n\t}\n} );\n\n\njQuery.expr.pseudos.hidden = function( elem ) {\n\treturn !jQuery.expr.pseudos.visible( elem );\n};\njQuery.expr.pseudos.visible = function( elem ) {\n\treturn !!( elem.offsetWidth || elem.offsetHeight || elem.getClientRects().length );\n};\n\n\n\n\njQuery.ajaxSettings.xhr = function() {\n\ttry {\n\t\treturn new window.XMLHttpRequest();\n\t} catch ( e ) {}\n};\n\nvar xhrSuccessStatus = {\n\n\t\t// File protocol always yields status code 0, assume 200\n\t\t0: 200,\n\n\t\t// Support: IE <=9 only\n\t\t// #1450: sometimes IE returns 1223 when it should be 204\n\t\t1223: 204\n\t},\n\txhrSupported = jQuery.ajaxSettings.xhr();\n\nsupport.cors = !!xhrSupported && ( \"withCredentials\" in xhrSupported );\nsupport.ajax = xhrSupported = !!xhrSupported;\n\njQuery.ajaxTransport( function( options ) {\n\tvar callback, errorCallback;\n\n\t// Cross domain only allowed if supported through XMLHttpRequest\n\tif ( support.cors || xhrSupported && !options.crossDomain ) {\n\t\treturn {\n\t\t\tsend: function( headers, complete ) {\n\t\t\t\tvar i,\n\t\t\t\t\txhr = options.xhr();\n\n\t\t\t\txhr.open(\n\t\t\t\t\toptions.type,\n\t\t\t\t\toptions.url,\n\t\t\t\t\toptions.async,\n\t\t\t\t\toptions.username,\n\t\t\t\t\toptions.password\n\t\t\t\t);\n\n\t\t\t\t// Apply custom fields if provided\n\t\t\t\tif ( options.xhrFields ) {\n\t\t\t\t\tfor ( i in options.xhrFields ) {\n\t\t\t\t\t\txhr[ i ] = options.xhrFields[ i ];\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// Override mime type if needed\n\t\t\t\tif ( options.mimeType && xhr.overrideMimeType ) {\n\t\t\t\t\txhr.overrideMimeType( options.mimeType );\n\t\t\t\t}\n\n\t\t\t\t// X-Requested-With header\n\t\t\t\t// For cross-domain requests, seeing as conditions for a preflight are\n\t\t\t\t// akin to a jigsaw puzzle, we simply never set it to be sure.\n\t\t\t\t// (it can always be set on a per-request basis or even using ajaxSetup)\n\t\t\t\t// For same-domain requests, won't change header if already provided.\n\t\t\t\tif ( !options.crossDomain && !headers[ \"X-Requested-With\" ] ) {\n\t\t\t\t\theaders[ \"X-Requested-With\" ] = \"XMLHttpRequest\";\n\t\t\t\t}\n\n\t\t\t\t// Set headers\n\t\t\t\tfor ( i in headers ) {\n\t\t\t\t\txhr.setRequestHeader( i, headers[ i ] );\n\t\t\t\t}\n\n\t\t\t\t// Callback\n\t\t\t\tcallback = function( type ) {\n\t\t\t\t\treturn function() {\n\t\t\t\t\t\tif ( callback ) {\n\t\t\t\t\t\t\tcallback = errorCallback = xhr.onload =\n\t\t\t\t\t\t\t\txhr.onerror = xhr.onabort = xhr.ontimeout =\n\t\t\t\t\t\t\t\t\txhr.onreadystatechange = null;\n\n\t\t\t\t\t\t\tif ( type === \"abort\" ) {\n\t\t\t\t\t\t\t\txhr.abort();\n\t\t\t\t\t\t\t} else if ( type === \"error\" ) {\n\n\t\t\t\t\t\t\t\t// Support: IE <=9 only\n\t\t\t\t\t\t\t\t// On a manual native abort, IE9 throws\n\t\t\t\t\t\t\t\t// errors on any property access that is not readyState\n\t\t\t\t\t\t\t\tif ( typeof xhr.status !== \"number\" ) {\n\t\t\t\t\t\t\t\t\tcomplete( 0, \"error\" );\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\tcomplete(\n\n\t\t\t\t\t\t\t\t\t\t// File: protocol always yields status 0; see #8605, #14207\n\t\t\t\t\t\t\t\t\t\txhr.status,\n\t\t\t\t\t\t\t\t\t\txhr.statusText\n\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tcomplete(\n\t\t\t\t\t\t\t\t\txhrSuccessStatus[ xhr.status ] || xhr.status,\n\t\t\t\t\t\t\t\t\txhr.statusText,\n\n\t\t\t\t\t\t\t\t\t// Support: IE <=9 only\n\t\t\t\t\t\t\t\t\t// IE9 has no XHR2 but throws on binary (trac-11426)\n\t\t\t\t\t\t\t\t\t// For XHR2 non-text, let the caller handle it (gh-2498)\n\t\t\t\t\t\t\t\t\t( xhr.responseType || \"text\" ) !== \"text\"  ||\n\t\t\t\t\t\t\t\t\ttypeof xhr.responseText !== \"string\" ?\n\t\t\t\t\t\t\t\t\t\t{ binary: xhr.response } :\n\t\t\t\t\t\t\t\t\t\t{ text: xhr.responseText },\n\t\t\t\t\t\t\t\t\txhr.getAllResponseHeaders()\n\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t};\n\t\t\t\t};\n\n\t\t\t\t// Listen to events\n\t\t\t\txhr.onload = callback();\n\t\t\t\terrorCallback = xhr.onerror = xhr.ontimeout = callback( \"error\" );\n\n\t\t\t\t// Support: IE 9 only\n\t\t\t\t// Use onreadystatechange to replace onabort\n\t\t\t\t// to handle uncaught aborts\n\t\t\t\tif ( xhr.onabort !== undefined ) {\n\t\t\t\t\txhr.onabort = errorCallback;\n\t\t\t\t} else {\n\t\t\t\t\txhr.onreadystatechange = function() {\n\n\t\t\t\t\t\t// Check readyState before timeout as it changes\n\t\t\t\t\t\tif ( xhr.readyState === 4 ) {\n\n\t\t\t\t\t\t\t// Allow onerror to be called first,\n\t\t\t\t\t\t\t// but that will not handle a native abort\n\t\t\t\t\t\t\t// Also, save errorCallback to a variable\n\t\t\t\t\t\t\t// as xhr.onerror cannot be accessed\n\t\t\t\t\t\t\twindow.setTimeout( function() {\n\t\t\t\t\t\t\t\tif ( callback ) {\n\t\t\t\t\t\t\t\t\terrorCallback();\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t} );\n\t\t\t\t\t\t}\n\t\t\t\t\t};\n\t\t\t\t}\n\n\t\t\t\t// Create the abort callback\n\t\t\t\tcallback = callback( \"abort\" );\n\n\t\t\t\ttry {\n\n\t\t\t\t\t// Do send the request (this may raise an exception)\n\t\t\t\t\txhr.send( options.hasContent && options.data || null );\n\t\t\t\t} catch ( e ) {\n\n\t\t\t\t\t// #14683: Only rethrow if this hasn't been notified as an error yet\n\t\t\t\t\tif ( callback ) {\n\t\t\t\t\t\tthrow e;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t},\n\n\t\t\tabort: function() {\n\t\t\t\tif ( callback ) {\n\t\t\t\t\tcallback();\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t}\n} );\n\n\n\n\n// Prevent auto-execution of scripts when no explicit dataType was provided (See gh-2432)\njQuery.ajaxPrefilter( function( s ) {\n\tif ( s.crossDomain ) {\n\t\ts.contents.script = false;\n\t}\n} );\n\n// Install script dataType\njQuery.ajaxSetup( {\n\taccepts: {\n\t\tscript: \"text/javascript, application/javascript, \" +\n\t\t\t\"application/ecmascript, application/x-ecmascript\"\n\t},\n\tcontents: {\n\t\tscript: /\\b(?:java|ecma)script\\b/\n\t},\n\tconverters: {\n\t\t\"text script\": function( text ) {\n\t\t\tjQuery.globalEval( text );\n\t\t\treturn text;\n\t\t}\n\t}\n} );\n\n// Handle cache's special case and crossDomain\njQuery.ajaxPrefilter( \"script\", function( s ) {\n\tif ( s.cache === undefined ) {\n\t\ts.cache = false;\n\t}\n\tif ( s.crossDomain ) {\n\t\ts.type = \"GET\";\n\t}\n} );\n\n// Bind script tag hack transport\njQuery.ajaxTransport( \"script\", function( s ) {\n\n\t// This transport only deals with cross domain or forced-by-attrs requests\n\tif ( s.crossDomain || s.scriptAttrs ) {\n\t\tvar script, callback;\n\t\treturn {\n\t\t\tsend: function( _, complete ) {\n\t\t\t\tscript = jQuery( \"<script>\" )\n\t\t\t\t\t.attr( s.scriptAttrs || {} )\n\t\t\t\t\t.prop( { charset: s.scriptCharset, src: s.url } )\n\t\t\t\t\t.on( \"load error\", callback = function( evt ) {\n\t\t\t\t\t\tscript.remove();\n\t\t\t\t\t\tcallback = null;\n\t\t\t\t\t\tif ( evt ) {\n\t\t\t\t\t\t\tcomplete( evt.type === \"error\" ? 404 : 200, evt.type );\n\t\t\t\t\t\t}\n\t\t\t\t\t} );\n\n\t\t\t\t// Use native DOM manipulation to avoid our domManip AJAX trickery\n\t\t\t\tdocument.head.appendChild( script[ 0 ] );\n\t\t\t},\n\t\t\tabort: function() {\n\t\t\t\tif ( callback ) {\n\t\t\t\t\tcallback();\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t}\n} );\n\n\n\n\nvar oldCallbacks = [],\n\trjsonp = /(=)\\?(?=&|$)|\\?\\?/;\n\n// Default jsonp settings\njQuery.ajaxSetup( {\n\tjsonp: \"callback\",\n\tjsonpCallback: function() {\n\t\tvar callback = oldCallbacks.pop() || ( jQuery.expando + \"_\" + ( nonce++ ) );\n\t\tthis[ callback ] = true;\n\t\treturn callback;\n\t}\n} );\n\n// Detect, normalize options and install callbacks for jsonp requests\njQuery.ajaxPrefilter( \"json jsonp\", function( s, originalSettings, jqXHR ) {\n\n\tvar callbackName, overwritten, responseContainer,\n\t\tjsonProp = s.jsonp !== false && ( rjsonp.test( s.url ) ?\n\t\t\t\"url\" :\n\t\t\ttypeof s.data === \"string\" &&\n\t\t\t\t( s.contentType || \"\" )\n\t\t\t\t\t.indexOf( \"application/x-www-form-urlencoded\" ) === 0 &&\n\t\t\t\trjsonp.test( s.data ) && \"data\"\n\t\t);\n\n\t// Handle iff the expected data type is \"jsonp\" or we have a parameter to set\n\tif ( jsonProp || s.dataTypes[ 0 ] === \"jsonp\" ) {\n\n\t\t// Get callback name, remembering preexisting value associated with it\n\t\tcallbackName = s.jsonpCallback = isFunction( s.jsonpCallback ) ?\n\t\t\ts.jsonpCallback() :\n\t\t\ts.jsonpCallback;\n\n\t\t// Insert callback into url or form data\n\t\tif ( jsonProp ) {\n\t\t\ts[ jsonProp ] = s[ jsonProp ].replace( rjsonp, \"$1\" + callbackName );\n\t\t} else if ( s.jsonp !== false ) {\n\t\t\ts.url += ( rquery.test( s.url ) ? \"&\" : \"?\" ) + s.jsonp + \"=\" + callbackName;\n\t\t}\n\n\t\t// Use data converter to retrieve json after script execution\n\t\ts.converters[ \"script json\" ] = function() {\n\t\t\tif ( !responseContainer ) {\n\t\t\t\tjQuery.error( callbackName + \" was not called\" );\n\t\t\t}\n\t\t\treturn responseContainer[ 0 ];\n\t\t};\n\n\t\t// Force json dataType\n\t\ts.dataTypes[ 0 ] = \"json\";\n\n\t\t// Install callback\n\t\toverwritten = window[ callbackName ];\n\t\twindow[ callbackName ] = function() {\n\t\t\tresponseContainer = arguments;\n\t\t};\n\n\t\t// Clean-up function (fires after converters)\n\t\tjqXHR.always( function() {\n\n\t\t\t// If previous value didn't exist - remove it\n\t\t\tif ( overwritten === undefined ) {\n\t\t\t\tjQuery( window ).removeProp( callbackName );\n\n\t\t\t// Otherwise restore preexisting value\n\t\t\t} else {\n\t\t\t\twindow[ callbackName ] = overwritten;\n\t\t\t}\n\n\t\t\t// Save back as free\n\t\t\tif ( s[ callbackName ] ) {\n\n\t\t\t\t// Make sure that re-using the options doesn't screw things around\n\t\t\t\ts.jsonpCallback = originalSettings.jsonpCallback;\n\n\t\t\t\t// Save the callback name for future use\n\t\t\t\toldCallbacks.push( callbackName );\n\t\t\t}\n\n\t\t\t// Call if it was a function and we have a response\n\t\t\tif ( responseContainer && isFunction( overwritten ) ) {\n\t\t\t\toverwritten( responseContainer[ 0 ] );\n\t\t\t}\n\n\t\t\tresponseContainer = overwritten = undefined;\n\t\t} );\n\n\t\t// Delegate to script\n\t\treturn \"script\";\n\t}\n} );\n\n\n\n\n// Support: Safari 8 only\n// In Safari 8 documents created via document.implementation.createHTMLDocument\n// collapse sibling forms: the second one becomes a child of the first one.\n// Because of that, this security measure has to be disabled in Safari 8.\n// https://bugs.webkit.org/show_bug.cgi?id=137337\nsupport.createHTMLDocument = ( function() {\n\tvar body = document.implementation.createHTMLDocument( \"\" ).body;\n\tbody.innerHTML = \"<form></form><form></form>\";\n\treturn body.childNodes.length === 2;\n} )();\n\n\n// Argument \"data\" should be string of html\n// context (optional): If specified, the fragment will be created in this context,\n// defaults to document\n// keepScripts (optional): If true, will include scripts passed in the html string\njQuery.parseHTML = function( data, context, keepScripts ) {\n\tif ( typeof data !== \"string\" ) {\n\t\treturn [];\n\t}\n\tif ( typeof context === \"boolean\" ) {\n\t\tkeepScripts = context;\n\t\tcontext = false;\n\t}\n\n\tvar base, parsed, scripts;\n\n\tif ( !context ) {\n\n\t\t// Stop scripts or inline event handlers from being executed immediately\n\t\t// by using document.implementation\n\t\tif ( support.createHTMLDocument ) {\n\t\t\tcontext = document.implementation.createHTMLDocument( \"\" );\n\n\t\t\t// Set the base href for the created document\n\t\t\t// so any parsed elements with URLs\n\t\t\t// are based on the document's URL (gh-2965)\n\t\t\tbase = context.createElement( \"base\" );\n\t\t\tbase.href = document.location.href;\n\t\t\tcontext.head.appendChild( base );\n\t\t} else {\n\t\t\tcontext = document;\n\t\t}\n\t}\n\n\tparsed = rsingleTag.exec( data );\n\tscripts = !keepScripts && [];\n\n\t// Single tag\n\tif ( parsed ) {\n\t\treturn [ context.createElement( parsed[ 1 ] ) ];\n\t}\n\n\tparsed = buildFragment( [ data ], context, scripts );\n\n\tif ( scripts && scripts.length ) {\n\t\tjQuery( scripts ).remove();\n\t}\n\n\treturn jQuery.merge( [], parsed.childNodes );\n};\n\n\n/**\n * Load a url into a page\n */\njQuery.fn.load = function( url, params, callback ) {\n\tvar selector, type, response,\n\t\tself = this,\n\t\toff = url.indexOf( \" \" );\n\n\tif ( off > -1 ) {\n\t\tselector = stripAndCollapse( url.slice( off ) );\n\t\turl = url.slice( 0, off );\n\t}\n\n\t// If it's a function\n\tif ( isFunction( params ) ) {\n\n\t\t// We assume that it's the callback\n\t\tcallback = params;\n\t\tparams = undefined;\n\n\t// Otherwise, build a param string\n\t} else if ( params && typeof params === \"object\" ) {\n\t\ttype = \"POST\";\n\t}\n\n\t// If we have elements to modify, make the request\n\tif ( self.length > 0 ) {\n\t\tjQuery.ajax( {\n\t\t\turl: url,\n\n\t\t\t// If \"type\" variable is undefined, then \"GET\" method will be used.\n\t\t\t// Make value of this field explicit since\n\t\t\t// user can override it through ajaxSetup method\n\t\t\ttype: type || \"GET\",\n\t\t\tdataType: \"html\",\n\t\t\tdata: params\n\t\t} ).done( function( responseText ) {\n\n\t\t\t// Save response for use in complete callback\n\t\t\tresponse = arguments;\n\n\t\t\tself.html( selector ?\n\n\t\t\t\t// If a selector was specified, locate the right elements in a dummy div\n\t\t\t\t// Exclude scripts to avoid IE 'Permission Denied' errors\n\t\t\t\tjQuery( \"<div>\" ).append( jQuery.parseHTML( responseText ) ).find( selector ) :\n\n\t\t\t\t// Otherwise use the full result\n\t\t\t\tresponseText );\n\n\t\t// If the request succeeds, this function gets \"data\", \"status\", \"jqXHR\"\n\t\t// but they are ignored because response was set above.\n\t\t// If it fails, this function gets \"jqXHR\", \"status\", \"error\"\n\t\t} ).always( callback && function( jqXHR, status ) {\n\t\t\tself.each( function() {\n\t\t\t\tcallback.apply( this, response || [ jqXHR.responseText, status, jqXHR ] );\n\t\t\t} );\n\t\t} );\n\t}\n\n\treturn this;\n};\n\n\n\n\n// Attach a bunch of functions for handling common AJAX events\njQuery.each( [\n\t\"ajaxStart\",\n\t\"ajaxStop\",\n\t\"ajaxComplete\",\n\t\"ajaxError\",\n\t\"ajaxSuccess\",\n\t\"ajaxSend\"\n], function( i, type ) {\n\tjQuery.fn[ type ] = function( fn ) {\n\t\treturn this.on( type, fn );\n\t};\n} );\n\n\n\n\njQuery.expr.pseudos.animated = function( elem ) {\n\treturn jQuery.grep( jQuery.timers, function( fn ) {\n\t\treturn elem === fn.elem;\n\t} ).length;\n};\n\n\n\n\njQuery.offset = {\n\tsetOffset: function( elem, options, i ) {\n\t\tvar curPosition, curLeft, curCSSTop, curTop, curOffset, curCSSLeft, calculatePosition,\n\t\t\tposition = jQuery.css( elem, \"position\" ),\n\t\t\tcurElem = jQuery( elem ),\n\t\t\tprops = {};\n\n\t\t// Set position first, in-case top/left are set even on static elem\n\t\tif ( position === \"static\" ) {\n\t\t\telem.style.position = \"relative\";\n\t\t}\n\n\t\tcurOffset = curElem.offset();\n\t\tcurCSSTop = jQuery.css( elem, \"top\" );\n\t\tcurCSSLeft = jQuery.css( elem, \"left\" );\n\t\tcalculatePosition = ( position === \"absolute\" || position === \"fixed\" ) &&\n\t\t\t( curCSSTop + curCSSLeft ).indexOf( \"auto\" ) > -1;\n\n\t\t// Need to be able to calculate position if either\n\t\t// top or left is auto and position is either absolute or fixed\n\t\tif ( calculatePosition ) {\n\t\t\tcurPosition = curElem.position();\n\t\t\tcurTop = curPosition.top;\n\t\t\tcurLeft = curPosition.left;\n\n\t\t} else {\n\t\t\tcurTop = parseFloat( curCSSTop ) || 0;\n\t\t\tcurLeft = parseFloat( curCSSLeft ) || 0;\n\t\t}\n\n\t\tif ( isFunction( options ) ) {\n\n\t\t\t// Use jQuery.extend here to allow modification of coordinates argument (gh-1848)\n\t\t\toptions = options.call( elem, i, jQuery.extend( {}, curOffset ) );\n\t\t}\n\n\t\tif ( options.top != null ) {\n\t\t\tprops.top = ( options.top - curOffset.top ) + curTop;\n\t\t}\n\t\tif ( options.left != null ) {\n\t\t\tprops.left = ( options.left - curOffset.left ) + curLeft;\n\t\t}\n\n\t\tif ( \"using\" in options ) {\n\t\t\toptions.using.call( elem, props );\n\n\t\t} else {\n\t\t\tcurElem.css( props );\n\t\t}\n\t}\n};\n\njQuery.fn.extend( {\n\n\t// offset() relates an element's border box to the document origin\n\toffset: function( options ) {\n\n\t\t// Preserve chaining for setter\n\t\tif ( arguments.length ) {\n\t\t\treturn options === undefined ?\n\t\t\t\tthis :\n\t\t\t\tthis.each( function( i ) {\n\t\t\t\t\tjQuery.offset.setOffset( this, options, i );\n\t\t\t\t} );\n\t\t}\n\n\t\tvar rect, win,\n\t\t\telem = this[ 0 ];\n\n\t\tif ( !elem ) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Return zeros for disconnected and hidden (display: none) elements (gh-2310)\n\t\t// Support: IE <=11 only\n\t\t// Running getBoundingClientRect on a\n\t\t// disconnected node in IE throws an error\n\t\tif ( !elem.getClientRects().length ) {\n\t\t\treturn { top: 0, left: 0 };\n\t\t}\n\n\t\t// Get document-relative position by adding viewport scroll to viewport-relative gBCR\n\t\trect = elem.getBoundingClientRect();\n\t\twin = elem.ownerDocument.defaultView;\n\t\treturn {\n\t\t\ttop: rect.top + win.pageYOffset,\n\t\t\tleft: rect.left + win.pageXOffset\n\t\t};\n\t},\n\n\t// position() relates an element's margin box to its offset parent's padding box\n\t// This corresponds to the behavior of CSS absolute positioning\n\tposition: function() {\n\t\tif ( !this[ 0 ] ) {\n\t\t\treturn;\n\t\t}\n\n\t\tvar offsetParent, offset, doc,\n\t\t\telem = this[ 0 ],\n\t\t\tparentOffset = { top: 0, left: 0 };\n\n\t\t// position:fixed elements are offset from the viewport, which itself always has zero offset\n\t\tif ( jQuery.css( elem, \"position\" ) === \"fixed\" ) {\n\n\t\t\t// Assume position:fixed implies availability of getBoundingClientRect\n\t\t\toffset = elem.getBoundingClientRect();\n\n\t\t} else {\n\t\t\toffset = this.offset();\n\n\t\t\t// Account for the *real* offset parent, which can be the document or its root element\n\t\t\t// when a statically positioned element is identified\n\t\t\tdoc = elem.ownerDocument;\n\t\t\toffsetParent = elem.offsetParent || doc.documentElement;\n\t\t\twhile ( offsetParent &&\n\t\t\t\t( offsetParent === doc.body || offsetParent === doc.documentElement ) &&\n\t\t\t\tjQuery.css( offsetParent, \"position\" ) === \"static\" ) {\n\n\t\t\t\toffsetParent = offsetParent.parentNode;\n\t\t\t}\n\t\t\tif ( offsetParent && offsetParent !== elem && offsetParent.nodeType === 1 ) {\n\n\t\t\t\t// Incorporate borders into its offset, since they are outside its content origin\n\t\t\t\tparentOffset = jQuery( offsetParent ).offset();\n\t\t\t\tparentOffset.top += jQuery.css( offsetParent, \"borderTopWidth\", true );\n\t\t\t\tparentOffset.left += jQuery.css( offsetParent, \"borderLeftWidth\", true );\n\t\t\t}\n\t\t}\n\n\t\t// Subtract parent offsets and element margins\n\t\treturn {\n\t\t\ttop: offset.top - parentOffset.top - jQuery.css( elem, \"marginTop\", true ),\n\t\t\tleft: offset.left - parentOffset.left - jQuery.css( elem, \"marginLeft\", true )\n\t\t};\n\t},\n\n\t// This method will return documentElement in the following cases:\n\t// 1) For the element inside the iframe without offsetParent, this method will return\n\t//    documentElement of the parent window\n\t// 2) For the hidden or detached element\n\t// 3) For body or html element, i.e. in case of the html node - it will return itself\n\t//\n\t// but those exceptions were never presented as a real life use-cases\n\t// and might be considered as more preferable results.\n\t//\n\t// This logic, however, is not guaranteed and can change at any point in the future\n\toffsetParent: function() {\n\t\treturn this.map( function() {\n\t\t\tvar offsetParent = this.offsetParent;\n\n\t\t\twhile ( offsetParent && jQuery.css( offsetParent, \"position\" ) === \"static\" ) {\n\t\t\t\toffsetParent = offsetParent.offsetParent;\n\t\t\t}\n\n\t\t\treturn offsetParent || documentElement;\n\t\t} );\n\t}\n} );\n\n// Create scrollLeft and scrollTop methods\njQuery.each( { scrollLeft: \"pageXOffset\", scrollTop: \"pageYOffset\" }, function( method, prop ) {\n\tvar top = \"pageYOffset\" === prop;\n\n\tjQuery.fn[ method ] = function( val ) {\n\t\treturn access( this, function( elem, method, val ) {\n\n\t\t\t// Coalesce documents and windows\n\t\t\tvar win;\n\t\t\tif ( isWindow( elem ) ) {\n\t\t\t\twin = elem;\n\t\t\t} else if ( elem.nodeType === 9 ) {\n\t\t\t\twin = elem.defaultView;\n\t\t\t}\n\n\t\t\tif ( val === undefined ) {\n\t\t\t\treturn win ? win[ prop ] : elem[ method ];\n\t\t\t}\n\n\t\t\tif ( win ) {\n\t\t\t\twin.scrollTo(\n\t\t\t\t\t!top ? val : win.pageXOffset,\n\t\t\t\t\ttop ? val : win.pageYOffset\n\t\t\t\t);\n\n\t\t\t} else {\n\t\t\t\telem[ method ] = val;\n\t\t\t}\n\t\t}, method, val, arguments.length );\n\t};\n} );\n\n// Support: Safari <=7 - 9.1, Chrome <=37 - 49\n// Add the top/left cssHooks using jQuery.fn.position\n// Webkit bug: https://bugs.webkit.org/show_bug.cgi?id=29084\n// Blink bug: https://bugs.chromium.org/p/chromium/issues/detail?id=589347\n// getComputedStyle returns percent when specified for top/left/bottom/right;\n// rather than make the css module depend on the offset module, just check for it here\njQuery.each( [ \"top\", \"left\" ], function( i, prop ) {\n\tjQuery.cssHooks[ prop ] = addGetHookIf( support.pixelPosition,\n\t\tfunction( elem, computed ) {\n\t\t\tif ( computed ) {\n\t\t\t\tcomputed = curCSS( elem, prop );\n\n\t\t\t\t// If curCSS returns percentage, fallback to offset\n\t\t\t\treturn rnumnonpx.test( computed ) ?\n\t\t\t\t\tjQuery( elem ).position()[ prop ] + \"px\" :\n\t\t\t\t\tcomputed;\n\t\t\t}\n\t\t}\n\t);\n} );\n\n\n// Create innerHeight, innerWidth, height, width, outerHeight and outerWidth methods\njQuery.each( { Height: \"height\", Width: \"width\" }, function( name, type ) {\n\tjQuery.each( { padding: \"inner\" + name, content: type, \"\": \"outer\" + name },\n\t\tfunction( defaultExtra, funcName ) {\n\n\t\t// Margin is only for outerHeight, outerWidth\n\t\tjQuery.fn[ funcName ] = function( margin, value ) {\n\t\t\tvar chainable = arguments.length && ( defaultExtra || typeof margin !== \"boolean\" ),\n\t\t\t\textra = defaultExtra || ( margin === true || value === true ? \"margin\" : \"border\" );\n\n\t\t\treturn access( this, function( elem, type, value ) {\n\t\t\t\tvar doc;\n\n\t\t\t\tif ( isWindow( elem ) ) {\n\n\t\t\t\t\t// $( window ).outerWidth/Height return w/h including scrollbars (gh-1729)\n\t\t\t\t\treturn funcName.indexOf( \"outer\" ) === 0 ?\n\t\t\t\t\t\telem[ \"inner\" + name ] :\n\t\t\t\t\t\telem.document.documentElement[ \"client\" + name ];\n\t\t\t\t}\n\n\t\t\t\t// Get document width or height\n\t\t\t\tif ( elem.nodeType === 9 ) {\n\t\t\t\t\tdoc = elem.documentElement;\n\n\t\t\t\t\t// Either scroll[Width/Height] or offset[Width/Height] or client[Width/Height],\n\t\t\t\t\t// whichever is greatest\n\t\t\t\t\treturn Math.max(\n\t\t\t\t\t\telem.body[ \"scroll\" + name ], doc[ \"scroll\" + name ],\n\t\t\t\t\t\telem.body[ \"offset\" + name ], doc[ \"offset\" + name ],\n\t\t\t\t\t\tdoc[ \"client\" + name ]\n\t\t\t\t\t);\n\t\t\t\t}\n\n\t\t\t\treturn value === undefined ?\n\n\t\t\t\t\t// Get width or height on the element, requesting but not forcing parseFloat\n\t\t\t\t\tjQuery.css( elem, type, extra ) :\n\n\t\t\t\t\t// Set width or height on the element\n\t\t\t\t\tjQuery.style( elem, type, value, extra );\n\t\t\t}, type, chainable ? margin : undefined, chainable );\n\t\t};\n\t} );\n} );\n\n\njQuery.each( ( \"blur focus focusin focusout resize scroll click dblclick \" +\n\t\"mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave \" +\n\t\"change select submit keydown keypress keyup contextmenu\" ).split( \" \" ),\n\tfunction( i, name ) {\n\n\t// Handle event binding\n\tjQuery.fn[ name ] = function( data, fn ) {\n\t\treturn arguments.length > 0 ?\n\t\t\tthis.on( name, null, data, fn ) :\n\t\t\tthis.trigger( name );\n\t};\n} );\n\njQuery.fn.extend( {\n\thover: function( fnOver, fnOut ) {\n\t\treturn this.mouseenter( fnOver ).mouseleave( fnOut || fnOver );\n\t}\n} );\n\n\n\n\njQuery.fn.extend( {\n\n\tbind: function( types, data, fn ) {\n\t\treturn this.on( types, null, data, fn );\n\t},\n\tunbind: function( types, fn ) {\n\t\treturn this.off( types, null, fn );\n\t},\n\n\tdelegate: function( selector, types, data, fn ) {\n\t\treturn this.on( types, selector, data, fn );\n\t},\n\tundelegate: function( selector, types, fn ) {\n\n\t\t// ( namespace ) or ( selector, types [, fn] )\n\t\treturn arguments.length === 1 ?\n\t\t\tthis.off( selector, \"**\" ) :\n\t\t\tthis.off( types, selector || \"**\", fn );\n\t}\n} );\n\n// Bind a function to a context, optionally partially applying any\n// arguments.\n// jQuery.proxy is deprecated to promote standards (specifically Function#bind)\n// However, it is not slated for removal any time soon\njQuery.proxy = function( fn, context ) {\n\tvar tmp, args, proxy;\n\n\tif ( typeof context === \"string\" ) {\n\t\ttmp = fn[ context ];\n\t\tcontext = fn;\n\t\tfn = tmp;\n\t}\n\n\t// Quick check to determine if target is callable, in the spec\n\t// this throws a TypeError, but we will just return undefined.\n\tif ( !isFunction( fn ) ) {\n\t\treturn undefined;\n\t}\n\n\t// Simulated bind\n\targs = slice.call( arguments, 2 );\n\tproxy = function() {\n\t\treturn fn.apply( context || this, args.concat( slice.call( arguments ) ) );\n\t};\n\n\t// Set the guid of unique handler to the same of original handler, so it can be removed\n\tproxy.guid = fn.guid = fn.guid || jQuery.guid++;\n\n\treturn proxy;\n};\n\njQuery.holdReady = function( hold ) {\n\tif ( hold ) {\n\t\tjQuery.readyWait++;\n\t} else {\n\t\tjQuery.ready( true );\n\t}\n};\njQuery.isArray = Array.isArray;\njQuery.parseJSON = JSON.parse;\njQuery.nodeName = nodeName;\njQuery.isFunction = isFunction;\njQuery.isWindow = isWindow;\njQuery.camelCase = camelCase;\njQuery.type = toType;\n\njQuery.now = Date.now;\n\njQuery.isNumeric = function( obj ) {\n\n\t// As of jQuery 3.0, isNumeric is limited to\n\t// strings and numbers (primitives or objects)\n\t// that can be coerced to finite numbers (gh-2662)\n\tvar type = jQuery.type( obj );\n\treturn ( type === \"number\" || type === \"string\" ) &&\n\n\t\t// parseFloat NaNs numeric-cast false positives (\"\")\n\t\t// ...but misinterprets leading-number strings, particularly hex literals (\"0x...\")\n\t\t// subtraction forces infinities to NaN\n\t\t!isNaN( obj - parseFloat( obj ) );\n};\n\n\n\n\n// Register as a named AMD module, since jQuery can be concatenated with other\n// files that may use define, but not via a proper concatenation script that\n// understands anonymous AMD modules. A named AMD is safest and most robust\n// way to register. Lowercase jquery is used because AMD module names are\n// derived from file names, and jQuery is normally delivered in a lowercase\n// file name. Do this after creating the global so that if an AMD module wants\n// to call noConflict to hide this version of jQuery, it will work.\n\n// Note that for maximum portability, libraries that are not jQuery should\n// declare themselves as anonymous modules, and avoid setting a global if an\n// AMD loader is present. jQuery is a special case. For more information, see\n// https://github.com/jrburke/requirejs/wiki/Updating-existing-libraries#wiki-anon\n\nif ( true ) {\n\t!(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = (function() {\n\t\treturn jQuery;\n\t}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n}\n\n\n\n\nvar\n\n\t// Map over jQuery in case of overwrite\n\t_jQuery = window.jQuery,\n\n\t// Map over the $ in case of overwrite\n\t_$ = window.$;\n\njQuery.noConflict = function( deep ) {\n\tif ( window.$ === jQuery ) {\n\t\twindow.$ = _$;\n\t}\n\n\tif ( deep && window.jQuery === jQuery ) {\n\t\twindow.jQuery = _jQuery;\n\t}\n\n\treturn jQuery;\n};\n\n// Expose jQuery and $ identifiers, even in AMD\n// (#7102#comment:10, https://github.com/jquery/jquery/pull/557)\n// and CommonJS for browser emulators (#13566)\nif ( !noGlobal ) {\n\twindow.jQuery = window.$ = jQuery;\n}\n\n\n\n\nreturn jQuery;\n} );\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvanF1ZXJ5L2Rpc3QvanF1ZXJ5LmpzP2VlZGYiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTs7QUFFQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7Ozs7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUFJQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILEVBQUU7O0FBRUY7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsK0JBQStCO0FBQy9CO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxRQUFRLFlBQVk7O0FBRXBCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRixvQkFBb0I7O0FBRXBCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQSxrQkFBa0Isa0NBQWtDO0FBQ3BELEVBQUU7O0FBRUY7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsVUFBVSxZQUFZO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxTQUFTLFNBQVM7QUFDbEI7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxTQUFTLFlBQVk7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLFlBQVk7QUFDdEI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUyxTQUFTO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBOztBQUVBLGdCQUFnQixJQUFJOztBQUVwQjtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSx3Q0FBd0MsSUFBSTtBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0QsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBLE1BQU07O0FBRU47QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxhQUFhLHlCQUF5QjtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxXQUFXLFNBQVM7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsV0FBVyxTQUFTO0FBQ3BCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQixXQUFXLFNBQVM7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsYUFBYSxPQUFPO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsV0FBVyxRQUFRLDZCQUE2QjtBQUNoRDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFdBQVcsU0FBUztBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxFQUFFO0FBQ0Y7O0FBRUE7QUFDQTtBQUNBLFdBQVcsZ0JBQWdCO0FBQzNCLGFBQWEsdUJBQXVCO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFdBQVcsZUFBZTtBQUMxQixhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsV0FBVyxlQUFlO0FBQzFCLGFBQWEsT0FBTztBQUNwQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FB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QTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZ0VBQWdFOztBQUVoRTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkM7O0FBRTdDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEdBQUc7O0FB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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUgsUUFBUSxTQUFTO0FBQ2pCO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFNBQVM7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QyxpREFBaUQ7QUFDeEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxpREFBaUQ7QUFDakQsVUFBVSx3Q0FBd0M7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxnQkFBZ0I7QUFDM0I7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxNQUFNO0FBQ2pCLFdBQVcsTUFBTTtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxJQUFJO0FBQ0o7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjs7QUFFQTs7QUFFQSxDQUFDOzs7O0FBSUQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUFLQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7O0FBRUEsUUFBUSxHQUFHO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7O0FBR0E7Ozs7QUFJQTs7QUFFQTs7QUFFQTtBQUNBOzs7O0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZ0JBQWdCLFNBQVM7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7O0FBRUE7O0FBRUEsY0FBYyxTQUFTO0FBQ3ZCO0FBQ0E7O0FBRUE7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7O0FBR0Q7OztBQUdBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsSUFBSTtBQUNKO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxJQUFJO0FBQ0o7O0FBRUE7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBOztBQUVBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOzs7QUFHQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsVUFBVSxPQUFPO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxVQUFVLE9BQU87QUFDakIsMEJBQTBCLHdCQUF3Qjs7QUFFbEQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxFQUFFOztBQUVGO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0EsMENBQTBDO0FBQzFDLEVBQUU7QUFDRjtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7Ozs7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQjs7QUFFbkI7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsVUFBVSxjQUFjO0FBQ3hCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTs7QUFFUjtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsTUFBTTs7QUFFTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsd0NBQXdDLHNDQUFzQztBQUM5RSxvQ0FBb0MsdUNBQXVDO0FBQzNFLG9DQUFvQyxzQ0FBc0M7QUFDMUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUixPQUFPO0FBQ1A7QUFDQSxNQUFNO0FBQ04sS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFdBQVc7O0FBRVg7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsVUFBVTs7QUFFVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7O0FBRVg7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7O0FBRVI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ04sS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU07O0FBRU47QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLG9DQUFvQztBQUNwQyxxQ0FBcUM7QUFDckMsb0NBQW9DO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsQ0FBQzs7O0FBR0Q7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUFLQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7Ozs7O0FBS0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLENBQUM7O0FBRUQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7Ozs7O0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEVBQUU7QUFDRjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsVUFBVSxTQUFTO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSwrQkFBK0I7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FBS0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSx1QkFBdUIsYUFBYTtBQUNwQyxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEVBQUU7QUFDRjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7O0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLG9CQUFvQixTQUFTO0FBQzdCOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxJQUFJO0FBQ0osR0FBRztBQUNILEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsQ0FBQzs7O0FBR0Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSixHQUFHO0FBQ0g7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSixFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILEVBQUU7QUFDRjtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEOztBQUVBOzs7QUFHQTs7QUFFQTs7OztBQUlBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsY0FBYzs7QUFFZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7Ozs7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsUUFBUSxnQkFBZ0I7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsaUJBQWlCLGdCQUFnQjtBQUNqQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsQ0FBQztBQUNEOztBQUVBOztBQUVBOzs7O0FBSUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOzs7QUFHQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxFQUFFO0FBQ0Y7O0FBRUEsRUFBRTtBQUNGO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLFFBQVEsT0FBTztBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQSxzQkFBc0I7O0FBRXRCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxRQUFRLE9BQU87QUFDZjs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLElBQUk7QUFDSjs7QUFFQTtBQUNBLElBQUk7QUFDSjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7O0FBR0Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRSxnQkFBZ0I7QUFDbEI7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLFdBQVc7O0FBRVg7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsRUFBRTs7QUFFRjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSwyQ0FBMkM7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esb0RBQW9EO0FBQ3BEOztBQUVBO0FBQ0E7O0FBRUEsY0FBYyxzQkFBc0I7QUFDcEM7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsK0RBQStEO0FBQy9EOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsVUFBVSxjQUFjOztBQUV4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLG1CQUFtQjtBQUNwQzs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLHVDQUF1QztBQUNqRTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsdURBQXVEO0FBQzlFOztBQUVBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxHQUFHO0FBQ0gsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLElBQUk7QUFDSjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLLCtDQUErQztBQUNwRDtBQUNBOztBQUVBO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxzQ0FBc0M7QUFDdEM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLEVBQUU7QUFDRjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxxQ0FBcUMsY0FBYztBQUNuRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLENBQUM7O0FBRUQsY0FBYyxxQ0FBcUM7QUFDbkQ7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQztBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7O0FBRUE7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsQ0FBQzs7O0FBR0Q7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsMkNBQTJDLE9BQU87QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEI7O0FBRTlCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsT0FBTztBQUNqQjs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLGdCQUFnQixnQkFBZ0I7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxRQUFRLCtCQUErQjtBQUN2QztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsdUNBQXVDLE9BQU87QUFDOUM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsd0NBQXdDLE9BQU87QUFDL0M7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxTQUFTLHFDQUFxQztBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSCxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILEVBQUU7O0FBRUY7QUFDQTtBQUNBOztBQUVBLFNBQVMsOEJBQThCO0FBQ3ZDOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNILEVBQUU7O0FBRUY7QUFDQTtBQUNBLDZCQUE2QjtBQUM3QjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxZQUFZLE9BQU87QUFDbkI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxFQUFFOztBQUVGO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEdBQUc7QUFDSDtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxTQUFTLFdBQVc7QUFDcEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsQ0FBQztBQUNEOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOzs7O0FBSUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLCtDQUErQyxjQUFjLFdBQVc7QUFDeEUsbUJBQW1CLFVBQVU7QUFDN0I7QUFDQSxzQkFBc0IsY0FBYyxzQkFBc0IsZ0JBQWdCO0FBQzFFLGdCQUFnQixXQUFXLFlBQVk7QUFDdkMsY0FBYztBQUNkOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGLENBQUM7OztBQUdEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSwrREFBK0Q7QUFDM0U7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsUUFBUSxPQUFPOztBQUVmO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxJQUFJO0FBQ0o7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBLGFBQWE7O0FBRWI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUEsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsZ0JBQWdCO0FBQ2xDO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCOztBQUVqQjtBQUNBOztBQUVBLFVBQVUsT0FBTztBQUNqQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7O0FBRUE7QUFDQTtBQUNBOztBQUVBLFdBQVcsU0FBUztBQUNwQjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsQ0FBQzs7O0FBR0Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOzs7OztBQUtBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXOztBQUVYO0FBQ0E7QUFDQTtBQUNBLFFBQVEsT0FBTztBQUNmO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSxnQkFBZ0I7QUFDeEI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKLGlEQUFpRCwwQkFBMEI7QUFDM0U7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxVQUFVLGdCQUFnQjtBQUMxQjtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsMkJBQTJCO0FBQzNCO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7OztBQUdEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7Ozs7O0FBS0Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7Ozs7O0FBS0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxJQUFJO0FBQ0o7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILEVBQUU7O0FBRUY7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxDQUFDOzs7OztBQUtEOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7O0FBRUEsaUNBQWlDO0FBQ2pDO0FBQ0E7O0FBRUEsSUFBSTtBQUNKOztBQUVBLElBQUk7QUFDSjtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBLFdBQVcsU0FBUztBQUNwQjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7Ozs7QUFLRDs7O0FBR0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHNDQUFzQztBQUN0QztBQUNBO0FBQ0E7O0FBRUE7O0FBRUEseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsOENBQThDO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsMkNBQTJDO0FBQzNDOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSxLQUFLO0FBQ2Y7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxpREFBaUQ7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxDQUFDOztBQUVEOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7O0FBR0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxxQ0FBcUM7O0FBRXBEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7O0FBRUE7O0FBRUE7Ozs7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsSUFBSTs7QUFFSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSCxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBOztBQUVBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVILEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLEtBQUs7QUFDTDs7QUFFQSxXQUFXO0FBQ1gsR0FBRztBQUNIO0FBQ0EsQ0FBQzs7O0FBR0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7O0FBRWhCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7O0FBRWhCLGdEQUFnRDtBQUNoRDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLG1CQUFtQjtBQUNuQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSx3REFBd0Q7QUFDeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCOztBQUVqQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxJQUFJOztBQUVKO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLFNBQVM7QUFDVDs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsaUJBQWlCO0FBQ2pCLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrREFBa0Q7O0FBRWxEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsMkJBQTJCOztBQUUzQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0Esa0NBQWtDOztBQUVsQztBQUNBLHNCQUFzQjtBQUN0QiwyQkFBMkI7O0FBRTNCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE9BQU87O0FBRVA7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNEQUFzRDtBQUN0RDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLENBQUM7OztBQUdEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7OztBQUdBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLElBQUk7QUFDSjs7QUFFQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsSUFBSTtBQUNKO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsRUFBRTs7QUFFRjtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLENBQUM7OztBQUdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUFLQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsUUFBUTs7QUFFUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBLG1EQUFtRDtBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsdUJBQXVCO0FBQ2xDLFdBQVcseUJBQXlCO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOzs7OztBQUtEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCO0FBQy9CLGFBQWEsdUNBQXVDO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07O0FBRU47QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7Ozs7O0FBS0Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxJQUFJO0FBQ0o7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQSxDQUFDOzs7OztBQUtEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7OztBQUdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsSUFBSTtBQUNKLEdBQUc7QUFDSDs7QUFFQTtBQUNBOzs7OztBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7Ozs7O0FBS0Q7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGOzs7OztBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EscURBQXFEO0FBQ3JEOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLG1CQUFtQjs7QUFFbkI7QUFDQTs7QUFFQTtBQUNBOztBQUVBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEdBQUc7QUFDSDtBQUNBLENBQUM7O0FBRUQ7QUFDQSxjQUFjLHNEQUFzRDtBQUNwRTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsSUFBSTtBQUNKO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOzs7QUFHRDtBQUNBLGNBQWMsbUNBQW1DO0FBQ2pELGVBQWUsNkRBQTZEO0FBQzVFOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQSxFQUFFO0FBQ0YsQ0FBQzs7O0FBR0Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7Ozs7O0FBS0Q7O0FBRUE7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0EsRUFBRTtBQUNGOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxLQUFLLElBQTBDO0FBQy9DLENBQUMsaUNBQWtCLEVBQUUsbUNBQUU7QUFDdkI7QUFDQSxFQUFFO0FBQUEsb0dBQUU7QUFDSjs7Ozs7QUFLQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQUtBO0FBQ0EsQ0FBQyIsImZpbGUiOiI2NS5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8qIVxuICogalF1ZXJ5IEphdmFTY3JpcHQgTGlicmFyeSB2My40LjFcbiAqIGh0dHBzOi8vanF1ZXJ5LmNvbS9cbiAqXG4gKiBJbmNsdWRlcyBTaXp6bGUuanNcbiAqIGh0dHBzOi8vc2l6emxlanMuY29tL1xuICpcbiAqIENvcHlyaWdodCBKUyBGb3VuZGF0aW9uIGFuZCBvdGhlciBjb250cmlidXRvcnNcbiAqIFJlbGVhc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZVxuICogaHR0cHM6Ly9qcXVlcnkub3JnL2xpY2Vuc2VcbiAqXG4gKiBEYXRlOiAyMDE5LTA1LTAxVDIxOjA0WlxuICovXG4oIGZ1bmN0aW9uKCBnbG9iYWwsIGZhY3RvcnkgKSB7XG5cblx0XCJ1c2Ugc3RyaWN0XCI7XG5cblx0aWYgKCB0eXBlb2YgbW9kdWxlID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBtb2R1bGUuZXhwb3J0cyA9PT0gXCJvYmplY3RcIiApIHtcblxuXHRcdC8vIEZvciBDb21tb25KUyBhbmQgQ29tbW9uSlMtbGlrZSBlbnZpcm9ubWVudHMgd2hlcmUgYSBwcm9wZXIgYHdpbmRvd2Bcblx0XHQvLyBpcyBwcmVzZW50LCBleGVjdXRlIHRoZSBmYWN0b3J5IGFuZCBnZXQgalF1ZXJ5LlxuXHRcdC8vIEZvciBlbnZpcm9ubWVudHMgdGhhdCBkbyBub3QgaGF2ZSBhIGB3aW5kb3dgIHdpdGggYSBgZG9jdW1lbnRgXG5cdFx0Ly8gKHN1Y2ggYXMgTm9kZS5qcyksIGV4cG9zZSBhIGZhY3RvcnkgYXMgbW9kdWxlLmV4cG9ydHMuXG5cdFx0Ly8gVGhpcyBhY2NlbnR1YXRlcyB0aGUgbmVlZCBmb3IgdGhlIGNyZWF0aW9uIG9mIGEgcmVhbCBgd2luZG93YC5cblx0XHQvLyBlLmcuIHZhciBqUXVlcnkgPSByZXF1aXJlKFwianF1ZXJ5XCIpKHdpbmRvdyk7XG5cdFx0Ly8gU2VlIHRpY2tldCAjMTQ1NDkgZm9yIG1vcmUgaW5mby5cblx0XHRtb2R1bGUuZXhwb3J0cyA9IGdsb2JhbC5kb2N1bWVudCA/XG5cdFx0XHRmYWN0b3J5KCBnbG9iYWwsIHRydWUgKSA6XG5cdFx0XHRmdW5jdGlvbiggdyApIHtcblx0XHRcdFx0aWYgKCAhdy5kb2N1bWVudCApIHtcblx0XHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IoIFwialF1ZXJ5IHJlcXVpcmVzIGEgd2luZG93IHdpdGggYSBkb2N1bWVudFwiICk7XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIGZhY3RvcnkoIHcgKTtcblx0XHRcdH07XG5cdH0gZWxzZSB7XG5cdFx0ZmFjdG9yeSggZ2xvYmFsICk7XG5cdH1cblxuLy8gUGFzcyB0aGlzIGlmIHdpbmRvdyBpcyBub3QgZGVmaW5lZCB5ZXRcbn0gKSggdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiA/IHdpbmRvdyA6IHRoaXMsIGZ1bmN0aW9uKCB3aW5kb3csIG5vR2xvYmFsICkge1xuXG4vLyBFZGdlIDw9IDEyIC0gMTMrLCBGaXJlZm94IDw9MTggLSA0NSssIElFIDEwIC0gMTEsIFNhZmFyaSA1LjEgLSA5KywgaU9TIDYgLSA5LjFcbi8vIHRocm93IGV4Y2VwdGlvbnMgd2hlbiBub24tc3RyaWN0IGNvZGUgKGUuZy4sIEFTUC5ORVQgNC41KSBhY2Nlc3NlcyBzdHJpY3QgbW9kZVxuLy8gYXJndW1lbnRzLmNhbGxlZS5jYWxsZXIgKHRyYWMtMTMzMzUpLiBCdXQgYXMgb2YgalF1ZXJ5IDMuMCAoMjAxNiksIHN0cmljdCBtb2RlIHNob3VsZCBiZSBjb21tb25cbi8vIGVub3VnaCB0aGF0IGFsbCBzdWNoIGF0dGVtcHRzIGFyZSBndWFyZGVkIGluIGEgdHJ5IGJsb2NrLlxuXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBhcnIgPSBbXTtcblxudmFyIGRvY3VtZW50ID0gd2luZG93LmRvY3VtZW50O1xuXG52YXIgZ2V0UHJvdG8gPSBPYmplY3QuZ2V0UHJvdG90eXBlT2Y7XG5cbnZhciBzbGljZSA9IGFyci5zbGljZTtcblxudmFyIGNvbmNhdCA9IGFyci5jb25jYXQ7XG5cbnZhciBwdXNoID0gYXJyLnB1c2g7XG5cbnZhciBpbmRleE9mID0gYXJyLmluZGV4T2Y7XG5cbnZhciBjbGFzczJ0eXBlID0ge307XG5cbnZhciB0b1N0cmluZyA9IGNsYXNzMnR5cGUudG9TdHJpbmc7XG5cbnZhciBoYXNPd24gPSBjbGFzczJ0eXBlLmhhc093blByb3BlcnR5O1xuXG52YXIgZm5Ub1N0cmluZyA9IGhhc093bi50b1N0cmluZztcblxudmFyIE9iamVjdEZ1bmN0aW9uU3RyaW5nID0gZm5Ub1N0cmluZy5jYWxsKCBPYmplY3QgKTtcblxudmFyIHN1cHBvcnQgPSB7fTtcblxudmFyIGlzRnVuY3Rpb24gPSBmdW5jdGlvbiBpc0Z1bmN0aW9uKCBvYmogKSB7XG5cbiAgICAgIC8vIFN1cHBvcnQ6IENocm9tZSA8PTU3LCBGaXJlZm94IDw9NTJcbiAgICAgIC8vIEluIHNvbWUgYnJvd3NlcnMsIHR5cGVvZiByZXR1cm5zIFwiZnVuY3Rpb25cIiBmb3IgSFRNTCA8b2JqZWN0PiBlbGVtZW50c1xuICAgICAgLy8gKGkuZS4sIGB0eXBlb2YgZG9jdW1lbnQuY3JlYXRlRWxlbWVudCggXCJvYmplY3RcIiApID09PSBcImZ1bmN0aW9uXCJgKS5cbiAgICAgIC8vIFdlIGRvbid0IHdhbnQgdG8gY2xhc3NpZnkgKmFueSogRE9NIG5vZGUgYXMgYSBmdW5jdGlvbi5cbiAgICAgIHJldHVybiB0eXBlb2Ygb2JqID09PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIG9iai5ub2RlVHlwZSAhPT0gXCJudW1iZXJcIjtcbiAgfTtcblxuXG52YXIgaXNXaW5kb3cgPSBmdW5jdGlvbiBpc1dpbmRvdyggb2JqICkge1xuXHRcdHJldHVybiBvYmogIT0gbnVsbCAmJiBvYmogPT09IG9iai53aW5kb3c7XG5cdH07XG5cblxuXG5cblx0dmFyIHByZXNlcnZlZFNjcmlwdEF0dHJpYnV0ZXMgPSB7XG5cdFx0dHlwZTogdHJ1ZSxcblx0XHRzcmM6IHRydWUsXG5cdFx0bm9uY2U6IHRydWUsXG5cdFx0bm9Nb2R1bGU6IHRydWVcblx0fTtcblxuXHRmdW5jdGlvbiBET01FdmFsKCBjb2RlLCBub2RlLCBkb2MgKSB7XG5cdFx0ZG9jID0gZG9jIHx8IGRvY3VtZW50O1xuXG5cdFx0dmFyIGksIHZhbCxcblx0XHRcdHNjcmlwdCA9IGRvYy5jcmVhdGVFbGVtZW50KCBcInNjcmlwdFwiICk7XG5cblx0XHRzY3JpcHQudGV4dCA9IGNvZGU7XG5cdFx0aWYgKCBub2RlICkge1xuXHRcdFx0Zm9yICggaSBpbiBwcmVzZXJ2ZWRTY3JpcHRBdHRyaWJ1dGVzICkge1xuXG5cdFx0XHRcdC8vIFN1cHBvcnQ6IEZpcmVmb3ggNjQrLCBFZGdlIDE4K1xuXHRcdFx0XHQvLyBTb21lIGJyb3dzZXJzIGRvbid0IHN1cHBvcnQgdGhlIFwibm9uY2VcIiBwcm9wZXJ0eSBvbiBzY3JpcHRzLlxuXHRcdFx0XHQvLyBPbiB0aGUgb3RoZXIgaGFuZCwganVzdCB1c2luZyBgZ2V0QXR0cmlidXRlYCBpcyBub3QgZW5vdWdoIGFzXG5cdFx0XHRcdC8vIHRoZSBgbm9uY2VgIGF0dHJpYnV0ZSBpcyByZXNldCB0byBhbiBlbXB0eSBzdHJpbmcgd2hlbmV2ZXIgaXRcblx0XHRcdFx0Ly8gYmVjb21lcyBicm93c2luZy1jb250ZXh0IGNvbm5lY3RlZC5cblx0XHRcdFx0Ly8gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS93aGF0d2cvaHRtbC9pc3N1ZXMvMjM2OVxuXHRcdFx0XHQvLyBTZWUgaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy8jbm9uY2UtYXR0cmlidXRlc1xuXHRcdFx0XHQvLyBUaGUgYG5vZGUuZ2V0QXR0cmlidXRlYCBjaGVjayB3YXMgYWRkZWQgZm9yIHRoZSBzYWtlIG9mXG5cdFx0XHRcdC8vIGBqUXVlcnkuZ2xvYmFsRXZhbGAgc28gdGhhdCBpdCBjYW4gZmFrZSBhIG5vbmNlLWNvbnRhaW5pbmcgbm9kZVxuXHRcdFx0XHQvLyB2aWEgYW4gb2JqZWN0LlxuXHRcdFx0XHR2YWwgPSBub2RlWyBpIF0gfHwgbm9kZS5nZXRBdHRyaWJ1dGUgJiYgbm9kZS5nZXRBdHRyaWJ1dGUoIGkgKTtcblx0XHRcdFx0aWYgKCB2YWwgKSB7XG5cdFx0XHRcdFx0c2NyaXB0LnNldEF0dHJpYnV0ZSggaSwgdmFsICk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdFx0ZG9jLmhlYWQuYXBwZW5kQ2hpbGQoIHNjcmlwdCApLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoIHNjcmlwdCApO1xuXHR9XG5cblxuZnVuY3Rpb24gdG9UeXBlKCBvYmogKSB7XG5cdGlmICggb2JqID09IG51bGwgKSB7XG5cdFx0cmV0dXJuIG9iaiArIFwiXCI7XG5cdH1cblxuXHQvLyBTdXBwb3J0OiBBbmRyb2lkIDw9Mi4zIG9ubHkgKGZ1bmN0aW9uaXNoIFJlZ0V4cClcblx0cmV0dXJuIHR5cGVvZiBvYmogPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIG9iaiA9PT0gXCJmdW5jdGlvblwiID9cblx0XHRjbGFzczJ0eXBlWyB0b1N0cmluZy5jYWxsKCBvYmogKSBdIHx8IFwib2JqZWN0XCIgOlxuXHRcdHR5cGVvZiBvYmo7XG59XG4vKiBnbG9iYWwgU3ltYm9sICovXG4vLyBEZWZpbmluZyB0aGlzIGdsb2JhbCBpbiAuZXNsaW50cmMuanNvbiB3b3VsZCBjcmVhdGUgYSBkYW5nZXIgb2YgdXNpbmcgdGhlIGdsb2JhbFxuLy8gdW5ndWFyZGVkIGluIGFub3RoZXIgcGxhY2UsIGl0IHNlZW1zIHNhZmVyIHRvIGRlZmluZSBnbG9iYWwgb25seSBmb3IgdGhpcyBtb2R1bGVcblxuXG5cbnZhclxuXHR2ZXJzaW9uID0gXCIzLjQuMVwiLFxuXG5cdC8vIERlZmluZSBhIGxvY2FsIGNvcHkgb2YgalF1ZXJ5XG5cdGpRdWVyeSA9IGZ1bmN0aW9uKCBzZWxlY3RvciwgY29udGV4dCApIHtcblxuXHRcdC8vIFRoZSBqUXVlcnkgb2JqZWN0IGlzIGFjdHVhbGx5IGp1c3QgdGhlIGluaXQgY29uc3RydWN0b3IgJ2VuaGFuY2VkJ1xuXHRcdC8vIE5lZWQgaW5pdCBpZiBqUXVlcnkgaXMgY2FsbGVkIChqdXN0IGFsbG93IGVycm9yIHRvIGJlIHRocm93biBpZiBub3QgaW5jbHVkZWQpXG5cdFx0cmV0dXJuIG5ldyBqUXVlcnkuZm4uaW5pdCggc2VsZWN0b3IsIGNvbnRleHQgKTtcblx0fSxcblxuXHQvLyBTdXBwb3J0OiBBbmRyb2lkIDw9NC4wIG9ubHlcblx0Ly8gTWFrZSBzdXJlIHdlIHRyaW0gQk9NIGFuZCBOQlNQXG5cdHJ0cmltID0gL15bXFxzXFx1RkVGRlxceEEwXSt8W1xcc1xcdUZFRkZcXHhBMF0rJC9nO1xuXG5qUXVlcnkuZm4gPSBqUXVlcnkucHJvdG90eXBlID0ge1xuXG5cdC8vIFRoZSBjdXJyZW50IHZlcnNpb24gb2YgalF1ZXJ5IGJlaW5nIHVzZWRcblx0anF1ZXJ5OiB2ZXJzaW9uLFxuXG5cdGNvbnN0cnVjdG9yOiBqUXVlcnksXG5cblx0Ly8gVGhlIGRlZmF1bHQgbGVuZ3RoIG9mIGEgalF1ZXJ5IG9iamVjdCBpcyAwXG5cdGxlbmd0aDogMCxcblxuXHR0b0FycmF5OiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gc2xpY2UuY2FsbCggdGhpcyApO1xuXHR9LFxuXG5cdC8vIEdldCB0aGUgTnRoIGVsZW1lbnQgaW4gdGhlIG1hdGNoZWQgZWxlbWVudCBzZXQgT1Jcblx0Ly8gR2V0IHRoZSB3aG9sZSBtYXRjaGVkIGVsZW1lbnQgc2V0IGFzIGEgY2xlYW4gYXJyYXlcblx0Z2V0OiBmdW5jdGlvbiggbnVtICkge1xuXG5cdFx0Ly8gUmV0dXJuIGFsbCB0aGUgZWxlbWVudHMgaW4gYSBjbGVhbiBhcnJheVxuXHRcdGlmICggbnVtID09IG51bGwgKSB7XG5cdFx0XHRyZXR1cm4gc2xpY2UuY2FsbCggdGhpcyApO1xuXHRcdH1cblxuXHRcdC8vIFJldHVybiBqdXN0IHRoZSBvbmUgZWxlbWVudCBmcm9tIHRoZSBzZXRcblx0XHRyZXR1cm4gbnVtIDwgMCA/IHRoaXNbIG51bSArIHRoaXMubGVuZ3RoIF0gOiB0aGlzWyBudW0gXTtcblx0fSxcblxuXHQvLyBUYWtlIGFuIGFycmF5IG9mIGVsZW1lbnRzIGFuZCBwdXNoIGl0IG9udG8gdGhlIHN0YWNrXG5cdC8vIChyZXR1cm5pbmcgdGhlIG5ldyBtYXRjaGVkIGVsZW1lbnQgc2V0KVxuXHRwdXNoU3RhY2s6IGZ1bmN0aW9uKCBlbGVtcyApIHtcblxuXHRcdC8vIEJ1aWxkIGEgbmV3IGpRdWVyeSBtYXRjaGVkIGVsZW1lbnQgc2V0XG5cdFx0dmFyIHJldCA9IGpRdWVyeS5tZXJnZSggdGhpcy5jb25zdHJ1Y3RvcigpLCBlbGVtcyApO1xuXG5cdFx0Ly8gQWRkIHRoZSBvbGQgb2JqZWN0IG9udG8gdGhlIHN0YWNrIChhcyBhIHJlZmVyZW5jZSlcblx0XHRyZXQucHJldk9iamVjdCA9IHRoaXM7XG5cblx0XHQvLyBSZXR1cm4gdGhlIG5ld2x5LWZvcm1lZCBlbGVtZW50IHNldFxuXHRcdHJldHVybiByZXQ7XG5cdH0sXG5cblx0Ly8gRXhlY3V0ZSBhIGNhbGxiYWNrIGZvciBldmVyeSBlbGVtZW50IGluIHRoZSBtYXRjaGVkIHNldC5cblx0ZWFjaDogZnVuY3Rpb24oIGNhbGxiYWNrICkge1xuXHRcdHJldHVybiBqUXVlcnkuZWFjaCggdGhpcywgY2FsbGJhY2sgKTtcblx0fSxcblxuXHRtYXA6IGZ1bmN0aW9uKCBjYWxsYmFjayApIHtcblx0XHRyZXR1cm4gdGhpcy5wdXNoU3RhY2soIGpRdWVyeS5tYXAoIHRoaXMsIGZ1bmN0aW9uKCBlbGVtLCBpICkge1xuXHRcdFx0cmV0dXJuIGNhbGxiYWNrLmNhbGwoIGVsZW0sIGksIGVsZW0gKTtcblx0XHR9ICkgKTtcblx0fSxcblxuXHRzbGljZTogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMucHVzaFN0YWNrKCBzbGljZS5hcHBseSggdGhpcywgYXJndW1lbnRzICkgKTtcblx0fSxcblxuXHRmaXJzdDogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuZXEoIDAgKTtcblx0fSxcblxuXHRsYXN0OiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5lcSggLTEgKTtcblx0fSxcblxuXHRlcTogZnVuY3Rpb24oIGkgKSB7XG5cdFx0dmFyIGxlbiA9IHRoaXMubGVuZ3RoLFxuXHRcdFx0aiA9ICtpICsgKCBpIDwgMCA/IGxlbiA6IDAgKTtcblx0XHRyZXR1cm4gdGhpcy5wdXNoU3RhY2soIGogPj0gMCAmJiBqIDwgbGVuID8gWyB0aGlzWyBqIF0gXSA6IFtdICk7XG5cdH0sXG5cblx0ZW5kOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5wcmV2T2JqZWN0IHx8IHRoaXMuY29uc3RydWN0b3IoKTtcblx0fSxcblxuXHQvLyBGb3IgaW50ZXJuYWwgdXNlIG9ubHkuXG5cdC8vIEJlaGF2ZXMgbGlrZSBhbiBBcnJheSdzIG1ldGhvZCwgbm90IGxpa2UgYSBqUXVlcnkgbWV0aG9kLlxuXHRwdXNoOiBwdXNoLFxuXHRzb3J0OiBhcnIuc29ydCxcblx0c3BsaWNlOiBhcnIuc3BsaWNlXG59O1xuXG5qUXVlcnkuZXh0ZW5kID0galF1ZXJ5LmZuLmV4dGVuZCA9IGZ1bmN0aW9uKCkge1xuXHR2YXIgb3B0aW9ucywgbmFtZSwgc3JjLCBjb3B5LCBjb3B5SXNBcnJheSwgY2xvbmUsXG5cdFx0dGFyZ2V0ID0gYXJndW1lbnRzWyAwIF0gfHwge30sXG5cdFx0aSA9IDEsXG5cdFx0bGVuZ3RoID0gYXJndW1lbnRzLmxlbmd0aCxcblx0XHRkZWVwID0gZmFsc2U7XG5cblx0Ly8gSGFuZGxlIGEgZGVlcCBjb3B5IHNpdHVhdGlvblxuXHRpZiAoIHR5cGVvZiB0YXJnZXQgPT09IFwiYm9vbGVhblwiICkge1xuXHRcdGRlZXAgPSB0YXJnZXQ7XG5cblx0XHQvLyBTa2lwIHRoZSBib29sZWFuIGFuZCB0aGUgdGFyZ2V0XG5cdFx0dGFyZ2V0ID0gYXJndW1lbnRzWyBpIF0gfHwge307XG5cdFx0aSsrO1xuXHR9XG5cblx0Ly8gSGFuZGxlIGNhc2Ugd2hlbiB0YXJnZXQgaXMgYSBzdHJpbmcgb3Igc29tZXRoaW5nIChwb3NzaWJsZSBpbiBkZWVwIGNvcHkpXG5cdGlmICggdHlwZW9mIHRhcmdldCAhPT0gXCJvYmplY3RcIiAmJiAhaXNGdW5jdGlvbiggdGFyZ2V0ICkgKSB7XG5cdFx0dGFyZ2V0ID0ge307XG5cdH1cblxuXHQvLyBFeHRlbmQgalF1ZXJ5IGl0c2VsZiBpZiBvbmx5IG9uZSBhcmd1bWVudCBpcyBwYXNzZWRcblx0aWYgKCBpID09PSBsZW5ndGggKSB7XG5cdFx0dGFyZ2V0ID0gdGhpcztcblx0XHRpLS07XG5cdH1cblxuXHRmb3IgKCA7IGkgPCBsZW5ndGg7IGkrKyApIHtcblxuXHRcdC8vIE9ubHkgZGVhbCB3aXRoIG5vbi1udWxsL3VuZGVmaW5lZCB2YWx1ZXNcblx0XHRpZiAoICggb3B0aW9ucyA9IGFyZ3VtZW50c1sgaSBdICkgIT0gbnVsbCApIHtcblxuXHRcdFx0Ly8gRXh0ZW5kIHRoZSBiYXNlIG9iamVjdFxuXHRcdFx0Zm9yICggbmFtZSBpbiBvcHRpb25zICkge1xuXHRcdFx0XHRjb3B5ID0gb3B0aW9uc1sgbmFtZSBdO1xuXG5cdFx0XHRcdC8vIFByZXZlbnQgT2JqZWN0LnByb3RvdHlwZSBwb2xsdXRpb25cblx0XHRcdFx0Ly8gUHJldmVudCBuZXZlci1lbmRpbmcgbG9vcFxuXHRcdFx0XHRpZiAoIG5hbWUgPT09IFwiX19wcm90b19fXCIgfHwgdGFyZ2V0ID09PSBjb3B5ICkge1xuXHRcdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gUmVjdXJzZSBpZiB3ZSdyZSBtZXJnaW5nIHBsYWluIG9iamVjdHMgb3IgYXJyYXlzXG5cdFx0XHRcdGlmICggZGVlcCAmJiBjb3B5ICYmICggalF1ZXJ5LmlzUGxhaW5PYmplY3QoIGNvcHkgKSB8fFxuXHRcdFx0XHRcdCggY29weUlzQXJyYXkgPSBBcnJheS5pc0FycmF5KCBjb3B5ICkgKSApICkge1xuXHRcdFx0XHRcdHNyYyA9IHRhcmdldFsgbmFtZSBdO1xuXG5cdFx0XHRcdFx0Ly8gRW5zdXJlIHByb3BlciB0eXBlIGZvciB0aGUgc291cmNlIHZhbHVlXG5cdFx0XHRcdFx0aWYgKCBjb3B5SXNBcnJheSAmJiAhQXJyYXkuaXNBcnJheSggc3JjICkgKSB7XG5cdFx0XHRcdFx0XHRjbG9uZSA9IFtdO1xuXHRcdFx0XHRcdH0gZWxzZSBpZiAoICFjb3B5SXNBcnJheSAmJiAhalF1ZXJ5LmlzUGxhaW5PYmplY3QoIHNyYyApICkge1xuXHRcdFx0XHRcdFx0Y2xvbmUgPSB7fTtcblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0Y2xvbmUgPSBzcmM7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGNvcHlJc0FycmF5ID0gZmFsc2U7XG5cblx0XHRcdFx0XHQvLyBOZXZlciBtb3ZlIG9yaWdpbmFsIG9iamVjdHMsIGNsb25lIHRoZW1cblx0XHRcdFx0XHR0YXJnZXRbIG5hbWUgXSA9IGpRdWVyeS5leHRlbmQoIGRlZXAsIGNsb25lLCBjb3B5ICk7XG5cblx0XHRcdFx0Ly8gRG9uJ3QgYnJpbmcgaW4gdW5kZWZpbmVkIHZhbHVlc1xuXHRcdFx0XHR9IGVsc2UgaWYgKCBjb3B5ICE9PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRcdFx0dGFyZ2V0WyBuYW1lIF0gPSBjb3B5O1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0Ly8gUmV0dXJuIHRoZSBtb2RpZmllZCBvYmplY3Rcblx0cmV0dXJuIHRhcmdldDtcbn07XG5cbmpRdWVyeS5leHRlbmQoIHtcblxuXHQvLyBVbmlxdWUgZm9yIGVhY2ggY29weSBvZiBqUXVlcnkgb24gdGhlIHBhZ2Vcblx0ZXhwYW5kbzogXCJqUXVlcnlcIiArICggdmVyc2lvbiArIE1hdGgucmFuZG9tKCkgKS5yZXBsYWNlKCAvXFxEL2csIFwiXCIgKSxcblxuXHQvLyBBc3N1bWUgalF1ZXJ5IGlzIHJlYWR5IHdpdGhvdXQgdGhlIHJlYWR5IG1vZHVsZVxuXHRpc1JlYWR5OiB0cnVlLFxuXG5cdGVycm9yOiBmdW5jdGlvbiggbXNnICkge1xuXHRcdHRocm93IG5ldyBFcnJvciggbXNnICk7XG5cdH0sXG5cblx0bm9vcDogZnVuY3Rpb24oKSB7fSxcblxuXHRpc1BsYWluT2JqZWN0OiBmdW5jdGlvbiggb2JqICkge1xuXHRcdHZhciBwcm90bywgQ3RvcjtcblxuXHRcdC8vIERldGVjdCBvYnZpb3VzIG5lZ2F0aXZlc1xuXHRcdC8vIFVzZSB0b1N0cmluZyBpbnN0ZWFkIG9mIGpRdWVyeS50eXBlIHRvIGNhdGNoIGhvc3Qgb2JqZWN0c1xuXHRcdGlmICggIW9iaiB8fCB0b1N0cmluZy5jYWxsKCBvYmogKSAhPT0gXCJbb2JqZWN0IE9iamVjdF1cIiApIHtcblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9XG5cblx0XHRwcm90byA9IGdldFByb3RvKCBvYmogKTtcblxuXHRcdC8vIE9iamVjdHMgd2l0aCBubyBwcm90b3R5cGUgKGUuZy4sIGBPYmplY3QuY3JlYXRlKCBudWxsIClgKSBhcmUgcGxhaW5cblx0XHRpZiAoICFwcm90byApIHtcblx0XHRcdHJldHVybiB0cnVlO1xuXHRcdH1cblxuXHRcdC8vIE9iamVjdHMgd2l0aCBwcm90b3R5cGUgYXJlIHBsYWluIGlmZiB0aGV5IHdlcmUgY29uc3RydWN0ZWQgYnkgYSBnbG9iYWwgT2JqZWN0IGZ1bmN0aW9uXG5cdFx0Q3RvciA9IGhhc093bi5jYWxsKCBwcm90bywgXCJjb25zdHJ1Y3RvclwiICkgJiYgcHJvdG8uY29uc3RydWN0b3I7XG5cdFx0cmV0dXJuIHR5cGVvZiBDdG9yID09PSBcImZ1bmN0aW9uXCIgJiYgZm5Ub1N0cmluZy5jYWxsKCBDdG9yICkgPT09IE9iamVjdEZ1bmN0aW9uU3RyaW5nO1xuXHR9LFxuXG5cdGlzRW1wdHlPYmplY3Q6IGZ1bmN0aW9uKCBvYmogKSB7XG5cdFx0dmFyIG5hbWU7XG5cblx0XHRmb3IgKCBuYW1lIGluIG9iaiApIHtcblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9XG5cdFx0cmV0dXJuIHRydWU7XG5cdH0sXG5cblx0Ly8gRXZhbHVhdGVzIGEgc2NyaXB0IGluIGEgZ2xvYmFsIGNvbnRleHRcblx0Z2xvYmFsRXZhbDogZnVuY3Rpb24oIGNvZGUsIG9wdGlvbnMgKSB7XG5cdFx0RE9NRXZhbCggY29kZSwgeyBub25jZTogb3B0aW9ucyAmJiBvcHRpb25zLm5vbmNlIH0gKTtcblx0fSxcblxuXHRlYWNoOiBmdW5jdGlvbiggb2JqLCBjYWxsYmFjayApIHtcblx0XHR2YXIgbGVuZ3RoLCBpID0gMDtcblxuXHRcdGlmICggaXNBcnJheUxpa2UoIG9iaiApICkge1xuXHRcdFx0bGVuZ3RoID0gb2JqLmxlbmd0aDtcblx0XHRcdGZvciAoIDsgaSA8IGxlbmd0aDsgaSsrICkge1xuXHRcdFx0XHRpZiAoIGNhbGxiYWNrLmNhbGwoIG9ialsgaSBdLCBpLCBvYmpbIGkgXSApID09PSBmYWxzZSApIHtcblx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH0gZWxzZSB7XG5cdFx0XHRmb3IgKCBpIGluIG9iaiApIHtcblx0XHRcdFx0aWYgKCBjYWxsYmFjay5jYWxsKCBvYmpbIGkgXSwgaSwgb2JqWyBpIF0gKSA9PT0gZmFsc2UgKSB7XG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblx0XHRyZXR1cm4gb2JqO1xuXHR9LFxuXG5cdC8vIFN1cHBvcnQ6IEFuZHJvaWQgPD00LjAgb25seVxuXHR0cmltOiBmdW5jdGlvbiggdGV4dCApIHtcblx0XHRyZXR1cm4gdGV4dCA9PSBudWxsID9cblx0XHRcdFwiXCIgOlxuXHRcdFx0KCB0ZXh0ICsgXCJcIiApLnJlcGxhY2UoIHJ0cmltLCBcIlwiICk7XG5cdH0sXG5cblx0Ly8gcmVzdWx0cyBpcyBmb3IgaW50ZXJuYWwgdXNhZ2Ugb25seVxuXHRtYWtlQXJyYXk6IGZ1bmN0aW9uKCBhcnIsIHJlc3VsdHMgKSB7XG5cdFx0dmFyIHJldCA9IHJlc3VsdHMgfHwgW107XG5cblx0XHRpZiAoIGFyciAhPSBudWxsICkge1xuXHRcdFx0aWYgKCBpc0FycmF5TGlrZSggT2JqZWN0KCBhcnIgKSApICkge1xuXHRcdFx0XHRqUXVlcnkubWVyZ2UoIHJldCxcblx0XHRcdFx0XHR0eXBlb2YgYXJyID09PSBcInN0cmluZ1wiID9cblx0XHRcdFx0XHRbIGFyciBdIDogYXJyXG5cdFx0XHRcdCk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRwdXNoLmNhbGwoIHJldCwgYXJyICk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHJldDtcblx0fSxcblxuXHRpbkFycmF5OiBmdW5jdGlvbiggZWxlbSwgYXJyLCBpICkge1xuXHRcdHJldHVybiBhcnIgPT0gbnVsbCA/IC0xIDogaW5kZXhPZi5jYWxsKCBhcnIsIGVsZW0sIGkgKTtcblx0fSxcblxuXHQvLyBTdXBwb3J0OiBBbmRyb2lkIDw9NC4wIG9ubHksIFBoYW50b21KUyAxIG9ubHlcblx0Ly8gcHVzaC5hcHBseShfLCBhcnJheWxpa2UpIHRocm93cyBvbiBhbmNpZW50IFdlYktpdFxuXHRtZXJnZTogZnVuY3Rpb24oIGZpcnN0LCBzZWNvbmQgKSB7XG5cdFx0dmFyIGxlbiA9ICtzZWNvbmQubGVuZ3RoLFxuXHRcdFx0aiA9IDAsXG5cdFx0XHRpID0gZmlyc3QubGVuZ3RoO1xuXG5cdFx0Zm9yICggOyBqIDwgbGVuOyBqKysgKSB7XG5cdFx0XHRmaXJzdFsgaSsrIF0gPSBzZWNvbmRbIGogXTtcblx0XHR9XG5cblx0XHRmaXJzdC5sZW5ndGggPSBpO1xuXG5cdFx0cmV0dXJuIGZpcnN0O1xuXHR9LFxuXG5cdGdyZXA6IGZ1bmN0aW9uKCBlbGVtcywgY2FsbGJhY2ssIGludmVydCApIHtcblx0XHR2YXIgY2FsbGJhY2tJbnZlcnNlLFxuXHRcdFx0bWF0Y2hlcyA9IFtdLFxuXHRcdFx0aSA9IDAsXG5cdFx0XHRsZW5ndGggPSBlbGVtcy5sZW5ndGgsXG5cdFx0XHRjYWxsYmFja0V4cGVjdCA9ICFpbnZlcnQ7XG5cblx0XHQvLyBHbyB0aHJvdWdoIHRoZSBhcnJheSwgb25seSBzYXZpbmcgdGhlIGl0ZW1zXG5cdFx0Ly8gdGhhdCBwYXNzIHRoZSB2YWxpZGF0b3IgZnVuY3Rpb25cblx0XHRmb3IgKCA7IGkgPCBsZW5ndGg7IGkrKyApIHtcblx0XHRcdGNhbGxiYWNrSW52ZXJzZSA9ICFjYWxsYmFjayggZWxlbXNbIGkgXSwgaSApO1xuXHRcdFx0aWYgKCBjYWxsYmFja0ludmVyc2UgIT09IGNhbGxiYWNrRXhwZWN0ICkge1xuXHRcdFx0XHRtYXRjaGVzLnB1c2goIGVsZW1zWyBpIF0gKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRyZXR1cm4gbWF0Y2hlcztcblx0fSxcblxuXHQvLyBhcmcgaXMgZm9yIGludGVybmFsIHVzYWdlIG9ubHlcblx0bWFwOiBmdW5jdGlvbiggZWxlbXMsIGNhbGxiYWNrLCBhcmcgKSB7XG5cdFx0dmFyIGxlbmd0aCwgdmFsdWUsXG5cdFx0XHRpID0gMCxcblx0XHRcdHJldCA9IFtdO1xuXG5cdFx0Ly8gR28gdGhyb3VnaCB0aGUgYXJyYXksIHRyYW5zbGF0aW5nIGVhY2ggb2YgdGhlIGl0ZW1zIHRvIHRoZWlyIG5ldyB2YWx1ZXNcblx0XHRpZiAoIGlzQXJyYXlMaWtlKCBlbGVtcyApICkge1xuXHRcdFx0bGVuZ3RoID0gZWxlbXMubGVuZ3RoO1xuXHRcdFx0Zm9yICggOyBpIDwgbGVuZ3RoOyBpKysgKSB7XG5cdFx0XHRcdHZhbHVlID0gY2FsbGJhY2soIGVsZW1zWyBpIF0sIGksIGFyZyApO1xuXG5cdFx0XHRcdGlmICggdmFsdWUgIT0gbnVsbCApIHtcblx0XHRcdFx0XHRyZXQucHVzaCggdmFsdWUgKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0Ly8gR28gdGhyb3VnaCBldmVyeSBrZXkgb24gdGhlIG9iamVjdCxcblx0XHR9IGVsc2Uge1xuXHRcdFx0Zm9yICggaSBpbiBlbGVtcyApIHtcblx0XHRcdFx0dmFsdWUgPSBjYWxsYmFjayggZWxlbXNbIGkgXSwgaSwgYXJnICk7XG5cblx0XHRcdFx0aWYgKCB2YWx1ZSAhPSBudWxsICkge1xuXHRcdFx0XHRcdHJldC5wdXNoKCB2YWx1ZSApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gRmxhdHRlbiBhbnkgbmVzdGVkIGFycmF5c1xuXHRcdHJldHVybiBjb25jYXQuYXBwbHkoIFtdLCByZXQgKTtcblx0fSxcblxuXHQvLyBBIGdsb2JhbCBHVUlEIGNvdW50ZXIgZm9yIG9iamVjdHNcblx0Z3VpZDogMSxcblxuXHQvLyBqUXVlcnkuc3VwcG9ydCBpcyBub3QgdXNlZCBpbiBDb3JlIGJ1dCBvdGhlciBwcm9qZWN0cyBhdHRhY2ggdGhlaXJcblx0Ly8gcHJvcGVydGllcyB0byBpdCBzbyBpdCBuZWVkcyB0byBleGlzdC5cblx0c3VwcG9ydDogc3VwcG9ydFxufSApO1xuXG5pZiAoIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiApIHtcblx0alF1ZXJ5LmZuWyBTeW1ib2wuaXRlcmF0b3IgXSA9IGFyclsgU3ltYm9sLml0ZXJhdG9yIF07XG59XG5cbi8vIFBvcHVsYXRlIHRoZSBjbGFzczJ0eXBlIG1hcFxualF1ZXJ5LmVhY2goIFwiQm9vbGVhbiBOdW1iZXIgU3RyaW5nIEZ1bmN0aW9uIEFycmF5IERhdGUgUmVnRXhwIE9iamVjdCBFcnJvciBTeW1ib2xcIi5zcGxpdCggXCIgXCIgKSxcbmZ1bmN0aW9uKCBpLCBuYW1lICkge1xuXHRjbGFzczJ0eXBlWyBcIltvYmplY3QgXCIgKyBuYW1lICsgXCJdXCIgXSA9IG5hbWUudG9Mb3dlckNhc2UoKTtcbn0gKTtcblxuZnVuY3Rpb24gaXNBcnJheUxpa2UoIG9iaiApIHtcblxuXHQvLyBTdXBwb3J0OiByZWFsIGlPUyA4LjIgb25seSAobm90IHJlcHJvZHVjaWJsZSBpbiBzaW11bGF0b3IpXG5cdC8vIGBpbmAgY2hlY2sgdXNlZCB0byBwcmV2ZW50IEpJVCBlcnJvciAoZ2gtMjE0NSlcblx0Ly8gaGFzT3duIGlzbid0IHVzZWQgaGVyZSBkdWUgdG8gZmFsc2UgbmVnYXRpdmVzXG5cdC8vIHJlZ2FyZGluZyBOb2RlbGlzdCBsZW5ndGggaW4gSUVcblx0dmFyIGxlbmd0aCA9ICEhb2JqICYmIFwibGVuZ3RoXCIgaW4gb2JqICYmIG9iai5sZW5ndGgsXG5cdFx0dHlwZSA9IHRvVHlwZSggb2JqICk7XG5cblx0aWYgKCBpc0Z1bmN0aW9uKCBvYmogKSB8fCBpc1dpbmRvdyggb2JqICkgKSB7XG5cdFx0cmV0dXJuIGZhbHNlO1xuXHR9XG5cblx0cmV0dXJuIHR5cGUgPT09IFwiYXJyYXlcIiB8fCBsZW5ndGggPT09IDAgfHxcblx0XHR0eXBlb2YgbGVuZ3RoID09PSBcIm51bWJlclwiICYmIGxlbmd0aCA+IDAgJiYgKCBsZW5ndGggLSAxICkgaW4gb2JqO1xufVxudmFyIFNpenpsZSA9XG4vKiFcbiAqIFNpenpsZSBDU1MgU2VsZWN0b3IgRW5naW5lIHYyLjMuNFxuICogaHR0cHM6Ly9zaXp6bGVqcy5jb20vXG4gKlxuICogQ29weXJpZ2h0IEpTIEZvdW5kYXRpb24gYW5kIG90aGVyIGNvbnRyaWJ1dG9yc1xuICogUmVsZWFzZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlXG4gKiBodHRwczovL2pzLmZvdW5kYXRpb24vXG4gKlxuICogRGF0ZTogMjAxOS0wNC0wOFxuICovXG4oZnVuY3Rpb24oIHdpbmRvdyApIHtcblxudmFyIGksXG5cdHN1cHBvcnQsXG5cdEV4cHIsXG5cdGdldFRleHQsXG5cdGlzWE1MLFxuXHR0b2tlbml6ZSxcblx0Y29tcGlsZSxcblx0c2VsZWN0LFxuXHRvdXRlcm1vc3RDb250ZXh0LFxuXHRzb3J0SW5wdXQsXG5cdGhhc0R1cGxpY2F0ZSxcblxuXHQvLyBMb2NhbCBkb2N1bWVudCB2YXJzXG5cdHNldERvY3VtZW50LFxuXHRkb2N1bWVudCxcblx0ZG9jRWxlbSxcblx0ZG9jdW1lbnRJc0hUTUwsXG5cdHJidWdneVFTQSxcblx0cmJ1Z2d5TWF0Y2hlcyxcblx0bWF0Y2hlcyxcblx0Y29udGFpbnMsXG5cblx0Ly8gSW5zdGFuY2Utc3BlY2lmaWMgZGF0YVxuXHRleHBhbmRvID0gXCJzaXp6bGVcIiArIDEgKiBuZXcgRGF0ZSgpLFxuXHRwcmVmZXJyZWREb2MgPSB3aW5kb3cuZG9jdW1lbnQsXG5cdGRpcnJ1bnMgPSAwLFxuXHRkb25lID0gMCxcblx0Y2xhc3NDYWNoZSA9IGNyZWF0ZUNhY2hlKCksXG5cdHRva2VuQ2FjaGUgPSBjcmVhdGVDYWNoZSgpLFxuXHRjb21waWxlckNhY2hlID0gY3JlYXRlQ2FjaGUoKSxcblx0bm9ubmF0aXZlU2VsZWN0b3JDYWNoZSA9IGNyZWF0ZUNhY2hlKCksXG5cdHNvcnRPcmRlciA9IGZ1bmN0aW9uKCBhLCBiICkge1xuXHRcdGlmICggYSA9PT0gYiApIHtcblx0XHRcdGhhc0R1cGxpY2F0ZSA9IHRydWU7XG5cdFx0fVxuXHRcdHJldHVybiAwO1xuXHR9LFxuXG5cdC8vIEluc3RhbmNlIG1ldGhvZHNcblx0aGFzT3duID0gKHt9KS5oYXNPd25Qcm9wZXJ0eSxcblx0YXJyID0gW10sXG5cdHBvcCA9IGFyci5wb3AsXG5cdHB1c2hfbmF0aXZlID0gYXJyLnB1c2gsXG5cdHB1c2ggPSBhcnIucHVzaCxcblx0c2xpY2UgPSBhcnIuc2xpY2UsXG5cdC8vIFVzZSBhIHN0cmlwcGVkLWRvd24gaW5kZXhPZiBhcyBpdCdzIGZhc3RlciB0aGFuIG5hdGl2ZVxuXHQvLyBodHRwczovL2pzcGVyZi5jb20vdGhvci1pbmRleG9mLXZzLWZvci81XG5cdGluZGV4T2YgPSBmdW5jdGlvbiggbGlzdCwgZWxlbSApIHtcblx0XHR2YXIgaSA9IDAsXG5cdFx0XHRsZW4gPSBsaXN0Lmxlbmd0aDtcblx0XHRmb3IgKCA7IGkgPCBsZW47IGkrKyApIHtcblx0XHRcdGlmICggbGlzdFtpXSA9PT0gZWxlbSApIHtcblx0XHRcdFx0cmV0dXJuIGk7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHJldHVybiAtMTtcblx0fSxcblxuXHRib29sZWFucyA9IFwiY2hlY2tlZHxzZWxlY3RlZHxhc3luY3xhdXRvZm9jdXN8YXV0b3BsYXl8Y29udHJvbHN8ZGVmZXJ8ZGlzYWJsZWR8aGlkZGVufGlzbWFwfGxvb3B8bXVsdGlwbGV8b3BlbnxyZWFkb25seXxyZXF1aXJlZHxzY29wZWRcIixcblxuXHQvLyBSZWd1bGFyIGV4cHJlc3Npb25zXG5cblx0Ly8gaHR0cDovL3d3dy53My5vcmcvVFIvY3NzMy1zZWxlY3RvcnMvI3doaXRlc3BhY2Vcblx0d2hpdGVzcGFjZSA9IFwiW1xcXFx4MjBcXFxcdFxcXFxyXFxcXG5cXFxcZl1cIixcblxuXHQvLyBodHRwOi8vd3d3LnczLm9yZy9UUi9DU1MyMS9zeW5kYXRhLmh0bWwjdmFsdWUtZGVmLWlkZW50aWZpZXJcblx0aWRlbnRpZmllciA9IFwiKD86XFxcXFxcXFwufFtcXFxcdy1dfFteXFwwLVxcXFx4YTBdKStcIixcblxuXHQvLyBBdHRyaWJ1dGUgc2VsZWN0b3JzOiBodHRwOi8vd3d3LnczLm9yZy9UUi9zZWxlY3RvcnMvI2F0dHJpYnV0ZS1zZWxlY3RvcnNcblx0YXR0cmlidXRlcyA9IFwiXFxcXFtcIiArIHdoaXRlc3BhY2UgKyBcIiooXCIgKyBpZGVudGlmaWVyICsgXCIpKD86XCIgKyB3aGl0ZXNwYWNlICtcblx0XHQvLyBPcGVyYXRvciAoY2FwdHVyZSAyKVxuXHRcdFwiKihbKl4kfCF+XT89KVwiICsgd2hpdGVzcGFjZSArXG5cdFx0Ly8gXCJBdHRyaWJ1dGUgdmFsdWVzIG11c3QgYmUgQ1NTIGlkZW50aWZpZXJzIFtjYXB0dXJlIDVdIG9yIHN0cmluZ3MgW2NhcHR1cmUgMyBvciBjYXB0dXJlIDRdXCJcblx0XHRcIiooPzonKCg/OlxcXFxcXFxcLnxbXlxcXFxcXFxcJ10pKiknfFxcXCIoKD86XFxcXFxcXFwufFteXFxcXFxcXFxcXFwiXSkqKVxcXCJ8KFwiICsgaWRlbnRpZmllciArIFwiKSl8KVwiICsgd2hpdGVzcGFjZSArXG5cdFx0XCIqXFxcXF1cIixcblxuXHRwc2V1ZG9zID0gXCI6KFwiICsgaWRlbnRpZmllciArIFwiKSg/OlxcXFwoKFwiICtcblx0XHQvLyBUbyByZWR1Y2UgdGhlIG51bWJlciBvZiBzZWxlY3RvcnMgbmVlZGluZyB0b2tlbml6ZSBpbiB0aGUgcHJlRmlsdGVyLCBwcmVmZXIgYXJndW1lbnRzOlxuXHRcdC8vIDEuIHF1b3RlZCAoY2FwdHVyZSAzOyBjYXB0dXJlIDQgb3IgY2FwdHVyZSA1KVxuXHRcdFwiKCcoKD86XFxcXFxcXFwufFteXFxcXFxcXFwnXSkqKSd8XFxcIigoPzpcXFxcXFxcXC58W15cXFxcXFxcXFxcXCJdKSopXFxcIil8XCIgK1xuXHRcdC8vIDIuIHNpbXBsZSAoY2FwdHVyZSA2KVxuXHRcdFwiKCg/OlxcXFxcXFxcLnxbXlxcXFxcXFxcKClbXFxcXF1dfFwiICsgYXR0cmlidXRlcyArIFwiKSopfFwiICtcblx0XHQvLyAzLiBhbnl0aGluZyBlbHNlIChjYXB0dXJlIDIpXG5cdFx0XCIuKlwiICtcblx0XHRcIilcXFxcKXwpXCIsXG5cblx0Ly8gTGVhZGluZyBhbmQgbm9uLWVzY2FwZWQgdHJhaWxpbmcgd2hpdGVzcGFjZSwgY2FwdHVyaW5nIHNvbWUgbm9uLXdoaXRlc3BhY2UgY2hhcmFjdGVycyBwcmVjZWRpbmcgdGhlIGxhdHRlclxuXHRyd2hpdGVzcGFjZSA9IG5ldyBSZWdFeHAoIHdoaXRlc3BhY2UgKyBcIitcIiwgXCJnXCIgKSxcblx0cnRyaW0gPSBuZXcgUmVnRXhwKCBcIl5cIiArIHdoaXRlc3BhY2UgKyBcIit8KCg/Ol58W15cXFxcXFxcXF0pKD86XFxcXFxcXFwuKSopXCIgKyB3aGl0ZXNwYWNlICsgXCIrJFwiLCBcImdcIiApLFxuXG5cdHJjb21tYSA9IG5ldyBSZWdFeHAoIFwiXlwiICsgd2hpdGVzcGFjZSArIFwiKixcIiArIHdoaXRlc3BhY2UgKyBcIipcIiApLFxuXHRyY29tYmluYXRvcnMgPSBuZXcgUmVnRXhwKCBcIl5cIiArIHdoaXRlc3BhY2UgKyBcIiooWz4rfl18XCIgKyB3aGl0ZXNwYWNlICsgXCIpXCIgKyB3aGl0ZXNwYWNlICsgXCIqXCIgKSxcblx0cmRlc2NlbmQgPSBuZXcgUmVnRXhwKCB3aGl0ZXNwYWNlICsgXCJ8PlwiICksXG5cblx0cnBzZXVkbyA9IG5ldyBSZWdFeHAoIHBzZXVkb3MgKSxcblx0cmlkZW50aWZpZXIgPSBuZXcgUmVnRXhwKCBcIl5cIiArIGlkZW50aWZpZXIgKyBcIiRcIiApLFxuXG5cdG1hdGNoRXhwciA9IHtcblx0XHRcIklEXCI6IG5ldyBSZWdFeHAoIFwiXiMoXCIgKyBpZGVudGlmaWVyICsgXCIpXCIgKSxcblx0XHRcIkNMQVNTXCI6IG5ldyBSZWdFeHAoIFwiXlxcXFwuKFwiICsgaWRlbnRpZmllciArIFwiKVwiICksXG5cdFx0XCJUQUdcIjogbmV3IFJlZ0V4cCggXCJeKFwiICsgaWRlbnRpZmllciArIFwifFsqXSlcIiApLFxuXHRcdFwiQVRUUlwiOiBuZXcgUmVnRXhwKCBcIl5cIiArIGF0dHJpYnV0ZXMgKSxcblx0XHRcIlBTRVVET1wiOiBuZXcgUmVnRXhwKCBcIl5cIiArIHBzZXVkb3MgKSxcblx0XHRcIkNISUxEXCI6IG5ldyBSZWdFeHAoIFwiXjoob25seXxmaXJzdHxsYXN0fG50aHxudGgtbGFzdCktKGNoaWxkfG9mLXR5cGUpKD86XFxcXChcIiArIHdoaXRlc3BhY2UgK1xuXHRcdFx0XCIqKGV2ZW58b2RkfCgoWystXXwpKFxcXFxkKilufClcIiArIHdoaXRlc3BhY2UgKyBcIiooPzooWystXXwpXCIgKyB3aGl0ZXNwYWNlICtcblx0XHRcdFwiKihcXFxcZCspfCkpXCIgKyB3aGl0ZXNwYWNlICsgXCIqXFxcXCl8KVwiLCBcImlcIiApLFxuXHRcdFwiYm9vbFwiOiBuZXcgUmVnRXhwKCBcIl4oPzpcIiArIGJvb2xlYW5zICsgXCIpJFwiLCBcImlcIiApLFxuXHRcdC8vIEZvciB1c2UgaW4gbGlicmFyaWVzIGltcGxlbWVudGluZyAuaXMoKVxuXHRcdC8vIFdlIHVzZSB0aGlzIGZvciBQT1MgbWF0Y2hpbmcgaW4gYHNlbGVjdGBcblx0XHRcIm5lZWRzQ29udGV4dFwiOiBuZXcgUmVnRXhwKCBcIl5cIiArIHdoaXRlc3BhY2UgKyBcIipbPit+XXw6KGV2ZW58b2RkfGVxfGd0fGx0fG50aHxmaXJzdHxsYXN0KSg/OlxcXFwoXCIgK1xuXHRcdFx0d2hpdGVzcGFjZSArIFwiKigoPzotXFxcXGQpP1xcXFxkKilcIiArIHdoaXRlc3BhY2UgKyBcIipcXFxcKXwpKD89W14tXXwkKVwiLCBcImlcIiApXG5cdH0sXG5cblx0cmh0bWwgPSAvSFRNTCQvaSxcblx0cmlucHV0cyA9IC9eKD86aW5wdXR8c2VsZWN0fHRleHRhcmVhfGJ1dHRvbikkL2ksXG5cdHJoZWFkZXIgPSAvXmhcXGQkL2ksXG5cblx0cm5hdGl2ZSA9IC9eW157XStcXHtcXHMqXFxbbmF0aXZlIFxcdy8sXG5cblx0Ly8gRWFzaWx5LXBhcnNlYWJsZS9yZXRyaWV2YWJsZSBJRCBvciBUQUcgb3IgQ0xBU1Mgc2VsZWN0b3JzXG5cdHJxdWlja0V4cHIgPSAvXig/OiMoW1xcdy1dKyl8KFxcdyspfFxcLihbXFx3LV0rKSkkLyxcblxuXHRyc2libGluZyA9IC9bK35dLyxcblxuXHQvLyBDU1MgZXNjYXBlc1xuXHQvLyBodHRwOi8vd3d3LnczLm9yZy9UUi9DU1MyMS9zeW5kYXRhLmh0bWwjZXNjYXBlZC1jaGFyYWN0ZXJzXG5cdHJ1bmVzY2FwZSA9IG5ldyBSZWdFeHAoIFwiXFxcXFxcXFwoW1xcXFxkYS1mXXsxLDZ9XCIgKyB3aGl0ZXNwYWNlICsgXCI/fChcIiArIHdoaXRlc3BhY2UgKyBcIil8LilcIiwgXCJpZ1wiICksXG5cdGZ1bmVzY2FwZSA9IGZ1bmN0aW9uKCBfLCBlc2NhcGVkLCBlc2NhcGVkV2hpdGVzcGFjZSApIHtcblx0XHR2YXIgaGlnaCA9IFwiMHhcIiArIGVzY2FwZWQgLSAweDEwMDAwO1xuXHRcdC8vIE5hTiBtZWFucyBub24tY29kZXBvaW50XG5cdFx0Ly8gU3VwcG9ydDogRmlyZWZveDwyNFxuXHRcdC8vIFdvcmthcm91bmQgZXJyb25lb3VzIG51bWVyaWMgaW50ZXJwcmV0YXRpb24gb2YgK1wiMHhcIlxuXHRcdHJldHVybiBoaWdoICE9PSBoaWdoIHx8IGVzY2FwZWRXaGl0ZXNwYWNlID9cblx0XHRcdGVzY2FwZWQgOlxuXHRcdFx0aGlnaCA8IDAgP1xuXHRcdFx0XHQvLyBCTVAgY29kZXBvaW50XG5cdFx0XHRcdFN0cmluZy5mcm9tQ2hhckNvZGUoIGhpZ2ggKyAweDEwMDAwICkgOlxuXHRcdFx0XHQvLyBTdXBwbGVtZW50YWwgUGxhbmUgY29kZXBvaW50IChzdXJyb2dhdGUgcGFpcilcblx0XHRcdFx0U3RyaW5nLmZyb21DaGFyQ29kZSggaGlnaCA+PiAxMCB8IDB4RDgwMCwgaGlnaCAmIDB4M0ZGIHwgMHhEQzAwICk7XG5cdH0sXG5cblx0Ly8gQ1NTIHN0cmluZy9pZGVudGlmaWVyIHNlcmlhbGl6YXRpb25cblx0Ly8gaHR0cHM6Ly9kcmFmdHMuY3Nzd2cub3JnL2Nzc29tLyNjb21tb24tc2VyaWFsaXppbmctaWRpb21zXG5cdHJjc3Nlc2NhcGUgPSAvKFtcXDAtXFx4MWZcXHg3Zl18Xi0/XFxkKXxeLSR8W15cXDAtXFx4MWZcXHg3Zi1cXHVGRkZGXFx3LV0vZyxcblx0ZmNzc2VzY2FwZSA9IGZ1bmN0aW9uKCBjaCwgYXNDb2RlUG9pbnQgKSB7XG5cdFx0aWYgKCBhc0NvZGVQb2ludCApIHtcblxuXHRcdFx0Ly8gVSswMDAwIE5VTEwgYmVjb21lcyBVK0ZGRkQgUkVQTEFDRU1FTlQgQ0hBUkFDVEVSXG5cdFx0XHRpZiAoIGNoID09PSBcIlxcMFwiICkge1xuXHRcdFx0XHRyZXR1cm4gXCJcXHVGRkZEXCI7XG5cdFx0XHR9XG5cblx0XHRcdC8vIENvbnRyb2wgY2hhcmFjdGVycyBhbmQgKGRlcGVuZGVudCB1cG9uIHBvc2l0aW9uKSBudW1iZXJzIGdldCBlc2NhcGVkIGFzIGNvZGUgcG9pbnRzXG5cdFx0XHRyZXR1cm4gY2guc2xpY2UoIDAsIC0xICkgKyBcIlxcXFxcIiArIGNoLmNoYXJDb2RlQXQoIGNoLmxlbmd0aCAtIDEgKS50b1N0cmluZyggMTYgKSArIFwiIFwiO1xuXHRcdH1cblxuXHRcdC8vIE90aGVyIHBvdGVudGlhbGx5LXNwZWNpYWwgQVNDSUkgY2hhcmFjdGVycyBnZXQgYmFja3NsYXNoLWVzY2FwZWRcblx0XHRyZXR1cm4gXCJcXFxcXCIgKyBjaDtcblx0fSxcblxuXHQvLyBVc2VkIGZvciBpZnJhbWVzXG5cdC8vIFNlZSBzZXREb2N1bWVudCgpXG5cdC8vIFJlbW92aW5nIHRoZSBmdW5jdGlvbiB3cmFwcGVyIGNhdXNlcyBhIFwiUGVybWlzc2lvbiBEZW5pZWRcIlxuXHQvLyBlcnJvciBpbiBJRVxuXHR1bmxvYWRIYW5kbGVyID0gZnVuY3Rpb24oKSB7XG5cdFx0c2V0RG9jdW1lbnQoKTtcblx0fSxcblxuXHRpbkRpc2FibGVkRmllbGRzZXQgPSBhZGRDb21iaW5hdG9yKFxuXHRcdGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0cmV0dXJuIGVsZW0uZGlzYWJsZWQgPT09IHRydWUgJiYgZWxlbS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpID09PSBcImZpZWxkc2V0XCI7XG5cdFx0fSxcblx0XHR7IGRpcjogXCJwYXJlbnROb2RlXCIsIG5leHQ6IFwibGVnZW5kXCIgfVxuXHQpO1xuXG4vLyBPcHRpbWl6ZSBmb3IgcHVzaC5hcHBseSggXywgTm9kZUxpc3QgKVxudHJ5IHtcblx0cHVzaC5hcHBseShcblx0XHQoYXJyID0gc2xpY2UuY2FsbCggcHJlZmVycmVkRG9jLmNoaWxkTm9kZXMgKSksXG5cdFx0cHJlZmVycmVkRG9jLmNoaWxkTm9kZXNcblx0KTtcblx0Ly8gU3VwcG9ydDogQW5kcm9pZDw0LjBcblx0Ly8gRGV0ZWN0IHNpbGVudGx5IGZhaWxpbmcgcHVzaC5hcHBseVxuXHRhcnJbIHByZWZlcnJlZERvYy5jaGlsZE5vZGVzLmxlbmd0aCBdLm5vZGVUeXBlO1xufSBjYXRjaCAoIGUgKSB7XG5cdHB1c2ggPSB7IGFwcGx5OiBhcnIubGVuZ3RoID9cblxuXHRcdC8vIExldmVyYWdlIHNsaWNlIGlmIHBvc3NpYmxlXG5cdFx0ZnVuY3Rpb24oIHRhcmdldCwgZWxzICkge1xuXHRcdFx0cHVzaF9uYXRpdmUuYXBwbHkoIHRhcmdldCwgc2xpY2UuY2FsbChlbHMpICk7XG5cdFx0fSA6XG5cblx0XHQvLyBTdXBwb3J0OiBJRTw5XG5cdFx0Ly8gT3RoZXJ3aXNlIGFwcGVuZCBkaXJlY3RseVxuXHRcdGZ1bmN0aW9uKCB0YXJnZXQsIGVscyApIHtcblx0XHRcdHZhciBqID0gdGFyZ2V0Lmxlbmd0aCxcblx0XHRcdFx0aSA9IDA7XG5cdFx0XHQvLyBDYW4ndCB0cnVzdCBOb2RlTGlzdC5sZW5ndGhcblx0XHRcdHdoaWxlICggKHRhcmdldFtqKytdID0gZWxzW2krK10pICkge31cblx0XHRcdHRhcmdldC5sZW5ndGggPSBqIC0gMTtcblx0XHR9XG5cdH07XG59XG5cbmZ1bmN0aW9uIFNpenpsZSggc2VsZWN0b3IsIGNvbnRleHQsIHJlc3VsdHMsIHNlZWQgKSB7XG5cdHZhciBtLCBpLCBlbGVtLCBuaWQsIG1hdGNoLCBncm91cHMsIG5ld1NlbGVjdG9yLFxuXHRcdG5ld0NvbnRleHQgPSBjb250ZXh0ICYmIGNvbnRleHQub3duZXJEb2N1bWVudCxcblxuXHRcdC8vIG5vZGVUeXBlIGRlZmF1bHRzIHRvIDksIHNpbmNlIGNvbnRleHQgZGVmYXVsdHMgdG8gZG9jdW1lbnRcblx0XHRub2RlVHlwZSA9IGNvbnRleHQgPyBjb250ZXh0Lm5vZGVUeXBlIDogOTtcblxuXHRyZXN1bHRzID0gcmVzdWx0cyB8fCBbXTtcblxuXHQvLyBSZXR1cm4gZWFybHkgZnJvbSBjYWxscyB3aXRoIGludmFsaWQgc2VsZWN0b3Igb3IgY29udGV4dFxuXHRpZiAoIHR5cGVvZiBzZWxlY3RvciAhPT0gXCJzdHJpbmdcIiB8fCAhc2VsZWN0b3IgfHxcblx0XHRub2RlVHlwZSAhPT0gMSAmJiBub2RlVHlwZSAhPT0gOSAmJiBub2RlVHlwZSAhPT0gMTEgKSB7XG5cblx0XHRyZXR1cm4gcmVzdWx0cztcblx0fVxuXG5cdC8vIFRyeSB0byBzaG9ydGN1dCBmaW5kIG9wZXJhdGlvbnMgKGFzIG9wcG9zZWQgdG8gZmlsdGVycykgaW4gSFRNTCBkb2N1bWVudHNcblx0aWYgKCAhc2VlZCApIHtcblxuXHRcdGlmICggKCBjb250ZXh0ID8gY29udGV4dC5vd25lckRvY3VtZW50IHx8IGNvbnRleHQgOiBwcmVmZXJyZWREb2MgKSAhPT0gZG9jdW1lbnQgKSB7XG5cdFx0XHRzZXREb2N1bWVudCggY29udGV4dCApO1xuXHRcdH1cblx0XHRjb250ZXh0ID0gY29udGV4dCB8fCBkb2N1bWVudDtcblxuXHRcdGlmICggZG9jdW1lbnRJc0hUTUwgKSB7XG5cblx0XHRcdC8vIElmIHRoZSBzZWxlY3RvciBpcyBzdWZmaWNpZW50bHkgc2ltcGxlLCB0cnkgdXNpbmcgYSBcImdldCpCeSpcIiBET00gbWV0aG9kXG5cdFx0XHQvLyAoZXhjZXB0aW5nIERvY3VtZW50RnJhZ21lbnQgY29udGV4dCwgd2hlcmUgdGhlIG1ldGhvZHMgZG9uJ3QgZXhpc3QpXG5cdFx0XHRpZiAoIG5vZGVUeXBlICE9PSAxMSAmJiAobWF0Y2ggPSBycXVpY2tFeHByLmV4ZWMoIHNlbGVjdG9yICkpICkge1xuXG5cdFx0XHRcdC8vIElEIHNlbGVjdG9yXG5cdFx0XHRcdGlmICggKG0gPSBtYXRjaFsxXSkgKSB7XG5cblx0XHRcdFx0XHQvLyBEb2N1bWVudCBjb250ZXh0XG5cdFx0XHRcdFx0aWYgKCBub2RlVHlwZSA9PT0gOSApIHtcblx0XHRcdFx0XHRcdGlmICggKGVsZW0gPSBjb250ZXh0LmdldEVsZW1lbnRCeUlkKCBtICkpICkge1xuXG5cdFx0XHRcdFx0XHRcdC8vIFN1cHBvcnQ6IElFLCBPcGVyYSwgV2Via2l0XG5cdFx0XHRcdFx0XHRcdC8vIFRPRE86IGlkZW50aWZ5IHZlcnNpb25zXG5cdFx0XHRcdFx0XHRcdC8vIGdldEVsZW1lbnRCeUlkIGNhbiBtYXRjaCBlbGVtZW50cyBieSBuYW1lIGluc3RlYWQgb2YgSURcblx0XHRcdFx0XHRcdFx0aWYgKCBlbGVtLmlkID09PSBtICkge1xuXHRcdFx0XHRcdFx0XHRcdHJlc3VsdHMucHVzaCggZWxlbSApO1xuXHRcdFx0XHRcdFx0XHRcdHJldHVybiByZXN1bHRzO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0XHRyZXR1cm4gcmVzdWx0cztcblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdC8vIEVsZW1lbnQgY29udGV4dFxuXHRcdFx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHRcdC8vIFN1cHBvcnQ6IElFLCBPcGVyYSwgV2Via2l0XG5cdFx0XHRcdFx0XHQvLyBUT0RPOiBpZGVudGlmeSB2ZXJzaW9uc1xuXHRcdFx0XHRcdFx0Ly8gZ2V0RWxlbWVudEJ5SWQgY2FuIG1hdGNoIGVsZW1lbnRzIGJ5IG5hbWUgaW5zdGVhZCBvZiBJRFxuXHRcdFx0XHRcdFx0aWYgKCBuZXdDb250ZXh0ICYmIChlbGVtID0gbmV3Q29udGV4dC5nZXRFbGVtZW50QnlJZCggbSApKSAmJlxuXHRcdFx0XHRcdFx0XHRjb250YWlucyggY29udGV4dCwgZWxlbSApICYmXG5cdFx0XHRcdFx0XHRcdGVsZW0uaWQgPT09IG0gKSB7XG5cblx0XHRcdFx0XHRcdFx0cmVzdWx0cy5wdXNoKCBlbGVtICk7XG5cdFx0XHRcdFx0XHRcdHJldHVybiByZXN1bHRzO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBUeXBlIHNlbGVjdG9yXG5cdFx0XHRcdH0gZWxzZSBpZiAoIG1hdGNoWzJdICkge1xuXHRcdFx0XHRcdHB1c2guYXBwbHkoIHJlc3VsdHMsIGNvbnRleHQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoIHNlbGVjdG9yICkgKTtcblx0XHRcdFx0XHRyZXR1cm4gcmVzdWx0cztcblxuXHRcdFx0XHQvLyBDbGFzcyBzZWxlY3RvclxuXHRcdFx0XHR9IGVsc2UgaWYgKCAobSA9IG1hdGNoWzNdKSAmJiBzdXBwb3J0LmdldEVsZW1lbnRzQnlDbGFzc05hbWUgJiZcblx0XHRcdFx0XHRjb250ZXh0LmdldEVsZW1lbnRzQnlDbGFzc05hbWUgKSB7XG5cblx0XHRcdFx0XHRwdXNoLmFwcGx5KCByZXN1bHRzLCBjb250ZXh0LmdldEVsZW1lbnRzQnlDbGFzc05hbWUoIG0gKSApO1xuXHRcdFx0XHRcdHJldHVybiByZXN1bHRzO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdC8vIFRha2UgYWR2YW50YWdlIG9mIHF1ZXJ5U2VsZWN0b3JBbGxcblx0XHRcdGlmICggc3VwcG9ydC5xc2EgJiZcblx0XHRcdFx0IW5vbm5hdGl2ZVNlbGVjdG9yQ2FjaGVbIHNlbGVjdG9yICsgXCIgXCIgXSAmJlxuXHRcdFx0XHQoIXJidWdneVFTQSB8fCAhcmJ1Z2d5UVNBLnRlc3QoIHNlbGVjdG9yICkpICYmXG5cblx0XHRcdFx0Ly8gU3VwcG9ydDogSUUgOCBvbmx5XG5cdFx0XHRcdC8vIEV4Y2x1ZGUgb2JqZWN0IGVsZW1lbnRzXG5cdFx0XHRcdChub2RlVHlwZSAhPT0gMSB8fCBjb250ZXh0Lm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkgIT09IFwib2JqZWN0XCIpICkge1xuXG5cdFx0XHRcdG5ld1NlbGVjdG9yID0gc2VsZWN0b3I7XG5cdFx0XHRcdG5ld0NvbnRleHQgPSBjb250ZXh0O1xuXG5cdFx0XHRcdC8vIHFTQSBjb25zaWRlcnMgZWxlbWVudHMgb3V0c2lkZSBhIHNjb3Bpbmcgcm9vdCB3aGVuIGV2YWx1YXRpbmcgY2hpbGQgb3Jcblx0XHRcdFx0Ly8gZGVzY2VuZGFudCBjb21iaW5hdG9ycywgd2hpY2ggaXMgbm90IHdoYXQgd2Ugd2FudC5cblx0XHRcdFx0Ly8gSW4gc3VjaCBjYXNlcywgd2Ugd29yayBhcm91bmQgdGhlIGJlaGF2aW9yIGJ5IHByZWZpeGluZyBldmVyeSBzZWxlY3RvciBpbiB0aGVcblx0XHRcdFx0Ly8gbGlzdCB3aXRoIGFuIElEIHNlbGVjdG9yIHJlZmVyZW5jaW5nIHRoZSBzY29wZSBjb250ZXh0LlxuXHRcdFx0XHQvLyBUaGFua3MgdG8gQW5kcmV3IER1cG9udCBmb3IgdGhpcyB0ZWNobmlxdWUuXG5cdFx0XHRcdGlmICggbm9kZVR5cGUgPT09IDEgJiYgcmRlc2NlbmQudGVzdCggc2VsZWN0b3IgKSApIHtcblxuXHRcdFx0XHRcdC8vIENhcHR1cmUgdGhlIGNvbnRleHQgSUQsIHNldHRpbmcgaXQgZmlyc3QgaWYgbmVjZXNzYXJ5XG5cdFx0XHRcdFx0aWYgKCAobmlkID0gY29udGV4dC5nZXRBdHRyaWJ1dGUoIFwiaWRcIiApKSApIHtcblx0XHRcdFx0XHRcdG5pZCA9IG5pZC5yZXBsYWNlKCByY3NzZXNjYXBlLCBmY3NzZXNjYXBlICk7XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdGNvbnRleHQuc2V0QXR0cmlidXRlKCBcImlkXCIsIChuaWQgPSBleHBhbmRvKSApO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdC8vIFByZWZpeCBldmVyeSBzZWxlY3RvciBpbiB0aGUgbGlzdFxuXHRcdFx0XHRcdGdyb3VwcyA9IHRva2VuaXplKCBzZWxlY3RvciApO1xuXHRcdFx0XHRcdGkgPSBncm91cHMubGVuZ3RoO1xuXHRcdFx0XHRcdHdoaWxlICggaS0tICkge1xuXHRcdFx0XHRcdFx0Z3JvdXBzW2ldID0gXCIjXCIgKyBuaWQgKyBcIiBcIiArIHRvU2VsZWN0b3IoIGdyb3Vwc1tpXSApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRuZXdTZWxlY3RvciA9IGdyb3Vwcy5qb2luKCBcIixcIiApO1xuXG5cdFx0XHRcdFx0Ly8gRXhwYW5kIGNvbnRleHQgZm9yIHNpYmxpbmcgc2VsZWN0b3JzXG5cdFx0XHRcdFx0bmV3Q29udGV4dCA9IHJzaWJsaW5nLnRlc3QoIHNlbGVjdG9yICkgJiYgdGVzdENvbnRleHQoIGNvbnRleHQucGFyZW50Tm9kZSApIHx8XG5cdFx0XHRcdFx0XHRjb250ZXh0O1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0dHJ5IHtcblx0XHRcdFx0XHRwdXNoLmFwcGx5KCByZXN1bHRzLFxuXHRcdFx0XHRcdFx0bmV3Q29udGV4dC5xdWVyeVNlbGVjdG9yQWxsKCBuZXdTZWxlY3RvciApXG5cdFx0XHRcdFx0KTtcblx0XHRcdFx0XHRyZXR1cm4gcmVzdWx0cztcblx0XHRcdFx0fSBjYXRjaCAoIHFzYUVycm9yICkge1xuXHRcdFx0XHRcdG5vbm5hdGl2ZVNlbGVjdG9yQ2FjaGUoIHNlbGVjdG9yLCB0cnVlICk7XG5cdFx0XHRcdH0gZmluYWxseSB7XG5cdFx0XHRcdFx0aWYgKCBuaWQgPT09IGV4cGFuZG8gKSB7XG5cdFx0XHRcdFx0XHRjb250ZXh0LnJlbW92ZUF0dHJpYnV0ZSggXCJpZFwiICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0Ly8gQWxsIG90aGVyc1xuXHRyZXR1cm4gc2VsZWN0KCBzZWxlY3Rvci5yZXBsYWNlKCBydHJpbSwgXCIkMVwiICksIGNvbnRleHQsIHJlc3VsdHMsIHNlZWQgKTtcbn1cblxuLyoqXG4gKiBDcmVhdGUga2V5LXZhbHVlIGNhY2hlcyBvZiBsaW1pdGVkIHNpemVcbiAqIEByZXR1cm5zIHtmdW5jdGlvbihzdHJpbmcsIG9iamVjdCl9IFJldHVybnMgdGhlIE9iamVjdCBkYXRhIGFmdGVyIHN0b3JpbmcgaXQgb24gaXRzZWxmIHdpdGhcbiAqXHRwcm9wZXJ0eSBuYW1lIHRoZSAoc3BhY2Utc3VmZml4ZWQpIHN0cmluZyBhbmQgKGlmIHRoZSBjYWNoZSBpcyBsYXJnZXIgdGhhbiBFeHByLmNhY2hlTGVuZ3RoKVxuICpcdGRlbGV0aW5nIHRoZSBvbGRlc3QgZW50cnlcbiAqL1xuZnVuY3Rpb24gY3JlYXRlQ2FjaGUoKSB7XG5cdHZhciBrZXlzID0gW107XG5cblx0ZnVuY3Rpb24gY2FjaGUoIGtleSwgdmFsdWUgKSB7XG5cdFx0Ly8gVXNlIChrZXkgKyBcIiBcIikgdG8gYXZvaWQgY29sbGlzaW9uIHdpdGggbmF0aXZlIHByb3RvdHlwZSBwcm9wZXJ0aWVzIChzZWUgSXNzdWUgIzE1Nylcblx0XHRpZiAoIGtleXMucHVzaCgga2V5ICsgXCIgXCIgKSA+IEV4cHIuY2FjaGVMZW5ndGggKSB7XG5cdFx0XHQvLyBPbmx5IGtlZXAgdGhlIG1vc3QgcmVjZW50IGVudHJpZXNcblx0XHRcdGRlbGV0ZSBjYWNoZVsga2V5cy5zaGlmdCgpIF07XG5cdFx0fVxuXHRcdHJldHVybiAoY2FjaGVbIGtleSArIFwiIFwiIF0gPSB2YWx1ZSk7XG5cdH1cblx0cmV0dXJuIGNhY2hlO1xufVxuXG4vKipcbiAqIE1hcmsgYSBmdW5jdGlvbiBmb3Igc3BlY2lhbCB1c2UgYnkgU2l6emxlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbiBUaGUgZnVuY3Rpb24gdG8gbWFya1xuICovXG5mdW5jdGlvbiBtYXJrRnVuY3Rpb24oIGZuICkge1xuXHRmblsgZXhwYW5kbyBdID0gdHJ1ZTtcblx0cmV0dXJuIGZuO1xufVxuXG4vKipcbiAqIFN1cHBvcnQgdGVzdGluZyB1c2luZyBhbiBlbGVtZW50XG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbiBQYXNzZWQgdGhlIGNyZWF0ZWQgZWxlbWVudCBhbmQgcmV0dXJucyBhIGJvb2xlYW4gcmVzdWx0XG4gKi9cbmZ1bmN0aW9uIGFzc2VydCggZm4gKSB7XG5cdHZhciBlbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJmaWVsZHNldFwiKTtcblxuXHR0cnkge1xuXHRcdHJldHVybiAhIWZuKCBlbCApO1xuXHR9IGNhdGNoIChlKSB7XG5cdFx0cmV0dXJuIGZhbHNlO1xuXHR9IGZpbmFsbHkge1xuXHRcdC8vIFJlbW92ZSBmcm9tIGl0cyBwYXJlbnQgYnkgZGVmYXVsdFxuXHRcdGlmICggZWwucGFyZW50Tm9kZSApIHtcblx0XHRcdGVsLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoIGVsICk7XG5cdFx0fVxuXHRcdC8vIHJlbGVhc2UgbWVtb3J5IGluIElFXG5cdFx0ZWwgPSBudWxsO1xuXHR9XG59XG5cbi8qKlxuICogQWRkcyB0aGUgc2FtZSBoYW5kbGVyIGZvciBhbGwgb2YgdGhlIHNwZWNpZmllZCBhdHRyc1xuICogQHBhcmFtIHtTdHJpbmd9IGF0dHJzIFBpcGUtc2VwYXJhdGVkIGxpc3Qgb2YgYXR0cmlidXRlc1xuICogQHBhcmFtIHtGdW5jdGlvbn0gaGFuZGxlciBUaGUgbWV0aG9kIHRoYXQgd2lsbCBiZSBhcHBsaWVkXG4gKi9cbmZ1bmN0aW9uIGFkZEhhbmRsZSggYXR0cnMsIGhhbmRsZXIgKSB7XG5cdHZhciBhcnIgPSBhdHRycy5zcGxpdChcInxcIiksXG5cdFx0aSA9IGFyci5sZW5ndGg7XG5cblx0d2hpbGUgKCBpLS0gKSB7XG5cdFx0RXhwci5hdHRySGFuZGxlWyBhcnJbaV0gXSA9IGhhbmRsZXI7XG5cdH1cbn1cblxuLyoqXG4gKiBDaGVja3MgZG9jdW1lbnQgb3JkZXIgb2YgdHdvIHNpYmxpbmdzXG4gKiBAcGFyYW0ge0VsZW1lbnR9IGFcbiAqIEBwYXJhbSB7RWxlbWVudH0gYlxuICogQHJldHVybnMge051bWJlcn0gUmV0dXJucyBsZXNzIHRoYW4gMCBpZiBhIHByZWNlZGVzIGIsIGdyZWF0ZXIgdGhhbiAwIGlmIGEgZm9sbG93cyBiXG4gKi9cbmZ1bmN0aW9uIHNpYmxpbmdDaGVjayggYSwgYiApIHtcblx0dmFyIGN1ciA9IGIgJiYgYSxcblx0XHRkaWZmID0gY3VyICYmIGEubm9kZVR5cGUgPT09IDEgJiYgYi5ub2RlVHlwZSA9PT0gMSAmJlxuXHRcdFx0YS5zb3VyY2VJbmRleCAtIGIuc291cmNlSW5kZXg7XG5cblx0Ly8gVXNlIElFIHNvdXJjZUluZGV4IGlmIGF2YWlsYWJsZSBvbiBib3RoIG5vZGVzXG5cdGlmICggZGlmZiApIHtcblx0XHRyZXR1cm4gZGlmZjtcblx0fVxuXG5cdC8vIENoZWNrIGlmIGIgZm9sbG93cyBhXG5cdGlmICggY3VyICkge1xuXHRcdHdoaWxlICggKGN1ciA9IGN1ci5uZXh0U2libGluZykgKSB7XG5cdFx0XHRpZiAoIGN1ciA9PT0gYiApIHtcblx0XHRcdFx0cmV0dXJuIC0xO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdHJldHVybiBhID8gMSA6IC0xO1xufVxuXG4vKipcbiAqIFJldHVybnMgYSBmdW5jdGlvbiB0byB1c2UgaW4gcHNldWRvcyBmb3IgaW5wdXQgdHlwZXNcbiAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZUlucHV0UHNldWRvKCB0eXBlICkge1xuXHRyZXR1cm4gZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0dmFyIG5hbWUgPSBlbGVtLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCk7XG5cdFx0cmV0dXJuIG5hbWUgPT09IFwiaW5wdXRcIiAmJiBlbGVtLnR5cGUgPT09IHR5cGU7XG5cdH07XG59XG5cbi8qKlxuICogUmV0dXJucyBhIGZ1bmN0aW9uIHRvIHVzZSBpbiBwc2V1ZG9zIGZvciBidXR0b25zXG4gKiBAcGFyYW0ge1N0cmluZ30gdHlwZVxuICovXG5mdW5jdGlvbiBjcmVhdGVCdXR0b25Qc2V1ZG8oIHR5cGUgKSB7XG5cdHJldHVybiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHR2YXIgbmFtZSA9IGVsZW0ubm9kZU5hbWUudG9Mb3dlckNhc2UoKTtcblx0XHRyZXR1cm4gKG5hbWUgPT09IFwiaW5wdXRcIiB8fCBuYW1lID09PSBcImJ1dHRvblwiKSAmJiBlbGVtLnR5cGUgPT09IHR5cGU7XG5cdH07XG59XG5cbi8qKlxuICogUmV0dXJucyBhIGZ1bmN0aW9uIHRvIHVzZSBpbiBwc2V1ZG9zIGZvciA6ZW5hYmxlZC86ZGlzYWJsZWRcbiAqIEBwYXJhbSB7Qm9vbGVhbn0gZGlzYWJsZWQgdHJ1ZSBmb3IgOmRpc2FibGVkOyBmYWxzZSBmb3IgOmVuYWJsZWRcbiAqL1xuZnVuY3Rpb24gY3JlYXRlRGlzYWJsZWRQc2V1ZG8oIGRpc2FibGVkICkge1xuXG5cdC8vIEtub3duIDpkaXNhYmxlZCBmYWxzZSBwb3NpdGl2ZXM6IGZpZWxkc2V0W2Rpc2FibGVkXSA+IGxlZ2VuZDpudGgtb2YtdHlwZShuKzIpIDpjYW4tZGlzYWJsZVxuXHRyZXR1cm4gZnVuY3Rpb24oIGVsZW0gKSB7XG5cblx0XHQvLyBPbmx5IGNlcnRhaW4gZWxlbWVudHMgY2FuIG1hdGNoIDplbmFibGVkIG9yIDpkaXNhYmxlZFxuXHRcdC8vIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL3NjcmlwdGluZy5odG1sI3NlbGVjdG9yLWVuYWJsZWRcblx0XHQvLyBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9zY3JpcHRpbmcuaHRtbCNzZWxlY3Rvci1kaXNhYmxlZFxuXHRcdGlmICggXCJmb3JtXCIgaW4gZWxlbSApIHtcblxuXHRcdFx0Ly8gQ2hlY2sgZm9yIGluaGVyaXRlZCBkaXNhYmxlZG5lc3Mgb24gcmVsZXZhbnQgbm9uLWRpc2FibGVkIGVsZW1lbnRzOlxuXHRcdFx0Ly8gKiBsaXN0ZWQgZm9ybS1hc3NvY2lhdGVkIGVsZW1lbnRzIGluIGEgZGlzYWJsZWQgZmllbGRzZXRcblx0XHRcdC8vICAgaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2UvZm9ybXMuaHRtbCNjYXRlZ29yeS1saXN0ZWRcblx0XHRcdC8vICAgaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2UvZm9ybXMuaHRtbCNjb25jZXB0LWZlLWRpc2FibGVkXG5cdFx0XHQvLyAqIG9wdGlvbiBlbGVtZW50cyBpbiBhIGRpc2FibGVkIG9wdGdyb3VwXG5cdFx0XHQvLyAgIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL2Zvcm1zLmh0bWwjY29uY2VwdC1vcHRpb24tZGlzYWJsZWRcblx0XHRcdC8vIEFsbCBzdWNoIGVsZW1lbnRzIGhhdmUgYSBcImZvcm1cIiBwcm9wZXJ0eS5cblx0XHRcdGlmICggZWxlbS5wYXJlbnROb2RlICYmIGVsZW0uZGlzYWJsZWQgPT09IGZhbHNlICkge1xuXG5cdFx0XHRcdC8vIE9wdGlvbiBlbGVtZW50cyBkZWZlciB0byBhIHBhcmVudCBvcHRncm91cCBpZiBwcmVzZW50XG5cdFx0XHRcdGlmICggXCJsYWJlbFwiIGluIGVsZW0gKSB7XG5cdFx0XHRcdFx0aWYgKCBcImxhYmVsXCIgaW4gZWxlbS5wYXJlbnROb2RlICkge1xuXHRcdFx0XHRcdFx0cmV0dXJuIGVsZW0ucGFyZW50Tm9kZS5kaXNhYmxlZCA9PT0gZGlzYWJsZWQ7XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdHJldHVybiBlbGVtLmRpc2FibGVkID09PSBkaXNhYmxlZDtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBTdXBwb3J0OiBJRSA2IC0gMTFcblx0XHRcdFx0Ly8gVXNlIHRoZSBpc0Rpc2FibGVkIHNob3J0Y3V0IHByb3BlcnR5IHRvIGNoZWNrIGZvciBkaXNhYmxlZCBmaWVsZHNldCBhbmNlc3RvcnNcblx0XHRcdFx0cmV0dXJuIGVsZW0uaXNEaXNhYmxlZCA9PT0gZGlzYWJsZWQgfHxcblxuXHRcdFx0XHRcdC8vIFdoZXJlIHRoZXJlIGlzIG5vIGlzRGlzYWJsZWQsIGNoZWNrIG1hbnVhbGx5XG5cdFx0XHRcdFx0LyoganNoaW50IC1XMDE4ICovXG5cdFx0XHRcdFx0ZWxlbS5pc0Rpc2FibGVkICE9PSAhZGlzYWJsZWQgJiZcblx0XHRcdFx0XHRcdGluRGlzYWJsZWRGaWVsZHNldCggZWxlbSApID09PSBkaXNhYmxlZDtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIGVsZW0uZGlzYWJsZWQgPT09IGRpc2FibGVkO1xuXG5cdFx0Ly8gVHJ5IHRvIHdpbm5vdyBvdXQgZWxlbWVudHMgdGhhdCBjYW4ndCBiZSBkaXNhYmxlZCBiZWZvcmUgdHJ1c3RpbmcgdGhlIGRpc2FibGVkIHByb3BlcnR5LlxuXHRcdC8vIFNvbWUgdmljdGltcyBnZXQgY2F1Z2h0IGluIG91ciBuZXQgKGxhYmVsLCBsZWdlbmQsIG1lbnUsIHRyYWNrKSwgYnV0IGl0IHNob3VsZG4ndFxuXHRcdC8vIGV2ZW4gZXhpc3Qgb24gdGhlbSwgbGV0IGFsb25lIGhhdmUgYSBib29sZWFuIHZhbHVlLlxuXHRcdH0gZWxzZSBpZiAoIFwibGFiZWxcIiBpbiBlbGVtICkge1xuXHRcdFx0cmV0dXJuIGVsZW0uZGlzYWJsZWQgPT09IGRpc2FibGVkO1xuXHRcdH1cblxuXHRcdC8vIFJlbWFpbmluZyBlbGVtZW50cyBhcmUgbmVpdGhlciA6ZW5hYmxlZCBub3IgOmRpc2FibGVkXG5cdFx0cmV0dXJuIGZhbHNlO1xuXHR9O1xufVxuXG4vKipcbiAqIFJldHVybnMgYSBmdW5jdGlvbiB0byB1c2UgaW4gcHNldWRvcyBmb3IgcG9zaXRpb25hbHNcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZVBvc2l0aW9uYWxQc2V1ZG8oIGZuICkge1xuXHRyZXR1cm4gbWFya0Z1bmN0aW9uKGZ1bmN0aW9uKCBhcmd1bWVudCApIHtcblx0XHRhcmd1bWVudCA9ICthcmd1bWVudDtcblx0XHRyZXR1cm4gbWFya0Z1bmN0aW9uKGZ1bmN0aW9uKCBzZWVkLCBtYXRjaGVzICkge1xuXHRcdFx0dmFyIGosXG5cdFx0XHRcdG1hdGNoSW5kZXhlcyA9IGZuKCBbXSwgc2VlZC5sZW5ndGgsIGFyZ3VtZW50ICksXG5cdFx0XHRcdGkgPSBtYXRjaEluZGV4ZXMubGVuZ3RoO1xuXG5cdFx0XHQvLyBNYXRjaCBlbGVtZW50cyBmb3VuZCBhdCB0aGUgc3BlY2lmaWVkIGluZGV4ZXNcblx0XHRcdHdoaWxlICggaS0tICkge1xuXHRcdFx0XHRpZiAoIHNlZWRbIChqID0gbWF0Y2hJbmRleGVzW2ldKSBdICkge1xuXHRcdFx0XHRcdHNlZWRbal0gPSAhKG1hdGNoZXNbal0gPSBzZWVkW2pdKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH0pO1xuXHR9KTtcbn1cblxuLyoqXG4gKiBDaGVja3MgYSBub2RlIGZvciB2YWxpZGl0eSBhcyBhIFNpenpsZSBjb250ZXh0XG4gKiBAcGFyYW0ge0VsZW1lbnR8T2JqZWN0PX0gY29udGV4dFxuICogQHJldHVybnMge0VsZW1lbnR8T2JqZWN0fEJvb2xlYW59IFRoZSBpbnB1dCBub2RlIGlmIGFjY2VwdGFibGUsIG90aGVyd2lzZSBhIGZhbHN5IHZhbHVlXG4gKi9cbmZ1bmN0aW9uIHRlc3RDb250ZXh0KCBjb250ZXh0ICkge1xuXHRyZXR1cm4gY29udGV4dCAmJiB0eXBlb2YgY29udGV4dC5nZXRFbGVtZW50c0J5VGFnTmFtZSAhPT0gXCJ1bmRlZmluZWRcIiAmJiBjb250ZXh0O1xufVxuXG4vLyBFeHBvc2Ugc3VwcG9ydCB2YXJzIGZvciBjb252ZW5pZW5jZVxuc3VwcG9ydCA9IFNpenpsZS5zdXBwb3J0ID0ge307XG5cbi8qKlxuICogRGV0ZWN0cyBYTUwgbm9kZXNcbiAqIEBwYXJhbSB7RWxlbWVudHxPYmplY3R9IGVsZW0gQW4gZWxlbWVudCBvciBhIGRvY3VtZW50XG4gKiBAcmV0dXJucyB7Qm9vbGVhbn0gVHJ1ZSBpZmYgZWxlbSBpcyBhIG5vbi1IVE1MIFhNTCBub2RlXG4gKi9cbmlzWE1MID0gU2l6emxlLmlzWE1MID0gZnVuY3Rpb24oIGVsZW0gKSB7XG5cdHZhciBuYW1lc3BhY2UgPSBlbGVtLm5hbWVzcGFjZVVSSSxcblx0XHRkb2NFbGVtID0gKGVsZW0ub3duZXJEb2N1bWVudCB8fCBlbGVtKS5kb2N1bWVudEVsZW1lbnQ7XG5cblx0Ly8gU3VwcG9ydDogSUUgPD04XG5cdC8vIEFzc3VtZSBIVE1MIHdoZW4gZG9jdW1lbnRFbGVtZW50IGRvZXNuJ3QgeWV0IGV4aXN0LCBzdWNoIGFzIGluc2lkZSBsb2FkaW5nIGlmcmFtZXNcblx0Ly8gaHR0cHM6Ly9idWdzLmpxdWVyeS5jb20vdGlja2V0LzQ4MzNcblx0cmV0dXJuICFyaHRtbC50ZXN0KCBuYW1lc3BhY2UgfHwgZG9jRWxlbSAmJiBkb2NFbGVtLm5vZGVOYW1lIHx8IFwiSFRNTFwiICk7XG59O1xuXG4vKipcbiAqIFNldHMgZG9jdW1lbnQtcmVsYXRlZCB2YXJpYWJsZXMgb25jZSBiYXNlZCBvbiB0aGUgY3VycmVudCBkb2N1bWVudFxuICogQHBhcmFtIHtFbGVtZW50fE9iamVjdH0gW2RvY10gQW4gZWxlbWVudCBvciBkb2N1bWVudCBvYmplY3QgdG8gdXNlIHRvIHNldCB0aGUgZG9jdW1lbnRcbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIGN1cnJlbnQgZG9jdW1lbnRcbiAqL1xuc2V0RG9jdW1lbnQgPSBTaXp6bGUuc2V0RG9jdW1lbnQgPSBmdW5jdGlvbiggbm9kZSApIHtcblx0dmFyIGhhc0NvbXBhcmUsIHN1YldpbmRvdyxcblx0XHRkb2MgPSBub2RlID8gbm9kZS5vd25lckRvY3VtZW50IHx8IG5vZGUgOiBwcmVmZXJyZWREb2M7XG5cblx0Ly8gUmV0dXJuIGVhcmx5IGlmIGRvYyBpcyBpbnZhbGlkIG9yIGFscmVhZHkgc2VsZWN0ZWRcblx0aWYgKCBkb2MgPT09IGRvY3VtZW50IHx8IGRvYy5ub2RlVHlwZSAhPT0gOSB8fCAhZG9jLmRvY3VtZW50RWxlbWVudCApIHtcblx0XHRyZXR1cm4gZG9jdW1lbnQ7XG5cdH1cblxuXHQvLyBVcGRhdGUgZ2xvYmFsIHZhcmlhYmxlc1xuXHRkb2N1bWVudCA9IGRvYztcblx0ZG9jRWxlbSA9IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudDtcblx0ZG9jdW1lbnRJc0hUTUwgPSAhaXNYTUwoIGRvY3VtZW50ICk7XG5cblx0Ly8gU3VwcG9ydDogSUUgOS0xMSwgRWRnZVxuXHQvLyBBY2Nlc3NpbmcgaWZyYW1lIGRvY3VtZW50cyBhZnRlciB1bmxvYWQgdGhyb3dzIFwicGVybWlzc2lvbiBkZW5pZWRcIiBlcnJvcnMgKGpRdWVyeSAjMTM5MzYpXG5cdGlmICggcHJlZmVycmVkRG9jICE9PSBkb2N1bWVudCAmJlxuXHRcdChzdWJXaW5kb3cgPSBkb2N1bWVudC5kZWZhdWx0VmlldykgJiYgc3ViV2luZG93LnRvcCAhPT0gc3ViV2luZG93ICkge1xuXG5cdFx0Ly8gU3VwcG9ydDogSUUgMTEsIEVkZ2Vcblx0XHRpZiAoIHN1YldpbmRvdy5hZGRFdmVudExpc3RlbmVyICkge1xuXHRcdFx0c3ViV2luZG93LmFkZEV2ZW50TGlzdGVuZXIoIFwidW5sb2FkXCIsIHVubG9hZEhhbmRsZXIsIGZhbHNlICk7XG5cblx0XHQvLyBTdXBwb3J0OiBJRSA5IC0gMTAgb25seVxuXHRcdH0gZWxzZSBpZiAoIHN1YldpbmRvdy5hdHRhY2hFdmVudCApIHtcblx0XHRcdHN1YldpbmRvdy5hdHRhY2hFdmVudCggXCJvbnVubG9hZFwiLCB1bmxvYWRIYW5kbGVyICk7XG5cdFx0fVxuXHR9XG5cblx0LyogQXR0cmlidXRlc1xuXHQtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tICovXG5cblx0Ly8gU3VwcG9ydDogSUU8OFxuXHQvLyBWZXJpZnkgdGhhdCBnZXRBdHRyaWJ1dGUgcmVhbGx5IHJldHVybnMgYXR0cmlidXRlcyBhbmQgbm90IHByb3BlcnRpZXNcblx0Ly8gKGV4Y2VwdGluZyBJRTggYm9vbGVhbnMpXG5cdHN1cHBvcnQuYXR0cmlidXRlcyA9IGFzc2VydChmdW5jdGlvbiggZWwgKSB7XG5cdFx0ZWwuY2xhc3NOYW1lID0gXCJpXCI7XG5cdFx0cmV0dXJuICFlbC5nZXRBdHRyaWJ1dGUoXCJjbGFzc05hbWVcIik7XG5cdH0pO1xuXG5cdC8qIGdldEVsZW1lbnQocylCeSpcblx0LS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAqL1xuXG5cdC8vIENoZWNrIGlmIGdldEVsZW1lbnRzQnlUYWdOYW1lKFwiKlwiKSByZXR1cm5zIG9ubHkgZWxlbWVudHNcblx0c3VwcG9ydC5nZXRFbGVtZW50c0J5VGFnTmFtZSA9IGFzc2VydChmdW5jdGlvbiggZWwgKSB7XG5cdFx0ZWwuYXBwZW5kQ2hpbGQoIGRvY3VtZW50LmNyZWF0ZUNvbW1lbnQoXCJcIikgKTtcblx0XHRyZXR1cm4gIWVsLmdldEVsZW1lbnRzQnlUYWdOYW1lKFwiKlwiKS5sZW5ndGg7XG5cdH0pO1xuXG5cdC8vIFN1cHBvcnQ6IElFPDlcblx0c3VwcG9ydC5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lID0gcm5hdGl2ZS50ZXN0KCBkb2N1bWVudC5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lICk7XG5cblx0Ly8gU3VwcG9ydDogSUU8MTBcblx0Ly8gQ2hlY2sgaWYgZ2V0RWxlbWVudEJ5SWQgcmV0dXJucyBlbGVtZW50cyBieSBuYW1lXG5cdC8vIFRoZSBicm9rZW4gZ2V0RWxlbWVudEJ5SWQgbWV0aG9kcyBkb24ndCBwaWNrIHVwIHByb2dyYW1tYXRpY2FsbHktc2V0IG5hbWVzLFxuXHQvLyBzbyB1c2UgYSByb3VuZGFib3V0IGdldEVsZW1lbnRzQnlOYW1lIHRlc3Rcblx0c3VwcG9ydC5nZXRCeUlkID0gYXNzZXJ0KGZ1bmN0aW9uKCBlbCApIHtcblx0XHRkb2NFbGVtLmFwcGVuZENoaWxkKCBlbCApLmlkID0gZXhwYW5kbztcblx0XHRyZXR1cm4gIWRvY3VtZW50LmdldEVsZW1lbnRzQnlOYW1lIHx8ICFkb2N1bWVudC5nZXRFbGVtZW50c0J5TmFtZSggZXhwYW5kbyApLmxlbmd0aDtcblx0fSk7XG5cblx0Ly8gSUQgZmlsdGVyIGFuZCBmaW5kXG5cdGlmICggc3VwcG9ydC5nZXRCeUlkICkge1xuXHRcdEV4cHIuZmlsdGVyW1wiSURcIl0gPSBmdW5jdGlvbiggaWQgKSB7XG5cdFx0XHR2YXIgYXR0cklkID0gaWQucmVwbGFjZSggcnVuZXNjYXBlLCBmdW5lc2NhcGUgKTtcblx0XHRcdHJldHVybiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdFx0cmV0dXJuIGVsZW0uZ2V0QXR0cmlidXRlKFwiaWRcIikgPT09IGF0dHJJZDtcblx0XHRcdH07XG5cdFx0fTtcblx0XHRFeHByLmZpbmRbXCJJRFwiXSA9IGZ1bmN0aW9uKCBpZCwgY29udGV4dCApIHtcblx0XHRcdGlmICggdHlwZW9mIGNvbnRleHQuZ2V0RWxlbWVudEJ5SWQgIT09IFwidW5kZWZpbmVkXCIgJiYgZG9jdW1lbnRJc0hUTUwgKSB7XG5cdFx0XHRcdHZhciBlbGVtID0gY29udGV4dC5nZXRFbGVtZW50QnlJZCggaWQgKTtcblx0XHRcdFx0cmV0dXJuIGVsZW0gPyBbIGVsZW0gXSA6IFtdO1xuXHRcdFx0fVxuXHRcdH07XG5cdH0gZWxzZSB7XG5cdFx0RXhwci5maWx0ZXJbXCJJRFwiXSA9ICBmdW5jdGlvbiggaWQgKSB7XG5cdFx0XHR2YXIgYXR0cklkID0gaWQucmVwbGFjZSggcnVuZXNjYXBlLCBmdW5lc2NhcGUgKTtcblx0XHRcdHJldHVybiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdFx0dmFyIG5vZGUgPSB0eXBlb2YgZWxlbS5nZXRBdHRyaWJ1dGVOb2RlICE9PSBcInVuZGVmaW5lZFwiICYmXG5cdFx0XHRcdFx0ZWxlbS5nZXRBdHRyaWJ1dGVOb2RlKFwiaWRcIik7XG5cdFx0XHRcdHJldHVybiBub2RlICYmIG5vZGUudmFsdWUgPT09IGF0dHJJZDtcblx0XHRcdH07XG5cdFx0fTtcblxuXHRcdC8vIFN1cHBvcnQ6IElFIDYgLSA3IG9ubHlcblx0XHQvLyBnZXRFbGVtZW50QnlJZCBpcyBub3QgcmVsaWFibGUgYXMgYSBmaW5kIHNob3J0Y3V0XG5cdFx0RXhwci5maW5kW1wiSURcIl0gPSBmdW5jdGlvbiggaWQsIGNvbnRleHQgKSB7XG5cdFx0XHRpZiAoIHR5cGVvZiBjb250ZXh0LmdldEVsZW1lbnRCeUlkICE9PSBcInVuZGVmaW5lZFwiICYmIGRvY3VtZW50SXNIVE1MICkge1xuXHRcdFx0XHR2YXIgbm9kZSwgaSwgZWxlbXMsXG5cdFx0XHRcdFx0ZWxlbSA9IGNvbnRleHQuZ2V0RWxlbWVudEJ5SWQoIGlkICk7XG5cblx0XHRcdFx0aWYgKCBlbGVtICkge1xuXG5cdFx0XHRcdFx0Ly8gVmVyaWZ5IHRoZSBpZCBhdHRyaWJ1dGVcblx0XHRcdFx0XHRub2RlID0gZWxlbS5nZXRBdHRyaWJ1dGVOb2RlKFwiaWRcIik7XG5cdFx0XHRcdFx0aWYgKCBub2RlICYmIG5vZGUudmFsdWUgPT09IGlkICkge1xuXHRcdFx0XHRcdFx0cmV0dXJuIFsgZWxlbSBdO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdC8vIEZhbGwgYmFjayBvbiBnZXRFbGVtZW50c0J5TmFtZVxuXHRcdFx0XHRcdGVsZW1zID0gY29udGV4dC5nZXRFbGVtZW50c0J5TmFtZSggaWQgKTtcblx0XHRcdFx0XHRpID0gMDtcblx0XHRcdFx0XHR3aGlsZSAoIChlbGVtID0gZWxlbXNbaSsrXSkgKSB7XG5cdFx0XHRcdFx0XHRub2RlID0gZWxlbS5nZXRBdHRyaWJ1dGVOb2RlKFwiaWRcIik7XG5cdFx0XHRcdFx0XHRpZiAoIG5vZGUgJiYgbm9kZS52YWx1ZSA9PT0gaWQgKSB7XG5cdFx0XHRcdFx0XHRcdHJldHVybiBbIGVsZW0gXTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRyZXR1cm4gW107XG5cdFx0XHR9XG5cdFx0fTtcblx0fVxuXG5cdC8vIFRhZ1xuXHRFeHByLmZpbmRbXCJUQUdcIl0gPSBzdXBwb3J0LmdldEVsZW1lbnRzQnlUYWdOYW1lID9cblx0XHRmdW5jdGlvbiggdGFnLCBjb250ZXh0ICkge1xuXHRcdFx0aWYgKCB0eXBlb2YgY29udGV4dC5nZXRFbGVtZW50c0J5VGFnTmFtZSAhPT0gXCJ1bmRlZmluZWRcIiApIHtcblx0XHRcdFx0cmV0dXJuIGNvbnRleHQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoIHRhZyApO1xuXG5cdFx0XHQvLyBEb2N1bWVudEZyYWdtZW50IG5vZGVzIGRvbid0IGhhdmUgZ0VCVE5cblx0XHRcdH0gZWxzZSBpZiAoIHN1cHBvcnQucXNhICkge1xuXHRcdFx0XHRyZXR1cm4gY29udGV4dC5xdWVyeVNlbGVjdG9yQWxsKCB0YWcgKTtcblx0XHRcdH1cblx0XHR9IDpcblxuXHRcdGZ1bmN0aW9uKCB0YWcsIGNvbnRleHQgKSB7XG5cdFx0XHR2YXIgZWxlbSxcblx0XHRcdFx0dG1wID0gW10sXG5cdFx0XHRcdGkgPSAwLFxuXHRcdFx0XHQvLyBCeSBoYXBweSBjb2luY2lkZW5jZSwgYSAoYnJva2VuKSBnRUJUTiBhcHBlYXJzIG9uIERvY3VtZW50RnJhZ21lbnQgbm9kZXMgdG9vXG5cdFx0XHRcdHJlc3VsdHMgPSBjb250ZXh0LmdldEVsZW1lbnRzQnlUYWdOYW1lKCB0YWcgKTtcblxuXHRcdFx0Ly8gRmlsdGVyIG91dCBwb3NzaWJsZSBjb21tZW50c1xuXHRcdFx0aWYgKCB0YWcgPT09IFwiKlwiICkge1xuXHRcdFx0XHR3aGlsZSAoIChlbGVtID0gcmVzdWx0c1tpKytdKSApIHtcblx0XHRcdFx0XHRpZiAoIGVsZW0ubm9kZVR5cGUgPT09IDEgKSB7XG5cdFx0XHRcdFx0XHR0bXAucHVzaCggZWxlbSApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXG5cdFx0XHRcdHJldHVybiB0bXA7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gcmVzdWx0cztcblx0XHR9O1xuXG5cdC8vIENsYXNzXG5cdEV4cHIuZmluZFtcIkNMQVNTXCJdID0gc3VwcG9ydC5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lICYmIGZ1bmN0aW9uKCBjbGFzc05hbWUsIGNvbnRleHQgKSB7XG5cdFx0aWYgKCB0eXBlb2YgY29udGV4dC5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lICE9PSBcInVuZGVmaW5lZFwiICYmIGRvY3VtZW50SXNIVE1MICkge1xuXHRcdFx0cmV0dXJuIGNvbnRleHQuZ2V0RWxlbWVudHNCeUNsYXNzTmFtZSggY2xhc3NOYW1lICk7XG5cdFx0fVxuXHR9O1xuXG5cdC8qIFFTQS9tYXRjaGVzU2VsZWN0b3Jcblx0LS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAqL1xuXG5cdC8vIFFTQSBhbmQgbWF0Y2hlc1NlbGVjdG9yIHN1cHBvcnRcblxuXHQvLyBtYXRjaGVzU2VsZWN0b3IoOmFjdGl2ZSkgcmVwb3J0cyBmYWxzZSB3aGVuIHRydWUgKElFOS9PcGVyYSAxMS41KVxuXHRyYnVnZ3lNYXRjaGVzID0gW107XG5cblx0Ly8gcVNhKDpmb2N1cykgcmVwb3J0cyBmYWxzZSB3aGVuIHRydWUgKENocm9tZSAyMSlcblx0Ly8gV2UgYWxsb3cgdGhpcyBiZWNhdXNlIG9mIGEgYnVnIGluIElFOC85IHRoYXQgdGhyb3dzIGFuIGVycm9yXG5cdC8vIHdoZW5ldmVyIGBkb2N1bWVudC5hY3RpdmVFbGVtZW50YCBpcyBhY2Nlc3NlZCBvbiBhbiBpZnJhbWVcblx0Ly8gU28sIHdlIGFsbG93IDpmb2N1cyB0byBwYXNzIHRocm91Z2ggUVNBIGFsbCB0aGUgdGltZSB0byBhdm9pZCB0aGUgSUUgZXJyb3Jcblx0Ly8gU2VlIGh0dHBzOi8vYnVncy5qcXVlcnkuY29tL3RpY2tldC8xMzM3OFxuXHRyYnVnZ3lRU0EgPSBbXTtcblxuXHRpZiAoIChzdXBwb3J0LnFzYSA9IHJuYXRpdmUudGVzdCggZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbCApKSApIHtcblx0XHQvLyBCdWlsZCBRU0EgcmVnZXhcblx0XHQvLyBSZWdleCBzdHJhdGVneSBhZG9wdGVkIGZyb20gRGllZ28gUGVyaW5pXG5cdFx0YXNzZXJ0KGZ1bmN0aW9uKCBlbCApIHtcblx0XHRcdC8vIFNlbGVjdCBpcyBzZXQgdG8gZW1wdHkgc3RyaW5nIG9uIHB1cnBvc2Vcblx0XHRcdC8vIFRoaXMgaXMgdG8gdGVzdCBJRSdzIHRyZWF0bWVudCBvZiBub3QgZXhwbGljaXRseVxuXHRcdFx0Ly8gc2V0dGluZyBhIGJvb2xlYW4gY29udGVudCBhdHRyaWJ1dGUsXG5cdFx0XHQvLyBzaW5jZSBpdHMgcHJlc2VuY2Ugc2hvdWxkIGJlIGVub3VnaFxuXHRcdFx0Ly8gaHR0cHM6Ly9idWdzLmpxdWVyeS5jb20vdGlja2V0LzEyMzU5XG5cdFx0XHRkb2NFbGVtLmFwcGVuZENoaWxkKCBlbCApLmlubmVySFRNTCA9IFwiPGEgaWQ9J1wiICsgZXhwYW5kbyArIFwiJz48L2E+XCIgK1xuXHRcdFx0XHRcIjxzZWxlY3QgaWQ9J1wiICsgZXhwYW5kbyArIFwiLVxcclxcXFwnIG1zYWxsb3djYXB0dXJlPScnPlwiICtcblx0XHRcdFx0XCI8b3B0aW9uIHNlbGVjdGVkPScnPjwvb3B0aW9uPjwvc2VsZWN0PlwiO1xuXG5cdFx0XHQvLyBTdXBwb3J0OiBJRTgsIE9wZXJhIDExLTEyLjE2XG5cdFx0XHQvLyBOb3RoaW5nIHNob3VsZCBiZSBzZWxlY3RlZCB3aGVuIGVtcHR5IHN0cmluZ3MgZm9sbG93IF49IG9yICQ9IG9yICo9XG5cdFx0XHQvLyBUaGUgdGVzdCBhdHRyaWJ1dGUgbXVzdCBiZSB1bmtub3duIGluIE9wZXJhIGJ1dCBcInNhZmVcIiBmb3IgV2luUlRcblx0XHRcdC8vIGh0dHBzOi8vbXNkbi5taWNyb3NvZnQuY29tL2VuLXVzL2xpYnJhcnkvaWUvaGg0NjUzODguYXNweCNhdHRyaWJ1dGVfc2VjdGlvblxuXHRcdFx0aWYgKCBlbC5xdWVyeVNlbGVjdG9yQWxsKFwiW21zYWxsb3djYXB0dXJlXj0nJ11cIikubGVuZ3RoICkge1xuXHRcdFx0XHRyYnVnZ3lRU0EucHVzaCggXCJbKl4kXT1cIiArIHdoaXRlc3BhY2UgKyBcIiooPzonJ3xcXFwiXFxcIilcIiApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBTdXBwb3J0OiBJRThcblx0XHRcdC8vIEJvb2xlYW4gYXR0cmlidXRlcyBhbmQgXCJ2YWx1ZVwiIGFyZSBub3QgdHJlYXRlZCBjb3JyZWN0bHlcblx0XHRcdGlmICggIWVsLnF1ZXJ5U2VsZWN0b3JBbGwoXCJbc2VsZWN0ZWRdXCIpLmxlbmd0aCApIHtcblx0XHRcdFx0cmJ1Z2d5UVNBLnB1c2goIFwiXFxcXFtcIiArIHdoaXRlc3BhY2UgKyBcIiooPzp2YWx1ZXxcIiArIGJvb2xlYW5zICsgXCIpXCIgKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gU3VwcG9ydDogQ2hyb21lPDI5LCBBbmRyb2lkPDQuNCwgU2FmYXJpPDcuMCssIGlPUzw3LjArLCBQaGFudG9tSlM8MS45LjgrXG5cdFx0XHRpZiAoICFlbC5xdWVyeVNlbGVjdG9yQWxsKCBcIltpZH49XCIgKyBleHBhbmRvICsgXCItXVwiICkubGVuZ3RoICkge1xuXHRcdFx0XHRyYnVnZ3lRU0EucHVzaChcIn49XCIpO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBXZWJraXQvT3BlcmEgLSA6Y2hlY2tlZCBzaG91bGQgcmV0dXJuIHNlbGVjdGVkIG9wdGlvbiBlbGVtZW50c1xuXHRcdFx0Ly8gaHR0cDovL3d3dy53My5vcmcvVFIvMjAxMS9SRUMtY3NzMy1zZWxlY3RvcnMtMjAxMTA5MjkvI2NoZWNrZWRcblx0XHRcdC8vIElFOCB0aHJvd3MgZXJyb3IgaGVyZSBhbmQgd2lsbCBub3Qgc2VlIGxhdGVyIHRlc3RzXG5cdFx0XHRpZiAoICFlbC5xdWVyeVNlbGVjdG9yQWxsKFwiOmNoZWNrZWRcIikubGVuZ3RoICkge1xuXHRcdFx0XHRyYnVnZ3lRU0EucHVzaChcIjpjaGVja2VkXCIpO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBTdXBwb3J0OiBTYWZhcmkgOCssIGlPUyA4K1xuXHRcdFx0Ly8gaHR0cHM6Ly9idWdzLndlYmtpdC5vcmcvc2hvd19idWcuY2dpP2lkPTEzNjg1MVxuXHRcdFx0Ly8gSW4tcGFnZSBgc2VsZWN0b3IjaWQgc2libGluZy1jb21iaW5hdG9yIHNlbGVjdG9yYCBmYWlsc1xuXHRcdFx0aWYgKCAhZWwucXVlcnlTZWxlY3RvckFsbCggXCJhI1wiICsgZXhwYW5kbyArIFwiKypcIiApLmxlbmd0aCApIHtcblx0XHRcdFx0cmJ1Z2d5UVNBLnB1c2goXCIuIy4rWyt+XVwiKTtcblx0XHRcdH1cblx0XHR9KTtcblxuXHRcdGFzc2VydChmdW5jdGlvbiggZWwgKSB7XG5cdFx0XHRlbC5pbm5lckhUTUwgPSBcIjxhIGhyZWY9JycgZGlzYWJsZWQ9J2Rpc2FibGVkJz48L2E+XCIgK1xuXHRcdFx0XHRcIjxzZWxlY3QgZGlzYWJsZWQ9J2Rpc2FibGVkJz48b3B0aW9uLz48L3NlbGVjdD5cIjtcblxuXHRcdFx0Ly8gU3VwcG9ydDogV2luZG93cyA4IE5hdGl2ZSBBcHBzXG5cdFx0XHQvLyBUaGUgdHlwZSBhbmQgbmFtZSBhdHRyaWJ1dGVzIGFyZSByZXN0cmljdGVkIGR1cmluZyAuaW5uZXJIVE1MIGFzc2lnbm1lbnRcblx0XHRcdHZhciBpbnB1dCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJpbnB1dFwiKTtcblx0XHRcdGlucHV0LnNldEF0dHJpYnV0ZSggXCJ0eXBlXCIsIFwiaGlkZGVuXCIgKTtcblx0XHRcdGVsLmFwcGVuZENoaWxkKCBpbnB1dCApLnNldEF0dHJpYnV0ZSggXCJuYW1lXCIsIFwiRFwiICk7XG5cblx0XHRcdC8vIFN1cHBvcnQ6IElFOFxuXHRcdFx0Ly8gRW5mb3JjZSBjYXNlLXNlbnNpdGl2aXR5IG9mIG5hbWUgYXR0cmlidXRlXG5cdFx0XHRpZiAoIGVsLnF1ZXJ5U2VsZWN0b3JBbGwoXCJbbmFtZT1kXVwiKS5sZW5ndGggKSB7XG5cdFx0XHRcdHJidWdneVFTQS5wdXNoKCBcIm5hbWVcIiArIHdoaXRlc3BhY2UgKyBcIipbKl4kfCF+XT89XCIgKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gRkYgMy41IC0gOmVuYWJsZWQvOmRpc2FibGVkIGFuZCBoaWRkZW4gZWxlbWVudHMgKGhpZGRlbiBlbGVtZW50cyBhcmUgc3RpbGwgZW5hYmxlZClcblx0XHRcdC8vIElFOCB0aHJvd3MgZXJyb3IgaGVyZSBhbmQgd2lsbCBub3Qgc2VlIGxhdGVyIHRlc3RzXG5cdFx0XHRpZiAoIGVsLnF1ZXJ5U2VsZWN0b3JBbGwoXCI6ZW5hYmxlZFwiKS5sZW5ndGggIT09IDIgKSB7XG5cdFx0XHRcdHJidWdneVFTQS5wdXNoKCBcIjplbmFibGVkXCIsIFwiOmRpc2FibGVkXCIgKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gU3VwcG9ydDogSUU5LTExK1xuXHRcdFx0Ly8gSUUncyA6ZGlzYWJsZWQgc2VsZWN0b3IgZG9lcyBub3QgcGljayB1cCB0aGUgY2hpbGRyZW4gb2YgZGlzYWJsZWQgZmllbGRzZXRzXG5cdFx0XHRkb2NFbGVtLmFwcGVuZENoaWxkKCBlbCApLmRpc2FibGVkID0gdHJ1ZTtcblx0XHRcdGlmICggZWwucXVlcnlTZWxlY3RvckFsbChcIjpkaXNhYmxlZFwiKS5sZW5ndGggIT09IDIgKSB7XG5cdFx0XHRcdHJidWdneVFTQS5wdXNoKCBcIjplbmFibGVkXCIsIFwiOmRpc2FibGVkXCIgKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gT3BlcmEgMTAtMTEgZG9lcyBub3QgdGhyb3cgb24gcG9zdC1jb21tYSBpbnZhbGlkIHBzZXVkb3Ncblx0XHRcdGVsLnF1ZXJ5U2VsZWN0b3JBbGwoXCIqLDp4XCIpO1xuXHRcdFx0cmJ1Z2d5UVNBLnB1c2goXCIsLio6XCIpO1xuXHRcdH0pO1xuXHR9XG5cblx0aWYgKCAoc3VwcG9ydC5tYXRjaGVzU2VsZWN0b3IgPSBybmF0aXZlLnRlc3QoIChtYXRjaGVzID0gZG9jRWxlbS5tYXRjaGVzIHx8XG5cdFx0ZG9jRWxlbS53ZWJraXRNYXRjaGVzU2VsZWN0b3IgfHxcblx0XHRkb2NFbGVtLm1vek1hdGNoZXNTZWxlY3RvciB8fFxuXHRcdGRvY0VsZW0ub01hdGNoZXNTZWxlY3RvciB8fFxuXHRcdGRvY0VsZW0ubXNNYXRjaGVzU2VsZWN0b3IpICkpICkge1xuXG5cdFx0YXNzZXJ0KGZ1bmN0aW9uKCBlbCApIHtcblx0XHRcdC8vIENoZWNrIHRvIHNlZSBpZiBpdCdzIHBvc3NpYmxlIHRvIGRvIG1hdGNoZXNTZWxlY3RvclxuXHRcdFx0Ly8gb24gYSBkaXNjb25uZWN0ZWQgbm9kZSAoSUUgOSlcblx0XHRcdHN1cHBvcnQuZGlzY29ubmVjdGVkTWF0Y2ggPSBtYXRjaGVzLmNhbGwoIGVsLCBcIipcIiApO1xuXG5cdFx0XHQvLyBUaGlzIHNob3VsZCBmYWlsIHdpdGggYW4gZXhjZXB0aW9uXG5cdFx0XHQvLyBHZWNrbyBkb2VzIG5vdCBlcnJvciwgcmV0dXJucyBmYWxzZSBpbnN0ZWFkXG5cdFx0XHRtYXRjaGVzLmNhbGwoIGVsLCBcIltzIT0nJ106eFwiICk7XG5cdFx0XHRyYnVnZ3lNYXRjaGVzLnB1c2goIFwiIT1cIiwgcHNldWRvcyApO1xuXHRcdH0pO1xuXHR9XG5cblx0cmJ1Z2d5UVNBID0gcmJ1Z2d5UVNBLmxlbmd0aCAmJiBuZXcgUmVnRXhwKCByYnVnZ3lRU0Euam9pbihcInxcIikgKTtcblx0cmJ1Z2d5TWF0Y2hlcyA9IHJidWdneU1hdGNoZXMubGVuZ3RoICYmIG5ldyBSZWdFeHAoIHJidWdneU1hdGNoZXMuam9pbihcInxcIikgKTtcblxuXHQvKiBDb250YWluc1xuXHQtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tICovXG5cdGhhc0NvbXBhcmUgPSBybmF0aXZlLnRlc3QoIGRvY0VsZW0uY29tcGFyZURvY3VtZW50UG9zaXRpb24gKTtcblxuXHQvLyBFbGVtZW50IGNvbnRhaW5zIGFub3RoZXJcblx0Ly8gUHVycG9zZWZ1bGx5IHNlbGYtZXhjbHVzaXZlXG5cdC8vIEFzIGluLCBhbiBlbGVtZW50IGRvZXMgbm90IGNvbnRhaW4gaXRzZWxmXG5cdGNvbnRhaW5zID0gaGFzQ29tcGFyZSB8fCBybmF0aXZlLnRlc3QoIGRvY0VsZW0uY29udGFpbnMgKSA/XG5cdFx0ZnVuY3Rpb24oIGEsIGIgKSB7XG5cdFx0XHR2YXIgYWRvd24gPSBhLm5vZGVUeXBlID09PSA5ID8gYS5kb2N1bWVudEVsZW1lbnQgOiBhLFxuXHRcdFx0XHRidXAgPSBiICYmIGIucGFyZW50Tm9kZTtcblx0XHRcdHJldHVybiBhID09PSBidXAgfHwgISEoIGJ1cCAmJiBidXAubm9kZVR5cGUgPT09IDEgJiYgKFxuXHRcdFx0XHRhZG93bi5jb250YWlucyA/XG5cdFx0XHRcdFx0YWRvd24uY29udGFpbnMoIGJ1cCApIDpcblx0XHRcdFx0XHRhLmNvbXBhcmVEb2N1bWVudFBvc2l0aW9uICYmIGEuY29tcGFyZURvY3VtZW50UG9zaXRpb24oIGJ1cCApICYgMTZcblx0XHRcdCkpO1xuXHRcdH0gOlxuXHRcdGZ1bmN0aW9uKCBhLCBiICkge1xuXHRcdFx0aWYgKCBiICkge1xuXHRcdFx0XHR3aGlsZSAoIChiID0gYi5wYXJlbnROb2RlKSApIHtcblx0XHRcdFx0XHRpZiAoIGIgPT09IGEgKSB7XG5cdFx0XHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9O1xuXG5cdC8qIFNvcnRpbmdcblx0LS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAqL1xuXG5cdC8vIERvY3VtZW50IG9yZGVyIHNvcnRpbmdcblx0c29ydE9yZGVyID0gaGFzQ29tcGFyZSA/XG5cdGZ1bmN0aW9uKCBhLCBiICkge1xuXG5cdFx0Ly8gRmxhZyBmb3IgZHVwbGljYXRlIHJlbW92YWxcblx0XHRpZiAoIGEgPT09IGIgKSB7XG5cdFx0XHRoYXNEdXBsaWNhdGUgPSB0cnVlO1xuXHRcdFx0cmV0dXJuIDA7XG5cdFx0fVxuXG5cdFx0Ly8gU29ydCBvbiBtZXRob2QgZXhpc3RlbmNlIGlmIG9ubHkgb25lIGlucHV0IGhhcyBjb21wYXJlRG9jdW1lbnRQb3NpdGlvblxuXHRcdHZhciBjb21wYXJlID0gIWEuY29tcGFyZURvY3VtZW50UG9zaXRpb24gLSAhYi5jb21wYXJlRG9jdW1lbnRQb3NpdGlvbjtcblx0XHRpZiAoIGNvbXBhcmUgKSB7XG5cdFx0XHRyZXR1cm4gY29tcGFyZTtcblx0XHR9XG5cblx0XHQvLyBDYWxjdWxhdGUgcG9zaXRpb24gaWYgYm90aCBpbnB1dHMgYmVsb25nIHRvIHRoZSBzYW1lIGRvY3VtZW50XG5cdFx0Y29tcGFyZSA9ICggYS5vd25lckRvY3VtZW50IHx8IGEgKSA9PT0gKCBiLm93bmVyRG9jdW1lbnQgfHwgYiApID9cblx0XHRcdGEuY29tcGFyZURvY3VtZW50UG9zaXRpb24oIGIgKSA6XG5cblx0XHRcdC8vIE90aGVyd2lzZSB3ZSBrbm93IHRoZXkgYXJlIGRpc2Nvbm5lY3RlZFxuXHRcdFx0MTtcblxuXHRcdC8vIERpc2Nvbm5lY3RlZCBub2Rlc1xuXHRcdGlmICggY29tcGFyZSAmIDEgfHxcblx0XHRcdCghc3VwcG9ydC5zb3J0RGV0YWNoZWQgJiYgYi5jb21wYXJlRG9jdW1lbnRQb3NpdGlvbiggYSApID09PSBjb21wYXJlKSApIHtcblxuXHRcdFx0Ly8gQ2hvb3NlIHRoZSBmaXJzdCBlbGVtZW50IHRoYXQgaXMgcmVsYXRlZCB0byBvdXIgcHJlZmVycmVkIGRvY3VtZW50XG5cdFx0XHRpZiAoIGEgPT09IGRvY3VtZW50IHx8IGEub3duZXJEb2N1bWVudCA9PT0gcHJlZmVycmVkRG9jICYmIGNvbnRhaW5zKHByZWZlcnJlZERvYywgYSkgKSB7XG5cdFx0XHRcdHJldHVybiAtMTtcblx0XHRcdH1cblx0XHRcdGlmICggYiA9PT0gZG9jdW1lbnQgfHwgYi5vd25lckRvY3VtZW50ID09PSBwcmVmZXJyZWREb2MgJiYgY29udGFpbnMocHJlZmVycmVkRG9jLCBiKSApIHtcblx0XHRcdFx0cmV0dXJuIDE7XG5cdFx0XHR9XG5cblx0XHRcdC8vIE1haW50YWluIG9yaWdpbmFsIG9yZGVyXG5cdFx0XHRyZXR1cm4gc29ydElucHV0ID9cblx0XHRcdFx0KCBpbmRleE9mKCBzb3J0SW5wdXQsIGEgKSAtIGluZGV4T2YoIHNvcnRJbnB1dCwgYiApICkgOlxuXHRcdFx0XHQwO1xuXHRcdH1cblxuXHRcdHJldHVybiBjb21wYXJlICYgNCA/IC0xIDogMTtcblx0fSA6XG5cdGZ1bmN0aW9uKCBhLCBiICkge1xuXHRcdC8vIEV4aXQgZWFybHkgaWYgdGhlIG5vZGVzIGFyZSBpZGVudGljYWxcblx0XHRpZiAoIGEgPT09IGIgKSB7XG5cdFx0XHRoYXNEdXBsaWNhdGUgPSB0cnVlO1xuXHRcdFx0cmV0dXJuIDA7XG5cdFx0fVxuXG5cdFx0dmFyIGN1cixcblx0XHRcdGkgPSAwLFxuXHRcdFx0YXVwID0gYS5wYXJlbnROb2RlLFxuXHRcdFx0YnVwID0gYi5wYXJlbnROb2RlLFxuXHRcdFx0YXAgPSBbIGEgXSxcblx0XHRcdGJwID0gWyBiIF07XG5cblx0XHQvLyBQYXJlbnRsZXNzIG5vZGVzIGFyZSBlaXRoZXIgZG9jdW1lbnRzIG9yIGRpc2Nvbm5lY3RlZFxuXHRcdGlmICggIWF1cCB8fCAhYnVwICkge1xuXHRcdFx0cmV0dXJuIGEgPT09IGRvY3VtZW50ID8gLTEgOlxuXHRcdFx0XHRiID09PSBkb2N1bWVudCA/IDEgOlxuXHRcdFx0XHRhdXAgPyAtMSA6XG5cdFx0XHRcdGJ1cCA/IDEgOlxuXHRcdFx0XHRzb3J0SW5wdXQgP1xuXHRcdFx0XHQoIGluZGV4T2YoIHNvcnRJbnB1dCwgYSApIC0gaW5kZXhPZiggc29ydElucHV0LCBiICkgKSA6XG5cdFx0XHRcdDA7XG5cblx0XHQvLyBJZiB0aGUgbm9kZXMgYXJlIHNpYmxpbmdzLCB3ZSBjYW4gZG8gYSBxdWljayBjaGVja1xuXHRcdH0gZWxzZSBpZiAoIGF1cCA9PT0gYnVwICkge1xuXHRcdFx0cmV0dXJuIHNpYmxpbmdDaGVjayggYSwgYiApO1xuXHRcdH1cblxuXHRcdC8vIE90aGVyd2lzZSB3ZSBuZWVkIGZ1bGwgbGlzdHMgb2YgdGhlaXIgYW5jZXN0b3JzIGZvciBjb21wYXJpc29uXG5cdFx0Y3VyID0gYTtcblx0XHR3aGlsZSAoIChjdXIgPSBjdXIucGFyZW50Tm9kZSkgKSB7XG5cdFx0XHRhcC51bnNoaWZ0KCBjdXIgKTtcblx0XHR9XG5cdFx0Y3VyID0gYjtcblx0XHR3aGlsZSAoIChjdXIgPSBjdXIucGFyZW50Tm9kZSkgKSB7XG5cdFx0XHRicC51bnNoaWZ0KCBjdXIgKTtcblx0XHR9XG5cblx0XHQvLyBXYWxrIGRvd24gdGhlIHRyZWUgbG9va2luZyBmb3IgYSBkaXNjcmVwYW5jeVxuXHRcdHdoaWxlICggYXBbaV0gPT09IGJwW2ldICkge1xuXHRcdFx0aSsrO1xuXHRcdH1cblxuXHRcdHJldHVybiBpID9cblx0XHRcdC8vIERvIGEgc2libGluZyBjaGVjayBpZiB0aGUgbm9kZXMgaGF2ZSBhIGNvbW1vbiBhbmNlc3RvclxuXHRcdFx0c2libGluZ0NoZWNrKCBhcFtpXSwgYnBbaV0gKSA6XG5cblx0XHRcdC8vIE90aGVyd2lzZSBub2RlcyBpbiBvdXIgZG9jdW1lbnQgc29ydCBmaXJzdFxuXHRcdFx0YXBbaV0gPT09IHByZWZlcnJlZERvYyA/IC0xIDpcblx0XHRcdGJwW2ldID09PSBwcmVmZXJyZWREb2MgPyAxIDpcblx0XHRcdDA7XG5cdH07XG5cblx0cmV0dXJuIGRvY3VtZW50O1xufTtcblxuU2l6emxlLm1hdGNoZXMgPSBmdW5jdGlvbiggZXhwciwgZWxlbWVudHMgKSB7XG5cdHJldHVybiBTaXp6bGUoIGV4cHIsIG51bGwsIG51bGwsIGVsZW1lbnRzICk7XG59O1xuXG5TaXp6bGUubWF0Y2hlc1NlbGVjdG9yID0gZnVuY3Rpb24oIGVsZW0sIGV4cHIgKSB7XG5cdC8vIFNldCBkb2N1bWVudCB2YXJzIGlmIG5lZWRlZFxuXHRpZiAoICggZWxlbS5vd25lckRvY3VtZW50IHx8IGVsZW0gKSAhPT0gZG9jdW1lbnQgKSB7XG5cdFx0c2V0RG9jdW1lbnQoIGVsZW0gKTtcblx0fVxuXG5cdGlmICggc3VwcG9ydC5tYXRjaGVzU2VsZWN0b3IgJiYgZG9jdW1lbnRJc0hUTUwgJiZcblx0XHQhbm9ubmF0aXZlU2VsZWN0b3JDYWNoZVsgZXhwciArIFwiIFwiIF0gJiZcblx0XHQoICFyYnVnZ3lNYXRjaGVzIHx8ICFyYnVnZ3lNYXRjaGVzLnRlc3QoIGV4cHIgKSApICYmXG5cdFx0KCAhcmJ1Z2d5UVNBICAgICB8fCAhcmJ1Z2d5UVNBLnRlc3QoIGV4cHIgKSApICkge1xuXG5cdFx0dHJ5IHtcblx0XHRcdHZhciByZXQgPSBtYXRjaGVzLmNhbGwoIGVsZW0sIGV4cHIgKTtcblxuXHRcdFx0Ly8gSUUgOSdzIG1hdGNoZXNTZWxlY3RvciByZXR1cm5zIGZhbHNlIG9uIGRpc2Nvbm5lY3RlZCBub2Rlc1xuXHRcdFx0aWYgKCByZXQgfHwgc3VwcG9ydC5kaXNjb25uZWN0ZWRNYXRjaCB8fFxuXHRcdFx0XHRcdC8vIEFzIHdlbGwsIGRpc2Nvbm5lY3RlZCBub2RlcyBhcmUgc2FpZCB0byBiZSBpbiBhIGRvY3VtZW50XG5cdFx0XHRcdFx0Ly8gZnJhZ21lbnQgaW4gSUUgOVxuXHRcdFx0XHRcdGVsZW0uZG9jdW1lbnQgJiYgZWxlbS5kb2N1bWVudC5ub2RlVHlwZSAhPT0gMTEgKSB7XG5cdFx0XHRcdHJldHVybiByZXQ7XG5cdFx0XHR9XG5cdFx0fSBjYXRjaCAoZSkge1xuXHRcdFx0bm9ubmF0aXZlU2VsZWN0b3JDYWNoZSggZXhwciwgdHJ1ZSApO1xuXHRcdH1cblx0fVxuXG5cdHJldHVybiBTaXp6bGUoIGV4cHIsIGRvY3VtZW50LCBudWxsLCBbIGVsZW0gXSApLmxlbmd0aCA+IDA7XG59O1xuXG5TaXp6bGUuY29udGFpbnMgPSBmdW5jdGlvbiggY29udGV4dCwgZWxlbSApIHtcblx0Ly8gU2V0IGRvY3VtZW50IHZhcnMgaWYgbmVlZGVkXG5cdGlmICggKCBjb250ZXh0Lm93bmVyRG9jdW1lbnQgfHwgY29udGV4dCApICE9PSBkb2N1bWVudCApIHtcblx0XHRzZXREb2N1bWVudCggY29udGV4dCApO1xuXHR9XG5cdHJldHVybiBjb250YWlucyggY29udGV4dCwgZWxlbSApO1xufTtcblxuU2l6emxlLmF0dHIgPSBmdW5jdGlvbiggZWxlbSwgbmFtZSApIHtcblx0Ly8gU2V0IGRvY3VtZW50IHZhcnMgaWYgbmVlZGVkXG5cdGlmICggKCBlbGVtLm93bmVyRG9jdW1lbnQgfHwgZWxlbSApICE9PSBkb2N1bWVudCApIHtcblx0XHRzZXREb2N1bWVudCggZWxlbSApO1xuXHR9XG5cblx0dmFyIGZuID0gRXhwci5hdHRySGFuZGxlWyBuYW1lLnRvTG93ZXJDYXNlKCkgXSxcblx0XHQvLyBEb24ndCBnZXQgZm9vbGVkIGJ5IE9iamVjdC5wcm90b3R5cGUgcHJvcGVydGllcyAoalF1ZXJ5ICMxMzgwNylcblx0XHR2YWwgPSBmbiAmJiBoYXNPd24uY2FsbCggRXhwci5hdHRySGFuZGxlLCBuYW1lLnRvTG93ZXJDYXNlKCkgKSA/XG5cdFx0XHRmbiggZWxlbSwgbmFtZSwgIWRvY3VtZW50SXNIVE1MICkgOlxuXHRcdFx0dW5kZWZpbmVkO1xuXG5cdHJldHVybiB2YWwgIT09IHVuZGVmaW5lZCA/XG5cdFx0dmFsIDpcblx0XHRzdXBwb3J0LmF0dHJpYnV0ZXMgfHwgIWRvY3VtZW50SXNIVE1MID9cblx0XHRcdGVsZW0uZ2V0QXR0cmlidXRlKCBuYW1lICkgOlxuXHRcdFx0KHZhbCA9IGVsZW0uZ2V0QXR0cmlidXRlTm9kZShuYW1lKSkgJiYgdmFsLnNwZWNpZmllZCA/XG5cdFx0XHRcdHZhbC52YWx1ZSA6XG5cdFx0XHRcdG51bGw7XG59O1xuXG5TaXp6bGUuZXNjYXBlID0gZnVuY3Rpb24oIHNlbCApIHtcblx0cmV0dXJuIChzZWwgKyBcIlwiKS5yZXBsYWNlKCByY3NzZXNjYXBlLCBmY3NzZXNjYXBlICk7XG59O1xuXG5TaXp6bGUuZXJyb3IgPSBmdW5jdGlvbiggbXNnICkge1xuXHR0aHJvdyBuZXcgRXJyb3IoIFwiU3ludGF4IGVycm9yLCB1bnJlY29nbml6ZWQgZXhwcmVzc2lvbjogXCIgKyBtc2cgKTtcbn07XG5cbi8qKlxuICogRG9jdW1lbnQgc29ydGluZyBhbmQgcmVtb3ZpbmcgZHVwbGljYXRlc1xuICogQHBhcmFtIHtBcnJheUxpa2V9IHJlc3VsdHNcbiAqL1xuU2l6emxlLnVuaXF1ZVNvcnQgPSBmdW5jdGlvbiggcmVzdWx0cyApIHtcblx0dmFyIGVsZW0sXG5cdFx0ZHVwbGljYXRlcyA9IFtdLFxuXHRcdGogPSAwLFxuXHRcdGkgPSAwO1xuXG5cdC8vIFVubGVzcyB3ZSAqa25vdyogd2UgY2FuIGRldGVjdCBkdXBsaWNhdGVzLCBhc3N1bWUgdGhlaXIgcHJlc2VuY2Vcblx0aGFzRHVwbGljYXRlID0gIXN1cHBvcnQuZGV0ZWN0RHVwbGljYXRlcztcblx0c29ydElucHV0ID0gIXN1cHBvcnQuc29ydFN0YWJsZSAmJiByZXN1bHRzLnNsaWNlKCAwICk7XG5cdHJlc3VsdHMuc29ydCggc29ydE9yZGVyICk7XG5cblx0aWYgKCBoYXNEdXBsaWNhdGUgKSB7XG5cdFx0d2hpbGUgKCAoZWxlbSA9IHJlc3VsdHNbaSsrXSkgKSB7XG5cdFx0XHRpZiAoIGVsZW0gPT09IHJlc3VsdHNbIGkgXSApIHtcblx0XHRcdFx0aiA9IGR1cGxpY2F0ZXMucHVzaCggaSApO1xuXHRcdFx0fVxuXHRcdH1cblx0XHR3aGlsZSAoIGotLSApIHtcblx0XHRcdHJlc3VsdHMuc3BsaWNlKCBkdXBsaWNhdGVzWyBqIF0sIDEgKTtcblx0XHR9XG5cdH1cblxuXHQvLyBDbGVhciBpbnB1dCBhZnRlciBzb3J0aW5nIHRvIHJlbGVhc2Ugb2JqZWN0c1xuXHQvLyBTZWUgaHR0cHM6Ly9naXRodWIuY29tL2pxdWVyeS9zaXp6bGUvcHVsbC8yMjVcblx0c29ydElucHV0ID0gbnVsbDtcblxuXHRyZXR1cm4gcmVzdWx0cztcbn07XG5cbi8qKlxuICogVXRpbGl0eSBmdW5jdGlvbiBmb3IgcmV0cmlldmluZyB0aGUgdGV4dCB2YWx1ZSBvZiBhbiBhcnJheSBvZiBET00gbm9kZXNcbiAqIEBwYXJhbSB7QXJyYXl8RWxlbWVudH0gZWxlbVxuICovXG5nZXRUZXh0ID0gU2l6emxlLmdldFRleHQgPSBmdW5jdGlvbiggZWxlbSApIHtcblx0dmFyIG5vZGUsXG5cdFx0cmV0ID0gXCJcIixcblx0XHRpID0gMCxcblx0XHRub2RlVHlwZSA9IGVsZW0ubm9kZVR5cGU7XG5cblx0aWYgKCAhbm9kZVR5cGUgKSB7XG5cdFx0Ly8gSWYgbm8gbm9kZVR5cGUsIHRoaXMgaXMgZXhwZWN0ZWQgdG8gYmUgYW4gYXJyYXlcblx0XHR3aGlsZSAoIChub2RlID0gZWxlbVtpKytdKSApIHtcblx0XHRcdC8vIERvIG5vdCB0cmF2ZXJzZSBjb21tZW50IG5vZGVzXG5cdFx0XHRyZXQgKz0gZ2V0VGV4dCggbm9kZSApO1xuXHRcdH1cblx0fSBlbHNlIGlmICggbm9kZVR5cGUgPT09IDEgfHwgbm9kZVR5cGUgPT09IDkgfHwgbm9kZVR5cGUgPT09IDExICkge1xuXHRcdC8vIFVzZSB0ZXh0Q29udGVudCBmb3IgZWxlbWVudHNcblx0XHQvLyBpbm5lclRleHQgdXNhZ2UgcmVtb3ZlZCBmb3IgY29uc2lzdGVuY3kgb2YgbmV3IGxpbmVzIChqUXVlcnkgIzExMTUzKVxuXHRcdGlmICggdHlwZW9mIGVsZW0udGV4dENvbnRlbnQgPT09IFwic3RyaW5nXCIgKSB7XG5cdFx0XHRyZXR1cm4gZWxlbS50ZXh0Q29udGVudDtcblx0XHR9IGVsc2Uge1xuXHRcdFx0Ly8gVHJhdmVyc2UgaXRzIGNoaWxkcmVuXG5cdFx0XHRmb3IgKCBlbGVtID0gZWxlbS5maXJzdENoaWxkOyBlbGVtOyBlbGVtID0gZWxlbS5uZXh0U2libGluZyApIHtcblx0XHRcdFx0cmV0ICs9IGdldFRleHQoIGVsZW0gKTtcblx0XHRcdH1cblx0XHR9XG5cdH0gZWxzZSBpZiAoIG5vZGVUeXBlID09PSAzIHx8IG5vZGVUeXBlID09PSA0ICkge1xuXHRcdHJldHVybiBlbGVtLm5vZGVWYWx1ZTtcblx0fVxuXHQvLyBEbyBub3QgaW5jbHVkZSBjb21tZW50IG9yIHByb2Nlc3NpbmcgaW5zdHJ1Y3Rpb24gbm9kZXNcblxuXHRyZXR1cm4gcmV0O1xufTtcblxuRXhwciA9IFNpenpsZS5zZWxlY3RvcnMgPSB7XG5cblx0Ly8gQ2FuIGJlIGFkanVzdGVkIGJ5IHRoZSB1c2VyXG5cdGNhY2hlTGVuZ3RoOiA1MCxcblxuXHRjcmVhdGVQc2V1ZG86IG1hcmtGdW5jdGlvbixcblxuXHRtYXRjaDogbWF0Y2hFeHByLFxuXG5cdGF0dHJIYW5kbGU6IHt9LFxuXG5cdGZpbmQ6IHt9LFxuXG5cdHJlbGF0aXZlOiB7XG5cdFx0XCI+XCI6IHsgZGlyOiBcInBhcmVudE5vZGVcIiwgZmlyc3Q6IHRydWUgfSxcblx0XHRcIiBcIjogeyBkaXI6IFwicGFyZW50Tm9kZVwiIH0sXG5cdFx0XCIrXCI6IHsgZGlyOiBcInByZXZpb3VzU2libGluZ1wiLCBmaXJzdDogdHJ1ZSB9LFxuXHRcdFwiflwiOiB7IGRpcjogXCJwcmV2aW91c1NpYmxpbmdcIiB9XG5cdH0sXG5cblx0cHJlRmlsdGVyOiB7XG5cdFx0XCJBVFRSXCI6IGZ1bmN0aW9uKCBtYXRjaCApIHtcblx0XHRcdG1hdGNoWzFdID0gbWF0Y2hbMV0ucmVwbGFjZSggcnVuZXNjYXBlLCBmdW5lc2NhcGUgKTtcblxuXHRcdFx0Ly8gTW92ZSB0aGUgZ2l2ZW4gdmFsdWUgdG8gbWF0Y2hbM10gd2hldGhlciBxdW90ZWQgb3IgdW5xdW90ZWRcblx0XHRcdG1hdGNoWzNdID0gKCBtYXRjaFszXSB8fCBtYXRjaFs0XSB8fCBtYXRjaFs1XSB8fCBcIlwiICkucmVwbGFjZSggcnVuZXNjYXBlLCBmdW5lc2NhcGUgKTtcblxuXHRcdFx0aWYgKCBtYXRjaFsyXSA9PT0gXCJ+PVwiICkge1xuXHRcdFx0XHRtYXRjaFszXSA9IFwiIFwiICsgbWF0Y2hbM10gKyBcIiBcIjtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIG1hdGNoLnNsaWNlKCAwLCA0ICk7XG5cdFx0fSxcblxuXHRcdFwiQ0hJTERcIjogZnVuY3Rpb24oIG1hdGNoICkge1xuXHRcdFx0LyogbWF0Y2hlcyBmcm9tIG1hdGNoRXhwcltcIkNISUxEXCJdXG5cdFx0XHRcdDEgdHlwZSAob25seXxudGh8Li4uKVxuXHRcdFx0XHQyIHdoYXQgKGNoaWxkfG9mLXR5cGUpXG5cdFx0XHRcdDMgYXJndW1lbnQgKGV2ZW58b2RkfFxcZCp8XFxkKm4oWystXVxcZCspP3wuLi4pXG5cdFx0XHRcdDQgeG4tY29tcG9uZW50IG9mIHhuK3kgYXJndW1lbnQgKFsrLV0/XFxkKm58KVxuXHRcdFx0XHQ1IHNpZ24gb2YgeG4tY29tcG9uZW50XG5cdFx0XHRcdDYgeCBvZiB4bi1jb21wb25lbnRcblx0XHRcdFx0NyBzaWduIG9mIHktY29tcG9uZW50XG5cdFx0XHRcdDggeSBvZiB5LWNvbXBvbmVudFxuXHRcdFx0Ki9cblx0XHRcdG1hdGNoWzFdID0gbWF0Y2hbMV0udG9Mb3dlckNhc2UoKTtcblxuXHRcdFx0aWYgKCBtYXRjaFsxXS5zbGljZSggMCwgMyApID09PSBcIm50aFwiICkge1xuXHRcdFx0XHQvLyBudGgtKiByZXF1aXJlcyBhcmd1bWVudFxuXHRcdFx0XHRpZiAoICFtYXRjaFszXSApIHtcblx0XHRcdFx0XHRTaXp6bGUuZXJyb3IoIG1hdGNoWzBdICk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBudW1lcmljIHggYW5kIHkgcGFyYW1ldGVycyBmb3IgRXhwci5maWx0ZXIuQ0hJTERcblx0XHRcdFx0Ly8gcmVtZW1iZXIgdGhhdCBmYWxzZS90cnVlIGNhc3QgcmVzcGVjdGl2ZWx5IHRvIDAvMVxuXHRcdFx0XHRtYXRjaFs0XSA9ICsoIG1hdGNoWzRdID8gbWF0Y2hbNV0gKyAobWF0Y2hbNl0gfHwgMSkgOiAyICogKCBtYXRjaFszXSA9PT0gXCJldmVuXCIgfHwgbWF0Y2hbM10gPT09IFwib2RkXCIgKSApO1xuXHRcdFx0XHRtYXRjaFs1XSA9ICsoICggbWF0Y2hbN10gKyBtYXRjaFs4XSApIHx8IG1hdGNoWzNdID09PSBcIm9kZFwiICk7XG5cblx0XHRcdC8vIG90aGVyIHR5cGVzIHByb2hpYml0IGFyZ3VtZW50c1xuXHRcdFx0fSBlbHNlIGlmICggbWF0Y2hbM10gKSB7XG5cdFx0XHRcdFNpenpsZS5lcnJvciggbWF0Y2hbMF0gKTtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIG1hdGNoO1xuXHRcdH0sXG5cblx0XHRcIlBTRVVET1wiOiBmdW5jdGlvbiggbWF0Y2ggKSB7XG5cdFx0XHR2YXIgZXhjZXNzLFxuXHRcdFx0XHR1bnF1b3RlZCA9ICFtYXRjaFs2XSAmJiBtYXRjaFsyXTtcblxuXHRcdFx0aWYgKCBtYXRjaEV4cHJbXCJDSElMRFwiXS50ZXN0KCBtYXRjaFswXSApICkge1xuXHRcdFx0XHRyZXR1cm4gbnVsbDtcblx0XHRcdH1cblxuXHRcdFx0Ly8gQWNjZXB0IHF1b3RlZCBhcmd1bWVudHMgYXMtaXNcblx0XHRcdGlmICggbWF0Y2hbM10gKSB7XG5cdFx0XHRcdG1hdGNoWzJdID0gbWF0Y2hbNF0gfHwgbWF0Y2hbNV0gfHwgXCJcIjtcblxuXHRcdFx0Ly8gU3RyaXAgZXhjZXNzIGNoYXJhY3RlcnMgZnJvbSB1bnF1b3RlZCBhcmd1bWVudHNcblx0XHRcdH0gZWxzZSBpZiAoIHVucXVvdGVkICYmIHJwc2V1ZG8udGVzdCggdW5xdW90ZWQgKSAmJlxuXHRcdFx0XHQvLyBHZXQgZXhjZXNzIGZyb20gdG9rZW5pemUgKHJlY3Vyc2l2ZWx5KVxuXHRcdFx0XHQoZXhjZXNzID0gdG9rZW5pemUoIHVucXVvdGVkLCB0cnVlICkpICYmXG5cdFx0XHRcdC8vIGFkdmFuY2UgdG8gdGhlIG5leHQgY2xvc2luZyBwYXJlbnRoZXNpc1xuXHRcdFx0XHQoZXhjZXNzID0gdW5xdW90ZWQuaW5kZXhPZiggXCIpXCIsIHVucXVvdGVkLmxlbmd0aCAtIGV4Y2VzcyApIC0gdW5xdW90ZWQubGVuZ3RoKSApIHtcblxuXHRcdFx0XHQvLyBleGNlc3MgaXMgYSBuZWdhdGl2ZSBpbmRleFxuXHRcdFx0XHRtYXRjaFswXSA9IG1hdGNoWzBdLnNsaWNlKCAwLCBleGNlc3MgKTtcblx0XHRcdFx0bWF0Y2hbMl0gPSB1bnF1b3RlZC5zbGljZSggMCwgZXhjZXNzICk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIFJldHVybiBvbmx5IGNhcHR1cmVzIG5lZWRlZCBieSB0aGUgcHNldWRvIGZpbHRlciBtZXRob2QgKHR5cGUgYW5kIGFyZ3VtZW50KVxuXHRcdFx0cmV0dXJuIG1hdGNoLnNsaWNlKCAwLCAzICk7XG5cdFx0fVxuXHR9LFxuXG5cdGZpbHRlcjoge1xuXG5cdFx0XCJUQUdcIjogZnVuY3Rpb24oIG5vZGVOYW1lU2VsZWN0b3IgKSB7XG5cdFx0XHR2YXIgbm9kZU5hbWUgPSBub2RlTmFtZVNlbGVjdG9yLnJlcGxhY2UoIHJ1bmVzY2FwZSwgZnVuZXNjYXBlICkudG9Mb3dlckNhc2UoKTtcblx0XHRcdHJldHVybiBub2RlTmFtZVNlbGVjdG9yID09PSBcIipcIiA/XG5cdFx0XHRcdGZ1bmN0aW9uKCkgeyByZXR1cm4gdHJ1ZTsgfSA6XG5cdFx0XHRcdGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0XHRcdHJldHVybiBlbGVtLm5vZGVOYW1lICYmIGVsZW0ubm9kZU5hbWUudG9Mb3dlckNhc2UoKSA9PT0gbm9kZU5hbWU7XG5cdFx0XHRcdH07XG5cdFx0fSxcblxuXHRcdFwiQ0xBU1NcIjogZnVuY3Rpb24oIGNsYXNzTmFtZSApIHtcblx0XHRcdHZhciBwYXR0ZXJuID0gY2xhc3NDYWNoZVsgY2xhc3NOYW1lICsgXCIgXCIgXTtcblxuXHRcdFx0cmV0dXJuIHBhdHRlcm4gfHxcblx0XHRcdFx0KHBhdHRlcm4gPSBuZXcgUmVnRXhwKCBcIihefFwiICsgd2hpdGVzcGFjZSArIFwiKVwiICsgY2xhc3NOYW1lICsgXCIoXCIgKyB3aGl0ZXNwYWNlICsgXCJ8JClcIiApKSAmJlxuXHRcdFx0XHRjbGFzc0NhY2hlKCBjbGFzc05hbWUsIGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0XHRcdHJldHVybiBwYXR0ZXJuLnRlc3QoIHR5cGVvZiBlbGVtLmNsYXNzTmFtZSA9PT0gXCJzdHJpbmdcIiAmJiBlbGVtLmNsYXNzTmFtZSB8fCB0eXBlb2YgZWxlbS5nZXRBdHRyaWJ1dGUgIT09IFwidW5kZWZpbmVkXCIgJiYgZWxlbS5nZXRBdHRyaWJ1dGUoXCJjbGFzc1wiKSB8fCBcIlwiICk7XG5cdFx0XHRcdH0pO1xuXHRcdH0sXG5cblx0XHRcIkFUVFJcIjogZnVuY3Rpb24oIG5hbWUsIG9wZXJhdG9yLCBjaGVjayApIHtcblx0XHRcdHJldHVybiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdFx0dmFyIHJlc3VsdCA9IFNpenpsZS5hdHRyKCBlbGVtLCBuYW1lICk7XG5cblx0XHRcdFx0aWYgKCByZXN1bHQgPT0gbnVsbCApIHtcblx0XHRcdFx0XHRyZXR1cm4gb3BlcmF0b3IgPT09IFwiIT1cIjtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAoICFvcGVyYXRvciApIHtcblx0XHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdHJlc3VsdCArPSBcIlwiO1xuXG5cdFx0XHRcdHJldHVybiBvcGVyYXRvciA9PT0gXCI9XCIgPyByZXN1bHQgPT09IGNoZWNrIDpcblx0XHRcdFx0XHRvcGVyYXRvciA9PT0gXCIhPVwiID8gcmVzdWx0ICE9PSBjaGVjayA6XG5cdFx0XHRcdFx0b3BlcmF0b3IgPT09IFwiXj1cIiA/IGNoZWNrICYmIHJlc3VsdC5pbmRleE9mKCBjaGVjayApID09PSAwIDpcblx0XHRcdFx0XHRvcGVyYXRvciA9PT0gXCIqPVwiID8gY2hlY2sgJiYgcmVzdWx0LmluZGV4T2YoIGNoZWNrICkgPiAtMSA6XG5cdFx0XHRcdFx0b3BlcmF0b3IgPT09IFwiJD1cIiA/IGNoZWNrICYmIHJlc3VsdC5zbGljZSggLWNoZWNrLmxlbmd0aCApID09PSBjaGVjayA6XG5cdFx0XHRcdFx0b3BlcmF0b3IgPT09IFwifj1cIiA/ICggXCIgXCIgKyByZXN1bHQucmVwbGFjZSggcndoaXRlc3BhY2UsIFwiIFwiICkgKyBcIiBcIiApLmluZGV4T2YoIGNoZWNrICkgPiAtMSA6XG5cdFx0XHRcdFx0b3BlcmF0b3IgPT09IFwifD1cIiA/IHJlc3VsdCA9PT0gY2hlY2sgfHwgcmVzdWx0LnNsaWNlKCAwLCBjaGVjay5sZW5ndGggKyAxICkgPT09IGNoZWNrICsgXCItXCIgOlxuXHRcdFx0XHRcdGZhbHNlO1xuXHRcdFx0fTtcblx0XHR9LFxuXG5cdFx0XCJDSElMRFwiOiBmdW5jdGlvbiggdHlwZSwgd2hhdCwgYXJndW1lbnQsIGZpcnN0LCBsYXN0ICkge1xuXHRcdFx0dmFyIHNpbXBsZSA9IHR5cGUuc2xpY2UoIDAsIDMgKSAhPT0gXCJudGhcIixcblx0XHRcdFx0Zm9yd2FyZCA9IHR5cGUuc2xpY2UoIC00ICkgIT09IFwibGFzdFwiLFxuXHRcdFx0XHRvZlR5cGUgPSB3aGF0ID09PSBcIm9mLXR5cGVcIjtcblxuXHRcdFx0cmV0dXJuIGZpcnN0ID09PSAxICYmIGxhc3QgPT09IDAgP1xuXG5cdFx0XHRcdC8vIFNob3J0Y3V0IGZvciA6bnRoLSoobilcblx0XHRcdFx0ZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRcdFx0cmV0dXJuICEhZWxlbS5wYXJlbnROb2RlO1xuXHRcdFx0XHR9IDpcblxuXHRcdFx0XHRmdW5jdGlvbiggZWxlbSwgY29udGV4dCwgeG1sICkge1xuXHRcdFx0XHRcdHZhciBjYWNoZSwgdW5pcXVlQ2FjaGUsIG91dGVyQ2FjaGUsIG5vZGUsIG5vZGVJbmRleCwgc3RhcnQsXG5cdFx0XHRcdFx0XHRkaXIgPSBzaW1wbGUgIT09IGZvcndhcmQgPyBcIm5leHRTaWJsaW5nXCIgOiBcInByZXZpb3VzU2libGluZ1wiLFxuXHRcdFx0XHRcdFx0cGFyZW50ID0gZWxlbS5wYXJlbnROb2RlLFxuXHRcdFx0XHRcdFx0bmFtZSA9IG9mVHlwZSAmJiBlbGVtLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCksXG5cdFx0XHRcdFx0XHR1c2VDYWNoZSA9ICF4bWwgJiYgIW9mVHlwZSxcblx0XHRcdFx0XHRcdGRpZmYgPSBmYWxzZTtcblxuXHRcdFx0XHRcdGlmICggcGFyZW50ICkge1xuXG5cdFx0XHRcdFx0XHQvLyA6KGZpcnN0fGxhc3R8b25seSktKGNoaWxkfG9mLXR5cGUpXG5cdFx0XHRcdFx0XHRpZiAoIHNpbXBsZSApIHtcblx0XHRcdFx0XHRcdFx0d2hpbGUgKCBkaXIgKSB7XG5cdFx0XHRcdFx0XHRcdFx0bm9kZSA9IGVsZW07XG5cdFx0XHRcdFx0XHRcdFx0d2hpbGUgKCAobm9kZSA9IG5vZGVbIGRpciBdKSApIHtcblx0XHRcdFx0XHRcdFx0XHRcdGlmICggb2ZUeXBlID9cblx0XHRcdFx0XHRcdFx0XHRcdFx0bm9kZS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpID09PSBuYW1lIDpcblx0XHRcdFx0XHRcdFx0XHRcdFx0bm9kZS5ub2RlVHlwZSA9PT0gMSApIHtcblxuXHRcdFx0XHRcdFx0XHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdC8vIFJldmVyc2UgZGlyZWN0aW9uIGZvciA6b25seS0qIChpZiB3ZSBoYXZlbid0IHlldCBkb25lIHNvKVxuXHRcdFx0XHRcdFx0XHRcdHN0YXJ0ID0gZGlyID0gdHlwZSA9PT0gXCJvbmx5XCIgJiYgIXN0YXJ0ICYmIFwibmV4dFNpYmxpbmdcIjtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0c3RhcnQgPSBbIGZvcndhcmQgPyBwYXJlbnQuZmlyc3RDaGlsZCA6IHBhcmVudC5sYXN0Q2hpbGQgXTtcblxuXHRcdFx0XHRcdFx0Ly8gbm9uLXhtbCA6bnRoLWNoaWxkKC4uLikgc3RvcmVzIGNhY2hlIGRhdGEgb24gYHBhcmVudGBcblx0XHRcdFx0XHRcdGlmICggZm9yd2FyZCAmJiB1c2VDYWNoZSApIHtcblxuXHRcdFx0XHRcdFx0XHQvLyBTZWVrIGBlbGVtYCBmcm9tIGEgcHJldmlvdXNseS1jYWNoZWQgaW5kZXhcblxuXHRcdFx0XHRcdFx0XHQvLyAuLi5pbiBhIGd6aXAtZnJpZW5kbHkgd2F5XG5cdFx0XHRcdFx0XHRcdG5vZGUgPSBwYXJlbnQ7XG5cdFx0XHRcdFx0XHRcdG91dGVyQ2FjaGUgPSBub2RlWyBleHBhbmRvIF0gfHwgKG5vZGVbIGV4cGFuZG8gXSA9IHt9KTtcblxuXHRcdFx0XHRcdFx0XHQvLyBTdXBwb3J0OiBJRSA8OSBvbmx5XG5cdFx0XHRcdFx0XHRcdC8vIERlZmVuZCBhZ2FpbnN0IGNsb25lZCBhdHRyb3BlcnRpZXMgKGpRdWVyeSBnaC0xNzA5KVxuXHRcdFx0XHRcdFx0XHR1bmlxdWVDYWNoZSA9IG91dGVyQ2FjaGVbIG5vZGUudW5pcXVlSUQgXSB8fFxuXHRcdFx0XHRcdFx0XHRcdChvdXRlckNhY2hlWyBub2RlLnVuaXF1ZUlEIF0gPSB7fSk7XG5cblx0XHRcdFx0XHRcdFx0Y2FjaGUgPSB1bmlxdWVDYWNoZVsgdHlwZSBdIHx8IFtdO1xuXHRcdFx0XHRcdFx0XHRub2RlSW5kZXggPSBjYWNoZVsgMCBdID09PSBkaXJydW5zICYmIGNhY2hlWyAxIF07XG5cdFx0XHRcdFx0XHRcdGRpZmYgPSBub2RlSW5kZXggJiYgY2FjaGVbIDIgXTtcblx0XHRcdFx0XHRcdFx0bm9kZSA9IG5vZGVJbmRleCAmJiBwYXJlbnQuY2hpbGROb2Rlc1sgbm9kZUluZGV4IF07XG5cblx0XHRcdFx0XHRcdFx0d2hpbGUgKCAobm9kZSA9ICsrbm9kZUluZGV4ICYmIG5vZGUgJiYgbm9kZVsgZGlyIF0gfHxcblxuXHRcdFx0XHRcdFx0XHRcdC8vIEZhbGxiYWNrIHRvIHNlZWtpbmcgYGVsZW1gIGZyb20gdGhlIHN0YXJ0XG5cdFx0XHRcdFx0XHRcdFx0KGRpZmYgPSBub2RlSW5kZXggPSAwKSB8fCBzdGFydC5wb3AoKSkgKSB7XG5cblx0XHRcdFx0XHRcdFx0XHQvLyBXaGVuIGZvdW5kLCBjYWNoZSBpbmRleGVzIG9uIGBwYXJlbnRgIGFuZCBicmVha1xuXHRcdFx0XHRcdFx0XHRcdGlmICggbm9kZS5ub2RlVHlwZSA9PT0gMSAmJiArK2RpZmYgJiYgbm9kZSA9PT0gZWxlbSApIHtcblx0XHRcdFx0XHRcdFx0XHRcdHVuaXF1ZUNhY2hlWyB0eXBlIF0gPSBbIGRpcnJ1bnMsIG5vZGVJbmRleCwgZGlmZiBdO1xuXHRcdFx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRcdC8vIFVzZSBwcmV2aW91c2x5LWNhY2hlZCBlbGVtZW50IGluZGV4IGlmIGF2YWlsYWJsZVxuXHRcdFx0XHRcdFx0XHRpZiAoIHVzZUNhY2hlICkge1xuXHRcdFx0XHRcdFx0XHRcdC8vIC4uLmluIGEgZ3ppcC1mcmllbmRseSB3YXlcblx0XHRcdFx0XHRcdFx0XHRub2RlID0gZWxlbTtcblx0XHRcdFx0XHRcdFx0XHRvdXRlckNhY2hlID0gbm9kZVsgZXhwYW5kbyBdIHx8IChub2RlWyBleHBhbmRvIF0gPSB7fSk7XG5cblx0XHRcdFx0XHRcdFx0XHQvLyBTdXBwb3J0OiBJRSA8OSBvbmx5XG5cdFx0XHRcdFx0XHRcdFx0Ly8gRGVmZW5kIGFnYWluc3QgY2xvbmVkIGF0dHJvcGVydGllcyAoalF1ZXJ5IGdoLTE3MDkpXG5cdFx0XHRcdFx0XHRcdFx0dW5pcXVlQ2FjaGUgPSBvdXRlckNhY2hlWyBub2RlLnVuaXF1ZUlEIF0gfHxcblx0XHRcdFx0XHRcdFx0XHRcdChvdXRlckNhY2hlWyBub2RlLnVuaXF1ZUlEIF0gPSB7fSk7XG5cblx0XHRcdFx0XHRcdFx0XHRjYWNoZSA9IHVuaXF1ZUNhY2hlWyB0eXBlIF0gfHwgW107XG5cdFx0XHRcdFx0XHRcdFx0bm9kZUluZGV4ID0gY2FjaGVbIDAgXSA9PT0gZGlycnVucyAmJiBjYWNoZVsgMSBdO1xuXHRcdFx0XHRcdFx0XHRcdGRpZmYgPSBub2RlSW5kZXg7XG5cdFx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0XHQvLyB4bWwgOm50aC1jaGlsZCguLi4pXG5cdFx0XHRcdFx0XHRcdC8vIG9yIDpudGgtbGFzdC1jaGlsZCguLi4pIG9yIDpudGgoLWxhc3QpPy1vZi10eXBlKC4uLilcblx0XHRcdFx0XHRcdFx0aWYgKCBkaWZmID09PSBmYWxzZSApIHtcblx0XHRcdFx0XHRcdFx0XHQvLyBVc2UgdGhlIHNhbWUgbG9vcCBhcyBhYm92ZSB0byBzZWVrIGBlbGVtYCBmcm9tIHRoZSBzdGFydFxuXHRcdFx0XHRcdFx0XHRcdHdoaWxlICggKG5vZGUgPSArK25vZGVJbmRleCAmJiBub2RlICYmIG5vZGVbIGRpciBdIHx8XG5cdFx0XHRcdFx0XHRcdFx0XHQoZGlmZiA9IG5vZGVJbmRleCA9IDApIHx8IHN0YXJ0LnBvcCgpKSApIHtcblxuXHRcdFx0XHRcdFx0XHRcdFx0aWYgKCAoIG9mVHlwZSA/XG5cdFx0XHRcdFx0XHRcdFx0XHRcdG5vZGUubm9kZU5hbWUudG9Mb3dlckNhc2UoKSA9PT0gbmFtZSA6XG5cdFx0XHRcdFx0XHRcdFx0XHRcdG5vZGUubm9kZVR5cGUgPT09IDEgKSAmJlxuXHRcdFx0XHRcdFx0XHRcdFx0XHQrK2RpZmYgKSB7XG5cblx0XHRcdFx0XHRcdFx0XHRcdFx0Ly8gQ2FjaGUgdGhlIGluZGV4IG9mIGVhY2ggZW5jb3VudGVyZWQgZWxlbWVudFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRpZiAoIHVzZUNhY2hlICkge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdG91dGVyQ2FjaGUgPSBub2RlWyBleHBhbmRvIF0gfHwgKG5vZGVbIGV4cGFuZG8gXSA9IHt9KTtcblxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdC8vIFN1cHBvcnQ6IElFIDw5IG9ubHlcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHQvLyBEZWZlbmQgYWdhaW5zdCBjbG9uZWQgYXR0cm9wZXJ0aWVzIChqUXVlcnkgZ2gtMTcwOSlcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHR1bmlxdWVDYWNoZSA9IG91dGVyQ2FjaGVbIG5vZGUudW5pcXVlSUQgXSB8fFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0KG91dGVyQ2FjaGVbIG5vZGUudW5pcXVlSUQgXSA9IHt9KTtcblxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdHVuaXF1ZUNhY2hlWyB0eXBlIF0gPSBbIGRpcnJ1bnMsIGRpZmYgXTtcblx0XHRcdFx0XHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRcdFx0XHRcdGlmICggbm9kZSA9PT0gZWxlbSApIHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHQvLyBJbmNvcnBvcmF0ZSB0aGUgb2Zmc2V0LCB0aGVuIGNoZWNrIGFnYWluc3QgY3ljbGUgc2l6ZVxuXHRcdFx0XHRcdFx0ZGlmZiAtPSBsYXN0O1xuXHRcdFx0XHRcdFx0cmV0dXJuIGRpZmYgPT09IGZpcnN0IHx8ICggZGlmZiAlIGZpcnN0ID09PSAwICYmIGRpZmYgLyBmaXJzdCA+PSAwICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9O1xuXHRcdH0sXG5cblx0XHRcIlBTRVVET1wiOiBmdW5jdGlvbiggcHNldWRvLCBhcmd1bWVudCApIHtcblx0XHRcdC8vIHBzZXVkby1jbGFzcyBuYW1lcyBhcmUgY2FzZS1pbnNlbnNpdGl2ZVxuXHRcdFx0Ly8gaHR0cDovL3d3dy53My5vcmcvVFIvc2VsZWN0b3JzLyNwc2V1ZG8tY2xhc3Nlc1xuXHRcdFx0Ly8gUHJpb3JpdGl6ZSBieSBjYXNlIHNlbnNpdGl2aXR5IGluIGNhc2UgY3VzdG9tIHBzZXVkb3MgYXJlIGFkZGVkIHdpdGggdXBwZXJjYXNlIGxldHRlcnNcblx0XHRcdC8vIFJlbWVtYmVyIHRoYXQgc2V0RmlsdGVycyBpbmhlcml0cyBmcm9tIHBzZXVkb3Ncblx0XHRcdHZhciBhcmdzLFxuXHRcdFx0XHRmbiA9IEV4cHIucHNldWRvc1sgcHNldWRvIF0gfHwgRXhwci5zZXRGaWx0ZXJzWyBwc2V1ZG8udG9Mb3dlckNhc2UoKSBdIHx8XG5cdFx0XHRcdFx0U2l6emxlLmVycm9yKCBcInVuc3VwcG9ydGVkIHBzZXVkbzogXCIgKyBwc2V1ZG8gKTtcblxuXHRcdFx0Ly8gVGhlIHVzZXIgbWF5IHVzZSBjcmVhdGVQc2V1ZG8gdG8gaW5kaWNhdGUgdGhhdFxuXHRcdFx0Ly8gYXJndW1lbnRzIGFyZSBuZWVkZWQgdG8gY3JlYXRlIHRoZSBmaWx0ZXIgZnVuY3Rpb25cblx0XHRcdC8vIGp1c3QgYXMgU2l6emxlIGRvZXNcblx0XHRcdGlmICggZm5bIGV4cGFuZG8gXSApIHtcblx0XHRcdFx0cmV0dXJuIGZuKCBhcmd1bWVudCApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBCdXQgbWFpbnRhaW4gc3VwcG9ydCBmb3Igb2xkIHNpZ25hdHVyZXNcblx0XHRcdGlmICggZm4ubGVuZ3RoID4gMSApIHtcblx0XHRcdFx0YXJncyA9IFsgcHNldWRvLCBwc2V1ZG8sIFwiXCIsIGFyZ3VtZW50IF07XG5cdFx0XHRcdHJldHVybiBFeHByLnNldEZpbHRlcnMuaGFzT3duUHJvcGVydHkoIHBzZXVkby50b0xvd2VyQ2FzZSgpICkgP1xuXHRcdFx0XHRcdG1hcmtGdW5jdGlvbihmdW5jdGlvbiggc2VlZCwgbWF0Y2hlcyApIHtcblx0XHRcdFx0XHRcdHZhciBpZHgsXG5cdFx0XHRcdFx0XHRcdG1hdGNoZWQgPSBmbiggc2VlZCwgYXJndW1lbnQgKSxcblx0XHRcdFx0XHRcdFx0aSA9IG1hdGNoZWQubGVuZ3RoO1xuXHRcdFx0XHRcdFx0d2hpbGUgKCBpLS0gKSB7XG5cdFx0XHRcdFx0XHRcdGlkeCA9IGluZGV4T2YoIHNlZWQsIG1hdGNoZWRbaV0gKTtcblx0XHRcdFx0XHRcdFx0c2VlZFsgaWR4IF0gPSAhKCBtYXRjaGVzWyBpZHggXSA9IG1hdGNoZWRbaV0gKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9KSA6XG5cdFx0XHRcdFx0ZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRcdFx0XHRyZXR1cm4gZm4oIGVsZW0sIDAsIGFyZ3MgKTtcblx0XHRcdFx0XHR9O1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gZm47XG5cdFx0fVxuXHR9LFxuXG5cdHBzZXVkb3M6IHtcblx0XHQvLyBQb3RlbnRpYWxseSBjb21wbGV4IHBzZXVkb3Ncblx0XHRcIm5vdFwiOiBtYXJrRnVuY3Rpb24oZnVuY3Rpb24oIHNlbGVjdG9yICkge1xuXHRcdFx0Ly8gVHJpbSB0aGUgc2VsZWN0b3IgcGFzc2VkIHRvIGNvbXBpbGVcblx0XHRcdC8vIHRvIGF2b2lkIHRyZWF0aW5nIGxlYWRpbmcgYW5kIHRyYWlsaW5nXG5cdFx0XHQvLyBzcGFjZXMgYXMgY29tYmluYXRvcnNcblx0XHRcdHZhciBpbnB1dCA9IFtdLFxuXHRcdFx0XHRyZXN1bHRzID0gW10sXG5cdFx0XHRcdG1hdGNoZXIgPSBjb21waWxlKCBzZWxlY3Rvci5yZXBsYWNlKCBydHJpbSwgXCIkMVwiICkgKTtcblxuXHRcdFx0cmV0dXJuIG1hdGNoZXJbIGV4cGFuZG8gXSA/XG5cdFx0XHRcdG1hcmtGdW5jdGlvbihmdW5jdGlvbiggc2VlZCwgbWF0Y2hlcywgY29udGV4dCwgeG1sICkge1xuXHRcdFx0XHRcdHZhciBlbGVtLFxuXHRcdFx0XHRcdFx0dW5tYXRjaGVkID0gbWF0Y2hlciggc2VlZCwgbnVsbCwgeG1sLCBbXSApLFxuXHRcdFx0XHRcdFx0aSA9IHNlZWQubGVuZ3RoO1xuXG5cdFx0XHRcdFx0Ly8gTWF0Y2ggZWxlbWVudHMgdW5tYXRjaGVkIGJ5IGBtYXRjaGVyYFxuXHRcdFx0XHRcdHdoaWxlICggaS0tICkge1xuXHRcdFx0XHRcdFx0aWYgKCAoZWxlbSA9IHVubWF0Y2hlZFtpXSkgKSB7XG5cdFx0XHRcdFx0XHRcdHNlZWRbaV0gPSAhKG1hdGNoZXNbaV0gPSBlbGVtKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0pIDpcblx0XHRcdFx0ZnVuY3Rpb24oIGVsZW0sIGNvbnRleHQsIHhtbCApIHtcblx0XHRcdFx0XHRpbnB1dFswXSA9IGVsZW07XG5cdFx0XHRcdFx0bWF0Y2hlciggaW5wdXQsIG51bGwsIHhtbCwgcmVzdWx0cyApO1xuXHRcdFx0XHRcdC8vIERvbid0IGtlZXAgdGhlIGVsZW1lbnQgKGlzc3VlICMyOTkpXG5cdFx0XHRcdFx0aW5wdXRbMF0gPSBudWxsO1xuXHRcdFx0XHRcdHJldHVybiAhcmVzdWx0cy5wb3AoKTtcblx0XHRcdFx0fTtcblx0XHR9KSxcblxuXHRcdFwiaGFzXCI6IG1hcmtGdW5jdGlvbihmdW5jdGlvbiggc2VsZWN0b3IgKSB7XG5cdFx0XHRyZXR1cm4gZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRcdHJldHVybiBTaXp6bGUoIHNlbGVjdG9yLCBlbGVtICkubGVuZ3RoID4gMDtcblx0XHRcdH07XG5cdFx0fSksXG5cblx0XHRcImNvbnRhaW5zXCI6IG1hcmtGdW5jdGlvbihmdW5jdGlvbiggdGV4dCApIHtcblx0XHRcdHRleHQgPSB0ZXh0LnJlcGxhY2UoIHJ1bmVzY2FwZSwgZnVuZXNjYXBlICk7XG5cdFx0XHRyZXR1cm4gZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRcdHJldHVybiAoIGVsZW0udGV4dENvbnRlbnQgfHwgZ2V0VGV4dCggZWxlbSApICkuaW5kZXhPZiggdGV4dCApID4gLTE7XG5cdFx0XHR9O1xuXHRcdH0pLFxuXG5cdFx0Ly8gXCJXaGV0aGVyIGFuIGVsZW1lbnQgaXMgcmVwcmVzZW50ZWQgYnkgYSA6bGFuZygpIHNlbGVjdG9yXG5cdFx0Ly8gaXMgYmFzZWQgc29sZWx5IG9uIHRoZSBlbGVtZW50J3MgbGFuZ3VhZ2UgdmFsdWVcblx0XHQvLyBiZWluZyBlcXVhbCB0byB0aGUgaWRlbnRpZmllciBDLFxuXHRcdC8vIG9yIGJlZ2lubmluZyB3aXRoIHRoZSBpZGVudGlmaWVyIEMgaW1tZWRpYXRlbHkgZm9sbG93ZWQgYnkgXCItXCIuXG5cdFx0Ly8gVGhlIG1hdGNoaW5nIG9mIEMgYWdhaW5zdCB0aGUgZWxlbWVudCdzIGxhbmd1YWdlIHZhbHVlIGlzIHBlcmZvcm1lZCBjYXNlLWluc2Vuc2l0aXZlbHkuXG5cdFx0Ly8gVGhlIGlkZW50aWZpZXIgQyBkb2VzIG5vdCBoYXZlIHRvIGJlIGEgdmFsaWQgbGFuZ3VhZ2UgbmFtZS5cIlxuXHRcdC8vIGh0dHA6Ly93d3cudzMub3JnL1RSL3NlbGVjdG9ycy8jbGFuZy1wc2V1ZG9cblx0XHRcImxhbmdcIjogbWFya0Z1bmN0aW9uKCBmdW5jdGlvbiggbGFuZyApIHtcblx0XHRcdC8vIGxhbmcgdmFsdWUgbXVzdCBiZSBhIHZhbGlkIGlkZW50aWZpZXJcblx0XHRcdGlmICggIXJpZGVudGlmaWVyLnRlc3QobGFuZyB8fCBcIlwiKSApIHtcblx0XHRcdFx0U2l6emxlLmVycm9yKCBcInVuc3VwcG9ydGVkIGxhbmc6IFwiICsgbGFuZyApO1xuXHRcdFx0fVxuXHRcdFx0bGFuZyA9IGxhbmcucmVwbGFjZSggcnVuZXNjYXBlLCBmdW5lc2NhcGUgKS50b0xvd2VyQ2FzZSgpO1xuXHRcdFx0cmV0dXJuIGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0XHR2YXIgZWxlbUxhbmc7XG5cdFx0XHRcdGRvIHtcblx0XHRcdFx0XHRpZiAoIChlbGVtTGFuZyA9IGRvY3VtZW50SXNIVE1MID9cblx0XHRcdFx0XHRcdGVsZW0ubGFuZyA6XG5cdFx0XHRcdFx0XHRlbGVtLmdldEF0dHJpYnV0ZShcInhtbDpsYW5nXCIpIHx8IGVsZW0uZ2V0QXR0cmlidXRlKFwibGFuZ1wiKSkgKSB7XG5cblx0XHRcdFx0XHRcdGVsZW1MYW5nID0gZWxlbUxhbmcudG9Mb3dlckNhc2UoKTtcblx0XHRcdFx0XHRcdHJldHVybiBlbGVtTGFuZyA9PT0gbGFuZyB8fCBlbGVtTGFuZy5pbmRleE9mKCBsYW5nICsgXCItXCIgKSA9PT0gMDtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0gd2hpbGUgKCAoZWxlbSA9IGVsZW0ucGFyZW50Tm9kZSkgJiYgZWxlbS5ub2RlVHlwZSA9PT0gMSApO1xuXHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHR9O1xuXHRcdH0pLFxuXG5cdFx0Ly8gTWlzY2VsbGFuZW91c1xuXHRcdFwidGFyZ2V0XCI6IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0dmFyIGhhc2ggPSB3aW5kb3cubG9jYXRpb24gJiYgd2luZG93LmxvY2F0aW9uLmhhc2g7XG5cdFx0XHRyZXR1cm4gaGFzaCAmJiBoYXNoLnNsaWNlKCAxICkgPT09IGVsZW0uaWQ7XG5cdFx0fSxcblxuXHRcdFwicm9vdFwiOiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdHJldHVybiBlbGVtID09PSBkb2NFbGVtO1xuXHRcdH0sXG5cblx0XHRcImZvY3VzXCI6IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0cmV0dXJuIGVsZW0gPT09IGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQgJiYgKCFkb2N1bWVudC5oYXNGb2N1cyB8fCBkb2N1bWVudC5oYXNGb2N1cygpKSAmJiAhIShlbGVtLnR5cGUgfHwgZWxlbS5ocmVmIHx8IH5lbGVtLnRhYkluZGV4KTtcblx0XHR9LFxuXG5cdFx0Ly8gQm9vbGVhbiBwcm9wZXJ0aWVzXG5cdFx0XCJlbmFibGVkXCI6IGNyZWF0ZURpc2FibGVkUHNldWRvKCBmYWxzZSApLFxuXHRcdFwiZGlzYWJsZWRcIjogY3JlYXRlRGlzYWJsZWRQc2V1ZG8oIHRydWUgKSxcblxuXHRcdFwiY2hlY2tlZFwiOiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdC8vIEluIENTUzMsIDpjaGVja2VkIHNob3VsZCByZXR1cm4gYm90aCBjaGVja2VkIGFuZCBzZWxlY3RlZCBlbGVtZW50c1xuXHRcdFx0Ly8gaHR0cDovL3d3dy53My5vcmcvVFIvMjAxMS9SRUMtY3NzMy1zZWxlY3RvcnMtMjAxMTA5MjkvI2NoZWNrZWRcblx0XHRcdHZhciBub2RlTmFtZSA9IGVsZW0ubm9kZU5hbWUudG9Mb3dlckNhc2UoKTtcblx0XHRcdHJldHVybiAobm9kZU5hbWUgPT09IFwiaW5wdXRcIiAmJiAhIWVsZW0uY2hlY2tlZCkgfHwgKG5vZGVOYW1lID09PSBcIm9wdGlvblwiICYmICEhZWxlbS5zZWxlY3RlZCk7XG5cdFx0fSxcblxuXHRcdFwic2VsZWN0ZWRcIjogZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHQvLyBBY2Nlc3NpbmcgdGhpcyBwcm9wZXJ0eSBtYWtlcyBzZWxlY3RlZC1ieS1kZWZhdWx0XG5cdFx0XHQvLyBvcHRpb25zIGluIFNhZmFyaSB3b3JrIHByb3Blcmx5XG5cdFx0XHRpZiAoIGVsZW0ucGFyZW50Tm9kZSApIHtcblx0XHRcdFx0ZWxlbS5wYXJlbnROb2RlLnNlbGVjdGVkSW5kZXg7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBlbGVtLnNlbGVjdGVkID09PSB0cnVlO1xuXHRcdH0sXG5cblx0XHQvLyBDb250ZW50c1xuXHRcdFwiZW1wdHlcIjogZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHQvLyBodHRwOi8vd3d3LnczLm9yZy9UUi9zZWxlY3RvcnMvI2VtcHR5LXBzZXVkb1xuXHRcdFx0Ly8gOmVtcHR5IGlzIG5lZ2F0ZWQgYnkgZWxlbWVudCAoMSkgb3IgY29udGVudCBub2RlcyAodGV4dDogMzsgY2RhdGE6IDQ7IGVudGl0eSByZWY6IDUpLFxuXHRcdFx0Ly8gICBidXQgbm90IGJ5IG90aGVycyAoY29tbWVudDogODsgcHJvY2Vzc2luZyBpbnN0cnVjdGlvbjogNzsgZXRjLilcblx0XHRcdC8vIG5vZGVUeXBlIDwgNiB3b3JrcyBiZWNhdXNlIGF0dHJpYnV0ZXMgKDIpIGRvIG5vdCBhcHBlYXIgYXMgY2hpbGRyZW5cblx0XHRcdGZvciAoIGVsZW0gPSBlbGVtLmZpcnN0Q2hpbGQ7IGVsZW07IGVsZW0gPSBlbGVtLm5leHRTaWJsaW5nICkge1xuXHRcdFx0XHRpZiAoIGVsZW0ubm9kZVR5cGUgPCA2ICkge1xuXHRcdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0fSxcblxuXHRcdFwicGFyZW50XCI6IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0cmV0dXJuICFFeHByLnBzZXVkb3NbXCJlbXB0eVwiXSggZWxlbSApO1xuXHRcdH0sXG5cblx0XHQvLyBFbGVtZW50L2lucHV0IHR5cGVzXG5cdFx0XCJoZWFkZXJcIjogZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRyZXR1cm4gcmhlYWRlci50ZXN0KCBlbGVtLm5vZGVOYW1lICk7XG5cdFx0fSxcblxuXHRcdFwiaW5wdXRcIjogZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRyZXR1cm4gcmlucHV0cy50ZXN0KCBlbGVtLm5vZGVOYW1lICk7XG5cdFx0fSxcblxuXHRcdFwiYnV0dG9uXCI6IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0dmFyIG5hbWUgPSBlbGVtLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCk7XG5cdFx0XHRyZXR1cm4gbmFtZSA9PT0gXCJpbnB1dFwiICYmIGVsZW0udHlwZSA9PT0gXCJidXR0b25cIiB8fCBuYW1lID09PSBcImJ1dHRvblwiO1xuXHRcdH0sXG5cblx0XHRcInRleHRcIjogZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHR2YXIgYXR0cjtcblx0XHRcdHJldHVybiBlbGVtLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkgPT09IFwiaW5wdXRcIiAmJlxuXHRcdFx0XHRlbGVtLnR5cGUgPT09IFwidGV4dFwiICYmXG5cblx0XHRcdFx0Ly8gU3VwcG9ydDogSUU8OFxuXHRcdFx0XHQvLyBOZXcgSFRNTDUgYXR0cmlidXRlIHZhbHVlcyAoZS5nLiwgXCJzZWFyY2hcIikgYXBwZWFyIHdpdGggZWxlbS50eXBlID09PSBcInRleHRcIlxuXHRcdFx0XHQoIChhdHRyID0gZWxlbS5nZXRBdHRyaWJ1dGUoXCJ0eXBlXCIpKSA9PSBudWxsIHx8IGF0dHIudG9Mb3dlckNhc2UoKSA9PT0gXCJ0ZXh0XCIgKTtcblx0XHR9LFxuXG5cdFx0Ly8gUG9zaXRpb24taW4tY29sbGVjdGlvblxuXHRcdFwiZmlyc3RcIjogY3JlYXRlUG9zaXRpb25hbFBzZXVkbyhmdW5jdGlvbigpIHtcblx0XHRcdHJldHVybiBbIDAgXTtcblx0XHR9KSxcblxuXHRcdFwibGFzdFwiOiBjcmVhdGVQb3NpdGlvbmFsUHNldWRvKGZ1bmN0aW9uKCBtYXRjaEluZGV4ZXMsIGxlbmd0aCApIHtcblx0XHRcdHJldHVybiBbIGxlbmd0aCAtIDEgXTtcblx0XHR9KSxcblxuXHRcdFwiZXFcIjogY3JlYXRlUG9zaXRpb25hbFBzZXVkbyhmdW5jdGlvbiggbWF0Y2hJbmRleGVzLCBsZW5ndGgsIGFyZ3VtZW50ICkge1xuXHRcdFx0cmV0dXJuIFsgYXJndW1lbnQgPCAwID8gYXJndW1lbnQgKyBsZW5ndGggOiBhcmd1bWVudCBdO1xuXHRcdH0pLFxuXG5cdFx0XCJldmVuXCI6IGNyZWF0ZVBvc2l0aW9uYWxQc2V1ZG8oZnVuY3Rpb24oIG1hdGNoSW5kZXhlcywgbGVuZ3RoICkge1xuXHRcdFx0dmFyIGkgPSAwO1xuXHRcdFx0Zm9yICggOyBpIDwgbGVuZ3RoOyBpICs9IDIgKSB7XG5cdFx0XHRcdG1hdGNoSW5kZXhlcy5wdXNoKCBpICk7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gbWF0Y2hJbmRleGVzO1xuXHRcdH0pLFxuXG5cdFx0XCJvZGRcIjogY3JlYXRlUG9zaXRpb25hbFBzZXVkbyhmdW5jdGlvbiggbWF0Y2hJbmRleGVzLCBsZW5ndGggKSB7XG5cdFx0XHR2YXIgaSA9IDE7XG5cdFx0XHRmb3IgKCA7IGkgPCBsZW5ndGg7IGkgKz0gMiApIHtcblx0XHRcdFx0bWF0Y2hJbmRleGVzLnB1c2goIGkgKTtcblx0XHRcdH1cblx0XHRcdHJldHVybiBtYXRjaEluZGV4ZXM7XG5cdFx0fSksXG5cblx0XHRcImx0XCI6IGNyZWF0ZVBvc2l0aW9uYWxQc2V1ZG8oZnVuY3Rpb24oIG1hdGNoSW5kZXhlcywgbGVuZ3RoLCBhcmd1bWVudCApIHtcblx0XHRcdHZhciBpID0gYXJndW1lbnQgPCAwID9cblx0XHRcdFx0YXJndW1lbnQgKyBsZW5ndGggOlxuXHRcdFx0XHRhcmd1bWVudCA+IGxlbmd0aCA/XG5cdFx0XHRcdFx0bGVuZ3RoIDpcblx0XHRcdFx0XHRhcmd1bWVudDtcblx0XHRcdGZvciAoIDsgLS1pID49IDA7ICkge1xuXHRcdFx0XHRtYXRjaEluZGV4ZXMucHVzaCggaSApO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIG1hdGNoSW5kZXhlcztcblx0XHR9KSxcblxuXHRcdFwiZ3RcIjogY3JlYXRlUG9zaXRpb25hbFBzZXVkbyhmdW5jdGlvbiggbWF0Y2hJbmRleGVzLCBsZW5ndGgsIGFyZ3VtZW50ICkge1xuXHRcdFx0dmFyIGkgPSBhcmd1bWVudCA8IDAgPyBhcmd1bWVudCArIGxlbmd0aCA6IGFyZ3VtZW50O1xuXHRcdFx0Zm9yICggOyArK2kgPCBsZW5ndGg7ICkge1xuXHRcdFx0XHRtYXRjaEluZGV4ZXMucHVzaCggaSApO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIG1hdGNoSW5kZXhlcztcblx0XHR9KVxuXHR9XG59O1xuXG5FeHByLnBzZXVkb3NbXCJudGhcIl0gPSBFeHByLnBzZXVkb3NbXCJlcVwiXTtcblxuLy8gQWRkIGJ1dHRvbi9pbnB1dCB0eXBlIHBzZXVkb3NcbmZvciAoIGkgaW4geyByYWRpbzogdHJ1ZSwgY2hlY2tib3g6IHRydWUsIGZpbGU6IHRydWUsIHBhc3N3b3JkOiB0cnVlLCBpbWFnZTogdHJ1ZSB9ICkge1xuXHRFeHByLnBzZXVkb3NbIGkgXSA9IGNyZWF0ZUlucHV0UHNldWRvKCBpICk7XG59XG5mb3IgKCBpIGluIHsgc3VibWl0OiB0cnVlLCByZXNldDogdHJ1ZSB9ICkge1xuXHRFeHByLnBzZXVkb3NbIGkgXSA9IGNyZWF0ZUJ1dHRvblBzZXVkbyggaSApO1xufVxuXG4vLyBFYXN5IEFQSSBmb3IgY3JlYXRpbmcgbmV3IHNldEZpbHRlcnNcbmZ1bmN0aW9uIHNldEZpbHRlcnMoKSB7fVxuc2V0RmlsdGVycy5wcm90b3R5cGUgPSBFeHByLmZpbHRlcnMgPSBFeHByLnBzZXVkb3M7XG5FeHByLnNldEZpbHRlcnMgPSBuZXcgc2V0RmlsdGVycygpO1xuXG50b2tlbml6ZSA9IFNpenpsZS50b2tlbml6ZSA9IGZ1bmN0aW9uKCBzZWxlY3RvciwgcGFyc2VPbmx5ICkge1xuXHR2YXIgbWF0Y2hlZCwgbWF0Y2gsIHRva2VucywgdHlwZSxcblx0XHRzb0ZhciwgZ3JvdXBzLCBwcmVGaWx0ZXJzLFxuXHRcdGNhY2hlZCA9IHRva2VuQ2FjaGVbIHNlbGVjdG9yICsgXCIgXCIgXTtcblxuXHRpZiAoIGNhY2hlZCApIHtcblx0XHRyZXR1cm4gcGFyc2VPbmx5ID8gMCA6IGNhY2hlZC5zbGljZSggMCApO1xuXHR9XG5cblx0c29GYXIgPSBzZWxlY3Rvcjtcblx0Z3JvdXBzID0gW107XG5cdHByZUZpbHRlcnMgPSBFeHByLnByZUZpbHRlcjtcblxuXHR3aGlsZSAoIHNvRmFyICkge1xuXG5cdFx0Ly8gQ29tbWEgYW5kIGZpcnN0IHJ1blxuXHRcdGlmICggIW1hdGNoZWQgfHwgKG1hdGNoID0gcmNvbW1hLmV4ZWMoIHNvRmFyICkpICkge1xuXHRcdFx0aWYgKCBtYXRjaCApIHtcblx0XHRcdFx0Ly8gRG9uJ3QgY29uc3VtZSB0cmFpbGluZyBjb21tYXMgYXMgdmFsaWRcblx0XHRcdFx0c29GYXIgPSBzb0Zhci5zbGljZSggbWF0Y2hbMF0ubGVuZ3RoICkgfHwgc29GYXI7XG5cdFx0XHR9XG5cdFx0XHRncm91cHMucHVzaCggKHRva2VucyA9IFtdKSApO1xuXHRcdH1cblxuXHRcdG1hdGNoZWQgPSBmYWxzZTtcblxuXHRcdC8vIENvbWJpbmF0b3JzXG5cdFx0aWYgKCAobWF0Y2ggPSByY29tYmluYXRvcnMuZXhlYyggc29GYXIgKSkgKSB7XG5cdFx0XHRtYXRjaGVkID0gbWF0Y2guc2hpZnQoKTtcblx0XHRcdHRva2Vucy5wdXNoKHtcblx0XHRcdFx0dmFsdWU6IG1hdGNoZWQsXG5cdFx0XHRcdC8vIENhc3QgZGVzY2VuZGFudCBjb21iaW5hdG9ycyB0byBzcGFjZVxuXHRcdFx0XHR0eXBlOiBtYXRjaFswXS5yZXBsYWNlKCBydHJpbSwgXCIgXCIgKVxuXHRcdFx0fSk7XG5cdFx0XHRzb0ZhciA9IHNvRmFyLnNsaWNlKCBtYXRjaGVkLmxlbmd0aCApO1xuXHRcdH1cblxuXHRcdC8vIEZpbHRlcnNcblx0XHRmb3IgKCB0eXBlIGluIEV4cHIuZmlsdGVyICkge1xuXHRcdFx0aWYgKCAobWF0Y2ggPSBtYXRjaEV4cHJbIHR5cGUgXS5leGVjKCBzb0ZhciApKSAmJiAoIXByZUZpbHRlcnNbIHR5cGUgXSB8fFxuXHRcdFx0XHQobWF0Y2ggPSBwcmVGaWx0ZXJzWyB0eXBlIF0oIG1hdGNoICkpKSApIHtcblx0XHRcdFx0bWF0Y2hlZCA9IG1hdGNoLnNoaWZ0KCk7XG5cdFx0XHRcdHRva2Vucy5wdXNoKHtcblx0XHRcdFx0XHR2YWx1ZTogbWF0Y2hlZCxcblx0XHRcdFx0XHR0eXBlOiB0eXBlLFxuXHRcdFx0XHRcdG1hdGNoZXM6IG1hdGNoXG5cdFx0XHRcdH0pO1xuXHRcdFx0XHRzb0ZhciA9IHNvRmFyLnNsaWNlKCBtYXRjaGVkLmxlbmd0aCApO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGlmICggIW1hdGNoZWQgKSB7XG5cdFx0XHRicmVhaztcblx0XHR9XG5cdH1cblxuXHQvLyBSZXR1cm4gdGhlIGxlbmd0aCBvZiB0aGUgaW52YWxpZCBleGNlc3Ncblx0Ly8gaWYgd2UncmUganVzdCBwYXJzaW5nXG5cdC8vIE90aGVyd2lzZSwgdGhyb3cgYW4gZXJyb3Igb3IgcmV0dXJuIHRva2Vuc1xuXHRyZXR1cm4gcGFyc2VPbmx5ID9cblx0XHRzb0Zhci5sZW5ndGggOlxuXHRcdHNvRmFyID9cblx0XHRcdFNpenpsZS5lcnJvciggc2VsZWN0b3IgKSA6XG5cdFx0XHQvLyBDYWNoZSB0aGUgdG9rZW5zXG5cdFx0XHR0b2tlbkNhY2hlKCBzZWxlY3RvciwgZ3JvdXBzICkuc2xpY2UoIDAgKTtcbn07XG5cbmZ1bmN0aW9uIHRvU2VsZWN0b3IoIHRva2VucyApIHtcblx0dmFyIGkgPSAwLFxuXHRcdGxlbiA9IHRva2Vucy5sZW5ndGgsXG5cdFx0c2VsZWN0b3IgPSBcIlwiO1xuXHRmb3IgKCA7IGkgPCBsZW47IGkrKyApIHtcblx0XHRzZWxlY3RvciArPSB0b2tlbnNbaV0udmFsdWU7XG5cdH1cblx0cmV0dXJuIHNlbGVjdG9yO1xufVxuXG5mdW5jdGlvbiBhZGRDb21iaW5hdG9yKCBtYXRjaGVyLCBjb21iaW5hdG9yLCBiYXNlICkge1xuXHR2YXIgZGlyID0gY29tYmluYXRvci5kaXIsXG5cdFx0c2tpcCA9IGNvbWJpbmF0b3IubmV4dCxcblx0XHRrZXkgPSBza2lwIHx8IGRpcixcblx0XHRjaGVja05vbkVsZW1lbnRzID0gYmFzZSAmJiBrZXkgPT09IFwicGFyZW50Tm9kZVwiLFxuXHRcdGRvbmVOYW1lID0gZG9uZSsrO1xuXG5cdHJldHVybiBjb21iaW5hdG9yLmZpcnN0ID9cblx0XHQvLyBDaGVjayBhZ2FpbnN0IGNsb3Nlc3QgYW5jZXN0b3IvcHJlY2VkaW5nIGVsZW1lbnRcblx0XHRmdW5jdGlvbiggZWxlbSwgY29udGV4dCwgeG1sICkge1xuXHRcdFx0d2hpbGUgKCAoZWxlbSA9IGVsZW1bIGRpciBdKSApIHtcblx0XHRcdFx0aWYgKCBlbGVtLm5vZGVUeXBlID09PSAxIHx8IGNoZWNrTm9uRWxlbWVudHMgKSB7XG5cdFx0XHRcdFx0cmV0dXJuIG1hdGNoZXIoIGVsZW0sIGNvbnRleHQsIHhtbCApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fSA6XG5cblx0XHQvLyBDaGVjayBhZ2FpbnN0IGFsbCBhbmNlc3Rvci9wcmVjZWRpbmcgZWxlbWVudHNcblx0XHRmdW5jdGlvbiggZWxlbSwgY29udGV4dCwgeG1sICkge1xuXHRcdFx0dmFyIG9sZENhY2hlLCB1bmlxdWVDYWNoZSwgb3V0ZXJDYWNoZSxcblx0XHRcdFx0bmV3Q2FjaGUgPSBbIGRpcnJ1bnMsIGRvbmVOYW1lIF07XG5cblx0XHRcdC8vIFdlIGNhbid0IHNldCBhcmJpdHJhcnkgZGF0YSBvbiBYTUwgbm9kZXMsIHNvIHRoZXkgZG9uJ3QgYmVuZWZpdCBmcm9tIGNvbWJpbmF0b3IgY2FjaGluZ1xuXHRcdFx0aWYgKCB4bWwgKSB7XG5cdFx0XHRcdHdoaWxlICggKGVsZW0gPSBlbGVtWyBkaXIgXSkgKSB7XG5cdFx0XHRcdFx0aWYgKCBlbGVtLm5vZGVUeXBlID09PSAxIHx8IGNoZWNrTm9uRWxlbWVudHMgKSB7XG5cdFx0XHRcdFx0XHRpZiAoIG1hdGNoZXIoIGVsZW0sIGNvbnRleHQsIHhtbCApICkge1xuXHRcdFx0XHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHdoaWxlICggKGVsZW0gPSBlbGVtWyBkaXIgXSkgKSB7XG5cdFx0XHRcdFx0aWYgKCBlbGVtLm5vZGVUeXBlID09PSAxIHx8IGNoZWNrTm9uRWxlbWVudHMgKSB7XG5cdFx0XHRcdFx0XHRvdXRlckNhY2hlID0gZWxlbVsgZXhwYW5kbyBdIHx8IChlbGVtWyBleHBhbmRvIF0gPSB7fSk7XG5cblx0XHRcdFx0XHRcdC8vIFN1cHBvcnQ6IElFIDw5IG9ubHlcblx0XHRcdFx0XHRcdC8vIERlZmVuZCBhZ2FpbnN0IGNsb25lZCBhdHRyb3BlcnRpZXMgKGpRdWVyeSBnaC0xNzA5KVxuXHRcdFx0XHRcdFx0dW5pcXVlQ2FjaGUgPSBvdXRlckNhY2hlWyBlbGVtLnVuaXF1ZUlEIF0gfHwgKG91dGVyQ2FjaGVbIGVsZW0udW5pcXVlSUQgXSA9IHt9KTtcblxuXHRcdFx0XHRcdFx0aWYgKCBza2lwICYmIHNraXAgPT09IGVsZW0ubm9kZU5hbWUudG9Mb3dlckNhc2UoKSApIHtcblx0XHRcdFx0XHRcdFx0ZWxlbSA9IGVsZW1bIGRpciBdIHx8IGVsZW07XG5cdFx0XHRcdFx0XHR9IGVsc2UgaWYgKCAob2xkQ2FjaGUgPSB1bmlxdWVDYWNoZVsga2V5IF0pICYmXG5cdFx0XHRcdFx0XHRcdG9sZENhY2hlWyAwIF0gPT09IGRpcnJ1bnMgJiYgb2xkQ2FjaGVbIDEgXSA9PT0gZG9uZU5hbWUgKSB7XG5cblx0XHRcdFx0XHRcdFx0Ly8gQXNzaWduIHRvIG5ld0NhY2hlIHNvIHJlc3VsdHMgYmFjay1wcm9wYWdhdGUgdG8gcHJldmlvdXMgZWxlbWVudHNcblx0XHRcdFx0XHRcdFx0cmV0dXJuIChuZXdDYWNoZVsgMiBdID0gb2xkQ2FjaGVbIDIgXSk7XG5cdFx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0XHQvLyBSZXVzZSBuZXdjYWNoZSBzbyByZXN1bHRzIGJhY2stcHJvcGFnYXRlIHRvIHByZXZpb3VzIGVsZW1lbnRzXG5cdFx0XHRcdFx0XHRcdHVuaXF1ZUNhY2hlWyBrZXkgXSA9IG5ld0NhY2hlO1xuXG5cdFx0XHRcdFx0XHRcdC8vIEEgbWF0Y2ggbWVhbnMgd2UncmUgZG9uZTsgYSBmYWlsIG1lYW5zIHdlIGhhdmUgdG8ga2VlcCBjaGVja2luZ1xuXHRcdFx0XHRcdFx0XHRpZiAoIChuZXdDYWNoZVsgMiBdID0gbWF0Y2hlciggZWxlbSwgY29udGV4dCwgeG1sICkpICkge1xuXHRcdFx0XHRcdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fTtcbn1cblxuZnVuY3Rpb24gZWxlbWVudE1hdGNoZXIoIG1hdGNoZXJzICkge1xuXHRyZXR1cm4gbWF0Y2hlcnMubGVuZ3RoID4gMSA/XG5cdFx0ZnVuY3Rpb24oIGVsZW0sIGNvbnRleHQsIHhtbCApIHtcblx0XHRcdHZhciBpID0gbWF0Y2hlcnMubGVuZ3RoO1xuXHRcdFx0d2hpbGUgKCBpLS0gKSB7XG5cdFx0XHRcdGlmICggIW1hdGNoZXJzW2ldKCBlbGVtLCBjb250ZXh0LCB4bWwgKSApIHtcblx0XHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdHJldHVybiB0cnVlO1xuXHRcdH0gOlxuXHRcdG1hdGNoZXJzWzBdO1xufVxuXG5mdW5jdGlvbiBtdWx0aXBsZUNvbnRleHRzKCBzZWxlY3RvciwgY29udGV4dHMsIHJlc3VsdHMgKSB7XG5cdHZhciBpID0gMCxcblx0XHRsZW4gPSBjb250ZXh0cy5sZW5ndGg7XG5cdGZvciAoIDsgaSA8IGxlbjsgaSsrICkge1xuXHRcdFNpenpsZSggc2VsZWN0b3IsIGNvbnRleHRzW2ldLCByZXN1bHRzICk7XG5cdH1cblx0cmV0dXJuIHJlc3VsdHM7XG59XG5cbmZ1bmN0aW9uIGNvbmRlbnNlKCB1bm1hdGNoZWQsIG1hcCwgZmlsdGVyLCBjb250ZXh0LCB4bWwgKSB7XG5cdHZhciBlbGVtLFxuXHRcdG5ld1VubWF0Y2hlZCA9IFtdLFxuXHRcdGkgPSAwLFxuXHRcdGxlbiA9IHVubWF0Y2hlZC5sZW5ndGgsXG5cdFx0bWFwcGVkID0gbWFwICE9IG51bGw7XG5cblx0Zm9yICggOyBpIDwgbGVuOyBpKysgKSB7XG5cdFx0aWYgKCAoZWxlbSA9IHVubWF0Y2hlZFtpXSkgKSB7XG5cdFx0XHRpZiAoICFmaWx0ZXIgfHwgZmlsdGVyKCBlbGVtLCBjb250ZXh0LCB4bWwgKSApIHtcblx0XHRcdFx0bmV3VW5tYXRjaGVkLnB1c2goIGVsZW0gKTtcblx0XHRcdFx0aWYgKCBtYXBwZWQgKSB7XG5cdFx0XHRcdFx0bWFwLnB1c2goIGkgKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdHJldHVybiBuZXdVbm1hdGNoZWQ7XG59XG5cbmZ1bmN0aW9uIHNldE1hdGNoZXIoIHByZUZpbHRlciwgc2VsZWN0b3IsIG1hdGNoZXIsIHBvc3RGaWx0ZXIsIHBvc3RGaW5kZXIsIHBvc3RTZWxlY3RvciApIHtcblx0aWYgKCBwb3N0RmlsdGVyICYmICFwb3N0RmlsdGVyWyBleHBhbmRvIF0gKSB7XG5cdFx0cG9zdEZpbHRlciA9IHNldE1hdGNoZXIoIHBvc3RGaWx0ZXIgKTtcblx0fVxuXHRpZiAoIHBvc3RGaW5kZXIgJiYgIXBvc3RGaW5kZXJbIGV4cGFuZG8gXSApIHtcblx0XHRwb3N0RmluZGVyID0gc2V0TWF0Y2hlciggcG9zdEZpbmRlciwgcG9zdFNlbGVjdG9yICk7XG5cdH1cblx0cmV0dXJuIG1hcmtGdW5jdGlvbihmdW5jdGlvbiggc2VlZCwgcmVzdWx0cywgY29udGV4dCwgeG1sICkge1xuXHRcdHZhciB0ZW1wLCBpLCBlbGVtLFxuXHRcdFx0cHJlTWFwID0gW10sXG5cdFx0XHRwb3N0TWFwID0gW10sXG5cdFx0XHRwcmVleGlzdGluZyA9IHJlc3VsdHMubGVuZ3RoLFxuXG5cdFx0XHQvLyBHZXQgaW5pdGlhbCBlbGVtZW50cyBmcm9tIHNlZWQgb3IgY29udGV4dFxuXHRcdFx0ZWxlbXMgPSBzZWVkIHx8IG11bHRpcGxlQ29udGV4dHMoIHNlbGVjdG9yIHx8IFwiKlwiLCBjb250ZXh0Lm5vZGVUeXBlID8gWyBjb250ZXh0IF0gOiBjb250ZXh0LCBbXSApLFxuXG5cdFx0XHQvLyBQcmVmaWx0ZXIgdG8gZ2V0IG1hdGNoZXIgaW5wdXQsIHByZXNlcnZpbmcgYSBtYXAgZm9yIHNlZWQtcmVzdWx0cyBzeW5jaHJvbml6YXRpb25cblx0XHRcdG1hdGNoZXJJbiA9IHByZUZpbHRlciAmJiAoIHNlZWQgfHwgIXNlbGVjdG9yICkgP1xuXHRcdFx0XHRjb25kZW5zZSggZWxlbXMsIHByZU1hcCwgcHJlRmlsdGVyLCBjb250ZXh0LCB4bWwgKSA6XG5cdFx0XHRcdGVsZW1zLFxuXG5cdFx0XHRtYXRjaGVyT3V0ID0gbWF0Y2hlciA/XG5cdFx0XHRcdC8vIElmIHdlIGhhdmUgYSBwb3N0RmluZGVyLCBvciBmaWx0ZXJlZCBzZWVkLCBvciBub24tc2VlZCBwb3N0RmlsdGVyIG9yIHByZWV4aXN0aW5nIHJlc3VsdHMsXG5cdFx0XHRcdHBvc3RGaW5kZXIgfHwgKCBzZWVkID8gcHJlRmlsdGVyIDogcHJlZXhpc3RpbmcgfHwgcG9zdEZpbHRlciApID9cblxuXHRcdFx0XHRcdC8vIC4uLmludGVybWVkaWF0ZSBwcm9jZXNzaW5nIGlzIG5lY2Vzc2FyeVxuXHRcdFx0XHRcdFtdIDpcblxuXHRcdFx0XHRcdC8vIC4uLm90aGVyd2lzZSB1c2UgcmVzdWx0cyBkaXJlY3RseVxuXHRcdFx0XHRcdHJlc3VsdHMgOlxuXHRcdFx0XHRtYXRjaGVySW47XG5cblx0XHQvLyBGaW5kIHByaW1hcnkgbWF0Y2hlc1xuXHRcdGlmICggbWF0Y2hlciApIHtcblx0XHRcdG1hdGNoZXIoIG1hdGNoZXJJbiwgbWF0Y2hlck91dCwgY29udGV4dCwgeG1sICk7XG5cdFx0fVxuXG5cdFx0Ly8gQXBwbHkgcG9zdEZpbHRlclxuXHRcdGlmICggcG9zdEZpbHRlciApIHtcblx0XHRcdHRlbXAgPSBjb25kZW5zZSggbWF0Y2hlck91dCwgcG9zdE1hcCApO1xuXHRcdFx0cG9zdEZpbHRlciggdGVtcCwgW10sIGNvbnRleHQsIHhtbCApO1xuXG5cdFx0XHQvLyBVbi1tYXRjaCBmYWlsaW5nIGVsZW1lbnRzIGJ5IG1vdmluZyB0aGVtIGJhY2sgdG8gbWF0Y2hlckluXG5cdFx0XHRpID0gdGVtcC5sZW5ndGg7XG5cdFx0XHR3aGlsZSAoIGktLSApIHtcblx0XHRcdFx0aWYgKCAoZWxlbSA9IHRlbXBbaV0pICkge1xuXHRcdFx0XHRcdG1hdGNoZXJPdXRbIHBvc3RNYXBbaV0gXSA9ICEobWF0Y2hlckluWyBwb3N0TWFwW2ldIF0gPSBlbGVtKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGlmICggc2VlZCApIHtcblx0XHRcdGlmICggcG9zdEZpbmRlciB8fCBwcmVGaWx0ZXIgKSB7XG5cdFx0XHRcdGlmICggcG9zdEZpbmRlciApIHtcblx0XHRcdFx0XHQvLyBHZXQgdGhlIGZpbmFsIG1hdGNoZXJPdXQgYnkgY29uZGVuc2luZyB0aGlzIGludGVybWVkaWF0ZSBpbnRvIHBvc3RGaW5kZXIgY29udGV4dHNcblx0XHRcdFx0XHR0ZW1wID0gW107XG5cdFx0XHRcdFx0aSA9IG1hdGNoZXJPdXQubGVuZ3RoO1xuXHRcdFx0XHRcdHdoaWxlICggaS0tICkge1xuXHRcdFx0XHRcdFx0aWYgKCAoZWxlbSA9IG1hdGNoZXJPdXRbaV0pICkge1xuXHRcdFx0XHRcdFx0XHQvLyBSZXN0b3JlIG1hdGNoZXJJbiBzaW5jZSBlbGVtIGlzIG5vdCB5ZXQgYSBmaW5hbCBtYXRjaFxuXHRcdFx0XHRcdFx0XHR0ZW1wLnB1c2goIChtYXRjaGVySW5baV0gPSBlbGVtKSApO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRwb3N0RmluZGVyKCBudWxsLCAobWF0Y2hlck91dCA9IFtdKSwgdGVtcCwgeG1sICk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBNb3ZlIG1hdGNoZWQgZWxlbWVudHMgZnJvbSBzZWVkIHRvIHJlc3VsdHMgdG8ga2VlcCB0aGVtIHN5bmNocm9uaXplZFxuXHRcdFx0XHRpID0gbWF0Y2hlck91dC5sZW5ndGg7XG5cdFx0XHRcdHdoaWxlICggaS0tICkge1xuXHRcdFx0XHRcdGlmICggKGVsZW0gPSBtYXRjaGVyT3V0W2ldKSAmJlxuXHRcdFx0XHRcdFx0KHRlbXAgPSBwb3N0RmluZGVyID8gaW5kZXhPZiggc2VlZCwgZWxlbSApIDogcHJlTWFwW2ldKSA+IC0xICkge1xuXG5cdFx0XHRcdFx0XHRzZWVkW3RlbXBdID0gIShyZXN1bHRzW3RlbXBdID0gZWxlbSk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHQvLyBBZGQgZWxlbWVudHMgdG8gcmVzdWx0cywgdGhyb3VnaCBwb3N0RmluZGVyIGlmIGRlZmluZWRcblx0XHR9IGVsc2Uge1xuXHRcdFx0bWF0Y2hlck91dCA9IGNvbmRlbnNlKFxuXHRcdFx0XHRtYXRjaGVyT3V0ID09PSByZXN1bHRzID9cblx0XHRcdFx0XHRtYXRjaGVyT3V0LnNwbGljZSggcHJlZXhpc3RpbmcsIG1hdGNoZXJPdXQubGVuZ3RoICkgOlxuXHRcdFx0XHRcdG1hdGNoZXJPdXRcblx0XHRcdCk7XG5cdFx0XHRpZiAoIHBvc3RGaW5kZXIgKSB7XG5cdFx0XHRcdHBvc3RGaW5kZXIoIG51bGwsIHJlc3VsdHMsIG1hdGNoZXJPdXQsIHhtbCApO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0cHVzaC5hcHBseSggcmVzdWx0cywgbWF0Y2hlck91dCApO1xuXHRcdFx0fVxuXHRcdH1cblx0fSk7XG59XG5cbmZ1bmN0aW9uIG1hdGNoZXJGcm9tVG9rZW5zKCB0b2tlbnMgKSB7XG5cdHZhciBjaGVja0NvbnRleHQsIG1hdGNoZXIsIGosXG5cdFx0bGVuID0gdG9rZW5zLmxlbmd0aCxcblx0XHRsZWFkaW5nUmVsYXRpdmUgPSBFeHByLnJlbGF0aXZlWyB0b2tlbnNbMF0udHlwZSBdLFxuXHRcdGltcGxpY2l0UmVsYXRpdmUgPSBsZWFkaW5nUmVsYXRpdmUgfHwgRXhwci5yZWxhdGl2ZVtcIiBcIl0sXG5cdFx0aSA9IGxlYWRpbmdSZWxhdGl2ZSA/IDEgOiAwLFxuXG5cdFx0Ly8gVGhlIGZvdW5kYXRpb25hbCBtYXRjaGVyIGVuc3VyZXMgdGhhdCBlbGVtZW50cyBhcmUgcmVhY2hhYmxlIGZyb20gdG9wLWxldmVsIGNvbnRleHQocylcblx0XHRtYXRjaENvbnRleHQgPSBhZGRDb21iaW5hdG9yKCBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdHJldHVybiBlbGVtID09PSBjaGVja0NvbnRleHQ7XG5cdFx0fSwgaW1wbGljaXRSZWxhdGl2ZSwgdHJ1ZSApLFxuXHRcdG1hdGNoQW55Q29udGV4dCA9IGFkZENvbWJpbmF0b3IoIGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0cmV0dXJuIGluZGV4T2YoIGNoZWNrQ29udGV4dCwgZWxlbSApID4gLTE7XG5cdFx0fSwgaW1wbGljaXRSZWxhdGl2ZSwgdHJ1ZSApLFxuXHRcdG1hdGNoZXJzID0gWyBmdW5jdGlvbiggZWxlbSwgY29udGV4dCwgeG1sICkge1xuXHRcdFx0dmFyIHJldCA9ICggIWxlYWRpbmdSZWxhdGl2ZSAmJiAoIHhtbCB8fCBjb250ZXh0ICE9PSBvdXRlcm1vc3RDb250ZXh0ICkgKSB8fCAoXG5cdFx0XHRcdChjaGVja0NvbnRleHQgPSBjb250ZXh0KS5ub2RlVHlwZSA/XG5cdFx0XHRcdFx0bWF0Y2hDb250ZXh0KCBlbGVtLCBjb250ZXh0LCB4bWwgKSA6XG5cdFx0XHRcdFx0bWF0Y2hBbnlDb250ZXh0KCBlbGVtLCBjb250ZXh0LCB4bWwgKSApO1xuXHRcdFx0Ly8gQXZvaWQgaGFuZ2luZyBvbnRvIGVsZW1lbnQgKGlzc3VlICMyOTkpXG5cdFx0XHRjaGVja0NvbnRleHQgPSBudWxsO1xuXHRcdFx0cmV0dXJuIHJldDtcblx0XHR9IF07XG5cblx0Zm9yICggOyBpIDwgbGVuOyBpKysgKSB7XG5cdFx0aWYgKCAobWF0Y2hlciA9IEV4cHIucmVsYXRpdmVbIHRva2Vuc1tpXS50eXBlIF0pICkge1xuXHRcdFx0bWF0Y2hlcnMgPSBbIGFkZENvbWJpbmF0b3IoZWxlbWVudE1hdGNoZXIoIG1hdGNoZXJzICksIG1hdGNoZXIpIF07XG5cdFx0fSBlbHNlIHtcblx0XHRcdG1hdGNoZXIgPSBFeHByLmZpbHRlclsgdG9rZW5zW2ldLnR5cGUgXS5hcHBseSggbnVsbCwgdG9rZW5zW2ldLm1hdGNoZXMgKTtcblxuXHRcdFx0Ly8gUmV0dXJuIHNwZWNpYWwgdXBvbiBzZWVpbmcgYSBwb3NpdGlvbmFsIG1hdGNoZXJcblx0XHRcdGlmICggbWF0Y2hlclsgZXhwYW5kbyBdICkge1xuXHRcdFx0XHQvLyBGaW5kIHRoZSBuZXh0IHJlbGF0aXZlIG9wZXJhdG9yIChpZiBhbnkpIGZvciBwcm9wZXIgaGFuZGxpbmdcblx0XHRcdFx0aiA9ICsraTtcblx0XHRcdFx0Zm9yICggOyBqIDwgbGVuOyBqKysgKSB7XG5cdFx0XHRcdFx0aWYgKCBFeHByLnJlbGF0aXZlWyB0b2tlbnNbal0udHlwZSBdICkge1xuXHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiBzZXRNYXRjaGVyKFxuXHRcdFx0XHRcdGkgPiAxICYmIGVsZW1lbnRNYXRjaGVyKCBtYXRjaGVycyApLFxuXHRcdFx0XHRcdGkgPiAxICYmIHRvU2VsZWN0b3IoXG5cdFx0XHRcdFx0XHQvLyBJZiB0aGUgcHJlY2VkaW5nIHRva2VuIHdhcyBhIGRlc2NlbmRhbnQgY29tYmluYXRvciwgaW5zZXJ0IGFuIGltcGxpY2l0IGFueS1lbGVtZW50IGAqYFxuXHRcdFx0XHRcdFx0dG9rZW5zLnNsaWNlKCAwLCBpIC0gMSApLmNvbmNhdCh7IHZhbHVlOiB0b2tlbnNbIGkgLSAyIF0udHlwZSA9PT0gXCIgXCIgPyBcIipcIiA6IFwiXCIgfSlcblx0XHRcdFx0XHQpLnJlcGxhY2UoIHJ0cmltLCBcIiQxXCIgKSxcblx0XHRcdFx0XHRtYXRjaGVyLFxuXHRcdFx0XHRcdGkgPCBqICYmIG1hdGNoZXJGcm9tVG9rZW5zKCB0b2tlbnMuc2xpY2UoIGksIGogKSApLFxuXHRcdFx0XHRcdGogPCBsZW4gJiYgbWF0Y2hlckZyb21Ub2tlbnMoICh0b2tlbnMgPSB0b2tlbnMuc2xpY2UoIGogKSkgKSxcblx0XHRcdFx0XHRqIDwgbGVuICYmIHRvU2VsZWN0b3IoIHRva2VucyApXG5cdFx0XHRcdCk7XG5cdFx0XHR9XG5cdFx0XHRtYXRjaGVycy5wdXNoKCBtYXRjaGVyICk7XG5cdFx0fVxuXHR9XG5cblx0cmV0dXJuIGVsZW1lbnRNYXRjaGVyKCBtYXRjaGVycyApO1xufVxuXG5mdW5jdGlvbiBtYXRjaGVyRnJvbUdyb3VwTWF0Y2hlcnMoIGVsZW1lbnRNYXRjaGVycywgc2V0TWF0Y2hlcnMgKSB7XG5cdHZhciBieVNldCA9IHNldE1hdGNoZXJzLmxlbmd0aCA+IDAsXG5cdFx0YnlFbGVtZW50ID0gZWxlbWVudE1hdGNoZXJzLmxlbmd0aCA+IDAsXG5cdFx0c3VwZXJNYXRjaGVyID0gZnVuY3Rpb24oIHNlZWQsIGNvbnRleHQsIHhtbCwgcmVzdWx0cywgb3V0ZXJtb3N0ICkge1xuXHRcdFx0dmFyIGVsZW0sIGosIG1hdGNoZXIsXG5cdFx0XHRcdG1hdGNoZWRDb3VudCA9IDAsXG5cdFx0XHRcdGkgPSBcIjBcIixcblx0XHRcdFx0dW5tYXRjaGVkID0gc2VlZCAmJiBbXSxcblx0XHRcdFx0c2V0TWF0Y2hlZCA9IFtdLFxuXHRcdFx0XHRjb250ZXh0QmFja3VwID0gb3V0ZXJtb3N0Q29udGV4dCxcblx0XHRcdFx0Ly8gV2UgbXVzdCBhbHdheXMgaGF2ZSBlaXRoZXIgc2VlZCBlbGVtZW50cyBvciBvdXRlcm1vc3QgY29udGV4dFxuXHRcdFx0XHRlbGVtcyA9IHNlZWQgfHwgYnlFbGVtZW50ICYmIEV4cHIuZmluZFtcIlRBR1wiXSggXCIqXCIsIG91dGVybW9zdCApLFxuXHRcdFx0XHQvLyBVc2UgaW50ZWdlciBkaXJydW5zIGlmZiB0aGlzIGlzIHRoZSBvdXRlcm1vc3QgbWF0Y2hlclxuXHRcdFx0XHRkaXJydW5zVW5pcXVlID0gKGRpcnJ1bnMgKz0gY29udGV4dEJhY2t1cCA9PSBudWxsID8gMSA6IE1hdGgucmFuZG9tKCkgfHwgMC4xKSxcblx0XHRcdFx0bGVuID0gZWxlbXMubGVuZ3RoO1xuXG5cdFx0XHRpZiAoIG91dGVybW9zdCApIHtcblx0XHRcdFx0b3V0ZXJtb3N0Q29udGV4dCA9IGNvbnRleHQgPT09IGRvY3VtZW50IHx8IGNvbnRleHQgfHwgb3V0ZXJtb3N0O1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBBZGQgZWxlbWVudHMgcGFzc2luZyBlbGVtZW50TWF0Y2hlcnMgZGlyZWN0bHkgdG8gcmVzdWx0c1xuXHRcdFx0Ly8gU3VwcG9ydDogSUU8OSwgU2FmYXJpXG5cdFx0XHQvLyBUb2xlcmF0ZSBOb2RlTGlzdCBwcm9wZXJ0aWVzIChJRTogXCJsZW5ndGhcIjsgU2FmYXJpOiA8bnVtYmVyPikgbWF0Y2hpbmcgZWxlbWVudHMgYnkgaWRcblx0XHRcdGZvciAoIDsgaSAhPT0gbGVuICYmIChlbGVtID0gZWxlbXNbaV0pICE9IG51bGw7IGkrKyApIHtcblx0XHRcdFx0aWYgKCBieUVsZW1lbnQgJiYgZWxlbSApIHtcblx0XHRcdFx0XHRqID0gMDtcblx0XHRcdFx0XHRpZiAoICFjb250ZXh0ICYmIGVsZW0ub3duZXJEb2N1bWVudCAhPT0gZG9jdW1lbnQgKSB7XG5cdFx0XHRcdFx0XHRzZXREb2N1bWVudCggZWxlbSApO1xuXHRcdFx0XHRcdFx0eG1sID0gIWRvY3VtZW50SXNIVE1MO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHR3aGlsZSAoIChtYXRjaGVyID0gZWxlbWVudE1hdGNoZXJzW2orK10pICkge1xuXHRcdFx0XHRcdFx0aWYgKCBtYXRjaGVyKCBlbGVtLCBjb250ZXh0IHx8IGRvY3VtZW50LCB4bWwpICkge1xuXHRcdFx0XHRcdFx0XHRyZXN1bHRzLnB1c2goIGVsZW0gKTtcblx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGlmICggb3V0ZXJtb3N0ICkge1xuXHRcdFx0XHRcdFx0ZGlycnVucyA9IGRpcnJ1bnNVbmlxdWU7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gVHJhY2sgdW5tYXRjaGVkIGVsZW1lbnRzIGZvciBzZXQgZmlsdGVyc1xuXHRcdFx0XHRpZiAoIGJ5U2V0ICkge1xuXHRcdFx0XHRcdC8vIFRoZXkgd2lsbCBoYXZlIGdvbmUgdGhyb3VnaCBhbGwgcG9zc2libGUgbWF0Y2hlcnNcblx0XHRcdFx0XHRpZiAoIChlbGVtID0gIW1hdGNoZXIgJiYgZWxlbSkgKSB7XG5cdFx0XHRcdFx0XHRtYXRjaGVkQ291bnQtLTtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHQvLyBMZW5ndGhlbiB0aGUgYXJyYXkgZm9yIGV2ZXJ5IGVsZW1lbnQsIG1hdGNoZWQgb3Igbm90XG5cdFx0XHRcdFx0aWYgKCBzZWVkICkge1xuXHRcdFx0XHRcdFx0dW5tYXRjaGVkLnB1c2goIGVsZW0gKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0Ly8gYGlgIGlzIG5vdyB0aGUgY291bnQgb2YgZWxlbWVudHMgdmlzaXRlZCBhYm92ZSwgYW5kIGFkZGluZyBpdCB0byBgbWF0Y2hlZENvdW50YFxuXHRcdFx0Ly8gbWFrZXMgdGhlIGxhdHRlciBub25uZWdhdGl2ZS5cblx0XHRcdG1hdGNoZWRDb3VudCArPSBpO1xuXG5cdFx0XHQvLyBBcHBseSBzZXQgZmlsdGVycyB0byB1bm1hdGNoZWQgZWxlbWVudHNcblx0XHRcdC8vIE5PVEU6IFRoaXMgY2FuIGJlIHNraXBwZWQgaWYgdGhlcmUgYXJlIG5vIHVubWF0Y2hlZCBlbGVtZW50cyAoaS5lLiwgYG1hdGNoZWRDb3VudGBcblx0XHRcdC8vIGVxdWFscyBgaWApLCB1bmxlc3Mgd2UgZGlkbid0IHZpc2l0IF9hbnlfIGVsZW1lbnRzIGluIHRoZSBhYm92ZSBsb29wIGJlY2F1c2Ugd2UgaGF2ZVxuXHRcdFx0Ly8gbm8gZWxlbWVudCBtYXRjaGVycyBhbmQgbm8gc2VlZC5cblx0XHRcdC8vIEluY3JlbWVudGluZyBhbiBpbml0aWFsbHktc3RyaW5nIFwiMFwiIGBpYCBhbGxvd3MgYGlgIHRvIHJlbWFpbiBhIHN0cmluZyBvbmx5IGluIHRoYXRcblx0XHRcdC8vIGNhc2UsIHdoaWNoIHdpbGwgcmVzdWx0IGluIGEgXCIwMFwiIGBtYXRjaGVkQ291bnRgIHRoYXQgZGlmZmVycyBmcm9tIGBpYCBidXQgaXMgYWxzb1xuXHRcdFx0Ly8gbnVtZXJpY2FsbHkgemVyby5cblx0XHRcdGlmICggYnlTZXQgJiYgaSAhPT0gbWF0Y2hlZENvdW50ICkge1xuXHRcdFx0XHRqID0gMDtcblx0XHRcdFx0d2hpbGUgKCAobWF0Y2hlciA9IHNldE1hdGNoZXJzW2orK10pICkge1xuXHRcdFx0XHRcdG1hdGNoZXIoIHVubWF0Y2hlZCwgc2V0TWF0Y2hlZCwgY29udGV4dCwgeG1sICk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpZiAoIHNlZWQgKSB7XG5cdFx0XHRcdFx0Ly8gUmVpbnRlZ3JhdGUgZWxlbWVudCBtYXRjaGVzIHRvIGVsaW1pbmF0ZSB0aGUgbmVlZCBmb3Igc29ydGluZ1xuXHRcdFx0XHRcdGlmICggbWF0Y2hlZENvdW50ID4gMCApIHtcblx0XHRcdFx0XHRcdHdoaWxlICggaS0tICkge1xuXHRcdFx0XHRcdFx0XHRpZiAoICEodW5tYXRjaGVkW2ldIHx8IHNldE1hdGNoZWRbaV0pICkge1xuXHRcdFx0XHRcdFx0XHRcdHNldE1hdGNoZWRbaV0gPSBwb3AuY2FsbCggcmVzdWx0cyApO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0Ly8gRGlzY2FyZCBpbmRleCBwbGFjZWhvbGRlciB2YWx1ZXMgdG8gZ2V0IG9ubHkgYWN0dWFsIG1hdGNoZXNcblx0XHRcdFx0XHRzZXRNYXRjaGVkID0gY29uZGVuc2UoIHNldE1hdGNoZWQgKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIEFkZCBtYXRjaGVzIHRvIHJlc3VsdHNcblx0XHRcdFx0cHVzaC5hcHBseSggcmVzdWx0cywgc2V0TWF0Y2hlZCApO1xuXG5cdFx0XHRcdC8vIFNlZWRsZXNzIHNldCBtYXRjaGVzIHN1Y2NlZWRpbmcgbXVsdGlwbGUgc3VjY2Vzc2Z1bCBtYXRjaGVycyBzdGlwdWxhdGUgc29ydGluZ1xuXHRcdFx0XHRpZiAoIG91dGVybW9zdCAmJiAhc2VlZCAmJiBzZXRNYXRjaGVkLmxlbmd0aCA+IDAgJiZcblx0XHRcdFx0XHQoIG1hdGNoZWRDb3VudCArIHNldE1hdGNoZXJzLmxlbmd0aCApID4gMSApIHtcblxuXHRcdFx0XHRcdFNpenpsZS51bmlxdWVTb3J0KCByZXN1bHRzICk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0Ly8gT3ZlcnJpZGUgbWFuaXB1bGF0aW9uIG9mIGdsb2JhbHMgYnkgbmVzdGVkIG1hdGNoZXJzXG5cdFx0XHRpZiAoIG91dGVybW9zdCApIHtcblx0XHRcdFx0ZGlycnVucyA9IGRpcnJ1bnNVbmlxdWU7XG5cdFx0XHRcdG91dGVybW9zdENvbnRleHQgPSBjb250ZXh0QmFja3VwO1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gdW5tYXRjaGVkO1xuXHRcdH07XG5cblx0cmV0dXJuIGJ5U2V0ID9cblx0XHRtYXJrRnVuY3Rpb24oIHN1cGVyTWF0Y2hlciApIDpcblx0XHRzdXBlck1hdGNoZXI7XG59XG5cbmNvbXBpbGUgPSBTaXp6bGUuY29tcGlsZSA9IGZ1bmN0aW9uKCBzZWxlY3RvciwgbWF0Y2ggLyogSW50ZXJuYWwgVXNlIE9ubHkgKi8gKSB7XG5cdHZhciBpLFxuXHRcdHNldE1hdGNoZXJzID0gW10sXG5cdFx0ZWxlbWVudE1hdGNoZXJzID0gW10sXG5cdFx0Y2FjaGVkID0gY29tcGlsZXJDYWNoZVsgc2VsZWN0b3IgKyBcIiBcIiBdO1xuXG5cdGlmICggIWNhY2hlZCApIHtcblx0XHQvLyBHZW5lcmF0ZSBhIGZ1bmN0aW9uIG9mIHJlY3Vyc2l2ZSBmdW5jdGlvbnMgdGhhdCBjYW4gYmUgdXNlZCB0byBjaGVjayBlYWNoIGVsZW1lbnRcblx0XHRpZiAoICFtYXRjaCApIHtcblx0XHRcdG1hdGNoID0gdG9rZW5pemUoIHNlbGVjdG9yICk7XG5cdFx0fVxuXHRcdGkgPSBtYXRjaC5sZW5ndGg7XG5cdFx0d2hpbGUgKCBpLS0gKSB7XG5cdFx0XHRjYWNoZWQgPSBtYXRjaGVyRnJvbVRva2VucyggbWF0Y2hbaV0gKTtcblx0XHRcdGlmICggY2FjaGVkWyBleHBhbmRvIF0gKSB7XG5cdFx0XHRcdHNldE1hdGNoZXJzLnB1c2goIGNhY2hlZCApO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0ZWxlbWVudE1hdGNoZXJzLnB1c2goIGNhY2hlZCApO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIENhY2hlIHRoZSBjb21waWxlZCBmdW5jdGlvblxuXHRcdGNhY2hlZCA9IGNvbXBpbGVyQ2FjaGUoIHNlbGVjdG9yLCBtYXRjaGVyRnJvbUdyb3VwTWF0Y2hlcnMoIGVsZW1lbnRNYXRjaGVycywgc2V0TWF0Y2hlcnMgKSApO1xuXG5cdFx0Ly8gU2F2ZSBzZWxlY3RvciBhbmQgdG9rZW5pemF0aW9uXG5cdFx0Y2FjaGVkLnNlbGVjdG9yID0gc2VsZWN0b3I7XG5cdH1cblx0cmV0dXJuIGNhY2hlZDtcbn07XG5cbi8qKlxuICogQSBsb3ctbGV2ZWwgc2VsZWN0aW9uIGZ1bmN0aW9uIHRoYXQgd29ya3Mgd2l0aCBTaXp6bGUncyBjb21waWxlZFxuICogIHNlbGVjdG9yIGZ1bmN0aW9uc1xuICogQHBhcmFtIHtTdHJpbmd8RnVuY3Rpb259IHNlbGVjdG9yIEEgc2VsZWN0b3Igb3IgYSBwcmUtY29tcGlsZWRcbiAqICBzZWxlY3RvciBmdW5jdGlvbiBidWlsdCB3aXRoIFNpenpsZS5jb21waWxlXG4gKiBAcGFyYW0ge0VsZW1lbnR9IGNvbnRleHRcbiAqIEBwYXJhbSB7QXJyYXl9IFtyZXN1bHRzXVxuICogQHBhcmFtIHtBcnJheX0gW3NlZWRdIEEgc2V0IG9mIGVsZW1lbnRzIHRvIG1hdGNoIGFnYWluc3RcbiAqL1xuc2VsZWN0ID0gU2l6emxlLnNlbGVjdCA9IGZ1bmN0aW9uKCBzZWxlY3RvciwgY29udGV4dCwgcmVzdWx0cywgc2VlZCApIHtcblx0dmFyIGksIHRva2VucywgdG9rZW4sIHR5cGUsIGZpbmQsXG5cdFx0Y29tcGlsZWQgPSB0eXBlb2Ygc2VsZWN0b3IgPT09IFwiZnVuY3Rpb25cIiAmJiBzZWxlY3Rvcixcblx0XHRtYXRjaCA9ICFzZWVkICYmIHRva2VuaXplKCAoc2VsZWN0b3IgPSBjb21waWxlZC5zZWxlY3RvciB8fCBzZWxlY3RvcikgKTtcblxuXHRyZXN1bHRzID0gcmVzdWx0cyB8fCBbXTtcblxuXHQvLyBUcnkgdG8gbWluaW1pemUgb3BlcmF0aW9ucyBpZiB0aGVyZSBpcyBvbmx5IG9uZSBzZWxlY3RvciBpbiB0aGUgbGlzdCBhbmQgbm8gc2VlZFxuXHQvLyAodGhlIGxhdHRlciBvZiB3aGljaCBndWFyYW50ZWVzIHVzIGNvbnRleHQpXG5cdGlmICggbWF0Y2gubGVuZ3RoID09PSAxICkge1xuXG5cdFx0Ly8gUmVkdWNlIGNvbnRleHQgaWYgdGhlIGxlYWRpbmcgY29tcG91bmQgc2VsZWN0b3IgaXMgYW4gSURcblx0XHR0b2tlbnMgPSBtYXRjaFswXSA9IG1hdGNoWzBdLnNsaWNlKCAwICk7XG5cdFx0aWYgKCB0b2tlbnMubGVuZ3RoID4gMiAmJiAodG9rZW4gPSB0b2tlbnNbMF0pLnR5cGUgPT09IFwiSURcIiAmJlxuXHRcdFx0XHRjb250ZXh0Lm5vZGVUeXBlID09PSA5ICYmIGRvY3VtZW50SXNIVE1MICYmIEV4cHIucmVsYXRpdmVbIHRva2Vuc1sxXS50eXBlIF0gKSB7XG5cblx0XHRcdGNvbnRleHQgPSAoIEV4cHIuZmluZFtcIklEXCJdKCB0b2tlbi5tYXRjaGVzWzBdLnJlcGxhY2UocnVuZXNjYXBlLCBmdW5lc2NhcGUpLCBjb250ZXh0ICkgfHwgW10gKVswXTtcblx0XHRcdGlmICggIWNvbnRleHQgKSB7XG5cdFx0XHRcdHJldHVybiByZXN1bHRzO1xuXG5cdFx0XHQvLyBQcmVjb21waWxlZCBtYXRjaGVycyB3aWxsIHN0aWxsIHZlcmlmeSBhbmNlc3RyeSwgc28gc3RlcCB1cCBhIGxldmVsXG5cdFx0XHR9IGVsc2UgaWYgKCBjb21waWxlZCApIHtcblx0XHRcdFx0Y29udGV4dCA9IGNvbnRleHQucGFyZW50Tm9kZTtcblx0XHRcdH1cblxuXHRcdFx0c2VsZWN0b3IgPSBzZWxlY3Rvci5zbGljZSggdG9rZW5zLnNoaWZ0KCkudmFsdWUubGVuZ3RoICk7XG5cdFx0fVxuXG5cdFx0Ly8gRmV0Y2ggYSBzZWVkIHNldCBmb3IgcmlnaHQtdG8tbGVmdCBtYXRjaGluZ1xuXHRcdGkgPSBtYXRjaEV4cHJbXCJuZWVkc0NvbnRleHRcIl0udGVzdCggc2VsZWN0b3IgKSA/IDAgOiB0b2tlbnMubGVuZ3RoO1xuXHRcdHdoaWxlICggaS0tICkge1xuXHRcdFx0dG9rZW4gPSB0b2tlbnNbaV07XG5cblx0XHRcdC8vIEFib3J0IGlmIHdlIGhpdCBhIGNvbWJpbmF0b3Jcblx0XHRcdGlmICggRXhwci5yZWxhdGl2ZVsgKHR5cGUgPSB0b2tlbi50eXBlKSBdICkge1xuXHRcdFx0XHRicmVhaztcblx0XHRcdH1cblx0XHRcdGlmICggKGZpbmQgPSBFeHByLmZpbmRbIHR5cGUgXSkgKSB7XG5cdFx0XHRcdC8vIFNlYXJjaCwgZXhwYW5kaW5nIGNvbnRleHQgZm9yIGxlYWRpbmcgc2libGluZyBjb21iaW5hdG9yc1xuXHRcdFx0XHRpZiAoIChzZWVkID0gZmluZChcblx0XHRcdFx0XHR0b2tlbi5tYXRjaGVzWzBdLnJlcGxhY2UoIHJ1bmVzY2FwZSwgZnVuZXNjYXBlICksXG5cdFx0XHRcdFx0cnNpYmxpbmcudGVzdCggdG9rZW5zWzBdLnR5cGUgKSAmJiB0ZXN0Q29udGV4dCggY29udGV4dC5wYXJlbnROb2RlICkgfHwgY29udGV4dFxuXHRcdFx0XHQpKSApIHtcblxuXHRcdFx0XHRcdC8vIElmIHNlZWQgaXMgZW1wdHkgb3Igbm8gdG9rZW5zIHJlbWFpbiwgd2UgY2FuIHJldHVybiBlYXJseVxuXHRcdFx0XHRcdHRva2Vucy5zcGxpY2UoIGksIDEgKTtcblx0XHRcdFx0XHRzZWxlY3RvciA9IHNlZWQubGVuZ3RoICYmIHRvU2VsZWN0b3IoIHRva2VucyApO1xuXHRcdFx0XHRcdGlmICggIXNlbGVjdG9yICkge1xuXHRcdFx0XHRcdFx0cHVzaC5hcHBseSggcmVzdWx0cywgc2VlZCApO1xuXHRcdFx0XHRcdFx0cmV0dXJuIHJlc3VsdHM7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHQvLyBDb21waWxlIGFuZCBleGVjdXRlIGEgZmlsdGVyaW5nIGZ1bmN0aW9uIGlmIG9uZSBpcyBub3QgcHJvdmlkZWRcblx0Ly8gUHJvdmlkZSBgbWF0Y2hgIHRvIGF2b2lkIHJldG9rZW5pemF0aW9uIGlmIHdlIG1vZGlmaWVkIHRoZSBzZWxlY3RvciBhYm92ZVxuXHQoIGNvbXBpbGVkIHx8IGNvbXBpbGUoIHNlbGVjdG9yLCBtYXRjaCApICkoXG5cdFx0c2VlZCxcblx0XHRjb250ZXh0LFxuXHRcdCFkb2N1bWVudElzSFRNTCxcblx0XHRyZXN1bHRzLFxuXHRcdCFjb250ZXh0IHx8IHJzaWJsaW5nLnRlc3QoIHNlbGVjdG9yICkgJiYgdGVzdENvbnRleHQoIGNvbnRleHQucGFyZW50Tm9kZSApIHx8IGNvbnRleHRcblx0KTtcblx0cmV0dXJuIHJlc3VsdHM7XG59O1xuXG4vLyBPbmUtdGltZSBhc3NpZ25tZW50c1xuXG4vLyBTb3J0IHN0YWJpbGl0eVxuc3VwcG9ydC5zb3J0U3RhYmxlID0gZXhwYW5kby5zcGxpdChcIlwiKS5zb3J0KCBzb3J0T3JkZXIgKS5qb2luKFwiXCIpID09PSBleHBhbmRvO1xuXG4vLyBTdXBwb3J0OiBDaHJvbWUgMTQtMzUrXG4vLyBBbHdheXMgYXNzdW1lIGR1cGxpY2F0ZXMgaWYgdGhleSBhcmVuJ3QgcGFzc2VkIHRvIHRoZSBjb21wYXJpc29uIGZ1bmN0aW9uXG5zdXBwb3J0LmRldGVjdER1cGxpY2F0ZXMgPSAhIWhhc0R1cGxpY2F0ZTtcblxuLy8gSW5pdGlhbGl6ZSBhZ2FpbnN0IHRoZSBkZWZhdWx0IGRvY3VtZW50XG5zZXREb2N1bWVudCgpO1xuXG4vLyBTdXBwb3J0OiBXZWJraXQ8NTM3LjMyIC0gU2FmYXJpIDYuMC4zL0Nocm9tZSAyNSAoZml4ZWQgaW4gQ2hyb21lIDI3KVxuLy8gRGV0YWNoZWQgbm9kZXMgY29uZm91bmRpbmdseSBmb2xsb3cgKmVhY2ggb3RoZXIqXG5zdXBwb3J0LnNvcnREZXRhY2hlZCA9IGFzc2VydChmdW5jdGlvbiggZWwgKSB7XG5cdC8vIFNob3VsZCByZXR1cm4gMSwgYnV0IHJldHVybnMgNCAoZm9sbG93aW5nKVxuXHRyZXR1cm4gZWwuY29tcGFyZURvY3VtZW50UG9zaXRpb24oIGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJmaWVsZHNldFwiKSApICYgMTtcbn0pO1xuXG4vLyBTdXBwb3J0OiBJRTw4XG4vLyBQcmV2ZW50IGF0dHJpYnV0ZS9wcm9wZXJ0eSBcImludGVycG9sYXRpb25cIlxuLy8gaHR0cHM6Ly9tc2RuLm1pY3Jvc29mdC5jb20vZW4tdXMvbGlicmFyeS9tczUzNjQyOSUyOFZTLjg1JTI5LmFzcHhcbmlmICggIWFzc2VydChmdW5jdGlvbiggZWwgKSB7XG5cdGVsLmlubmVySFRNTCA9IFwiPGEgaHJlZj0nIyc+PC9hPlwiO1xuXHRyZXR1cm4gZWwuZmlyc3RDaGlsZC5nZXRBdHRyaWJ1dGUoXCJocmVmXCIpID09PSBcIiNcIiA7XG59KSApIHtcblx0YWRkSGFuZGxlKCBcInR5cGV8aHJlZnxoZWlnaHR8d2lkdGhcIiwgZnVuY3Rpb24oIGVsZW0sIG5hbWUsIGlzWE1MICkge1xuXHRcdGlmICggIWlzWE1MICkge1xuXHRcdFx0cmV0dXJuIGVsZW0uZ2V0QXR0cmlidXRlKCBuYW1lLCBuYW1lLnRvTG93ZXJDYXNlKCkgPT09IFwidHlwZVwiID8gMSA6IDIgKTtcblx0XHR9XG5cdH0pO1xufVxuXG4vLyBTdXBwb3J0OiBJRTw5XG4vLyBVc2UgZGVmYXVsdFZhbHVlIGluIHBsYWNlIG9mIGdldEF0dHJpYnV0ZShcInZhbHVlXCIpXG5pZiAoICFzdXBwb3J0LmF0dHJpYnV0ZXMgfHwgIWFzc2VydChmdW5jdGlvbiggZWwgKSB7XG5cdGVsLmlubmVySFRNTCA9IFwiPGlucHV0Lz5cIjtcblx0ZWwuZmlyc3RDaGlsZC5zZXRBdHRyaWJ1dGUoIFwidmFsdWVcIiwgXCJcIiApO1xuXHRyZXR1cm4gZWwuZmlyc3RDaGlsZC5nZXRBdHRyaWJ1dGUoIFwidmFsdWVcIiApID09PSBcIlwiO1xufSkgKSB7XG5cdGFkZEhhbmRsZSggXCJ2YWx1ZVwiLCBmdW5jdGlvbiggZWxlbSwgbmFtZSwgaXNYTUwgKSB7XG5cdFx0aWYgKCAhaXNYTUwgJiYgZWxlbS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpID09PSBcImlucHV0XCIgKSB7XG5cdFx0XHRyZXR1cm4gZWxlbS5kZWZhdWx0VmFsdWU7XG5cdFx0fVxuXHR9KTtcbn1cblxuLy8gU3VwcG9ydDogSUU8OVxuLy8gVXNlIGdldEF0dHJpYnV0ZU5vZGUgdG8gZmV0Y2ggYm9vbGVhbnMgd2hlbiBnZXRBdHRyaWJ1dGUgbGllc1xuaWYgKCAhYXNzZXJ0KGZ1bmN0aW9uKCBlbCApIHtcblx0cmV0dXJuIGVsLmdldEF0dHJpYnV0ZShcImRpc2FibGVkXCIpID09IG51bGw7XG59KSApIHtcblx0YWRkSGFuZGxlKCBib29sZWFucywgZnVuY3Rpb24oIGVsZW0sIG5hbWUsIGlzWE1MICkge1xuXHRcdHZhciB2YWw7XG5cdFx0aWYgKCAhaXNYTUwgKSB7XG5cdFx0XHRyZXR1cm4gZWxlbVsgbmFtZSBdID09PSB0cnVlID8gbmFtZS50b0xvd2VyQ2FzZSgpIDpcblx0XHRcdFx0XHQodmFsID0gZWxlbS5nZXRBdHRyaWJ1dGVOb2RlKCBuYW1lICkpICYmIHZhbC5zcGVjaWZpZWQgP1xuXHRcdFx0XHRcdHZhbC52YWx1ZSA6XG5cdFx0XHRcdG51bGw7XG5cdFx0fVxuXHR9KTtcbn1cblxucmV0dXJuIFNpenpsZTtcblxufSkoIHdpbmRvdyApO1xuXG5cblxualF1ZXJ5LmZpbmQgPSBTaXp6bGU7XG5qUXVlcnkuZXhwciA9IFNpenpsZS5zZWxlY3RvcnM7XG5cbi8vIERlcHJlY2F0ZWRcbmpRdWVyeS5leHByWyBcIjpcIiBdID0galF1ZXJ5LmV4cHIucHNldWRvcztcbmpRdWVyeS51bmlxdWVTb3J0ID0galF1ZXJ5LnVuaXF1ZSA9IFNpenpsZS51bmlxdWVTb3J0O1xualF1ZXJ5LnRleHQgPSBTaXp6bGUuZ2V0VGV4dDtcbmpRdWVyeS5pc1hNTERvYyA9IFNpenpsZS5pc1hNTDtcbmpRdWVyeS5jb250YWlucyA9IFNpenpsZS5jb250YWlucztcbmpRdWVyeS5lc2NhcGVTZWxlY3RvciA9IFNpenpsZS5lc2NhcGU7XG5cblxuXG5cbnZhciBkaXIgPSBmdW5jdGlvbiggZWxlbSwgZGlyLCB1bnRpbCApIHtcblx0dmFyIG1hdGNoZWQgPSBbXSxcblx0XHR0cnVuY2F0ZSA9IHVudGlsICE9PSB1bmRlZmluZWQ7XG5cblx0d2hpbGUgKCAoIGVsZW0gPSBlbGVtWyBkaXIgXSApICYmIGVsZW0ubm9kZVR5cGUgIT09IDkgKSB7XG5cdFx0aWYgKCBlbGVtLm5vZGVUeXBlID09PSAxICkge1xuXHRcdFx0aWYgKCB0cnVuY2F0ZSAmJiBqUXVlcnkoIGVsZW0gKS5pcyggdW50aWwgKSApIHtcblx0XHRcdFx0YnJlYWs7XG5cdFx0XHR9XG5cdFx0XHRtYXRjaGVkLnB1c2goIGVsZW0gKTtcblx0XHR9XG5cdH1cblx0cmV0dXJuIG1hdGNoZWQ7XG59O1xuXG5cbnZhciBzaWJsaW5ncyA9IGZ1bmN0aW9uKCBuLCBlbGVtICkge1xuXHR2YXIgbWF0Y2hlZCA9IFtdO1xuXG5cdGZvciAoIDsgbjsgbiA9IG4ubmV4dFNpYmxpbmcgKSB7XG5cdFx0aWYgKCBuLm5vZGVUeXBlID09PSAxICYmIG4gIT09IGVsZW0gKSB7XG5cdFx0XHRtYXRjaGVkLnB1c2goIG4gKTtcblx0XHR9XG5cdH1cblxuXHRyZXR1cm4gbWF0Y2hlZDtcbn07XG5cblxudmFyIHJuZWVkc0NvbnRleHQgPSBqUXVlcnkuZXhwci5tYXRjaC5uZWVkc0NvbnRleHQ7XG5cblxuXG5mdW5jdGlvbiBub2RlTmFtZSggZWxlbSwgbmFtZSApIHtcblxuICByZXR1cm4gZWxlbS5ub2RlTmFtZSAmJiBlbGVtLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkgPT09IG5hbWUudG9Mb3dlckNhc2UoKTtcblxufTtcbnZhciByc2luZ2xlVGFnID0gKCAvXjwoW2Etel1bXlxcL1xcMD46XFx4MjBcXHRcXHJcXG5cXGZdKilbXFx4MjBcXHRcXHJcXG5cXGZdKlxcLz8+KD86PFxcL1xcMT58KSQvaSApO1xuXG5cblxuLy8gSW1wbGVtZW50IHRoZSBpZGVudGljYWwgZnVuY3Rpb25hbGl0eSBmb3IgZmlsdGVyIGFuZCBub3RcbmZ1bmN0aW9uIHdpbm5vdyggZWxlbWVudHMsIHF1YWxpZmllciwgbm90ICkge1xuXHRpZiAoIGlzRnVuY3Rpb24oIHF1YWxpZmllciApICkge1xuXHRcdHJldHVybiBqUXVlcnkuZ3JlcCggZWxlbWVudHMsIGZ1bmN0aW9uKCBlbGVtLCBpICkge1xuXHRcdFx0cmV0dXJuICEhcXVhbGlmaWVyLmNhbGwoIGVsZW0sIGksIGVsZW0gKSAhPT0gbm90O1xuXHRcdH0gKTtcblx0fVxuXG5cdC8vIFNpbmdsZSBlbGVtZW50XG5cdGlmICggcXVhbGlmaWVyLm5vZGVUeXBlICkge1xuXHRcdHJldHVybiBqUXVlcnkuZ3JlcCggZWxlbWVudHMsIGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0cmV0dXJuICggZWxlbSA9PT0gcXVhbGlmaWVyICkgIT09IG5vdDtcblx0XHR9ICk7XG5cdH1cblxuXHQvLyBBcnJheWxpa2Ugb2YgZWxlbWVudHMgKGpRdWVyeSwgYXJndW1lbnRzLCBBcnJheSlcblx0aWYgKCB0eXBlb2YgcXVhbGlmaWVyICE9PSBcInN0cmluZ1wiICkge1xuXHRcdHJldHVybiBqUXVlcnkuZ3JlcCggZWxlbWVudHMsIGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0cmV0dXJuICggaW5kZXhPZi5jYWxsKCBxdWFsaWZpZXIsIGVsZW0gKSA+IC0xICkgIT09IG5vdDtcblx0XHR9ICk7XG5cdH1cblxuXHQvLyBGaWx0ZXJlZCBkaXJlY3RseSBmb3IgYm90aCBzaW1wbGUgYW5kIGNvbXBsZXggc2VsZWN0b3JzXG5cdHJldHVybiBqUXVlcnkuZmlsdGVyKCBxdWFsaWZpZXIsIGVsZW1lbnRzLCBub3QgKTtcbn1cblxualF1ZXJ5LmZpbHRlciA9IGZ1bmN0aW9uKCBleHByLCBlbGVtcywgbm90ICkge1xuXHR2YXIgZWxlbSA9IGVsZW1zWyAwIF07XG5cblx0aWYgKCBub3QgKSB7XG5cdFx0ZXhwciA9IFwiOm5vdChcIiArIGV4cHIgKyBcIilcIjtcblx0fVxuXG5cdGlmICggZWxlbXMubGVuZ3RoID09PSAxICYmIGVsZW0ubm9kZVR5cGUgPT09IDEgKSB7XG5cdFx0cmV0dXJuIGpRdWVyeS5maW5kLm1hdGNoZXNTZWxlY3RvciggZWxlbSwgZXhwciApID8gWyBlbGVtIF0gOiBbXTtcblx0fVxuXG5cdHJldHVybiBqUXVlcnkuZmluZC5tYXRjaGVzKCBleHByLCBqUXVlcnkuZ3JlcCggZWxlbXMsIGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdHJldHVybiBlbGVtLm5vZGVUeXBlID09PSAxO1xuXHR9ICkgKTtcbn07XG5cbmpRdWVyeS5mbi5leHRlbmQoIHtcblx0ZmluZDogZnVuY3Rpb24oIHNlbGVjdG9yICkge1xuXHRcdHZhciBpLCByZXQsXG5cdFx0XHRsZW4gPSB0aGlzLmxlbmd0aCxcblx0XHRcdHNlbGYgPSB0aGlzO1xuXG5cdFx0aWYgKCB0eXBlb2Ygc2VsZWN0b3IgIT09IFwic3RyaW5nXCIgKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5wdXNoU3RhY2soIGpRdWVyeSggc2VsZWN0b3IgKS5maWx0ZXIoIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRmb3IgKCBpID0gMDsgaSA8IGxlbjsgaSsrICkge1xuXHRcdFx0XHRcdGlmICggalF1ZXJ5LmNvbnRhaW5zKCBzZWxmWyBpIF0sIHRoaXMgKSApIHtcblx0XHRcdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fSApICk7XG5cdFx0fVxuXG5cdFx0cmV0ID0gdGhpcy5wdXNoU3RhY2soIFtdICk7XG5cblx0XHRmb3IgKCBpID0gMDsgaSA8IGxlbjsgaSsrICkge1xuXHRcdFx0alF1ZXJ5LmZpbmQoIHNlbGVjdG9yLCBzZWxmWyBpIF0sIHJldCApO1xuXHRcdH1cblxuXHRcdHJldHVybiBsZW4gPiAxID8galF1ZXJ5LnVuaXF1ZVNvcnQoIHJldCApIDogcmV0O1xuXHR9LFxuXHRmaWx0ZXI6IGZ1bmN0aW9uKCBzZWxlY3RvciApIHtcblx0XHRyZXR1cm4gdGhpcy5wdXNoU3RhY2soIHdpbm5vdyggdGhpcywgc2VsZWN0b3IgfHwgW10sIGZhbHNlICkgKTtcblx0fSxcblx0bm90OiBmdW5jdGlvbiggc2VsZWN0b3IgKSB7XG5cdFx0cmV0dXJuIHRoaXMucHVzaFN0YWNrKCB3aW5ub3coIHRoaXMsIHNlbGVjdG9yIHx8IFtdLCB0cnVlICkgKTtcblx0fSxcblx0aXM6IGZ1bmN0aW9uKCBzZWxlY3RvciApIHtcblx0XHRyZXR1cm4gISF3aW5ub3coXG5cdFx0XHR0aGlzLFxuXG5cdFx0XHQvLyBJZiB0aGlzIGlzIGEgcG9zaXRpb25hbC9yZWxhdGl2ZSBzZWxlY3RvciwgY2hlY2sgbWVtYmVyc2hpcCBpbiB0aGUgcmV0dXJuZWQgc2V0XG5cdFx0XHQvLyBzbyAkKFwicDpmaXJzdFwiKS5pcyhcInA6bGFzdFwiKSB3b24ndCByZXR1cm4gdHJ1ZSBmb3IgYSBkb2Mgd2l0aCB0d28gXCJwXCIuXG5cdFx0XHR0eXBlb2Ygc2VsZWN0b3IgPT09IFwic3RyaW5nXCIgJiYgcm5lZWRzQ29udGV4dC50ZXN0KCBzZWxlY3RvciApID9cblx0XHRcdFx0alF1ZXJ5KCBzZWxlY3RvciApIDpcblx0XHRcdFx0c2VsZWN0b3IgfHwgW10sXG5cdFx0XHRmYWxzZVxuXHRcdCkubGVuZ3RoO1xuXHR9XG59ICk7XG5cblxuLy8gSW5pdGlhbGl6ZSBhIGpRdWVyeSBvYmplY3RcblxuXG4vLyBBIGNlbnRyYWwgcmVmZXJlbmNlIHRvIHRoZSByb290IGpRdWVyeShkb2N1bWVudClcbnZhciByb290alF1ZXJ5LFxuXG5cdC8vIEEgc2ltcGxlIHdheSB0byBjaGVjayBmb3IgSFRNTCBzdHJpbmdzXG5cdC8vIFByaW9yaXRpemUgI2lkIG92ZXIgPHRhZz4gdG8gYXZvaWQgWFNTIHZpYSBsb2NhdGlvbi5oYXNoICgjOTUyMSlcblx0Ly8gU3RyaWN0IEhUTUwgcmVjb2duaXRpb24gKCMxMTI5MDogbXVzdCBzdGFydCB3aXRoIDwpXG5cdC8vIFNob3J0Y3V0IHNpbXBsZSAjaWQgY2FzZSBmb3Igc3BlZWRcblx0cnF1aWNrRXhwciA9IC9eKD86XFxzKig8W1xcd1xcV10rPilbXj5dKnwjKFtcXHctXSspKSQvLFxuXG5cdGluaXQgPSBqUXVlcnkuZm4uaW5pdCA9IGZ1bmN0aW9uKCBzZWxlY3RvciwgY29udGV4dCwgcm9vdCApIHtcblx0XHR2YXIgbWF0Y2gsIGVsZW07XG5cblx0XHQvLyBIQU5ETEU6ICQoXCJcIiksICQobnVsbCksICQodW5kZWZpbmVkKSwgJChmYWxzZSlcblx0XHRpZiAoICFzZWxlY3RvciApIHtcblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH1cblxuXHRcdC8vIE1ldGhvZCBpbml0KCkgYWNjZXB0cyBhbiBhbHRlcm5hdGUgcm9vdGpRdWVyeVxuXHRcdC8vIHNvIG1pZ3JhdGUgY2FuIHN1cHBvcnQgalF1ZXJ5LnN1YiAoZ2gtMjEwMSlcblx0XHRyb290ID0gcm9vdCB8fCByb290alF1ZXJ5O1xuXG5cdFx0Ly8gSGFuZGxlIEhUTUwgc3RyaW5nc1xuXHRcdGlmICggdHlwZW9mIHNlbGVjdG9yID09PSBcInN0cmluZ1wiICkge1xuXHRcdFx0aWYgKCBzZWxlY3RvclsgMCBdID09PSBcIjxcIiAmJlxuXHRcdFx0XHRzZWxlY3Rvclsgc2VsZWN0b3IubGVuZ3RoIC0gMSBdID09PSBcIj5cIiAmJlxuXHRcdFx0XHRzZWxlY3Rvci5sZW5ndGggPj0gMyApIHtcblxuXHRcdFx0XHQvLyBBc3N1bWUgdGhhdCBzdHJpbmdzIHRoYXQgc3RhcnQgYW5kIGVuZCB3aXRoIDw+IGFyZSBIVE1MIGFuZCBza2lwIHRoZSByZWdleCBjaGVja1xuXHRcdFx0XHRtYXRjaCA9IFsgbnVsbCwgc2VsZWN0b3IsIG51bGwgXTtcblxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0bWF0Y2ggPSBycXVpY2tFeHByLmV4ZWMoIHNlbGVjdG9yICk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIE1hdGNoIGh0bWwgb3IgbWFrZSBzdXJlIG5vIGNvbnRleHQgaXMgc3BlY2lmaWVkIGZvciAjaWRcblx0XHRcdGlmICggbWF0Y2ggJiYgKCBtYXRjaFsgMSBdIHx8ICFjb250ZXh0ICkgKSB7XG5cblx0XHRcdFx0Ly8gSEFORExFOiAkKGh0bWwpIC0+ICQoYXJyYXkpXG5cdFx0XHRcdGlmICggbWF0Y2hbIDEgXSApIHtcblx0XHRcdFx0XHRjb250ZXh0ID0gY29udGV4dCBpbnN0YW5jZW9mIGpRdWVyeSA/IGNvbnRleHRbIDAgXSA6IGNvbnRleHQ7XG5cblx0XHRcdFx0XHQvLyBPcHRpb24gdG8gcnVuIHNjcmlwdHMgaXMgdHJ1ZSBmb3IgYmFjay1jb21wYXRcblx0XHRcdFx0XHQvLyBJbnRlbnRpb25hbGx5IGxldCB0aGUgZXJyb3IgYmUgdGhyb3duIGlmIHBhcnNlSFRNTCBpcyBub3QgcHJlc2VudFxuXHRcdFx0XHRcdGpRdWVyeS5tZXJnZSggdGhpcywgalF1ZXJ5LnBhcnNlSFRNTChcblx0XHRcdFx0XHRcdG1hdGNoWyAxIF0sXG5cdFx0XHRcdFx0XHRjb250ZXh0ICYmIGNvbnRleHQubm9kZVR5cGUgPyBjb250ZXh0Lm93bmVyRG9jdW1lbnQgfHwgY29udGV4dCA6IGRvY3VtZW50LFxuXHRcdFx0XHRcdFx0dHJ1ZVxuXHRcdFx0XHRcdCkgKTtcblxuXHRcdFx0XHRcdC8vIEhBTkRMRTogJChodG1sLCBwcm9wcylcblx0XHRcdFx0XHRpZiAoIHJzaW5nbGVUYWcudGVzdCggbWF0Y2hbIDEgXSApICYmIGpRdWVyeS5pc1BsYWluT2JqZWN0KCBjb250ZXh0ICkgKSB7XG5cdFx0XHRcdFx0XHRmb3IgKCBtYXRjaCBpbiBjb250ZXh0ICkge1xuXG5cdFx0XHRcdFx0XHRcdC8vIFByb3BlcnRpZXMgb2YgY29udGV4dCBhcmUgY2FsbGVkIGFzIG1ldGhvZHMgaWYgcG9zc2libGVcblx0XHRcdFx0XHRcdFx0aWYgKCBpc0Z1bmN0aW9uKCB0aGlzWyBtYXRjaCBdICkgKSB7XG5cdFx0XHRcdFx0XHRcdFx0dGhpc1sgbWF0Y2ggXSggY29udGV4dFsgbWF0Y2ggXSApO1xuXG5cdFx0XHRcdFx0XHRcdC8vIC4uLmFuZCBvdGhlcndpc2Ugc2V0IGFzIGF0dHJpYnV0ZXNcblx0XHRcdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdFx0XHR0aGlzLmF0dHIoIG1hdGNoLCBjb250ZXh0WyBtYXRjaCBdICk7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRyZXR1cm4gdGhpcztcblxuXHRcdFx0XHQvLyBIQU5ETEU6ICQoI2lkKVxuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdGVsZW0gPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCggbWF0Y2hbIDIgXSApO1xuXG5cdFx0XHRcdFx0aWYgKCBlbGVtICkge1xuXG5cdFx0XHRcdFx0XHQvLyBJbmplY3QgdGhlIGVsZW1lbnQgZGlyZWN0bHkgaW50byB0aGUgalF1ZXJ5IG9iamVjdFxuXHRcdFx0XHRcdFx0dGhpc1sgMCBdID0gZWxlbTtcblx0XHRcdFx0XHRcdHRoaXMubGVuZ3RoID0gMTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0XHRcdH1cblxuXHRcdFx0Ly8gSEFORExFOiAkKGV4cHIsICQoLi4uKSlcblx0XHRcdH0gZWxzZSBpZiAoICFjb250ZXh0IHx8IGNvbnRleHQuanF1ZXJ5ICkge1xuXHRcdFx0XHRyZXR1cm4gKCBjb250ZXh0IHx8IHJvb3QgKS5maW5kKCBzZWxlY3RvciApO1xuXG5cdFx0XHQvLyBIQU5ETEU6ICQoZXhwciwgY29udGV4dClcblx0XHRcdC8vICh3aGljaCBpcyBqdXN0IGVxdWl2YWxlbnQgdG86ICQoY29udGV4dCkuZmluZChleHByKVxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0cmV0dXJuIHRoaXMuY29uc3RydWN0b3IoIGNvbnRleHQgKS5maW5kKCBzZWxlY3RvciApO1xuXHRcdFx0fVxuXG5cdFx0Ly8gSEFORExFOiAkKERPTUVsZW1lbnQpXG5cdFx0fSBlbHNlIGlmICggc2VsZWN0b3Iubm9kZVR5cGUgKSB7XG5cdFx0XHR0aGlzWyAwIF0gPSBzZWxlY3Rvcjtcblx0XHRcdHRoaXMubGVuZ3RoID0gMTtcblx0XHRcdHJldHVybiB0aGlzO1xuXG5cdFx0Ly8gSEFORExFOiAkKGZ1bmN0aW9uKVxuXHRcdC8vIFNob3J0Y3V0IGZvciBkb2N1bWVudCByZWFkeVxuXHRcdH0gZWxzZSBpZiAoIGlzRnVuY3Rpb24oIHNlbGVjdG9yICkgKSB7XG5cdFx0XHRyZXR1cm4gcm9vdC5yZWFkeSAhPT0gdW5kZWZpbmVkID9cblx0XHRcdFx0cm9vdC5yZWFkeSggc2VsZWN0b3IgKSA6XG5cblx0XHRcdFx0Ly8gRXhlY3V0ZSBpbW1lZGlhdGVseSBpZiByZWFkeSBpcyBub3QgcHJlc2VudFxuXHRcdFx0XHRzZWxlY3RvciggalF1ZXJ5ICk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGpRdWVyeS5tYWtlQXJyYXkoIHNlbGVjdG9yLCB0aGlzICk7XG5cdH07XG5cbi8vIEdpdmUgdGhlIGluaXQgZnVuY3Rpb24gdGhlIGpRdWVyeSBwcm90b3R5cGUgZm9yIGxhdGVyIGluc3RhbnRpYXRpb25cbmluaXQucHJvdG90eXBlID0galF1ZXJ5LmZuO1xuXG4vLyBJbml0aWFsaXplIGNlbnRyYWwgcmVmZXJlbmNlXG5yb290alF1ZXJ5ID0galF1ZXJ5KCBkb2N1bWVudCApO1xuXG5cbnZhciBycGFyZW50c3ByZXYgPSAvXig/OnBhcmVudHN8cHJldig/OlVudGlsfEFsbCkpLyxcblxuXHQvLyBNZXRob2RzIGd1YXJhbnRlZWQgdG8gcHJvZHVjZSBhIHVuaXF1ZSBzZXQgd2hlbiBzdGFydGluZyBmcm9tIGEgdW5pcXVlIHNldFxuXHRndWFyYW50ZWVkVW5pcXVlID0ge1xuXHRcdGNoaWxkcmVuOiB0cnVlLFxuXHRcdGNvbnRlbnRzOiB0cnVlLFxuXHRcdG5leHQ6IHRydWUsXG5cdFx0cHJldjogdHJ1ZVxuXHR9O1xuXG5qUXVlcnkuZm4uZXh0ZW5kKCB7XG5cdGhhczogZnVuY3Rpb24oIHRhcmdldCApIHtcblx0XHR2YXIgdGFyZ2V0cyA9IGpRdWVyeSggdGFyZ2V0LCB0aGlzICksXG5cdFx0XHRsID0gdGFyZ2V0cy5sZW5ndGg7XG5cblx0XHRyZXR1cm4gdGhpcy5maWx0ZXIoIGZ1bmN0aW9uKCkge1xuXHRcdFx0dmFyIGkgPSAwO1xuXHRcdFx0Zm9yICggOyBpIDwgbDsgaSsrICkge1xuXHRcdFx0XHRpZiAoIGpRdWVyeS5jb250YWlucyggdGhpcywgdGFyZ2V0c1sgaSBdICkgKSB7XG5cdFx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9ICk7XG5cdH0sXG5cblx0Y2xvc2VzdDogZnVuY3Rpb24oIHNlbGVjdG9ycywgY29udGV4dCApIHtcblx0XHR2YXIgY3VyLFxuXHRcdFx0aSA9IDAsXG5cdFx0XHRsID0gdGhpcy5sZW5ndGgsXG5cdFx0XHRtYXRjaGVkID0gW10sXG5cdFx0XHR0YXJnZXRzID0gdHlwZW9mIHNlbGVjdG9ycyAhPT0gXCJzdHJpbmdcIiAmJiBqUXVlcnkoIHNlbGVjdG9ycyApO1xuXG5cdFx0Ly8gUG9zaXRpb25hbCBzZWxlY3RvcnMgbmV2ZXIgbWF0Y2gsIHNpbmNlIHRoZXJlJ3Mgbm8gX3NlbGVjdGlvbl8gY29udGV4dFxuXHRcdGlmICggIXJuZWVkc0NvbnRleHQudGVzdCggc2VsZWN0b3JzICkgKSB7XG5cdFx0XHRmb3IgKCA7IGkgPCBsOyBpKysgKSB7XG5cdFx0XHRcdGZvciAoIGN1ciA9IHRoaXNbIGkgXTsgY3VyICYmIGN1ciAhPT0gY29udGV4dDsgY3VyID0gY3VyLnBhcmVudE5vZGUgKSB7XG5cblx0XHRcdFx0XHQvLyBBbHdheXMgc2tpcCBkb2N1bWVudCBmcmFnbWVudHNcblx0XHRcdFx0XHRpZiAoIGN1ci5ub2RlVHlwZSA8IDExICYmICggdGFyZ2V0cyA/XG5cdFx0XHRcdFx0XHR0YXJnZXRzLmluZGV4KCBjdXIgKSA+IC0xIDpcblxuXHRcdFx0XHRcdFx0Ly8gRG9uJ3QgcGFzcyBub24tZWxlbWVudHMgdG8gU2l6emxlXG5cdFx0XHRcdFx0XHRjdXIubm9kZVR5cGUgPT09IDEgJiZcblx0XHRcdFx0XHRcdFx0alF1ZXJ5LmZpbmQubWF0Y2hlc1NlbGVjdG9yKCBjdXIsIHNlbGVjdG9ycyApICkgKSB7XG5cblx0XHRcdFx0XHRcdG1hdGNoZWQucHVzaCggY3VyICk7XG5cdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblx0XHRyZXR1cm4gdGhpcy5wdXNoU3RhY2soIG1hdGNoZWQubGVuZ3RoID4gMSA/IGpRdWVyeS51bmlxdWVTb3J0KCBtYXRjaGVkICkgOiBtYXRjaGVkICk7XG5cdH0sXG5cblx0Ly8gRGV0ZXJtaW5lIHRoZSBwb3NpdGlvbiBvZiBhbiBlbGVtZW50IHdpdGhpbiB0aGUgc2V0XG5cdGluZGV4OiBmdW5jdGlvbiggZWxlbSApIHtcblxuXHRcdC8vIE5vIGFyZ3VtZW50LCByZXR1cm4gaW5kZXggaW4gcGFyZW50XG5cdFx0aWYgKCAhZWxlbSApIHtcblx0XHRcdHJldHVybiAoIHRoaXNbIDAgXSAmJiB0aGlzWyAwIF0ucGFyZW50Tm9kZSApID8gdGhpcy5maXJzdCgpLnByZXZBbGwoKS5sZW5ndGggOiAtMTtcblx0XHR9XG5cblx0XHQvLyBJbmRleCBpbiBzZWxlY3RvclxuXHRcdGlmICggdHlwZW9mIGVsZW0gPT09IFwic3RyaW5nXCIgKSB7XG5cdFx0XHRyZXR1cm4gaW5kZXhPZi5jYWxsKCBqUXVlcnkoIGVsZW0gKSwgdGhpc1sgMCBdICk7XG5cdFx0fVxuXG5cdFx0Ly8gTG9jYXRlIHRoZSBwb3NpdGlvbiBvZiB0aGUgZGVzaXJlZCBlbGVtZW50XG5cdFx0cmV0dXJuIGluZGV4T2YuY2FsbCggdGhpcyxcblxuXHRcdFx0Ly8gSWYgaXQgcmVjZWl2ZXMgYSBqUXVlcnkgb2JqZWN0LCB0aGUgZmlyc3QgZWxlbWVudCBpcyB1c2VkXG5cdFx0XHRlbGVtLmpxdWVyeSA/IGVsZW1bIDAgXSA6IGVsZW1cblx0XHQpO1xuXHR9LFxuXG5cdGFkZDogZnVuY3Rpb24oIHNlbGVjdG9yLCBjb250ZXh0ICkge1xuXHRcdHJldHVybiB0aGlzLnB1c2hTdGFjayhcblx0XHRcdGpRdWVyeS51bmlxdWVTb3J0KFxuXHRcdFx0XHRqUXVlcnkubWVyZ2UoIHRoaXMuZ2V0KCksIGpRdWVyeSggc2VsZWN0b3IsIGNvbnRleHQgKSApXG5cdFx0XHQpXG5cdFx0KTtcblx0fSxcblxuXHRhZGRCYWNrOiBmdW5jdGlvbiggc2VsZWN0b3IgKSB7XG5cdFx0cmV0dXJuIHRoaXMuYWRkKCBzZWxlY3RvciA9PSBudWxsID9cblx0XHRcdHRoaXMucHJldk9iamVjdCA6IHRoaXMucHJldk9iamVjdC5maWx0ZXIoIHNlbGVjdG9yIClcblx0XHQpO1xuXHR9XG59ICk7XG5cbmZ1bmN0aW9uIHNpYmxpbmcoIGN1ciwgZGlyICkge1xuXHR3aGlsZSAoICggY3VyID0gY3VyWyBkaXIgXSApICYmIGN1ci5ub2RlVHlwZSAhPT0gMSApIHt9XG5cdHJldHVybiBjdXI7XG59XG5cbmpRdWVyeS5lYWNoKCB7XG5cdHBhcmVudDogZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0dmFyIHBhcmVudCA9IGVsZW0ucGFyZW50Tm9kZTtcblx0XHRyZXR1cm4gcGFyZW50ICYmIHBhcmVudC5ub2RlVHlwZSAhPT0gMTEgPyBwYXJlbnQgOiBudWxsO1xuXHR9LFxuXHRwYXJlbnRzOiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRyZXR1cm4gZGlyKCBlbGVtLCBcInBhcmVudE5vZGVcIiApO1xuXHR9LFxuXHRwYXJlbnRzVW50aWw6IGZ1bmN0aW9uKCBlbGVtLCBpLCB1bnRpbCApIHtcblx0XHRyZXR1cm4gZGlyKCBlbGVtLCBcInBhcmVudE5vZGVcIiwgdW50aWwgKTtcblx0fSxcblx0bmV4dDogZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0cmV0dXJuIHNpYmxpbmcoIGVsZW0sIFwibmV4dFNpYmxpbmdcIiApO1xuXHR9LFxuXHRwcmV2OiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRyZXR1cm4gc2libGluZyggZWxlbSwgXCJwcmV2aW91c1NpYmxpbmdcIiApO1xuXHR9LFxuXHRuZXh0QWxsOiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRyZXR1cm4gZGlyKCBlbGVtLCBcIm5leHRTaWJsaW5nXCIgKTtcblx0fSxcblx0cHJldkFsbDogZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0cmV0dXJuIGRpciggZWxlbSwgXCJwcmV2aW91c1NpYmxpbmdcIiApO1xuXHR9LFxuXHRuZXh0VW50aWw6IGZ1bmN0aW9uKCBlbGVtLCBpLCB1bnRpbCApIHtcblx0XHRyZXR1cm4gZGlyKCBlbGVtLCBcIm5leHRTaWJsaW5nXCIsIHVudGlsICk7XG5cdH0sXG5cdHByZXZVbnRpbDogZnVuY3Rpb24oIGVsZW0sIGksIHVudGlsICkge1xuXHRcdHJldHVybiBkaXIoIGVsZW0sIFwicHJldmlvdXNTaWJsaW5nXCIsIHVudGlsICk7XG5cdH0sXG5cdHNpYmxpbmdzOiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRyZXR1cm4gc2libGluZ3MoICggZWxlbS5wYXJlbnROb2RlIHx8IHt9ICkuZmlyc3RDaGlsZCwgZWxlbSApO1xuXHR9LFxuXHRjaGlsZHJlbjogZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0cmV0dXJuIHNpYmxpbmdzKCBlbGVtLmZpcnN0Q2hpbGQgKTtcblx0fSxcblx0Y29udGVudHM6IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdGlmICggdHlwZW9mIGVsZW0uY29udGVudERvY3VtZW50ICE9PSBcInVuZGVmaW5lZFwiICkge1xuXHRcdFx0cmV0dXJuIGVsZW0uY29udGVudERvY3VtZW50O1xuXHRcdH1cblxuXHRcdC8vIFN1cHBvcnQ6IElFIDkgLSAxMSBvbmx5LCBpT1MgNyBvbmx5LCBBbmRyb2lkIEJyb3dzZXIgPD00LjMgb25seVxuXHRcdC8vIFRyZWF0IHRoZSB0ZW1wbGF0ZSBlbGVtZW50IGFzIGEgcmVndWxhciBvbmUgaW4gYnJvd3NlcnMgdGhhdFxuXHRcdC8vIGRvbid0IHN1cHBvcnQgaXQuXG5cdFx0aWYgKCBub2RlTmFtZSggZWxlbSwgXCJ0ZW1wbGF0ZVwiICkgKSB7XG5cdFx0XHRlbGVtID0gZWxlbS5jb250ZW50IHx8IGVsZW07XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGpRdWVyeS5tZXJnZSggW10sIGVsZW0uY2hpbGROb2RlcyApO1xuXHR9XG59LCBmdW5jdGlvbiggbmFtZSwgZm4gKSB7XG5cdGpRdWVyeS5mblsgbmFtZSBdID0gZnVuY3Rpb24oIHVudGlsLCBzZWxlY3RvciApIHtcblx0XHR2YXIgbWF0Y2hlZCA9IGpRdWVyeS5tYXAoIHRoaXMsIGZuLCB1bnRpbCApO1xuXG5cdFx0aWYgKCBuYW1lLnNsaWNlKCAtNSApICE9PSBcIlVudGlsXCIgKSB7XG5cdFx0XHRzZWxlY3RvciA9IHVudGlsO1xuXHRcdH1cblxuXHRcdGlmICggc2VsZWN0b3IgJiYgdHlwZW9mIHNlbGVjdG9yID09PSBcInN0cmluZ1wiICkge1xuXHRcdFx0bWF0Y2hlZCA9IGpRdWVyeS5maWx0ZXIoIHNlbGVjdG9yLCBtYXRjaGVkICk7XG5cdFx0fVxuXG5cdFx0aWYgKCB0aGlzLmxlbmd0aCA+IDEgKSB7XG5cblx0XHRcdC8vIFJlbW92ZSBkdXBsaWNhdGVzXG5cdFx0XHRpZiAoICFndWFyYW50ZWVkVW5pcXVlWyBuYW1lIF0gKSB7XG5cdFx0XHRcdGpRdWVyeS51bmlxdWVTb3J0KCBtYXRjaGVkICk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIFJldmVyc2Ugb3JkZXIgZm9yIHBhcmVudHMqIGFuZCBwcmV2LWRlcml2YXRpdmVzXG5cdFx0XHRpZiAoIHJwYXJlbnRzcHJldi50ZXN0KCBuYW1lICkgKSB7XG5cdFx0XHRcdG1hdGNoZWQucmV2ZXJzZSgpO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHJldHVybiB0aGlzLnB1c2hTdGFjayggbWF0Y2hlZCApO1xuXHR9O1xufSApO1xudmFyIHJub3RodG1sd2hpdGUgPSAoIC9bXlxceDIwXFx0XFxyXFxuXFxmXSsvZyApO1xuXG5cblxuLy8gQ29udmVydCBTdHJpbmctZm9ybWF0dGVkIG9wdGlvbnMgaW50byBPYmplY3QtZm9ybWF0dGVkIG9uZXNcbmZ1bmN0aW9uIGNyZWF0ZU9wdGlvbnMoIG9wdGlvbnMgKSB7XG5cdHZhciBvYmplY3QgPSB7fTtcblx0alF1ZXJ5LmVhY2goIG9wdGlvbnMubWF0Y2goIHJub3RodG1sd2hpdGUgKSB8fCBbXSwgZnVuY3Rpb24oIF8sIGZsYWcgKSB7XG5cdFx0b2JqZWN0WyBmbGFnIF0gPSB0cnVlO1xuXHR9ICk7XG5cdHJldHVybiBvYmplY3Q7XG59XG5cbi8qXG4gKiBDcmVhdGUgYSBjYWxsYmFjayBsaXN0IHVzaW5nIHRoZSBmb2xsb3dpbmcgcGFyYW1ldGVyczpcbiAqXG4gKlx0b3B0aW9uczogYW4gb3B0aW9uYWwgbGlzdCBvZiBzcGFjZS1zZXBhcmF0ZWQgb3B0aW9ucyB0aGF0IHdpbGwgY2hhbmdlIGhvd1xuICpcdFx0XHR0aGUgY2FsbGJhY2sgbGlzdCBiZWhhdmVzIG9yIGEgbW9yZSB0cmFkaXRpb25hbCBvcHRpb24gb2JqZWN0XG4gKlxuICogQnkgZGVmYXVsdCBhIGNhbGxiYWNrIGxpc3Qgd2lsbCBhY3QgbGlrZSBhbiBldmVudCBjYWxsYmFjayBsaXN0IGFuZCBjYW4gYmVcbiAqIFwiZmlyZWRcIiBtdWx0aXBsZSB0aW1lcy5cbiAqXG4gKiBQb3NzaWJsZSBvcHRpb25zOlxuICpcbiAqXHRvbmNlOlx0XHRcdHdpbGwgZW5zdXJlIHRoZSBjYWxsYmFjayBsaXN0IGNhbiBvbmx5IGJlIGZpcmVkIG9uY2UgKGxpa2UgYSBEZWZlcnJlZClcbiAqXG4gKlx0bWVtb3J5Olx0XHRcdHdpbGwga2VlcCB0cmFjayBvZiBwcmV2aW91cyB2YWx1ZXMgYW5kIHdpbGwgY2FsbCBhbnkgY2FsbGJhY2sgYWRkZWRcbiAqXHRcdFx0XHRcdGFmdGVyIHRoZSBsaXN0IGhhcyBiZWVuIGZpcmVkIHJpZ2h0IGF3YXkgd2l0aCB0aGUgbGF0ZXN0IFwibWVtb3JpemVkXCJcbiAqXHRcdFx0XHRcdHZhbHVlcyAobGlrZSBhIERlZmVycmVkKVxuICpcbiAqXHR1bmlxdWU6XHRcdFx0d2lsbCBlbnN1cmUgYSBjYWxsYmFjayBjYW4gb25seSBiZSBhZGRlZCBvbmNlIChubyBkdXBsaWNhdGUgaW4gdGhlIGxpc3QpXG4gKlxuICpcdHN0b3BPbkZhbHNlOlx0aW50ZXJydXB0IGNhbGxpbmdzIHdoZW4gYSBjYWxsYmFjayByZXR1cm5zIGZhbHNlXG4gKlxuICovXG5qUXVlcnkuQ2FsbGJhY2tzID0gZnVuY3Rpb24oIG9wdGlvbnMgKSB7XG5cblx0Ly8gQ29udmVydCBvcHRpb25zIGZyb20gU3RyaW5nLWZvcm1hdHRlZCB0byBPYmplY3QtZm9ybWF0dGVkIGlmIG5lZWRlZFxuXHQvLyAod2UgY2hlY2sgaW4gY2FjaGUgZmlyc3QpXG5cdG9wdGlvbnMgPSB0eXBlb2Ygb3B0aW9ucyA9PT0gXCJzdHJpbmdcIiA/XG5cdFx0Y3JlYXRlT3B0aW9ucyggb3B0aW9ucyApIDpcblx0XHRqUXVlcnkuZXh0ZW5kKCB7fSwgb3B0aW9ucyApO1xuXG5cdHZhciAvLyBGbGFnIHRvIGtub3cgaWYgbGlzdCBpcyBjdXJyZW50bHkgZmlyaW5nXG5cdFx0ZmlyaW5nLFxuXG5cdFx0Ly8gTGFzdCBmaXJlIHZhbHVlIGZvciBub24tZm9yZ2V0dGFibGUgbGlzdHNcblx0XHRtZW1vcnksXG5cblx0XHQvLyBGbGFnIHRvIGtub3cgaWYgbGlzdCB3YXMgYWxyZWFkeSBmaXJlZFxuXHRcdGZpcmVkLFxuXG5cdFx0Ly8gRmxhZyB0byBwcmV2ZW50IGZpcmluZ1xuXHRcdGxvY2tlZCxcblxuXHRcdC8vIEFjdHVhbCBjYWxsYmFjayBsaXN0XG5cdFx0bGlzdCA9IFtdLFxuXG5cdFx0Ly8gUXVldWUgb2YgZXhlY3V0aW9uIGRhdGEgZm9yIHJlcGVhdGFibGUgbGlzdHNcblx0XHRxdWV1ZSA9IFtdLFxuXG5cdFx0Ly8gSW5kZXggb2YgY3VycmVudGx5IGZpcmluZyBjYWxsYmFjayAobW9kaWZpZWQgYnkgYWRkL3JlbW92ZSBhcyBuZWVkZWQpXG5cdFx0ZmlyaW5nSW5kZXggPSAtMSxcblxuXHRcdC8vIEZpcmUgY2FsbGJhY2tzXG5cdFx0ZmlyZSA9IGZ1bmN0aW9uKCkge1xuXG5cdFx0XHQvLyBFbmZvcmNlIHNpbmdsZS1maXJpbmdcblx0XHRcdGxvY2tlZCA9IGxvY2tlZCB8fCBvcHRpb25zLm9uY2U7XG5cblx0XHRcdC8vIEV4ZWN1dGUgY2FsbGJhY2tzIGZvciBhbGwgcGVuZGluZyBleGVjdXRpb25zLFxuXHRcdFx0Ly8gcmVzcGVjdGluZyBmaXJpbmdJbmRleCBvdmVycmlkZXMgYW5kIHJ1bnRpbWUgY2hhbmdlc1xuXHRcdFx0ZmlyZWQgPSBmaXJpbmcgPSB0cnVlO1xuXHRcdFx0Zm9yICggOyBxdWV1ZS5sZW5ndGg7IGZpcmluZ0luZGV4ID0gLTEgKSB7XG5cdFx0XHRcdG1lbW9yeSA9IHF1ZXVlLnNoaWZ0KCk7XG5cdFx0XHRcdHdoaWxlICggKytmaXJpbmdJbmRleCA8IGxpc3QubGVuZ3RoICkge1xuXG5cdFx0XHRcdFx0Ly8gUnVuIGNhbGxiYWNrIGFuZCBjaGVjayBmb3IgZWFybHkgdGVybWluYXRpb25cblx0XHRcdFx0XHRpZiAoIGxpc3RbIGZpcmluZ0luZGV4IF0uYXBwbHkoIG1lbW9yeVsgMCBdLCBtZW1vcnlbIDEgXSApID09PSBmYWxzZSAmJlxuXHRcdFx0XHRcdFx0b3B0aW9ucy5zdG9wT25GYWxzZSApIHtcblxuXHRcdFx0XHRcdFx0Ly8gSnVtcCB0byBlbmQgYW5kIGZvcmdldCB0aGUgZGF0YSBzbyAuYWRkIGRvZXNuJ3QgcmUtZmlyZVxuXHRcdFx0XHRcdFx0ZmlyaW5nSW5kZXggPSBsaXN0Lmxlbmd0aDtcblx0XHRcdFx0XHRcdG1lbW9yeSA9IGZhbHNlO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHQvLyBGb3JnZXQgdGhlIGRhdGEgaWYgd2UncmUgZG9uZSB3aXRoIGl0XG5cdFx0XHRpZiAoICFvcHRpb25zLm1lbW9yeSApIHtcblx0XHRcdFx0bWVtb3J5ID0gZmFsc2U7XG5cdFx0XHR9XG5cblx0XHRcdGZpcmluZyA9IGZhbHNlO1xuXG5cdFx0XHQvLyBDbGVhbiB1cCBpZiB3ZSdyZSBkb25lIGZpcmluZyBmb3IgZ29vZFxuXHRcdFx0aWYgKCBsb2NrZWQgKSB7XG5cblx0XHRcdFx0Ly8gS2VlcCBhbiBlbXB0eSBsaXN0IGlmIHdlIGhhdmUgZGF0YSBmb3IgZnV0dXJlIGFkZCBjYWxsc1xuXHRcdFx0XHRpZiAoIG1lbW9yeSApIHtcblx0XHRcdFx0XHRsaXN0ID0gW107XG5cblx0XHRcdFx0Ly8gT3RoZXJ3aXNlLCB0aGlzIG9iamVjdCBpcyBzcGVudFxuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdGxpc3QgPSBcIlwiO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fSxcblxuXHRcdC8vIEFjdHVhbCBDYWxsYmFja3Mgb2JqZWN0XG5cdFx0c2VsZiA9IHtcblxuXHRcdFx0Ly8gQWRkIGEgY2FsbGJhY2sgb3IgYSBjb2xsZWN0aW9uIG9mIGNhbGxiYWNrcyB0byB0aGUgbGlzdFxuXHRcdFx0YWRkOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0aWYgKCBsaXN0ICkge1xuXG5cdFx0XHRcdFx0Ly8gSWYgd2UgaGF2ZSBtZW1vcnkgZnJvbSBhIHBhc3QgcnVuLCB3ZSBzaG91bGQgZmlyZSBhZnRlciBhZGRpbmdcblx0XHRcdFx0XHRpZiAoIG1lbW9yeSAmJiAhZmlyaW5nICkge1xuXHRcdFx0XHRcdFx0ZmlyaW5nSW5kZXggPSBsaXN0Lmxlbmd0aCAtIDE7XG5cdFx0XHRcdFx0XHRxdWV1ZS5wdXNoKCBtZW1vcnkgKTtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHQoIGZ1bmN0aW9uIGFkZCggYXJncyApIHtcblx0XHRcdFx0XHRcdGpRdWVyeS5lYWNoKCBhcmdzLCBmdW5jdGlvbiggXywgYXJnICkge1xuXHRcdFx0XHRcdFx0XHRpZiAoIGlzRnVuY3Rpb24oIGFyZyApICkge1xuXHRcdFx0XHRcdFx0XHRcdGlmICggIW9wdGlvbnMudW5pcXVlIHx8ICFzZWxmLmhhcyggYXJnICkgKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRsaXN0LnB1c2goIGFyZyApO1xuXHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0fSBlbHNlIGlmICggYXJnICYmIGFyZy5sZW5ndGggJiYgdG9UeXBlKCBhcmcgKSAhPT0gXCJzdHJpbmdcIiApIHtcblxuXHRcdFx0XHRcdFx0XHRcdC8vIEluc3BlY3QgcmVjdXJzaXZlbHlcblx0XHRcdFx0XHRcdFx0XHRhZGQoIGFyZyApO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9ICk7XG5cdFx0XHRcdFx0fSApKCBhcmd1bWVudHMgKTtcblxuXHRcdFx0XHRcdGlmICggbWVtb3J5ICYmICFmaXJpbmcgKSB7XG5cdFx0XHRcdFx0XHRmaXJlKCk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiB0aGlzO1xuXHRcdFx0fSxcblxuXHRcdFx0Ly8gUmVtb3ZlIGEgY2FsbGJhY2sgZnJvbSB0aGUgbGlzdFxuXHRcdFx0cmVtb3ZlOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0alF1ZXJ5LmVhY2goIGFyZ3VtZW50cywgZnVuY3Rpb24oIF8sIGFyZyApIHtcblx0XHRcdFx0XHR2YXIgaW5kZXg7XG5cdFx0XHRcdFx0d2hpbGUgKCAoIGluZGV4ID0galF1ZXJ5LmluQXJyYXkoIGFyZywgbGlzdCwgaW5kZXggKSApID4gLTEgKSB7XG5cdFx0XHRcdFx0XHRsaXN0LnNwbGljZSggaW5kZXgsIDEgKTtcblxuXHRcdFx0XHRcdFx0Ly8gSGFuZGxlIGZpcmluZyBpbmRleGVzXG5cdFx0XHRcdFx0XHRpZiAoIGluZGV4IDw9IGZpcmluZ0luZGV4ICkge1xuXHRcdFx0XHRcdFx0XHRmaXJpbmdJbmRleC0tO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSApO1xuXHRcdFx0XHRyZXR1cm4gdGhpcztcblx0XHRcdH0sXG5cblx0XHRcdC8vIENoZWNrIGlmIGEgZ2l2ZW4gY2FsbGJhY2sgaXMgaW4gdGhlIGxpc3QuXG5cdFx0XHQvLyBJZiBubyBhcmd1bWVudCBpcyBnaXZlbiwgcmV0dXJuIHdoZXRoZXIgb3Igbm90IGxpc3QgaGFzIGNhbGxiYWNrcyBhdHRhY2hlZC5cblx0XHRcdGhhczogZnVuY3Rpb24oIGZuICkge1xuXHRcdFx0XHRyZXR1cm4gZm4gP1xuXHRcdFx0XHRcdGpRdWVyeS5pbkFycmF5KCBmbiwgbGlzdCApID4gLTEgOlxuXHRcdFx0XHRcdGxpc3QubGVuZ3RoID4gMDtcblx0XHRcdH0sXG5cblx0XHRcdC8vIFJlbW92ZSBhbGwgY2FsbGJhY2tzIGZyb20gdGhlIGxpc3Rcblx0XHRcdGVtcHR5OiBmdW5jdGlvbigpIHtcblx0XHRcdFx0aWYgKCBsaXN0ICkge1xuXHRcdFx0XHRcdGxpc3QgPSBbXTtcblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gdGhpcztcblx0XHRcdH0sXG5cblx0XHRcdC8vIERpc2FibGUgLmZpcmUgYW5kIC5hZGRcblx0XHRcdC8vIEFib3J0IGFueSBjdXJyZW50L3BlbmRpbmcgZXhlY3V0aW9uc1xuXHRcdFx0Ly8gQ2xlYXIgYWxsIGNhbGxiYWNrcyBhbmQgdmFsdWVzXG5cdFx0XHRkaXNhYmxlOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0bG9ja2VkID0gcXVldWUgPSBbXTtcblx0XHRcdFx0bGlzdCA9IG1lbW9yeSA9IFwiXCI7XG5cdFx0XHRcdHJldHVybiB0aGlzO1xuXHRcdFx0fSxcblx0XHRcdGRpc2FibGVkOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0cmV0dXJuICFsaXN0O1xuXHRcdFx0fSxcblxuXHRcdFx0Ly8gRGlzYWJsZSAuZmlyZVxuXHRcdFx0Ly8gQWxzbyBkaXNhYmxlIC5hZGQgdW5sZXNzIHdlIGhhdmUgbWVtb3J5IChzaW5jZSBpdCB3b3VsZCBoYXZlIG5vIGVmZmVjdClcblx0XHRcdC8vIEFib3J0IGFueSBwZW5kaW5nIGV4ZWN1dGlvbnNcblx0XHRcdGxvY2s6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRsb2NrZWQgPSBxdWV1ZSA9IFtdO1xuXHRcdFx0XHRpZiAoICFtZW1vcnkgJiYgIWZpcmluZyApIHtcblx0XHRcdFx0XHRsaXN0ID0gbWVtb3J5ID0gXCJcIjtcblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gdGhpcztcblx0XHRcdH0sXG5cdFx0XHRsb2NrZWQ6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRyZXR1cm4gISFsb2NrZWQ7XG5cdFx0XHR9LFxuXG5cdFx0XHQvLyBDYWxsIGFsbCBjYWxsYmFja3Mgd2l0aCB0aGUgZ2l2ZW4gY29udGV4dCBhbmQgYXJndW1lbnRzXG5cdFx0XHRmaXJlV2l0aDogZnVuY3Rpb24oIGNvbnRleHQsIGFyZ3MgKSB7XG5cdFx0XHRcdGlmICggIWxvY2tlZCApIHtcblx0XHRcdFx0XHRhcmdzID0gYXJncyB8fCBbXTtcblx0XHRcdFx0XHRhcmdzID0gWyBjb250ZXh0LCBhcmdzLnNsaWNlID8gYXJncy5zbGljZSgpIDogYXJncyBdO1xuXHRcdFx0XHRcdHF1ZXVlLnB1c2goIGFyZ3MgKTtcblx0XHRcdFx0XHRpZiAoICFmaXJpbmcgKSB7XG5cdFx0XHRcdFx0XHRmaXJlKCk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiB0aGlzO1xuXHRcdFx0fSxcblxuXHRcdFx0Ly8gQ2FsbCBhbGwgdGhlIGNhbGxiYWNrcyB3aXRoIHRoZSBnaXZlbiBhcmd1bWVudHNcblx0XHRcdGZpcmU6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRzZWxmLmZpcmVXaXRoKCB0aGlzLCBhcmd1bWVudHMgKTtcblx0XHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0XHR9LFxuXG5cdFx0XHQvLyBUbyBrbm93IGlmIHRoZSBjYWxsYmFja3MgaGF2ZSBhbHJlYWR5IGJlZW4gY2FsbGVkIGF0IGxlYXN0IG9uY2Vcblx0XHRcdGZpcmVkOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0cmV0dXJuICEhZmlyZWQ7XG5cdFx0XHR9XG5cdFx0fTtcblxuXHRyZXR1cm4gc2VsZjtcbn07XG5cblxuZnVuY3Rpb24gSWRlbnRpdHkoIHYgKSB7XG5cdHJldHVybiB2O1xufVxuZnVuY3Rpb24gVGhyb3dlciggZXggKSB7XG5cdHRocm93IGV4O1xufVxuXG5mdW5jdGlvbiBhZG9wdFZhbHVlKCB2YWx1ZSwgcmVzb2x2ZSwgcmVqZWN0LCBub1ZhbHVlICkge1xuXHR2YXIgbWV0aG9kO1xuXG5cdHRyeSB7XG5cblx0XHQvLyBDaGVjayBmb3IgcHJvbWlzZSBhc3BlY3QgZmlyc3QgdG8gcHJpdmlsZWdlIHN5bmNocm9ub3VzIGJlaGF2aW9yXG5cdFx0aWYgKCB2YWx1ZSAmJiBpc0Z1bmN0aW9uKCAoIG1ldGhvZCA9IHZhbHVlLnByb21pc2UgKSApICkge1xuXHRcdFx0bWV0aG9kLmNhbGwoIHZhbHVlICkuZG9uZSggcmVzb2x2ZSApLmZhaWwoIHJlamVjdCApO1xuXG5cdFx0Ly8gT3RoZXIgdGhlbmFibGVzXG5cdFx0fSBlbHNlIGlmICggdmFsdWUgJiYgaXNGdW5jdGlvbiggKCBtZXRob2QgPSB2YWx1ZS50aGVuICkgKSApIHtcblx0XHRcdG1ldGhvZC5jYWxsKCB2YWx1ZSwgcmVzb2x2ZSwgcmVqZWN0ICk7XG5cblx0XHQvLyBPdGhlciBub24tdGhlbmFibGVzXG5cdFx0fSBlbHNlIHtcblxuXHRcdFx0Ly8gQ29udHJvbCBgcmVzb2x2ZWAgYXJndW1lbnRzIGJ5IGxldHRpbmcgQXJyYXkjc2xpY2UgY2FzdCBib29sZWFuIGBub1ZhbHVlYCB0byBpbnRlZ2VyOlxuXHRcdFx0Ly8gKiBmYWxzZTogWyB2YWx1ZSBdLnNsaWNlKCAwICkgPT4gcmVzb2x2ZSggdmFsdWUgKVxuXHRcdFx0Ly8gKiB0cnVlOiBbIHZhbHVlIF0uc2xpY2UoIDEgKSA9PiByZXNvbHZlKClcblx0XHRcdHJlc29sdmUuYXBwbHkoIHVuZGVmaW5lZCwgWyB2YWx1ZSBdLnNsaWNlKCBub1ZhbHVlICkgKTtcblx0XHR9XG5cblx0Ly8gRm9yIFByb21pc2VzL0ErLCBjb252ZXJ0IGV4Y2VwdGlvbnMgaW50byByZWplY3Rpb25zXG5cdC8vIFNpbmNlIGpRdWVyeS53aGVuIGRvZXNuJ3QgdW53cmFwIHRoZW5hYmxlcywgd2UgY2FuIHNraXAgdGhlIGV4dHJhIGNoZWNrcyBhcHBlYXJpbmcgaW5cblx0Ly8gRGVmZXJyZWQjdGhlbiB0byBjb25kaXRpb25hbGx5IHN1cHByZXNzIHJlamVjdGlvbi5cblx0fSBjYXRjaCAoIHZhbHVlICkge1xuXG5cdFx0Ly8gU3VwcG9ydDogQW5kcm9pZCA0LjAgb25seVxuXHRcdC8vIFN0cmljdCBtb2RlIGZ1bmN0aW9ucyBpbnZva2VkIHdpdGhvdXQgLmNhbGwvLmFwcGx5IGdldCBnbG9iYWwtb2JqZWN0IGNvbnRleHRcblx0XHRyZWplY3QuYXBwbHkoIHVuZGVmaW5lZCwgWyB2YWx1ZSBdICk7XG5cdH1cbn1cblxualF1ZXJ5LmV4dGVuZCgge1xuXG5cdERlZmVycmVkOiBmdW5jdGlvbiggZnVuYyApIHtcblx0XHR2YXIgdHVwbGVzID0gW1xuXG5cdFx0XHRcdC8vIGFjdGlvbiwgYWRkIGxpc3RlbmVyLCBjYWxsYmFja3MsXG5cdFx0XHRcdC8vIC4uLiAudGhlbiBoYW5kbGVycywgYXJndW1lbnQgaW5kZXgsIFtmaW5hbCBzdGF0ZV1cblx0XHRcdFx0WyBcIm5vdGlmeVwiLCBcInByb2dyZXNzXCIsIGpRdWVyeS5DYWxsYmFja3MoIFwibWVtb3J5XCIgKSxcblx0XHRcdFx0XHRqUXVlcnkuQ2FsbGJhY2tzKCBcIm1lbW9yeVwiICksIDIgXSxcblx0XHRcdFx0WyBcInJlc29sdmVcIiwgXCJkb25lXCIsIGpRdWVyeS5DYWxsYmFja3MoIFwib25jZSBtZW1vcnlcIiApLFxuXHRcdFx0XHRcdGpRdWVyeS5DYWxsYmFja3MoIFwib25jZSBtZW1vcnlcIiApLCAwLCBcInJlc29sdmVkXCIgXSxcblx0XHRcdFx0WyBcInJlamVjdFwiLCBcImZhaWxcIiwgalF1ZXJ5LkNhbGxiYWNrcyggXCJvbmNlIG1lbW9yeVwiICksXG5cdFx0XHRcdFx0alF1ZXJ5LkNhbGxiYWNrcyggXCJvbmNlIG1lbW9yeVwiICksIDEsIFwicmVqZWN0ZWRcIiBdXG5cdFx0XHRdLFxuXHRcdFx0c3RhdGUgPSBcInBlbmRpbmdcIixcblx0XHRcdHByb21pc2UgPSB7XG5cdFx0XHRcdHN0YXRlOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRyZXR1cm4gc3RhdGU7XG5cdFx0XHRcdH0sXG5cdFx0XHRcdGFsd2F5czogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0ZGVmZXJyZWQuZG9uZSggYXJndW1lbnRzICkuZmFpbCggYXJndW1lbnRzICk7XG5cdFx0XHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0XHRcdH0sXG5cdFx0XHRcdFwiY2F0Y2hcIjogZnVuY3Rpb24oIGZuICkge1xuXHRcdFx0XHRcdHJldHVybiBwcm9taXNlLnRoZW4oIG51bGwsIGZuICk7XG5cdFx0XHRcdH0sXG5cblx0XHRcdFx0Ly8gS2VlcCBwaXBlIGZvciBiYWNrLWNvbXBhdFxuXHRcdFx0XHRwaXBlOiBmdW5jdGlvbiggLyogZm5Eb25lLCBmbkZhaWwsIGZuUHJvZ3Jlc3MgKi8gKSB7XG5cdFx0XHRcdFx0dmFyIGZucyA9IGFyZ3VtZW50cztcblxuXHRcdFx0XHRcdHJldHVybiBqUXVlcnkuRGVmZXJyZWQoIGZ1bmN0aW9uKCBuZXdEZWZlciApIHtcblx0XHRcdFx0XHRcdGpRdWVyeS5lYWNoKCB0dXBsZXMsIGZ1bmN0aW9uKCBpLCB0dXBsZSApIHtcblxuXHRcdFx0XHRcdFx0XHQvLyBNYXAgdHVwbGVzIChwcm9ncmVzcywgZG9uZSwgZmFpbCkgdG8gYXJndW1lbnRzIChkb25lLCBmYWlsLCBwcm9ncmVzcylcblx0XHRcdFx0XHRcdFx0dmFyIGZuID0gaXNGdW5jdGlvbiggZm5zWyB0dXBsZVsgNCBdIF0gKSAmJiBmbnNbIHR1cGxlWyA0IF0gXTtcblxuXHRcdFx0XHRcdFx0XHQvLyBkZWZlcnJlZC5wcm9ncmVzcyhmdW5jdGlvbigpIHsgYmluZCB0byBuZXdEZWZlciBvciBuZXdEZWZlci5ub3RpZnkgfSlcblx0XHRcdFx0XHRcdFx0Ly8gZGVmZXJyZWQuZG9uZShmdW5jdGlvbigpIHsgYmluZCB0byBuZXdEZWZlciBvciBuZXdEZWZlci5yZXNvbHZlIH0pXG5cdFx0XHRcdFx0XHRcdC8vIGRlZmVycmVkLmZhaWwoZnVuY3Rpb24oKSB7IGJpbmQgdG8gbmV3RGVmZXIgb3IgbmV3RGVmZXIucmVqZWN0IH0pXG5cdFx0XHRcdFx0XHRcdGRlZmVycmVkWyB0dXBsZVsgMSBdIF0oIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdFx0XHRcdHZhciByZXR1cm5lZCA9IGZuICYmIGZuLmFwcGx5KCB0aGlzLCBhcmd1bWVudHMgKTtcblx0XHRcdFx0XHRcdFx0XHRpZiAoIHJldHVybmVkICYmIGlzRnVuY3Rpb24oIHJldHVybmVkLnByb21pc2UgKSApIHtcblx0XHRcdFx0XHRcdFx0XHRcdHJldHVybmVkLnByb21pc2UoKVxuXHRcdFx0XHRcdFx0XHRcdFx0XHQucHJvZ3Jlc3MoIG5ld0RlZmVyLm5vdGlmeSApXG5cdFx0XHRcdFx0XHRcdFx0XHRcdC5kb25lKCBuZXdEZWZlci5yZXNvbHZlIClcblx0XHRcdFx0XHRcdFx0XHRcdFx0LmZhaWwoIG5ld0RlZmVyLnJlamVjdCApO1xuXHRcdFx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRuZXdEZWZlclsgdHVwbGVbIDAgXSArIFwiV2l0aFwiIF0oXG5cdFx0XHRcdFx0XHRcdFx0XHRcdHRoaXMsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdGZuID8gWyByZXR1cm5lZCBdIDogYXJndW1lbnRzXG5cdFx0XHRcdFx0XHRcdFx0XHQpO1xuXHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0fSApO1xuXHRcdFx0XHRcdFx0fSApO1xuXHRcdFx0XHRcdFx0Zm5zID0gbnVsbDtcblx0XHRcdFx0XHR9ICkucHJvbWlzZSgpO1xuXHRcdFx0XHR9LFxuXHRcdFx0XHR0aGVuOiBmdW5jdGlvbiggb25GdWxmaWxsZWQsIG9uUmVqZWN0ZWQsIG9uUHJvZ3Jlc3MgKSB7XG5cdFx0XHRcdFx0dmFyIG1heERlcHRoID0gMDtcblx0XHRcdFx0XHRmdW5jdGlvbiByZXNvbHZlKCBkZXB0aCwgZGVmZXJyZWQsIGhhbmRsZXIsIHNwZWNpYWwgKSB7XG5cdFx0XHRcdFx0XHRyZXR1cm4gZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0XHRcdHZhciB0aGF0ID0gdGhpcyxcblx0XHRcdFx0XHRcdFx0XHRhcmdzID0gYXJndW1lbnRzLFxuXHRcdFx0XHRcdFx0XHRcdG1pZ2h0VGhyb3cgPSBmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRcdFx0XHRcdHZhciByZXR1cm5lZCwgdGhlbjtcblxuXHRcdFx0XHRcdFx0XHRcdFx0Ly8gU3VwcG9ydDogUHJvbWlzZXMvQSsgc2VjdGlvbiAyLjMuMy4zLjNcblx0XHRcdFx0XHRcdFx0XHRcdC8vIGh0dHBzOi8vcHJvbWlzZXNhcGx1cy5jb20vI3BvaW50LTU5XG5cdFx0XHRcdFx0XHRcdFx0XHQvLyBJZ25vcmUgZG91YmxlLXJlc29sdXRpb24gYXR0ZW1wdHNcblx0XHRcdFx0XHRcdFx0XHRcdGlmICggZGVwdGggPCBtYXhEZXB0aCApIHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRcdFx0XHRyZXR1cm5lZCA9IGhhbmRsZXIuYXBwbHkoIHRoYXQsIGFyZ3MgKTtcblxuXHRcdFx0XHRcdFx0XHRcdFx0Ly8gU3VwcG9ydDogUHJvbWlzZXMvQSsgc2VjdGlvbiAyLjMuMVxuXHRcdFx0XHRcdFx0XHRcdFx0Ly8gaHR0cHM6Ly9wcm9taXNlc2FwbHVzLmNvbS8jcG9pbnQtNDhcblx0XHRcdFx0XHRcdFx0XHRcdGlmICggcmV0dXJuZWQgPT09IGRlZmVycmVkLnByb21pc2UoKSApIHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0dGhyb3cgbmV3IFR5cGVFcnJvciggXCJUaGVuYWJsZSBzZWxmLXJlc29sdXRpb25cIiApO1xuXHRcdFx0XHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRcdFx0XHQvLyBTdXBwb3J0OiBQcm9taXNlcy9BKyBzZWN0aW9ucyAyLjMuMy4xLCAzLjVcblx0XHRcdFx0XHRcdFx0XHRcdC8vIGh0dHBzOi8vcHJvbWlzZXNhcGx1cy5jb20vI3BvaW50LTU0XG5cdFx0XHRcdFx0XHRcdFx0XHQvLyBodHRwczovL3Byb21pc2VzYXBsdXMuY29tLyNwb2ludC03NVxuXHRcdFx0XHRcdFx0XHRcdFx0Ly8gUmV0cmlldmUgYHRoZW5gIG9ubHkgb25jZVxuXHRcdFx0XHRcdFx0XHRcdFx0dGhlbiA9IHJldHVybmVkICYmXG5cblx0XHRcdFx0XHRcdFx0XHRcdFx0Ly8gU3VwcG9ydDogUHJvbWlzZXMvQSsgc2VjdGlvbiAyLjMuNFxuXHRcdFx0XHRcdFx0XHRcdFx0XHQvLyBodHRwczovL3Byb21pc2VzYXBsdXMuY29tLyNwb2ludC02NFxuXHRcdFx0XHRcdFx0XHRcdFx0XHQvLyBPbmx5IGNoZWNrIG9iamVjdHMgYW5kIGZ1bmN0aW9ucyBmb3IgdGhlbmFiaWxpdHlcblx0XHRcdFx0XHRcdFx0XHRcdFx0KCB0eXBlb2YgcmV0dXJuZWQgPT09IFwib2JqZWN0XCIgfHxcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHR0eXBlb2YgcmV0dXJuZWQgPT09IFwiZnVuY3Rpb25cIiApICYmXG5cdFx0XHRcdFx0XHRcdFx0XHRcdHJldHVybmVkLnRoZW47XG5cblx0XHRcdFx0XHRcdFx0XHRcdC8vIEhhbmRsZSBhIHJldHVybmVkIHRoZW5hYmxlXG5cdFx0XHRcdFx0XHRcdFx0XHRpZiAoIGlzRnVuY3Rpb24oIHRoZW4gKSApIHtcblxuXHRcdFx0XHRcdFx0XHRcdFx0XHQvLyBTcGVjaWFsIHByb2Nlc3NvcnMgKG5vdGlmeSkganVzdCB3YWl0IGZvciByZXNvbHV0aW9uXG5cdFx0XHRcdFx0XHRcdFx0XHRcdGlmICggc3BlY2lhbCApIHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHR0aGVuLmNhbGwoXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRyZXR1cm5lZCxcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdHJlc29sdmUoIG1heERlcHRoLCBkZWZlcnJlZCwgSWRlbnRpdHksIHNwZWNpYWwgKSxcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdHJlc29sdmUoIG1heERlcHRoLCBkZWZlcnJlZCwgVGhyb3dlciwgc3BlY2lhbCApXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0KTtcblxuXHRcdFx0XHRcdFx0XHRcdFx0XHQvLyBOb3JtYWwgcHJvY2Vzc29ycyAocmVzb2x2ZSkgYWxzbyBob29rIGludG8gcHJvZ3Jlc3Ncblx0XHRcdFx0XHRcdFx0XHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdC8vIC4uLmFuZCBkaXNyZWdhcmQgb2xkZXIgcmVzb2x1dGlvbiB2YWx1ZXNcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRtYXhEZXB0aCsrO1xuXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0dGhlbi5jYWxsKFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0cmV0dXJuZWQsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRyZXNvbHZlKCBtYXhEZXB0aCwgZGVmZXJyZWQsIElkZW50aXR5LCBzcGVjaWFsICksXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRyZXNvbHZlKCBtYXhEZXB0aCwgZGVmZXJyZWQsIFRocm93ZXIsIHNwZWNpYWwgKSxcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdHJlc29sdmUoIG1heERlcHRoLCBkZWZlcnJlZCwgSWRlbnRpdHksXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdGRlZmVycmVkLm5vdGlmeVdpdGggKVxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdCk7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0XHRcdFx0Ly8gSGFuZGxlIGFsbCBvdGhlciByZXR1cm5lZCB2YWx1ZXNcblx0XHRcdFx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHRcdFx0XHRcdFx0Ly8gT25seSBzdWJzdGl0dXRlIGhhbmRsZXJzIHBhc3Mgb24gY29udGV4dFxuXHRcdFx0XHRcdFx0XHRcdFx0XHQvLyBhbmQgbXVsdGlwbGUgdmFsdWVzIChub24tc3BlYyBiZWhhdmlvcilcblx0XHRcdFx0XHRcdFx0XHRcdFx0aWYgKCBoYW5kbGVyICE9PSBJZGVudGl0eSApIHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHR0aGF0ID0gdW5kZWZpbmVkO1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdGFyZ3MgPSBbIHJldHVybmVkIF07XG5cdFx0XHRcdFx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0XHRcdFx0XHQvLyBQcm9jZXNzIHRoZSB2YWx1ZShzKVxuXHRcdFx0XHRcdFx0XHRcdFx0XHQvLyBEZWZhdWx0IHByb2Nlc3MgaXMgcmVzb2x2ZVxuXHRcdFx0XHRcdFx0XHRcdFx0XHQoIHNwZWNpYWwgfHwgZGVmZXJyZWQucmVzb2x2ZVdpdGggKSggdGhhdCwgYXJncyApO1xuXHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdH0sXG5cblx0XHRcdFx0XHRcdFx0XHQvLyBPbmx5IG5vcm1hbCBwcm9jZXNzb3JzIChyZXNvbHZlKSBjYXRjaCBhbmQgcmVqZWN0IGV4Y2VwdGlvbnNcblx0XHRcdFx0XHRcdFx0XHRwcm9jZXNzID0gc3BlY2lhbCA/XG5cdFx0XHRcdFx0XHRcdFx0XHRtaWdodFRocm93IDpcblx0XHRcdFx0XHRcdFx0XHRcdGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR0cnkge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdG1pZ2h0VGhyb3coKTtcblx0XHRcdFx0XHRcdFx0XHRcdFx0fSBjYXRjaCAoIGUgKSB7XG5cblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRpZiAoIGpRdWVyeS5EZWZlcnJlZC5leGNlcHRpb25Ib29rICkge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0alF1ZXJ5LkRlZmVycmVkLmV4Y2VwdGlvbkhvb2soIGUsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdHByb2Nlc3Muc3RhY2tUcmFjZSApO1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdC8vIFN1cHBvcnQ6IFByb21pc2VzL0ErIHNlY3Rpb24gMi4zLjMuMy40LjFcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHQvLyBodHRwczovL3Byb21pc2VzYXBsdXMuY29tLyNwb2ludC02MVxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdC8vIElnbm9yZSBwb3N0LXJlc29sdXRpb24gZXhjZXB0aW9uc1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdGlmICggZGVwdGggKyAxID49IG1heERlcHRoICkge1xuXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHQvLyBPbmx5IHN1YnN0aXR1dGUgaGFuZGxlcnMgcGFzcyBvbiBjb250ZXh0XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHQvLyBhbmQgbXVsdGlwbGUgdmFsdWVzIChub24tc3BlYyBiZWhhdmlvcilcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdGlmICggaGFuZGxlciAhPT0gVGhyb3dlciApIHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0dGhhdCA9IHVuZGVmaW5lZDtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0YXJncyA9IFsgZSBdO1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRkZWZlcnJlZC5yZWplY3RXaXRoKCB0aGF0LCBhcmdzICk7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0XHR9O1xuXG5cdFx0XHRcdFx0XHRcdC8vIFN1cHBvcnQ6IFByb21pc2VzL0ErIHNlY3Rpb24gMi4zLjMuMy4xXG5cdFx0XHRcdFx0XHRcdC8vIGh0dHBzOi8vcHJvbWlzZXNhcGx1cy5jb20vI3BvaW50LTU3XG5cdFx0XHRcdFx0XHRcdC8vIFJlLXJlc29sdmUgcHJvbWlzZXMgaW1tZWRpYXRlbHkgdG8gZG9kZ2UgZmFsc2UgcmVqZWN0aW9uIGZyb21cblx0XHRcdFx0XHRcdFx0Ly8gc3Vic2VxdWVudCBlcnJvcnNcblx0XHRcdFx0XHRcdFx0aWYgKCBkZXB0aCApIHtcblx0XHRcdFx0XHRcdFx0XHRwcm9jZXNzKCk7XG5cdFx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHRcdFx0XHQvLyBDYWxsIGFuIG9wdGlvbmFsIGhvb2sgdG8gcmVjb3JkIHRoZSBzdGFjaywgaW4gY2FzZSBvZiBleGNlcHRpb25cblx0XHRcdFx0XHRcdFx0XHQvLyBzaW5jZSBpdCdzIG90aGVyd2lzZSBsb3N0IHdoZW4gZXhlY3V0aW9uIGdvZXMgYXN5bmNcblx0XHRcdFx0XHRcdFx0XHRpZiAoIGpRdWVyeS5EZWZlcnJlZC5nZXRTdGFja0hvb2sgKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRwcm9jZXNzLnN0YWNrVHJhY2UgPSBqUXVlcnkuRGVmZXJyZWQuZ2V0U3RhY2tIb29rKCk7XG5cdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdHdpbmRvdy5zZXRUaW1lb3V0KCBwcm9jZXNzICk7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH07XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0cmV0dXJuIGpRdWVyeS5EZWZlcnJlZCggZnVuY3Rpb24oIG5ld0RlZmVyICkge1xuXG5cdFx0XHRcdFx0XHQvLyBwcm9ncmVzc19oYW5kbGVycy5hZGQoIC4uLiApXG5cdFx0XHRcdFx0XHR0dXBsZXNbIDAgXVsgMyBdLmFkZChcblx0XHRcdFx0XHRcdFx0cmVzb2x2ZShcblx0XHRcdFx0XHRcdFx0XHQwLFxuXHRcdFx0XHRcdFx0XHRcdG5ld0RlZmVyLFxuXHRcdFx0XHRcdFx0XHRcdGlzRnVuY3Rpb24oIG9uUHJvZ3Jlc3MgKSA/XG5cdFx0XHRcdFx0XHRcdFx0XHRvblByb2dyZXNzIDpcblx0XHRcdFx0XHRcdFx0XHRcdElkZW50aXR5LFxuXHRcdFx0XHRcdFx0XHRcdG5ld0RlZmVyLm5vdGlmeVdpdGhcblx0XHRcdFx0XHRcdFx0KVxuXHRcdFx0XHRcdFx0KTtcblxuXHRcdFx0XHRcdFx0Ly8gZnVsZmlsbGVkX2hhbmRsZXJzLmFkZCggLi4uIClcblx0XHRcdFx0XHRcdHR1cGxlc1sgMSBdWyAzIF0uYWRkKFxuXHRcdFx0XHRcdFx0XHRyZXNvbHZlKFxuXHRcdFx0XHRcdFx0XHRcdDAsXG5cdFx0XHRcdFx0XHRcdFx0bmV3RGVmZXIsXG5cdFx0XHRcdFx0XHRcdFx0aXNGdW5jdGlvbiggb25GdWxmaWxsZWQgKSA/XG5cdFx0XHRcdFx0XHRcdFx0XHRvbkZ1bGZpbGxlZCA6XG5cdFx0XHRcdFx0XHRcdFx0XHRJZGVudGl0eVxuXHRcdFx0XHRcdFx0XHQpXG5cdFx0XHRcdFx0XHQpO1xuXG5cdFx0XHRcdFx0XHQvLyByZWplY3RlZF9oYW5kbGVycy5hZGQoIC4uLiApXG5cdFx0XHRcdFx0XHR0dXBsZXNbIDIgXVsgMyBdLmFkZChcblx0XHRcdFx0XHRcdFx0cmVzb2x2ZShcblx0XHRcdFx0XHRcdFx0XHQwLFxuXHRcdFx0XHRcdFx0XHRcdG5ld0RlZmVyLFxuXHRcdFx0XHRcdFx0XHRcdGlzRnVuY3Rpb24oIG9uUmVqZWN0ZWQgKSA/XG5cdFx0XHRcdFx0XHRcdFx0XHRvblJlamVjdGVkIDpcblx0XHRcdFx0XHRcdFx0XHRcdFRocm93ZXJcblx0XHRcdFx0XHRcdFx0KVxuXHRcdFx0XHRcdFx0KTtcblx0XHRcdFx0XHR9ICkucHJvbWlzZSgpO1xuXHRcdFx0XHR9LFxuXG5cdFx0XHRcdC8vIEdldCBhIHByb21pc2UgZm9yIHRoaXMgZGVmZXJyZWRcblx0XHRcdFx0Ly8gSWYgb2JqIGlzIHByb3ZpZGVkLCB0aGUgcHJvbWlzZSBhc3BlY3QgaXMgYWRkZWQgdG8gdGhlIG9iamVjdFxuXHRcdFx0XHRwcm9taXNlOiBmdW5jdGlvbiggb2JqICkge1xuXHRcdFx0XHRcdHJldHVybiBvYmogIT0gbnVsbCA/IGpRdWVyeS5leHRlbmQoIG9iaiwgcHJvbWlzZSApIDogcHJvbWlzZTtcblx0XHRcdFx0fVxuXHRcdFx0fSxcblx0XHRcdGRlZmVycmVkID0ge307XG5cblx0XHQvLyBBZGQgbGlzdC1zcGVjaWZpYyBtZXRob2RzXG5cdFx0alF1ZXJ5LmVhY2goIHR1cGxlcywgZnVuY3Rpb24oIGksIHR1cGxlICkge1xuXHRcdFx0dmFyIGxpc3QgPSB0dXBsZVsgMiBdLFxuXHRcdFx0XHRzdGF0ZVN0cmluZyA9IHR1cGxlWyA1IF07XG5cblx0XHRcdC8vIHByb21pc2UucHJvZ3Jlc3MgPSBsaXN0LmFkZFxuXHRcdFx0Ly8gcHJvbWlzZS5kb25lID0gbGlzdC5hZGRcblx0XHRcdC8vIHByb21pc2UuZmFpbCA9IGxpc3QuYWRkXG5cdFx0XHRwcm9taXNlWyB0dXBsZVsgMSBdIF0gPSBsaXN0LmFkZDtcblxuXHRcdFx0Ly8gSGFuZGxlIHN0YXRlXG5cdFx0XHRpZiAoIHN0YXRlU3RyaW5nICkge1xuXHRcdFx0XHRsaXN0LmFkZChcblx0XHRcdFx0XHRmdW5jdGlvbigpIHtcblxuXHRcdFx0XHRcdFx0Ly8gc3RhdGUgPSBcInJlc29sdmVkXCIgKGkuZS4sIGZ1bGZpbGxlZClcblx0XHRcdFx0XHRcdC8vIHN0YXRlID0gXCJyZWplY3RlZFwiXG5cdFx0XHRcdFx0XHRzdGF0ZSA9IHN0YXRlU3RyaW5nO1xuXHRcdFx0XHRcdH0sXG5cblx0XHRcdFx0XHQvLyByZWplY3RlZF9jYWxsYmFja3MuZGlzYWJsZVxuXHRcdFx0XHRcdC8vIGZ1bGZpbGxlZF9jYWxsYmFja3MuZGlzYWJsZVxuXHRcdFx0XHRcdHR1cGxlc1sgMyAtIGkgXVsgMiBdLmRpc2FibGUsXG5cblx0XHRcdFx0XHQvLyByZWplY3RlZF9oYW5kbGVycy5kaXNhYmxlXG5cdFx0XHRcdFx0Ly8gZnVsZmlsbGVkX2hhbmRsZXJzLmRpc2FibGVcblx0XHRcdFx0XHR0dXBsZXNbIDMgLSBpIF1bIDMgXS5kaXNhYmxlLFxuXG5cdFx0XHRcdFx0Ly8gcHJvZ3Jlc3NfY2FsbGJhY2tzLmxvY2tcblx0XHRcdFx0XHR0dXBsZXNbIDAgXVsgMiBdLmxvY2ssXG5cblx0XHRcdFx0XHQvLyBwcm9ncmVzc19oYW5kbGVycy5sb2NrXG5cdFx0XHRcdFx0dHVwbGVzWyAwIF1bIDMgXS5sb2NrXG5cdFx0XHRcdCk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIHByb2dyZXNzX2hhbmRsZXJzLmZpcmVcblx0XHRcdC8vIGZ1bGZpbGxlZF9oYW5kbGVycy5maXJlXG5cdFx0XHQvLyByZWplY3RlZF9oYW5kbGVycy5maXJlXG5cdFx0XHRsaXN0LmFkZCggdHVwbGVbIDMgXS5maXJlICk7XG5cblx0XHRcdC8vIGRlZmVycmVkLm5vdGlmeSA9IGZ1bmN0aW9uKCkgeyBkZWZlcnJlZC5ub3RpZnlXaXRoKC4uLikgfVxuXHRcdFx0Ly8gZGVmZXJyZWQucmVzb2x2ZSA9IGZ1bmN0aW9uKCkgeyBkZWZlcnJlZC5yZXNvbHZlV2l0aCguLi4pIH1cblx0XHRcdC8vIGRlZmVycmVkLnJlamVjdCA9IGZ1bmN0aW9uKCkgeyBkZWZlcnJlZC5yZWplY3RXaXRoKC4uLikgfVxuXHRcdFx0ZGVmZXJyZWRbIHR1cGxlWyAwIF0gXSA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRkZWZlcnJlZFsgdHVwbGVbIDAgXSArIFwiV2l0aFwiIF0oIHRoaXMgPT09IGRlZmVycmVkID8gdW5kZWZpbmVkIDogdGhpcywgYXJndW1lbnRzICk7XG5cdFx0XHRcdHJldHVybiB0aGlzO1xuXHRcdFx0fTtcblxuXHRcdFx0Ly8gZGVmZXJyZWQubm90aWZ5V2l0aCA9IGxpc3QuZmlyZVdpdGhcblx0XHRcdC8vIGRlZmVycmVkLnJlc29sdmVXaXRoID0gbGlzdC5maXJlV2l0aFxuXHRcdFx0Ly8gZGVmZXJyZWQucmVqZWN0V2l0aCA9IGxpc3QuZmlyZVdpdGhcblx0XHRcdGRlZmVycmVkWyB0dXBsZVsgMCBdICsgXCJXaXRoXCIgXSA9IGxpc3QuZmlyZVdpdGg7XG5cdFx0fSApO1xuXG5cdFx0Ly8gTWFrZSB0aGUgZGVmZXJyZWQgYSBwcm9taXNlXG5cdFx0cHJvbWlzZS5wcm9taXNlKCBkZWZlcnJlZCApO1xuXG5cdFx0Ly8gQ2FsbCBnaXZlbiBmdW5jIGlmIGFueVxuXHRcdGlmICggZnVuYyApIHtcblx0XHRcdGZ1bmMuY2FsbCggZGVmZXJyZWQsIGRlZmVycmVkICk7XG5cdFx0fVxuXG5cdFx0Ly8gQWxsIGRvbmUhXG5cdFx0cmV0dXJuIGRlZmVycmVkO1xuXHR9LFxuXG5cdC8vIERlZmVycmVkIGhlbHBlclxuXHR3aGVuOiBmdW5jdGlvbiggc2luZ2xlVmFsdWUgKSB7XG5cdFx0dmFyXG5cblx0XHRcdC8vIGNvdW50IG9mIHVuY29tcGxldGVkIHN1Ym9yZGluYXRlc1xuXHRcdFx0cmVtYWluaW5nID0gYXJndW1lbnRzLmxlbmd0aCxcblxuXHRcdFx0Ly8gY291bnQgb2YgdW5wcm9jZXNzZWQgYXJndW1lbnRzXG5cdFx0XHRpID0gcmVtYWluaW5nLFxuXG5cdFx0XHQvLyBzdWJvcmRpbmF0ZSBmdWxmaWxsbWVudCBkYXRhXG5cdFx0XHRyZXNvbHZlQ29udGV4dHMgPSBBcnJheSggaSApLFxuXHRcdFx0cmVzb2x2ZVZhbHVlcyA9IHNsaWNlLmNhbGwoIGFyZ3VtZW50cyApLFxuXG5cdFx0XHQvLyB0aGUgbWFzdGVyIERlZmVycmVkXG5cdFx0XHRtYXN0ZXIgPSBqUXVlcnkuRGVmZXJyZWQoKSxcblxuXHRcdFx0Ly8gc3Vib3JkaW5hdGUgY2FsbGJhY2sgZmFjdG9yeVxuXHRcdFx0dXBkYXRlRnVuYyA9IGZ1bmN0aW9uKCBpICkge1xuXHRcdFx0XHRyZXR1cm4gZnVuY3Rpb24oIHZhbHVlICkge1xuXHRcdFx0XHRcdHJlc29sdmVDb250ZXh0c1sgaSBdID0gdGhpcztcblx0XHRcdFx0XHRyZXNvbHZlVmFsdWVzWyBpIF0gPSBhcmd1bWVudHMubGVuZ3RoID4gMSA/IHNsaWNlLmNhbGwoIGFyZ3VtZW50cyApIDogdmFsdWU7XG5cdFx0XHRcdFx0aWYgKCAhKCAtLXJlbWFpbmluZyApICkge1xuXHRcdFx0XHRcdFx0bWFzdGVyLnJlc29sdmVXaXRoKCByZXNvbHZlQ29udGV4dHMsIHJlc29sdmVWYWx1ZXMgKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH07XG5cdFx0XHR9O1xuXG5cdFx0Ly8gU2luZ2xlLSBhbmQgZW1wdHkgYXJndW1lbnRzIGFyZSBhZG9wdGVkIGxpa2UgUHJvbWlzZS5yZXNvbHZlXG5cdFx0aWYgKCByZW1haW5pbmcgPD0gMSApIHtcblx0XHRcdGFkb3B0VmFsdWUoIHNpbmdsZVZhbHVlLCBtYXN0ZXIuZG9uZSggdXBkYXRlRnVuYyggaSApICkucmVzb2x2ZSwgbWFzdGVyLnJlamVjdCxcblx0XHRcdFx0IXJlbWFpbmluZyApO1xuXG5cdFx0XHQvLyBVc2UgLnRoZW4oKSB0byB1bndyYXAgc2Vjb25kYXJ5IHRoZW5hYmxlcyAoY2YuIGdoLTMwMDApXG5cdFx0XHRpZiAoIG1hc3Rlci5zdGF0ZSgpID09PSBcInBlbmRpbmdcIiB8fFxuXHRcdFx0XHRpc0Z1bmN0aW9uKCByZXNvbHZlVmFsdWVzWyBpIF0gJiYgcmVzb2x2ZVZhbHVlc1sgaSBdLnRoZW4gKSApIHtcblxuXHRcdFx0XHRyZXR1cm4gbWFzdGVyLnRoZW4oKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyBNdWx0aXBsZSBhcmd1bWVudHMgYXJlIGFnZ3JlZ2F0ZWQgbGlrZSBQcm9taXNlLmFsbCBhcnJheSBlbGVtZW50c1xuXHRcdHdoaWxlICggaS0tICkge1xuXHRcdFx0YWRvcHRWYWx1ZSggcmVzb2x2ZVZhbHVlc1sgaSBdLCB1cGRhdGVGdW5jKCBpICksIG1hc3Rlci5yZWplY3QgKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gbWFzdGVyLnByb21pc2UoKTtcblx0fVxufSApO1xuXG5cbi8vIFRoZXNlIHVzdWFsbHkgaW5kaWNhdGUgYSBwcm9ncmFtbWVyIG1pc3Rha2UgZHVyaW5nIGRldmVsb3BtZW50LFxuLy8gd2FybiBhYm91dCB0aGVtIEFTQVAgcmF0aGVyIHRoYW4gc3dhbGxvd2luZyB0aGVtIGJ5IGRlZmF1bHQuXG52YXIgcmVycm9yTmFtZXMgPSAvXihFdmFsfEludGVybmFsfFJhbmdlfFJlZmVyZW5jZXxTeW50YXh8VHlwZXxVUkkpRXJyb3IkLztcblxualF1ZXJ5LkRlZmVycmVkLmV4Y2VwdGlvbkhvb2sgPSBmdW5jdGlvbiggZXJyb3IsIHN0YWNrICkge1xuXG5cdC8vIFN1cHBvcnQ6IElFIDggLSA5IG9ubHlcblx0Ly8gQ29uc29sZSBleGlzdHMgd2hlbiBkZXYgdG9vbHMgYXJlIG9wZW4sIHdoaWNoIGNhbiBoYXBwZW4gYXQgYW55IHRpbWVcblx0aWYgKCB3aW5kb3cuY29uc29sZSAmJiB3aW5kb3cuY29uc29sZS53YXJuICYmIGVycm9yICYmIHJlcnJvck5hbWVzLnRlc3QoIGVycm9yLm5hbWUgKSApIHtcblx0XHR3aW5kb3cuY29uc29sZS53YXJuKCBcImpRdWVyeS5EZWZlcnJlZCBleGNlcHRpb246IFwiICsgZXJyb3IubWVzc2FnZSwgZXJyb3Iuc3RhY2ssIHN0YWNrICk7XG5cdH1cbn07XG5cblxuXG5cbmpRdWVyeS5yZWFkeUV4Y2VwdGlvbiA9IGZ1bmN0aW9uKCBlcnJvciApIHtcblx0d2luZG93LnNldFRpbWVvdXQoIGZ1bmN0aW9uKCkge1xuXHRcdHRocm93IGVycm9yO1xuXHR9ICk7XG59O1xuXG5cblxuXG4vLyBUaGUgZGVmZXJyZWQgdXNlZCBvbiBET00gcmVhZHlcbnZhciByZWFkeUxpc3QgPSBqUXVlcnkuRGVmZXJyZWQoKTtcblxualF1ZXJ5LmZuLnJlYWR5ID0gZnVuY3Rpb24oIGZuICkge1xuXG5cdHJlYWR5TGlzdFxuXHRcdC50aGVuKCBmbiApXG5cblx0XHQvLyBXcmFwIGpRdWVyeS5yZWFkeUV4Y2VwdGlvbiBpbiBhIGZ1bmN0aW9uIHNvIHRoYXQgdGhlIGxvb2t1cFxuXHRcdC8vIGhhcHBlbnMgYXQgdGhlIHRpbWUgb2YgZXJyb3IgaGFuZGxpbmcgaW5zdGVhZCBvZiBjYWxsYmFja1xuXHRcdC8vIHJlZ2lzdHJhdGlvbi5cblx0XHQuY2F0Y2goIGZ1bmN0aW9uKCBlcnJvciApIHtcblx0XHRcdGpRdWVyeS5yZWFkeUV4Y2VwdGlvbiggZXJyb3IgKTtcblx0XHR9ICk7XG5cblx0cmV0dXJuIHRoaXM7XG59O1xuXG5qUXVlcnkuZXh0ZW5kKCB7XG5cblx0Ly8gSXMgdGhlIERPTSByZWFkeSB0byBiZSB1c2VkPyBTZXQgdG8gdHJ1ZSBvbmNlIGl0IG9jY3Vycy5cblx0aXNSZWFkeTogZmFsc2UsXG5cblx0Ly8gQSBjb3VudGVyIHRvIHRyYWNrIGhvdyBtYW55IGl0ZW1zIHRvIHdhaXQgZm9yIGJlZm9yZVxuXHQvLyB0aGUgcmVhZHkgZXZlbnQgZmlyZXMuIFNlZSAjNjc4MVxuXHRyZWFkeVdhaXQ6IDEsXG5cblx0Ly8gSGFuZGxlIHdoZW4gdGhlIERPTSBpcyByZWFkeVxuXHRyZWFkeTogZnVuY3Rpb24oIHdhaXQgKSB7XG5cblx0XHQvLyBBYm9ydCBpZiB0aGVyZSBhcmUgcGVuZGluZyBob2xkcyBvciB3ZSdyZSBhbHJlYWR5IHJlYWR5XG5cdFx0aWYgKCB3YWl0ID09PSB0cnVlID8gLS1qUXVlcnkucmVhZHlXYWl0IDogalF1ZXJ5LmlzUmVhZHkgKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0Ly8gUmVtZW1iZXIgdGhhdCB0aGUgRE9NIGlzIHJlYWR5XG5cdFx0alF1ZXJ5LmlzUmVhZHkgPSB0cnVlO1xuXG5cdFx0Ly8gSWYgYSBub3JtYWwgRE9NIFJlYWR5IGV2ZW50IGZpcmVkLCBkZWNyZW1lbnQsIGFuZCB3YWl0IGlmIG5lZWQgYmVcblx0XHRpZiAoIHdhaXQgIT09IHRydWUgJiYgLS1qUXVlcnkucmVhZHlXYWl0ID4gMCApIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHQvLyBJZiB0aGVyZSBhcmUgZnVuY3Rpb25zIGJvdW5kLCB0byBleGVjdXRlXG5cdFx0cmVhZHlMaXN0LnJlc29sdmVXaXRoKCBkb2N1bWVudCwgWyBqUXVlcnkgXSApO1xuXHR9XG59ICk7XG5cbmpRdWVyeS5yZWFkeS50aGVuID0gcmVhZHlMaXN0LnRoZW47XG5cbi8vIFRoZSByZWFkeSBldmVudCBoYW5kbGVyIGFuZCBzZWxmIGNsZWFudXAgbWV0aG9kXG5mdW5jdGlvbiBjb21wbGV0ZWQoKSB7XG5cdGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoIFwiRE9NQ29udGVudExvYWRlZFwiLCBjb21wbGV0ZWQgKTtcblx0d2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoIFwibG9hZFwiLCBjb21wbGV0ZWQgKTtcblx0alF1ZXJ5LnJlYWR5KCk7XG59XG5cbi8vIENhdGNoIGNhc2VzIHdoZXJlICQoZG9jdW1lbnQpLnJlYWR5KCkgaXMgY2FsbGVkXG4vLyBhZnRlciB0aGUgYnJvd3NlciBldmVudCBoYXMgYWxyZWFkeSBvY2N1cnJlZC5cbi8vIFN1cHBvcnQ6IElFIDw9OSAtIDEwIG9ubHlcbi8vIE9sZGVyIElFIHNvbWV0aW1lcyBzaWduYWxzIFwiaW50ZXJhY3RpdmVcIiB0b28gc29vblxuaWYgKCBkb2N1bWVudC5yZWFkeVN0YXRlID09PSBcImNvbXBsZXRlXCIgfHxcblx0KCBkb2N1bWVudC5yZWFkeVN0YXRlICE9PSBcImxvYWRpbmdcIiAmJiAhZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmRvU2Nyb2xsICkgKSB7XG5cblx0Ly8gSGFuZGxlIGl0IGFzeW5jaHJvbm91c2x5IHRvIGFsbG93IHNjcmlwdHMgdGhlIG9wcG9ydHVuaXR5IHRvIGRlbGF5IHJlYWR5XG5cdHdpbmRvdy5zZXRUaW1lb3V0KCBqUXVlcnkucmVhZHkgKTtcblxufSBlbHNlIHtcblxuXHQvLyBVc2UgdGhlIGhhbmR5IGV2ZW50IGNhbGxiYWNrXG5cdGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoIFwiRE9NQ29udGVudExvYWRlZFwiLCBjb21wbGV0ZWQgKTtcblxuXHQvLyBBIGZhbGxiYWNrIHRvIHdpbmRvdy5vbmxvYWQsIHRoYXQgd2lsbCBhbHdheXMgd29ya1xuXHR3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lciggXCJsb2FkXCIsIGNvbXBsZXRlZCApO1xufVxuXG5cblxuXG4vLyBNdWx0aWZ1bmN0aW9uYWwgbWV0aG9kIHRvIGdldCBhbmQgc2V0IHZhbHVlcyBvZiBhIGNvbGxlY3Rpb25cbi8vIFRoZSB2YWx1ZS9zIGNhbiBvcHRpb25hbGx5IGJlIGV4ZWN1dGVkIGlmIGl0J3MgYSBmdW5jdGlvblxudmFyIGFjY2VzcyA9IGZ1bmN0aW9uKCBlbGVtcywgZm4sIGtleSwgdmFsdWUsIGNoYWluYWJsZSwgZW1wdHlHZXQsIHJhdyApIHtcblx0dmFyIGkgPSAwLFxuXHRcdGxlbiA9IGVsZW1zLmxlbmd0aCxcblx0XHRidWxrID0ga2V5ID09IG51bGw7XG5cblx0Ly8gU2V0cyBtYW55IHZhbHVlc1xuXHRpZiAoIHRvVHlwZSgga2V5ICkgPT09IFwib2JqZWN0XCIgKSB7XG5cdFx0Y2hhaW5hYmxlID0gdHJ1ZTtcblx0XHRmb3IgKCBpIGluIGtleSApIHtcblx0XHRcdGFjY2VzcyggZWxlbXMsIGZuLCBpLCBrZXlbIGkgXSwgdHJ1ZSwgZW1wdHlHZXQsIHJhdyApO1xuXHRcdH1cblxuXHQvLyBTZXRzIG9uZSB2YWx1ZVxuXHR9IGVsc2UgaWYgKCB2YWx1ZSAhPT0gdW5kZWZpbmVkICkge1xuXHRcdGNoYWluYWJsZSA9IHRydWU7XG5cblx0XHRpZiAoICFpc0Z1bmN0aW9uKCB2YWx1ZSApICkge1xuXHRcdFx0cmF3ID0gdHJ1ZTtcblx0XHR9XG5cblx0XHRpZiAoIGJ1bGsgKSB7XG5cblx0XHRcdC8vIEJ1bGsgb3BlcmF0aW9ucyBydW4gYWdhaW5zdCB0aGUgZW50aXJlIHNldFxuXHRcdFx0aWYgKCByYXcgKSB7XG5cdFx0XHRcdGZuLmNhbGwoIGVsZW1zLCB2YWx1ZSApO1xuXHRcdFx0XHRmbiA9IG51bGw7XG5cblx0XHRcdC8vIC4uLmV4Y2VwdCB3aGVuIGV4ZWN1dGluZyBmdW5jdGlvbiB2YWx1ZXNcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGJ1bGsgPSBmbjtcblx0XHRcdFx0Zm4gPSBmdW5jdGlvbiggZWxlbSwga2V5LCB2YWx1ZSApIHtcblx0XHRcdFx0XHRyZXR1cm4gYnVsay5jYWxsKCBqUXVlcnkoIGVsZW0gKSwgdmFsdWUgKTtcblx0XHRcdFx0fTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRpZiAoIGZuICkge1xuXHRcdFx0Zm9yICggOyBpIDwgbGVuOyBpKysgKSB7XG5cdFx0XHRcdGZuKFxuXHRcdFx0XHRcdGVsZW1zWyBpIF0sIGtleSwgcmF3ID9cblx0XHRcdFx0XHR2YWx1ZSA6XG5cdFx0XHRcdFx0dmFsdWUuY2FsbCggZWxlbXNbIGkgXSwgaSwgZm4oIGVsZW1zWyBpIF0sIGtleSApIClcblx0XHRcdFx0KTtcblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHRpZiAoIGNoYWluYWJsZSApIHtcblx0XHRyZXR1cm4gZWxlbXM7XG5cdH1cblxuXHQvLyBHZXRzXG5cdGlmICggYnVsayApIHtcblx0XHRyZXR1cm4gZm4uY2FsbCggZWxlbXMgKTtcblx0fVxuXG5cdHJldHVybiBsZW4gPyBmbiggZWxlbXNbIDAgXSwga2V5ICkgOiBlbXB0eUdldDtcbn07XG5cblxuLy8gTWF0Y2hlcyBkYXNoZWQgc3RyaW5nIGZvciBjYW1lbGl6aW5nXG52YXIgcm1zUHJlZml4ID0gL14tbXMtLyxcblx0cmRhc2hBbHBoYSA9IC8tKFthLXpdKS9nO1xuXG4vLyBVc2VkIGJ5IGNhbWVsQ2FzZSBhcyBjYWxsYmFjayB0byByZXBsYWNlKClcbmZ1bmN0aW9uIGZjYW1lbENhc2UoIGFsbCwgbGV0dGVyICkge1xuXHRyZXR1cm4gbGV0dGVyLnRvVXBwZXJDYXNlKCk7XG59XG5cbi8vIENvbnZlcnQgZGFzaGVkIHRvIGNhbWVsQ2FzZTsgdXNlZCBieSB0aGUgY3NzIGFuZCBkYXRhIG1vZHVsZXNcbi8vIFN1cHBvcnQ6IElFIDw9OSAtIDExLCBFZGdlIDEyIC0gMTVcbi8vIE1pY3Jvc29mdCBmb3Jnb3QgdG8gaHVtcCB0aGVpciB2ZW5kb3IgcHJlZml4ICgjOTU3MilcbmZ1bmN0aW9uIGNhbWVsQ2FzZSggc3RyaW5nICkge1xuXHRyZXR1cm4gc3RyaW5nLnJlcGxhY2UoIHJtc1ByZWZpeCwgXCJtcy1cIiApLnJlcGxhY2UoIHJkYXNoQWxwaGEsIGZjYW1lbENhc2UgKTtcbn1cbnZhciBhY2NlcHREYXRhID0gZnVuY3Rpb24oIG93bmVyICkge1xuXG5cdC8vIEFjY2VwdHMgb25seTpcblx0Ly8gIC0gTm9kZVxuXHQvLyAgICAtIE5vZGUuRUxFTUVOVF9OT0RFXG5cdC8vICAgIC0gTm9kZS5ET0NVTUVOVF9OT0RFXG5cdC8vICAtIE9iamVjdFxuXHQvLyAgICAtIEFueVxuXHRyZXR1cm4gb3duZXIubm9kZVR5cGUgPT09IDEgfHwgb3duZXIubm9kZVR5cGUgPT09IDkgfHwgISggK293bmVyLm5vZGVUeXBlICk7XG59O1xuXG5cblxuXG5mdW5jdGlvbiBEYXRhKCkge1xuXHR0aGlzLmV4cGFuZG8gPSBqUXVlcnkuZXhwYW5kbyArIERhdGEudWlkKys7XG59XG5cbkRhdGEudWlkID0gMTtcblxuRGF0YS5wcm90b3R5cGUgPSB7XG5cblx0Y2FjaGU6IGZ1bmN0aW9uKCBvd25lciApIHtcblxuXHRcdC8vIENoZWNrIGlmIHRoZSBvd25lciBvYmplY3QgYWxyZWFkeSBoYXMgYSBjYWNoZVxuXHRcdHZhciB2YWx1ZSA9IG93bmVyWyB0aGlzLmV4cGFuZG8gXTtcblxuXHRcdC8vIElmIG5vdCwgY3JlYXRlIG9uZVxuXHRcdGlmICggIXZhbHVlICkge1xuXHRcdFx0dmFsdWUgPSB7fTtcblxuXHRcdFx0Ly8gV2UgY2FuIGFjY2VwdCBkYXRhIGZvciBub24tZWxlbWVudCBub2RlcyBpbiBtb2Rlcm4gYnJvd3NlcnMsXG5cdFx0XHQvLyBidXQgd2Ugc2hvdWxkIG5vdCwgc2VlICM4MzM1LlxuXHRcdFx0Ly8gQWx3YXlzIHJldHVybiBhbiBlbXB0eSBvYmplY3QuXG5cdFx0XHRpZiAoIGFjY2VwdERhdGEoIG93bmVyICkgKSB7XG5cblx0XHRcdFx0Ly8gSWYgaXQgaXMgYSBub2RlIHVubGlrZWx5IHRvIGJlIHN0cmluZ2lmeS1lZCBvciBsb29wZWQgb3ZlclxuXHRcdFx0XHQvLyB1c2UgcGxhaW4gYXNzaWdubWVudFxuXHRcdFx0XHRpZiAoIG93bmVyLm5vZGVUeXBlICkge1xuXHRcdFx0XHRcdG93bmVyWyB0aGlzLmV4cGFuZG8gXSA9IHZhbHVlO1xuXG5cdFx0XHRcdC8vIE90aGVyd2lzZSBzZWN1cmUgaXQgaW4gYSBub24tZW51bWVyYWJsZSBwcm9wZXJ0eVxuXHRcdFx0XHQvLyBjb25maWd1cmFibGUgbXVzdCBiZSB0cnVlIHRvIGFsbG93IHRoZSBwcm9wZXJ0eSB0byBiZVxuXHRcdFx0XHQvLyBkZWxldGVkIHdoZW4gZGF0YSBpcyByZW1vdmVkXG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KCBvd25lciwgdGhpcy5leHBhbmRvLCB7XG5cdFx0XHRcdFx0XHR2YWx1ZTogdmFsdWUsXG5cdFx0XHRcdFx0XHRjb25maWd1cmFibGU6IHRydWVcblx0XHRcdFx0XHR9ICk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblx0XHRyZXR1cm4gdmFsdWU7XG5cdH0sXG5cdHNldDogZnVuY3Rpb24oIG93bmVyLCBkYXRhLCB2YWx1ZSApIHtcblx0XHR2YXIgcHJvcCxcblx0XHRcdGNhY2hlID0gdGhpcy5jYWNoZSggb3duZXIgKTtcblxuXHRcdC8vIEhhbmRsZTogWyBvd25lciwga2V5LCB2YWx1ZSBdIGFyZ3Ncblx0XHQvLyBBbHdheXMgdXNlIGNhbWVsQ2FzZSBrZXkgKGdoLTIyNTcpXG5cdFx0aWYgKCB0eXBlb2YgZGF0YSA9PT0gXCJzdHJpbmdcIiApIHtcblx0XHRcdGNhY2hlWyBjYW1lbENhc2UoIGRhdGEgKSBdID0gdmFsdWU7XG5cblx0XHQvLyBIYW5kbGU6IFsgb3duZXIsIHsgcHJvcGVydGllcyB9IF0gYXJnc1xuXHRcdH0gZWxzZSB7XG5cblx0XHRcdC8vIENvcHkgdGhlIHByb3BlcnRpZXMgb25lLWJ5LW9uZSB0byB0aGUgY2FjaGUgb2JqZWN0XG5cdFx0XHRmb3IgKCBwcm9wIGluIGRhdGEgKSB7XG5cdFx0XHRcdGNhY2hlWyBjYW1lbENhc2UoIHByb3AgKSBdID0gZGF0YVsgcHJvcCBdO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRyZXR1cm4gY2FjaGU7XG5cdH0sXG5cdGdldDogZnVuY3Rpb24oIG93bmVyLCBrZXkgKSB7XG5cdFx0cmV0dXJuIGtleSA9PT0gdW5kZWZpbmVkID9cblx0XHRcdHRoaXMuY2FjaGUoIG93bmVyICkgOlxuXG5cdFx0XHQvLyBBbHdheXMgdXNlIGNhbWVsQ2FzZSBrZXkgKGdoLTIyNTcpXG5cdFx0XHRvd25lclsgdGhpcy5leHBhbmRvIF0gJiYgb3duZXJbIHRoaXMuZXhwYW5kbyBdWyBjYW1lbENhc2UoIGtleSApIF07XG5cdH0sXG5cdGFjY2VzczogZnVuY3Rpb24oIG93bmVyLCBrZXksIHZhbHVlICkge1xuXG5cdFx0Ly8gSW4gY2FzZXMgd2hlcmUgZWl0aGVyOlxuXHRcdC8vXG5cdFx0Ly8gICAxLiBObyBrZXkgd2FzIHNwZWNpZmllZFxuXHRcdC8vICAgMi4gQSBzdHJpbmcga2V5IHdhcyBzcGVjaWZpZWQsIGJ1dCBubyB2YWx1ZSBwcm92aWRlZFxuXHRcdC8vXG5cdFx0Ly8gVGFrZSB0aGUgXCJyZWFkXCIgcGF0aCBhbmQgYWxsb3cgdGhlIGdldCBtZXRob2QgdG8gZGV0ZXJtaW5lXG5cdFx0Ly8gd2hpY2ggdmFsdWUgdG8gcmV0dXJuLCByZXNwZWN0aXZlbHkgZWl0aGVyOlxuXHRcdC8vXG5cdFx0Ly8gICAxLiBUaGUgZW50aXJlIGNhY2hlIG9iamVjdFxuXHRcdC8vICAgMi4gVGhlIGRhdGEgc3RvcmVkIGF0IHRoZSBrZXlcblx0XHQvL1xuXHRcdGlmICgga2V5ID09PSB1bmRlZmluZWQgfHxcblx0XHRcdFx0KCAoIGtleSAmJiB0eXBlb2Yga2V5ID09PSBcInN0cmluZ1wiICkgJiYgdmFsdWUgPT09IHVuZGVmaW5lZCApICkge1xuXG5cdFx0XHRyZXR1cm4gdGhpcy5nZXQoIG93bmVyLCBrZXkgKTtcblx0XHR9XG5cblx0XHQvLyBXaGVuIHRoZSBrZXkgaXMgbm90IGEgc3RyaW5nLCBvciBib3RoIGEga2V5IGFuZCB2YWx1ZVxuXHRcdC8vIGFyZSBzcGVjaWZpZWQsIHNldCBvciBleHRlbmQgKGV4aXN0aW5nIG9iamVjdHMpIHdpdGggZWl0aGVyOlxuXHRcdC8vXG5cdFx0Ly8gICAxLiBBbiBvYmplY3Qgb2YgcHJvcGVydGllc1xuXHRcdC8vICAgMi4gQSBrZXkgYW5kIHZhbHVlXG5cdFx0Ly9cblx0XHR0aGlzLnNldCggb3duZXIsIGtleSwgdmFsdWUgKTtcblxuXHRcdC8vIFNpbmNlIHRoZSBcInNldFwiIHBhdGggY2FuIGhhdmUgdHdvIHBvc3NpYmxlIGVudHJ5IHBvaW50c1xuXHRcdC8vIHJldHVybiB0aGUgZXhwZWN0ZWQgZGF0YSBiYXNlZCBvbiB3aGljaCBwYXRoIHdhcyB0YWtlblsqXVxuXHRcdHJldHVybiB2YWx1ZSAhPT0gdW5kZWZpbmVkID8gdmFsdWUgOiBrZXk7XG5cdH0sXG5cdHJlbW92ZTogZnVuY3Rpb24oIG93bmVyLCBrZXkgKSB7XG5cdFx0dmFyIGksXG5cdFx0XHRjYWNoZSA9IG93bmVyWyB0aGlzLmV4cGFuZG8gXTtcblxuXHRcdGlmICggY2FjaGUgPT09IHVuZGVmaW5lZCApIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHRpZiAoIGtleSAhPT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHQvLyBTdXBwb3J0IGFycmF5IG9yIHNwYWNlIHNlcGFyYXRlZCBzdHJpbmcgb2Yga2V5c1xuXHRcdFx0aWYgKCBBcnJheS5pc0FycmF5KCBrZXkgKSApIHtcblxuXHRcdFx0XHQvLyBJZiBrZXkgaXMgYW4gYXJyYXkgb2Yga2V5cy4uLlxuXHRcdFx0XHQvLyBXZSBhbHdheXMgc2V0IGNhbWVsQ2FzZSBrZXlzLCBzbyByZW1vdmUgdGhhdC5cblx0XHRcdFx0a2V5ID0ga2V5Lm1hcCggY2FtZWxDYXNlICk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRrZXkgPSBjYW1lbENhc2UoIGtleSApO1xuXG5cdFx0XHRcdC8vIElmIGEga2V5IHdpdGggdGhlIHNwYWNlcyBleGlzdHMsIHVzZSBpdC5cblx0XHRcdFx0Ly8gT3RoZXJ3aXNlLCBjcmVhdGUgYW4gYXJyYXkgYnkgbWF0Y2hpbmcgbm9uLXdoaXRlc3BhY2Vcblx0XHRcdFx0a2V5ID0ga2V5IGluIGNhY2hlID9cblx0XHRcdFx0XHRbIGtleSBdIDpcblx0XHRcdFx0XHQoIGtleS5tYXRjaCggcm5vdGh0bWx3aGl0ZSApIHx8IFtdICk7XG5cdFx0XHR9XG5cblx0XHRcdGkgPSBrZXkubGVuZ3RoO1xuXG5cdFx0XHR3aGlsZSAoIGktLSApIHtcblx0XHRcdFx0ZGVsZXRlIGNhY2hlWyBrZXlbIGkgXSBdO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIFJlbW92ZSB0aGUgZXhwYW5kbyBpZiB0aGVyZSdzIG5vIG1vcmUgZGF0YVxuXHRcdGlmICgga2V5ID09PSB1bmRlZmluZWQgfHwgalF1ZXJ5LmlzRW1wdHlPYmplY3QoIGNhY2hlICkgKSB7XG5cblx0XHRcdC8vIFN1cHBvcnQ6IENocm9tZSA8PTM1IC0gNDVcblx0XHRcdC8vIFdlYmtpdCAmIEJsaW5rIHBlcmZvcm1hbmNlIHN1ZmZlcnMgd2hlbiBkZWxldGluZyBwcm9wZXJ0aWVzXG5cdFx0XHQvLyBmcm9tIERPTSBub2Rlcywgc28gc2V0IHRvIHVuZGVmaW5lZCBpbnN0ZWFkXG5cdFx0XHQvLyBodHRwczovL2J1Z3MuY2hyb21pdW0ub3JnL3AvY2hyb21pdW0vaXNzdWVzL2RldGFpbD9pZD0zNzg2MDcgKGJ1ZyByZXN0cmljdGVkKVxuXHRcdFx0aWYgKCBvd25lci5ub2RlVHlwZSApIHtcblx0XHRcdFx0b3duZXJbIHRoaXMuZXhwYW5kbyBdID0gdW5kZWZpbmVkO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0ZGVsZXRlIG93bmVyWyB0aGlzLmV4cGFuZG8gXTtcblx0XHRcdH1cblx0XHR9XG5cdH0sXG5cdGhhc0RhdGE6IGZ1bmN0aW9uKCBvd25lciApIHtcblx0XHR2YXIgY2FjaGUgPSBvd25lclsgdGhpcy5leHBhbmRvIF07XG5cdFx0cmV0dXJuIGNhY2hlICE9PSB1bmRlZmluZWQgJiYgIWpRdWVyeS5pc0VtcHR5T2JqZWN0KCBjYWNoZSApO1xuXHR9XG59O1xudmFyIGRhdGFQcml2ID0gbmV3IERhdGEoKTtcblxudmFyIGRhdGFVc2VyID0gbmV3IERhdGEoKTtcblxuXG5cbi8vXHRJbXBsZW1lbnRhdGlvbiBTdW1tYXJ5XG4vL1xuLy9cdDEuIEVuZm9yY2UgQVBJIHN1cmZhY2UgYW5kIHNlbWFudGljIGNvbXBhdGliaWxpdHkgd2l0aCAxLjkueCBicmFuY2hcbi8vXHQyLiBJbXByb3ZlIHRoZSBtb2R1bGUncyBtYWludGFpbmFiaWxpdHkgYnkgcmVkdWNpbmcgdGhlIHN0b3JhZ2Vcbi8vXHRcdHBhdGhzIHRvIGEgc2luZ2xlIG1lY2hhbmlzbS5cbi8vXHQzLiBVc2UgdGhlIHNhbWUgc2luZ2xlIG1lY2hhbmlzbSB0byBzdXBwb3J0IFwicHJpdmF0ZVwiIGFuZCBcInVzZXJcIiBkYXRhLlxuLy9cdDQuIF9OZXZlcl8gZXhwb3NlIFwicHJpdmF0ZVwiIGRhdGEgdG8gdXNlciBjb2RlIChUT0RPOiBEcm9wIF9kYXRhLCBfcmVtb3ZlRGF0YSlcbi8vXHQ1LiBBdm9pZCBleHBvc2luZyBpbXBsZW1lbnRhdGlvbiBkZXRhaWxzIG9uIHVzZXIgb2JqZWN0cyAoZWcuIGV4cGFuZG8gcHJvcGVydGllcylcbi8vXHQ2LiBQcm92aWRlIGEgY2xlYXIgcGF0aCBmb3IgaW1wbGVtZW50YXRpb24gdXBncmFkZSB0byBXZWFrTWFwIGluIDIwMTRcblxudmFyIHJicmFjZSA9IC9eKD86XFx7W1xcd1xcV10qXFx9fFxcW1tcXHdcXFddKlxcXSkkLyxcblx0cm11bHRpRGFzaCA9IC9bQS1aXS9nO1xuXG5mdW5jdGlvbiBnZXREYXRhKCBkYXRhICkge1xuXHRpZiAoIGRhdGEgPT09IFwidHJ1ZVwiICkge1xuXHRcdHJldHVybiB0cnVlO1xuXHR9XG5cblx0aWYgKCBkYXRhID09PSBcImZhbHNlXCIgKSB7XG5cdFx0cmV0dXJuIGZhbHNlO1xuXHR9XG5cblx0aWYgKCBkYXRhID09PSBcIm51bGxcIiApIHtcblx0XHRyZXR1cm4gbnVsbDtcblx0fVxuXG5cdC8vIE9ubHkgY29udmVydCB0byBhIG51bWJlciBpZiBpdCBkb2Vzbid0IGNoYW5nZSB0aGUgc3RyaW5nXG5cdGlmICggZGF0YSA9PT0gK2RhdGEgKyBcIlwiICkge1xuXHRcdHJldHVybiArZGF0YTtcblx0fVxuXG5cdGlmICggcmJyYWNlLnRlc3QoIGRhdGEgKSApIHtcblx0XHRyZXR1cm4gSlNPTi5wYXJzZSggZGF0YSApO1xuXHR9XG5cblx0cmV0dXJuIGRhdGE7XG59XG5cbmZ1bmN0aW9uIGRhdGFBdHRyKCBlbGVtLCBrZXksIGRhdGEgKSB7XG5cdHZhciBuYW1lO1xuXG5cdC8vIElmIG5vdGhpbmcgd2FzIGZvdW5kIGludGVybmFsbHksIHRyeSB0byBmZXRjaCBhbnlcblx0Ly8gZGF0YSBmcm9tIHRoZSBIVE1MNSBkYXRhLSogYXR0cmlidXRlXG5cdGlmICggZGF0YSA9PT0gdW5kZWZpbmVkICYmIGVsZW0ubm9kZVR5cGUgPT09IDEgKSB7XG5cdFx0bmFtZSA9IFwiZGF0YS1cIiArIGtleS5yZXBsYWNlKCBybXVsdGlEYXNoLCBcIi0kJlwiICkudG9Mb3dlckNhc2UoKTtcblx0XHRkYXRhID0gZWxlbS5nZXRBdHRyaWJ1dGUoIG5hbWUgKTtcblxuXHRcdGlmICggdHlwZW9mIGRhdGEgPT09IFwic3RyaW5nXCIgKSB7XG5cdFx0XHR0cnkge1xuXHRcdFx0XHRkYXRhID0gZ2V0RGF0YSggZGF0YSApO1xuXHRcdFx0fSBjYXRjaCAoIGUgKSB7fVxuXG5cdFx0XHQvLyBNYWtlIHN1cmUgd2Ugc2V0IHRoZSBkYXRhIHNvIGl0IGlzbid0IGNoYW5nZWQgbGF0ZXJcblx0XHRcdGRhdGFVc2VyLnNldCggZWxlbSwga2V5LCBkYXRhICk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdGRhdGEgPSB1bmRlZmluZWQ7XG5cdFx0fVxuXHR9XG5cdHJldHVybiBkYXRhO1xufVxuXG5qUXVlcnkuZXh0ZW5kKCB7XG5cdGhhc0RhdGE6IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdHJldHVybiBkYXRhVXNlci5oYXNEYXRhKCBlbGVtICkgfHwgZGF0YVByaXYuaGFzRGF0YSggZWxlbSApO1xuXHR9LFxuXG5cdGRhdGE6IGZ1bmN0aW9uKCBlbGVtLCBuYW1lLCBkYXRhICkge1xuXHRcdHJldHVybiBkYXRhVXNlci5hY2Nlc3MoIGVsZW0sIG5hbWUsIGRhdGEgKTtcblx0fSxcblxuXHRyZW1vdmVEYXRhOiBmdW5jdGlvbiggZWxlbSwgbmFtZSApIHtcblx0XHRkYXRhVXNlci5yZW1vdmUoIGVsZW0sIG5hbWUgKTtcblx0fSxcblxuXHQvLyBUT0RPOiBOb3cgdGhhdCBhbGwgY2FsbHMgdG8gX2RhdGEgYW5kIF9yZW1vdmVEYXRhIGhhdmUgYmVlbiByZXBsYWNlZFxuXHQvLyB3aXRoIGRpcmVjdCBjYWxscyB0byBkYXRhUHJpdiBtZXRob2RzLCB0aGVzZSBjYW4gYmUgZGVwcmVjYXRlZC5cblx0X2RhdGE6IGZ1bmN0aW9uKCBlbGVtLCBuYW1lLCBkYXRhICkge1xuXHRcdHJldHVybiBkYXRhUHJpdi5hY2Nlc3MoIGVsZW0sIG5hbWUsIGRhdGEgKTtcblx0fSxcblxuXHRfcmVtb3ZlRGF0YTogZnVuY3Rpb24oIGVsZW0sIG5hbWUgKSB7XG5cdFx0ZGF0YVByaXYucmVtb3ZlKCBlbGVtLCBuYW1lICk7XG5cdH1cbn0gKTtcblxualF1ZXJ5LmZuLmV4dGVuZCgge1xuXHRkYXRhOiBmdW5jdGlvbigga2V5LCB2YWx1ZSApIHtcblx0XHR2YXIgaSwgbmFtZSwgZGF0YSxcblx0XHRcdGVsZW0gPSB0aGlzWyAwIF0sXG5cdFx0XHRhdHRycyA9IGVsZW0gJiYgZWxlbS5hdHRyaWJ1dGVzO1xuXG5cdFx0Ly8gR2V0cyBhbGwgdmFsdWVzXG5cdFx0aWYgKCBrZXkgPT09IHVuZGVmaW5lZCApIHtcblx0XHRcdGlmICggdGhpcy5sZW5ndGggKSB7XG5cdFx0XHRcdGRhdGEgPSBkYXRhVXNlci5nZXQoIGVsZW0gKTtcblxuXHRcdFx0XHRpZiAoIGVsZW0ubm9kZVR5cGUgPT09IDEgJiYgIWRhdGFQcml2LmdldCggZWxlbSwgXCJoYXNEYXRhQXR0cnNcIiApICkge1xuXHRcdFx0XHRcdGkgPSBhdHRycy5sZW5ndGg7XG5cdFx0XHRcdFx0d2hpbGUgKCBpLS0gKSB7XG5cblx0XHRcdFx0XHRcdC8vIFN1cHBvcnQ6IElFIDExIG9ubHlcblx0XHRcdFx0XHRcdC8vIFRoZSBhdHRycyBlbGVtZW50cyBjYW4gYmUgbnVsbCAoIzE0ODk0KVxuXHRcdFx0XHRcdFx0aWYgKCBhdHRyc1sgaSBdICkge1xuXHRcdFx0XHRcdFx0XHRuYW1lID0gYXR0cnNbIGkgXS5uYW1lO1xuXHRcdFx0XHRcdFx0XHRpZiAoIG5hbWUuaW5kZXhPZiggXCJkYXRhLVwiICkgPT09IDAgKSB7XG5cdFx0XHRcdFx0XHRcdFx0bmFtZSA9IGNhbWVsQ2FzZSggbmFtZS5zbGljZSggNSApICk7XG5cdFx0XHRcdFx0XHRcdFx0ZGF0YUF0dHIoIGVsZW0sIG5hbWUsIGRhdGFbIG5hbWUgXSApO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGRhdGFQcml2LnNldCggZWxlbSwgXCJoYXNEYXRhQXR0cnNcIiwgdHJ1ZSApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBkYXRhO1xuXHRcdH1cblxuXHRcdC8vIFNldHMgbXVsdGlwbGUgdmFsdWVzXG5cdFx0aWYgKCB0eXBlb2Yga2V5ID09PSBcIm9iamVjdFwiICkge1xuXHRcdFx0cmV0dXJuIHRoaXMuZWFjaCggZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGRhdGFVc2VyLnNldCggdGhpcywga2V5ICk7XG5cdFx0XHR9ICk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGFjY2VzcyggdGhpcywgZnVuY3Rpb24oIHZhbHVlICkge1xuXHRcdFx0dmFyIGRhdGE7XG5cblx0XHRcdC8vIFRoZSBjYWxsaW5nIGpRdWVyeSBvYmplY3QgKGVsZW1lbnQgbWF0Y2hlcykgaXMgbm90IGVtcHR5XG5cdFx0XHQvLyAoYW5kIHRoZXJlZm9yZSBoYXMgYW4gZWxlbWVudCBhcHBlYXJzIGF0IHRoaXNbIDAgXSkgYW5kIHRoZVxuXHRcdFx0Ly8gYHZhbHVlYCBwYXJhbWV0ZXIgd2FzIG5vdCB1bmRlZmluZWQuIEFuIGVtcHR5IGpRdWVyeSBvYmplY3Rcblx0XHRcdC8vIHdpbGwgcmVzdWx0IGluIGB1bmRlZmluZWRgIGZvciBlbGVtID0gdGhpc1sgMCBdIHdoaWNoIHdpbGxcblx0XHRcdC8vIHRocm93IGFuIGV4Y2VwdGlvbiBpZiBhbiBhdHRlbXB0IHRvIHJlYWQgYSBkYXRhIGNhY2hlIGlzIG1hZGUuXG5cdFx0XHRpZiAoIGVsZW0gJiYgdmFsdWUgPT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0XHQvLyBBdHRlbXB0IHRvIGdldCBkYXRhIGZyb20gdGhlIGNhY2hlXG5cdFx0XHRcdC8vIFRoZSBrZXkgd2lsbCBhbHdheXMgYmUgY2FtZWxDYXNlZCBpbiBEYXRhXG5cdFx0XHRcdGRhdGEgPSBkYXRhVXNlci5nZXQoIGVsZW0sIGtleSApO1xuXHRcdFx0XHRpZiAoIGRhdGEgIT09IHVuZGVmaW5lZCApIHtcblx0XHRcdFx0XHRyZXR1cm4gZGF0YTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIEF0dGVtcHQgdG8gXCJkaXNjb3ZlclwiIHRoZSBkYXRhIGluXG5cdFx0XHRcdC8vIEhUTUw1IGN1c3RvbSBkYXRhLSogYXR0cnNcblx0XHRcdFx0ZGF0YSA9IGRhdGFBdHRyKCBlbGVtLCBrZXkgKTtcblx0XHRcdFx0aWYgKCBkYXRhICE9PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRcdFx0cmV0dXJuIGRhdGE7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBXZSB0cmllZCByZWFsbHkgaGFyZCwgYnV0IHRoZSBkYXRhIGRvZXNuJ3QgZXhpc3QuXG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblxuXHRcdFx0Ly8gU2V0IHRoZSBkYXRhLi4uXG5cdFx0XHR0aGlzLmVhY2goIGZ1bmN0aW9uKCkge1xuXG5cdFx0XHRcdC8vIFdlIGFsd2F5cyBzdG9yZSB0aGUgY2FtZWxDYXNlZCBrZXlcblx0XHRcdFx0ZGF0YVVzZXIuc2V0KCB0aGlzLCBrZXksIHZhbHVlICk7XG5cdFx0XHR9ICk7XG5cdFx0fSwgbnVsbCwgdmFsdWUsIGFyZ3VtZW50cy5sZW5ndGggPiAxLCBudWxsLCB0cnVlICk7XG5cdH0sXG5cblx0cmVtb3ZlRGF0YTogZnVuY3Rpb24oIGtleSApIHtcblx0XHRyZXR1cm4gdGhpcy5lYWNoKCBmdW5jdGlvbigpIHtcblx0XHRcdGRhdGFVc2VyLnJlbW92ZSggdGhpcywga2V5ICk7XG5cdFx0fSApO1xuXHR9XG59ICk7XG5cblxualF1ZXJ5LmV4dGVuZCgge1xuXHRxdWV1ZTogZnVuY3Rpb24oIGVsZW0sIHR5cGUsIGRhdGEgKSB7XG5cdFx0dmFyIHF1ZXVlO1xuXG5cdFx0aWYgKCBlbGVtICkge1xuXHRcdFx0dHlwZSA9ICggdHlwZSB8fCBcImZ4XCIgKSArIFwicXVldWVcIjtcblx0XHRcdHF1ZXVlID0gZGF0YVByaXYuZ2V0KCBlbGVtLCB0eXBlICk7XG5cblx0XHRcdC8vIFNwZWVkIHVwIGRlcXVldWUgYnkgZ2V0dGluZyBvdXQgcXVpY2tseSBpZiB0aGlzIGlzIGp1c3QgYSBsb29rdXBcblx0XHRcdGlmICggZGF0YSApIHtcblx0XHRcdFx0aWYgKCAhcXVldWUgfHwgQXJyYXkuaXNBcnJheSggZGF0YSApICkge1xuXHRcdFx0XHRcdHF1ZXVlID0gZGF0YVByaXYuYWNjZXNzKCBlbGVtLCB0eXBlLCBqUXVlcnkubWFrZUFycmF5KCBkYXRhICkgKTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRxdWV1ZS5wdXNoKCBkYXRhICk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdHJldHVybiBxdWV1ZSB8fCBbXTtcblx0XHR9XG5cdH0sXG5cblx0ZGVxdWV1ZTogZnVuY3Rpb24oIGVsZW0sIHR5cGUgKSB7XG5cdFx0dHlwZSA9IHR5cGUgfHwgXCJmeFwiO1xuXG5cdFx0dmFyIHF1ZXVlID0galF1ZXJ5LnF1ZXVlKCBlbGVtLCB0eXBlICksXG5cdFx0XHRzdGFydExlbmd0aCA9IHF1ZXVlLmxlbmd0aCxcblx0XHRcdGZuID0gcXVldWUuc2hpZnQoKSxcblx0XHRcdGhvb2tzID0galF1ZXJ5Ll9xdWV1ZUhvb2tzKCBlbGVtLCB0eXBlICksXG5cdFx0XHRuZXh0ID0gZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGpRdWVyeS5kZXF1ZXVlKCBlbGVtLCB0eXBlICk7XG5cdFx0XHR9O1xuXG5cdFx0Ly8gSWYgdGhlIGZ4IHF1ZXVlIGlzIGRlcXVldWVkLCBhbHdheXMgcmVtb3ZlIHRoZSBwcm9ncmVzcyBzZW50aW5lbFxuXHRcdGlmICggZm4gPT09IFwiaW5wcm9ncmVzc1wiICkge1xuXHRcdFx0Zm4gPSBxdWV1ZS5zaGlmdCgpO1xuXHRcdFx0c3RhcnRMZW5ndGgtLTtcblx0XHR9XG5cblx0XHRpZiAoIGZuICkge1xuXG5cdFx0XHQvLyBBZGQgYSBwcm9ncmVzcyBzZW50aW5lbCB0byBwcmV2ZW50IHRoZSBmeCBxdWV1ZSBmcm9tIGJlaW5nXG5cdFx0XHQvLyBhdXRvbWF0aWNhbGx5IGRlcXVldWVkXG5cdFx0XHRpZiAoIHR5cGUgPT09IFwiZnhcIiApIHtcblx0XHRcdFx0cXVldWUudW5zaGlmdCggXCJpbnByb2dyZXNzXCIgKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gQ2xlYXIgdXAgdGhlIGxhc3QgcXVldWUgc3RvcCBmdW5jdGlvblxuXHRcdFx0ZGVsZXRlIGhvb2tzLnN0b3A7XG5cdFx0XHRmbi5jYWxsKCBlbGVtLCBuZXh0LCBob29rcyApO1xuXHRcdH1cblxuXHRcdGlmICggIXN0YXJ0TGVuZ3RoICYmIGhvb2tzICkge1xuXHRcdFx0aG9va3MuZW1wdHkuZmlyZSgpO1xuXHRcdH1cblx0fSxcblxuXHQvLyBOb3QgcHVibGljIC0gZ2VuZXJhdGUgYSBxdWV1ZUhvb2tzIG9iamVjdCwgb3IgcmV0dXJuIHRoZSBjdXJyZW50IG9uZVxuXHRfcXVldWVIb29rczogZnVuY3Rpb24oIGVsZW0sIHR5cGUgKSB7XG5cdFx0dmFyIGtleSA9IHR5cGUgKyBcInF1ZXVlSG9va3NcIjtcblx0XHRyZXR1cm4gZGF0YVByaXYuZ2V0KCBlbGVtLCBrZXkgKSB8fCBkYXRhUHJpdi5hY2Nlc3MoIGVsZW0sIGtleSwge1xuXHRcdFx0ZW1wdHk6IGpRdWVyeS5DYWxsYmFja3MoIFwib25jZSBtZW1vcnlcIiApLmFkZCggZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGRhdGFQcml2LnJlbW92ZSggZWxlbSwgWyB0eXBlICsgXCJxdWV1ZVwiLCBrZXkgXSApO1xuXHRcdFx0fSApXG5cdFx0fSApO1xuXHR9XG59ICk7XG5cbmpRdWVyeS5mbi5leHRlbmQoIHtcblx0cXVldWU6IGZ1bmN0aW9uKCB0eXBlLCBkYXRhICkge1xuXHRcdHZhciBzZXR0ZXIgPSAyO1xuXG5cdFx0aWYgKCB0eXBlb2YgdHlwZSAhPT0gXCJzdHJpbmdcIiApIHtcblx0XHRcdGRhdGEgPSB0eXBlO1xuXHRcdFx0dHlwZSA9IFwiZnhcIjtcblx0XHRcdHNldHRlci0tO1xuXHRcdH1cblxuXHRcdGlmICggYXJndW1lbnRzLmxlbmd0aCA8IHNldHRlciApIHtcblx0XHRcdHJldHVybiBqUXVlcnkucXVldWUoIHRoaXNbIDAgXSwgdHlwZSApO1xuXHRcdH1cblxuXHRcdHJldHVybiBkYXRhID09PSB1bmRlZmluZWQgP1xuXHRcdFx0dGhpcyA6XG5cdFx0XHR0aGlzLmVhY2goIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHR2YXIgcXVldWUgPSBqUXVlcnkucXVldWUoIHRoaXMsIHR5cGUsIGRhdGEgKTtcblxuXHRcdFx0XHQvLyBFbnN1cmUgYSBob29rcyBmb3IgdGhpcyBxdWV1ZVxuXHRcdFx0XHRqUXVlcnkuX3F1ZXVlSG9va3MoIHRoaXMsIHR5cGUgKTtcblxuXHRcdFx0XHRpZiAoIHR5cGUgPT09IFwiZnhcIiAmJiBxdWV1ZVsgMCBdICE9PSBcImlucHJvZ3Jlc3NcIiApIHtcblx0XHRcdFx0XHRqUXVlcnkuZGVxdWV1ZSggdGhpcywgdHlwZSApO1xuXHRcdFx0XHR9XG5cdFx0XHR9ICk7XG5cdH0sXG5cdGRlcXVldWU6IGZ1bmN0aW9uKCB0eXBlICkge1xuXHRcdHJldHVybiB0aGlzLmVhY2goIGZ1bmN0aW9uKCkge1xuXHRcdFx0alF1ZXJ5LmRlcXVldWUoIHRoaXMsIHR5cGUgKTtcblx0XHR9ICk7XG5cdH0sXG5cdGNsZWFyUXVldWU6IGZ1bmN0aW9uKCB0eXBlICkge1xuXHRcdHJldHVybiB0aGlzLnF1ZXVlKCB0eXBlIHx8IFwiZnhcIiwgW10gKTtcblx0fSxcblxuXHQvLyBHZXQgYSBwcm9taXNlIHJlc29sdmVkIHdoZW4gcXVldWVzIG9mIGEgY2VydGFpbiB0eXBlXG5cdC8vIGFyZSBlbXB0aWVkIChmeCBpcyB0aGUgdHlwZSBieSBkZWZhdWx0KVxuXHRwcm9taXNlOiBmdW5jdGlvbiggdHlwZSwgb2JqICkge1xuXHRcdHZhciB0bXAsXG5cdFx0XHRjb3VudCA9IDEsXG5cdFx0XHRkZWZlciA9IGpRdWVyeS5EZWZlcnJlZCgpLFxuXHRcdFx0ZWxlbWVudHMgPSB0aGlzLFxuXHRcdFx0aSA9IHRoaXMubGVuZ3RoLFxuXHRcdFx0cmVzb2x2ZSA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRpZiAoICEoIC0tY291bnQgKSApIHtcblx0XHRcdFx0XHRkZWZlci5yZXNvbHZlV2l0aCggZWxlbWVudHMsIFsgZWxlbWVudHMgXSApO1xuXHRcdFx0XHR9XG5cdFx0XHR9O1xuXG5cdFx0aWYgKCB0eXBlb2YgdHlwZSAhPT0gXCJzdHJpbmdcIiApIHtcblx0XHRcdG9iaiA9IHR5cGU7XG5cdFx0XHR0eXBlID0gdW5kZWZpbmVkO1xuXHRcdH1cblx0XHR0eXBlID0gdHlwZSB8fCBcImZ4XCI7XG5cblx0XHR3aGlsZSAoIGktLSApIHtcblx0XHRcdHRtcCA9IGRhdGFQcml2LmdldCggZWxlbWVudHNbIGkgXSwgdHlwZSArIFwicXVldWVIb29rc1wiICk7XG5cdFx0XHRpZiAoIHRtcCAmJiB0bXAuZW1wdHkgKSB7XG5cdFx0XHRcdGNvdW50Kys7XG5cdFx0XHRcdHRtcC5lbXB0eS5hZGQoIHJlc29sdmUgKTtcblx0XHRcdH1cblx0XHR9XG5cdFx0cmVzb2x2ZSgpO1xuXHRcdHJldHVybiBkZWZlci5wcm9taXNlKCBvYmogKTtcblx0fVxufSApO1xudmFyIHBudW0gPSAoIC9bKy1dPyg/OlxcZCpcXC58KVxcZCsoPzpbZUVdWystXT9cXGQrfCkvICkuc291cmNlO1xuXG52YXIgcmNzc051bSA9IG5ldyBSZWdFeHAoIFwiXig/OihbKy1dKT18KShcIiArIHBudW0gKyBcIikoW2EteiVdKikkXCIsIFwiaVwiICk7XG5cblxudmFyIGNzc0V4cGFuZCA9IFsgXCJUb3BcIiwgXCJSaWdodFwiLCBcIkJvdHRvbVwiLCBcIkxlZnRcIiBdO1xuXG52YXIgZG9jdW1lbnRFbGVtZW50ID0gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50O1xuXG5cblxuXHR2YXIgaXNBdHRhY2hlZCA9IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0cmV0dXJuIGpRdWVyeS5jb250YWlucyggZWxlbS5vd25lckRvY3VtZW50LCBlbGVtICk7XG5cdFx0fSxcblx0XHRjb21wb3NlZCA9IHsgY29tcG9zZWQ6IHRydWUgfTtcblxuXHQvLyBTdXBwb3J0OiBJRSA5IC0gMTErLCBFZGdlIDEyIC0gMTgrLCBpT1MgMTAuMCAtIDEwLjIgb25seVxuXHQvLyBDaGVjayBhdHRhY2htZW50IGFjcm9zcyBzaGFkb3cgRE9NIGJvdW5kYXJpZXMgd2hlbiBwb3NzaWJsZSAoZ2gtMzUwNClcblx0Ly8gU3VwcG9ydDogaU9TIDEwLjAtMTAuMiBvbmx5XG5cdC8vIEVhcmx5IGlPUyAxMCB2ZXJzaW9ucyBzdXBwb3J0IGBhdHRhY2hTaGFkb3dgIGJ1dCBub3QgYGdldFJvb3ROb2RlYCxcblx0Ly8gbGVhZGluZyB0byBlcnJvcnMuIFdlIG5lZWQgdG8gY2hlY2sgZm9yIGBnZXRSb290Tm9kZWAuXG5cdGlmICggZG9jdW1lbnRFbGVtZW50LmdldFJvb3ROb2RlICkge1xuXHRcdGlzQXR0YWNoZWQgPSBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdHJldHVybiBqUXVlcnkuY29udGFpbnMoIGVsZW0ub3duZXJEb2N1bWVudCwgZWxlbSApIHx8XG5cdFx0XHRcdGVsZW0uZ2V0Um9vdE5vZGUoIGNvbXBvc2VkICkgPT09IGVsZW0ub3duZXJEb2N1bWVudDtcblx0XHR9O1xuXHR9XG52YXIgaXNIaWRkZW5XaXRoaW5UcmVlID0gZnVuY3Rpb24oIGVsZW0sIGVsICkge1xuXG5cdFx0Ly8gaXNIaWRkZW5XaXRoaW5UcmVlIG1pZ2h0IGJlIGNhbGxlZCBmcm9tIGpRdWVyeSNmaWx0ZXIgZnVuY3Rpb247XG5cdFx0Ly8gaW4gdGhhdCBjYXNlLCBlbGVtZW50IHdpbGwgYmUgc2Vjb25kIGFyZ3VtZW50XG5cdFx0ZWxlbSA9IGVsIHx8IGVsZW07XG5cblx0XHQvLyBJbmxpbmUgc3R5bGUgdHJ1bXBzIGFsbFxuXHRcdHJldHVybiBlbGVtLnN0eWxlLmRpc3BsYXkgPT09IFwibm9uZVwiIHx8XG5cdFx0XHRlbGVtLnN0eWxlLmRpc3BsYXkgPT09IFwiXCIgJiZcblxuXHRcdFx0Ly8gT3RoZXJ3aXNlLCBjaGVjayBjb21wdXRlZCBzdHlsZVxuXHRcdFx0Ly8gU3VwcG9ydDogRmlyZWZveCA8PTQzIC0gNDVcblx0XHRcdC8vIERpc2Nvbm5lY3RlZCBlbGVtZW50cyBjYW4gaGF2ZSBjb21wdXRlZCBkaXNwbGF5OiBub25lLCBzbyBmaXJzdCBjb25maXJtIHRoYXQgZWxlbSBpc1xuXHRcdFx0Ly8gaW4gdGhlIGRvY3VtZW50LlxuXHRcdFx0aXNBdHRhY2hlZCggZWxlbSApICYmXG5cblx0XHRcdGpRdWVyeS5jc3MoIGVsZW0sIFwiZGlzcGxheVwiICkgPT09IFwibm9uZVwiO1xuXHR9O1xuXG52YXIgc3dhcCA9IGZ1bmN0aW9uKCBlbGVtLCBvcHRpb25zLCBjYWxsYmFjaywgYXJncyApIHtcblx0dmFyIHJldCwgbmFtZSxcblx0XHRvbGQgPSB7fTtcblxuXHQvLyBSZW1lbWJlciB0aGUgb2xkIHZhbHVlcywgYW5kIGluc2VydCB0aGUgbmV3IG9uZXNcblx0Zm9yICggbmFtZSBpbiBvcHRpb25zICkge1xuXHRcdG9sZFsgbmFtZSBdID0gZWxlbS5zdHlsZVsgbmFtZSBdO1xuXHRcdGVsZW0uc3R5bGVbIG5hbWUgXSA9IG9wdGlvbnNbIG5hbWUgXTtcblx0fVxuXG5cdHJldCA9IGNhbGxiYWNrLmFwcGx5KCBlbGVtLCBhcmdzIHx8IFtdICk7XG5cblx0Ly8gUmV2ZXJ0IHRoZSBvbGQgdmFsdWVzXG5cdGZvciAoIG5hbWUgaW4gb3B0aW9ucyApIHtcblx0XHRlbGVtLnN0eWxlWyBuYW1lIF0gPSBvbGRbIG5hbWUgXTtcblx0fVxuXG5cdHJldHVybiByZXQ7XG59O1xuXG5cblxuXG5mdW5jdGlvbiBhZGp1c3RDU1MoIGVsZW0sIHByb3AsIHZhbHVlUGFydHMsIHR3ZWVuICkge1xuXHR2YXIgYWRqdXN0ZWQsIHNjYWxlLFxuXHRcdG1heEl0ZXJhdGlvbnMgPSAyMCxcblx0XHRjdXJyZW50VmFsdWUgPSB0d2VlbiA/XG5cdFx0XHRmdW5jdGlvbigpIHtcblx0XHRcdFx0cmV0dXJuIHR3ZWVuLmN1cigpO1xuXHRcdFx0fSA6XG5cdFx0XHRmdW5jdGlvbigpIHtcblx0XHRcdFx0cmV0dXJuIGpRdWVyeS5jc3MoIGVsZW0sIHByb3AsIFwiXCIgKTtcblx0XHRcdH0sXG5cdFx0aW5pdGlhbCA9IGN1cnJlbnRWYWx1ZSgpLFxuXHRcdHVuaXQgPSB2YWx1ZVBhcnRzICYmIHZhbHVlUGFydHNbIDMgXSB8fCAoIGpRdWVyeS5jc3NOdW1iZXJbIHByb3AgXSA/IFwiXCIgOiBcInB4XCIgKSxcblxuXHRcdC8vIFN0YXJ0aW5nIHZhbHVlIGNvbXB1dGF0aW9uIGlzIHJlcXVpcmVkIGZvciBwb3RlbnRpYWwgdW5pdCBtaXNtYXRjaGVzXG5cdFx0aW5pdGlhbEluVW5pdCA9IGVsZW0ubm9kZVR5cGUgJiZcblx0XHRcdCggalF1ZXJ5LmNzc051bWJlclsgcHJvcCBdIHx8IHVuaXQgIT09IFwicHhcIiAmJiAraW5pdGlhbCApICYmXG5cdFx0XHRyY3NzTnVtLmV4ZWMoIGpRdWVyeS5jc3MoIGVsZW0sIHByb3AgKSApO1xuXG5cdGlmICggaW5pdGlhbEluVW5pdCAmJiBpbml0aWFsSW5Vbml0WyAzIF0gIT09IHVuaXQgKSB7XG5cblx0XHQvLyBTdXBwb3J0OiBGaXJlZm94IDw9NTRcblx0XHQvLyBIYWx2ZSB0aGUgaXRlcmF0aW9uIHRhcmdldCB2YWx1ZSB0byBwcmV2ZW50IGludGVyZmVyZW5jZSBmcm9tIENTUyB1cHBlciBib3VuZHMgKGdoLTIxNDQpXG5cdFx0aW5pdGlhbCA9IGluaXRpYWwgLyAyO1xuXG5cdFx0Ly8gVHJ1c3QgdW5pdHMgcmVwb3J0ZWQgYnkgalF1ZXJ5LmNzc1xuXHRcdHVuaXQgPSB1bml0IHx8IGluaXRpYWxJblVuaXRbIDMgXTtcblxuXHRcdC8vIEl0ZXJhdGl2ZWx5IGFwcHJveGltYXRlIGZyb20gYSBub256ZXJvIHN0YXJ0aW5nIHBvaW50XG5cdFx0aW5pdGlhbEluVW5pdCA9ICtpbml0aWFsIHx8IDE7XG5cblx0XHR3aGlsZSAoIG1heEl0ZXJhdGlvbnMtLSApIHtcblxuXHRcdFx0Ly8gRXZhbHVhdGUgYW5kIHVwZGF0ZSBvdXIgYmVzdCBndWVzcyAoZG91YmxpbmcgZ3Vlc3NlcyB0aGF0IHplcm8gb3V0KS5cblx0XHRcdC8vIEZpbmlzaCBpZiB0aGUgc2NhbGUgZXF1YWxzIG9yIGNyb3NzZXMgMSAobWFraW5nIHRoZSBvbGQqbmV3IHByb2R1Y3Qgbm9uLXBvc2l0aXZlKS5cblx0XHRcdGpRdWVyeS5zdHlsZSggZWxlbSwgcHJvcCwgaW5pdGlhbEluVW5pdCArIHVuaXQgKTtcblx0XHRcdGlmICggKCAxIC0gc2NhbGUgKSAqICggMSAtICggc2NhbGUgPSBjdXJyZW50VmFsdWUoKSAvIGluaXRpYWwgfHwgMC41ICkgKSA8PSAwICkge1xuXHRcdFx0XHRtYXhJdGVyYXRpb25zID0gMDtcblx0XHRcdH1cblx0XHRcdGluaXRpYWxJblVuaXQgPSBpbml0aWFsSW5Vbml0IC8gc2NhbGU7XG5cblx0XHR9XG5cblx0XHRpbml0aWFsSW5Vbml0ID0gaW5pdGlhbEluVW5pdCAqIDI7XG5cdFx0alF1ZXJ5LnN0eWxlKCBlbGVtLCBwcm9wLCBpbml0aWFsSW5Vbml0ICsgdW5pdCApO1xuXG5cdFx0Ly8gTWFrZSBzdXJlIHdlIHVwZGF0ZSB0aGUgdHdlZW4gcHJvcGVydGllcyBsYXRlciBvblxuXHRcdHZhbHVlUGFydHMgPSB2YWx1ZVBhcnRzIHx8IFtdO1xuXHR9XG5cblx0aWYgKCB2YWx1ZVBhcnRzICkge1xuXHRcdGluaXRpYWxJblVuaXQgPSAraW5pdGlhbEluVW5pdCB8fCAraW5pdGlhbCB8fCAwO1xuXG5cdFx0Ly8gQXBwbHkgcmVsYXRpdmUgb2Zmc2V0ICgrPS8tPSkgaWYgc3BlY2lmaWVkXG5cdFx0YWRqdXN0ZWQgPSB2YWx1ZVBhcnRzWyAxIF0gP1xuXHRcdFx0aW5pdGlhbEluVW5pdCArICggdmFsdWVQYXJ0c1sgMSBdICsgMSApICogdmFsdWVQYXJ0c1sgMiBdIDpcblx0XHRcdCt2YWx1ZVBhcnRzWyAyIF07XG5cdFx0aWYgKCB0d2VlbiApIHtcblx0XHRcdHR3ZWVuLnVuaXQgPSB1bml0O1xuXHRcdFx0dHdlZW4uc3RhcnQgPSBpbml0aWFsSW5Vbml0O1xuXHRcdFx0dHdlZW4uZW5kID0gYWRqdXN0ZWQ7XG5cdFx0fVxuXHR9XG5cdHJldHVybiBhZGp1c3RlZDtcbn1cblxuXG52YXIgZGVmYXVsdERpc3BsYXlNYXAgPSB7fTtcblxuZnVuY3Rpb24gZ2V0RGVmYXVsdERpc3BsYXkoIGVsZW0gKSB7XG5cdHZhciB0ZW1wLFxuXHRcdGRvYyA9IGVsZW0ub3duZXJEb2N1bWVudCxcblx0XHRub2RlTmFtZSA9IGVsZW0ubm9kZU5hbWUsXG5cdFx0ZGlzcGxheSA9IGRlZmF1bHREaXNwbGF5TWFwWyBub2RlTmFtZSBdO1xuXG5cdGlmICggZGlzcGxheSApIHtcblx0XHRyZXR1cm4gZGlzcGxheTtcblx0fVxuXG5cdHRlbXAgPSBkb2MuYm9keS5hcHBlbmRDaGlsZCggZG9jLmNyZWF0ZUVsZW1lbnQoIG5vZGVOYW1lICkgKTtcblx0ZGlzcGxheSA9IGpRdWVyeS5jc3MoIHRlbXAsIFwiZGlzcGxheVwiICk7XG5cblx0dGVtcC5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKCB0ZW1wICk7XG5cblx0aWYgKCBkaXNwbGF5ID09PSBcIm5vbmVcIiApIHtcblx0XHRkaXNwbGF5ID0gXCJibG9ja1wiO1xuXHR9XG5cdGRlZmF1bHREaXNwbGF5TWFwWyBub2RlTmFtZSBdID0gZGlzcGxheTtcblxuXHRyZXR1cm4gZGlzcGxheTtcbn1cblxuZnVuY3Rpb24gc2hvd0hpZGUoIGVsZW1lbnRzLCBzaG93ICkge1xuXHR2YXIgZGlzcGxheSwgZWxlbSxcblx0XHR2YWx1ZXMgPSBbXSxcblx0XHRpbmRleCA9IDAsXG5cdFx0bGVuZ3RoID0gZWxlbWVudHMubGVuZ3RoO1xuXG5cdC8vIERldGVybWluZSBuZXcgZGlzcGxheSB2YWx1ZSBmb3IgZWxlbWVudHMgdGhhdCBuZWVkIHRvIGNoYW5nZVxuXHRmb3IgKCA7IGluZGV4IDwgbGVuZ3RoOyBpbmRleCsrICkge1xuXHRcdGVsZW0gPSBlbGVtZW50c1sgaW5kZXggXTtcblx0XHRpZiAoICFlbGVtLnN0eWxlICkge1xuXHRcdFx0Y29udGludWU7XG5cdFx0fVxuXG5cdFx0ZGlzcGxheSA9IGVsZW0uc3R5bGUuZGlzcGxheTtcblx0XHRpZiAoIHNob3cgKSB7XG5cblx0XHRcdC8vIFNpbmNlIHdlIGZvcmNlIHZpc2liaWxpdHkgdXBvbiBjYXNjYWRlLWhpZGRlbiBlbGVtZW50cywgYW4gaW1tZWRpYXRlIChhbmQgc2xvdylcblx0XHRcdC8vIGNoZWNrIGlzIHJlcXVpcmVkIGluIHRoaXMgZmlyc3QgbG9vcCB1bmxlc3Mgd2UgaGF2ZSBhIG5vbmVtcHR5IGRpc3BsYXkgdmFsdWUgKGVpdGhlclxuXHRcdFx0Ly8gaW5saW5lIG9yIGFib3V0LXRvLWJlLXJlc3RvcmVkKVxuXHRcdFx0aWYgKCBkaXNwbGF5ID09PSBcIm5vbmVcIiApIHtcblx0XHRcdFx0dmFsdWVzWyBpbmRleCBdID0gZGF0YVByaXYuZ2V0KCBlbGVtLCBcImRpc3BsYXlcIiApIHx8IG51bGw7XG5cdFx0XHRcdGlmICggIXZhbHVlc1sgaW5kZXggXSApIHtcblx0XHRcdFx0XHRlbGVtLnN0eWxlLmRpc3BsYXkgPSBcIlwiO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRpZiAoIGVsZW0uc3R5bGUuZGlzcGxheSA9PT0gXCJcIiAmJiBpc0hpZGRlbldpdGhpblRyZWUoIGVsZW0gKSApIHtcblx0XHRcdFx0dmFsdWVzWyBpbmRleCBdID0gZ2V0RGVmYXVsdERpc3BsYXkoIGVsZW0gKTtcblx0XHRcdH1cblx0XHR9IGVsc2Uge1xuXHRcdFx0aWYgKCBkaXNwbGF5ICE9PSBcIm5vbmVcIiApIHtcblx0XHRcdFx0dmFsdWVzWyBpbmRleCBdID0gXCJub25lXCI7XG5cblx0XHRcdFx0Ly8gUmVtZW1iZXIgd2hhdCB3ZSdyZSBvdmVyd3JpdGluZ1xuXHRcdFx0XHRkYXRhUHJpdi5zZXQoIGVsZW0sIFwiZGlzcGxheVwiLCBkaXNwbGF5ICk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0Ly8gU2V0IHRoZSBkaXNwbGF5IG9mIHRoZSBlbGVtZW50cyBpbiBhIHNlY29uZCBsb29wIHRvIGF2b2lkIGNvbnN0YW50IHJlZmxvd1xuXHRmb3IgKCBpbmRleCA9IDA7IGluZGV4IDwgbGVuZ3RoOyBpbmRleCsrICkge1xuXHRcdGlmICggdmFsdWVzWyBpbmRleCBdICE9IG51bGwgKSB7XG5cdFx0XHRlbGVtZW50c1sgaW5kZXggXS5zdHlsZS5kaXNwbGF5ID0gdmFsdWVzWyBpbmRleCBdO1xuXHRcdH1cblx0fVxuXG5cdHJldHVybiBlbGVtZW50cztcbn1cblxualF1ZXJ5LmZuLmV4dGVuZCgge1xuXHRzaG93OiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gc2hvd0hpZGUoIHRoaXMsIHRydWUgKTtcblx0fSxcblx0aGlkZTogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHNob3dIaWRlKCB0aGlzICk7XG5cdH0sXG5cdHRvZ2dsZTogZnVuY3Rpb24oIHN0YXRlICkge1xuXHRcdGlmICggdHlwZW9mIHN0YXRlID09PSBcImJvb2xlYW5cIiApIHtcblx0XHRcdHJldHVybiBzdGF0ZSA/IHRoaXMuc2hvdygpIDogdGhpcy5oaWRlKCk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRoaXMuZWFjaCggZnVuY3Rpb24oKSB7XG5cdFx0XHRpZiAoIGlzSGlkZGVuV2l0aGluVHJlZSggdGhpcyApICkge1xuXHRcdFx0XHRqUXVlcnkoIHRoaXMgKS5zaG93KCk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRqUXVlcnkoIHRoaXMgKS5oaWRlKCk7XG5cdFx0XHR9XG5cdFx0fSApO1xuXHR9XG59ICk7XG52YXIgcmNoZWNrYWJsZVR5cGUgPSAoIC9eKD86Y2hlY2tib3h8cmFkaW8pJC9pICk7XG5cbnZhciBydGFnTmFtZSA9ICggLzwoW2Etel1bXlxcL1xcMD5cXHgyMFxcdFxcclxcblxcZl0qKS9pICk7XG5cbnZhciByc2NyaXB0VHlwZSA9ICggL14kfF5tb2R1bGUkfFxcLyg/OmphdmF8ZWNtYSlzY3JpcHQvaSApO1xuXG5cblxuLy8gV2UgaGF2ZSB0byBjbG9zZSB0aGVzZSB0YWdzIHRvIHN1cHBvcnQgWEhUTUwgKCMxMzIwMClcbnZhciB3cmFwTWFwID0ge1xuXG5cdC8vIFN1cHBvcnQ6IElFIDw9OSBvbmx5XG5cdG9wdGlvbjogWyAxLCBcIjxzZWxlY3QgbXVsdGlwbGU9J211bHRpcGxlJz5cIiwgXCI8L3NlbGVjdD5cIiBdLFxuXG5cdC8vIFhIVE1MIHBhcnNlcnMgZG8gbm90IG1hZ2ljYWxseSBpbnNlcnQgZWxlbWVudHMgaW4gdGhlXG5cdC8vIHNhbWUgd2F5IHRoYXQgdGFnIHNvdXAgcGFyc2VycyBkby4gU28gd2UgY2Fubm90IHNob3J0ZW5cblx0Ly8gdGhpcyBieSBvbWl0dGluZyA8dGJvZHk+IG9yIG90aGVyIHJlcXVpcmVkIGVsZW1lbnRzLlxuXHR0aGVhZDogWyAxLCBcIjx0YWJsZT5cIiwgXCI8L3RhYmxlPlwiIF0sXG5cdGNvbDogWyAyLCBcIjx0YWJsZT48Y29sZ3JvdXA+XCIsIFwiPC9jb2xncm91cD48L3RhYmxlPlwiIF0sXG5cdHRyOiBbIDIsIFwiPHRhYmxlPjx0Ym9keT5cIiwgXCI8L3Rib2R5PjwvdGFibGU+XCIgXSxcblx0dGQ6IFsgMywgXCI8dGFibGU+PHRib2R5Pjx0cj5cIiwgXCI8L3RyPjwvdGJvZHk+PC90YWJsZT5cIiBdLFxuXG5cdF9kZWZhdWx0OiBbIDAsIFwiXCIsIFwiXCIgXVxufTtcblxuLy8gU3VwcG9ydDogSUUgPD05IG9ubHlcbndyYXBNYXAub3B0Z3JvdXAgPSB3cmFwTWFwLm9wdGlvbjtcblxud3JhcE1hcC50Ym9keSA9IHdyYXBNYXAudGZvb3QgPSB3cmFwTWFwLmNvbGdyb3VwID0gd3JhcE1hcC5jYXB0aW9uID0gd3JhcE1hcC50aGVhZDtcbndyYXBNYXAudGggPSB3cmFwTWFwLnRkO1xuXG5cbmZ1bmN0aW9uIGdldEFsbCggY29udGV4dCwgdGFnICkge1xuXG5cdC8vIFN1cHBvcnQ6IElFIDw9OSAtIDExIG9ubHlcblx0Ly8gVXNlIHR5cGVvZiB0byBhdm9pZCB6ZXJvLWFyZ3VtZW50IG1ldGhvZCBpbnZvY2F0aW9uIG9uIGhvc3Qgb2JqZWN0cyAoIzE1MTUxKVxuXHR2YXIgcmV0O1xuXG5cdGlmICggdHlwZW9mIGNvbnRleHQuZ2V0RWxlbWVudHNCeVRhZ05hbWUgIT09IFwidW5kZWZpbmVkXCIgKSB7XG5cdFx0cmV0ID0gY29udGV4dC5nZXRFbGVtZW50c0J5VGFnTmFtZSggdGFnIHx8IFwiKlwiICk7XG5cblx0fSBlbHNlIGlmICggdHlwZW9mIGNvbnRleHQucXVlcnlTZWxlY3RvckFsbCAhPT0gXCJ1bmRlZmluZWRcIiApIHtcblx0XHRyZXQgPSBjb250ZXh0LnF1ZXJ5U2VsZWN0b3JBbGwoIHRhZyB8fCBcIipcIiApO1xuXG5cdH0gZWxzZSB7XG5cdFx0cmV0ID0gW107XG5cdH1cblxuXHRpZiAoIHRhZyA9PT0gdW5kZWZpbmVkIHx8IHRhZyAmJiBub2RlTmFtZSggY29udGV4dCwgdGFnICkgKSB7XG5cdFx0cmV0dXJuIGpRdWVyeS5tZXJnZSggWyBjb250ZXh0IF0sIHJldCApO1xuXHR9XG5cblx0cmV0dXJuIHJldDtcbn1cblxuXG4vLyBNYXJrIHNjcmlwdHMgYXMgaGF2aW5nIGFscmVhZHkgYmVlbiBldmFsdWF0ZWRcbmZ1bmN0aW9uIHNldEdsb2JhbEV2YWwoIGVsZW1zLCByZWZFbGVtZW50cyApIHtcblx0dmFyIGkgPSAwLFxuXHRcdGwgPSBlbGVtcy5sZW5ndGg7XG5cblx0Zm9yICggOyBpIDwgbDsgaSsrICkge1xuXHRcdGRhdGFQcml2LnNldChcblx0XHRcdGVsZW1zWyBpIF0sXG5cdFx0XHRcImdsb2JhbEV2YWxcIixcblx0XHRcdCFyZWZFbGVtZW50cyB8fCBkYXRhUHJpdi5nZXQoIHJlZkVsZW1lbnRzWyBpIF0sIFwiZ2xvYmFsRXZhbFwiIClcblx0XHQpO1xuXHR9XG59XG5cblxudmFyIHJodG1sID0gLzx8JiM/XFx3KzsvO1xuXG5mdW5jdGlvbiBidWlsZEZyYWdtZW50KCBlbGVtcywgY29udGV4dCwgc2NyaXB0cywgc2VsZWN0aW9uLCBpZ25vcmVkICkge1xuXHR2YXIgZWxlbSwgdG1wLCB0YWcsIHdyYXAsIGF0dGFjaGVkLCBqLFxuXHRcdGZyYWdtZW50ID0gY29udGV4dC5jcmVhdGVEb2N1bWVudEZyYWdtZW50KCksXG5cdFx0bm9kZXMgPSBbXSxcblx0XHRpID0gMCxcblx0XHRsID0gZWxlbXMubGVuZ3RoO1xuXG5cdGZvciAoIDsgaSA8IGw7IGkrKyApIHtcblx0XHRlbGVtID0gZWxlbXNbIGkgXTtcblxuXHRcdGlmICggZWxlbSB8fCBlbGVtID09PSAwICkge1xuXG5cdFx0XHQvLyBBZGQgbm9kZXMgZGlyZWN0bHlcblx0XHRcdGlmICggdG9UeXBlKCBlbGVtICkgPT09IFwib2JqZWN0XCIgKSB7XG5cblx0XHRcdFx0Ly8gU3VwcG9ydDogQW5kcm9pZCA8PTQuMCBvbmx5LCBQaGFudG9tSlMgMSBvbmx5XG5cdFx0XHRcdC8vIHB1c2guYXBwbHkoXywgYXJyYXlsaWtlKSB0aHJvd3Mgb24gYW5jaWVudCBXZWJLaXRcblx0XHRcdFx0alF1ZXJ5Lm1lcmdlKCBub2RlcywgZWxlbS5ub2RlVHlwZSA/IFsgZWxlbSBdIDogZWxlbSApO1xuXG5cdFx0XHQvLyBDb252ZXJ0IG5vbi1odG1sIGludG8gYSB0ZXh0IG5vZGVcblx0XHRcdH0gZWxzZSBpZiAoICFyaHRtbC50ZXN0KCBlbGVtICkgKSB7XG5cdFx0XHRcdG5vZGVzLnB1c2goIGNvbnRleHQuY3JlYXRlVGV4dE5vZGUoIGVsZW0gKSApO1xuXG5cdFx0XHQvLyBDb252ZXJ0IGh0bWwgaW50byBET00gbm9kZXNcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHRtcCA9IHRtcCB8fCBmcmFnbWVudC5hcHBlbmRDaGlsZCggY29udGV4dC5jcmVhdGVFbGVtZW50KCBcImRpdlwiICkgKTtcblxuXHRcdFx0XHQvLyBEZXNlcmlhbGl6ZSBhIHN0YW5kYXJkIHJlcHJlc2VudGF0aW9uXG5cdFx0XHRcdHRhZyA9ICggcnRhZ05hbWUuZXhlYyggZWxlbSApIHx8IFsgXCJcIiwgXCJcIiBdIClbIDEgXS50b0xvd2VyQ2FzZSgpO1xuXHRcdFx0XHR3cmFwID0gd3JhcE1hcFsgdGFnIF0gfHwgd3JhcE1hcC5fZGVmYXVsdDtcblx0XHRcdFx0dG1wLmlubmVySFRNTCA9IHdyYXBbIDEgXSArIGpRdWVyeS5odG1sUHJlZmlsdGVyKCBlbGVtICkgKyB3cmFwWyAyIF07XG5cblx0XHRcdFx0Ly8gRGVzY2VuZCB0aHJvdWdoIHdyYXBwZXJzIHRvIHRoZSByaWdodCBjb250ZW50XG5cdFx0XHRcdGogPSB3cmFwWyAwIF07XG5cdFx0XHRcdHdoaWxlICggai0tICkge1xuXHRcdFx0XHRcdHRtcCA9IHRtcC5sYXN0Q2hpbGQ7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBTdXBwb3J0OiBBbmRyb2lkIDw9NC4wIG9ubHksIFBoYW50b21KUyAxIG9ubHlcblx0XHRcdFx0Ly8gcHVzaC5hcHBseShfLCBhcnJheWxpa2UpIHRocm93cyBvbiBhbmNpZW50IFdlYktpdFxuXHRcdFx0XHRqUXVlcnkubWVyZ2UoIG5vZGVzLCB0bXAuY2hpbGROb2RlcyApO1xuXG5cdFx0XHRcdC8vIFJlbWVtYmVyIHRoZSB0b3AtbGV2ZWwgY29udGFpbmVyXG5cdFx0XHRcdHRtcCA9IGZyYWdtZW50LmZpcnN0Q2hpbGQ7XG5cblx0XHRcdFx0Ly8gRW5zdXJlIHRoZSBjcmVhdGVkIG5vZGVzIGFyZSBvcnBoYW5lZCAoIzEyMzkyKVxuXHRcdFx0XHR0bXAudGV4dENvbnRlbnQgPSBcIlwiO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdC8vIFJlbW92ZSB3cmFwcGVyIGZyb20gZnJhZ21lbnRcblx0ZnJhZ21lbnQudGV4dENvbnRlbnQgPSBcIlwiO1xuXG5cdGkgPSAwO1xuXHR3aGlsZSAoICggZWxlbSA9IG5vZGVzWyBpKysgXSApICkge1xuXG5cdFx0Ly8gU2tpcCBlbGVtZW50cyBhbHJlYWR5IGluIHRoZSBjb250ZXh0IGNvbGxlY3Rpb24gKHRyYWMtNDA4Nylcblx0XHRpZiAoIHNlbGVjdGlvbiAmJiBqUXVlcnkuaW5BcnJheSggZWxlbSwgc2VsZWN0aW9uICkgPiAtMSApIHtcblx0XHRcdGlmICggaWdub3JlZCApIHtcblx0XHRcdFx0aWdub3JlZC5wdXNoKCBlbGVtICk7XG5cdFx0XHR9XG5cdFx0XHRjb250aW51ZTtcblx0XHR9XG5cblx0XHRhdHRhY2hlZCA9IGlzQXR0YWNoZWQoIGVsZW0gKTtcblxuXHRcdC8vIEFwcGVuZCB0byBmcmFnbWVudFxuXHRcdHRtcCA9IGdldEFsbCggZnJhZ21lbnQuYXBwZW5kQ2hpbGQoIGVsZW0gKSwgXCJzY3JpcHRcIiApO1xuXG5cdFx0Ly8gUHJlc2VydmUgc2NyaXB0IGV2YWx1YXRpb24gaGlzdG9yeVxuXHRcdGlmICggYXR0YWNoZWQgKSB7XG5cdFx0XHRzZXRHbG9iYWxFdmFsKCB0bXAgKTtcblx0XHR9XG5cblx0XHQvLyBDYXB0dXJlIGV4ZWN1dGFibGVzXG5cdFx0aWYgKCBzY3JpcHRzICkge1xuXHRcdFx0aiA9IDA7XG5cdFx0XHR3aGlsZSAoICggZWxlbSA9IHRtcFsgaisrIF0gKSApIHtcblx0XHRcdFx0aWYgKCByc2NyaXB0VHlwZS50ZXN0KCBlbGVtLnR5cGUgfHwgXCJcIiApICkge1xuXHRcdFx0XHRcdHNjcmlwdHMucHVzaCggZWxlbSApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0cmV0dXJuIGZyYWdtZW50O1xufVxuXG5cbiggZnVuY3Rpb24oKSB7XG5cdHZhciBmcmFnbWVudCA9IGRvY3VtZW50LmNyZWF0ZURvY3VtZW50RnJhZ21lbnQoKSxcblx0XHRkaXYgPSBmcmFnbWVudC5hcHBlbmRDaGlsZCggZG9jdW1lbnQuY3JlYXRlRWxlbWVudCggXCJkaXZcIiApICksXG5cdFx0aW5wdXQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCBcImlucHV0XCIgKTtcblxuXHQvLyBTdXBwb3J0OiBBbmRyb2lkIDQuMCAtIDQuMyBvbmx5XG5cdC8vIENoZWNrIHN0YXRlIGxvc3QgaWYgdGhlIG5hbWUgaXMgc2V0ICgjMTEyMTcpXG5cdC8vIFN1cHBvcnQ6IFdpbmRvd3MgV2ViIEFwcHMgKFdXQSlcblx0Ly8gYG5hbWVgIGFuZCBgdHlwZWAgbXVzdCB1c2UgLnNldEF0dHJpYnV0ZSBmb3IgV1dBICgjMTQ5MDEpXG5cdGlucHV0LnNldEF0dHJpYnV0ZSggXCJ0eXBlXCIsIFwicmFkaW9cIiApO1xuXHRpbnB1dC5zZXRBdHRyaWJ1dGUoIFwiY2hlY2tlZFwiLCBcImNoZWNrZWRcIiApO1xuXHRpbnB1dC5zZXRBdHRyaWJ1dGUoIFwibmFtZVwiLCBcInRcIiApO1xuXG5cdGRpdi5hcHBlbmRDaGlsZCggaW5wdXQgKTtcblxuXHQvLyBTdXBwb3J0OiBBbmRyb2lkIDw9NC4xIG9ubHlcblx0Ly8gT2xkZXIgV2ViS2l0IGRvZXNuJ3QgY2xvbmUgY2hlY2tlZCBzdGF0ZSBjb3JyZWN0bHkgaW4gZnJhZ21lbnRzXG5cdHN1cHBvcnQuY2hlY2tDbG9uZSA9IGRpdi5jbG9uZU5vZGUoIHRydWUgKS5jbG9uZU5vZGUoIHRydWUgKS5sYXN0Q2hpbGQuY2hlY2tlZDtcblxuXHQvLyBTdXBwb3J0OiBJRSA8PTExIG9ubHlcblx0Ly8gTWFrZSBzdXJlIHRleHRhcmVhIChhbmQgY2hlY2tib3gpIGRlZmF1bHRWYWx1ZSBpcyBwcm9wZXJseSBjbG9uZWRcblx0ZGl2LmlubmVySFRNTCA9IFwiPHRleHRhcmVhPng8L3RleHRhcmVhPlwiO1xuXHRzdXBwb3J0Lm5vQ2xvbmVDaGVja2VkID0gISFkaXYuY2xvbmVOb2RlKCB0cnVlICkubGFzdENoaWxkLmRlZmF1bHRWYWx1ZTtcbn0gKSgpO1xuXG5cbnZhclxuXHRya2V5RXZlbnQgPSAvXmtleS8sXG5cdHJtb3VzZUV2ZW50ID0gL14oPzptb3VzZXxwb2ludGVyfGNvbnRleHRtZW51fGRyYWd8ZHJvcCl8Y2xpY2svLFxuXHRydHlwZW5hbWVzcGFjZSA9IC9eKFteLl0qKSg/OlxcLiguKyl8KS87XG5cbmZ1bmN0aW9uIHJldHVyblRydWUoKSB7XG5cdHJldHVybiB0cnVlO1xufVxuXG5mdW5jdGlvbiByZXR1cm5GYWxzZSgpIHtcblx0cmV0dXJuIGZhbHNlO1xufVxuXG4vLyBTdXBwb3J0OiBJRSA8PTkgLSAxMStcbi8vIGZvY3VzKCkgYW5kIGJsdXIoKSBhcmUgYXN5bmNocm9ub3VzLCBleGNlcHQgd2hlbiB0aGV5IGFyZSBuby1vcC5cbi8vIFNvIGV4cGVjdCBmb2N1cyB0byBiZSBzeW5jaHJvbm91cyB3aGVuIHRoZSBlbGVtZW50IGlzIGFscmVhZHkgYWN0aXZlLFxuLy8gYW5kIGJsdXIgdG8gYmUgc3luY2hyb25vdXMgd2hlbiB0aGUgZWxlbWVudCBpcyBub3QgYWxyZWFkeSBhY3RpdmUuXG4vLyAoZm9jdXMgYW5kIGJsdXIgYXJlIGFsd2F5cyBzeW5jaHJvbm91cyBpbiBvdGhlciBzdXBwb3J0ZWQgYnJvd3NlcnMsXG4vLyB0aGlzIGp1c3QgZGVmaW5lcyB3aGVuIHdlIGNhbiBjb3VudCBvbiBpdCkuXG5mdW5jdGlvbiBleHBlY3RTeW5jKCBlbGVtLCB0eXBlICkge1xuXHRyZXR1cm4gKCBlbGVtID09PSBzYWZlQWN0aXZlRWxlbWVudCgpICkgPT09ICggdHlwZSA9PT0gXCJmb2N1c1wiICk7XG59XG5cbi8vIFN1cHBvcnQ6IElFIDw9OSBvbmx5XG4vLyBBY2Nlc3NpbmcgZG9jdW1lbnQuYWN0aXZlRWxlbWVudCBjYW4gdGhyb3cgdW5leHBlY3RlZGx5XG4vLyBodHRwczovL2J1Z3MuanF1ZXJ5LmNvbS90aWNrZXQvMTMzOTNcbmZ1bmN0aW9uIHNhZmVBY3RpdmVFbGVtZW50KCkge1xuXHR0cnkge1xuXHRcdHJldHVybiBkb2N1bWVudC5hY3RpdmVFbGVtZW50O1xuXHR9IGNhdGNoICggZXJyICkgeyB9XG59XG5cbmZ1bmN0aW9uIG9uKCBlbGVtLCB0eXBlcywgc2VsZWN0b3IsIGRhdGEsIGZuLCBvbmUgKSB7XG5cdHZhciBvcmlnRm4sIHR5cGU7XG5cblx0Ly8gVHlwZXMgY2FuIGJlIGEgbWFwIG9mIHR5cGVzL2hhbmRsZXJzXG5cdGlmICggdHlwZW9mIHR5cGVzID09PSBcIm9iamVjdFwiICkge1xuXG5cdFx0Ly8gKCB0eXBlcy1PYmplY3QsIHNlbGVjdG9yLCBkYXRhIClcblx0XHRpZiAoIHR5cGVvZiBzZWxlY3RvciAhPT0gXCJzdHJpbmdcIiApIHtcblxuXHRcdFx0Ly8gKCB0eXBlcy1PYmplY3QsIGRhdGEgKVxuXHRcdFx0ZGF0YSA9IGRhdGEgfHwgc2VsZWN0b3I7XG5cdFx0XHRzZWxlY3RvciA9IHVuZGVmaW5lZDtcblx0XHR9XG5cdFx0Zm9yICggdHlwZSBpbiB0eXBlcyApIHtcblx0XHRcdG9uKCBlbGVtLCB0eXBlLCBzZWxlY3RvciwgZGF0YSwgdHlwZXNbIHR5cGUgXSwgb25lICk7XG5cdFx0fVxuXHRcdHJldHVybiBlbGVtO1xuXHR9XG5cblx0aWYgKCBkYXRhID09IG51bGwgJiYgZm4gPT0gbnVsbCApIHtcblxuXHRcdC8vICggdHlwZXMsIGZuIClcblx0XHRmbiA9IHNlbGVjdG9yO1xuXHRcdGRhdGEgPSBzZWxlY3RvciA9IHVuZGVmaW5lZDtcblx0fSBlbHNlIGlmICggZm4gPT0gbnVsbCApIHtcblx0XHRpZiAoIHR5cGVvZiBzZWxlY3RvciA9PT0gXCJzdHJpbmdcIiApIHtcblxuXHRcdFx0Ly8gKCB0eXBlcywgc2VsZWN0b3IsIGZuIClcblx0XHRcdGZuID0gZGF0YTtcblx0XHRcdGRhdGEgPSB1bmRlZmluZWQ7XG5cdFx0fSBlbHNlIHtcblxuXHRcdFx0Ly8gKCB0eXBlcywgZGF0YSwgZm4gKVxuXHRcdFx0Zm4gPSBkYXRhO1xuXHRcdFx0ZGF0YSA9IHNlbGVjdG9yO1xuXHRcdFx0c2VsZWN0b3IgPSB1bmRlZmluZWQ7XG5cdFx0fVxuXHR9XG5cdGlmICggZm4gPT09IGZhbHNlICkge1xuXHRcdGZuID0gcmV0dXJuRmFsc2U7XG5cdH0gZWxzZSBpZiAoICFmbiApIHtcblx0XHRyZXR1cm4gZWxlbTtcblx0fVxuXG5cdGlmICggb25lID09PSAxICkge1xuXHRcdG9yaWdGbiA9IGZuO1xuXHRcdGZuID0gZnVuY3Rpb24oIGV2ZW50ICkge1xuXG5cdFx0XHQvLyBDYW4gdXNlIGFuIGVtcHR5IHNldCwgc2luY2UgZXZlbnQgY29udGFpbnMgdGhlIGluZm9cblx0XHRcdGpRdWVyeSgpLm9mZiggZXZlbnQgKTtcblx0XHRcdHJldHVybiBvcmlnRm4uYXBwbHkoIHRoaXMsIGFyZ3VtZW50cyApO1xuXHRcdH07XG5cblx0XHQvLyBVc2Ugc2FtZSBndWlkIHNvIGNhbGxlciBjYW4gcmVtb3ZlIHVzaW5nIG9yaWdGblxuXHRcdGZuLmd1aWQgPSBvcmlnRm4uZ3VpZCB8fCAoIG9yaWdGbi5ndWlkID0galF1ZXJ5Lmd1aWQrKyApO1xuXHR9XG5cdHJldHVybiBlbGVtLmVhY2goIGZ1bmN0aW9uKCkge1xuXHRcdGpRdWVyeS5ldmVudC5hZGQoIHRoaXMsIHR5cGVzLCBmbiwgZGF0YSwgc2VsZWN0b3IgKTtcblx0fSApO1xufVxuXG4vKlxuICogSGVscGVyIGZ1bmN0aW9ucyBmb3IgbWFuYWdpbmcgZXZlbnRzIC0tIG5vdCBwYXJ0IG9mIHRoZSBwdWJsaWMgaW50ZXJmYWNlLlxuICogUHJvcHMgdG8gRGVhbiBFZHdhcmRzJyBhZGRFdmVudCBsaWJyYXJ5IGZvciBtYW55IG9mIHRoZSBpZGVhcy5cbiAqL1xualF1ZXJ5LmV2ZW50ID0ge1xuXG5cdGdsb2JhbDoge30sXG5cblx0YWRkOiBmdW5jdGlvbiggZWxlbSwgdHlwZXMsIGhhbmRsZXIsIGRhdGEsIHNlbGVjdG9yICkge1xuXG5cdFx0dmFyIGhhbmRsZU9iakluLCBldmVudEhhbmRsZSwgdG1wLFxuXHRcdFx0ZXZlbnRzLCB0LCBoYW5kbGVPYmosXG5cdFx0XHRzcGVjaWFsLCBoYW5kbGVycywgdHlwZSwgbmFtZXNwYWNlcywgb3JpZ1R5cGUsXG5cdFx0XHRlbGVtRGF0YSA9IGRhdGFQcml2LmdldCggZWxlbSApO1xuXG5cdFx0Ly8gRG9uJ3QgYXR0YWNoIGV2ZW50cyB0byBub0RhdGEgb3IgdGV4dC9jb21tZW50IG5vZGVzIChidXQgYWxsb3cgcGxhaW4gb2JqZWN0cylcblx0XHRpZiAoICFlbGVtRGF0YSApIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHQvLyBDYWxsZXIgY2FuIHBhc3MgaW4gYW4gb2JqZWN0IG9mIGN1c3RvbSBkYXRhIGluIGxpZXUgb2YgdGhlIGhhbmRsZXJcblx0XHRpZiAoIGhhbmRsZXIuaGFuZGxlciApIHtcblx0XHRcdGhhbmRsZU9iakluID0gaGFuZGxlcjtcblx0XHRcdGhhbmRsZXIgPSBoYW5kbGVPYmpJbi5oYW5kbGVyO1xuXHRcdFx0c2VsZWN0b3IgPSBoYW5kbGVPYmpJbi5zZWxlY3Rvcjtcblx0XHR9XG5cblx0XHQvLyBFbnN1cmUgdGhhdCBpbnZhbGlkIHNlbGVjdG9ycyB0aHJvdyBleGNlcHRpb25zIGF0IGF0dGFjaCB0aW1lXG5cdFx0Ly8gRXZhbHVhdGUgYWdhaW5zdCBkb2N1bWVudEVsZW1lbnQgaW4gY2FzZSBlbGVtIGlzIGEgbm9uLWVsZW1lbnQgbm9kZSAoZS5nLiwgZG9jdW1lbnQpXG5cdFx0aWYgKCBzZWxlY3RvciApIHtcblx0XHRcdGpRdWVyeS5maW5kLm1hdGNoZXNTZWxlY3RvciggZG9jdW1lbnRFbGVtZW50LCBzZWxlY3RvciApO1xuXHRcdH1cblxuXHRcdC8vIE1ha2Ugc3VyZSB0aGF0IHRoZSBoYW5kbGVyIGhhcyBhIHVuaXF1ZSBJRCwgdXNlZCB0byBmaW5kL3JlbW92ZSBpdCBsYXRlclxuXHRcdGlmICggIWhhbmRsZXIuZ3VpZCApIHtcblx0XHRcdGhhbmRsZXIuZ3VpZCA9IGpRdWVyeS5ndWlkKys7XG5cdFx0fVxuXG5cdFx0Ly8gSW5pdCB0aGUgZWxlbWVudCdzIGV2ZW50IHN0cnVjdHVyZSBhbmQgbWFpbiBoYW5kbGVyLCBpZiB0aGlzIGlzIHRoZSBmaXJzdFxuXHRcdGlmICggISggZXZlbnRzID0gZWxlbURhdGEuZXZlbnRzICkgKSB7XG5cdFx0XHRldmVudHMgPSBlbGVtRGF0YS5ldmVudHMgPSB7fTtcblx0XHR9XG5cdFx0aWYgKCAhKCBldmVudEhhbmRsZSA9IGVsZW1EYXRhLmhhbmRsZSApICkge1xuXHRcdFx0ZXZlbnRIYW5kbGUgPSBlbGVtRGF0YS5oYW5kbGUgPSBmdW5jdGlvbiggZSApIHtcblxuXHRcdFx0XHQvLyBEaXNjYXJkIHRoZSBzZWNvbmQgZXZlbnQgb2YgYSBqUXVlcnkuZXZlbnQudHJpZ2dlcigpIGFuZFxuXHRcdFx0XHQvLyB3aGVuIGFuIGV2ZW50IGlzIGNhbGxlZCBhZnRlciBhIHBhZ2UgaGFzIHVubG9hZGVkXG5cdFx0XHRcdHJldHVybiB0eXBlb2YgalF1ZXJ5ICE9PSBcInVuZGVmaW5lZFwiICYmIGpRdWVyeS5ldmVudC50cmlnZ2VyZWQgIT09IGUudHlwZSA/XG5cdFx0XHRcdFx0alF1ZXJ5LmV2ZW50LmRpc3BhdGNoLmFwcGx5KCBlbGVtLCBhcmd1bWVudHMgKSA6IHVuZGVmaW5lZDtcblx0XHRcdH07XG5cdFx0fVxuXG5cdFx0Ly8gSGFuZGxlIG11bHRpcGxlIGV2ZW50cyBzZXBhcmF0ZWQgYnkgYSBzcGFjZVxuXHRcdHR5cGVzID0gKCB0eXBlcyB8fCBcIlwiICkubWF0Y2goIHJub3RodG1sd2hpdGUgKSB8fCBbIFwiXCIgXTtcblx0XHR0ID0gdHlwZXMubGVuZ3RoO1xuXHRcdHdoaWxlICggdC0tICkge1xuXHRcdFx0dG1wID0gcnR5cGVuYW1lc3BhY2UuZXhlYyggdHlwZXNbIHQgXSApIHx8IFtdO1xuXHRcdFx0dHlwZSA9IG9yaWdUeXBlID0gdG1wWyAxIF07XG5cdFx0XHRuYW1lc3BhY2VzID0gKCB0bXBbIDIgXSB8fCBcIlwiICkuc3BsaXQoIFwiLlwiICkuc29ydCgpO1xuXG5cdFx0XHQvLyBUaGVyZSAqbXVzdCogYmUgYSB0eXBlLCBubyBhdHRhY2hpbmcgbmFtZXNwYWNlLW9ubHkgaGFuZGxlcnNcblx0XHRcdGlmICggIXR5cGUgKSB7XG5cdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBJZiBldmVudCBjaGFuZ2VzIGl0cyB0eXBlLCB1c2UgdGhlIHNwZWNpYWwgZXZlbnQgaGFuZGxlcnMgZm9yIHRoZSBjaGFuZ2VkIHR5cGVcblx0XHRcdHNwZWNpYWwgPSBqUXVlcnkuZXZlbnQuc3BlY2lhbFsgdHlwZSBdIHx8IHt9O1xuXG5cdFx0XHQvLyBJZiBzZWxlY3RvciBkZWZpbmVkLCBkZXRlcm1pbmUgc3BlY2lhbCBldmVudCBhcGkgdHlwZSwgb3RoZXJ3aXNlIGdpdmVuIHR5cGVcblx0XHRcdHR5cGUgPSAoIHNlbGVjdG9yID8gc3BlY2lhbC5kZWxlZ2F0ZVR5cGUgOiBzcGVjaWFsLmJpbmRUeXBlICkgfHwgdHlwZTtcblxuXHRcdFx0Ly8gVXBkYXRlIHNwZWNpYWwgYmFzZWQgb24gbmV3bHkgcmVzZXQgdHlwZVxuXHRcdFx0c3BlY2lhbCA9IGpRdWVyeS5ldmVudC5zcGVjaWFsWyB0eXBlIF0gfHwge307XG5cblx0XHRcdC8vIGhhbmRsZU9iaiBpcyBwYXNzZWQgdG8gYWxsIGV2ZW50IGhhbmRsZXJzXG5cdFx0XHRoYW5kbGVPYmogPSBqUXVlcnkuZXh0ZW5kKCB7XG5cdFx0XHRcdHR5cGU6IHR5cGUsXG5cdFx0XHRcdG9yaWdUeXBlOiBvcmlnVHlwZSxcblx0XHRcdFx0ZGF0YTogZGF0YSxcblx0XHRcdFx0aGFuZGxlcjogaGFuZGxlcixcblx0XHRcdFx0Z3VpZDogaGFuZGxlci5ndWlkLFxuXHRcdFx0XHRzZWxlY3Rvcjogc2VsZWN0b3IsXG5cdFx0XHRcdG5lZWRzQ29udGV4dDogc2VsZWN0b3IgJiYgalF1ZXJ5LmV4cHIubWF0Y2gubmVlZHNDb250ZXh0LnRlc3QoIHNlbGVjdG9yICksXG5cdFx0XHRcdG5hbWVzcGFjZTogbmFtZXNwYWNlcy5qb2luKCBcIi5cIiApXG5cdFx0XHR9LCBoYW5kbGVPYmpJbiApO1xuXG5cdFx0XHQvLyBJbml0IHRoZSBldmVudCBoYW5kbGVyIHF1ZXVlIGlmIHdlJ3JlIHRoZSBmaXJzdFxuXHRcdFx0aWYgKCAhKCBoYW5kbGVycyA9IGV2ZW50c1sgdHlwZSBdICkgKSB7XG5cdFx0XHRcdGhhbmRsZXJzID0gZXZlbnRzWyB0eXBlIF0gPSBbXTtcblx0XHRcdFx0aGFuZGxlcnMuZGVsZWdhdGVDb3VudCA9IDA7XG5cblx0XHRcdFx0Ly8gT25seSB1c2UgYWRkRXZlbnRMaXN0ZW5lciBpZiB0aGUgc3BlY2lhbCBldmVudHMgaGFuZGxlciByZXR1cm5zIGZhbHNlXG5cdFx0XHRcdGlmICggIXNwZWNpYWwuc2V0dXAgfHxcblx0XHRcdFx0XHRzcGVjaWFsLnNldHVwLmNhbGwoIGVsZW0sIGRhdGEsIG5hbWVzcGFjZXMsIGV2ZW50SGFuZGxlICkgPT09IGZhbHNlICkge1xuXG5cdFx0XHRcdFx0aWYgKCBlbGVtLmFkZEV2ZW50TGlzdGVuZXIgKSB7XG5cdFx0XHRcdFx0XHRlbGVtLmFkZEV2ZW50TGlzdGVuZXIoIHR5cGUsIGV2ZW50SGFuZGxlICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdGlmICggc3BlY2lhbC5hZGQgKSB7XG5cdFx0XHRcdHNwZWNpYWwuYWRkLmNhbGwoIGVsZW0sIGhhbmRsZU9iaiApO1xuXG5cdFx0XHRcdGlmICggIWhhbmRsZU9iai5oYW5kbGVyLmd1aWQgKSB7XG5cdFx0XHRcdFx0aGFuZGxlT2JqLmhhbmRsZXIuZ3VpZCA9IGhhbmRsZXIuZ3VpZDtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHQvLyBBZGQgdG8gdGhlIGVsZW1lbnQncyBoYW5kbGVyIGxpc3QsIGRlbGVnYXRlcyBpbiBmcm9udFxuXHRcdFx0aWYgKCBzZWxlY3RvciApIHtcblx0XHRcdFx0aGFuZGxlcnMuc3BsaWNlKCBoYW5kbGVycy5kZWxlZ2F0ZUNvdW50KyssIDAsIGhhbmRsZU9iaiApO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0aGFuZGxlcnMucHVzaCggaGFuZGxlT2JqICk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIEtlZXAgdHJhY2sgb2Ygd2hpY2ggZXZlbnRzIGhhdmUgZXZlciBiZWVuIHVzZWQsIGZvciBldmVudCBvcHRpbWl6YXRpb25cblx0XHRcdGpRdWVyeS5ldmVudC5nbG9iYWxbIHR5cGUgXSA9IHRydWU7XG5cdFx0fVxuXG5cdH0sXG5cblx0Ly8gRGV0YWNoIGFuIGV2ZW50IG9yIHNldCBvZiBldmVudHMgZnJvbSBhbiBlbGVtZW50XG5cdHJlbW92ZTogZnVuY3Rpb24oIGVsZW0sIHR5cGVzLCBoYW5kbGVyLCBzZWxlY3RvciwgbWFwcGVkVHlwZXMgKSB7XG5cblx0XHR2YXIgaiwgb3JpZ0NvdW50LCB0bXAsXG5cdFx0XHRldmVudHMsIHQsIGhhbmRsZU9iaixcblx0XHRcdHNwZWNpYWwsIGhhbmRsZXJzLCB0eXBlLCBuYW1lc3BhY2VzLCBvcmlnVHlwZSxcblx0XHRcdGVsZW1EYXRhID0gZGF0YVByaXYuaGFzRGF0YSggZWxlbSApICYmIGRhdGFQcml2LmdldCggZWxlbSApO1xuXG5cdFx0aWYgKCAhZWxlbURhdGEgfHwgISggZXZlbnRzID0gZWxlbURhdGEuZXZlbnRzICkgKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0Ly8gT25jZSBmb3IgZWFjaCB0eXBlLm5hbWVzcGFjZSBpbiB0eXBlczsgdHlwZSBtYXkgYmUgb21pdHRlZFxuXHRcdHR5cGVzID0gKCB0eXBlcyB8fCBcIlwiICkubWF0Y2goIHJub3RodG1sd2hpdGUgKSB8fCBbIFwiXCIgXTtcblx0XHR0ID0gdHlwZXMubGVuZ3RoO1xuXHRcdHdoaWxlICggdC0tICkge1xuXHRcdFx0dG1wID0gcnR5cGVuYW1lc3BhY2UuZXhlYyggdHlwZXNbIHQgXSApIHx8IFtdO1xuXHRcdFx0dHlwZSA9IG9yaWdUeXBlID0gdG1wWyAxIF07XG5cdFx0XHRuYW1lc3BhY2VzID0gKCB0bXBbIDIgXSB8fCBcIlwiICkuc3BsaXQoIFwiLlwiICkuc29ydCgpO1xuXG5cdFx0XHQvLyBVbmJpbmQgYWxsIGV2ZW50cyAob24gdGhpcyBuYW1lc3BhY2UsIGlmIHByb3ZpZGVkKSBmb3IgdGhlIGVsZW1lbnRcblx0XHRcdGlmICggIXR5cGUgKSB7XG5cdFx0XHRcdGZvciAoIHR5cGUgaW4gZXZlbnRzICkge1xuXHRcdFx0XHRcdGpRdWVyeS5ldmVudC5yZW1vdmUoIGVsZW0sIHR5cGUgKyB0eXBlc1sgdCBdLCBoYW5kbGVyLCBzZWxlY3RvciwgdHJ1ZSApO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0fVxuXG5cdFx0XHRzcGVjaWFsID0galF1ZXJ5LmV2ZW50LnNwZWNpYWxbIHR5cGUgXSB8fCB7fTtcblx0XHRcdHR5cGUgPSAoIHNlbGVjdG9yID8gc3BlY2lhbC5kZWxlZ2F0ZVR5cGUgOiBzcGVjaWFsLmJpbmRUeXBlICkgfHwgdHlwZTtcblx0XHRcdGhhbmRsZXJzID0gZXZlbnRzWyB0eXBlIF0gfHwgW107XG5cdFx0XHR0bXAgPSB0bXBbIDIgXSAmJlxuXHRcdFx0XHRuZXcgUmVnRXhwKCBcIihefFxcXFwuKVwiICsgbmFtZXNwYWNlcy5qb2luKCBcIlxcXFwuKD86LipcXFxcLnwpXCIgKSArIFwiKFxcXFwufCQpXCIgKTtcblxuXHRcdFx0Ly8gUmVtb3ZlIG1hdGNoaW5nIGV2ZW50c1xuXHRcdFx0b3JpZ0NvdW50ID0gaiA9IGhhbmRsZXJzLmxlbmd0aDtcblx0XHRcdHdoaWxlICggai0tICkge1xuXHRcdFx0XHRoYW5kbGVPYmogPSBoYW5kbGVyc1sgaiBdO1xuXG5cdFx0XHRcdGlmICggKCBtYXBwZWRUeXBlcyB8fCBvcmlnVHlwZSA9PT0gaGFuZGxlT2JqLm9yaWdUeXBlICkgJiZcblx0XHRcdFx0XHQoICFoYW5kbGVyIHx8IGhhbmRsZXIuZ3VpZCA9PT0gaGFuZGxlT2JqLmd1aWQgKSAmJlxuXHRcdFx0XHRcdCggIXRtcCB8fCB0bXAudGVzdCggaGFuZGxlT2JqLm5hbWVzcGFjZSApICkgJiZcblx0XHRcdFx0XHQoICFzZWxlY3RvciB8fCBzZWxlY3RvciA9PT0gaGFuZGxlT2JqLnNlbGVjdG9yIHx8XG5cdFx0XHRcdFx0XHRzZWxlY3RvciA9PT0gXCIqKlwiICYmIGhhbmRsZU9iai5zZWxlY3RvciApICkge1xuXHRcdFx0XHRcdGhhbmRsZXJzLnNwbGljZSggaiwgMSApO1xuXG5cdFx0XHRcdFx0aWYgKCBoYW5kbGVPYmouc2VsZWN0b3IgKSB7XG5cdFx0XHRcdFx0XHRoYW5kbGVycy5kZWxlZ2F0ZUNvdW50LS07XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGlmICggc3BlY2lhbC5yZW1vdmUgKSB7XG5cdFx0XHRcdFx0XHRzcGVjaWFsLnJlbW92ZS5jYWxsKCBlbGVtLCBoYW5kbGVPYmogKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0Ly8gUmVtb3ZlIGdlbmVyaWMgZXZlbnQgaGFuZGxlciBpZiB3ZSByZW1vdmVkIHNvbWV0aGluZyBhbmQgbm8gbW9yZSBoYW5kbGVycyBleGlzdFxuXHRcdFx0Ly8gKGF2b2lkcyBwb3RlbnRpYWwgZm9yIGVuZGxlc3MgcmVjdXJzaW9uIGR1cmluZyByZW1vdmFsIG9mIHNwZWNpYWwgZXZlbnQgaGFuZGxlcnMpXG5cdFx0XHRpZiAoIG9yaWdDb3VudCAmJiAhaGFuZGxlcnMubGVuZ3RoICkge1xuXHRcdFx0XHRpZiAoICFzcGVjaWFsLnRlYXJkb3duIHx8XG5cdFx0XHRcdFx0c3BlY2lhbC50ZWFyZG93bi5jYWxsKCBlbGVtLCBuYW1lc3BhY2VzLCBlbGVtRGF0YS5oYW5kbGUgKSA9PT0gZmFsc2UgKSB7XG5cblx0XHRcdFx0XHRqUXVlcnkucmVtb3ZlRXZlbnQoIGVsZW0sIHR5cGUsIGVsZW1EYXRhLmhhbmRsZSApO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0ZGVsZXRlIGV2ZW50c1sgdHlwZSBdO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIFJlbW92ZSBkYXRhIGFuZCB0aGUgZXhwYW5kbyBpZiBpdCdzIG5vIGxvbmdlciB1c2VkXG5cdFx0aWYgKCBqUXVlcnkuaXNFbXB0eU9iamVjdCggZXZlbnRzICkgKSB7XG5cdFx0XHRkYXRhUHJpdi5yZW1vdmUoIGVsZW0sIFwiaGFuZGxlIGV2ZW50c1wiICk7XG5cdFx0fVxuXHR9LFxuXG5cdGRpc3BhdGNoOiBmdW5jdGlvbiggbmF0aXZlRXZlbnQgKSB7XG5cblx0XHQvLyBNYWtlIGEgd3JpdGFibGUgalF1ZXJ5LkV2ZW50IGZyb20gdGhlIG5hdGl2ZSBldmVudCBvYmplY3Rcblx0XHR2YXIgZXZlbnQgPSBqUXVlcnkuZXZlbnQuZml4KCBuYXRpdmVFdmVudCApO1xuXG5cdFx0dmFyIGksIGosIHJldCwgbWF0Y2hlZCwgaGFuZGxlT2JqLCBoYW5kbGVyUXVldWUsXG5cdFx0XHRhcmdzID0gbmV3IEFycmF5KCBhcmd1bWVudHMubGVuZ3RoICksXG5cdFx0XHRoYW5kbGVycyA9ICggZGF0YVByaXYuZ2V0KCB0aGlzLCBcImV2ZW50c1wiICkgfHwge30gKVsgZXZlbnQudHlwZSBdIHx8IFtdLFxuXHRcdFx0c3BlY2lhbCA9IGpRdWVyeS5ldmVudC5zcGVjaWFsWyBldmVudC50eXBlIF0gfHwge307XG5cblx0XHQvLyBVc2UgdGhlIGZpeC1lZCBqUXVlcnkuRXZlbnQgcmF0aGVyIHRoYW4gdGhlIChyZWFkLW9ubHkpIG5hdGl2ZSBldmVudFxuXHRcdGFyZ3NbIDAgXSA9IGV2ZW50O1xuXG5cdFx0Zm9yICggaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKysgKSB7XG5cdFx0XHRhcmdzWyBpIF0gPSBhcmd1bWVudHNbIGkgXTtcblx0XHR9XG5cblx0XHRldmVudC5kZWxlZ2F0ZVRhcmdldCA9IHRoaXM7XG5cblx0XHQvLyBDYWxsIHRoZSBwcmVEaXNwYXRjaCBob29rIGZvciB0aGUgbWFwcGVkIHR5cGUsIGFuZCBsZXQgaXQgYmFpbCBpZiBkZXNpcmVkXG5cdFx0aWYgKCBzcGVjaWFsLnByZURpc3BhdGNoICYmIHNwZWNpYWwucHJlRGlzcGF0Y2guY2FsbCggdGhpcywgZXZlbnQgKSA9PT0gZmFsc2UgKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0Ly8gRGV0ZXJtaW5lIGhhbmRsZXJzXG5cdFx0aGFuZGxlclF1ZXVlID0galF1ZXJ5LmV2ZW50LmhhbmRsZXJzLmNhbGwoIHRoaXMsIGV2ZW50LCBoYW5kbGVycyApO1xuXG5cdFx0Ly8gUnVuIGRlbGVnYXRlcyBmaXJzdDsgdGhleSBtYXkgd2FudCB0byBzdG9wIHByb3BhZ2F0aW9uIGJlbmVhdGggdXNcblx0XHRpID0gMDtcblx0XHR3aGlsZSAoICggbWF0Y2hlZCA9IGhhbmRsZXJRdWV1ZVsgaSsrIF0gKSAmJiAhZXZlbnQuaXNQcm9wYWdhdGlvblN0b3BwZWQoKSApIHtcblx0XHRcdGV2ZW50LmN1cnJlbnRUYXJnZXQgPSBtYXRjaGVkLmVsZW07XG5cblx0XHRcdGogPSAwO1xuXHRcdFx0d2hpbGUgKCAoIGhhbmRsZU9iaiA9IG1hdGNoZWQuaGFuZGxlcnNbIGorKyBdICkgJiZcblx0XHRcdFx0IWV2ZW50LmlzSW1tZWRpYXRlUHJvcGFnYXRpb25TdG9wcGVkKCkgKSB7XG5cblx0XHRcdFx0Ly8gSWYgdGhlIGV2ZW50IGlzIG5hbWVzcGFjZWQsIHRoZW4gZWFjaCBoYW5kbGVyIGlzIG9ubHkgaW52b2tlZCBpZiBpdCBpc1xuXHRcdFx0XHQvLyBzcGVjaWFsbHkgdW5pdmVyc2FsIG9yIGl0cyBuYW1lc3BhY2VzIGFyZSBhIHN1cGVyc2V0IG9mIHRoZSBldmVudCdzLlxuXHRcdFx0XHRpZiAoICFldmVudC5ybmFtZXNwYWNlIHx8IGhhbmRsZU9iai5uYW1lc3BhY2UgPT09IGZhbHNlIHx8XG5cdFx0XHRcdFx0ZXZlbnQucm5hbWVzcGFjZS50ZXN0KCBoYW5kbGVPYmoubmFtZXNwYWNlICkgKSB7XG5cblx0XHRcdFx0XHRldmVudC5oYW5kbGVPYmogPSBoYW5kbGVPYmo7XG5cdFx0XHRcdFx0ZXZlbnQuZGF0YSA9IGhhbmRsZU9iai5kYXRhO1xuXG5cdFx0XHRcdFx0cmV0ID0gKCAoIGpRdWVyeS5ldmVudC5zcGVjaWFsWyBoYW5kbGVPYmoub3JpZ1R5cGUgXSB8fCB7fSApLmhhbmRsZSB8fFxuXHRcdFx0XHRcdFx0aGFuZGxlT2JqLmhhbmRsZXIgKS5hcHBseSggbWF0Y2hlZC5lbGVtLCBhcmdzICk7XG5cblx0XHRcdFx0XHRpZiAoIHJldCAhPT0gdW5kZWZpbmVkICkge1xuXHRcdFx0XHRcdFx0aWYgKCAoIGV2ZW50LnJlc3VsdCA9IHJldCApID09PSBmYWxzZSApIHtcblx0XHRcdFx0XHRcdFx0ZXZlbnQucHJldmVudERlZmF1bHQoKTtcblx0XHRcdFx0XHRcdFx0ZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gQ2FsbCB0aGUgcG9zdERpc3BhdGNoIGhvb2sgZm9yIHRoZSBtYXBwZWQgdHlwZVxuXHRcdGlmICggc3BlY2lhbC5wb3N0RGlzcGF0Y2ggKSB7XG5cdFx0XHRzcGVjaWFsLnBvc3REaXNwYXRjaC5jYWxsKCB0aGlzLCBldmVudCApO1xuXHRcdH1cblxuXHRcdHJldHVybiBldmVudC5yZXN1bHQ7XG5cdH0sXG5cblx0aGFuZGxlcnM6IGZ1bmN0aW9uKCBldmVudCwgaGFuZGxlcnMgKSB7XG5cdFx0dmFyIGksIGhhbmRsZU9iaiwgc2VsLCBtYXRjaGVkSGFuZGxlcnMsIG1hdGNoZWRTZWxlY3RvcnMsXG5cdFx0XHRoYW5kbGVyUXVldWUgPSBbXSxcblx0XHRcdGRlbGVnYXRlQ291bnQgPSBoYW5kbGVycy5kZWxlZ2F0ZUNvdW50LFxuXHRcdFx0Y3VyID0gZXZlbnQudGFyZ2V0O1xuXG5cdFx0Ly8gRmluZCBkZWxlZ2F0ZSBoYW5kbGVyc1xuXHRcdGlmICggZGVsZWdhdGVDb3VudCAmJlxuXG5cdFx0XHQvLyBTdXBwb3J0OiBJRSA8PTlcblx0XHRcdC8vIEJsYWNrLWhvbGUgU1ZHIDx1c2U+IGluc3RhbmNlIHRyZWVzICh0cmFjLTEzMTgwKVxuXHRcdFx0Y3VyLm5vZGVUeXBlICYmXG5cblx0XHRcdC8vIFN1cHBvcnQ6IEZpcmVmb3ggPD00MlxuXHRcdFx0Ly8gU3VwcHJlc3Mgc3BlYy12aW9sYXRpbmcgY2xpY2tzIGluZGljYXRpbmcgYSBub24tcHJpbWFyeSBwb2ludGVyIGJ1dHRvbiAodHJhYy0zODYxKVxuXHRcdFx0Ly8gaHR0cHM6Ly93d3cudzMub3JnL1RSL0RPTS1MZXZlbC0zLUV2ZW50cy8jZXZlbnQtdHlwZS1jbGlja1xuXHRcdFx0Ly8gU3VwcG9ydDogSUUgMTEgb25seVxuXHRcdFx0Ly8gLi4uYnV0IG5vdCBhcnJvdyBrZXkgXCJjbGlja3NcIiBvZiByYWRpbyBpbnB1dHMsIHdoaWNoIGNhbiBoYXZlIGBidXR0b25gIC0xIChnaC0yMzQzKVxuXHRcdFx0ISggZXZlbnQudHlwZSA9PT0gXCJjbGlja1wiICYmIGV2ZW50LmJ1dHRvbiA+PSAxICkgKSB7XG5cblx0XHRcdGZvciAoIDsgY3VyICE9PSB0aGlzOyBjdXIgPSBjdXIucGFyZW50Tm9kZSB8fCB0aGlzICkge1xuXG5cdFx0XHRcdC8vIERvbid0IGNoZWNrIG5vbi1lbGVtZW50cyAoIzEzMjA4KVxuXHRcdFx0XHQvLyBEb24ndCBwcm9jZXNzIGNsaWNrcyBvbiBkaXNhYmxlZCBlbGVtZW50cyAoIzY5MTEsICM4MTY1LCAjMTEzODIsICMxMTc2NClcblx0XHRcdFx0aWYgKCBjdXIubm9kZVR5cGUgPT09IDEgJiYgISggZXZlbnQudHlwZSA9PT0gXCJjbGlja1wiICYmIGN1ci5kaXNhYmxlZCA9PT0gdHJ1ZSApICkge1xuXHRcdFx0XHRcdG1hdGNoZWRIYW5kbGVycyA9IFtdO1xuXHRcdFx0XHRcdG1hdGNoZWRTZWxlY3RvcnMgPSB7fTtcblx0XHRcdFx0XHRmb3IgKCBpID0gMDsgaSA8IGRlbGVnYXRlQ291bnQ7IGkrKyApIHtcblx0XHRcdFx0XHRcdGhhbmRsZU9iaiA9IGhhbmRsZXJzWyBpIF07XG5cblx0XHRcdFx0XHRcdC8vIERvbid0IGNvbmZsaWN0IHdpdGggT2JqZWN0LnByb3RvdHlwZSBwcm9wZXJ0aWVzICgjMTMyMDMpXG5cdFx0XHRcdFx0XHRzZWwgPSBoYW5kbGVPYmouc2VsZWN0b3IgKyBcIiBcIjtcblxuXHRcdFx0XHRcdFx0aWYgKCBtYXRjaGVkU2VsZWN0b3JzWyBzZWwgXSA9PT0gdW5kZWZpbmVkICkge1xuXHRcdFx0XHRcdFx0XHRtYXRjaGVkU2VsZWN0b3JzWyBzZWwgXSA9IGhhbmRsZU9iai5uZWVkc0NvbnRleHQgP1xuXHRcdFx0XHRcdFx0XHRcdGpRdWVyeSggc2VsLCB0aGlzICkuaW5kZXgoIGN1ciApID4gLTEgOlxuXHRcdFx0XHRcdFx0XHRcdGpRdWVyeS5maW5kKCBzZWwsIHRoaXMsIG51bGwsIFsgY3VyIF0gKS5sZW5ndGg7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRpZiAoIG1hdGNoZWRTZWxlY3RvcnNbIHNlbCBdICkge1xuXHRcdFx0XHRcdFx0XHRtYXRjaGVkSGFuZGxlcnMucHVzaCggaGFuZGxlT2JqICk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGlmICggbWF0Y2hlZEhhbmRsZXJzLmxlbmd0aCApIHtcblx0XHRcdFx0XHRcdGhhbmRsZXJRdWV1ZS5wdXNoKCB7IGVsZW06IGN1ciwgaGFuZGxlcnM6IG1hdGNoZWRIYW5kbGVycyB9ICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gQWRkIHRoZSByZW1haW5pbmcgKGRpcmVjdGx5LWJvdW5kKSBoYW5kbGVyc1xuXHRcdGN1ciA9IHRoaXM7XG5cdFx0aWYgKCBkZWxlZ2F0ZUNvdW50IDwgaGFuZGxlcnMubGVuZ3RoICkge1xuXHRcdFx0aGFuZGxlclF1ZXVlLnB1c2goIHsgZWxlbTogY3VyLCBoYW5kbGVyczogaGFuZGxlcnMuc2xpY2UoIGRlbGVnYXRlQ291bnQgKSB9ICk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGhhbmRsZXJRdWV1ZTtcblx0fSxcblxuXHRhZGRQcm9wOiBmdW5jdGlvbiggbmFtZSwgaG9vayApIHtcblx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoIGpRdWVyeS5FdmVudC5wcm90b3R5cGUsIG5hbWUsIHtcblx0XHRcdGVudW1lcmFibGU6IHRydWUsXG5cdFx0XHRjb25maWd1cmFibGU6IHRydWUsXG5cblx0XHRcdGdldDogaXNGdW5jdGlvbiggaG9vayApID9cblx0XHRcdFx0ZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0aWYgKCB0aGlzLm9yaWdpbmFsRXZlbnQgKSB7XG5cdFx0XHRcdFx0XHRcdHJldHVybiBob29rKCB0aGlzLm9yaWdpbmFsRXZlbnQgKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0gOlxuXHRcdFx0XHRmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRpZiAoIHRoaXMub3JpZ2luYWxFdmVudCApIHtcblx0XHRcdFx0XHRcdFx0cmV0dXJuIHRoaXMub3JpZ2luYWxFdmVudFsgbmFtZSBdO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSxcblxuXHRcdFx0c2V0OiBmdW5jdGlvbiggdmFsdWUgKSB7XG5cdFx0XHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eSggdGhpcywgbmFtZSwge1xuXHRcdFx0XHRcdGVudW1lcmFibGU6IHRydWUsXG5cdFx0XHRcdFx0Y29uZmlndXJhYmxlOiB0cnVlLFxuXHRcdFx0XHRcdHdyaXRhYmxlOiB0cnVlLFxuXHRcdFx0XHRcdHZhbHVlOiB2YWx1ZVxuXHRcdFx0XHR9ICk7XG5cdFx0XHR9XG5cdFx0fSApO1xuXHR9LFxuXG5cdGZpeDogZnVuY3Rpb24oIG9yaWdpbmFsRXZlbnQgKSB7XG5cdFx0cmV0dXJuIG9yaWdpbmFsRXZlbnRbIGpRdWVyeS5leHBhbmRvIF0gP1xuXHRcdFx0b3JpZ2luYWxFdmVudCA6XG5cdFx0XHRuZXcgalF1ZXJ5LkV2ZW50KCBvcmlnaW5hbEV2ZW50ICk7XG5cdH0sXG5cblx0c3BlY2lhbDoge1xuXHRcdGxvYWQ6IHtcblxuXHRcdFx0Ly8gUHJldmVudCB0cmlnZ2VyZWQgaW1hZ2UubG9hZCBldmVudHMgZnJvbSBidWJibGluZyB0byB3aW5kb3cubG9hZFxuXHRcdFx0bm9CdWJibGU6IHRydWVcblx0XHR9LFxuXHRcdGNsaWNrOiB7XG5cblx0XHRcdC8vIFV0aWxpemUgbmF0aXZlIGV2ZW50IHRvIGVuc3VyZSBjb3JyZWN0IHN0YXRlIGZvciBjaGVja2FibGUgaW5wdXRzXG5cdFx0XHRzZXR1cDogZnVuY3Rpb24oIGRhdGEgKSB7XG5cblx0XHRcdFx0Ly8gRm9yIG11dHVhbCBjb21wcmVzc2liaWxpdHkgd2l0aCBfZGVmYXVsdCwgcmVwbGFjZSBgdGhpc2AgYWNjZXNzIHdpdGggYSBsb2NhbCB2YXIuXG5cdFx0XHRcdC8vIGB8fCBkYXRhYCBpcyBkZWFkIGNvZGUgbWVhbnQgb25seSB0byBwcmVzZXJ2ZSB0aGUgdmFyaWFibGUgdGhyb3VnaCBtaW5pZmljYXRpb24uXG5cdFx0XHRcdHZhciBlbCA9IHRoaXMgfHwgZGF0YTtcblxuXHRcdFx0XHQvLyBDbGFpbSB0aGUgZmlyc3QgaGFuZGxlclxuXHRcdFx0XHRpZiAoIHJjaGVja2FibGVUeXBlLnRlc3QoIGVsLnR5cGUgKSAmJlxuXHRcdFx0XHRcdGVsLmNsaWNrICYmIG5vZGVOYW1lKCBlbCwgXCJpbnB1dFwiICkgKSB7XG5cblx0XHRcdFx0XHQvLyBkYXRhUHJpdi5zZXQoIGVsLCBcImNsaWNrXCIsIC4uLiApXG5cdFx0XHRcdFx0bGV2ZXJhZ2VOYXRpdmUoIGVsLCBcImNsaWNrXCIsIHJldHVyblRydWUgKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIFJldHVybiBmYWxzZSB0byBhbGxvdyBub3JtYWwgcHJvY2Vzc2luZyBpbiB0aGUgY2FsbGVyXG5cdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdH0sXG5cdFx0XHR0cmlnZ2VyOiBmdW5jdGlvbiggZGF0YSApIHtcblxuXHRcdFx0XHQvLyBGb3IgbXV0dWFsIGNvbXByZXNzaWJpbGl0eSB3aXRoIF9kZWZhdWx0LCByZXBsYWNlIGB0aGlzYCBhY2Nlc3Mgd2l0aCBhIGxvY2FsIHZhci5cblx0XHRcdFx0Ly8gYHx8IGRhdGFgIGlzIGRlYWQgY29kZSBtZWFudCBvbmx5IHRvIHByZXNlcnZlIHRoZSB2YXJpYWJsZSB0aHJvdWdoIG1pbmlmaWNhdGlvbi5cblx0XHRcdFx0dmFyIGVsID0gdGhpcyB8fCBkYXRhO1xuXG5cdFx0XHRcdC8vIEZvcmNlIHNldHVwIGJlZm9yZSB0cmlnZ2VyaW5nIGEgY2xpY2tcblx0XHRcdFx0aWYgKCByY2hlY2thYmxlVHlwZS50ZXN0KCBlbC50eXBlICkgJiZcblx0XHRcdFx0XHRlbC5jbGljayAmJiBub2RlTmFtZSggZWwsIFwiaW5wdXRcIiApICkge1xuXG5cdFx0XHRcdFx0bGV2ZXJhZ2VOYXRpdmUoIGVsLCBcImNsaWNrXCIgKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIFJldHVybiBub24tZmFsc2UgdG8gYWxsb3cgbm9ybWFsIGV2ZW50LXBhdGggcHJvcGFnYXRpb25cblx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHR9LFxuXG5cdFx0XHQvLyBGb3IgY3Jvc3MtYnJvd3NlciBjb25zaXN0ZW5jeSwgc3VwcHJlc3MgbmF0aXZlIC5jbGljaygpIG9uIGxpbmtzXG5cdFx0XHQvLyBBbHNvIHByZXZlbnQgaXQgaWYgd2UncmUgY3VycmVudGx5IGluc2lkZSBhIGxldmVyYWdlZCBuYXRpdmUtZXZlbnQgc3RhY2tcblx0XHRcdF9kZWZhdWx0OiBmdW5jdGlvbiggZXZlbnQgKSB7XG5cdFx0XHRcdHZhciB0YXJnZXQgPSBldmVudC50YXJnZXQ7XG5cdFx0XHRcdHJldHVybiByY2hlY2thYmxlVHlwZS50ZXN0KCB0YXJnZXQudHlwZSApICYmXG5cdFx0XHRcdFx0dGFyZ2V0LmNsaWNrICYmIG5vZGVOYW1lKCB0YXJnZXQsIFwiaW5wdXRcIiApICYmXG5cdFx0XHRcdFx0ZGF0YVByaXYuZ2V0KCB0YXJnZXQsIFwiY2xpY2tcIiApIHx8XG5cdFx0XHRcdFx0bm9kZU5hbWUoIHRhcmdldCwgXCJhXCIgKTtcblx0XHRcdH1cblx0XHR9LFxuXG5cdFx0YmVmb3JldW5sb2FkOiB7XG5cdFx0XHRwb3N0RGlzcGF0Y2g6IGZ1bmN0aW9uKCBldmVudCApIHtcblxuXHRcdFx0XHQvLyBTdXBwb3J0OiBGaXJlZm94IDIwK1xuXHRcdFx0XHQvLyBGaXJlZm94IGRvZXNuJ3QgYWxlcnQgaWYgdGhlIHJldHVyblZhbHVlIGZpZWxkIGlzIG5vdCBzZXQuXG5cdFx0XHRcdGlmICggZXZlbnQucmVzdWx0ICE9PSB1bmRlZmluZWQgJiYgZXZlbnQub3JpZ2luYWxFdmVudCApIHtcblx0XHRcdFx0XHRldmVudC5vcmlnaW5hbEV2ZW50LnJldHVyblZhbHVlID0gZXZlbnQucmVzdWx0O1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG59O1xuXG4vLyBFbnN1cmUgdGhlIHByZXNlbmNlIG9mIGFuIGV2ZW50IGxpc3RlbmVyIHRoYXQgaGFuZGxlcyBtYW51YWxseS10cmlnZ2VyZWRcbi8vIHN5bnRoZXRpYyBldmVudHMgYnkgaW50ZXJydXB0aW5nIHByb2dyZXNzIHVudGlsIHJlaW52b2tlZCBpbiByZXNwb25zZSB0b1xuLy8gKm5hdGl2ZSogZXZlbnRzIHRoYXQgaXQgZmlyZXMgZGlyZWN0bHksIGVuc3VyaW5nIHRoYXQgc3RhdGUgY2hhbmdlcyBoYXZlXG4vLyBhbHJlYWR5IG9jY3VycmVkIGJlZm9yZSBvdGhlciBsaXN0ZW5lcnMgYXJlIGludm9rZWQuXG5mdW5jdGlvbiBsZXZlcmFnZU5hdGl2ZSggZWwsIHR5cGUsIGV4cGVjdFN5bmMgKSB7XG5cblx0Ly8gTWlzc2luZyBleHBlY3RTeW5jIGluZGljYXRlcyBhIHRyaWdnZXIgY2FsbCwgd2hpY2ggbXVzdCBmb3JjZSBzZXR1cCB0aHJvdWdoIGpRdWVyeS5ldmVudC5hZGRcblx0aWYgKCAhZXhwZWN0U3luYyApIHtcblx0XHRpZiAoIGRhdGFQcml2LmdldCggZWwsIHR5cGUgKSA9PT0gdW5kZWZpbmVkICkge1xuXHRcdFx0alF1ZXJ5LmV2ZW50LmFkZCggZWwsIHR5cGUsIHJldHVyblRydWUgKTtcblx0XHR9XG5cdFx0cmV0dXJuO1xuXHR9XG5cblx0Ly8gUmVnaXN0ZXIgdGhlIGNvbnRyb2xsZXIgYXMgYSBzcGVjaWFsIHVuaXZlcnNhbCBoYW5kbGVyIGZvciBhbGwgZXZlbnQgbmFtZXNwYWNlc1xuXHRkYXRhUHJpdi5zZXQoIGVsLCB0eXBlLCBmYWxzZSApO1xuXHRqUXVlcnkuZXZlbnQuYWRkKCBlbCwgdHlwZSwge1xuXHRcdG5hbWVzcGFjZTogZmFsc2UsXG5cdFx0aGFuZGxlcjogZnVuY3Rpb24oIGV2ZW50ICkge1xuXHRcdFx0dmFyIG5vdEFzeW5jLCByZXN1bHQsXG5cdFx0XHRcdHNhdmVkID0gZGF0YVByaXYuZ2V0KCB0aGlzLCB0eXBlICk7XG5cblx0XHRcdGlmICggKCBldmVudC5pc1RyaWdnZXIgJiAxICkgJiYgdGhpc1sgdHlwZSBdICkge1xuXG5cdFx0XHRcdC8vIEludGVycnVwdCBwcm9jZXNzaW5nIG9mIHRoZSBvdXRlciBzeW50aGV0aWMgLnRyaWdnZXIoKWVkIGV2ZW50XG5cdFx0XHRcdC8vIFNhdmVkIGRhdGEgc2hvdWxkIGJlIGZhbHNlIGluIHN1Y2ggY2FzZXMsIGJ1dCBtaWdodCBiZSBhIGxlZnRvdmVyIGNhcHR1cmUgb2JqZWN0XG5cdFx0XHRcdC8vIGZyb20gYW4gYXN5bmMgbmF0aXZlIGhhbmRsZXIgKGdoLTQzNTApXG5cdFx0XHRcdGlmICggIXNhdmVkLmxlbmd0aCApIHtcblxuXHRcdFx0XHRcdC8vIFN0b3JlIGFyZ3VtZW50cyBmb3IgdXNlIHdoZW4gaGFuZGxpbmcgdGhlIGlubmVyIG5hdGl2ZSBldmVudFxuXHRcdFx0XHRcdC8vIFRoZXJlIHdpbGwgYWx3YXlzIGJlIGF0IGxlYXN0IG9uZSBhcmd1bWVudCAoYW4gZXZlbnQgb2JqZWN0KSwgc28gdGhpcyBhcnJheVxuXHRcdFx0XHRcdC8vIHdpbGwgbm90IGJlIGNvbmZ1c2VkIHdpdGggYSBsZWZ0b3ZlciBjYXB0dXJlIG9iamVjdC5cblx0XHRcdFx0XHRzYXZlZCA9IHNsaWNlLmNhbGwoIGFyZ3VtZW50cyApO1xuXHRcdFx0XHRcdGRhdGFQcml2LnNldCggdGhpcywgdHlwZSwgc2F2ZWQgKTtcblxuXHRcdFx0XHRcdC8vIFRyaWdnZXIgdGhlIG5hdGl2ZSBldmVudCBhbmQgY2FwdHVyZSBpdHMgcmVzdWx0XG5cdFx0XHRcdFx0Ly8gU3VwcG9ydDogSUUgPD05IC0gMTErXG5cdFx0XHRcdFx0Ly8gZm9jdXMoKSBhbmQgYmx1cigpIGFyZSBhc3luY2hyb25vdXNcblx0XHRcdFx0XHRub3RBc3luYyA9IGV4cGVjdFN5bmMoIHRoaXMsIHR5cGUgKTtcblx0XHRcdFx0XHR0aGlzWyB0eXBlIF0oKTtcblx0XHRcdFx0XHRyZXN1bHQgPSBkYXRhUHJpdi5nZXQoIHRoaXMsIHR5cGUgKTtcblx0XHRcdFx0XHRpZiAoIHNhdmVkICE9PSByZXN1bHQgfHwgbm90QXN5bmMgKSB7XG5cdFx0XHRcdFx0XHRkYXRhUHJpdi5zZXQoIHRoaXMsIHR5cGUsIGZhbHNlICk7XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdHJlc3VsdCA9IHt9O1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRpZiAoIHNhdmVkICE9PSByZXN1bHQgKSB7XG5cblx0XHRcdFx0XHRcdC8vIENhbmNlbCB0aGUgb3V0ZXIgc3ludGhldGljIGV2ZW50XG5cdFx0XHRcdFx0XHRldmVudC5zdG9wSW1tZWRpYXRlUHJvcGFnYXRpb24oKTtcblx0XHRcdFx0XHRcdGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG5cdFx0XHRcdFx0XHRyZXR1cm4gcmVzdWx0LnZhbHVlO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBJZiB0aGlzIGlzIGFuIGlubmVyIHN5bnRoZXRpYyBldmVudCBmb3IgYW4gZXZlbnQgd2l0aCBhIGJ1YmJsaW5nIHN1cnJvZ2F0ZVxuXHRcdFx0XHQvLyAoZm9jdXMgb3IgYmx1ciksIGFzc3VtZSB0aGF0IHRoZSBzdXJyb2dhdGUgYWxyZWFkeSBwcm9wYWdhdGVkIGZyb20gdHJpZ2dlcmluZyB0aGVcblx0XHRcdFx0Ly8gbmF0aXZlIGV2ZW50IGFuZCBwcmV2ZW50IHRoYXQgZnJvbSBoYXBwZW5pbmcgYWdhaW4gaGVyZS5cblx0XHRcdFx0Ly8gVGhpcyB0ZWNobmljYWxseSBnZXRzIHRoZSBvcmRlcmluZyB3cm9uZyB3LnIudC4gdG8gYC50cmlnZ2VyKClgIChpbiB3aGljaCB0aGVcblx0XHRcdFx0Ly8gYnViYmxpbmcgc3Vycm9nYXRlIHByb3BhZ2F0ZXMgKmFmdGVyKiB0aGUgbm9uLWJ1YmJsaW5nIGJhc2UpLCBidXQgdGhhdCBzZWVtc1xuXHRcdFx0XHQvLyBsZXNzIGJhZCB0aGFuIGR1cGxpY2F0aW9uLlxuXHRcdFx0XHR9IGVsc2UgaWYgKCAoIGpRdWVyeS5ldmVudC5zcGVjaWFsWyB0eXBlIF0gfHwge30gKS5kZWxlZ2F0ZVR5cGUgKSB7XG5cdFx0XHRcdFx0ZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG5cdFx0XHRcdH1cblxuXHRcdFx0Ly8gSWYgdGhpcyBpcyBhIG5hdGl2ZSBldmVudCB0cmlnZ2VyZWQgYWJvdmUsIGV2ZXJ5dGhpbmcgaXMgbm93IGluIG9yZGVyXG5cdFx0XHQvLyBGaXJlIGFuIGlubmVyIHN5bnRoZXRpYyBldmVudCB3aXRoIHRoZSBvcmlnaW5hbCBhcmd1bWVudHNcblx0XHRcdH0gZWxzZSBpZiAoIHNhdmVkLmxlbmd0aCApIHtcblxuXHRcdFx0XHQvLyAuLi5hbmQgY2FwdHVyZSB0aGUgcmVzdWx0XG5cdFx0XHRcdGRhdGFQcml2LnNldCggdGhpcywgdHlwZSwge1xuXHRcdFx0XHRcdHZhbHVlOiBqUXVlcnkuZXZlbnQudHJpZ2dlcihcblxuXHRcdFx0XHRcdFx0Ly8gU3VwcG9ydDogSUUgPD05IC0gMTErXG5cdFx0XHRcdFx0XHQvLyBFeHRlbmQgd2l0aCB0aGUgcHJvdG90eXBlIHRvIHJlc2V0IHRoZSBhYm92ZSBzdG9wSW1tZWRpYXRlUHJvcGFnYXRpb24oKVxuXHRcdFx0XHRcdFx0alF1ZXJ5LmV4dGVuZCggc2F2ZWRbIDAgXSwgalF1ZXJ5LkV2ZW50LnByb3RvdHlwZSApLFxuXHRcdFx0XHRcdFx0c2F2ZWQuc2xpY2UoIDEgKSxcblx0XHRcdFx0XHRcdHRoaXNcblx0XHRcdFx0XHQpXG5cdFx0XHRcdH0gKTtcblxuXHRcdFx0XHQvLyBBYm9ydCBoYW5kbGluZyBvZiB0aGUgbmF0aXZlIGV2ZW50XG5cdFx0XHRcdGV2ZW50LnN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbigpO1xuXHRcdFx0fVxuXHRcdH1cblx0fSApO1xufVxuXG5qUXVlcnkucmVtb3ZlRXZlbnQgPSBmdW5jdGlvbiggZWxlbSwgdHlwZSwgaGFuZGxlICkge1xuXG5cdC8vIFRoaXMgXCJpZlwiIGlzIG5lZWRlZCBmb3IgcGxhaW4gb2JqZWN0c1xuXHRpZiAoIGVsZW0ucmVtb3ZlRXZlbnRMaXN0ZW5lciApIHtcblx0XHRlbGVtLnJlbW92ZUV2ZW50TGlzdGVuZXIoIHR5cGUsIGhhbmRsZSApO1xuXHR9XG59O1xuXG5qUXVlcnkuRXZlbnQgPSBmdW5jdGlvbiggc3JjLCBwcm9wcyApIHtcblxuXHQvLyBBbGxvdyBpbnN0YW50aWF0aW9uIHdpdGhvdXQgdGhlICduZXcnIGtleXdvcmRcblx0aWYgKCAhKCB0aGlzIGluc3RhbmNlb2YgalF1ZXJ5LkV2ZW50ICkgKSB7XG5cdFx0cmV0dXJuIG5ldyBqUXVlcnkuRXZlbnQoIHNyYywgcHJvcHMgKTtcblx0fVxuXG5cdC8vIEV2ZW50IG9iamVjdFxuXHRpZiAoIHNyYyAmJiBzcmMudHlwZSApIHtcblx0XHR0aGlzLm9yaWdpbmFsRXZlbnQgPSBzcmM7XG5cdFx0dGhpcy50eXBlID0gc3JjLnR5cGU7XG5cblx0XHQvLyBFdmVudHMgYnViYmxpbmcgdXAgdGhlIGRvY3VtZW50IG1heSBoYXZlIGJlZW4gbWFya2VkIGFzIHByZXZlbnRlZFxuXHRcdC8vIGJ5IGEgaGFuZGxlciBsb3dlciBkb3duIHRoZSB0cmVlOyByZWZsZWN0IHRoZSBjb3JyZWN0IHZhbHVlLlxuXHRcdHRoaXMuaXNEZWZhdWx0UHJldmVudGVkID0gc3JjLmRlZmF1bHRQcmV2ZW50ZWQgfHxcblx0XHRcdFx0c3JjLmRlZmF1bHRQcmV2ZW50ZWQgPT09IHVuZGVmaW5lZCAmJlxuXG5cdFx0XHRcdC8vIFN1cHBvcnQ6IEFuZHJvaWQgPD0yLjMgb25seVxuXHRcdFx0XHRzcmMucmV0dXJuVmFsdWUgPT09IGZhbHNlID9cblx0XHRcdHJldHVyblRydWUgOlxuXHRcdFx0cmV0dXJuRmFsc2U7XG5cblx0XHQvLyBDcmVhdGUgdGFyZ2V0IHByb3BlcnRpZXNcblx0XHQvLyBTdXBwb3J0OiBTYWZhcmkgPD02IC0gNyBvbmx5XG5cdFx0Ly8gVGFyZ2V0IHNob3VsZCBub3QgYmUgYSB0ZXh0IG5vZGUgKCM1MDQsICMxMzE0Mylcblx0XHR0aGlzLnRhcmdldCA9ICggc3JjLnRhcmdldCAmJiBzcmMudGFyZ2V0Lm5vZGVUeXBlID09PSAzICkgP1xuXHRcdFx0c3JjLnRhcmdldC5wYXJlbnROb2RlIDpcblx0XHRcdHNyYy50YXJnZXQ7XG5cblx0XHR0aGlzLmN1cnJlbnRUYXJnZXQgPSBzcmMuY3VycmVudFRhcmdldDtcblx0XHR0aGlzLnJlbGF0ZWRUYXJnZXQgPSBzcmMucmVsYXRlZFRhcmdldDtcblxuXHQvLyBFdmVudCB0eXBlXG5cdH0gZWxzZSB7XG5cdFx0dGhpcy50eXBlID0gc3JjO1xuXHR9XG5cblx0Ly8gUHV0IGV4cGxpY2l0bHkgcHJvdmlkZWQgcHJvcGVydGllcyBvbnRvIHRoZSBldmVudCBvYmplY3Rcblx0aWYgKCBwcm9wcyApIHtcblx0XHRqUXVlcnkuZXh0ZW5kKCB0aGlzLCBwcm9wcyApO1xuXHR9XG5cblx0Ly8gQ3JlYXRlIGEgdGltZXN0YW1wIGlmIGluY29taW5nIGV2ZW50IGRvZXNuJ3QgaGF2ZSBvbmVcblx0dGhpcy50aW1lU3RhbXAgPSBzcmMgJiYgc3JjLnRpbWVTdGFtcCB8fCBEYXRlLm5vdygpO1xuXG5cdC8vIE1hcmsgaXQgYXMgZml4ZWRcblx0dGhpc1sgalF1ZXJ5LmV4cGFuZG8gXSA9IHRydWU7XG59O1xuXG4vLyBqUXVlcnkuRXZlbnQgaXMgYmFzZWQgb24gRE9NMyBFdmVudHMgYXMgc3BlY2lmaWVkIGJ5IHRoZSBFQ01BU2NyaXB0IExhbmd1YWdlIEJpbmRpbmdcbi8vIGh0dHBzOi8vd3d3LnczLm9yZy9UUi8yMDAzL1dELURPTS1MZXZlbC0zLUV2ZW50cy0yMDAzMDMzMS9lY21hLXNjcmlwdC1iaW5kaW5nLmh0bWxcbmpRdWVyeS5FdmVudC5wcm90b3R5cGUgPSB7XG5cdGNvbnN0cnVjdG9yOiBqUXVlcnkuRXZlbnQsXG5cdGlzRGVmYXVsdFByZXZlbnRlZDogcmV0dXJuRmFsc2UsXG5cdGlzUHJvcGFnYXRpb25TdG9wcGVkOiByZXR1cm5GYWxzZSxcblx0aXNJbW1lZGlhdGVQcm9wYWdhdGlvblN0b3BwZWQ6IHJldHVybkZhbHNlLFxuXHRpc1NpbXVsYXRlZDogZmFsc2UsXG5cblx0cHJldmVudERlZmF1bHQ6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBlID0gdGhpcy5vcmlnaW5hbEV2ZW50O1xuXG5cdFx0dGhpcy5pc0RlZmF1bHRQcmV2ZW50ZWQgPSByZXR1cm5UcnVlO1xuXG5cdFx0aWYgKCBlICYmICF0aGlzLmlzU2ltdWxhdGVkICkge1xuXHRcdFx0ZS5wcmV2ZW50RGVmYXVsdCgpO1xuXHRcdH1cblx0fSxcblx0c3RvcFByb3BhZ2F0aW9uOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgZSA9IHRoaXMub3JpZ2luYWxFdmVudDtcblxuXHRcdHRoaXMuaXNQcm9wYWdhdGlvblN0b3BwZWQgPSByZXR1cm5UcnVlO1xuXG5cdFx0aWYgKCBlICYmICF0aGlzLmlzU2ltdWxhdGVkICkge1xuXHRcdFx0ZS5zdG9wUHJvcGFnYXRpb24oKTtcblx0XHR9XG5cdH0sXG5cdHN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbjogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIGUgPSB0aGlzLm9yaWdpbmFsRXZlbnQ7XG5cblx0XHR0aGlzLmlzSW1tZWRpYXRlUHJvcGFnYXRpb25TdG9wcGVkID0gcmV0dXJuVHJ1ZTtcblxuXHRcdGlmICggZSAmJiAhdGhpcy5pc1NpbXVsYXRlZCApIHtcblx0XHRcdGUuc3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uKCk7XG5cdFx0fVxuXG5cdFx0dGhpcy5zdG9wUHJvcGFnYXRpb24oKTtcblx0fVxufTtcblxuLy8gSW5jbHVkZXMgYWxsIGNvbW1vbiBldmVudCBwcm9wcyBpbmNsdWRpbmcgS2V5RXZlbnQgYW5kIE1vdXNlRXZlbnQgc3BlY2lmaWMgcHJvcHNcbmpRdWVyeS5lYWNoKCB7XG5cdGFsdEtleTogdHJ1ZSxcblx0YnViYmxlczogdHJ1ZSxcblx0Y2FuY2VsYWJsZTogdHJ1ZSxcblx0Y2hhbmdlZFRvdWNoZXM6IHRydWUsXG5cdGN0cmxLZXk6IHRydWUsXG5cdGRldGFpbDogdHJ1ZSxcblx0ZXZlbnRQaGFzZTogdHJ1ZSxcblx0bWV0YUtleTogdHJ1ZSxcblx0cGFnZVg6IHRydWUsXG5cdHBhZ2VZOiB0cnVlLFxuXHRzaGlmdEtleTogdHJ1ZSxcblx0dmlldzogdHJ1ZSxcblx0XCJjaGFyXCI6IHRydWUsXG5cdGNvZGU6IHRydWUsXG5cdGNoYXJDb2RlOiB0cnVlLFxuXHRrZXk6IHRydWUsXG5cdGtleUNvZGU6IHRydWUsXG5cdGJ1dHRvbjogdHJ1ZSxcblx0YnV0dG9uczogdHJ1ZSxcblx0Y2xpZW50WDogdHJ1ZSxcblx0Y2xpZW50WTogdHJ1ZSxcblx0b2Zmc2V0WDogdHJ1ZSxcblx0b2Zmc2V0WTogdHJ1ZSxcblx0cG9pbnRlcklkOiB0cnVlLFxuXHRwb2ludGVyVHlwZTogdHJ1ZSxcblx0c2NyZWVuWDogdHJ1ZSxcblx0c2NyZWVuWTogdHJ1ZSxcblx0dGFyZ2V0VG91Y2hlczogdHJ1ZSxcblx0dG9FbGVtZW50OiB0cnVlLFxuXHR0b3VjaGVzOiB0cnVlLFxuXG5cdHdoaWNoOiBmdW5jdGlvbiggZXZlbnQgKSB7XG5cdFx0dmFyIGJ1dHRvbiA9IGV2ZW50LmJ1dHRvbjtcblxuXHRcdC8vIEFkZCB3aGljaCBmb3Iga2V5IGV2ZW50c1xuXHRcdGlmICggZXZlbnQud2hpY2ggPT0gbnVsbCAmJiBya2V5RXZlbnQudGVzdCggZXZlbnQudHlwZSApICkge1xuXHRcdFx0cmV0dXJuIGV2ZW50LmNoYXJDb2RlICE9IG51bGwgPyBldmVudC5jaGFyQ29kZSA6IGV2ZW50LmtleUNvZGU7XG5cdFx0fVxuXG5cdFx0Ly8gQWRkIHdoaWNoIGZvciBjbGljazogMSA9PT0gbGVmdDsgMiA9PT0gbWlkZGxlOyAzID09PSByaWdodFxuXHRcdGlmICggIWV2ZW50LndoaWNoICYmIGJ1dHRvbiAhPT0gdW5kZWZpbmVkICYmIHJtb3VzZUV2ZW50LnRlc3QoIGV2ZW50LnR5cGUgKSApIHtcblx0XHRcdGlmICggYnV0dG9uICYgMSApIHtcblx0XHRcdFx0cmV0dXJuIDE7XG5cdFx0XHR9XG5cblx0XHRcdGlmICggYnV0dG9uICYgMiApIHtcblx0XHRcdFx0cmV0dXJuIDM7XG5cdFx0XHR9XG5cblx0XHRcdGlmICggYnV0dG9uICYgNCApIHtcblx0XHRcdFx0cmV0dXJuIDI7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiAwO1xuXHRcdH1cblxuXHRcdHJldHVybiBldmVudC53aGljaDtcblx0fVxufSwgalF1ZXJ5LmV2ZW50LmFkZFByb3AgKTtcblxualF1ZXJ5LmVhY2goIHsgZm9jdXM6IFwiZm9jdXNpblwiLCBibHVyOiBcImZvY3Vzb3V0XCIgfSwgZnVuY3Rpb24oIHR5cGUsIGRlbGVnYXRlVHlwZSApIHtcblx0alF1ZXJ5LmV2ZW50LnNwZWNpYWxbIHR5cGUgXSA9IHtcblxuXHRcdC8vIFV0aWxpemUgbmF0aXZlIGV2ZW50IGlmIHBvc3NpYmxlIHNvIGJsdXIvZm9jdXMgc2VxdWVuY2UgaXMgY29ycmVjdFxuXHRcdHNldHVwOiBmdW5jdGlvbigpIHtcblxuXHRcdFx0Ly8gQ2xhaW0gdGhlIGZpcnN0IGhhbmRsZXJcblx0XHRcdC8vIGRhdGFQcml2LnNldCggdGhpcywgXCJmb2N1c1wiLCAuLi4gKVxuXHRcdFx0Ly8gZGF0YVByaXYuc2V0KCB0aGlzLCBcImJsdXJcIiwgLi4uIClcblx0XHRcdGxldmVyYWdlTmF0aXZlKCB0aGlzLCB0eXBlLCBleHBlY3RTeW5jICk7XG5cblx0XHRcdC8vIFJldHVybiBmYWxzZSB0byBhbGxvdyBub3JtYWwgcHJvY2Vzc2luZyBpbiB0aGUgY2FsbGVyXG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fSxcblx0XHR0cmlnZ2VyOiBmdW5jdGlvbigpIHtcblxuXHRcdFx0Ly8gRm9yY2Ugc2V0dXAgYmVmb3JlIHRyaWdnZXJcblx0XHRcdGxldmVyYWdlTmF0aXZlKCB0aGlzLCB0eXBlICk7XG5cblx0XHRcdC8vIFJldHVybiBub24tZmFsc2UgdG8gYWxsb3cgbm9ybWFsIGV2ZW50LXBhdGggcHJvcGFnYXRpb25cblx0XHRcdHJldHVybiB0cnVlO1xuXHRcdH0sXG5cblx0XHRkZWxlZ2F0ZVR5cGU6IGRlbGVnYXRlVHlwZVxuXHR9O1xufSApO1xuXG4vLyBDcmVhdGUgbW91c2VlbnRlci9sZWF2ZSBldmVudHMgdXNpbmcgbW91c2VvdmVyL291dCBhbmQgZXZlbnQtdGltZSBjaGVja3Ncbi8vIHNvIHRoYXQgZXZlbnQgZGVsZWdhdGlvbiB3b3JrcyBpbiBqUXVlcnkuXG4vLyBEbyB0aGUgc2FtZSBmb3IgcG9pbnRlcmVudGVyL3BvaW50ZXJsZWF2ZSBhbmQgcG9pbnRlcm92ZXIvcG9pbnRlcm91dFxuLy9cbi8vIFN1cHBvcnQ6IFNhZmFyaSA3IG9ubHlcbi8vIFNhZmFyaSBzZW5kcyBtb3VzZWVudGVyIHRvbyBvZnRlbjsgc2VlOlxuLy8gaHR0cHM6Ly9idWdzLmNocm9taXVtLm9yZy9wL2Nocm9taXVtL2lzc3Vlcy9kZXRhaWw/aWQ9NDcwMjU4XG4vLyBmb3IgdGhlIGRlc2NyaXB0aW9uIG9mIHRoZSBidWcgKGl0IGV4aXN0ZWQgaW4gb2xkZXIgQ2hyb21lIHZlcnNpb25zIGFzIHdlbGwpLlxualF1ZXJ5LmVhY2goIHtcblx0bW91c2VlbnRlcjogXCJtb3VzZW92ZXJcIixcblx0bW91c2VsZWF2ZTogXCJtb3VzZW91dFwiLFxuXHRwb2ludGVyZW50ZXI6IFwicG9pbnRlcm92ZXJcIixcblx0cG9pbnRlcmxlYXZlOiBcInBvaW50ZXJvdXRcIlxufSwgZnVuY3Rpb24oIG9yaWcsIGZpeCApIHtcblx0alF1ZXJ5LmV2ZW50LnNwZWNpYWxbIG9yaWcgXSA9IHtcblx0XHRkZWxlZ2F0ZVR5cGU6IGZpeCxcblx0XHRiaW5kVHlwZTogZml4LFxuXG5cdFx0aGFuZGxlOiBmdW5jdGlvbiggZXZlbnQgKSB7XG5cdFx0XHR2YXIgcmV0LFxuXHRcdFx0XHR0YXJnZXQgPSB0aGlzLFxuXHRcdFx0XHRyZWxhdGVkID0gZXZlbnQucmVsYXRlZFRhcmdldCxcblx0XHRcdFx0aGFuZGxlT2JqID0gZXZlbnQuaGFuZGxlT2JqO1xuXG5cdFx0XHQvLyBGb3IgbW91c2VlbnRlci9sZWF2ZSBjYWxsIHRoZSBoYW5kbGVyIGlmIHJlbGF0ZWQgaXMgb3V0c2lkZSB0aGUgdGFyZ2V0LlxuXHRcdFx0Ly8gTkI6IE5vIHJlbGF0ZWRUYXJnZXQgaWYgdGhlIG1vdXNlIGxlZnQvZW50ZXJlZCB0aGUgYnJvd3NlciB3aW5kb3dcblx0XHRcdGlmICggIXJlbGF0ZWQgfHwgKCByZWxhdGVkICE9PSB0YXJnZXQgJiYgIWpRdWVyeS5jb250YWlucyggdGFyZ2V0LCByZWxhdGVkICkgKSApIHtcblx0XHRcdFx0ZXZlbnQudHlwZSA9IGhhbmRsZU9iai5vcmlnVHlwZTtcblx0XHRcdFx0cmV0ID0gaGFuZGxlT2JqLmhhbmRsZXIuYXBwbHkoIHRoaXMsIGFyZ3VtZW50cyApO1xuXHRcdFx0XHRldmVudC50eXBlID0gZml4O1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHJldDtcblx0XHR9XG5cdH07XG59ICk7XG5cbmpRdWVyeS5mbi5leHRlbmQoIHtcblxuXHRvbjogZnVuY3Rpb24oIHR5cGVzLCBzZWxlY3RvciwgZGF0YSwgZm4gKSB7XG5cdFx0cmV0dXJuIG9uKCB0aGlzLCB0eXBlcywgc2VsZWN0b3IsIGRhdGEsIGZuICk7XG5cdH0sXG5cdG9uZTogZnVuY3Rpb24oIHR5cGVzLCBzZWxlY3RvciwgZGF0YSwgZm4gKSB7XG5cdFx0cmV0dXJuIG9uKCB0aGlzLCB0eXBlcywgc2VsZWN0b3IsIGRhdGEsIGZuLCAxICk7XG5cdH0sXG5cdG9mZjogZnVuY3Rpb24oIHR5cGVzLCBzZWxlY3RvciwgZm4gKSB7XG5cdFx0dmFyIGhhbmRsZU9iaiwgdHlwZTtcblx0XHRpZiAoIHR5cGVzICYmIHR5cGVzLnByZXZlbnREZWZhdWx0ICYmIHR5cGVzLmhhbmRsZU9iaiApIHtcblxuXHRcdFx0Ly8gKCBldmVudCApICBkaXNwYXRjaGVkIGpRdWVyeS5FdmVudFxuXHRcdFx0aGFuZGxlT2JqID0gdHlwZXMuaGFuZGxlT2JqO1xuXHRcdFx0alF1ZXJ5KCB0eXBlcy5kZWxlZ2F0ZVRhcmdldCApLm9mZihcblx0XHRcdFx0aGFuZGxlT2JqLm5hbWVzcGFjZSA/XG5cdFx0XHRcdFx0aGFuZGxlT2JqLm9yaWdUeXBlICsgXCIuXCIgKyBoYW5kbGVPYmoubmFtZXNwYWNlIDpcblx0XHRcdFx0XHRoYW5kbGVPYmoub3JpZ1R5cGUsXG5cdFx0XHRcdGhhbmRsZU9iai5zZWxlY3Rvcixcblx0XHRcdFx0aGFuZGxlT2JqLmhhbmRsZXJcblx0XHRcdCk7XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9XG5cdFx0aWYgKCB0eXBlb2YgdHlwZXMgPT09IFwib2JqZWN0XCIgKSB7XG5cblx0XHRcdC8vICggdHlwZXMtb2JqZWN0IFssIHNlbGVjdG9yXSApXG5cdFx0XHRmb3IgKCB0eXBlIGluIHR5cGVzICkge1xuXHRcdFx0XHR0aGlzLm9mZiggdHlwZSwgc2VsZWN0b3IsIHR5cGVzWyB0eXBlIF0gKTtcblx0XHRcdH1cblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH1cblx0XHRpZiAoIHNlbGVjdG9yID09PSBmYWxzZSB8fCB0eXBlb2Ygc2VsZWN0b3IgPT09IFwiZnVuY3Rpb25cIiApIHtcblxuXHRcdFx0Ly8gKCB0eXBlcyBbLCBmbl0gKVxuXHRcdFx0Zm4gPSBzZWxlY3Rvcjtcblx0XHRcdHNlbGVjdG9yID0gdW5kZWZpbmVkO1xuXHRcdH1cblx0XHRpZiAoIGZuID09PSBmYWxzZSApIHtcblx0XHRcdGZuID0gcmV0dXJuRmFsc2U7XG5cdFx0fVxuXHRcdHJldHVybiB0aGlzLmVhY2goIGZ1bmN0aW9uKCkge1xuXHRcdFx0alF1ZXJ5LmV2ZW50LnJlbW92ZSggdGhpcywgdHlwZXMsIGZuLCBzZWxlY3RvciApO1xuXHRcdH0gKTtcblx0fVxufSApO1xuXG5cbnZhclxuXG5cdC8qIGVzbGludC1kaXNhYmxlIG1heC1sZW4gKi9cblxuXHQvLyBTZWUgaHR0cHM6Ly9naXRodWIuY29tL2VzbGludC9lc2xpbnQvaXNzdWVzLzMyMjlcblx0cnhodG1sVGFnID0gLzwoPyFhcmVhfGJyfGNvbHxlbWJlZHxocnxpbWd8aW5wdXR8bGlua3xtZXRhfHBhcmFtKSgoW2Etel1bXlxcL1xcMD5cXHgyMFxcdFxcclxcblxcZl0qKVtePl0qKVxcLz4vZ2ksXG5cblx0LyogZXNsaW50LWVuYWJsZSAqL1xuXG5cdC8vIFN1cHBvcnQ6IElFIDw9MTAgLSAxMSwgRWRnZSAxMiAtIDEzIG9ubHlcblx0Ly8gSW4gSUUvRWRnZSB1c2luZyByZWdleCBncm91cHMgaGVyZSBjYXVzZXMgc2V2ZXJlIHNsb3dkb3ducy5cblx0Ly8gU2VlIGh0dHBzOi8vY29ubmVjdC5taWNyb3NvZnQuY29tL0lFL2ZlZWRiYWNrL2RldGFpbHMvMTczNjUxMi9cblx0cm5vSW5uZXJodG1sID0gLzxzY3JpcHR8PHN0eWxlfDxsaW5rL2ksXG5cblx0Ly8gY2hlY2tlZD1cImNoZWNrZWRcIiBvciBjaGVja2VkXG5cdHJjaGVja2VkID0gL2NoZWNrZWRcXHMqKD86W149XXw9XFxzKi5jaGVja2VkLikvaSxcblx0cmNsZWFuU2NyaXB0ID0gL15cXHMqPCEoPzpcXFtDREFUQVxcW3wtLSl8KD86XFxdXFxdfC0tKT5cXHMqJC9nO1xuXG4vLyBQcmVmZXIgYSB0Ym9keSBvdmVyIGl0cyBwYXJlbnQgdGFibGUgZm9yIGNvbnRhaW5pbmcgbmV3IHJvd3NcbmZ1bmN0aW9uIG1hbmlwdWxhdGlvblRhcmdldCggZWxlbSwgY29udGVudCApIHtcblx0aWYgKCBub2RlTmFtZSggZWxlbSwgXCJ0YWJsZVwiICkgJiZcblx0XHRub2RlTmFtZSggY29udGVudC5ub2RlVHlwZSAhPT0gMTEgPyBjb250ZW50IDogY29udGVudC5maXJzdENoaWxkLCBcInRyXCIgKSApIHtcblxuXHRcdHJldHVybiBqUXVlcnkoIGVsZW0gKS5jaGlsZHJlbiggXCJ0Ym9keVwiIClbIDAgXSB8fCBlbGVtO1xuXHR9XG5cblx0cmV0dXJuIGVsZW07XG59XG5cbi8vIFJlcGxhY2UvcmVzdG9yZSB0aGUgdHlwZSBhdHRyaWJ1dGUgb2Ygc2NyaXB0IGVsZW1lbnRzIGZvciBzYWZlIERPTSBtYW5pcHVsYXRpb25cbmZ1bmN0aW9uIGRpc2FibGVTY3JpcHQoIGVsZW0gKSB7XG5cdGVsZW0udHlwZSA9ICggZWxlbS5nZXRBdHRyaWJ1dGUoIFwidHlwZVwiICkgIT09IG51bGwgKSArIFwiL1wiICsgZWxlbS50eXBlO1xuXHRyZXR1cm4gZWxlbTtcbn1cbmZ1bmN0aW9uIHJlc3RvcmVTY3JpcHQoIGVsZW0gKSB7XG5cdGlmICggKCBlbGVtLnR5cGUgfHwgXCJcIiApLnNsaWNlKCAwLCA1ICkgPT09IFwidHJ1ZS9cIiApIHtcblx0XHRlbGVtLnR5cGUgPSBlbGVtLnR5cGUuc2xpY2UoIDUgKTtcblx0fSBlbHNlIHtcblx0XHRlbGVtLnJlbW92ZUF0dHJpYnV0ZSggXCJ0eXBlXCIgKTtcblx0fVxuXG5cdHJldHVybiBlbGVtO1xufVxuXG5mdW5jdGlvbiBjbG9uZUNvcHlFdmVudCggc3JjLCBkZXN0ICkge1xuXHR2YXIgaSwgbCwgdHlwZSwgcGRhdGFPbGQsIHBkYXRhQ3VyLCB1ZGF0YU9sZCwgdWRhdGFDdXIsIGV2ZW50cztcblxuXHRpZiAoIGRlc3Qubm9kZVR5cGUgIT09IDEgKSB7XG5cdFx0cmV0dXJuO1xuXHR9XG5cblx0Ly8gMS4gQ29weSBwcml2YXRlIGRhdGE6IGV2ZW50cywgaGFuZGxlcnMsIGV0Yy5cblx0aWYgKCBkYXRhUHJpdi5oYXNEYXRhKCBzcmMgKSApIHtcblx0XHRwZGF0YU9sZCA9IGRhdGFQcml2LmFjY2Vzcyggc3JjICk7XG5cdFx0cGRhdGFDdXIgPSBkYXRhUHJpdi5zZXQoIGRlc3QsIHBkYXRhT2xkICk7XG5cdFx0ZXZlbnRzID0gcGRhdGFPbGQuZXZlbnRzO1xuXG5cdFx0aWYgKCBldmVudHMgKSB7XG5cdFx0XHRkZWxldGUgcGRhdGFDdXIuaGFuZGxlO1xuXHRcdFx0cGRhdGFDdXIuZXZlbnRzID0ge307XG5cblx0XHRcdGZvciAoIHR5cGUgaW4gZXZlbnRzICkge1xuXHRcdFx0XHRmb3IgKCBpID0gMCwgbCA9IGV2ZW50c1sgdHlwZSBdLmxlbmd0aDsgaSA8IGw7IGkrKyApIHtcblx0XHRcdFx0XHRqUXVlcnkuZXZlbnQuYWRkKCBkZXN0LCB0eXBlLCBldmVudHNbIHR5cGUgXVsgaSBdICk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHQvLyAyLiBDb3B5IHVzZXIgZGF0YVxuXHRpZiAoIGRhdGFVc2VyLmhhc0RhdGEoIHNyYyApICkge1xuXHRcdHVkYXRhT2xkID0gZGF0YVVzZXIuYWNjZXNzKCBzcmMgKTtcblx0XHR1ZGF0YUN1ciA9IGpRdWVyeS5leHRlbmQoIHt9LCB1ZGF0YU9sZCApO1xuXG5cdFx0ZGF0YVVzZXIuc2V0KCBkZXN0LCB1ZGF0YUN1ciApO1xuXHR9XG59XG5cbi8vIEZpeCBJRSBidWdzLCBzZWUgc3VwcG9ydCB0ZXN0c1xuZnVuY3Rpb24gZml4SW5wdXQoIHNyYywgZGVzdCApIHtcblx0dmFyIG5vZGVOYW1lID0gZGVzdC5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpO1xuXG5cdC8vIEZhaWxzIHRvIHBlcnNpc3QgdGhlIGNoZWNrZWQgc3RhdGUgb2YgYSBjbG9uZWQgY2hlY2tib3ggb3IgcmFkaW8gYnV0dG9uLlxuXHRpZiAoIG5vZGVOYW1lID09PSBcImlucHV0XCIgJiYgcmNoZWNrYWJsZVR5cGUudGVzdCggc3JjLnR5cGUgKSApIHtcblx0XHRkZXN0LmNoZWNrZWQgPSBzcmMuY2hlY2tlZDtcblxuXHQvLyBGYWlscyB0byByZXR1cm4gdGhlIHNlbGVjdGVkIG9wdGlvbiB0byB0aGUgZGVmYXVsdCBzZWxlY3RlZCBzdGF0ZSB3aGVuIGNsb25pbmcgb3B0aW9uc1xuXHR9IGVsc2UgaWYgKCBub2RlTmFtZSA9PT0gXCJpbnB1dFwiIHx8IG5vZGVOYW1lID09PSBcInRleHRhcmVhXCIgKSB7XG5cdFx0ZGVzdC5kZWZhdWx0VmFsdWUgPSBzcmMuZGVmYXVsdFZhbHVlO1xuXHR9XG59XG5cbmZ1bmN0aW9uIGRvbU1hbmlwKCBjb2xsZWN0aW9uLCBhcmdzLCBjYWxsYmFjaywgaWdub3JlZCApIHtcblxuXHQvLyBGbGF0dGVuIGFueSBuZXN0ZWQgYXJyYXlzXG5cdGFyZ3MgPSBjb25jYXQuYXBwbHkoIFtdLCBhcmdzICk7XG5cblx0dmFyIGZyYWdtZW50LCBmaXJzdCwgc2NyaXB0cywgaGFzU2NyaXB0cywgbm9kZSwgZG9jLFxuXHRcdGkgPSAwLFxuXHRcdGwgPSBjb2xsZWN0aW9uLmxlbmd0aCxcblx0XHRpTm9DbG9uZSA9IGwgLSAxLFxuXHRcdHZhbHVlID0gYXJnc1sgMCBdLFxuXHRcdHZhbHVlSXNGdW5jdGlvbiA9IGlzRnVuY3Rpb24oIHZhbHVlICk7XG5cblx0Ly8gV2UgY2FuJ3QgY2xvbmVOb2RlIGZyYWdtZW50cyB0aGF0IGNvbnRhaW4gY2hlY2tlZCwgaW4gV2ViS2l0XG5cdGlmICggdmFsdWVJc0Z1bmN0aW9uIHx8XG5cdFx0XHQoIGwgPiAxICYmIHR5cGVvZiB2YWx1ZSA9PT0gXCJzdHJpbmdcIiAmJlxuXHRcdFx0XHQhc3VwcG9ydC5jaGVja0Nsb25lICYmIHJjaGVja2VkLnRlc3QoIHZhbHVlICkgKSApIHtcblx0XHRyZXR1cm4gY29sbGVjdGlvbi5lYWNoKCBmdW5jdGlvbiggaW5kZXggKSB7XG5cdFx0XHR2YXIgc2VsZiA9IGNvbGxlY3Rpb24uZXEoIGluZGV4ICk7XG5cdFx0XHRpZiAoIHZhbHVlSXNGdW5jdGlvbiApIHtcblx0XHRcdFx0YXJnc1sgMCBdID0gdmFsdWUuY2FsbCggdGhpcywgaW5kZXgsIHNlbGYuaHRtbCgpICk7XG5cdFx0XHR9XG5cdFx0XHRkb21NYW5pcCggc2VsZiwgYXJncywgY2FsbGJhY2ssIGlnbm9yZWQgKTtcblx0XHR9ICk7XG5cdH1cblxuXHRpZiAoIGwgKSB7XG5cdFx0ZnJhZ21lbnQgPSBidWlsZEZyYWdtZW50KCBhcmdzLCBjb2xsZWN0aW9uWyAwIF0ub3duZXJEb2N1bWVudCwgZmFsc2UsIGNvbGxlY3Rpb24sIGlnbm9yZWQgKTtcblx0XHRmaXJzdCA9IGZyYWdtZW50LmZpcnN0Q2hpbGQ7XG5cblx0XHRpZiAoIGZyYWdtZW50LmNoaWxkTm9kZXMubGVuZ3RoID09PSAxICkge1xuXHRcdFx0ZnJhZ21lbnQgPSBmaXJzdDtcblx0XHR9XG5cblx0XHQvLyBSZXF1aXJlIGVpdGhlciBuZXcgY29udGVudCBvciBhbiBpbnRlcmVzdCBpbiBpZ25vcmVkIGVsZW1lbnRzIHRvIGludm9rZSB0aGUgY2FsbGJhY2tcblx0XHRpZiAoIGZpcnN0IHx8IGlnbm9yZWQgKSB7XG5cdFx0XHRzY3JpcHRzID0galF1ZXJ5Lm1hcCggZ2V0QWxsKCBmcmFnbWVudCwgXCJzY3JpcHRcIiApLCBkaXNhYmxlU2NyaXB0ICk7XG5cdFx0XHRoYXNTY3JpcHRzID0gc2NyaXB0cy5sZW5ndGg7XG5cblx0XHRcdC8vIFVzZSB0aGUgb3JpZ2luYWwgZnJhZ21lbnQgZm9yIHRoZSBsYXN0IGl0ZW1cblx0XHRcdC8vIGluc3RlYWQgb2YgdGhlIGZpcnN0IGJlY2F1c2UgaXQgY2FuIGVuZCB1cFxuXHRcdFx0Ly8gYmVpbmcgZW1wdGllZCBpbmNvcnJlY3RseSBpbiBjZXJ0YWluIHNpdHVhdGlvbnMgKCM4MDcwKS5cblx0XHRcdGZvciAoIDsgaSA8IGw7IGkrKyApIHtcblx0XHRcdFx0bm9kZSA9IGZyYWdtZW50O1xuXG5cdFx0XHRcdGlmICggaSAhPT0gaU5vQ2xvbmUgKSB7XG5cdFx0XHRcdFx0bm9kZSA9IGpRdWVyeS5jbG9uZSggbm9kZSwgdHJ1ZSwgdHJ1ZSApO1xuXG5cdFx0XHRcdFx0Ly8gS2VlcCByZWZlcmVuY2VzIHRvIGNsb25lZCBzY3JpcHRzIGZvciBsYXRlciByZXN0b3JhdGlvblxuXHRcdFx0XHRcdGlmICggaGFzU2NyaXB0cyApIHtcblxuXHRcdFx0XHRcdFx0Ly8gU3VwcG9ydDogQW5kcm9pZCA8PTQuMCBvbmx5LCBQaGFudG9tSlMgMSBvbmx5XG5cdFx0XHRcdFx0XHQvLyBwdXNoLmFwcGx5KF8sIGFycmF5bGlrZSkgdGhyb3dzIG9uIGFuY2llbnQgV2ViS2l0XG5cdFx0XHRcdFx0XHRqUXVlcnkubWVyZ2UoIHNjcmlwdHMsIGdldEFsbCggbm9kZSwgXCJzY3JpcHRcIiApICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cblx0XHRcdFx0Y2FsbGJhY2suY2FsbCggY29sbGVjdGlvblsgaSBdLCBub2RlLCBpICk7XG5cdFx0XHR9XG5cblx0XHRcdGlmICggaGFzU2NyaXB0cyApIHtcblx0XHRcdFx0ZG9jID0gc2NyaXB0c1sgc2NyaXB0cy5sZW5ndGggLSAxIF0ub3duZXJEb2N1bWVudDtcblxuXHRcdFx0XHQvLyBSZWVuYWJsZSBzY3JpcHRzXG5cdFx0XHRcdGpRdWVyeS5tYXAoIHNjcmlwdHMsIHJlc3RvcmVTY3JpcHQgKTtcblxuXHRcdFx0XHQvLyBFdmFsdWF0ZSBleGVjdXRhYmxlIHNjcmlwdHMgb24gZmlyc3QgZG9jdW1lbnQgaW5zZXJ0aW9uXG5cdFx0XHRcdGZvciAoIGkgPSAwOyBpIDwgaGFzU2NyaXB0czsgaSsrICkge1xuXHRcdFx0XHRcdG5vZGUgPSBzY3JpcHRzWyBpIF07XG5cdFx0XHRcdFx0aWYgKCByc2NyaXB0VHlwZS50ZXN0KCBub2RlLnR5cGUgfHwgXCJcIiApICYmXG5cdFx0XHRcdFx0XHQhZGF0YVByaXYuYWNjZXNzKCBub2RlLCBcImdsb2JhbEV2YWxcIiApICYmXG5cdFx0XHRcdFx0XHRqUXVlcnkuY29udGFpbnMoIGRvYywgbm9kZSApICkge1xuXG5cdFx0XHRcdFx0XHRpZiAoIG5vZGUuc3JjICYmICggbm9kZS50eXBlIHx8IFwiXCIgKS50b0xvd2VyQ2FzZSgpICAhPT0gXCJtb2R1bGVcIiApIHtcblxuXHRcdFx0XHRcdFx0XHQvLyBPcHRpb25hbCBBSkFYIGRlcGVuZGVuY3ksIGJ1dCB3b24ndCBydW4gc2NyaXB0cyBpZiBub3QgcHJlc2VudFxuXHRcdFx0XHRcdFx0XHRpZiAoIGpRdWVyeS5fZXZhbFVybCAmJiAhbm9kZS5ub01vZHVsZSApIHtcblx0XHRcdFx0XHRcdFx0XHRqUXVlcnkuX2V2YWxVcmwoIG5vZGUuc3JjLCB7XG5cdFx0XHRcdFx0XHRcdFx0XHRub25jZTogbm9kZS5ub25jZSB8fCBub2RlLmdldEF0dHJpYnV0ZSggXCJub25jZVwiIClcblx0XHRcdFx0XHRcdFx0XHR9ICk7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRcdERPTUV2YWwoIG5vZGUudGV4dENvbnRlbnQucmVwbGFjZSggcmNsZWFuU2NyaXB0LCBcIlwiICksIG5vZGUsIGRvYyApO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdHJldHVybiBjb2xsZWN0aW9uO1xufVxuXG5mdW5jdGlvbiByZW1vdmUoIGVsZW0sIHNlbGVjdG9yLCBrZWVwRGF0YSApIHtcblx0dmFyIG5vZGUsXG5cdFx0bm9kZXMgPSBzZWxlY3RvciA/IGpRdWVyeS5maWx0ZXIoIHNlbGVjdG9yLCBlbGVtICkgOiBlbGVtLFxuXHRcdGkgPSAwO1xuXG5cdGZvciAoIDsgKCBub2RlID0gbm9kZXNbIGkgXSApICE9IG51bGw7IGkrKyApIHtcblx0XHRpZiAoICFrZWVwRGF0YSAmJiBub2RlLm5vZGVUeXBlID09PSAxICkge1xuXHRcdFx0alF1ZXJ5LmNsZWFuRGF0YSggZ2V0QWxsKCBub2RlICkgKTtcblx0XHR9XG5cblx0XHRpZiAoIG5vZGUucGFyZW50Tm9kZSApIHtcblx0XHRcdGlmICgga2VlcERhdGEgJiYgaXNBdHRhY2hlZCggbm9kZSApICkge1xuXHRcdFx0XHRzZXRHbG9iYWxFdmFsKCBnZXRBbGwoIG5vZGUsIFwic2NyaXB0XCIgKSApO1xuXHRcdFx0fVxuXHRcdFx0bm9kZS5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKCBub2RlICk7XG5cdFx0fVxuXHR9XG5cblx0cmV0dXJuIGVsZW07XG59XG5cbmpRdWVyeS5leHRlbmQoIHtcblx0aHRtbFByZWZpbHRlcjogZnVuY3Rpb24oIGh0bWwgKSB7XG5cdFx0cmV0dXJuIGh0bWwucmVwbGFjZSggcnhodG1sVGFnLCBcIjwkMT48LyQyPlwiICk7XG5cdH0sXG5cblx0Y2xvbmU6IGZ1bmN0aW9uKCBlbGVtLCBkYXRhQW5kRXZlbnRzLCBkZWVwRGF0YUFuZEV2ZW50cyApIHtcblx0XHR2YXIgaSwgbCwgc3JjRWxlbWVudHMsIGRlc3RFbGVtZW50cyxcblx0XHRcdGNsb25lID0gZWxlbS5jbG9uZU5vZGUoIHRydWUgKSxcblx0XHRcdGluUGFnZSA9IGlzQXR0YWNoZWQoIGVsZW0gKTtcblxuXHRcdC8vIEZpeCBJRSBjbG9uaW5nIGlzc3Vlc1xuXHRcdGlmICggIXN1cHBvcnQubm9DbG9uZUNoZWNrZWQgJiYgKCBlbGVtLm5vZGVUeXBlID09PSAxIHx8IGVsZW0ubm9kZVR5cGUgPT09IDExICkgJiZcblx0XHRcdFx0IWpRdWVyeS5pc1hNTERvYyggZWxlbSApICkge1xuXG5cdFx0XHQvLyBXZSBlc2NoZXcgU2l6emxlIGhlcmUgZm9yIHBlcmZvcm1hbmNlIHJlYXNvbnM6IGh0dHBzOi8vanNwZXJmLmNvbS9nZXRhbGwtdnMtc2l6emxlLzJcblx0XHRcdGRlc3RFbGVtZW50cyA9IGdldEFsbCggY2xvbmUgKTtcblx0XHRcdHNyY0VsZW1lbnRzID0gZ2V0QWxsKCBlbGVtICk7XG5cblx0XHRcdGZvciAoIGkgPSAwLCBsID0gc3JjRWxlbWVudHMubGVuZ3RoOyBpIDwgbDsgaSsrICkge1xuXHRcdFx0XHRmaXhJbnB1dCggc3JjRWxlbWVudHNbIGkgXSwgZGVzdEVsZW1lbnRzWyBpIF0gKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyBDb3B5IHRoZSBldmVudHMgZnJvbSB0aGUgb3JpZ2luYWwgdG8gdGhlIGNsb25lXG5cdFx0aWYgKCBkYXRhQW5kRXZlbnRzICkge1xuXHRcdFx0aWYgKCBkZWVwRGF0YUFuZEV2ZW50cyApIHtcblx0XHRcdFx0c3JjRWxlbWVudHMgPSBzcmNFbGVtZW50cyB8fCBnZXRBbGwoIGVsZW0gKTtcblx0XHRcdFx0ZGVzdEVsZW1lbnRzID0gZGVzdEVsZW1lbnRzIHx8IGdldEFsbCggY2xvbmUgKTtcblxuXHRcdFx0XHRmb3IgKCBpID0gMCwgbCA9IHNyY0VsZW1lbnRzLmxlbmd0aDsgaSA8IGw7IGkrKyApIHtcblx0XHRcdFx0XHRjbG9uZUNvcHlFdmVudCggc3JjRWxlbWVudHNbIGkgXSwgZGVzdEVsZW1lbnRzWyBpIF0gKTtcblx0XHRcdFx0fVxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0Y2xvbmVDb3B5RXZlbnQoIGVsZW0sIGNsb25lICk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gUHJlc2VydmUgc2NyaXB0IGV2YWx1YXRpb24gaGlzdG9yeVxuXHRcdGRlc3RFbGVtZW50cyA9IGdldEFsbCggY2xvbmUsIFwic2NyaXB0XCIgKTtcblx0XHRpZiAoIGRlc3RFbGVtZW50cy5sZW5ndGggPiAwICkge1xuXHRcdFx0c2V0R2xvYmFsRXZhbCggZGVzdEVsZW1lbnRzLCAhaW5QYWdlICYmIGdldEFsbCggZWxlbSwgXCJzY3JpcHRcIiApICk7XG5cdFx0fVxuXG5cdFx0Ly8gUmV0dXJuIHRoZSBjbG9uZWQgc2V0XG5cdFx0cmV0dXJuIGNsb25lO1xuXHR9LFxuXG5cdGNsZWFuRGF0YTogZnVuY3Rpb24oIGVsZW1zICkge1xuXHRcdHZhciBkYXRhLCBlbGVtLCB0eXBlLFxuXHRcdFx0c3BlY2lhbCA9IGpRdWVyeS5ldmVudC5zcGVjaWFsLFxuXHRcdFx0aSA9IDA7XG5cblx0XHRmb3IgKCA7ICggZWxlbSA9IGVsZW1zWyBpIF0gKSAhPT0gdW5kZWZpbmVkOyBpKysgKSB7XG5cdFx0XHRpZiAoIGFjY2VwdERhdGEoIGVsZW0gKSApIHtcblx0XHRcdFx0aWYgKCAoIGRhdGEgPSBlbGVtWyBkYXRhUHJpdi5leHBhbmRvIF0gKSApIHtcblx0XHRcdFx0XHRpZiAoIGRhdGEuZXZlbnRzICkge1xuXHRcdFx0XHRcdFx0Zm9yICggdHlwZSBpbiBkYXRhLmV2ZW50cyApIHtcblx0XHRcdFx0XHRcdFx0aWYgKCBzcGVjaWFsWyB0eXBlIF0gKSB7XG5cdFx0XHRcdFx0XHRcdFx0alF1ZXJ5LmV2ZW50LnJlbW92ZSggZWxlbSwgdHlwZSApO1xuXG5cdFx0XHRcdFx0XHRcdC8vIFRoaXMgaXMgYSBzaG9ydGN1dCB0byBhdm9pZCBqUXVlcnkuZXZlbnQucmVtb3ZlJ3Mgb3ZlcmhlYWRcblx0XHRcdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdFx0XHRqUXVlcnkucmVtb3ZlRXZlbnQoIGVsZW0sIHR5cGUsIGRhdGEuaGFuZGxlICk7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHQvLyBTdXBwb3J0OiBDaHJvbWUgPD0zNSAtIDQ1K1xuXHRcdFx0XHRcdC8vIEFzc2lnbiB1bmRlZmluZWQgaW5zdGVhZCBvZiB1c2luZyBkZWxldGUsIHNlZSBEYXRhI3JlbW92ZVxuXHRcdFx0XHRcdGVsZW1bIGRhdGFQcml2LmV4cGFuZG8gXSA9IHVuZGVmaW5lZDtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAoIGVsZW1bIGRhdGFVc2VyLmV4cGFuZG8gXSApIHtcblxuXHRcdFx0XHRcdC8vIFN1cHBvcnQ6IENocm9tZSA8PTM1IC0gNDUrXG5cdFx0XHRcdFx0Ly8gQXNzaWduIHVuZGVmaW5lZCBpbnN0ZWFkIG9mIHVzaW5nIGRlbGV0ZSwgc2VlIERhdGEjcmVtb3ZlXG5cdFx0XHRcdFx0ZWxlbVsgZGF0YVVzZXIuZXhwYW5kbyBdID0gdW5kZWZpbmVkO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG59ICk7XG5cbmpRdWVyeS5mbi5leHRlbmQoIHtcblx0ZGV0YWNoOiBmdW5jdGlvbiggc2VsZWN0b3IgKSB7XG5cdFx0cmV0dXJuIHJlbW92ZSggdGhpcywgc2VsZWN0b3IsIHRydWUgKTtcblx0fSxcblxuXHRyZW1vdmU6IGZ1bmN0aW9uKCBzZWxlY3RvciApIHtcblx0XHRyZXR1cm4gcmVtb3ZlKCB0aGlzLCBzZWxlY3RvciApO1xuXHR9LFxuXG5cdHRleHQ6IGZ1bmN0aW9uKCB2YWx1ZSApIHtcblx0XHRyZXR1cm4gYWNjZXNzKCB0aGlzLCBmdW5jdGlvbiggdmFsdWUgKSB7XG5cdFx0XHRyZXR1cm4gdmFsdWUgPT09IHVuZGVmaW5lZCA/XG5cdFx0XHRcdGpRdWVyeS50ZXh0KCB0aGlzICkgOlxuXHRcdFx0XHR0aGlzLmVtcHR5KCkuZWFjaCggZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0aWYgKCB0aGlzLm5vZGVUeXBlID09PSAxIHx8IHRoaXMubm9kZVR5cGUgPT09IDExIHx8IHRoaXMubm9kZVR5cGUgPT09IDkgKSB7XG5cdFx0XHRcdFx0XHR0aGlzLnRleHRDb250ZW50ID0gdmFsdWU7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9ICk7XG5cdFx0fSwgbnVsbCwgdmFsdWUsIGFyZ3VtZW50cy5sZW5ndGggKTtcblx0fSxcblxuXHRhcHBlbmQ6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiBkb21NYW5pcCggdGhpcywgYXJndW1lbnRzLCBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdGlmICggdGhpcy5ub2RlVHlwZSA9PT0gMSB8fCB0aGlzLm5vZGVUeXBlID09PSAxMSB8fCB0aGlzLm5vZGVUeXBlID09PSA5ICkge1xuXHRcdFx0XHR2YXIgdGFyZ2V0ID0gbWFuaXB1bGF0aW9uVGFyZ2V0KCB0aGlzLCBlbGVtICk7XG5cdFx0XHRcdHRhcmdldC5hcHBlbmRDaGlsZCggZWxlbSApO1xuXHRcdFx0fVxuXHRcdH0gKTtcblx0fSxcblxuXHRwcmVwZW5kOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gZG9tTWFuaXAoIHRoaXMsIGFyZ3VtZW50cywgZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRpZiAoIHRoaXMubm9kZVR5cGUgPT09IDEgfHwgdGhpcy5ub2RlVHlwZSA9PT0gMTEgfHwgdGhpcy5ub2RlVHlwZSA9PT0gOSApIHtcblx0XHRcdFx0dmFyIHRhcmdldCA9IG1hbmlwdWxhdGlvblRhcmdldCggdGhpcywgZWxlbSApO1xuXHRcdFx0XHR0YXJnZXQuaW5zZXJ0QmVmb3JlKCBlbGVtLCB0YXJnZXQuZmlyc3RDaGlsZCApO1xuXHRcdFx0fVxuXHRcdH0gKTtcblx0fSxcblxuXHRiZWZvcmU6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiBkb21NYW5pcCggdGhpcywgYXJndW1lbnRzLCBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdGlmICggdGhpcy5wYXJlbnROb2RlICkge1xuXHRcdFx0XHR0aGlzLnBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKCBlbGVtLCB0aGlzICk7XG5cdFx0XHR9XG5cdFx0fSApO1xuXHR9LFxuXG5cdGFmdGVyOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gZG9tTWFuaXAoIHRoaXMsIGFyZ3VtZW50cywgZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRpZiAoIHRoaXMucGFyZW50Tm9kZSApIHtcblx0XHRcdFx0dGhpcy5wYXJlbnROb2RlLmluc2VydEJlZm9yZSggZWxlbSwgdGhpcy5uZXh0U2libGluZyApO1xuXHRcdFx0fVxuXHRcdH0gKTtcblx0fSxcblxuXHRlbXB0eTogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIGVsZW0sXG5cdFx0XHRpID0gMDtcblxuXHRcdGZvciAoIDsgKCBlbGVtID0gdGhpc1sgaSBdICkgIT0gbnVsbDsgaSsrICkge1xuXHRcdFx0aWYgKCBlbGVtLm5vZGVUeXBlID09PSAxICkge1xuXG5cdFx0XHRcdC8vIFByZXZlbnQgbWVtb3J5IGxlYWtzXG5cdFx0XHRcdGpRdWVyeS5jbGVhbkRhdGEoIGdldEFsbCggZWxlbSwgZmFsc2UgKSApO1xuXG5cdFx0XHRcdC8vIFJlbW92ZSBhbnkgcmVtYWluaW5nIG5vZGVzXG5cdFx0XHRcdGVsZW0udGV4dENvbnRlbnQgPSBcIlwiO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHJldHVybiB0aGlzO1xuXHR9LFxuXG5cdGNsb25lOiBmdW5jdGlvbiggZGF0YUFuZEV2ZW50cywgZGVlcERhdGFBbmRFdmVudHMgKSB7XG5cdFx0ZGF0YUFuZEV2ZW50cyA9IGRhdGFBbmRFdmVudHMgPT0gbnVsbCA/IGZhbHNlIDogZGF0YUFuZEV2ZW50cztcblx0XHRkZWVwRGF0YUFuZEV2ZW50cyA9IGRlZXBEYXRhQW5kRXZlbnRzID09IG51bGwgPyBkYXRhQW5kRXZlbnRzIDogZGVlcERhdGFBbmRFdmVudHM7XG5cblx0XHRyZXR1cm4gdGhpcy5tYXAoIGZ1bmN0aW9uKCkge1xuXHRcdFx0cmV0dXJuIGpRdWVyeS5jbG9uZSggdGhpcywgZGF0YUFuZEV2ZW50cywgZGVlcERhdGFBbmRFdmVudHMgKTtcblx0XHR9ICk7XG5cdH0sXG5cblx0aHRtbDogZnVuY3Rpb24oIHZhbHVlICkge1xuXHRcdHJldHVybiBhY2Nlc3MoIHRoaXMsIGZ1bmN0aW9uKCB2YWx1ZSApIHtcblx0XHRcdHZhciBlbGVtID0gdGhpc1sgMCBdIHx8IHt9LFxuXHRcdFx0XHRpID0gMCxcblx0XHRcdFx0bCA9IHRoaXMubGVuZ3RoO1xuXG5cdFx0XHRpZiAoIHZhbHVlID09PSB1bmRlZmluZWQgJiYgZWxlbS5ub2RlVHlwZSA9PT0gMSApIHtcblx0XHRcdFx0cmV0dXJuIGVsZW0uaW5uZXJIVE1MO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBTZWUgaWYgd2UgY2FuIHRha2UgYSBzaG9ydGN1dCBhbmQganVzdCB1c2UgaW5uZXJIVE1MXG5cdFx0XHRpZiAoIHR5cGVvZiB2YWx1ZSA9PT0gXCJzdHJpbmdcIiAmJiAhcm5vSW5uZXJodG1sLnRlc3QoIHZhbHVlICkgJiZcblx0XHRcdFx0IXdyYXBNYXBbICggcnRhZ05hbWUuZXhlYyggdmFsdWUgKSB8fCBbIFwiXCIsIFwiXCIgXSApWyAxIF0udG9Mb3dlckNhc2UoKSBdICkge1xuXG5cdFx0XHRcdHZhbHVlID0galF1ZXJ5Lmh0bWxQcmVmaWx0ZXIoIHZhbHVlICk7XG5cblx0XHRcdFx0dHJ5IHtcblx0XHRcdFx0XHRmb3IgKCA7IGkgPCBsOyBpKysgKSB7XG5cdFx0XHRcdFx0XHRlbGVtID0gdGhpc1sgaSBdIHx8IHt9O1xuXG5cdFx0XHRcdFx0XHQvLyBSZW1vdmUgZWxlbWVudCBub2RlcyBhbmQgcHJldmVudCBtZW1vcnkgbGVha3Ncblx0XHRcdFx0XHRcdGlmICggZWxlbS5ub2RlVHlwZSA9PT0gMSApIHtcblx0XHRcdFx0XHRcdFx0alF1ZXJ5LmNsZWFuRGF0YSggZ2V0QWxsKCBlbGVtLCBmYWxzZSApICk7XG5cdFx0XHRcdFx0XHRcdGVsZW0uaW5uZXJIVE1MID0gdmFsdWU7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0ZWxlbSA9IDA7XG5cblx0XHRcdFx0Ly8gSWYgdXNpbmcgaW5uZXJIVE1MIHRocm93cyBhbiBleGNlcHRpb24sIHVzZSB0aGUgZmFsbGJhY2sgbWV0aG9kXG5cdFx0XHRcdH0gY2F0Y2ggKCBlICkge31cblx0XHRcdH1cblxuXHRcdFx0aWYgKCBlbGVtICkge1xuXHRcdFx0XHR0aGlzLmVtcHR5KCkuYXBwZW5kKCB2YWx1ZSApO1xuXHRcdFx0fVxuXHRcdH0sIG51bGwsIHZhbHVlLCBhcmd1bWVudHMubGVuZ3RoICk7XG5cdH0sXG5cblx0cmVwbGFjZVdpdGg6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBpZ25vcmVkID0gW107XG5cblx0XHQvLyBNYWtlIHRoZSBjaGFuZ2VzLCByZXBsYWNpbmcgZWFjaCBub24taWdub3JlZCBjb250ZXh0IGVsZW1lbnQgd2l0aCB0aGUgbmV3IGNvbnRlbnRcblx0XHRyZXR1cm4gZG9tTWFuaXAoIHRoaXMsIGFyZ3VtZW50cywgZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHR2YXIgcGFyZW50ID0gdGhpcy5wYXJlbnROb2RlO1xuXG5cdFx0XHRpZiAoIGpRdWVyeS5pbkFycmF5KCB0aGlzLCBpZ25vcmVkICkgPCAwICkge1xuXHRcdFx0XHRqUXVlcnkuY2xlYW5EYXRhKCBnZXRBbGwoIHRoaXMgKSApO1xuXHRcdFx0XHRpZiAoIHBhcmVudCApIHtcblx0XHRcdFx0XHRwYXJlbnQucmVwbGFjZUNoaWxkKCBlbGVtLCB0aGlzICk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdC8vIEZvcmNlIGNhbGxiYWNrIGludm9jYXRpb25cblx0XHR9LCBpZ25vcmVkICk7XG5cdH1cbn0gKTtcblxualF1ZXJ5LmVhY2goIHtcblx0YXBwZW5kVG86IFwiYXBwZW5kXCIsXG5cdHByZXBlbmRUbzogXCJwcmVwZW5kXCIsXG5cdGluc2VydEJlZm9yZTogXCJiZWZvcmVcIixcblx0aW5zZXJ0QWZ0ZXI6IFwiYWZ0ZXJcIixcblx0cmVwbGFjZUFsbDogXCJyZXBsYWNlV2l0aFwiXG59LCBmdW5jdGlvbiggbmFtZSwgb3JpZ2luYWwgKSB7XG5cdGpRdWVyeS5mblsgbmFtZSBdID0gZnVuY3Rpb24oIHNlbGVjdG9yICkge1xuXHRcdHZhciBlbGVtcyxcblx0XHRcdHJldCA9IFtdLFxuXHRcdFx0aW5zZXJ0ID0galF1ZXJ5KCBzZWxlY3RvciApLFxuXHRcdFx0bGFzdCA9IGluc2VydC5sZW5ndGggLSAxLFxuXHRcdFx0aSA9IDA7XG5cblx0XHRmb3IgKCA7IGkgPD0gbGFzdDsgaSsrICkge1xuXHRcdFx0ZWxlbXMgPSBpID09PSBsYXN0ID8gdGhpcyA6IHRoaXMuY2xvbmUoIHRydWUgKTtcblx0XHRcdGpRdWVyeSggaW5zZXJ0WyBpIF0gKVsgb3JpZ2luYWwgXSggZWxlbXMgKTtcblxuXHRcdFx0Ly8gU3VwcG9ydDogQW5kcm9pZCA8PTQuMCBvbmx5LCBQaGFudG9tSlMgMSBvbmx5XG5cdFx0XHQvLyAuZ2V0KCkgYmVjYXVzZSBwdXNoLmFwcGx5KF8sIGFycmF5bGlrZSkgdGhyb3dzIG9uIGFuY2llbnQgV2ViS2l0XG5cdFx0XHRwdXNoLmFwcGx5KCByZXQsIGVsZW1zLmdldCgpICk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRoaXMucHVzaFN0YWNrKCByZXQgKTtcblx0fTtcbn0gKTtcbnZhciBybnVtbm9ucHggPSBuZXcgUmVnRXhwKCBcIl4oXCIgKyBwbnVtICsgXCIpKD8hcHgpW2EteiVdKyRcIiwgXCJpXCIgKTtcblxudmFyIGdldFN0eWxlcyA9IGZ1bmN0aW9uKCBlbGVtICkge1xuXG5cdFx0Ly8gU3VwcG9ydDogSUUgPD0xMSBvbmx5LCBGaXJlZm94IDw9MzAgKCMxNTA5OCwgIzE0MTUwKVxuXHRcdC8vIElFIHRocm93cyBvbiBlbGVtZW50cyBjcmVhdGVkIGluIHBvcHVwc1xuXHRcdC8vIEZGIG1lYW53aGlsZSB0aHJvd3Mgb24gZnJhbWUgZWxlbWVudHMgdGhyb3VnaCBcImRlZmF1bHRWaWV3LmdldENvbXB1dGVkU3R5bGVcIlxuXHRcdHZhciB2aWV3ID0gZWxlbS5vd25lckRvY3VtZW50LmRlZmF1bHRWaWV3O1xuXG5cdFx0aWYgKCAhdmlldyB8fCAhdmlldy5vcGVuZXIgKSB7XG5cdFx0XHR2aWV3ID0gd2luZG93O1xuXHRcdH1cblxuXHRcdHJldHVybiB2aWV3LmdldENvbXB1dGVkU3R5bGUoIGVsZW0gKTtcblx0fTtcblxudmFyIHJib3hTdHlsZSA9IG5ldyBSZWdFeHAoIGNzc0V4cGFuZC5qb2luKCBcInxcIiApLCBcImlcIiApO1xuXG5cblxuKCBmdW5jdGlvbigpIHtcblxuXHQvLyBFeGVjdXRpbmcgYm90aCBwaXhlbFBvc2l0aW9uICYgYm94U2l6aW5nUmVsaWFibGUgdGVzdHMgcmVxdWlyZSBvbmx5IG9uZSBsYXlvdXRcblx0Ly8gc28gdGhleSdyZSBleGVjdXRlZCBhdCB0aGUgc2FtZSB0aW1lIHRvIHNhdmUgdGhlIHNlY29uZCBjb21wdXRhdGlvbi5cblx0ZnVuY3Rpb24gY29tcHV0ZVN0eWxlVGVzdHMoKSB7XG5cblx0XHQvLyBUaGlzIGlzIGEgc2luZ2xldG9uLCB3ZSBuZWVkIHRvIGV4ZWN1dGUgaXQgb25seSBvbmNlXG5cdFx0aWYgKCAhZGl2ICkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdGNvbnRhaW5lci5zdHlsZS5jc3NUZXh0ID0gXCJwb3NpdGlvbjphYnNvbHV0ZTtsZWZ0Oi0xMTExMXB4O3dpZHRoOjYwcHg7XCIgK1xuXHRcdFx0XCJtYXJnaW4tdG9wOjFweDtwYWRkaW5nOjA7Ym9yZGVyOjBcIjtcblx0XHRkaXYuc3R5bGUuY3NzVGV4dCA9XG5cdFx0XHRcInBvc2l0aW9uOnJlbGF0aXZlO2Rpc3BsYXk6YmxvY2s7Ym94LXNpemluZzpib3JkZXItYm94O292ZXJmbG93OnNjcm9sbDtcIiArXG5cdFx0XHRcIm1hcmdpbjphdXRvO2JvcmRlcjoxcHg7cGFkZGluZzoxcHg7XCIgK1xuXHRcdFx0XCJ3aWR0aDo2MCU7dG9wOjElXCI7XG5cdFx0ZG9jdW1lbnRFbGVtZW50LmFwcGVuZENoaWxkKCBjb250YWluZXIgKS5hcHBlbmRDaGlsZCggZGl2ICk7XG5cblx0XHR2YXIgZGl2U3R5bGUgPSB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZSggZGl2ICk7XG5cdFx0cGl4ZWxQb3NpdGlvblZhbCA9IGRpdlN0eWxlLnRvcCAhPT0gXCIxJVwiO1xuXG5cdFx0Ly8gU3VwcG9ydDogQW5kcm9pZCA0LjAgLSA0LjMgb25seSwgRmlyZWZveCA8PTMgLSA0NFxuXHRcdHJlbGlhYmxlTWFyZ2luTGVmdFZhbCA9IHJvdW5kUGl4ZWxNZWFzdXJlcyggZGl2U3R5bGUubWFyZ2luTGVmdCApID09PSAxMjtcblxuXHRcdC8vIFN1cHBvcnQ6IEFuZHJvaWQgNC4wIC0gNC4zIG9ubHksIFNhZmFyaSA8PTkuMSAtIDEwLjEsIGlPUyA8PTcuMCAtIDkuM1xuXHRcdC8vIFNvbWUgc3R5bGVzIGNvbWUgYmFjayB3aXRoIHBlcmNlbnRhZ2UgdmFsdWVzLCBldmVuIHRob3VnaCB0aGV5IHNob3VsZG4ndFxuXHRcdGRpdi5zdHlsZS5yaWdodCA9IFwiNjAlXCI7XG5cdFx0cGl4ZWxCb3hTdHlsZXNWYWwgPSByb3VuZFBpeGVsTWVhc3VyZXMoIGRpdlN0eWxlLnJpZ2h0ICkgPT09IDM2O1xuXG5cdFx0Ly8gU3VwcG9ydDogSUUgOSAtIDExIG9ubHlcblx0XHQvLyBEZXRlY3QgbWlzcmVwb3J0aW5nIG9mIGNvbnRlbnQgZGltZW5zaW9ucyBmb3IgYm94LXNpemluZzpib3JkZXItYm94IGVsZW1lbnRzXG5cdFx0Ym94U2l6aW5nUmVsaWFibGVWYWwgPSByb3VuZFBpeGVsTWVhc3VyZXMoIGRpdlN0eWxlLndpZHRoICkgPT09IDM2O1xuXG5cdFx0Ly8gU3VwcG9ydDogSUUgOSBvbmx5XG5cdFx0Ly8gRGV0ZWN0IG92ZXJmbG93OnNjcm9sbCBzY3Jld2luZXNzIChnaC0zNjk5KVxuXHRcdC8vIFN1cHBvcnQ6IENocm9tZSA8PTY0XG5cdFx0Ly8gRG9uJ3QgZ2V0IHRyaWNrZWQgd2hlbiB6b29tIGFmZmVjdHMgb2Zmc2V0V2lkdGggKGdoLTQwMjkpXG5cdFx0ZGl2LnN0eWxlLnBvc2l0aW9uID0gXCJhYnNvbHV0ZVwiO1xuXHRcdHNjcm9sbGJveFNpemVWYWwgPSByb3VuZFBpeGVsTWVhc3VyZXMoIGRpdi5vZmZzZXRXaWR0aCAvIDMgKSA9PT0gMTI7XG5cblx0XHRkb2N1bWVudEVsZW1lbnQucmVtb3ZlQ2hpbGQoIGNvbnRhaW5lciApO1xuXG5cdFx0Ly8gTnVsbGlmeSB0aGUgZGl2IHNvIGl0IHdvdWxkbid0IGJlIHN0b3JlZCBpbiB0aGUgbWVtb3J5IGFuZFxuXHRcdC8vIGl0IHdpbGwgYWxzbyBiZSBhIHNpZ24gdGhhdCBjaGVja3MgYWxyZWFkeSBwZXJmb3JtZWRcblx0XHRkaXYgPSBudWxsO1xuXHR9XG5cblx0ZnVuY3Rpb24gcm91bmRQaXhlbE1lYXN1cmVzKCBtZWFzdXJlICkge1xuXHRcdHJldHVybiBNYXRoLnJvdW5kKCBwYXJzZUZsb2F0KCBtZWFzdXJlICkgKTtcblx0fVxuXG5cdHZhciBwaXhlbFBvc2l0aW9uVmFsLCBib3hTaXppbmdSZWxpYWJsZVZhbCwgc2Nyb2xsYm94U2l6ZVZhbCwgcGl4ZWxCb3hTdHlsZXNWYWwsXG5cdFx0cmVsaWFibGVNYXJnaW5MZWZ0VmFsLFxuXHRcdGNvbnRhaW5lciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoIFwiZGl2XCIgKSxcblx0XHRkaXYgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCBcImRpdlwiICk7XG5cblx0Ly8gRmluaXNoIGVhcmx5IGluIGxpbWl0ZWQgKG5vbi1icm93c2VyKSBlbnZpcm9ubWVudHNcblx0aWYgKCAhZGl2LnN0eWxlICkge1xuXHRcdHJldHVybjtcblx0fVxuXG5cdC8vIFN1cHBvcnQ6IElFIDw9OSAtIDExIG9ubHlcblx0Ly8gU3R5bGUgb2YgY2xvbmVkIGVsZW1lbnQgYWZmZWN0cyBzb3VyY2UgZWxlbWVudCBjbG9uZWQgKCM4OTA4KVxuXHRkaXYuc3R5bGUuYmFja2dyb3VuZENsaXAgPSBcImNvbnRlbnQtYm94XCI7XG5cdGRpdi5jbG9uZU5vZGUoIHRydWUgKS5zdHlsZS5iYWNrZ3JvdW5kQ2xpcCA9IFwiXCI7XG5cdHN1cHBvcnQuY2xlYXJDbG9uZVN0eWxlID0gZGl2LnN0eWxlLmJhY2tncm91bmRDbGlwID09PSBcImNvbnRlbnQtYm94XCI7XG5cblx0alF1ZXJ5LmV4dGVuZCggc3VwcG9ydCwge1xuXHRcdGJveFNpemluZ1JlbGlhYmxlOiBmdW5jdGlvbigpIHtcblx0XHRcdGNvbXB1dGVTdHlsZVRlc3RzKCk7XG5cdFx0XHRyZXR1cm4gYm94U2l6aW5nUmVsaWFibGVWYWw7XG5cdFx0fSxcblx0XHRwaXhlbEJveFN0eWxlczogZnVuY3Rpb24oKSB7XG5cdFx0XHRjb21wdXRlU3R5bGVUZXN0cygpO1xuXHRcdFx0cmV0dXJuIHBpeGVsQm94U3R5bGVzVmFsO1xuXHRcdH0sXG5cdFx0cGl4ZWxQb3NpdGlvbjogZnVuY3Rpb24oKSB7XG5cdFx0XHRjb21wdXRlU3R5bGVUZXN0cygpO1xuXHRcdFx0cmV0dXJuIHBpeGVsUG9zaXRpb25WYWw7XG5cdFx0fSxcblx0XHRyZWxpYWJsZU1hcmdpbkxlZnQ6IGZ1bmN0aW9uKCkge1xuXHRcdFx0Y29tcHV0ZVN0eWxlVGVzdHMoKTtcblx0XHRcdHJldHVybiByZWxpYWJsZU1hcmdpbkxlZnRWYWw7XG5cdFx0fSxcblx0XHRzY3JvbGxib3hTaXplOiBmdW5jdGlvbigpIHtcblx0XHRcdGNvbXB1dGVTdHlsZVRlc3RzKCk7XG5cdFx0XHRyZXR1cm4gc2Nyb2xsYm94U2l6ZVZhbDtcblx0XHR9XG5cdH0gKTtcbn0gKSgpO1xuXG5cbmZ1bmN0aW9uIGN1ckNTUyggZWxlbSwgbmFtZSwgY29tcHV0ZWQgKSB7XG5cdHZhciB3aWR0aCwgbWluV2lkdGgsIG1heFdpZHRoLCByZXQsXG5cblx0XHQvLyBTdXBwb3J0OiBGaXJlZm94IDUxK1xuXHRcdC8vIFJldHJpZXZpbmcgc3R5bGUgYmVmb3JlIGNvbXB1dGVkIHNvbWVob3dcblx0XHQvLyBmaXhlcyBhbiBpc3N1ZSB3aXRoIGdldHRpbmcgd3JvbmcgdmFsdWVzXG5cdFx0Ly8gb24gZGV0YWNoZWQgZWxlbWVudHNcblx0XHRzdHlsZSA9IGVsZW0uc3R5bGU7XG5cblx0Y29tcHV0ZWQgPSBjb21wdXRlZCB8fCBnZXRTdHlsZXMoIGVsZW0gKTtcblxuXHQvLyBnZXRQcm9wZXJ0eVZhbHVlIGlzIG5lZWRlZCBmb3I6XG5cdC8vICAgLmNzcygnZmlsdGVyJykgKElFIDkgb25seSwgIzEyNTM3KVxuXHQvLyAgIC5jc3MoJy0tY3VzdG9tUHJvcGVydHkpICgjMzE0NClcblx0aWYgKCBjb21wdXRlZCApIHtcblx0XHRyZXQgPSBjb21wdXRlZC5nZXRQcm9wZXJ0eVZhbHVlKCBuYW1lICkgfHwgY29tcHV0ZWRbIG5hbWUgXTtcblxuXHRcdGlmICggcmV0ID09PSBcIlwiICYmICFpc0F0dGFjaGVkKCBlbGVtICkgKSB7XG5cdFx0XHRyZXQgPSBqUXVlcnkuc3R5bGUoIGVsZW0sIG5hbWUgKTtcblx0XHR9XG5cblx0XHQvLyBBIHRyaWJ1dGUgdG8gdGhlIFwiYXdlc29tZSBoYWNrIGJ5IERlYW4gRWR3YXJkc1wiXG5cdFx0Ly8gQW5kcm9pZCBCcm93c2VyIHJldHVybnMgcGVyY2VudGFnZSBmb3Igc29tZSB2YWx1ZXMsXG5cdFx0Ly8gYnV0IHdpZHRoIHNlZW1zIHRvIGJlIHJlbGlhYmx5IHBpeGVscy5cblx0XHQvLyBUaGlzIGlzIGFnYWluc3QgdGhlIENTU09NIGRyYWZ0IHNwZWM6XG5cdFx0Ly8gaHR0cHM6Ly9kcmFmdHMuY3Nzd2cub3JnL2Nzc29tLyNyZXNvbHZlZC12YWx1ZXNcblx0XHRpZiAoICFzdXBwb3J0LnBpeGVsQm94U3R5bGVzKCkgJiYgcm51bW5vbnB4LnRlc3QoIHJldCApICYmIHJib3hTdHlsZS50ZXN0KCBuYW1lICkgKSB7XG5cblx0XHRcdC8vIFJlbWVtYmVyIHRoZSBvcmlnaW5hbCB2YWx1ZXNcblx0XHRcdHdpZHRoID0gc3R5bGUud2lkdGg7XG5cdFx0XHRtaW5XaWR0aCA9IHN0eWxlLm1pbldpZHRoO1xuXHRcdFx0bWF4V2lkdGggPSBzdHlsZS5tYXhXaWR0aDtcblxuXHRcdFx0Ly8gUHV0IGluIHRoZSBuZXcgdmFsdWVzIHRvIGdldCBhIGNvbXB1dGVkIHZhbHVlIG91dFxuXHRcdFx0c3R5bGUubWluV2lkdGggPSBzdHlsZS5tYXhXaWR0aCA9IHN0eWxlLndpZHRoID0gcmV0O1xuXHRcdFx0cmV0ID0gY29tcHV0ZWQud2lkdGg7XG5cblx0XHRcdC8vIFJldmVydCB0aGUgY2hhbmdlZCB2YWx1ZXNcblx0XHRcdHN0eWxlLndpZHRoID0gd2lkdGg7XG5cdFx0XHRzdHlsZS5taW5XaWR0aCA9IG1pbldpZHRoO1xuXHRcdFx0c3R5bGUubWF4V2lkdGggPSBtYXhXaWR0aDtcblx0XHR9XG5cdH1cblxuXHRyZXR1cm4gcmV0ICE9PSB1bmRlZmluZWQgP1xuXG5cdFx0Ly8gU3VwcG9ydDogSUUgPD05IC0gMTEgb25seVxuXHRcdC8vIElFIHJldHVybnMgekluZGV4IHZhbHVlIGFzIGFuIGludGVnZXIuXG5cdFx0cmV0ICsgXCJcIiA6XG5cdFx0cmV0O1xufVxuXG5cbmZ1bmN0aW9uIGFkZEdldEhvb2tJZiggY29uZGl0aW9uRm4sIGhvb2tGbiApIHtcblxuXHQvLyBEZWZpbmUgdGhlIGhvb2ssIHdlJ2xsIGNoZWNrIG9uIHRoZSBmaXJzdCBydW4gaWYgaXQncyByZWFsbHkgbmVlZGVkLlxuXHRyZXR1cm4ge1xuXHRcdGdldDogZnVuY3Rpb24oKSB7XG5cdFx0XHRpZiAoIGNvbmRpdGlvbkZuKCkgKSB7XG5cblx0XHRcdFx0Ly8gSG9vayBub3QgbmVlZGVkIChvciBpdCdzIG5vdCBwb3NzaWJsZSB0byB1c2UgaXQgZHVlXG5cdFx0XHRcdC8vIHRvIG1pc3NpbmcgZGVwZW5kZW5jeSksIHJlbW92ZSBpdC5cblx0XHRcdFx0ZGVsZXRlIHRoaXMuZ2V0O1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cblx0XHRcdC8vIEhvb2sgbmVlZGVkOyByZWRlZmluZSBpdCBzbyB0aGF0IHRoZSBzdXBwb3J0IHRlc3QgaXMgbm90IGV4ZWN1dGVkIGFnYWluLlxuXHRcdFx0cmV0dXJuICggdGhpcy5nZXQgPSBob29rRm4gKS5hcHBseSggdGhpcywgYXJndW1lbnRzICk7XG5cdFx0fVxuXHR9O1xufVxuXG5cbnZhciBjc3NQcmVmaXhlcyA9IFsgXCJXZWJraXRcIiwgXCJNb3pcIiwgXCJtc1wiIF0sXG5cdGVtcHR5U3R5bGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCBcImRpdlwiICkuc3R5bGUsXG5cdHZlbmRvclByb3BzID0ge307XG5cbi8vIFJldHVybiBhIHZlbmRvci1wcmVmaXhlZCBwcm9wZXJ0eSBvciB1bmRlZmluZWRcbmZ1bmN0aW9uIHZlbmRvclByb3BOYW1lKCBuYW1lICkge1xuXG5cdC8vIENoZWNrIGZvciB2ZW5kb3IgcHJlZml4ZWQgbmFtZXNcblx0dmFyIGNhcE5hbWUgPSBuYW1lWyAwIF0udG9VcHBlckNhc2UoKSArIG5hbWUuc2xpY2UoIDEgKSxcblx0XHRpID0gY3NzUHJlZml4ZXMubGVuZ3RoO1xuXG5cdHdoaWxlICggaS0tICkge1xuXHRcdG5hbWUgPSBjc3NQcmVmaXhlc1sgaSBdICsgY2FwTmFtZTtcblx0XHRpZiAoIG5hbWUgaW4gZW1wdHlTdHlsZSApIHtcblx0XHRcdHJldHVybiBuYW1lO1xuXHRcdH1cblx0fVxufVxuXG4vLyBSZXR1cm4gYSBwb3RlbnRpYWxseS1tYXBwZWQgalF1ZXJ5LmNzc1Byb3BzIG9yIHZlbmRvciBwcmVmaXhlZCBwcm9wZXJ0eVxuZnVuY3Rpb24gZmluYWxQcm9wTmFtZSggbmFtZSApIHtcblx0dmFyIGZpbmFsID0galF1ZXJ5LmNzc1Byb3BzWyBuYW1lIF0gfHwgdmVuZG9yUHJvcHNbIG5hbWUgXTtcblxuXHRpZiAoIGZpbmFsICkge1xuXHRcdHJldHVybiBmaW5hbDtcblx0fVxuXHRpZiAoIG5hbWUgaW4gZW1wdHlTdHlsZSApIHtcblx0XHRyZXR1cm4gbmFtZTtcblx0fVxuXHRyZXR1cm4gdmVuZG9yUHJvcHNbIG5hbWUgXSA9IHZlbmRvclByb3BOYW1lKCBuYW1lICkgfHwgbmFtZTtcbn1cblxuXG52YXJcblxuXHQvLyBTd2FwcGFibGUgaWYgZGlzcGxheSBpcyBub25lIG9yIHN0YXJ0cyB3aXRoIHRhYmxlXG5cdC8vIGV4Y2VwdCBcInRhYmxlXCIsIFwidGFibGUtY2VsbFwiLCBvciBcInRhYmxlLWNhcHRpb25cIlxuXHQvLyBTZWUgaGVyZSBmb3IgZGlzcGxheSB2YWx1ZXM6IGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvQ1NTL2Rpc3BsYXlcblx0cmRpc3BsYXlzd2FwID0gL14obm9uZXx0YWJsZSg/IS1jW2VhXSkuKykvLFxuXHRyY3VzdG9tUHJvcCA9IC9eLS0vLFxuXHRjc3NTaG93ID0geyBwb3NpdGlvbjogXCJhYnNvbHV0ZVwiLCB2aXNpYmlsaXR5OiBcImhpZGRlblwiLCBkaXNwbGF5OiBcImJsb2NrXCIgfSxcblx0Y3NzTm9ybWFsVHJhbnNmb3JtID0ge1xuXHRcdGxldHRlclNwYWNpbmc6IFwiMFwiLFxuXHRcdGZvbnRXZWlnaHQ6IFwiNDAwXCJcblx0fTtcblxuZnVuY3Rpb24gc2V0UG9zaXRpdmVOdW1iZXIoIGVsZW0sIHZhbHVlLCBzdWJ0cmFjdCApIHtcblxuXHQvLyBBbnkgcmVsYXRpdmUgKCsvLSkgdmFsdWVzIGhhdmUgYWxyZWFkeSBiZWVuXG5cdC8vIG5vcm1hbGl6ZWQgYXQgdGhpcyBwb2ludFxuXHR2YXIgbWF0Y2hlcyA9IHJjc3NOdW0uZXhlYyggdmFsdWUgKTtcblx0cmV0dXJuIG1hdGNoZXMgP1xuXG5cdFx0Ly8gR3VhcmQgYWdhaW5zdCB1bmRlZmluZWQgXCJzdWJ0cmFjdFwiLCBlLmcuLCB3aGVuIHVzZWQgYXMgaW4gY3NzSG9va3Ncblx0XHRNYXRoLm1heCggMCwgbWF0Y2hlc1sgMiBdIC0gKCBzdWJ0cmFjdCB8fCAwICkgKSArICggbWF0Y2hlc1sgMyBdIHx8IFwicHhcIiApIDpcblx0XHR2YWx1ZTtcbn1cblxuZnVuY3Rpb24gYm94TW9kZWxBZGp1c3RtZW50KCBlbGVtLCBkaW1lbnNpb24sIGJveCwgaXNCb3JkZXJCb3gsIHN0eWxlcywgY29tcHV0ZWRWYWwgKSB7XG5cdHZhciBpID0gZGltZW5zaW9uID09PSBcIndpZHRoXCIgPyAxIDogMCxcblx0XHRleHRyYSA9IDAsXG5cdFx0ZGVsdGEgPSAwO1xuXG5cdC8vIEFkanVzdG1lbnQgbWF5IG5vdCBiZSBuZWNlc3Nhcnlcblx0aWYgKCBib3ggPT09ICggaXNCb3JkZXJCb3ggPyBcImJvcmRlclwiIDogXCJjb250ZW50XCIgKSApIHtcblx0XHRyZXR1cm4gMDtcblx0fVxuXG5cdGZvciAoIDsgaSA8IDQ7IGkgKz0gMiApIHtcblxuXHRcdC8vIEJvdGggYm94IG1vZGVscyBleGNsdWRlIG1hcmdpblxuXHRcdGlmICggYm94ID09PSBcIm1hcmdpblwiICkge1xuXHRcdFx0ZGVsdGEgKz0galF1ZXJ5LmNzcyggZWxlbSwgYm94ICsgY3NzRXhwYW5kWyBpIF0sIHRydWUsIHN0eWxlcyApO1xuXHRcdH1cblxuXHRcdC8vIElmIHdlIGdldCBoZXJlIHdpdGggYSBjb250ZW50LWJveCwgd2UncmUgc2Vla2luZyBcInBhZGRpbmdcIiBvciBcImJvcmRlclwiIG9yIFwibWFyZ2luXCJcblx0XHRpZiAoICFpc0JvcmRlckJveCApIHtcblxuXHRcdFx0Ly8gQWRkIHBhZGRpbmdcblx0XHRcdGRlbHRhICs9IGpRdWVyeS5jc3MoIGVsZW0sIFwicGFkZGluZ1wiICsgY3NzRXhwYW5kWyBpIF0sIHRydWUsIHN0eWxlcyApO1xuXG5cdFx0XHQvLyBGb3IgXCJib3JkZXJcIiBvciBcIm1hcmdpblwiLCBhZGQgYm9yZGVyXG5cdFx0XHRpZiAoIGJveCAhPT0gXCJwYWRkaW5nXCIgKSB7XG5cdFx0XHRcdGRlbHRhICs9IGpRdWVyeS5jc3MoIGVsZW0sIFwiYm9yZGVyXCIgKyBjc3NFeHBhbmRbIGkgXSArIFwiV2lkdGhcIiwgdHJ1ZSwgc3R5bGVzICk7XG5cblx0XHRcdC8vIEJ1dCBzdGlsbCBrZWVwIHRyYWNrIG9mIGl0IG90aGVyd2lzZVxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0ZXh0cmEgKz0galF1ZXJ5LmNzcyggZWxlbSwgXCJib3JkZXJcIiArIGNzc0V4cGFuZFsgaSBdICsgXCJXaWR0aFwiLCB0cnVlLCBzdHlsZXMgKTtcblx0XHRcdH1cblxuXHRcdC8vIElmIHdlIGdldCBoZXJlIHdpdGggYSBib3JkZXItYm94IChjb250ZW50ICsgcGFkZGluZyArIGJvcmRlciksIHdlJ3JlIHNlZWtpbmcgXCJjb250ZW50XCIgb3Jcblx0XHQvLyBcInBhZGRpbmdcIiBvciBcIm1hcmdpblwiXG5cdFx0fSBlbHNlIHtcblxuXHRcdFx0Ly8gRm9yIFwiY29udGVudFwiLCBzdWJ0cmFjdCBwYWRkaW5nXG5cdFx0XHRpZiAoIGJveCA9PT0gXCJjb250ZW50XCIgKSB7XG5cdFx0XHRcdGRlbHRhIC09IGpRdWVyeS5jc3MoIGVsZW0sIFwicGFkZGluZ1wiICsgY3NzRXhwYW5kWyBpIF0sIHRydWUsIHN0eWxlcyApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBGb3IgXCJjb250ZW50XCIgb3IgXCJwYWRkaW5nXCIsIHN1YnRyYWN0IGJvcmRlclxuXHRcdFx0aWYgKCBib3ggIT09IFwibWFyZ2luXCIgKSB7XG5cdFx0XHRcdGRlbHRhIC09IGpRdWVyeS5jc3MoIGVsZW0sIFwiYm9yZGVyXCIgKyBjc3NFeHBhbmRbIGkgXSArIFwiV2lkdGhcIiwgdHJ1ZSwgc3R5bGVzICk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0Ly8gQWNjb3VudCBmb3IgcG9zaXRpdmUgY29udGVudC1ib3ggc2Nyb2xsIGd1dHRlciB3aGVuIHJlcXVlc3RlZCBieSBwcm92aWRpbmcgY29tcHV0ZWRWYWxcblx0aWYgKCAhaXNCb3JkZXJCb3ggJiYgY29tcHV0ZWRWYWwgPj0gMCApIHtcblxuXHRcdC8vIG9mZnNldFdpZHRoL29mZnNldEhlaWdodCBpcyBhIHJvdW5kZWQgc3VtIG9mIGNvbnRlbnQsIHBhZGRpbmcsIHNjcm9sbCBndXR0ZXIsIGFuZCBib3JkZXJcblx0XHQvLyBBc3N1bWluZyBpbnRlZ2VyIHNjcm9sbCBndXR0ZXIsIHN1YnRyYWN0IHRoZSByZXN0IGFuZCByb3VuZCBkb3duXG5cdFx0ZGVsdGEgKz0gTWF0aC5tYXgoIDAsIE1hdGguY2VpbChcblx0XHRcdGVsZW1bIFwib2Zmc2V0XCIgKyBkaW1lbnNpb25bIDAgXS50b1VwcGVyQ2FzZSgpICsgZGltZW5zaW9uLnNsaWNlKCAxICkgXSAtXG5cdFx0XHRjb21wdXRlZFZhbCAtXG5cdFx0XHRkZWx0YSAtXG5cdFx0XHRleHRyYSAtXG5cdFx0XHQwLjVcblxuXHRcdC8vIElmIG9mZnNldFdpZHRoL29mZnNldEhlaWdodCBpcyB1bmtub3duLCB0aGVuIHdlIGNhbid0IGRldGVybWluZSBjb250ZW50LWJveCBzY3JvbGwgZ3V0dGVyXG5cdFx0Ly8gVXNlIGFuIGV4cGxpY2l0IHplcm8gdG8gYXZvaWQgTmFOIChnaC0zOTY0KVxuXHRcdCkgKSB8fCAwO1xuXHR9XG5cblx0cmV0dXJuIGRlbHRhO1xufVxuXG5mdW5jdGlvbiBnZXRXaWR0aE9ySGVpZ2h0KCBlbGVtLCBkaW1lbnNpb24sIGV4dHJhICkge1xuXG5cdC8vIFN0YXJ0IHdpdGggY29tcHV0ZWQgc3R5bGVcblx0dmFyIHN0eWxlcyA9IGdldFN0eWxlcyggZWxlbSApLFxuXG5cdFx0Ly8gVG8gYXZvaWQgZm9yY2luZyBhIHJlZmxvdywgb25seSBmZXRjaCBib3hTaXppbmcgaWYgd2UgbmVlZCBpdCAoZ2gtNDMyMikuXG5cdFx0Ly8gRmFrZSBjb250ZW50LWJveCB1bnRpbCB3ZSBrbm93IGl0J3MgbmVlZGVkIHRvIGtub3cgdGhlIHRydWUgdmFsdWUuXG5cdFx0Ym94U2l6aW5nTmVlZGVkID0gIXN1cHBvcnQuYm94U2l6aW5nUmVsaWFibGUoKSB8fCBleHRyYSxcblx0XHRpc0JvcmRlckJveCA9IGJveFNpemluZ05lZWRlZCAmJlxuXHRcdFx0alF1ZXJ5LmNzcyggZWxlbSwgXCJib3hTaXppbmdcIiwgZmFsc2UsIHN0eWxlcyApID09PSBcImJvcmRlci1ib3hcIixcblx0XHR2YWx1ZUlzQm9yZGVyQm94ID0gaXNCb3JkZXJCb3gsXG5cblx0XHR2YWwgPSBjdXJDU1MoIGVsZW0sIGRpbWVuc2lvbiwgc3R5bGVzICksXG5cdFx0b2Zmc2V0UHJvcCA9IFwib2Zmc2V0XCIgKyBkaW1lbnNpb25bIDAgXS50b1VwcGVyQ2FzZSgpICsgZGltZW5zaW9uLnNsaWNlKCAxICk7XG5cblx0Ly8gU3VwcG9ydDogRmlyZWZveCA8PTU0XG5cdC8vIFJldHVybiBhIGNvbmZvdW5kaW5nIG5vbi1waXhlbCB2YWx1ZSBvciBmZWlnbiBpZ25vcmFuY2UsIGFzIGFwcHJvcHJpYXRlLlxuXHRpZiAoIHJudW1ub25weC50ZXN0KCB2YWwgKSApIHtcblx0XHRpZiAoICFleHRyYSApIHtcblx0XHRcdHJldHVybiB2YWw7XG5cdFx0fVxuXHRcdHZhbCA9IFwiYXV0b1wiO1xuXHR9XG5cblxuXHQvLyBGYWxsIGJhY2sgdG8gb2Zmc2V0V2lkdGgvb2Zmc2V0SGVpZ2h0IHdoZW4gdmFsdWUgaXMgXCJhdXRvXCJcblx0Ly8gVGhpcyBoYXBwZW5zIGZvciBpbmxpbmUgZWxlbWVudHMgd2l0aCBubyBleHBsaWNpdCBzZXR0aW5nIChnaC0zNTcxKVxuXHQvLyBTdXBwb3J0OiBBbmRyb2lkIDw9NC4xIC0gNC4zIG9ubHlcblx0Ly8gQWxzbyB1c2Ugb2Zmc2V0V2lkdGgvb2Zmc2V0SGVpZ2h0IGZvciBtaXNyZXBvcnRlZCBpbmxpbmUgZGltZW5zaW9ucyAoZ2gtMzYwMilcblx0Ly8gU3VwcG9ydDogSUUgOS0xMSBvbmx5XG5cdC8vIEFsc28gdXNlIG9mZnNldFdpZHRoL29mZnNldEhlaWdodCBmb3Igd2hlbiBib3ggc2l6aW5nIGlzIHVucmVsaWFibGVcblx0Ly8gV2UgdXNlIGdldENsaWVudFJlY3RzKCkgdG8gY2hlY2sgZm9yIGhpZGRlbi9kaXNjb25uZWN0ZWQuXG5cdC8vIEluIHRob3NlIGNhc2VzLCB0aGUgY29tcHV0ZWQgdmFsdWUgY2FuIGJlIHRydXN0ZWQgdG8gYmUgYm9yZGVyLWJveFxuXHRpZiAoICggIXN1cHBvcnQuYm94U2l6aW5nUmVsaWFibGUoKSAmJiBpc0JvcmRlckJveCB8fFxuXHRcdHZhbCA9PT0gXCJhdXRvXCIgfHxcblx0XHQhcGFyc2VGbG9hdCggdmFsICkgJiYgalF1ZXJ5LmNzcyggZWxlbSwgXCJkaXNwbGF5XCIsIGZhbHNlLCBzdHlsZXMgKSA9PT0gXCJpbmxpbmVcIiApICYmXG5cdFx0ZWxlbS5nZXRDbGllbnRSZWN0cygpLmxlbmd0aCApIHtcblxuXHRcdGlzQm9yZGVyQm94ID0galF1ZXJ5LmNzcyggZWxlbSwgXCJib3hTaXppbmdcIiwgZmFsc2UsIHN0eWxlcyApID09PSBcImJvcmRlci1ib3hcIjtcblxuXHRcdC8vIFdoZXJlIGF2YWlsYWJsZSwgb2Zmc2V0V2lkdGgvb2Zmc2V0SGVpZ2h0IGFwcHJveGltYXRlIGJvcmRlciBib3ggZGltZW5zaW9ucy5cblx0XHQvLyBXaGVyZSBub3QgYXZhaWxhYmxlIChlLmcuLCBTVkcpLCBhc3N1bWUgdW5yZWxpYWJsZSBib3gtc2l6aW5nIGFuZCBpbnRlcnByZXQgdGhlXG5cdFx0Ly8gcmV0cmlldmVkIHZhbHVlIGFzIGEgY29udGVudCBib3ggZGltZW5zaW9uLlxuXHRcdHZhbHVlSXNCb3JkZXJCb3ggPSBvZmZzZXRQcm9wIGluIGVsZW07XG5cdFx0aWYgKCB2YWx1ZUlzQm9yZGVyQm94ICkge1xuXHRcdFx0dmFsID0gZWxlbVsgb2Zmc2V0UHJvcCBdO1xuXHRcdH1cblx0fVxuXG5cdC8vIE5vcm1hbGl6ZSBcIlwiIGFuZCBhdXRvXG5cdHZhbCA9IHBhcnNlRmxvYXQoIHZhbCApIHx8IDA7XG5cblx0Ly8gQWRqdXN0IGZvciB0aGUgZWxlbWVudCdzIGJveCBtb2RlbFxuXHRyZXR1cm4gKCB2YWwgK1xuXHRcdGJveE1vZGVsQWRqdXN0bWVudChcblx0XHRcdGVsZW0sXG5cdFx0XHRkaW1lbnNpb24sXG5cdFx0XHRleHRyYSB8fCAoIGlzQm9yZGVyQm94ID8gXCJib3JkZXJcIiA6IFwiY29udGVudFwiICksXG5cdFx0XHR2YWx1ZUlzQm9yZGVyQm94LFxuXHRcdFx0c3R5bGVzLFxuXG5cdFx0XHQvLyBQcm92aWRlIHRoZSBjdXJyZW50IGNvbXB1dGVkIHNpemUgdG8gcmVxdWVzdCBzY3JvbGwgZ3V0dGVyIGNhbGN1bGF0aW9uIChnaC0zNTg5KVxuXHRcdFx0dmFsXG5cdFx0KVxuXHQpICsgXCJweFwiO1xufVxuXG5qUXVlcnkuZXh0ZW5kKCB7XG5cblx0Ly8gQWRkIGluIHN0eWxlIHByb3BlcnR5IGhvb2tzIGZvciBvdmVycmlkaW5nIHRoZSBkZWZhdWx0XG5cdC8vIGJlaGF2aW9yIG9mIGdldHRpbmcgYW5kIHNldHRpbmcgYSBzdHlsZSBwcm9wZXJ0eVxuXHRjc3NIb29rczoge1xuXHRcdG9wYWNpdHk6IHtcblx0XHRcdGdldDogZnVuY3Rpb24oIGVsZW0sIGNvbXB1dGVkICkge1xuXHRcdFx0XHRpZiAoIGNvbXB1dGVkICkge1xuXG5cdFx0XHRcdFx0Ly8gV2Ugc2hvdWxkIGFsd2F5cyBnZXQgYSBudW1iZXIgYmFjayBmcm9tIG9wYWNpdHlcblx0XHRcdFx0XHR2YXIgcmV0ID0gY3VyQ1NTKCBlbGVtLCBcIm9wYWNpdHlcIiApO1xuXHRcdFx0XHRcdHJldHVybiByZXQgPT09IFwiXCIgPyBcIjFcIiA6IHJldDtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fSxcblxuXHQvLyBEb24ndCBhdXRvbWF0aWNhbGx5IGFkZCBcInB4XCIgdG8gdGhlc2UgcG9zc2libHktdW5pdGxlc3MgcHJvcGVydGllc1xuXHRjc3NOdW1iZXI6IHtcblx0XHRcImFuaW1hdGlvbkl0ZXJhdGlvbkNvdW50XCI6IHRydWUsXG5cdFx0XCJjb2x1bW5Db3VudFwiOiB0cnVlLFxuXHRcdFwiZmlsbE9wYWNpdHlcIjogdHJ1ZSxcblx0XHRcImZsZXhHcm93XCI6IHRydWUsXG5cdFx0XCJmbGV4U2hyaW5rXCI6IHRydWUsXG5cdFx0XCJmb250V2VpZ2h0XCI6IHRydWUsXG5cdFx0XCJncmlkQXJlYVwiOiB0cnVlLFxuXHRcdFwiZ3JpZENvbHVtblwiOiB0cnVlLFxuXHRcdFwiZ3JpZENvbHVtbkVuZFwiOiB0cnVlLFxuXHRcdFwiZ3JpZENvbHVtblN0YXJ0XCI6IHRydWUsXG5cdFx0XCJncmlkUm93XCI6IHRydWUsXG5cdFx0XCJncmlkUm93RW5kXCI6IHRydWUsXG5cdFx0XCJncmlkUm93U3RhcnRcIjogdHJ1ZSxcblx0XHRcImxpbmVIZWlnaHRcIjogdHJ1ZSxcblx0XHRcIm9wYWNpdHlcIjogdHJ1ZSxcblx0XHRcIm9yZGVyXCI6IHRydWUsXG5cdFx0XCJvcnBoYW5zXCI6IHRydWUsXG5cdFx0XCJ3aWRvd3NcIjogdHJ1ZSxcblx0XHRcInpJbmRleFwiOiB0cnVlLFxuXHRcdFwiem9vbVwiOiB0cnVlXG5cdH0sXG5cblx0Ly8gQWRkIGluIHByb3BlcnRpZXMgd2hvc2UgbmFtZXMgeW91IHdpc2ggdG8gZml4IGJlZm9yZVxuXHQvLyBzZXR0aW5nIG9yIGdldHRpbmcgdGhlIHZhbHVlXG5cdGNzc1Byb3BzOiB7fSxcblxuXHQvLyBHZXQgYW5kIHNldCB0aGUgc3R5bGUgcHJvcGVydHkgb24gYSBET00gTm9kZVxuXHRzdHlsZTogZnVuY3Rpb24oIGVsZW0sIG5hbWUsIHZhbHVlLCBleHRyYSApIHtcblxuXHRcdC8vIERvbid0IHNldCBzdHlsZXMgb24gdGV4dCBhbmQgY29tbWVudCBub2Rlc1xuXHRcdGlmICggIWVsZW0gfHwgZWxlbS5ub2RlVHlwZSA9PT0gMyB8fCBlbGVtLm5vZGVUeXBlID09PSA4IHx8ICFlbGVtLnN0eWxlICkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdC8vIE1ha2Ugc3VyZSB0aGF0IHdlJ3JlIHdvcmtpbmcgd2l0aCB0aGUgcmlnaHQgbmFtZVxuXHRcdHZhciByZXQsIHR5cGUsIGhvb2tzLFxuXHRcdFx0b3JpZ05hbWUgPSBjYW1lbENhc2UoIG5hbWUgKSxcblx0XHRcdGlzQ3VzdG9tUHJvcCA9IHJjdXN0b21Qcm9wLnRlc3QoIG5hbWUgKSxcblx0XHRcdHN0eWxlID0gZWxlbS5zdHlsZTtcblxuXHRcdC8vIE1ha2Ugc3VyZSB0aGF0IHdlJ3JlIHdvcmtpbmcgd2l0aCB0aGUgcmlnaHQgbmFtZS4gV2UgZG9uJ3Rcblx0XHQvLyB3YW50IHRvIHF1ZXJ5IHRoZSB2YWx1ZSBpZiBpdCBpcyBhIENTUyBjdXN0b20gcHJvcGVydHlcblx0XHQvLyBzaW5jZSB0aGV5IGFyZSB1c2VyLWRlZmluZWQuXG5cdFx0aWYgKCAhaXNDdXN0b21Qcm9wICkge1xuXHRcdFx0bmFtZSA9IGZpbmFsUHJvcE5hbWUoIG9yaWdOYW1lICk7XG5cdFx0fVxuXG5cdFx0Ly8gR2V0cyBob29rIGZvciB0aGUgcHJlZml4ZWQgdmVyc2lvbiwgdGhlbiB1bnByZWZpeGVkIHZlcnNpb25cblx0XHRob29rcyA9IGpRdWVyeS5jc3NIb29rc1sgbmFtZSBdIHx8IGpRdWVyeS5jc3NIb29rc1sgb3JpZ05hbWUgXTtcblxuXHRcdC8vIENoZWNrIGlmIHdlJ3JlIHNldHRpbmcgYSB2YWx1ZVxuXHRcdGlmICggdmFsdWUgIT09IHVuZGVmaW5lZCApIHtcblx0XHRcdHR5cGUgPSB0eXBlb2YgdmFsdWU7XG5cblx0XHRcdC8vIENvbnZlcnQgXCIrPVwiIG9yIFwiLT1cIiB0byByZWxhdGl2ZSBudW1iZXJzICgjNzM0NSlcblx0XHRcdGlmICggdHlwZSA9PT0gXCJzdHJpbmdcIiAmJiAoIHJldCA9IHJjc3NOdW0uZXhlYyggdmFsdWUgKSApICYmIHJldFsgMSBdICkge1xuXHRcdFx0XHR2YWx1ZSA9IGFkanVzdENTUyggZWxlbSwgbmFtZSwgcmV0ICk7XG5cblx0XHRcdFx0Ly8gRml4ZXMgYnVnICM5MjM3XG5cdFx0XHRcdHR5cGUgPSBcIm51bWJlclwiO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBNYWtlIHN1cmUgdGhhdCBudWxsIGFuZCBOYU4gdmFsdWVzIGFyZW4ndCBzZXQgKCM3MTE2KVxuXHRcdFx0aWYgKCB2YWx1ZSA9PSBudWxsIHx8IHZhbHVlICE9PSB2YWx1ZSApIHtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBJZiBhIG51bWJlciB3YXMgcGFzc2VkIGluLCBhZGQgdGhlIHVuaXQgKGV4Y2VwdCBmb3IgY2VydGFpbiBDU1MgcHJvcGVydGllcylcblx0XHRcdC8vIFRoZSBpc0N1c3RvbVByb3AgY2hlY2sgY2FuIGJlIHJlbW92ZWQgaW4galF1ZXJ5IDQuMCB3aGVuIHdlIG9ubHkgYXV0by1hcHBlbmRcblx0XHRcdC8vIFwicHhcIiB0byBhIGZldyBoYXJkY29kZWQgdmFsdWVzLlxuXHRcdFx0aWYgKCB0eXBlID09PSBcIm51bWJlclwiICYmICFpc0N1c3RvbVByb3AgKSB7XG5cdFx0XHRcdHZhbHVlICs9IHJldCAmJiByZXRbIDMgXSB8fCAoIGpRdWVyeS5jc3NOdW1iZXJbIG9yaWdOYW1lIF0gPyBcIlwiIDogXCJweFwiICk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIGJhY2tncm91bmQtKiBwcm9wcyBhZmZlY3Qgb3JpZ2luYWwgY2xvbmUncyB2YWx1ZXNcblx0XHRcdGlmICggIXN1cHBvcnQuY2xlYXJDbG9uZVN0eWxlICYmIHZhbHVlID09PSBcIlwiICYmIG5hbWUuaW5kZXhPZiggXCJiYWNrZ3JvdW5kXCIgKSA9PT0gMCApIHtcblx0XHRcdFx0c3R5bGVbIG5hbWUgXSA9IFwiaW5oZXJpdFwiO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBJZiBhIGhvb2sgd2FzIHByb3ZpZGVkLCB1c2UgdGhhdCB2YWx1ZSwgb3RoZXJ3aXNlIGp1c3Qgc2V0IHRoZSBzcGVjaWZpZWQgdmFsdWVcblx0XHRcdGlmICggIWhvb2tzIHx8ICEoIFwic2V0XCIgaW4gaG9va3MgKSB8fFxuXHRcdFx0XHQoIHZhbHVlID0gaG9va3Muc2V0KCBlbGVtLCB2YWx1ZSwgZXh0cmEgKSApICE9PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdFx0aWYgKCBpc0N1c3RvbVByb3AgKSB7XG5cdFx0XHRcdFx0c3R5bGUuc2V0UHJvcGVydHkoIG5hbWUsIHZhbHVlICk7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0c3R5bGVbIG5hbWUgXSA9IHZhbHVlO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHR9IGVsc2Uge1xuXG5cdFx0XHQvLyBJZiBhIGhvb2sgd2FzIHByb3ZpZGVkIGdldCB0aGUgbm9uLWNvbXB1dGVkIHZhbHVlIGZyb20gdGhlcmVcblx0XHRcdGlmICggaG9va3MgJiYgXCJnZXRcIiBpbiBob29rcyAmJlxuXHRcdFx0XHQoIHJldCA9IGhvb2tzLmdldCggZWxlbSwgZmFsc2UsIGV4dHJhICkgKSAhPT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRcdHJldHVybiByZXQ7XG5cdFx0XHR9XG5cblx0XHRcdC8vIE90aGVyd2lzZSBqdXN0IGdldCB0aGUgdmFsdWUgZnJvbSB0aGUgc3R5bGUgb2JqZWN0XG5cdFx0XHRyZXR1cm4gc3R5bGVbIG5hbWUgXTtcblx0XHR9XG5cdH0sXG5cblx0Y3NzOiBmdW5jdGlvbiggZWxlbSwgbmFtZSwgZXh0cmEsIHN0eWxlcyApIHtcblx0XHR2YXIgdmFsLCBudW0sIGhvb2tzLFxuXHRcdFx0b3JpZ05hbWUgPSBjYW1lbENhc2UoIG5hbWUgKSxcblx0XHRcdGlzQ3VzdG9tUHJvcCA9IHJjdXN0b21Qcm9wLnRlc3QoIG5hbWUgKTtcblxuXHRcdC8vIE1ha2Ugc3VyZSB0aGF0IHdlJ3JlIHdvcmtpbmcgd2l0aCB0aGUgcmlnaHQgbmFtZS4gV2UgZG9uJ3Rcblx0XHQvLyB3YW50IHRvIG1vZGlmeSB0aGUgdmFsdWUgaWYgaXQgaXMgYSBDU1MgY3VzdG9tIHByb3BlcnR5XG5cdFx0Ly8gc2luY2UgdGhleSBhcmUgdXNlci1kZWZpbmVkLlxuXHRcdGlmICggIWlzQ3VzdG9tUHJvcCApIHtcblx0XHRcdG5hbWUgPSBmaW5hbFByb3BOYW1lKCBvcmlnTmFtZSApO1xuXHRcdH1cblxuXHRcdC8vIFRyeSBwcmVmaXhlZCBuYW1lIGZvbGxvd2VkIGJ5IHRoZSB1bnByZWZpeGVkIG5hbWVcblx0XHRob29rcyA9IGpRdWVyeS5jc3NIb29rc1sgbmFtZSBdIHx8IGpRdWVyeS5jc3NIb29rc1sgb3JpZ05hbWUgXTtcblxuXHRcdC8vIElmIGEgaG9vayB3YXMgcHJvdmlkZWQgZ2V0IHRoZSBjb21wdXRlZCB2YWx1ZSBmcm9tIHRoZXJlXG5cdFx0aWYgKCBob29rcyAmJiBcImdldFwiIGluIGhvb2tzICkge1xuXHRcdFx0dmFsID0gaG9va3MuZ2V0KCBlbGVtLCB0cnVlLCBleHRyYSApO1xuXHRcdH1cblxuXHRcdC8vIE90aGVyd2lzZSwgaWYgYSB3YXkgdG8gZ2V0IHRoZSBjb21wdXRlZCB2YWx1ZSBleGlzdHMsIHVzZSB0aGF0XG5cdFx0aWYgKCB2YWwgPT09IHVuZGVmaW5lZCApIHtcblx0XHRcdHZhbCA9IGN1ckNTUyggZWxlbSwgbmFtZSwgc3R5bGVzICk7XG5cdFx0fVxuXG5cdFx0Ly8gQ29udmVydCBcIm5vcm1hbFwiIHRvIGNvbXB1dGVkIHZhbHVlXG5cdFx0aWYgKCB2YWwgPT09IFwibm9ybWFsXCIgJiYgbmFtZSBpbiBjc3NOb3JtYWxUcmFuc2Zvcm0gKSB7XG5cdFx0XHR2YWwgPSBjc3NOb3JtYWxUcmFuc2Zvcm1bIG5hbWUgXTtcblx0XHR9XG5cblx0XHQvLyBNYWtlIG51bWVyaWMgaWYgZm9yY2VkIG9yIGEgcXVhbGlmaWVyIHdhcyBwcm92aWRlZCBhbmQgdmFsIGxvb2tzIG51bWVyaWNcblx0XHRpZiAoIGV4dHJhID09PSBcIlwiIHx8IGV4dHJhICkge1xuXHRcdFx0bnVtID0gcGFyc2VGbG9hdCggdmFsICk7XG5cdFx0XHRyZXR1cm4gZXh0cmEgPT09IHRydWUgfHwgaXNGaW5pdGUoIG51bSApID8gbnVtIHx8IDAgOiB2YWw7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHZhbDtcblx0fVxufSApO1xuXG5qUXVlcnkuZWFjaCggWyBcImhlaWdodFwiLCBcIndpZHRoXCIgXSwgZnVuY3Rpb24oIGksIGRpbWVuc2lvbiApIHtcblx0alF1ZXJ5LmNzc0hvb2tzWyBkaW1lbnNpb24gXSA9IHtcblx0XHRnZXQ6IGZ1bmN0aW9uKCBlbGVtLCBjb21wdXRlZCwgZXh0cmEgKSB7XG5cdFx0XHRpZiAoIGNvbXB1dGVkICkge1xuXG5cdFx0XHRcdC8vIENlcnRhaW4gZWxlbWVudHMgY2FuIGhhdmUgZGltZW5zaW9uIGluZm8gaWYgd2UgaW52aXNpYmx5IHNob3cgdGhlbVxuXHRcdFx0XHQvLyBidXQgaXQgbXVzdCBoYXZlIGEgY3VycmVudCBkaXNwbGF5IHN0eWxlIHRoYXQgd291bGQgYmVuZWZpdFxuXHRcdFx0XHRyZXR1cm4gcmRpc3BsYXlzd2FwLnRlc3QoIGpRdWVyeS5jc3MoIGVsZW0sIFwiZGlzcGxheVwiICkgKSAmJlxuXG5cdFx0XHRcdFx0Ly8gU3VwcG9ydDogU2FmYXJpIDgrXG5cdFx0XHRcdFx0Ly8gVGFibGUgY29sdW1ucyBpbiBTYWZhcmkgaGF2ZSBub24temVybyBvZmZzZXRXaWR0aCAmIHplcm9cblx0XHRcdFx0XHQvLyBnZXRCb3VuZGluZ0NsaWVudFJlY3QoKS53aWR0aCB1bmxlc3MgZGlzcGxheSBpcyBjaGFuZ2VkLlxuXHRcdFx0XHRcdC8vIFN1cHBvcnQ6IElFIDw9MTEgb25seVxuXHRcdFx0XHRcdC8vIFJ1bm5pbmcgZ2V0Qm91bmRpbmdDbGllbnRSZWN0IG9uIGEgZGlzY29ubmVjdGVkIG5vZGVcblx0XHRcdFx0XHQvLyBpbiBJRSB0aHJvd3MgYW4gZXJyb3IuXG5cdFx0XHRcdFx0KCAhZWxlbS5nZXRDbGllbnRSZWN0cygpLmxlbmd0aCB8fCAhZWxlbS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS53aWR0aCApID9cblx0XHRcdFx0XHRcdHN3YXAoIGVsZW0sIGNzc1Nob3csIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdFx0XHRyZXR1cm4gZ2V0V2lkdGhPckhlaWdodCggZWxlbSwgZGltZW5zaW9uLCBleHRyYSApO1xuXHRcdFx0XHRcdFx0fSApIDpcblx0XHRcdFx0XHRcdGdldFdpZHRoT3JIZWlnaHQoIGVsZW0sIGRpbWVuc2lvbiwgZXh0cmEgKTtcblx0XHRcdH1cblx0XHR9LFxuXG5cdFx0c2V0OiBmdW5jdGlvbiggZWxlbSwgdmFsdWUsIGV4dHJhICkge1xuXHRcdFx0dmFyIG1hdGNoZXMsXG5cdFx0XHRcdHN0eWxlcyA9IGdldFN0eWxlcyggZWxlbSApLFxuXG5cdFx0XHRcdC8vIE9ubHkgcmVhZCBzdHlsZXMucG9zaXRpb24gaWYgdGhlIHRlc3QgaGFzIGEgY2hhbmNlIHRvIGZhaWxcblx0XHRcdFx0Ly8gdG8gYXZvaWQgZm9yY2luZyBhIHJlZmxvdy5cblx0XHRcdFx0c2Nyb2xsYm94U2l6ZUJ1Z2d5ID0gIXN1cHBvcnQuc2Nyb2xsYm94U2l6ZSgpICYmXG5cdFx0XHRcdFx0c3R5bGVzLnBvc2l0aW9uID09PSBcImFic29sdXRlXCIsXG5cblx0XHRcdFx0Ly8gVG8gYXZvaWQgZm9yY2luZyBhIHJlZmxvdywgb25seSBmZXRjaCBib3hTaXppbmcgaWYgd2UgbmVlZCBpdCAoZ2gtMzk5MSlcblx0XHRcdFx0Ym94U2l6aW5nTmVlZGVkID0gc2Nyb2xsYm94U2l6ZUJ1Z2d5IHx8IGV4dHJhLFxuXHRcdFx0XHRpc0JvcmRlckJveCA9IGJveFNpemluZ05lZWRlZCAmJlxuXHRcdFx0XHRcdGpRdWVyeS5jc3MoIGVsZW0sIFwiYm94U2l6aW5nXCIsIGZhbHNlLCBzdHlsZXMgKSA9PT0gXCJib3JkZXItYm94XCIsXG5cdFx0XHRcdHN1YnRyYWN0ID0gZXh0cmEgP1xuXHRcdFx0XHRcdGJveE1vZGVsQWRqdXN0bWVudChcblx0XHRcdFx0XHRcdGVsZW0sXG5cdFx0XHRcdFx0XHRkaW1lbnNpb24sXG5cdFx0XHRcdFx0XHRleHRyYSxcblx0XHRcdFx0XHRcdGlzQm9yZGVyQm94LFxuXHRcdFx0XHRcdFx0c3R5bGVzXG5cdFx0XHRcdFx0KSA6XG5cdFx0XHRcdFx0MDtcblxuXHRcdFx0Ly8gQWNjb3VudCBmb3IgdW5yZWxpYWJsZSBib3JkZXItYm94IGRpbWVuc2lvbnMgYnkgY29tcGFyaW5nIG9mZnNldCogdG8gY29tcHV0ZWQgYW5kXG5cdFx0XHQvLyBmYWtpbmcgYSBjb250ZW50LWJveCB0byBnZXQgYm9yZGVyIGFuZCBwYWRkaW5nIChnaC0zNjk5KVxuXHRcdFx0aWYgKCBpc0JvcmRlckJveCAmJiBzY3JvbGxib3hTaXplQnVnZ3kgKSB7XG5cdFx0XHRcdHN1YnRyYWN0IC09IE1hdGguY2VpbChcblx0XHRcdFx0XHRlbGVtWyBcIm9mZnNldFwiICsgZGltZW5zaW9uWyAwIF0udG9VcHBlckNhc2UoKSArIGRpbWVuc2lvbi5zbGljZSggMSApIF0gLVxuXHRcdFx0XHRcdHBhcnNlRmxvYXQoIHN0eWxlc1sgZGltZW5zaW9uIF0gKSAtXG5cdFx0XHRcdFx0Ym94TW9kZWxBZGp1c3RtZW50KCBlbGVtLCBkaW1lbnNpb24sIFwiYm9yZGVyXCIsIGZhbHNlLCBzdHlsZXMgKSAtXG5cdFx0XHRcdFx0MC41XG5cdFx0XHRcdCk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIENvbnZlcnQgdG8gcGl4ZWxzIGlmIHZhbHVlIGFkanVzdG1lbnQgaXMgbmVlZGVkXG5cdFx0XHRpZiAoIHN1YnRyYWN0ICYmICggbWF0Y2hlcyA9IHJjc3NOdW0uZXhlYyggdmFsdWUgKSApICYmXG5cdFx0XHRcdCggbWF0Y2hlc1sgMyBdIHx8IFwicHhcIiApICE9PSBcInB4XCIgKSB7XG5cblx0XHRcdFx0ZWxlbS5zdHlsZVsgZGltZW5zaW9uIF0gPSB2YWx1ZTtcblx0XHRcdFx0dmFsdWUgPSBqUXVlcnkuY3NzKCBlbGVtLCBkaW1lbnNpb24gKTtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIHNldFBvc2l0aXZlTnVtYmVyKCBlbGVtLCB2YWx1ZSwgc3VidHJhY3QgKTtcblx0XHR9XG5cdH07XG59ICk7XG5cbmpRdWVyeS5jc3NIb29rcy5tYXJnaW5MZWZ0ID0gYWRkR2V0SG9va0lmKCBzdXBwb3J0LnJlbGlhYmxlTWFyZ2luTGVmdCxcblx0ZnVuY3Rpb24oIGVsZW0sIGNvbXB1dGVkICkge1xuXHRcdGlmICggY29tcHV0ZWQgKSB7XG5cdFx0XHRyZXR1cm4gKCBwYXJzZUZsb2F0KCBjdXJDU1MoIGVsZW0sIFwibWFyZ2luTGVmdFwiICkgKSB8fFxuXHRcdFx0XHRlbGVtLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLmxlZnQgLVxuXHRcdFx0XHRcdHN3YXAoIGVsZW0sIHsgbWFyZ2luTGVmdDogMCB9LCBmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRcdHJldHVybiBlbGVtLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLmxlZnQ7XG5cdFx0XHRcdFx0fSApXG5cdFx0XHRcdCkgKyBcInB4XCI7XG5cdFx0fVxuXHR9XG4pO1xuXG4vLyBUaGVzZSBob29rcyBhcmUgdXNlZCBieSBhbmltYXRlIHRvIGV4cGFuZCBwcm9wZXJ0aWVzXG5qUXVlcnkuZWFjaCgge1xuXHRtYXJnaW46IFwiXCIsXG5cdHBhZGRpbmc6IFwiXCIsXG5cdGJvcmRlcjogXCJXaWR0aFwiXG59LCBmdW5jdGlvbiggcHJlZml4LCBzdWZmaXggKSB7XG5cdGpRdWVyeS5jc3NIb29rc1sgcHJlZml4ICsgc3VmZml4IF0gPSB7XG5cdFx0ZXhwYW5kOiBmdW5jdGlvbiggdmFsdWUgKSB7XG5cdFx0XHR2YXIgaSA9IDAsXG5cdFx0XHRcdGV4cGFuZGVkID0ge30sXG5cblx0XHRcdFx0Ly8gQXNzdW1lcyBhIHNpbmdsZSBudW1iZXIgaWYgbm90IGEgc3RyaW5nXG5cdFx0XHRcdHBhcnRzID0gdHlwZW9mIHZhbHVlID09PSBcInN0cmluZ1wiID8gdmFsdWUuc3BsaXQoIFwiIFwiICkgOiBbIHZhbHVlIF07XG5cblx0XHRcdGZvciAoIDsgaSA8IDQ7IGkrKyApIHtcblx0XHRcdFx0ZXhwYW5kZWRbIHByZWZpeCArIGNzc0V4cGFuZFsgaSBdICsgc3VmZml4IF0gPVxuXHRcdFx0XHRcdHBhcnRzWyBpIF0gfHwgcGFydHNbIGkgLSAyIF0gfHwgcGFydHNbIDAgXTtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIGV4cGFuZGVkO1xuXHRcdH1cblx0fTtcblxuXHRpZiAoIHByZWZpeCAhPT0gXCJtYXJnaW5cIiApIHtcblx0XHRqUXVlcnkuY3NzSG9va3NbIHByZWZpeCArIHN1ZmZpeCBdLnNldCA9IHNldFBvc2l0aXZlTnVtYmVyO1xuXHR9XG59ICk7XG5cbmpRdWVyeS5mbi5leHRlbmQoIHtcblx0Y3NzOiBmdW5jdGlvbiggbmFtZSwgdmFsdWUgKSB7XG5cdFx0cmV0dXJuIGFjY2VzcyggdGhpcywgZnVuY3Rpb24oIGVsZW0sIG5hbWUsIHZhbHVlICkge1xuXHRcdFx0dmFyIHN0eWxlcywgbGVuLFxuXHRcdFx0XHRtYXAgPSB7fSxcblx0XHRcdFx0aSA9IDA7XG5cblx0XHRcdGlmICggQXJyYXkuaXNBcnJheSggbmFtZSApICkge1xuXHRcdFx0XHRzdHlsZXMgPSBnZXRTdHlsZXMoIGVsZW0gKTtcblx0XHRcdFx0bGVuID0gbmFtZS5sZW5ndGg7XG5cblx0XHRcdFx0Zm9yICggOyBpIDwgbGVuOyBpKysgKSB7XG5cdFx0XHRcdFx0bWFwWyBuYW1lWyBpIF0gXSA9IGpRdWVyeS5jc3MoIGVsZW0sIG5hbWVbIGkgXSwgZmFsc2UsIHN0eWxlcyApO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0cmV0dXJuIG1hcDtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIHZhbHVlICE9PSB1bmRlZmluZWQgP1xuXHRcdFx0XHRqUXVlcnkuc3R5bGUoIGVsZW0sIG5hbWUsIHZhbHVlICkgOlxuXHRcdFx0XHRqUXVlcnkuY3NzKCBlbGVtLCBuYW1lICk7XG5cdFx0fSwgbmFtZSwgdmFsdWUsIGFyZ3VtZW50cy5sZW5ndGggPiAxICk7XG5cdH1cbn0gKTtcblxuXG5mdW5jdGlvbiBUd2VlbiggZWxlbSwgb3B0aW9ucywgcHJvcCwgZW5kLCBlYXNpbmcgKSB7XG5cdHJldHVybiBuZXcgVHdlZW4ucHJvdG90eXBlLmluaXQoIGVsZW0sIG9wdGlvbnMsIHByb3AsIGVuZCwgZWFzaW5nICk7XG59XG5qUXVlcnkuVHdlZW4gPSBUd2VlbjtcblxuVHdlZW4ucHJvdG90eXBlID0ge1xuXHRjb25zdHJ1Y3RvcjogVHdlZW4sXG5cdGluaXQ6IGZ1bmN0aW9uKCBlbGVtLCBvcHRpb25zLCBwcm9wLCBlbmQsIGVhc2luZywgdW5pdCApIHtcblx0XHR0aGlzLmVsZW0gPSBlbGVtO1xuXHRcdHRoaXMucHJvcCA9IHByb3A7XG5cdFx0dGhpcy5lYXNpbmcgPSBlYXNpbmcgfHwgalF1ZXJ5LmVhc2luZy5fZGVmYXVsdDtcblx0XHR0aGlzLm9wdGlvbnMgPSBvcHRpb25zO1xuXHRcdHRoaXMuc3RhcnQgPSB0aGlzLm5vdyA9IHRoaXMuY3VyKCk7XG5cdFx0dGhpcy5lbmQgPSBlbmQ7XG5cdFx0dGhpcy51bml0ID0gdW5pdCB8fCAoIGpRdWVyeS5jc3NOdW1iZXJbIHByb3AgXSA/IFwiXCIgOiBcInB4XCIgKTtcblx0fSxcblx0Y3VyOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgaG9va3MgPSBUd2Vlbi5wcm9wSG9va3NbIHRoaXMucHJvcCBdO1xuXG5cdFx0cmV0dXJuIGhvb2tzICYmIGhvb2tzLmdldCA/XG5cdFx0XHRob29rcy5nZXQoIHRoaXMgKSA6XG5cdFx0XHRUd2Vlbi5wcm9wSG9va3MuX2RlZmF1bHQuZ2V0KCB0aGlzICk7XG5cdH0sXG5cdHJ1bjogZnVuY3Rpb24oIHBlcmNlbnQgKSB7XG5cdFx0dmFyIGVhc2VkLFxuXHRcdFx0aG9va3MgPSBUd2Vlbi5wcm9wSG9va3NbIHRoaXMucHJvcCBdO1xuXG5cdFx0aWYgKCB0aGlzLm9wdGlvbnMuZHVyYXRpb24gKSB7XG5cdFx0XHR0aGlzLnBvcyA9IGVhc2VkID0galF1ZXJ5LmVhc2luZ1sgdGhpcy5lYXNpbmcgXShcblx0XHRcdFx0cGVyY2VudCwgdGhpcy5vcHRpb25zLmR1cmF0aW9uICogcGVyY2VudCwgMCwgMSwgdGhpcy5vcHRpb25zLmR1cmF0aW9uXG5cdFx0XHQpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR0aGlzLnBvcyA9IGVhc2VkID0gcGVyY2VudDtcblx0XHR9XG5cdFx0dGhpcy5ub3cgPSAoIHRoaXMuZW5kIC0gdGhpcy5zdGFydCApICogZWFzZWQgKyB0aGlzLnN0YXJ0O1xuXG5cdFx0aWYgKCB0aGlzLm9wdGlvbnMuc3RlcCApIHtcblx0XHRcdHRoaXMub3B0aW9ucy5zdGVwLmNhbGwoIHRoaXMuZWxlbSwgdGhpcy5ub3csIHRoaXMgKTtcblx0XHR9XG5cblx0XHRpZiAoIGhvb2tzICYmIGhvb2tzLnNldCApIHtcblx0XHRcdGhvb2tzLnNldCggdGhpcyApO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRUd2Vlbi5wcm9wSG9va3MuX2RlZmF1bHQuc2V0KCB0aGlzICk7XG5cdFx0fVxuXHRcdHJldHVybiB0aGlzO1xuXHR9XG59O1xuXG5Ud2Vlbi5wcm90b3R5cGUuaW5pdC5wcm90b3R5cGUgPSBUd2Vlbi5wcm90b3R5cGU7XG5cblR3ZWVuLnByb3BIb29rcyA9IHtcblx0X2RlZmF1bHQ6IHtcblx0XHRnZXQ6IGZ1bmN0aW9uKCB0d2VlbiApIHtcblx0XHRcdHZhciByZXN1bHQ7XG5cblx0XHRcdC8vIFVzZSBhIHByb3BlcnR5IG9uIHRoZSBlbGVtZW50IGRpcmVjdGx5IHdoZW4gaXQgaXMgbm90IGEgRE9NIGVsZW1lbnQsXG5cdFx0XHQvLyBvciB3aGVuIHRoZXJlIGlzIG5vIG1hdGNoaW5nIHN0eWxlIHByb3BlcnR5IHRoYXQgZXhpc3RzLlxuXHRcdFx0aWYgKCB0d2Vlbi5lbGVtLm5vZGVUeXBlICE9PSAxIHx8XG5cdFx0XHRcdHR3ZWVuLmVsZW1bIHR3ZWVuLnByb3AgXSAhPSBudWxsICYmIHR3ZWVuLmVsZW0uc3R5bGVbIHR3ZWVuLnByb3AgXSA9PSBudWxsICkge1xuXHRcdFx0XHRyZXR1cm4gdHdlZW4uZWxlbVsgdHdlZW4ucHJvcCBdO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBQYXNzaW5nIGFuIGVtcHR5IHN0cmluZyBhcyBhIDNyZCBwYXJhbWV0ZXIgdG8gLmNzcyB3aWxsIGF1dG9tYXRpY2FsbHlcblx0XHRcdC8vIGF0dGVtcHQgYSBwYXJzZUZsb2F0IGFuZCBmYWxsYmFjayB0byBhIHN0cmluZyBpZiB0aGUgcGFyc2UgZmFpbHMuXG5cdFx0XHQvLyBTaW1wbGUgdmFsdWVzIHN1Y2ggYXMgXCIxMHB4XCIgYXJlIHBhcnNlZCB0byBGbG9hdDtcblx0XHRcdC8vIGNvbXBsZXggdmFsdWVzIHN1Y2ggYXMgXCJyb3RhdGUoMXJhZClcIiBhcmUgcmV0dXJuZWQgYXMtaXMuXG5cdFx0XHRyZXN1bHQgPSBqUXVlcnkuY3NzKCB0d2Vlbi5lbGVtLCB0d2Vlbi5wcm9wLCBcIlwiICk7XG5cblx0XHRcdC8vIEVtcHR5IHN0cmluZ3MsIG51bGwsIHVuZGVmaW5lZCBhbmQgXCJhdXRvXCIgYXJlIGNvbnZlcnRlZCB0byAwLlxuXHRcdFx0cmV0dXJuICFyZXN1bHQgfHwgcmVzdWx0ID09PSBcImF1dG9cIiA/IDAgOiByZXN1bHQ7XG5cdFx0fSxcblx0XHRzZXQ6IGZ1bmN0aW9uKCB0d2VlbiApIHtcblxuXHRcdFx0Ly8gVXNlIHN0ZXAgaG9vayBmb3IgYmFjayBjb21wYXQuXG5cdFx0XHQvLyBVc2UgY3NzSG9vayBpZiBpdHMgdGhlcmUuXG5cdFx0XHQvLyBVc2UgLnN0eWxlIGlmIGF2YWlsYWJsZSBhbmQgdXNlIHBsYWluIHByb3BlcnRpZXMgd2hlcmUgYXZhaWxhYmxlLlxuXHRcdFx0aWYgKCBqUXVlcnkuZnguc3RlcFsgdHdlZW4ucHJvcCBdICkge1xuXHRcdFx0XHRqUXVlcnkuZnguc3RlcFsgdHdlZW4ucHJvcCBdKCB0d2VlbiApO1xuXHRcdFx0fSBlbHNlIGlmICggdHdlZW4uZWxlbS5ub2RlVHlwZSA9PT0gMSAmJiAoXG5cdFx0XHRcdFx0alF1ZXJ5LmNzc0hvb2tzWyB0d2Vlbi5wcm9wIF0gfHxcblx0XHRcdFx0XHR0d2Vlbi5lbGVtLnN0eWxlWyBmaW5hbFByb3BOYW1lKCB0d2Vlbi5wcm9wICkgXSAhPSBudWxsICkgKSB7XG5cdFx0XHRcdGpRdWVyeS5zdHlsZSggdHdlZW4uZWxlbSwgdHdlZW4ucHJvcCwgdHdlZW4ubm93ICsgdHdlZW4udW5pdCApO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0dHdlZW4uZWxlbVsgdHdlZW4ucHJvcCBdID0gdHdlZW4ubm93O1xuXHRcdFx0fVxuXHRcdH1cblx0fVxufTtcblxuLy8gU3VwcG9ydDogSUUgPD05IG9ubHlcbi8vIFBhbmljIGJhc2VkIGFwcHJvYWNoIHRvIHNldHRpbmcgdGhpbmdzIG9uIGRpc2Nvbm5lY3RlZCBub2Rlc1xuVHdlZW4ucHJvcEhvb2tzLnNjcm9sbFRvcCA9IFR3ZWVuLnByb3BIb29rcy5zY3JvbGxMZWZ0ID0ge1xuXHRzZXQ6IGZ1bmN0aW9uKCB0d2VlbiApIHtcblx0XHRpZiAoIHR3ZWVuLmVsZW0ubm9kZVR5cGUgJiYgdHdlZW4uZWxlbS5wYXJlbnROb2RlICkge1xuXHRcdFx0dHdlZW4uZWxlbVsgdHdlZW4ucHJvcCBdID0gdHdlZW4ubm93O1xuXHRcdH1cblx0fVxufTtcblxualF1ZXJ5LmVhc2luZyA9IHtcblx0bGluZWFyOiBmdW5jdGlvbiggcCApIHtcblx0XHRyZXR1cm4gcDtcblx0fSxcblx0c3dpbmc6IGZ1bmN0aW9uKCBwICkge1xuXHRcdHJldHVybiAwLjUgLSBNYXRoLmNvcyggcCAqIE1hdGguUEkgKSAvIDI7XG5cdH0sXG5cdF9kZWZhdWx0OiBcInN3aW5nXCJcbn07XG5cbmpRdWVyeS5meCA9IFR3ZWVuLnByb3RvdHlwZS5pbml0O1xuXG4vLyBCYWNrIGNvbXBhdCA8MS44IGV4dGVuc2lvbiBwb2ludFxualF1ZXJ5LmZ4LnN0ZXAgPSB7fTtcblxuXG5cblxudmFyXG5cdGZ4Tm93LCBpblByb2dyZXNzLFxuXHRyZnh0eXBlcyA9IC9eKD86dG9nZ2xlfHNob3d8aGlkZSkkLyxcblx0cnJ1biA9IC9xdWV1ZUhvb2tzJC87XG5cbmZ1bmN0aW9uIHNjaGVkdWxlKCkge1xuXHRpZiAoIGluUHJvZ3Jlc3MgKSB7XG5cdFx0aWYgKCBkb2N1bWVudC5oaWRkZW4gPT09IGZhbHNlICYmIHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUgKSB7XG5cdFx0XHR3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lKCBzY2hlZHVsZSApO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR3aW5kb3cuc2V0VGltZW91dCggc2NoZWR1bGUsIGpRdWVyeS5meC5pbnRlcnZhbCApO1xuXHRcdH1cblxuXHRcdGpRdWVyeS5meC50aWNrKCk7XG5cdH1cbn1cblxuLy8gQW5pbWF0aW9ucyBjcmVhdGVkIHN5bmNocm9ub3VzbHkgd2lsbCBydW4gc3luY2hyb25vdXNseVxuZnVuY3Rpb24gY3JlYXRlRnhOb3coKSB7XG5cdHdpbmRvdy5zZXRUaW1lb3V0KCBmdW5jdGlvbigpIHtcblx0XHRmeE5vdyA9IHVuZGVmaW5lZDtcblx0fSApO1xuXHRyZXR1cm4gKCBmeE5vdyA9IERhdGUubm93KCkgKTtcbn1cblxuLy8gR2VuZXJhdGUgcGFyYW1ldGVycyB0byBjcmVhdGUgYSBzdGFuZGFyZCBhbmltYXRpb25cbmZ1bmN0aW9uIGdlbkZ4KCB0eXBlLCBpbmNsdWRlV2lkdGggKSB7XG5cdHZhciB3aGljaCxcblx0XHRpID0gMCxcblx0XHRhdHRycyA9IHsgaGVpZ2h0OiB0eXBlIH07XG5cblx0Ly8gSWYgd2UgaW5jbHVkZSB3aWR0aCwgc3RlcCB2YWx1ZSBpcyAxIHRvIGRvIGFsbCBjc3NFeHBhbmQgdmFsdWVzLFxuXHQvLyBvdGhlcndpc2Ugc3RlcCB2YWx1ZSBpcyAyIHRvIHNraXAgb3ZlciBMZWZ0IGFuZCBSaWdodFxuXHRpbmNsdWRlV2lkdGggPSBpbmNsdWRlV2lkdGggPyAxIDogMDtcblx0Zm9yICggOyBpIDwgNDsgaSArPSAyIC0gaW5jbHVkZVdpZHRoICkge1xuXHRcdHdoaWNoID0gY3NzRXhwYW5kWyBpIF07XG5cdFx0YXR0cnNbIFwibWFyZ2luXCIgKyB3aGljaCBdID0gYXR0cnNbIFwicGFkZGluZ1wiICsgd2hpY2ggXSA9IHR5cGU7XG5cdH1cblxuXHRpZiAoIGluY2x1ZGVXaWR0aCApIHtcblx0XHRhdHRycy5vcGFjaXR5ID0gYXR0cnMud2lkdGggPSB0eXBlO1xuXHR9XG5cblx0cmV0dXJuIGF0dHJzO1xufVxuXG5mdW5jdGlvbiBjcmVhdGVUd2VlbiggdmFsdWUsIHByb3AsIGFuaW1hdGlvbiApIHtcblx0dmFyIHR3ZWVuLFxuXHRcdGNvbGxlY3Rpb24gPSAoIEFuaW1hdGlvbi50d2VlbmVyc1sgcHJvcCBdIHx8IFtdICkuY29uY2F0KCBBbmltYXRpb24udHdlZW5lcnNbIFwiKlwiIF0gKSxcblx0XHRpbmRleCA9IDAsXG5cdFx0bGVuZ3RoID0gY29sbGVjdGlvbi5sZW5ndGg7XG5cdGZvciAoIDsgaW5kZXggPCBsZW5ndGg7IGluZGV4KysgKSB7XG5cdFx0aWYgKCAoIHR3ZWVuID0gY29sbGVjdGlvblsgaW5kZXggXS5jYWxsKCBhbmltYXRpb24sIHByb3AsIHZhbHVlICkgKSApIHtcblxuXHRcdFx0Ly8gV2UncmUgZG9uZSB3aXRoIHRoaXMgcHJvcGVydHlcblx0XHRcdHJldHVybiB0d2Vlbjtcblx0XHR9XG5cdH1cbn1cblxuZnVuY3Rpb24gZGVmYXVsdFByZWZpbHRlciggZWxlbSwgcHJvcHMsIG9wdHMgKSB7XG5cdHZhciBwcm9wLCB2YWx1ZSwgdG9nZ2xlLCBob29rcywgb2xkZmlyZSwgcHJvcFR3ZWVuLCByZXN0b3JlRGlzcGxheSwgZGlzcGxheSxcblx0XHRpc0JveCA9IFwid2lkdGhcIiBpbiBwcm9wcyB8fCBcImhlaWdodFwiIGluIHByb3BzLFxuXHRcdGFuaW0gPSB0aGlzLFxuXHRcdG9yaWcgPSB7fSxcblx0XHRzdHlsZSA9IGVsZW0uc3R5bGUsXG5cdFx0aGlkZGVuID0gZWxlbS5ub2RlVHlwZSAmJiBpc0hpZGRlbldpdGhpblRyZWUoIGVsZW0gKSxcblx0XHRkYXRhU2hvdyA9IGRhdGFQcml2LmdldCggZWxlbSwgXCJmeHNob3dcIiApO1xuXG5cdC8vIFF1ZXVlLXNraXBwaW5nIGFuaW1hdGlvbnMgaGlqYWNrIHRoZSBmeCBob29rc1xuXHRpZiAoICFvcHRzLnF1ZXVlICkge1xuXHRcdGhvb2tzID0galF1ZXJ5Ll9xdWV1ZUhvb2tzKCBlbGVtLCBcImZ4XCIgKTtcblx0XHRpZiAoIGhvb2tzLnVucXVldWVkID09IG51bGwgKSB7XG5cdFx0XHRob29rcy51bnF1ZXVlZCA9IDA7XG5cdFx0XHRvbGRmaXJlID0gaG9va3MuZW1wdHkuZmlyZTtcblx0XHRcdGhvb2tzLmVtcHR5LmZpcmUgPSBmdW5jdGlvbigpIHtcblx0XHRcdFx0aWYgKCAhaG9va3MudW5xdWV1ZWQgKSB7XG5cdFx0XHRcdFx0b2xkZmlyZSgpO1xuXHRcdFx0XHR9XG5cdFx0XHR9O1xuXHRcdH1cblx0XHRob29rcy51bnF1ZXVlZCsrO1xuXG5cdFx0YW5pbS5hbHdheXMoIGZ1bmN0aW9uKCkge1xuXG5cdFx0XHQvLyBFbnN1cmUgdGhlIGNvbXBsZXRlIGhhbmRsZXIgaXMgY2FsbGVkIGJlZm9yZSB0aGlzIGNvbXBsZXRlc1xuXHRcdFx0YW5pbS5hbHdheXMoIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRob29rcy51bnF1ZXVlZC0tO1xuXHRcdFx0XHRpZiAoICFqUXVlcnkucXVldWUoIGVsZW0sIFwiZnhcIiApLmxlbmd0aCApIHtcblx0XHRcdFx0XHRob29rcy5lbXB0eS5maXJlKCk7XG5cdFx0XHRcdH1cblx0XHRcdH0gKTtcblx0XHR9ICk7XG5cdH1cblxuXHQvLyBEZXRlY3Qgc2hvdy9oaWRlIGFuaW1hdGlvbnNcblx0Zm9yICggcHJvcCBpbiBwcm9wcyApIHtcblx0XHR2YWx1ZSA9IHByb3BzWyBwcm9wIF07XG5cdFx0aWYgKCByZnh0eXBlcy50ZXN0KCB2YWx1ZSApICkge1xuXHRcdFx0ZGVsZXRlIHByb3BzWyBwcm9wIF07XG5cdFx0XHR0b2dnbGUgPSB0b2dnbGUgfHwgdmFsdWUgPT09IFwidG9nZ2xlXCI7XG5cdFx0XHRpZiAoIHZhbHVlID09PSAoIGhpZGRlbiA/IFwiaGlkZVwiIDogXCJzaG93XCIgKSApIHtcblxuXHRcdFx0XHQvLyBQcmV0ZW5kIHRvIGJlIGhpZGRlbiBpZiB0aGlzIGlzIGEgXCJzaG93XCIgYW5kXG5cdFx0XHRcdC8vIHRoZXJlIGlzIHN0aWxsIGRhdGEgZnJvbSBhIHN0b3BwZWQgc2hvdy9oaWRlXG5cdFx0XHRcdGlmICggdmFsdWUgPT09IFwic2hvd1wiICYmIGRhdGFTaG93ICYmIGRhdGFTaG93WyBwcm9wIF0gIT09IHVuZGVmaW5lZCApIHtcblx0XHRcdFx0XHRoaWRkZW4gPSB0cnVlO1xuXG5cdFx0XHRcdC8vIElnbm9yZSBhbGwgb3RoZXIgbm8tb3Agc2hvdy9oaWRlIGRhdGFcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRjb250aW51ZTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0b3JpZ1sgcHJvcCBdID0gZGF0YVNob3cgJiYgZGF0YVNob3dbIHByb3AgXSB8fCBqUXVlcnkuc3R5bGUoIGVsZW0sIHByb3AgKTtcblx0XHR9XG5cdH1cblxuXHQvLyBCYWlsIG91dCBpZiB0aGlzIGlzIGEgbm8tb3AgbGlrZSAuaGlkZSgpLmhpZGUoKVxuXHRwcm9wVHdlZW4gPSAhalF1ZXJ5LmlzRW1wdHlPYmplY3QoIHByb3BzICk7XG5cdGlmICggIXByb3BUd2VlbiAmJiBqUXVlcnkuaXNFbXB0eU9iamVjdCggb3JpZyApICkge1xuXHRcdHJldHVybjtcblx0fVxuXG5cdC8vIFJlc3RyaWN0IFwib3ZlcmZsb3dcIiBhbmQgXCJkaXNwbGF5XCIgc3R5bGVzIGR1cmluZyBib3ggYW5pbWF0aW9uc1xuXHRpZiAoIGlzQm94ICYmIGVsZW0ubm9kZVR5cGUgPT09IDEgKSB7XG5cblx0XHQvLyBTdXBwb3J0OiBJRSA8PTkgLSAxMSwgRWRnZSAxMiAtIDE1XG5cdFx0Ly8gUmVjb3JkIGFsbCAzIG92ZXJmbG93IGF0dHJpYnV0ZXMgYmVjYXVzZSBJRSBkb2VzIG5vdCBpbmZlciB0aGUgc2hvcnRoYW5kXG5cdFx0Ly8gZnJvbSBpZGVudGljYWxseS12YWx1ZWQgb3ZlcmZsb3dYIGFuZCBvdmVyZmxvd1kgYW5kIEVkZ2UganVzdCBtaXJyb3JzXG5cdFx0Ly8gdGhlIG92ZXJmbG93WCB2YWx1ZSB0aGVyZS5cblx0XHRvcHRzLm92ZXJmbG93ID0gWyBzdHlsZS5vdmVyZmxvdywgc3R5bGUub3ZlcmZsb3dYLCBzdHlsZS5vdmVyZmxvd1kgXTtcblxuXHRcdC8vIElkZW50aWZ5IGEgZGlzcGxheSB0eXBlLCBwcmVmZXJyaW5nIG9sZCBzaG93L2hpZGUgZGF0YSBvdmVyIHRoZSBDU1MgY2FzY2FkZVxuXHRcdHJlc3RvcmVEaXNwbGF5ID0gZGF0YVNob3cgJiYgZGF0YVNob3cuZGlzcGxheTtcblx0XHRpZiAoIHJlc3RvcmVEaXNwbGF5ID09IG51bGwgKSB7XG5cdFx0XHRyZXN0b3JlRGlzcGxheSA9IGRhdGFQcml2LmdldCggZWxlbSwgXCJkaXNwbGF5XCIgKTtcblx0XHR9XG5cdFx0ZGlzcGxheSA9IGpRdWVyeS5jc3MoIGVsZW0sIFwiZGlzcGxheVwiICk7XG5cdFx0aWYgKCBkaXNwbGF5ID09PSBcIm5vbmVcIiApIHtcblx0XHRcdGlmICggcmVzdG9yZURpc3BsYXkgKSB7XG5cdFx0XHRcdGRpc3BsYXkgPSByZXN0b3JlRGlzcGxheTtcblx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0Ly8gR2V0IG5vbmVtcHR5IHZhbHVlKHMpIGJ5IHRlbXBvcmFyaWx5IGZvcmNpbmcgdmlzaWJpbGl0eVxuXHRcdFx0XHRzaG93SGlkZSggWyBlbGVtIF0sIHRydWUgKTtcblx0XHRcdFx0cmVzdG9yZURpc3BsYXkgPSBlbGVtLnN0eWxlLmRpc3BsYXkgfHwgcmVzdG9yZURpc3BsYXk7XG5cdFx0XHRcdGRpc3BsYXkgPSBqUXVlcnkuY3NzKCBlbGVtLCBcImRpc3BsYXlcIiApO1xuXHRcdFx0XHRzaG93SGlkZSggWyBlbGVtIF0gKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyBBbmltYXRlIGlubGluZSBlbGVtZW50cyBhcyBpbmxpbmUtYmxvY2tcblx0XHRpZiAoIGRpc3BsYXkgPT09IFwiaW5saW5lXCIgfHwgZGlzcGxheSA9PT0gXCJpbmxpbmUtYmxvY2tcIiAmJiByZXN0b3JlRGlzcGxheSAhPSBudWxsICkge1xuXHRcdFx0aWYgKCBqUXVlcnkuY3NzKCBlbGVtLCBcImZsb2F0XCIgKSA9PT0gXCJub25lXCIgKSB7XG5cblx0XHRcdFx0Ly8gUmVzdG9yZSB0aGUgb3JpZ2luYWwgZGlzcGxheSB2YWx1ZSBhdCB0aGUgZW5kIG9mIHB1cmUgc2hvdy9oaWRlIGFuaW1hdGlvbnNcblx0XHRcdFx0aWYgKCAhcHJvcFR3ZWVuICkge1xuXHRcdFx0XHRcdGFuaW0uZG9uZSggZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0XHRzdHlsZS5kaXNwbGF5ID0gcmVzdG9yZURpc3BsYXk7XG5cdFx0XHRcdFx0fSApO1xuXHRcdFx0XHRcdGlmICggcmVzdG9yZURpc3BsYXkgPT0gbnVsbCApIHtcblx0XHRcdFx0XHRcdGRpc3BsYXkgPSBzdHlsZS5kaXNwbGF5O1xuXHRcdFx0XHRcdFx0cmVzdG9yZURpc3BsYXkgPSBkaXNwbGF5ID09PSBcIm5vbmVcIiA/IFwiXCIgOiBkaXNwbGF5O1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0XHRzdHlsZS5kaXNwbGF5ID0gXCJpbmxpbmUtYmxvY2tcIjtcblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHRpZiAoIG9wdHMub3ZlcmZsb3cgKSB7XG5cdFx0c3R5bGUub3ZlcmZsb3cgPSBcImhpZGRlblwiO1xuXHRcdGFuaW0uYWx3YXlzKCBmdW5jdGlvbigpIHtcblx0XHRcdHN0eWxlLm92ZXJmbG93ID0gb3B0cy5vdmVyZmxvd1sgMCBdO1xuXHRcdFx0c3R5bGUub3ZlcmZsb3dYID0gb3B0cy5vdmVyZmxvd1sgMSBdO1xuXHRcdFx0c3R5bGUub3ZlcmZsb3dZID0gb3B0cy5vdmVyZmxvd1sgMiBdO1xuXHRcdH0gKTtcblx0fVxuXG5cdC8vIEltcGxlbWVudCBzaG93L2hpZGUgYW5pbWF0aW9uc1xuXHRwcm9wVHdlZW4gPSBmYWxzZTtcblx0Zm9yICggcHJvcCBpbiBvcmlnICkge1xuXG5cdFx0Ly8gR2VuZXJhbCBzaG93L2hpZGUgc2V0dXAgZm9yIHRoaXMgZWxlbWVudCBhbmltYXRpb25cblx0XHRpZiAoICFwcm9wVHdlZW4gKSB7XG5cdFx0XHRpZiAoIGRhdGFTaG93ICkge1xuXHRcdFx0XHRpZiAoIFwiaGlkZGVuXCIgaW4gZGF0YVNob3cgKSB7XG5cdFx0XHRcdFx0aGlkZGVuID0gZGF0YVNob3cuaGlkZGVuO1xuXHRcdFx0XHR9XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRkYXRhU2hvdyA9IGRhdGFQcml2LmFjY2VzcyggZWxlbSwgXCJmeHNob3dcIiwgeyBkaXNwbGF5OiByZXN0b3JlRGlzcGxheSB9ICk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIFN0b3JlIGhpZGRlbi92aXNpYmxlIGZvciB0b2dnbGUgc28gYC5zdG9wKCkudG9nZ2xlKClgIFwicmV2ZXJzZXNcIlxuXHRcdFx0aWYgKCB0b2dnbGUgKSB7XG5cdFx0XHRcdGRhdGFTaG93LmhpZGRlbiA9ICFoaWRkZW47XG5cdFx0XHR9XG5cblx0XHRcdC8vIFNob3cgZWxlbWVudHMgYmVmb3JlIGFuaW1hdGluZyB0aGVtXG5cdFx0XHRpZiAoIGhpZGRlbiApIHtcblx0XHRcdFx0c2hvd0hpZGUoIFsgZWxlbSBdLCB0cnVlICk7XG5cdFx0XHR9XG5cblx0XHRcdC8qIGVzbGludC1kaXNhYmxlIG5vLWxvb3AtZnVuYyAqL1xuXG5cdFx0XHRhbmltLmRvbmUoIGZ1bmN0aW9uKCkge1xuXG5cdFx0XHQvKiBlc2xpbnQtZW5hYmxlIG5vLWxvb3AtZnVuYyAqL1xuXG5cdFx0XHRcdC8vIFRoZSBmaW5hbCBzdGVwIG9mIGEgXCJoaWRlXCIgYW5pbWF0aW9uIGlzIGFjdHVhbGx5IGhpZGluZyB0aGUgZWxlbWVudFxuXHRcdFx0XHRpZiAoICFoaWRkZW4gKSB7XG5cdFx0XHRcdFx0c2hvd0hpZGUoIFsgZWxlbSBdICk7XG5cdFx0XHRcdH1cblx0XHRcdFx0ZGF0YVByaXYucmVtb3ZlKCBlbGVtLCBcImZ4c2hvd1wiICk7XG5cdFx0XHRcdGZvciAoIHByb3AgaW4gb3JpZyApIHtcblx0XHRcdFx0XHRqUXVlcnkuc3R5bGUoIGVsZW0sIHByb3AsIG9yaWdbIHByb3AgXSApO1xuXHRcdFx0XHR9XG5cdFx0XHR9ICk7XG5cdFx0fVxuXG5cdFx0Ly8gUGVyLXByb3BlcnR5IHNldHVwXG5cdFx0cHJvcFR3ZWVuID0gY3JlYXRlVHdlZW4oIGhpZGRlbiA/IGRhdGFTaG93WyBwcm9wIF0gOiAwLCBwcm9wLCBhbmltICk7XG5cdFx0aWYgKCAhKCBwcm9wIGluIGRhdGFTaG93ICkgKSB7XG5cdFx0XHRkYXRhU2hvd1sgcHJvcCBdID0gcHJvcFR3ZWVuLnN0YXJ0O1xuXHRcdFx0aWYgKCBoaWRkZW4gKSB7XG5cdFx0XHRcdHByb3BUd2Vlbi5lbmQgPSBwcm9wVHdlZW4uc3RhcnQ7XG5cdFx0XHRcdHByb3BUd2Vlbi5zdGFydCA9IDA7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG59XG5cbmZ1bmN0aW9uIHByb3BGaWx0ZXIoIHByb3BzLCBzcGVjaWFsRWFzaW5nICkge1xuXHR2YXIgaW5kZXgsIG5hbWUsIGVhc2luZywgdmFsdWUsIGhvb2tzO1xuXG5cdC8vIGNhbWVsQ2FzZSwgc3BlY2lhbEVhc2luZyBhbmQgZXhwYW5kIGNzc0hvb2sgcGFzc1xuXHRmb3IgKCBpbmRleCBpbiBwcm9wcyApIHtcblx0XHRuYW1lID0gY2FtZWxDYXNlKCBpbmRleCApO1xuXHRcdGVhc2luZyA9IHNwZWNpYWxFYXNpbmdbIG5hbWUgXTtcblx0XHR2YWx1ZSA9IHByb3BzWyBpbmRleCBdO1xuXHRcdGlmICggQXJyYXkuaXNBcnJheSggdmFsdWUgKSApIHtcblx0XHRcdGVhc2luZyA9IHZhbHVlWyAxIF07XG5cdFx0XHR2YWx1ZSA9IHByb3BzWyBpbmRleCBdID0gdmFsdWVbIDAgXTtcblx0XHR9XG5cblx0XHRpZiAoIGluZGV4ICE9PSBuYW1lICkge1xuXHRcdFx0cHJvcHNbIG5hbWUgXSA9IHZhbHVlO1xuXHRcdFx0ZGVsZXRlIHByb3BzWyBpbmRleCBdO1xuXHRcdH1cblxuXHRcdGhvb2tzID0galF1ZXJ5LmNzc0hvb2tzWyBuYW1lIF07XG5cdFx0aWYgKCBob29rcyAmJiBcImV4cGFuZFwiIGluIGhvb2tzICkge1xuXHRcdFx0dmFsdWUgPSBob29rcy5leHBhbmQoIHZhbHVlICk7XG5cdFx0XHRkZWxldGUgcHJvcHNbIG5hbWUgXTtcblxuXHRcdFx0Ly8gTm90IHF1aXRlICQuZXh0ZW5kLCB0aGlzIHdvbid0IG92ZXJ3cml0ZSBleGlzdGluZyBrZXlzLlxuXHRcdFx0Ly8gUmV1c2luZyAnaW5kZXgnIGJlY2F1c2Ugd2UgaGF2ZSB0aGUgY29ycmVjdCBcIm5hbWVcIlxuXHRcdFx0Zm9yICggaW5kZXggaW4gdmFsdWUgKSB7XG5cdFx0XHRcdGlmICggISggaW5kZXggaW4gcHJvcHMgKSApIHtcblx0XHRcdFx0XHRwcm9wc1sgaW5kZXggXSA9IHZhbHVlWyBpbmRleCBdO1xuXHRcdFx0XHRcdHNwZWNpYWxFYXNpbmdbIGluZGV4IF0gPSBlYXNpbmc7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9IGVsc2Uge1xuXHRcdFx0c3BlY2lhbEVhc2luZ1sgbmFtZSBdID0gZWFzaW5nO1xuXHRcdH1cblx0fVxufVxuXG5mdW5jdGlvbiBBbmltYXRpb24oIGVsZW0sIHByb3BlcnRpZXMsIG9wdGlvbnMgKSB7XG5cdHZhciByZXN1bHQsXG5cdFx0c3RvcHBlZCxcblx0XHRpbmRleCA9IDAsXG5cdFx0bGVuZ3RoID0gQW5pbWF0aW9uLnByZWZpbHRlcnMubGVuZ3RoLFxuXHRcdGRlZmVycmVkID0galF1ZXJ5LkRlZmVycmVkKCkuYWx3YXlzKCBmdW5jdGlvbigpIHtcblxuXHRcdFx0Ly8gRG9uJ3QgbWF0Y2ggZWxlbSBpbiB0aGUgOmFuaW1hdGVkIHNlbGVjdG9yXG5cdFx0XHRkZWxldGUgdGljay5lbGVtO1xuXHRcdH0gKSxcblx0XHR0aWNrID0gZnVuY3Rpb24oKSB7XG5cdFx0XHRpZiAoIHN0b3BwZWQgKSB7XG5cdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdH1cblx0XHRcdHZhciBjdXJyZW50VGltZSA9IGZ4Tm93IHx8IGNyZWF0ZUZ4Tm93KCksXG5cdFx0XHRcdHJlbWFpbmluZyA9IE1hdGgubWF4KCAwLCBhbmltYXRpb24uc3RhcnRUaW1lICsgYW5pbWF0aW9uLmR1cmF0aW9uIC0gY3VycmVudFRpbWUgKSxcblxuXHRcdFx0XHQvLyBTdXBwb3J0OiBBbmRyb2lkIDIuMyBvbmx5XG5cdFx0XHRcdC8vIEFyY2hhaWMgY3Jhc2ggYnVnIHdvbid0IGFsbG93IHVzIHRvIHVzZSBgMSAtICggMC41IHx8IDAgKWAgKCMxMjQ5Nylcblx0XHRcdFx0dGVtcCA9IHJlbWFpbmluZyAvIGFuaW1hdGlvbi5kdXJhdGlvbiB8fCAwLFxuXHRcdFx0XHRwZXJjZW50ID0gMSAtIHRlbXAsXG5cdFx0XHRcdGluZGV4ID0gMCxcblx0XHRcdFx0bGVuZ3RoID0gYW5pbWF0aW9uLnR3ZWVucy5sZW5ndGg7XG5cblx0XHRcdGZvciAoIDsgaW5kZXggPCBsZW5ndGg7IGluZGV4KysgKSB7XG5cdFx0XHRcdGFuaW1hdGlvbi50d2VlbnNbIGluZGV4IF0ucnVuKCBwZXJjZW50ICk7XG5cdFx0XHR9XG5cblx0XHRcdGRlZmVycmVkLm5vdGlmeVdpdGgoIGVsZW0sIFsgYW5pbWF0aW9uLCBwZXJjZW50LCByZW1haW5pbmcgXSApO1xuXG5cdFx0XHQvLyBJZiB0aGVyZSdzIG1vcmUgdG8gZG8sIHlpZWxkXG5cdFx0XHRpZiAoIHBlcmNlbnQgPCAxICYmIGxlbmd0aCApIHtcblx0XHRcdFx0cmV0dXJuIHJlbWFpbmluZztcblx0XHRcdH1cblxuXHRcdFx0Ly8gSWYgdGhpcyB3YXMgYW4gZW1wdHkgYW5pbWF0aW9uLCBzeW50aGVzaXplIGEgZmluYWwgcHJvZ3Jlc3Mgbm90aWZpY2F0aW9uXG5cdFx0XHRpZiAoICFsZW5ndGggKSB7XG5cdFx0XHRcdGRlZmVycmVkLm5vdGlmeVdpdGgoIGVsZW0sIFsgYW5pbWF0aW9uLCAxLCAwIF0gKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gUmVzb2x2ZSB0aGUgYW5pbWF0aW9uIGFuZCByZXBvcnQgaXRzIGNvbmNsdXNpb25cblx0XHRcdGRlZmVycmVkLnJlc29sdmVXaXRoKCBlbGVtLCBbIGFuaW1hdGlvbiBdICk7XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fSxcblx0XHRhbmltYXRpb24gPSBkZWZlcnJlZC5wcm9taXNlKCB7XG5cdFx0XHRlbGVtOiBlbGVtLFxuXHRcdFx0cHJvcHM6IGpRdWVyeS5leHRlbmQoIHt9LCBwcm9wZXJ0aWVzICksXG5cdFx0XHRvcHRzOiBqUXVlcnkuZXh0ZW5kKCB0cnVlLCB7XG5cdFx0XHRcdHNwZWNpYWxFYXNpbmc6IHt9LFxuXHRcdFx0XHRlYXNpbmc6IGpRdWVyeS5lYXNpbmcuX2RlZmF1bHRcblx0XHRcdH0sIG9wdGlvbnMgKSxcblx0XHRcdG9yaWdpbmFsUHJvcGVydGllczogcHJvcGVydGllcyxcblx0XHRcdG9yaWdpbmFsT3B0aW9uczogb3B0aW9ucyxcblx0XHRcdHN0YXJ0VGltZTogZnhOb3cgfHwgY3JlYXRlRnhOb3coKSxcblx0XHRcdGR1cmF0aW9uOiBvcHRpb25zLmR1cmF0aW9uLFxuXHRcdFx0dHdlZW5zOiBbXSxcblx0XHRcdGNyZWF0ZVR3ZWVuOiBmdW5jdGlvbiggcHJvcCwgZW5kICkge1xuXHRcdFx0XHR2YXIgdHdlZW4gPSBqUXVlcnkuVHdlZW4oIGVsZW0sIGFuaW1hdGlvbi5vcHRzLCBwcm9wLCBlbmQsXG5cdFx0XHRcdFx0XHRhbmltYXRpb24ub3B0cy5zcGVjaWFsRWFzaW5nWyBwcm9wIF0gfHwgYW5pbWF0aW9uLm9wdHMuZWFzaW5nICk7XG5cdFx0XHRcdGFuaW1hdGlvbi50d2VlbnMucHVzaCggdHdlZW4gKTtcblx0XHRcdFx0cmV0dXJuIHR3ZWVuO1xuXHRcdFx0fSxcblx0XHRcdHN0b3A6IGZ1bmN0aW9uKCBnb3RvRW5kICkge1xuXHRcdFx0XHR2YXIgaW5kZXggPSAwLFxuXG5cdFx0XHRcdFx0Ly8gSWYgd2UgYXJlIGdvaW5nIHRvIHRoZSBlbmQsIHdlIHdhbnQgdG8gcnVuIGFsbCB0aGUgdHdlZW5zXG5cdFx0XHRcdFx0Ly8gb3RoZXJ3aXNlIHdlIHNraXAgdGhpcyBwYXJ0XG5cdFx0XHRcdFx0bGVuZ3RoID0gZ290b0VuZCA/IGFuaW1hdGlvbi50d2VlbnMubGVuZ3RoIDogMDtcblx0XHRcdFx0aWYgKCBzdG9wcGVkICkge1xuXHRcdFx0XHRcdHJldHVybiB0aGlzO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHN0b3BwZWQgPSB0cnVlO1xuXHRcdFx0XHRmb3IgKCA7IGluZGV4IDwgbGVuZ3RoOyBpbmRleCsrICkge1xuXHRcdFx0XHRcdGFuaW1hdGlvbi50d2VlbnNbIGluZGV4IF0ucnVuKCAxICk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBSZXNvbHZlIHdoZW4gd2UgcGxheWVkIHRoZSBsYXN0IGZyYW1lOyBvdGhlcndpc2UsIHJlamVjdFxuXHRcdFx0XHRpZiAoIGdvdG9FbmQgKSB7XG5cdFx0XHRcdFx0ZGVmZXJyZWQubm90aWZ5V2l0aCggZWxlbSwgWyBhbmltYXRpb24sIDEsIDAgXSApO1xuXHRcdFx0XHRcdGRlZmVycmVkLnJlc29sdmVXaXRoKCBlbGVtLCBbIGFuaW1hdGlvbiwgZ290b0VuZCBdICk7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0ZGVmZXJyZWQucmVqZWN0V2l0aCggZWxlbSwgWyBhbmltYXRpb24sIGdvdG9FbmQgXSApO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiB0aGlzO1xuXHRcdFx0fVxuXHRcdH0gKSxcblx0XHRwcm9wcyA9IGFuaW1hdGlvbi5wcm9wcztcblxuXHRwcm9wRmlsdGVyKCBwcm9wcywgYW5pbWF0aW9uLm9wdHMuc3BlY2lhbEVhc2luZyApO1xuXG5cdGZvciAoIDsgaW5kZXggPCBsZW5ndGg7IGluZGV4KysgKSB7XG5cdFx0cmVzdWx0ID0gQW5pbWF0aW9uLnByZWZpbHRlcnNbIGluZGV4IF0uY2FsbCggYW5pbWF0aW9uLCBlbGVtLCBwcm9wcywgYW5pbWF0aW9uLm9wdHMgKTtcblx0XHRpZiAoIHJlc3VsdCApIHtcblx0XHRcdGlmICggaXNGdW5jdGlvbiggcmVzdWx0LnN0b3AgKSApIHtcblx0XHRcdFx0alF1ZXJ5Ll9xdWV1ZUhvb2tzKCBhbmltYXRpb24uZWxlbSwgYW5pbWF0aW9uLm9wdHMucXVldWUgKS5zdG9wID1cblx0XHRcdFx0XHRyZXN1bHQuc3RvcC5iaW5kKCByZXN1bHQgKTtcblx0XHRcdH1cblx0XHRcdHJldHVybiByZXN1bHQ7XG5cdFx0fVxuXHR9XG5cblx0alF1ZXJ5Lm1hcCggcHJvcHMsIGNyZWF0ZVR3ZWVuLCBhbmltYXRpb24gKTtcblxuXHRpZiAoIGlzRnVuY3Rpb24oIGFuaW1hdGlvbi5vcHRzLnN0YXJ0ICkgKSB7XG5cdFx0YW5pbWF0aW9uLm9wdHMuc3RhcnQuY2FsbCggZWxlbSwgYW5pbWF0aW9uICk7XG5cdH1cblxuXHQvLyBBdHRhY2ggY2FsbGJhY2tzIGZyb20gb3B0aW9uc1xuXHRhbmltYXRpb25cblx0XHQucHJvZ3Jlc3MoIGFuaW1hdGlvbi5vcHRzLnByb2dyZXNzIClcblx0XHQuZG9uZSggYW5pbWF0aW9uLm9wdHMuZG9uZSwgYW5pbWF0aW9uLm9wdHMuY29tcGxldGUgKVxuXHRcdC5mYWlsKCBhbmltYXRpb24ub3B0cy5mYWlsIClcblx0XHQuYWx3YXlzKCBhbmltYXRpb24ub3B0cy5hbHdheXMgKTtcblxuXHRqUXVlcnkuZngudGltZXIoXG5cdFx0alF1ZXJ5LmV4dGVuZCggdGljaywge1xuXHRcdFx0ZWxlbTogZWxlbSxcblx0XHRcdGFuaW06IGFuaW1hdGlvbixcblx0XHRcdHF1ZXVlOiBhbmltYXRpb24ub3B0cy5xdWV1ZVxuXHRcdH0gKVxuXHQpO1xuXG5cdHJldHVybiBhbmltYXRpb247XG59XG5cbmpRdWVyeS5BbmltYXRpb24gPSBqUXVlcnkuZXh0ZW5kKCBBbmltYXRpb24sIHtcblxuXHR0d2VlbmVyczoge1xuXHRcdFwiKlwiOiBbIGZ1bmN0aW9uKCBwcm9wLCB2YWx1ZSApIHtcblx0XHRcdHZhciB0d2VlbiA9IHRoaXMuY3JlYXRlVHdlZW4oIHByb3AsIHZhbHVlICk7XG5cdFx0XHRhZGp1c3RDU1MoIHR3ZWVuLmVsZW0sIHByb3AsIHJjc3NOdW0uZXhlYyggdmFsdWUgKSwgdHdlZW4gKTtcblx0XHRcdHJldHVybiB0d2Vlbjtcblx0XHR9IF1cblx0fSxcblxuXHR0d2VlbmVyOiBmdW5jdGlvbiggcHJvcHMsIGNhbGxiYWNrICkge1xuXHRcdGlmICggaXNGdW5jdGlvbiggcHJvcHMgKSApIHtcblx0XHRcdGNhbGxiYWNrID0gcHJvcHM7XG5cdFx0XHRwcm9wcyA9IFsgXCIqXCIgXTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0cHJvcHMgPSBwcm9wcy5tYXRjaCggcm5vdGh0bWx3aGl0ZSApO1xuXHRcdH1cblxuXHRcdHZhciBwcm9wLFxuXHRcdFx0aW5kZXggPSAwLFxuXHRcdFx0bGVuZ3RoID0gcHJvcHMubGVuZ3RoO1xuXG5cdFx0Zm9yICggOyBpbmRleCA8IGxlbmd0aDsgaW5kZXgrKyApIHtcblx0XHRcdHByb3AgPSBwcm9wc1sgaW5kZXggXTtcblx0XHRcdEFuaW1hdGlvbi50d2VlbmVyc1sgcHJvcCBdID0gQW5pbWF0aW9uLnR3ZWVuZXJzWyBwcm9wIF0gfHwgW107XG5cdFx0XHRBbmltYXRpb24udHdlZW5lcnNbIHByb3AgXS51bnNoaWZ0KCBjYWxsYmFjayApO1xuXHRcdH1cblx0fSxcblxuXHRwcmVmaWx0ZXJzOiBbIGRlZmF1bHRQcmVmaWx0ZXIgXSxcblxuXHRwcmVmaWx0ZXI6IGZ1bmN0aW9uKCBjYWxsYmFjaywgcHJlcGVuZCApIHtcblx0XHRpZiAoIHByZXBlbmQgKSB7XG5cdFx0XHRBbmltYXRpb24ucHJlZmlsdGVycy51bnNoaWZ0KCBjYWxsYmFjayApO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRBbmltYXRpb24ucHJlZmlsdGVycy5wdXNoKCBjYWxsYmFjayApO1xuXHRcdH1cblx0fVxufSApO1xuXG5qUXVlcnkuc3BlZWQgPSBmdW5jdGlvbiggc3BlZWQsIGVhc2luZywgZm4gKSB7XG5cdHZhciBvcHQgPSBzcGVlZCAmJiB0eXBlb2Ygc3BlZWQgPT09IFwib2JqZWN0XCIgPyBqUXVlcnkuZXh0ZW5kKCB7fSwgc3BlZWQgKSA6IHtcblx0XHRjb21wbGV0ZTogZm4gfHwgIWZuICYmIGVhc2luZyB8fFxuXHRcdFx0aXNGdW5jdGlvbiggc3BlZWQgKSAmJiBzcGVlZCxcblx0XHRkdXJhdGlvbjogc3BlZWQsXG5cdFx0ZWFzaW5nOiBmbiAmJiBlYXNpbmcgfHwgZWFzaW5nICYmICFpc0Z1bmN0aW9uKCBlYXNpbmcgKSAmJiBlYXNpbmdcblx0fTtcblxuXHQvLyBHbyB0byB0aGUgZW5kIHN0YXRlIGlmIGZ4IGFyZSBvZmZcblx0aWYgKCBqUXVlcnkuZngub2ZmICkge1xuXHRcdG9wdC5kdXJhdGlvbiA9IDA7XG5cblx0fSBlbHNlIHtcblx0XHRpZiAoIHR5cGVvZiBvcHQuZHVyYXRpb24gIT09IFwibnVtYmVyXCIgKSB7XG5cdFx0XHRpZiAoIG9wdC5kdXJhdGlvbiBpbiBqUXVlcnkuZnguc3BlZWRzICkge1xuXHRcdFx0XHRvcHQuZHVyYXRpb24gPSBqUXVlcnkuZnguc3BlZWRzWyBvcHQuZHVyYXRpb24gXTtcblxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0b3B0LmR1cmF0aW9uID0galF1ZXJ5LmZ4LnNwZWVkcy5fZGVmYXVsdDtcblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHQvLyBOb3JtYWxpemUgb3B0LnF1ZXVlIC0gdHJ1ZS91bmRlZmluZWQvbnVsbCAtPiBcImZ4XCJcblx0aWYgKCBvcHQucXVldWUgPT0gbnVsbCB8fCBvcHQucXVldWUgPT09IHRydWUgKSB7XG5cdFx0b3B0LnF1ZXVlID0gXCJmeFwiO1xuXHR9XG5cblx0Ly8gUXVldWVpbmdcblx0b3B0Lm9sZCA9IG9wdC5jb21wbGV0ZTtcblxuXHRvcHQuY29tcGxldGUgPSBmdW5jdGlvbigpIHtcblx0XHRpZiAoIGlzRnVuY3Rpb24oIG9wdC5vbGQgKSApIHtcblx0XHRcdG9wdC5vbGQuY2FsbCggdGhpcyApO1xuXHRcdH1cblxuXHRcdGlmICggb3B0LnF1ZXVlICkge1xuXHRcdFx0alF1ZXJ5LmRlcXVldWUoIHRoaXMsIG9wdC5xdWV1ZSApO1xuXHRcdH1cblx0fTtcblxuXHRyZXR1cm4gb3B0O1xufTtcblxualF1ZXJ5LmZuLmV4dGVuZCgge1xuXHRmYWRlVG86IGZ1bmN0aW9uKCBzcGVlZCwgdG8sIGVhc2luZywgY2FsbGJhY2sgKSB7XG5cblx0XHQvLyBTaG93IGFueSBoaWRkZW4gZWxlbWVudHMgYWZ0ZXIgc2V0dGluZyBvcGFjaXR5IHRvIDBcblx0XHRyZXR1cm4gdGhpcy5maWx0ZXIoIGlzSGlkZGVuV2l0aGluVHJlZSApLmNzcyggXCJvcGFjaXR5XCIsIDAgKS5zaG93KClcblxuXHRcdFx0Ly8gQW5pbWF0ZSB0byB0aGUgdmFsdWUgc3BlY2lmaWVkXG5cdFx0XHQuZW5kKCkuYW5pbWF0ZSggeyBvcGFjaXR5OiB0byB9LCBzcGVlZCwgZWFzaW5nLCBjYWxsYmFjayApO1xuXHR9LFxuXHRhbmltYXRlOiBmdW5jdGlvbiggcHJvcCwgc3BlZWQsIGVhc2luZywgY2FsbGJhY2sgKSB7XG5cdFx0dmFyIGVtcHR5ID0galF1ZXJ5LmlzRW1wdHlPYmplY3QoIHByb3AgKSxcblx0XHRcdG9wdGFsbCA9IGpRdWVyeS5zcGVlZCggc3BlZWQsIGVhc2luZywgY2FsbGJhY2sgKSxcblx0XHRcdGRvQW5pbWF0aW9uID0gZnVuY3Rpb24oKSB7XG5cblx0XHRcdFx0Ly8gT3BlcmF0ZSBvbiBhIGNvcHkgb2YgcHJvcCBzbyBwZXItcHJvcGVydHkgZWFzaW5nIHdvbid0IGJlIGxvc3Rcblx0XHRcdFx0dmFyIGFuaW0gPSBBbmltYXRpb24oIHRoaXMsIGpRdWVyeS5leHRlbmQoIHt9LCBwcm9wICksIG9wdGFsbCApO1xuXG5cdFx0XHRcdC8vIEVtcHR5IGFuaW1hdGlvbnMsIG9yIGZpbmlzaGluZyByZXNvbHZlcyBpbW1lZGlhdGVseVxuXHRcdFx0XHRpZiAoIGVtcHR5IHx8IGRhdGFQcml2LmdldCggdGhpcywgXCJmaW5pc2hcIiApICkge1xuXHRcdFx0XHRcdGFuaW0uc3RvcCggdHJ1ZSApO1xuXHRcdFx0XHR9XG5cdFx0XHR9O1xuXHRcdFx0ZG9BbmltYXRpb24uZmluaXNoID0gZG9BbmltYXRpb247XG5cblx0XHRyZXR1cm4gZW1wdHkgfHwgb3B0YWxsLnF1ZXVlID09PSBmYWxzZSA/XG5cdFx0XHR0aGlzLmVhY2goIGRvQW5pbWF0aW9uICkgOlxuXHRcdFx0dGhpcy5xdWV1ZSggb3B0YWxsLnF1ZXVlLCBkb0FuaW1hdGlvbiApO1xuXHR9LFxuXHRzdG9wOiBmdW5jdGlvbiggdHlwZSwgY2xlYXJRdWV1ZSwgZ290b0VuZCApIHtcblx0XHR2YXIgc3RvcFF1ZXVlID0gZnVuY3Rpb24oIGhvb2tzICkge1xuXHRcdFx0dmFyIHN0b3AgPSBob29rcy5zdG9wO1xuXHRcdFx0ZGVsZXRlIGhvb2tzLnN0b3A7XG5cdFx0XHRzdG9wKCBnb3RvRW5kICk7XG5cdFx0fTtcblxuXHRcdGlmICggdHlwZW9mIHR5cGUgIT09IFwic3RyaW5nXCIgKSB7XG5cdFx0XHRnb3RvRW5kID0gY2xlYXJRdWV1ZTtcblx0XHRcdGNsZWFyUXVldWUgPSB0eXBlO1xuXHRcdFx0dHlwZSA9IHVuZGVmaW5lZDtcblx0XHR9XG5cdFx0aWYgKCBjbGVhclF1ZXVlICYmIHR5cGUgIT09IGZhbHNlICkge1xuXHRcdFx0dGhpcy5xdWV1ZSggdHlwZSB8fCBcImZ4XCIsIFtdICk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRoaXMuZWFjaCggZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgZGVxdWV1ZSA9IHRydWUsXG5cdFx0XHRcdGluZGV4ID0gdHlwZSAhPSBudWxsICYmIHR5cGUgKyBcInF1ZXVlSG9va3NcIixcblx0XHRcdFx0dGltZXJzID0galF1ZXJ5LnRpbWVycyxcblx0XHRcdFx0ZGF0YSA9IGRhdGFQcml2LmdldCggdGhpcyApO1xuXG5cdFx0XHRpZiAoIGluZGV4ICkge1xuXHRcdFx0XHRpZiAoIGRhdGFbIGluZGV4IF0gJiYgZGF0YVsgaW5kZXggXS5zdG9wICkge1xuXHRcdFx0XHRcdHN0b3BRdWV1ZSggZGF0YVsgaW5kZXggXSApO1xuXHRcdFx0XHR9XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRmb3IgKCBpbmRleCBpbiBkYXRhICkge1xuXHRcdFx0XHRcdGlmICggZGF0YVsgaW5kZXggXSAmJiBkYXRhWyBpbmRleCBdLnN0b3AgJiYgcnJ1bi50ZXN0KCBpbmRleCApICkge1xuXHRcdFx0XHRcdFx0c3RvcFF1ZXVlKCBkYXRhWyBpbmRleCBdICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdGZvciAoIGluZGV4ID0gdGltZXJzLmxlbmd0aDsgaW5kZXgtLTsgKSB7XG5cdFx0XHRcdGlmICggdGltZXJzWyBpbmRleCBdLmVsZW0gPT09IHRoaXMgJiZcblx0XHRcdFx0XHQoIHR5cGUgPT0gbnVsbCB8fCB0aW1lcnNbIGluZGV4IF0ucXVldWUgPT09IHR5cGUgKSApIHtcblxuXHRcdFx0XHRcdHRpbWVyc1sgaW5kZXggXS5hbmltLnN0b3AoIGdvdG9FbmQgKTtcblx0XHRcdFx0XHRkZXF1ZXVlID0gZmFsc2U7XG5cdFx0XHRcdFx0dGltZXJzLnNwbGljZSggaW5kZXgsIDEgKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHQvLyBTdGFydCB0aGUgbmV4dCBpbiB0aGUgcXVldWUgaWYgdGhlIGxhc3Qgc3RlcCB3YXNuJ3QgZm9yY2VkLlxuXHRcdFx0Ly8gVGltZXJzIGN1cnJlbnRseSB3aWxsIGNhbGwgdGhlaXIgY29tcGxldGUgY2FsbGJhY2tzLCB3aGljaFxuXHRcdFx0Ly8gd2lsbCBkZXF1ZXVlIGJ1dCBvbmx5IGlmIHRoZXkgd2VyZSBnb3RvRW5kLlxuXHRcdFx0aWYgKCBkZXF1ZXVlIHx8ICFnb3RvRW5kICkge1xuXHRcdFx0XHRqUXVlcnkuZGVxdWV1ZSggdGhpcywgdHlwZSApO1xuXHRcdFx0fVxuXHRcdH0gKTtcblx0fSxcblx0ZmluaXNoOiBmdW5jdGlvbiggdHlwZSApIHtcblx0XHRpZiAoIHR5cGUgIT09IGZhbHNlICkge1xuXHRcdFx0dHlwZSA9IHR5cGUgfHwgXCJmeFwiO1xuXHRcdH1cblx0XHRyZXR1cm4gdGhpcy5lYWNoKCBmdW5jdGlvbigpIHtcblx0XHRcdHZhciBpbmRleCxcblx0XHRcdFx0ZGF0YSA9IGRhdGFQcml2LmdldCggdGhpcyApLFxuXHRcdFx0XHRxdWV1ZSA9IGRhdGFbIHR5cGUgKyBcInF1ZXVlXCIgXSxcblx0XHRcdFx0aG9va3MgPSBkYXRhWyB0eXBlICsgXCJxdWV1ZUhvb2tzXCIgXSxcblx0XHRcdFx0dGltZXJzID0galF1ZXJ5LnRpbWVycyxcblx0XHRcdFx0bGVuZ3RoID0gcXVldWUgPyBxdWV1ZS5sZW5ndGggOiAwO1xuXG5cdFx0XHQvLyBFbmFibGUgZmluaXNoaW5nIGZsYWcgb24gcHJpdmF0ZSBkYXRhXG5cdFx0XHRkYXRhLmZpbmlzaCA9IHRydWU7XG5cblx0XHRcdC8vIEVtcHR5IHRoZSBxdWV1ZSBmaXJzdFxuXHRcdFx0alF1ZXJ5LnF1ZXVlKCB0aGlzLCB0eXBlLCBbXSApO1xuXG5cdFx0XHRpZiAoIGhvb2tzICYmIGhvb2tzLnN0b3AgKSB7XG5cdFx0XHRcdGhvb2tzLnN0b3AuY2FsbCggdGhpcywgdHJ1ZSApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBMb29rIGZvciBhbnkgYWN0aXZlIGFuaW1hdGlvbnMsIGFuZCBmaW5pc2ggdGhlbVxuXHRcdFx0Zm9yICggaW5kZXggPSB0aW1lcnMubGVuZ3RoOyBpbmRleC0tOyApIHtcblx0XHRcdFx0aWYgKCB0aW1lcnNbIGluZGV4IF0uZWxlbSA9PT0gdGhpcyAmJiB0aW1lcnNbIGluZGV4IF0ucXVldWUgPT09IHR5cGUgKSB7XG5cdFx0XHRcdFx0dGltZXJzWyBpbmRleCBdLmFuaW0uc3RvcCggdHJ1ZSApO1xuXHRcdFx0XHRcdHRpbWVycy5zcGxpY2UoIGluZGV4LCAxICk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0Ly8gTG9vayBmb3IgYW55IGFuaW1hdGlvbnMgaW4gdGhlIG9sZCBxdWV1ZSBhbmQgZmluaXNoIHRoZW1cblx0XHRcdGZvciAoIGluZGV4ID0gMDsgaW5kZXggPCBsZW5ndGg7IGluZGV4KysgKSB7XG5cdFx0XHRcdGlmICggcXVldWVbIGluZGV4IF0gJiYgcXVldWVbIGluZGV4IF0uZmluaXNoICkge1xuXHRcdFx0XHRcdHF1ZXVlWyBpbmRleCBdLmZpbmlzaC5jYWxsKCB0aGlzICk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0Ly8gVHVybiBvZmYgZmluaXNoaW5nIGZsYWdcblx0XHRcdGRlbGV0ZSBkYXRhLmZpbmlzaDtcblx0XHR9ICk7XG5cdH1cbn0gKTtcblxualF1ZXJ5LmVhY2goIFsgXCJ0b2dnbGVcIiwgXCJzaG93XCIsIFwiaGlkZVwiIF0sIGZ1bmN0aW9uKCBpLCBuYW1lICkge1xuXHR2YXIgY3NzRm4gPSBqUXVlcnkuZm5bIG5hbWUgXTtcblx0alF1ZXJ5LmZuWyBuYW1lIF0gPSBmdW5jdGlvbiggc3BlZWQsIGVhc2luZywgY2FsbGJhY2sgKSB7XG5cdFx0cmV0dXJuIHNwZWVkID09IG51bGwgfHwgdHlwZW9mIHNwZWVkID09PSBcImJvb2xlYW5cIiA/XG5cdFx0XHRjc3NGbi5hcHBseSggdGhpcywgYXJndW1lbnRzICkgOlxuXHRcdFx0dGhpcy5hbmltYXRlKCBnZW5GeCggbmFtZSwgdHJ1ZSApLCBzcGVlZCwgZWFzaW5nLCBjYWxsYmFjayApO1xuXHR9O1xufSApO1xuXG4vLyBHZW5lcmF0ZSBzaG9ydGN1dHMgZm9yIGN1c3RvbSBhbmltYXRpb25zXG5qUXVlcnkuZWFjaCgge1xuXHRzbGlkZURvd246IGdlbkZ4KCBcInNob3dcIiApLFxuXHRzbGlkZVVwOiBnZW5GeCggXCJoaWRlXCIgKSxcblx0c2xpZGVUb2dnbGU6IGdlbkZ4KCBcInRvZ2dsZVwiICksXG5cdGZhZGVJbjogeyBvcGFjaXR5OiBcInNob3dcIiB9LFxuXHRmYWRlT3V0OiB7IG9wYWNpdHk6IFwiaGlkZVwiIH0sXG5cdGZhZGVUb2dnbGU6IHsgb3BhY2l0eTogXCJ0b2dnbGVcIiB9XG59LCBmdW5jdGlvbiggbmFtZSwgcHJvcHMgKSB7XG5cdGpRdWVyeS5mblsgbmFtZSBdID0gZnVuY3Rpb24oIHNwZWVkLCBlYXNpbmcsIGNhbGxiYWNrICkge1xuXHRcdHJldHVybiB0aGlzLmFuaW1hdGUoIHByb3BzLCBzcGVlZCwgZWFzaW5nLCBjYWxsYmFjayApO1xuXHR9O1xufSApO1xuXG5qUXVlcnkudGltZXJzID0gW107XG5qUXVlcnkuZngudGljayA9IGZ1bmN0aW9uKCkge1xuXHR2YXIgdGltZXIsXG5cdFx0aSA9IDAsXG5cdFx0dGltZXJzID0galF1ZXJ5LnRpbWVycztcblxuXHRmeE5vdyA9IERhdGUubm93KCk7XG5cblx0Zm9yICggOyBpIDwgdGltZXJzLmxlbmd0aDsgaSsrICkge1xuXHRcdHRpbWVyID0gdGltZXJzWyBpIF07XG5cblx0XHQvLyBSdW4gdGhlIHRpbWVyIGFuZCBzYWZlbHkgcmVtb3ZlIGl0IHdoZW4gZG9uZSAoYWxsb3dpbmcgZm9yIGV4dGVybmFsIHJlbW92YWwpXG5cdFx0aWYgKCAhdGltZXIoKSAmJiB0aW1lcnNbIGkgXSA9PT0gdGltZXIgKSB7XG5cdFx0XHR0aW1lcnMuc3BsaWNlKCBpLS0sIDEgKTtcblx0XHR9XG5cdH1cblxuXHRpZiAoICF0aW1lcnMubGVuZ3RoICkge1xuXHRcdGpRdWVyeS5meC5zdG9wKCk7XG5cdH1cblx0ZnhOb3cgPSB1bmRlZmluZWQ7XG59O1xuXG5qUXVlcnkuZngudGltZXIgPSBmdW5jdGlvbiggdGltZXIgKSB7XG5cdGpRdWVyeS50aW1lcnMucHVzaCggdGltZXIgKTtcblx0alF1ZXJ5LmZ4LnN0YXJ0KCk7XG59O1xuXG5qUXVlcnkuZnguaW50ZXJ2YWwgPSAxMztcbmpRdWVyeS5meC5zdGFydCA9IGZ1bmN0aW9uKCkge1xuXHRpZiAoIGluUHJvZ3Jlc3MgKSB7XG5cdFx0cmV0dXJuO1xuXHR9XG5cblx0aW5Qcm9ncmVzcyA9IHRydWU7XG5cdHNjaGVkdWxlKCk7XG59O1xuXG5qUXVlcnkuZnguc3RvcCA9IGZ1bmN0aW9uKCkge1xuXHRpblByb2dyZXNzID0gbnVsbDtcbn07XG5cbmpRdWVyeS5meC5zcGVlZHMgPSB7XG5cdHNsb3c6IDYwMCxcblx0ZmFzdDogMjAwLFxuXG5cdC8vIERlZmF1bHQgc3BlZWRcblx0X2RlZmF1bHQ6IDQwMFxufTtcblxuXG4vLyBCYXNlZCBvZmYgb2YgdGhlIHBsdWdpbiBieSBDbGludCBIZWxmZXJzLCB3aXRoIHBlcm1pc3Npb24uXG4vLyBodHRwczovL3dlYi5hcmNoaXZlLm9yZy93ZWIvMjAxMDAzMjQwMTQ3NDcvaHR0cDovL2JsaW5kc2lnbmFscy5jb20vaW5kZXgucGhwLzIwMDkvMDcvanF1ZXJ5LWRlbGF5L1xualF1ZXJ5LmZuLmRlbGF5ID0gZnVuY3Rpb24oIHRpbWUsIHR5cGUgKSB7XG5cdHRpbWUgPSBqUXVlcnkuZnggPyBqUXVlcnkuZnguc3BlZWRzWyB0aW1lIF0gfHwgdGltZSA6IHRpbWU7XG5cdHR5cGUgPSB0eXBlIHx8IFwiZnhcIjtcblxuXHRyZXR1cm4gdGhpcy5xdWV1ZSggdHlwZSwgZnVuY3Rpb24oIG5leHQsIGhvb2tzICkge1xuXHRcdHZhciB0aW1lb3V0ID0gd2luZG93LnNldFRpbWVvdXQoIG5leHQsIHRpbWUgKTtcblx0XHRob29rcy5zdG9wID0gZnVuY3Rpb24oKSB7XG5cdFx0XHR3aW5kb3cuY2xlYXJUaW1lb3V0KCB0aW1lb3V0ICk7XG5cdFx0fTtcblx0fSApO1xufTtcblxuXG4oIGZ1bmN0aW9uKCkge1xuXHR2YXIgaW5wdXQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCBcImlucHV0XCIgKSxcblx0XHRzZWxlY3QgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCBcInNlbGVjdFwiICksXG5cdFx0b3B0ID0gc2VsZWN0LmFwcGVuZENoaWxkKCBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCBcIm9wdGlvblwiICkgKTtcblxuXHRpbnB1dC50eXBlID0gXCJjaGVja2JveFwiO1xuXG5cdC8vIFN1cHBvcnQ6IEFuZHJvaWQgPD00LjMgb25seVxuXHQvLyBEZWZhdWx0IHZhbHVlIGZvciBhIGNoZWNrYm94IHNob3VsZCBiZSBcIm9uXCJcblx0c3VwcG9ydC5jaGVja09uID0gaW5wdXQudmFsdWUgIT09IFwiXCI7XG5cblx0Ly8gU3VwcG9ydDogSUUgPD0xMSBvbmx5XG5cdC8vIE11c3QgYWNjZXNzIHNlbGVjdGVkSW5kZXggdG8gbWFrZSBkZWZhdWx0IG9wdGlvbnMgc2VsZWN0XG5cdHN1cHBvcnQub3B0U2VsZWN0ZWQgPSBvcHQuc2VsZWN0ZWQ7XG5cblx0Ly8gU3VwcG9ydDogSUUgPD0xMSBvbmx5XG5cdC8vIEFuIGlucHV0IGxvc2VzIGl0cyB2YWx1ZSBhZnRlciBiZWNvbWluZyBhIHJhZGlvXG5cdGlucHV0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCggXCJpbnB1dFwiICk7XG5cdGlucHV0LnZhbHVlID0gXCJ0XCI7XG5cdGlucHV0LnR5cGUgPSBcInJhZGlvXCI7XG5cdHN1cHBvcnQucmFkaW9WYWx1ZSA9IGlucHV0LnZhbHVlID09PSBcInRcIjtcbn0gKSgpO1xuXG5cbnZhciBib29sSG9vayxcblx0YXR0ckhhbmRsZSA9IGpRdWVyeS5leHByLmF0dHJIYW5kbGU7XG5cbmpRdWVyeS5mbi5leHRlbmQoIHtcblx0YXR0cjogZnVuY3Rpb24oIG5hbWUsIHZhbHVlICkge1xuXHRcdHJldHVybiBhY2Nlc3MoIHRoaXMsIGpRdWVyeS5hdHRyLCBuYW1lLCB2YWx1ZSwgYXJndW1lbnRzLmxlbmd0aCA+IDEgKTtcblx0fSxcblxuXHRyZW1vdmVBdHRyOiBmdW5jdGlvbiggbmFtZSApIHtcblx0XHRyZXR1cm4gdGhpcy5lYWNoKCBmdW5jdGlvbigpIHtcblx0XHRcdGpRdWVyeS5yZW1vdmVBdHRyKCB0aGlzLCBuYW1lICk7XG5cdFx0fSApO1xuXHR9XG59ICk7XG5cbmpRdWVyeS5leHRlbmQoIHtcblx0YXR0cjogZnVuY3Rpb24oIGVsZW0sIG5hbWUsIHZhbHVlICkge1xuXHRcdHZhciByZXQsIGhvb2tzLFxuXHRcdFx0blR5cGUgPSBlbGVtLm5vZGVUeXBlO1xuXG5cdFx0Ly8gRG9uJ3QgZ2V0L3NldCBhdHRyaWJ1dGVzIG9uIHRleHQsIGNvbW1lbnQgYW5kIGF0dHJpYnV0ZSBub2Rlc1xuXHRcdGlmICggblR5cGUgPT09IDMgfHwgblR5cGUgPT09IDggfHwgblR5cGUgPT09IDIgKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0Ly8gRmFsbGJhY2sgdG8gcHJvcCB3aGVuIGF0dHJpYnV0ZXMgYXJlIG5vdCBzdXBwb3J0ZWRcblx0XHRpZiAoIHR5cGVvZiBlbGVtLmdldEF0dHJpYnV0ZSA9PT0gXCJ1bmRlZmluZWRcIiApIHtcblx0XHRcdHJldHVybiBqUXVlcnkucHJvcCggZWxlbSwgbmFtZSwgdmFsdWUgKTtcblx0XHR9XG5cblx0XHQvLyBBdHRyaWJ1dGUgaG9va3MgYXJlIGRldGVybWluZWQgYnkgdGhlIGxvd2VyY2FzZSB2ZXJzaW9uXG5cdFx0Ly8gR3JhYiBuZWNlc3NhcnkgaG9vayBpZiBvbmUgaXMgZGVmaW5lZFxuXHRcdGlmICggblR5cGUgIT09IDEgfHwgIWpRdWVyeS5pc1hNTERvYyggZWxlbSApICkge1xuXHRcdFx0aG9va3MgPSBqUXVlcnkuYXR0ckhvb2tzWyBuYW1lLnRvTG93ZXJDYXNlKCkgXSB8fFxuXHRcdFx0XHQoIGpRdWVyeS5leHByLm1hdGNoLmJvb2wudGVzdCggbmFtZSApID8gYm9vbEhvb2sgOiB1bmRlZmluZWQgKTtcblx0XHR9XG5cblx0XHRpZiAoIHZhbHVlICE9PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRpZiAoIHZhbHVlID09PSBudWxsICkge1xuXHRcdFx0XHRqUXVlcnkucmVtb3ZlQXR0ciggZWxlbSwgbmFtZSApO1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cblx0XHRcdGlmICggaG9va3MgJiYgXCJzZXRcIiBpbiBob29rcyAmJlxuXHRcdFx0XHQoIHJldCA9IGhvb2tzLnNldCggZWxlbSwgdmFsdWUsIG5hbWUgKSApICE9PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRcdHJldHVybiByZXQ7XG5cdFx0XHR9XG5cblx0XHRcdGVsZW0uc2V0QXR0cmlidXRlKCBuYW1lLCB2YWx1ZSArIFwiXCIgKTtcblx0XHRcdHJldHVybiB2YWx1ZTtcblx0XHR9XG5cblx0XHRpZiAoIGhvb2tzICYmIFwiZ2V0XCIgaW4gaG9va3MgJiYgKCByZXQgPSBob29rcy5nZXQoIGVsZW0sIG5hbWUgKSApICE9PSBudWxsICkge1xuXHRcdFx0cmV0dXJuIHJldDtcblx0XHR9XG5cblx0XHRyZXQgPSBqUXVlcnkuZmluZC5hdHRyKCBlbGVtLCBuYW1lICk7XG5cblx0XHQvLyBOb24tZXhpc3RlbnQgYXR0cmlidXRlcyByZXR1cm4gbnVsbCwgd2Ugbm9ybWFsaXplIHRvIHVuZGVmaW5lZFxuXHRcdHJldHVybiByZXQgPT0gbnVsbCA/IHVuZGVmaW5lZCA6IHJldDtcblx0fSxcblxuXHRhdHRySG9va3M6IHtcblx0XHR0eXBlOiB7XG5cdFx0XHRzZXQ6IGZ1bmN0aW9uKCBlbGVtLCB2YWx1ZSApIHtcblx0XHRcdFx0aWYgKCAhc3VwcG9ydC5yYWRpb1ZhbHVlICYmIHZhbHVlID09PSBcInJhZGlvXCIgJiZcblx0XHRcdFx0XHRub2RlTmFtZSggZWxlbSwgXCJpbnB1dFwiICkgKSB7XG5cdFx0XHRcdFx0dmFyIHZhbCA9IGVsZW0udmFsdWU7XG5cdFx0XHRcdFx0ZWxlbS5zZXRBdHRyaWJ1dGUoIFwidHlwZVwiLCB2YWx1ZSApO1xuXHRcdFx0XHRcdGlmICggdmFsICkge1xuXHRcdFx0XHRcdFx0ZWxlbS52YWx1ZSA9IHZhbDtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0cmV0dXJuIHZhbHVlO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9LFxuXG5cdHJlbW92ZUF0dHI6IGZ1bmN0aW9uKCBlbGVtLCB2YWx1ZSApIHtcblx0XHR2YXIgbmFtZSxcblx0XHRcdGkgPSAwLFxuXG5cdFx0XHQvLyBBdHRyaWJ1dGUgbmFtZXMgY2FuIGNvbnRhaW4gbm9uLUhUTUwgd2hpdGVzcGFjZSBjaGFyYWN0ZXJzXG5cdFx0XHQvLyBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9zeW50YXguaHRtbCNhdHRyaWJ1dGVzLTJcblx0XHRcdGF0dHJOYW1lcyA9IHZhbHVlICYmIHZhbHVlLm1hdGNoKCBybm90aHRtbHdoaXRlICk7XG5cblx0XHRpZiAoIGF0dHJOYW1lcyAmJiBlbGVtLm5vZGVUeXBlID09PSAxICkge1xuXHRcdFx0d2hpbGUgKCAoIG5hbWUgPSBhdHRyTmFtZXNbIGkrKyBdICkgKSB7XG5cdFx0XHRcdGVsZW0ucmVtb3ZlQXR0cmlidXRlKCBuYW1lICk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG59ICk7XG5cbi8vIEhvb2tzIGZvciBib29sZWFuIGF0dHJpYnV0ZXNcbmJvb2xIb29rID0ge1xuXHRzZXQ6IGZ1bmN0aW9uKCBlbGVtLCB2YWx1ZSwgbmFtZSApIHtcblx0XHRpZiAoIHZhbHVlID09PSBmYWxzZSApIHtcblxuXHRcdFx0Ly8gUmVtb3ZlIGJvb2xlYW4gYXR0cmlidXRlcyB3aGVuIHNldCB0byBmYWxzZVxuXHRcdFx0alF1ZXJ5LnJlbW92ZUF0dHIoIGVsZW0sIG5hbWUgKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0ZWxlbS5zZXRBdHRyaWJ1dGUoIG5hbWUsIG5hbWUgKTtcblx0XHR9XG5cdFx0cmV0dXJuIG5hbWU7XG5cdH1cbn07XG5cbmpRdWVyeS5lYWNoKCBqUXVlcnkuZXhwci5tYXRjaC5ib29sLnNvdXJjZS5tYXRjaCggL1xcdysvZyApLCBmdW5jdGlvbiggaSwgbmFtZSApIHtcblx0dmFyIGdldHRlciA9IGF0dHJIYW5kbGVbIG5hbWUgXSB8fCBqUXVlcnkuZmluZC5hdHRyO1xuXG5cdGF0dHJIYW5kbGVbIG5hbWUgXSA9IGZ1bmN0aW9uKCBlbGVtLCBuYW1lLCBpc1hNTCApIHtcblx0XHR2YXIgcmV0LCBoYW5kbGUsXG5cdFx0XHRsb3dlcmNhc2VOYW1lID0gbmFtZS50b0xvd2VyQ2FzZSgpO1xuXG5cdFx0aWYgKCAhaXNYTUwgKSB7XG5cblx0XHRcdC8vIEF2b2lkIGFuIGluZmluaXRlIGxvb3AgYnkgdGVtcG9yYXJpbHkgcmVtb3ZpbmcgdGhpcyBmdW5jdGlvbiBmcm9tIHRoZSBnZXR0ZXJcblx0XHRcdGhhbmRsZSA9IGF0dHJIYW5kbGVbIGxvd2VyY2FzZU5hbWUgXTtcblx0XHRcdGF0dHJIYW5kbGVbIGxvd2VyY2FzZU5hbWUgXSA9IHJldDtcblx0XHRcdHJldCA9IGdldHRlciggZWxlbSwgbmFtZSwgaXNYTUwgKSAhPSBudWxsID9cblx0XHRcdFx0bG93ZXJjYXNlTmFtZSA6XG5cdFx0XHRcdG51bGw7XG5cdFx0XHRhdHRySGFuZGxlWyBsb3dlcmNhc2VOYW1lIF0gPSBoYW5kbGU7XG5cdFx0fVxuXHRcdHJldHVybiByZXQ7XG5cdH07XG59ICk7XG5cblxuXG5cbnZhciByZm9jdXNhYmxlID0gL14oPzppbnB1dHxzZWxlY3R8dGV4dGFyZWF8YnV0dG9uKSQvaSxcblx0cmNsaWNrYWJsZSA9IC9eKD86YXxhcmVhKSQvaTtcblxualF1ZXJ5LmZuLmV4dGVuZCgge1xuXHRwcm9wOiBmdW5jdGlvbiggbmFtZSwgdmFsdWUgKSB7XG5cdFx0cmV0dXJuIGFjY2VzcyggdGhpcywgalF1ZXJ5LnByb3AsIG5hbWUsIHZhbHVlLCBhcmd1bWVudHMubGVuZ3RoID4gMSApO1xuXHR9LFxuXG5cdHJlbW92ZVByb3A6IGZ1bmN0aW9uKCBuYW1lICkge1xuXHRcdHJldHVybiB0aGlzLmVhY2goIGZ1bmN0aW9uKCkge1xuXHRcdFx0ZGVsZXRlIHRoaXNbIGpRdWVyeS5wcm9wRml4WyBuYW1lIF0gfHwgbmFtZSBdO1xuXHRcdH0gKTtcblx0fVxufSApO1xuXG5qUXVlcnkuZXh0ZW5kKCB7XG5cdHByb3A6IGZ1bmN0aW9uKCBlbGVtLCBuYW1lLCB2YWx1ZSApIHtcblx0XHR2YXIgcmV0LCBob29rcyxcblx0XHRcdG5UeXBlID0gZWxlbS5ub2RlVHlwZTtcblxuXHRcdC8vIERvbid0IGdldC9zZXQgcHJvcGVydGllcyBvbiB0ZXh0LCBjb21tZW50IGFuZCBhdHRyaWJ1dGUgbm9kZXNcblx0XHRpZiAoIG5UeXBlID09PSAzIHx8IG5UeXBlID09PSA4IHx8IG5UeXBlID09PSAyICkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdGlmICggblR5cGUgIT09IDEgfHwgIWpRdWVyeS5pc1hNTERvYyggZWxlbSApICkge1xuXG5cdFx0XHQvLyBGaXggbmFtZSBhbmQgYXR0YWNoIGhvb2tzXG5cdFx0XHRuYW1lID0galF1ZXJ5LnByb3BGaXhbIG5hbWUgXSB8fCBuYW1lO1xuXHRcdFx0aG9va3MgPSBqUXVlcnkucHJvcEhvb2tzWyBuYW1lIF07XG5cdFx0fVxuXG5cdFx0aWYgKCB2YWx1ZSAhPT0gdW5kZWZpbmVkICkge1xuXHRcdFx0aWYgKCBob29rcyAmJiBcInNldFwiIGluIGhvb2tzICYmXG5cdFx0XHRcdCggcmV0ID0gaG9va3Muc2V0KCBlbGVtLCB2YWx1ZSwgbmFtZSApICkgIT09IHVuZGVmaW5lZCApIHtcblx0XHRcdFx0cmV0dXJuIHJldDtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuICggZWxlbVsgbmFtZSBdID0gdmFsdWUgKTtcblx0XHR9XG5cblx0XHRpZiAoIGhvb2tzICYmIFwiZ2V0XCIgaW4gaG9va3MgJiYgKCByZXQgPSBob29rcy5nZXQoIGVsZW0sIG5hbWUgKSApICE9PSBudWxsICkge1xuXHRcdFx0cmV0dXJuIHJldDtcblx0XHR9XG5cblx0XHRyZXR1cm4gZWxlbVsgbmFtZSBdO1xuXHR9LFxuXG5cdHByb3BIb29rczoge1xuXHRcdHRhYkluZGV4OiB7XG5cdFx0XHRnZXQ6IGZ1bmN0aW9uKCBlbGVtICkge1xuXG5cdFx0XHRcdC8vIFN1cHBvcnQ6IElFIDw9OSAtIDExIG9ubHlcblx0XHRcdFx0Ly8gZWxlbS50YWJJbmRleCBkb2Vzbid0IGFsd2F5cyByZXR1cm4gdGhlXG5cdFx0XHRcdC8vIGNvcnJlY3QgdmFsdWUgd2hlbiBpdCBoYXNuJ3QgYmVlbiBleHBsaWNpdGx5IHNldFxuXHRcdFx0XHQvLyBodHRwczovL3dlYi5hcmNoaXZlLm9yZy93ZWIvMjAxNDExMTYyMzMzNDcvaHR0cDovL2ZsdWlkcHJvamVjdC5vcmcvYmxvZy8yMDA4LzAxLzA5L2dldHRpbmctc2V0dGluZy1hbmQtcmVtb3ZpbmctdGFiaW5kZXgtdmFsdWVzLXdpdGgtamF2YXNjcmlwdC9cblx0XHRcdFx0Ly8gVXNlIHByb3BlciBhdHRyaWJ1dGUgcmV0cmlldmFsKCMxMjA3Milcblx0XHRcdFx0dmFyIHRhYmluZGV4ID0galF1ZXJ5LmZpbmQuYXR0ciggZWxlbSwgXCJ0YWJpbmRleFwiICk7XG5cblx0XHRcdFx0aWYgKCB0YWJpbmRleCApIHtcblx0XHRcdFx0XHRyZXR1cm4gcGFyc2VJbnQoIHRhYmluZGV4LCAxMCApO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0aWYgKFxuXHRcdFx0XHRcdHJmb2N1c2FibGUudGVzdCggZWxlbS5ub2RlTmFtZSApIHx8XG5cdFx0XHRcdFx0cmNsaWNrYWJsZS50ZXN0KCBlbGVtLm5vZGVOYW1lICkgJiZcblx0XHRcdFx0XHRlbGVtLmhyZWZcblx0XHRcdFx0KSB7XG5cdFx0XHRcdFx0cmV0dXJuIDA7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRyZXR1cm4gLTE7XG5cdFx0XHR9XG5cdFx0fVxuXHR9LFxuXG5cdHByb3BGaXg6IHtcblx0XHRcImZvclwiOiBcImh0bWxGb3JcIixcblx0XHRcImNsYXNzXCI6IFwiY2xhc3NOYW1lXCJcblx0fVxufSApO1xuXG4vLyBTdXBwb3J0OiBJRSA8PTExIG9ubHlcbi8vIEFjY2Vzc2luZyB0aGUgc2VsZWN0ZWRJbmRleCBwcm9wZXJ0eVxuLy8gZm9yY2VzIHRoZSBicm93c2VyIHRvIHJlc3BlY3Qgc2V0dGluZyBzZWxlY3RlZFxuLy8gb24gdGhlIG9wdGlvblxuLy8gVGhlIGdldHRlciBlbnN1cmVzIGEgZGVmYXVsdCBvcHRpb24gaXMgc2VsZWN0ZWRcbi8vIHdoZW4gaW4gYW4gb3B0Z3JvdXBcbi8vIGVzbGludCBydWxlIFwibm8tdW51c2VkLWV4cHJlc3Npb25zXCIgaXMgZGlzYWJsZWQgZm9yIHRoaXMgY29kZVxuLy8gc2luY2UgaXQgY29uc2lkZXJzIHN1Y2ggYWNjZXNzaW9ucyBub29wXG5pZiAoICFzdXBwb3J0Lm9wdFNlbGVjdGVkICkge1xuXHRqUXVlcnkucHJvcEhvb2tzLnNlbGVjdGVkID0ge1xuXHRcdGdldDogZnVuY3Rpb24oIGVsZW0gKSB7XG5cblx0XHRcdC8qIGVzbGludCBuby11bnVzZWQtZXhwcmVzc2lvbnM6IFwib2ZmXCIgKi9cblxuXHRcdFx0dmFyIHBhcmVudCA9IGVsZW0ucGFyZW50Tm9kZTtcblx0XHRcdGlmICggcGFyZW50ICYmIHBhcmVudC5wYXJlbnROb2RlICkge1xuXHRcdFx0XHRwYXJlbnQucGFyZW50Tm9kZS5zZWxlY3RlZEluZGV4O1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIG51bGw7XG5cdFx0fSxcblx0XHRzZXQ6IGZ1bmN0aW9uKCBlbGVtICkge1xuXG5cdFx0XHQvKiBlc2xpbnQgbm8tdW51c2VkLWV4cHJlc3Npb25zOiBcIm9mZlwiICovXG5cblx0XHRcdHZhciBwYXJlbnQgPSBlbGVtLnBhcmVudE5vZGU7XG5cdFx0XHRpZiAoIHBhcmVudCApIHtcblx0XHRcdFx0cGFyZW50LnNlbGVjdGVkSW5kZXg7XG5cblx0XHRcdFx0aWYgKCBwYXJlbnQucGFyZW50Tm9kZSApIHtcblx0XHRcdFx0XHRwYXJlbnQucGFyZW50Tm9kZS5zZWxlY3RlZEluZGV4O1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9O1xufVxuXG5qUXVlcnkuZWFjaCggW1xuXHRcInRhYkluZGV4XCIsXG5cdFwicmVhZE9ubHlcIixcblx0XCJtYXhMZW5ndGhcIixcblx0XCJjZWxsU3BhY2luZ1wiLFxuXHRcImNlbGxQYWRkaW5nXCIsXG5cdFwicm93U3BhblwiLFxuXHRcImNvbFNwYW5cIixcblx0XCJ1c2VNYXBcIixcblx0XCJmcmFtZUJvcmRlclwiLFxuXHRcImNvbnRlbnRFZGl0YWJsZVwiXG5dLCBmdW5jdGlvbigpIHtcblx0alF1ZXJ5LnByb3BGaXhbIHRoaXMudG9Mb3dlckNhc2UoKSBdID0gdGhpcztcbn0gKTtcblxuXG5cblxuXHQvLyBTdHJpcCBhbmQgY29sbGFwc2Ugd2hpdGVzcGFjZSBhY2NvcmRpbmcgdG8gSFRNTCBzcGVjXG5cdC8vIGh0dHBzOi8vaW5mcmEuc3BlYy53aGF0d2cub3JnLyNzdHJpcC1hbmQtY29sbGFwc2UtYXNjaWktd2hpdGVzcGFjZVxuXHRmdW5jdGlvbiBzdHJpcEFuZENvbGxhcHNlKCB2YWx1ZSApIHtcblx0XHR2YXIgdG9rZW5zID0gdmFsdWUubWF0Y2goIHJub3RodG1sd2hpdGUgKSB8fCBbXTtcblx0XHRyZXR1cm4gdG9rZW5zLmpvaW4oIFwiIFwiICk7XG5cdH1cblxuXG5mdW5jdGlvbiBnZXRDbGFzcyggZWxlbSApIHtcblx0cmV0dXJuIGVsZW0uZ2V0QXR0cmlidXRlICYmIGVsZW0uZ2V0QXR0cmlidXRlKCBcImNsYXNzXCIgKSB8fCBcIlwiO1xufVxuXG5mdW5jdGlvbiBjbGFzc2VzVG9BcnJheSggdmFsdWUgKSB7XG5cdGlmICggQXJyYXkuaXNBcnJheSggdmFsdWUgKSApIHtcblx0XHRyZXR1cm4gdmFsdWU7XG5cdH1cblx0aWYgKCB0eXBlb2YgdmFsdWUgPT09IFwic3RyaW5nXCIgKSB7XG5cdFx0cmV0dXJuIHZhbHVlLm1hdGNoKCBybm90aHRtbHdoaXRlICkgfHwgW107XG5cdH1cblx0cmV0dXJuIFtdO1xufVxuXG5qUXVlcnkuZm4uZXh0ZW5kKCB7XG5cdGFkZENsYXNzOiBmdW5jdGlvbiggdmFsdWUgKSB7XG5cdFx0dmFyIGNsYXNzZXMsIGVsZW0sIGN1ciwgY3VyVmFsdWUsIGNsYXp6LCBqLCBmaW5hbFZhbHVlLFxuXHRcdFx0aSA9IDA7XG5cblx0XHRpZiAoIGlzRnVuY3Rpb24oIHZhbHVlICkgKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5lYWNoKCBmdW5jdGlvbiggaiApIHtcblx0XHRcdFx0alF1ZXJ5KCB0aGlzICkuYWRkQ2xhc3MoIHZhbHVlLmNhbGwoIHRoaXMsIGosIGdldENsYXNzKCB0aGlzICkgKSApO1xuXHRcdFx0fSApO1xuXHRcdH1cblxuXHRcdGNsYXNzZXMgPSBjbGFzc2VzVG9BcnJheSggdmFsdWUgKTtcblxuXHRcdGlmICggY2xhc3Nlcy5sZW5ndGggKSB7XG5cdFx0XHR3aGlsZSAoICggZWxlbSA9IHRoaXNbIGkrKyBdICkgKSB7XG5cdFx0XHRcdGN1clZhbHVlID0gZ2V0Q2xhc3MoIGVsZW0gKTtcblx0XHRcdFx0Y3VyID0gZWxlbS5ub2RlVHlwZSA9PT0gMSAmJiAoIFwiIFwiICsgc3RyaXBBbmRDb2xsYXBzZSggY3VyVmFsdWUgKSArIFwiIFwiICk7XG5cblx0XHRcdFx0aWYgKCBjdXIgKSB7XG5cdFx0XHRcdFx0aiA9IDA7XG5cdFx0XHRcdFx0d2hpbGUgKCAoIGNsYXp6ID0gY2xhc3Nlc1sgaisrIF0gKSApIHtcblx0XHRcdFx0XHRcdGlmICggY3VyLmluZGV4T2YoIFwiIFwiICsgY2xhenogKyBcIiBcIiApIDwgMCApIHtcblx0XHRcdFx0XHRcdFx0Y3VyICs9IGNsYXp6ICsgXCIgXCI7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0Ly8gT25seSBhc3NpZ24gaWYgZGlmZmVyZW50IHRvIGF2b2lkIHVubmVlZGVkIHJlbmRlcmluZy5cblx0XHRcdFx0XHRmaW5hbFZhbHVlID0gc3RyaXBBbmRDb2xsYXBzZSggY3VyICk7XG5cdFx0XHRcdFx0aWYgKCBjdXJWYWx1ZSAhPT0gZmluYWxWYWx1ZSApIHtcblx0XHRcdFx0XHRcdGVsZW0uc2V0QXR0cmlidXRlKCBcImNsYXNzXCIsIGZpbmFsVmFsdWUgKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblx0XHRyZXR1cm4gdGhpcztcblx0fSxcblxuXHRyZW1vdmVDbGFzczogZnVuY3Rpb24oIHZhbHVlICkge1xuXHRcdHZhciBjbGFzc2VzLCBlbGVtLCBjdXIsIGN1clZhbHVlLCBjbGF6eiwgaiwgZmluYWxWYWx1ZSxcblx0XHRcdGkgPSAwO1xuXG5cdFx0aWYgKCBpc0Z1bmN0aW9uKCB2YWx1ZSApICkge1xuXHRcdFx0cmV0dXJuIHRoaXMuZWFjaCggZnVuY3Rpb24oIGogKSB7XG5cdFx0XHRcdGpRdWVyeSggdGhpcyApLnJlbW92ZUNsYXNzKCB2YWx1ZS5jYWxsKCB0aGlzLCBqLCBnZXRDbGFzcyggdGhpcyApICkgKTtcblx0XHRcdH0gKTtcblx0XHR9XG5cblx0XHRpZiAoICFhcmd1bWVudHMubGVuZ3RoICkge1xuXHRcdFx0cmV0dXJuIHRoaXMuYXR0ciggXCJjbGFzc1wiLCBcIlwiICk7XG5cdFx0fVxuXG5cdFx0Y2xhc3NlcyA9IGNsYXNzZXNUb0FycmF5KCB2YWx1ZSApO1xuXG5cdFx0aWYgKCBjbGFzc2VzLmxlbmd0aCApIHtcblx0XHRcdHdoaWxlICggKCBlbGVtID0gdGhpc1sgaSsrIF0gKSApIHtcblx0XHRcdFx0Y3VyVmFsdWUgPSBnZXRDbGFzcyggZWxlbSApO1xuXG5cdFx0XHRcdC8vIFRoaXMgZXhwcmVzc2lvbiBpcyBoZXJlIGZvciBiZXR0ZXIgY29tcHJlc3NpYmlsaXR5IChzZWUgYWRkQ2xhc3MpXG5cdFx0XHRcdGN1ciA9IGVsZW0ubm9kZVR5cGUgPT09IDEgJiYgKCBcIiBcIiArIHN0cmlwQW5kQ29sbGFwc2UoIGN1clZhbHVlICkgKyBcIiBcIiApO1xuXG5cdFx0XHRcdGlmICggY3VyICkge1xuXHRcdFx0XHRcdGogPSAwO1xuXHRcdFx0XHRcdHdoaWxlICggKCBjbGF6eiA9IGNsYXNzZXNbIGorKyBdICkgKSB7XG5cblx0XHRcdFx0XHRcdC8vIFJlbW92ZSAqYWxsKiBpbnN0YW5jZXNcblx0XHRcdFx0XHRcdHdoaWxlICggY3VyLmluZGV4T2YoIFwiIFwiICsgY2xhenogKyBcIiBcIiApID4gLTEgKSB7XG5cdFx0XHRcdFx0XHRcdGN1ciA9IGN1ci5yZXBsYWNlKCBcIiBcIiArIGNsYXp6ICsgXCIgXCIsIFwiIFwiICk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0Ly8gT25seSBhc3NpZ24gaWYgZGlmZmVyZW50IHRvIGF2b2lkIHVubmVlZGVkIHJlbmRlcmluZy5cblx0XHRcdFx0XHRmaW5hbFZhbHVlID0gc3RyaXBBbmRDb2xsYXBzZSggY3VyICk7XG5cdFx0XHRcdFx0aWYgKCBjdXJWYWx1ZSAhPT0gZmluYWxWYWx1ZSApIHtcblx0XHRcdFx0XHRcdGVsZW0uc2V0QXR0cmlidXRlKCBcImNsYXNzXCIsIGZpbmFsVmFsdWUgKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblx0XHRyZXR1cm4gdGhpcztcblx0fSxcblxuXHR0b2dnbGVDbGFzczogZnVuY3Rpb24oIHZhbHVlLCBzdGF0ZVZhbCApIHtcblx0XHR2YXIgdHlwZSA9IHR5cGVvZiB2YWx1ZSxcblx0XHRcdGlzVmFsaWRWYWx1ZSA9IHR5cGUgPT09IFwic3RyaW5nXCIgfHwgQXJyYXkuaXNBcnJheSggdmFsdWUgKTtcblxuXHRcdGlmICggdHlwZW9mIHN0YXRlVmFsID09PSBcImJvb2xlYW5cIiAmJiBpc1ZhbGlkVmFsdWUgKSB7XG5cdFx0XHRyZXR1cm4gc3RhdGVWYWwgPyB0aGlzLmFkZENsYXNzKCB2YWx1ZSApIDogdGhpcy5yZW1vdmVDbGFzcyggdmFsdWUgKTtcblx0XHR9XG5cblx0XHRpZiAoIGlzRnVuY3Rpb24oIHZhbHVlICkgKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5lYWNoKCBmdW5jdGlvbiggaSApIHtcblx0XHRcdFx0alF1ZXJ5KCB0aGlzICkudG9nZ2xlQ2xhc3MoXG5cdFx0XHRcdFx0dmFsdWUuY2FsbCggdGhpcywgaSwgZ2V0Q2xhc3MoIHRoaXMgKSwgc3RhdGVWYWwgKSxcblx0XHRcdFx0XHRzdGF0ZVZhbFxuXHRcdFx0XHQpO1xuXHRcdFx0fSApO1xuXHRcdH1cblxuXHRcdHJldHVybiB0aGlzLmVhY2goIGZ1bmN0aW9uKCkge1xuXHRcdFx0dmFyIGNsYXNzTmFtZSwgaSwgc2VsZiwgY2xhc3NOYW1lcztcblxuXHRcdFx0aWYgKCBpc1ZhbGlkVmFsdWUgKSB7XG5cblx0XHRcdFx0Ly8gVG9nZ2xlIGluZGl2aWR1YWwgY2xhc3MgbmFtZXNcblx0XHRcdFx0aSA9IDA7XG5cdFx0XHRcdHNlbGYgPSBqUXVlcnkoIHRoaXMgKTtcblx0XHRcdFx0Y2xhc3NOYW1lcyA9IGNsYXNzZXNUb0FycmF5KCB2YWx1ZSApO1xuXG5cdFx0XHRcdHdoaWxlICggKCBjbGFzc05hbWUgPSBjbGFzc05hbWVzWyBpKysgXSApICkge1xuXG5cdFx0XHRcdFx0Ly8gQ2hlY2sgZWFjaCBjbGFzc05hbWUgZ2l2ZW4sIHNwYWNlIHNlcGFyYXRlZCBsaXN0XG5cdFx0XHRcdFx0aWYgKCBzZWxmLmhhc0NsYXNzKCBjbGFzc05hbWUgKSApIHtcblx0XHRcdFx0XHRcdHNlbGYucmVtb3ZlQ2xhc3MoIGNsYXNzTmFtZSApO1xuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRzZWxmLmFkZENsYXNzKCBjbGFzc05hbWUgKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblxuXHRcdFx0Ly8gVG9nZ2xlIHdob2xlIGNsYXNzIG5hbWVcblx0XHRcdH0gZWxzZSBpZiAoIHZhbHVlID09PSB1bmRlZmluZWQgfHwgdHlwZSA9PT0gXCJib29sZWFuXCIgKSB7XG5cdFx0XHRcdGNsYXNzTmFtZSA9IGdldENsYXNzKCB0aGlzICk7XG5cdFx0XHRcdGlmICggY2xhc3NOYW1lICkge1xuXG5cdFx0XHRcdFx0Ly8gU3RvcmUgY2xhc3NOYW1lIGlmIHNldFxuXHRcdFx0XHRcdGRhdGFQcml2LnNldCggdGhpcywgXCJfX2NsYXNzTmFtZV9fXCIsIGNsYXNzTmFtZSApO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gSWYgdGhlIGVsZW1lbnQgaGFzIGEgY2xhc3MgbmFtZSBvciBpZiB3ZSdyZSBwYXNzZWQgYGZhbHNlYCxcblx0XHRcdFx0Ly8gdGhlbiByZW1vdmUgdGhlIHdob2xlIGNsYXNzbmFtZSAoaWYgdGhlcmUgd2FzIG9uZSwgdGhlIGFib3ZlIHNhdmVkIGl0KS5cblx0XHRcdFx0Ly8gT3RoZXJ3aXNlIGJyaW5nIGJhY2sgd2hhdGV2ZXIgd2FzIHByZXZpb3VzbHkgc2F2ZWQgKGlmIGFueXRoaW5nKSxcblx0XHRcdFx0Ly8gZmFsbGluZyBiYWNrIHRvIHRoZSBlbXB0eSBzdHJpbmcgaWYgbm90aGluZyB3YXMgc3RvcmVkLlxuXHRcdFx0XHRpZiAoIHRoaXMuc2V0QXR0cmlidXRlICkge1xuXHRcdFx0XHRcdHRoaXMuc2V0QXR0cmlidXRlKCBcImNsYXNzXCIsXG5cdFx0XHRcdFx0XHRjbGFzc05hbWUgfHwgdmFsdWUgPT09IGZhbHNlID9cblx0XHRcdFx0XHRcdFwiXCIgOlxuXHRcdFx0XHRcdFx0ZGF0YVByaXYuZ2V0KCB0aGlzLCBcIl9fY2xhc3NOYW1lX19cIiApIHx8IFwiXCJcblx0XHRcdFx0XHQpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fSApO1xuXHR9LFxuXG5cdGhhc0NsYXNzOiBmdW5jdGlvbiggc2VsZWN0b3IgKSB7XG5cdFx0dmFyIGNsYXNzTmFtZSwgZWxlbSxcblx0XHRcdGkgPSAwO1xuXG5cdFx0Y2xhc3NOYW1lID0gXCIgXCIgKyBzZWxlY3RvciArIFwiIFwiO1xuXHRcdHdoaWxlICggKCBlbGVtID0gdGhpc1sgaSsrIF0gKSApIHtcblx0XHRcdGlmICggZWxlbS5ub2RlVHlwZSA9PT0gMSAmJlxuXHRcdFx0XHQoIFwiIFwiICsgc3RyaXBBbmRDb2xsYXBzZSggZ2V0Q2xhc3MoIGVsZW0gKSApICsgXCIgXCIgKS5pbmRleE9mKCBjbGFzc05hbWUgKSA+IC0xICkge1xuXHRcdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHJldHVybiBmYWxzZTtcblx0fVxufSApO1xuXG5cblxuXG52YXIgcnJldHVybiA9IC9cXHIvZztcblxualF1ZXJ5LmZuLmV4dGVuZCgge1xuXHR2YWw6IGZ1bmN0aW9uKCB2YWx1ZSApIHtcblx0XHR2YXIgaG9va3MsIHJldCwgdmFsdWVJc0Z1bmN0aW9uLFxuXHRcdFx0ZWxlbSA9IHRoaXNbIDAgXTtcblxuXHRcdGlmICggIWFyZ3VtZW50cy5sZW5ndGggKSB7XG5cdFx0XHRpZiAoIGVsZW0gKSB7XG5cdFx0XHRcdGhvb2tzID0galF1ZXJ5LnZhbEhvb2tzWyBlbGVtLnR5cGUgXSB8fFxuXHRcdFx0XHRcdGpRdWVyeS52YWxIb29rc1sgZWxlbS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpIF07XG5cblx0XHRcdFx0aWYgKCBob29rcyAmJlxuXHRcdFx0XHRcdFwiZ2V0XCIgaW4gaG9va3MgJiZcblx0XHRcdFx0XHQoIHJldCA9IGhvb2tzLmdldCggZWxlbSwgXCJ2YWx1ZVwiICkgKSAhPT0gdW5kZWZpbmVkXG5cdFx0XHRcdCkge1xuXHRcdFx0XHRcdHJldHVybiByZXQ7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRyZXQgPSBlbGVtLnZhbHVlO1xuXG5cdFx0XHRcdC8vIEhhbmRsZSBtb3N0IGNvbW1vbiBzdHJpbmcgY2FzZXNcblx0XHRcdFx0aWYgKCB0eXBlb2YgcmV0ID09PSBcInN0cmluZ1wiICkge1xuXHRcdFx0XHRcdHJldHVybiByZXQucmVwbGFjZSggcnJldHVybiwgXCJcIiApO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gSGFuZGxlIGNhc2VzIHdoZXJlIHZhbHVlIGlzIG51bGwvdW5kZWYgb3IgbnVtYmVyXG5cdFx0XHRcdHJldHVybiByZXQgPT0gbnVsbCA/IFwiXCIgOiByZXQ7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHR2YWx1ZUlzRnVuY3Rpb24gPSBpc0Z1bmN0aW9uKCB2YWx1ZSApO1xuXG5cdFx0cmV0dXJuIHRoaXMuZWFjaCggZnVuY3Rpb24oIGkgKSB7XG5cdFx0XHR2YXIgdmFsO1xuXG5cdFx0XHRpZiAoIHRoaXMubm9kZVR5cGUgIT09IDEgKSB7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblxuXHRcdFx0aWYgKCB2YWx1ZUlzRnVuY3Rpb24gKSB7XG5cdFx0XHRcdHZhbCA9IHZhbHVlLmNhbGwoIHRoaXMsIGksIGpRdWVyeSggdGhpcyApLnZhbCgpICk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR2YWwgPSB2YWx1ZTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gVHJlYXQgbnVsbC91bmRlZmluZWQgYXMgXCJcIjsgY29udmVydCBudW1iZXJzIHRvIHN0cmluZ1xuXHRcdFx0aWYgKCB2YWwgPT0gbnVsbCApIHtcblx0XHRcdFx0dmFsID0gXCJcIjtcblxuXHRcdFx0fSBlbHNlIGlmICggdHlwZW9mIHZhbCA9PT0gXCJudW1iZXJcIiApIHtcblx0XHRcdFx0dmFsICs9IFwiXCI7XG5cblx0XHRcdH0gZWxzZSBpZiAoIEFycmF5LmlzQXJyYXkoIHZhbCApICkge1xuXHRcdFx0XHR2YWwgPSBqUXVlcnkubWFwKCB2YWwsIGZ1bmN0aW9uKCB2YWx1ZSApIHtcblx0XHRcdFx0XHRyZXR1cm4gdmFsdWUgPT0gbnVsbCA/IFwiXCIgOiB2YWx1ZSArIFwiXCI7XG5cdFx0XHRcdH0gKTtcblx0XHRcdH1cblxuXHRcdFx0aG9va3MgPSBqUXVlcnkudmFsSG9va3NbIHRoaXMudHlwZSBdIHx8IGpRdWVyeS52YWxIb29rc1sgdGhpcy5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpIF07XG5cblx0XHRcdC8vIElmIHNldCByZXR1cm5zIHVuZGVmaW5lZCwgZmFsbCBiYWNrIHRvIG5vcm1hbCBzZXR0aW5nXG5cdFx0XHRpZiAoICFob29rcyB8fCAhKCBcInNldFwiIGluIGhvb2tzICkgfHwgaG9va3Muc2V0KCB0aGlzLCB2YWwsIFwidmFsdWVcIiApID09PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRcdHRoaXMudmFsdWUgPSB2YWw7XG5cdFx0XHR9XG5cdFx0fSApO1xuXHR9XG59ICk7XG5cbmpRdWVyeS5leHRlbmQoIHtcblx0dmFsSG9va3M6IHtcblx0XHRvcHRpb246IHtcblx0XHRcdGdldDogZnVuY3Rpb24oIGVsZW0gKSB7XG5cblx0XHRcdFx0dmFyIHZhbCA9IGpRdWVyeS5maW5kLmF0dHIoIGVsZW0sIFwidmFsdWVcIiApO1xuXHRcdFx0XHRyZXR1cm4gdmFsICE9IG51bGwgP1xuXHRcdFx0XHRcdHZhbCA6XG5cblx0XHRcdFx0XHQvLyBTdXBwb3J0OiBJRSA8PTEwIC0gMTEgb25seVxuXHRcdFx0XHRcdC8vIG9wdGlvbi50ZXh0IHRocm93cyBleGNlcHRpb25zICgjMTQ2ODYsICMxNDg1OClcblx0XHRcdFx0XHQvLyBTdHJpcCBhbmQgY29sbGFwc2Ugd2hpdGVzcGFjZVxuXHRcdFx0XHRcdC8vIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvI3N0cmlwLWFuZC1jb2xsYXBzZS13aGl0ZXNwYWNlXG5cdFx0XHRcdFx0c3RyaXBBbmRDb2xsYXBzZSggalF1ZXJ5LnRleHQoIGVsZW0gKSApO1xuXHRcdFx0fVxuXHRcdH0sXG5cdFx0c2VsZWN0OiB7XG5cdFx0XHRnZXQ6IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0XHR2YXIgdmFsdWUsIG9wdGlvbiwgaSxcblx0XHRcdFx0XHRvcHRpb25zID0gZWxlbS5vcHRpb25zLFxuXHRcdFx0XHRcdGluZGV4ID0gZWxlbS5zZWxlY3RlZEluZGV4LFxuXHRcdFx0XHRcdG9uZSA9IGVsZW0udHlwZSA9PT0gXCJzZWxlY3Qtb25lXCIsXG5cdFx0XHRcdFx0dmFsdWVzID0gb25lID8gbnVsbCA6IFtdLFxuXHRcdFx0XHRcdG1heCA9IG9uZSA/IGluZGV4ICsgMSA6IG9wdGlvbnMubGVuZ3RoO1xuXG5cdFx0XHRcdGlmICggaW5kZXggPCAwICkge1xuXHRcdFx0XHRcdGkgPSBtYXg7XG5cblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRpID0gb25lID8gaW5kZXggOiAwO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gTG9vcCB0aHJvdWdoIGFsbCB0aGUgc2VsZWN0ZWQgb3B0aW9uc1xuXHRcdFx0XHRmb3IgKCA7IGkgPCBtYXg7IGkrKyApIHtcblx0XHRcdFx0XHRvcHRpb24gPSBvcHRpb25zWyBpIF07XG5cblx0XHRcdFx0XHQvLyBTdXBwb3J0OiBJRSA8PTkgb25seVxuXHRcdFx0XHRcdC8vIElFOC05IGRvZXNuJ3QgdXBkYXRlIHNlbGVjdGVkIGFmdGVyIGZvcm0gcmVzZXQgKCMyNTUxKVxuXHRcdFx0XHRcdGlmICggKCBvcHRpb24uc2VsZWN0ZWQgfHwgaSA9PT0gaW5kZXggKSAmJlxuXG5cdFx0XHRcdFx0XHRcdC8vIERvbid0IHJldHVybiBvcHRpb25zIHRoYXQgYXJlIGRpc2FibGVkIG9yIGluIGEgZGlzYWJsZWQgb3B0Z3JvdXBcblx0XHRcdFx0XHRcdFx0IW9wdGlvbi5kaXNhYmxlZCAmJlxuXHRcdFx0XHRcdFx0XHQoICFvcHRpb24ucGFyZW50Tm9kZS5kaXNhYmxlZCB8fFxuXHRcdFx0XHRcdFx0XHRcdCFub2RlTmFtZSggb3B0aW9uLnBhcmVudE5vZGUsIFwib3B0Z3JvdXBcIiApICkgKSB7XG5cblx0XHRcdFx0XHRcdC8vIEdldCB0aGUgc3BlY2lmaWMgdmFsdWUgZm9yIHRoZSBvcHRpb25cblx0XHRcdFx0XHRcdHZhbHVlID0galF1ZXJ5KCBvcHRpb24gKS52YWwoKTtcblxuXHRcdFx0XHRcdFx0Ly8gV2UgZG9uJ3QgbmVlZCBhbiBhcnJheSBmb3Igb25lIHNlbGVjdHNcblx0XHRcdFx0XHRcdGlmICggb25lICkge1xuXHRcdFx0XHRcdFx0XHRyZXR1cm4gdmFsdWU7XG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdC8vIE11bHRpLVNlbGVjdHMgcmV0dXJuIGFuIGFycmF5XG5cdFx0XHRcdFx0XHR2YWx1ZXMucHVzaCggdmFsdWUgKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRyZXR1cm4gdmFsdWVzO1xuXHRcdFx0fSxcblxuXHRcdFx0c2V0OiBmdW5jdGlvbiggZWxlbSwgdmFsdWUgKSB7XG5cdFx0XHRcdHZhciBvcHRpb25TZXQsIG9wdGlvbixcblx0XHRcdFx0XHRvcHRpb25zID0gZWxlbS5vcHRpb25zLFxuXHRcdFx0XHRcdHZhbHVlcyA9IGpRdWVyeS5tYWtlQXJyYXkoIHZhbHVlICksXG5cdFx0XHRcdFx0aSA9IG9wdGlvbnMubGVuZ3RoO1xuXG5cdFx0XHRcdHdoaWxlICggaS0tICkge1xuXHRcdFx0XHRcdG9wdGlvbiA9IG9wdGlvbnNbIGkgXTtcblxuXHRcdFx0XHRcdC8qIGVzbGludC1kaXNhYmxlIG5vLWNvbmQtYXNzaWduICovXG5cblx0XHRcdFx0XHRpZiAoIG9wdGlvbi5zZWxlY3RlZCA9XG5cdFx0XHRcdFx0XHRqUXVlcnkuaW5BcnJheSggalF1ZXJ5LnZhbEhvb2tzLm9wdGlvbi5nZXQoIG9wdGlvbiApLCB2YWx1ZXMgKSA+IC0xXG5cdFx0XHRcdFx0KSB7XG5cdFx0XHRcdFx0XHRvcHRpb25TZXQgPSB0cnVlO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdC8qIGVzbGludC1lbmFibGUgbm8tY29uZC1hc3NpZ24gKi9cblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIEZvcmNlIGJyb3dzZXJzIHRvIGJlaGF2ZSBjb25zaXN0ZW50bHkgd2hlbiBub24tbWF0Y2hpbmcgdmFsdWUgaXMgc2V0XG5cdFx0XHRcdGlmICggIW9wdGlvblNldCApIHtcblx0XHRcdFx0XHRlbGVtLnNlbGVjdGVkSW5kZXggPSAtMTtcblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gdmFsdWVzO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxufSApO1xuXG4vLyBSYWRpb3MgYW5kIGNoZWNrYm94ZXMgZ2V0dGVyL3NldHRlclxualF1ZXJ5LmVhY2goIFsgXCJyYWRpb1wiLCBcImNoZWNrYm94XCIgXSwgZnVuY3Rpb24oKSB7XG5cdGpRdWVyeS52YWxIb29rc1sgdGhpcyBdID0ge1xuXHRcdHNldDogZnVuY3Rpb24oIGVsZW0sIHZhbHVlICkge1xuXHRcdFx0aWYgKCBBcnJheS5pc0FycmF5KCB2YWx1ZSApICkge1xuXHRcdFx0XHRyZXR1cm4gKCBlbGVtLmNoZWNrZWQgPSBqUXVlcnkuaW5BcnJheSggalF1ZXJ5KCBlbGVtICkudmFsKCksIHZhbHVlICkgPiAtMSApO1xuXHRcdFx0fVxuXHRcdH1cblx0fTtcblx0aWYgKCAhc3VwcG9ydC5jaGVja09uICkge1xuXHRcdGpRdWVyeS52YWxIb29rc1sgdGhpcyBdLmdldCA9IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0cmV0dXJuIGVsZW0uZ2V0QXR0cmlidXRlKCBcInZhbHVlXCIgKSA9PT0gbnVsbCA/IFwib25cIiA6IGVsZW0udmFsdWU7XG5cdFx0fTtcblx0fVxufSApO1xuXG5cblxuXG4vLyBSZXR1cm4galF1ZXJ5IGZvciBhdHRyaWJ1dGVzLW9ubHkgaW5jbHVzaW9uXG5cblxuc3VwcG9ydC5mb2N1c2luID0gXCJvbmZvY3VzaW5cIiBpbiB3aW5kb3c7XG5cblxudmFyIHJmb2N1c01vcnBoID0gL14oPzpmb2N1c2luZm9jdXN8Zm9jdXNvdXRibHVyKSQvLFxuXHRzdG9wUHJvcGFnYXRpb25DYWxsYmFjayA9IGZ1bmN0aW9uKCBlICkge1xuXHRcdGUuc3RvcFByb3BhZ2F0aW9uKCk7XG5cdH07XG5cbmpRdWVyeS5leHRlbmQoIGpRdWVyeS5ldmVudCwge1xuXG5cdHRyaWdnZXI6IGZ1bmN0aW9uKCBldmVudCwgZGF0YSwgZWxlbSwgb25seUhhbmRsZXJzICkge1xuXG5cdFx0dmFyIGksIGN1ciwgdG1wLCBidWJibGVUeXBlLCBvbnR5cGUsIGhhbmRsZSwgc3BlY2lhbCwgbGFzdEVsZW1lbnQsXG5cdFx0XHRldmVudFBhdGggPSBbIGVsZW0gfHwgZG9jdW1lbnQgXSxcblx0XHRcdHR5cGUgPSBoYXNPd24uY2FsbCggZXZlbnQsIFwidHlwZVwiICkgPyBldmVudC50eXBlIDogZXZlbnQsXG5cdFx0XHRuYW1lc3BhY2VzID0gaGFzT3duLmNhbGwoIGV2ZW50LCBcIm5hbWVzcGFjZVwiICkgPyBldmVudC5uYW1lc3BhY2Uuc3BsaXQoIFwiLlwiICkgOiBbXTtcblxuXHRcdGN1ciA9IGxhc3RFbGVtZW50ID0gdG1wID0gZWxlbSA9IGVsZW0gfHwgZG9jdW1lbnQ7XG5cblx0XHQvLyBEb24ndCBkbyBldmVudHMgb24gdGV4dCBhbmQgY29tbWVudCBub2Rlc1xuXHRcdGlmICggZWxlbS5ub2RlVHlwZSA9PT0gMyB8fCBlbGVtLm5vZGVUeXBlID09PSA4ICkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdC8vIGZvY3VzL2JsdXIgbW9ycGhzIHRvIGZvY3VzaW4vb3V0OyBlbnN1cmUgd2UncmUgbm90IGZpcmluZyB0aGVtIHJpZ2h0IG5vd1xuXHRcdGlmICggcmZvY3VzTW9ycGgudGVzdCggdHlwZSArIGpRdWVyeS5ldmVudC50cmlnZ2VyZWQgKSApIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHRpZiAoIHR5cGUuaW5kZXhPZiggXCIuXCIgKSA+IC0xICkge1xuXG5cdFx0XHQvLyBOYW1lc3BhY2VkIHRyaWdnZXI7IGNyZWF0ZSBhIHJlZ2V4cCB0byBtYXRjaCBldmVudCB0eXBlIGluIGhhbmRsZSgpXG5cdFx0XHRuYW1lc3BhY2VzID0gdHlwZS5zcGxpdCggXCIuXCIgKTtcblx0XHRcdHR5cGUgPSBuYW1lc3BhY2VzLnNoaWZ0KCk7XG5cdFx0XHRuYW1lc3BhY2VzLnNvcnQoKTtcblx0XHR9XG5cdFx0b250eXBlID0gdHlwZS5pbmRleE9mKCBcIjpcIiApIDwgMCAmJiBcIm9uXCIgKyB0eXBlO1xuXG5cdFx0Ly8gQ2FsbGVyIGNhbiBwYXNzIGluIGEgalF1ZXJ5LkV2ZW50IG9iamVjdCwgT2JqZWN0LCBvciBqdXN0IGFuIGV2ZW50IHR5cGUgc3RyaW5nXG5cdFx0ZXZlbnQgPSBldmVudFsgalF1ZXJ5LmV4cGFuZG8gXSA/XG5cdFx0XHRldmVudCA6XG5cdFx0XHRuZXcgalF1ZXJ5LkV2ZW50KCB0eXBlLCB0eXBlb2YgZXZlbnQgPT09IFwib2JqZWN0XCIgJiYgZXZlbnQgKTtcblxuXHRcdC8vIFRyaWdnZXIgYml0bWFzazogJiAxIGZvciBuYXRpdmUgaGFuZGxlcnM7ICYgMiBmb3IgalF1ZXJ5IChhbHdheXMgdHJ1ZSlcblx0XHRldmVudC5pc1RyaWdnZXIgPSBvbmx5SGFuZGxlcnMgPyAyIDogMztcblx0XHRldmVudC5uYW1lc3BhY2UgPSBuYW1lc3BhY2VzLmpvaW4oIFwiLlwiICk7XG5cdFx0ZXZlbnQucm5hbWVzcGFjZSA9IGV2ZW50Lm5hbWVzcGFjZSA/XG5cdFx0XHRuZXcgUmVnRXhwKCBcIihefFxcXFwuKVwiICsgbmFtZXNwYWNlcy5qb2luKCBcIlxcXFwuKD86LipcXFxcLnwpXCIgKSArIFwiKFxcXFwufCQpXCIgKSA6XG5cdFx0XHRudWxsO1xuXG5cdFx0Ly8gQ2xlYW4gdXAgdGhlIGV2ZW50IGluIGNhc2UgaXQgaXMgYmVpbmcgcmV1c2VkXG5cdFx0ZXZlbnQucmVzdWx0ID0gdW5kZWZpbmVkO1xuXHRcdGlmICggIWV2ZW50LnRhcmdldCApIHtcblx0XHRcdGV2ZW50LnRhcmdldCA9IGVsZW07XG5cdFx0fVxuXG5cdFx0Ly8gQ2xvbmUgYW55IGluY29taW5nIGRhdGEgYW5kIHByZXBlbmQgdGhlIGV2ZW50LCBjcmVhdGluZyB0aGUgaGFuZGxlciBhcmcgbGlzdFxuXHRcdGRhdGEgPSBkYXRhID09IG51bGwgP1xuXHRcdFx0WyBldmVudCBdIDpcblx0XHRcdGpRdWVyeS5tYWtlQXJyYXkoIGRhdGEsIFsgZXZlbnQgXSApO1xuXG5cdFx0Ly8gQWxsb3cgc3BlY2lhbCBldmVudHMgdG8gZHJhdyBvdXRzaWRlIHRoZSBsaW5lc1xuXHRcdHNwZWNpYWwgPSBqUXVlcnkuZXZlbnQuc3BlY2lhbFsgdHlwZSBdIHx8IHt9O1xuXHRcdGlmICggIW9ubHlIYW5kbGVycyAmJiBzcGVjaWFsLnRyaWdnZXIgJiYgc3BlY2lhbC50cmlnZ2VyLmFwcGx5KCBlbGVtLCBkYXRhICkgPT09IGZhbHNlICkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdC8vIERldGVybWluZSBldmVudCBwcm9wYWdhdGlvbiBwYXRoIGluIGFkdmFuY2UsIHBlciBXM0MgZXZlbnRzIHNwZWMgKCM5OTUxKVxuXHRcdC8vIEJ1YmJsZSB1cCB0byBkb2N1bWVudCwgdGhlbiB0byB3aW5kb3c7IHdhdGNoIGZvciBhIGdsb2JhbCBvd25lckRvY3VtZW50IHZhciAoIzk3MjQpXG5cdFx0aWYgKCAhb25seUhhbmRsZXJzICYmICFzcGVjaWFsLm5vQnViYmxlICYmICFpc1dpbmRvdyggZWxlbSApICkge1xuXG5cdFx0XHRidWJibGVUeXBlID0gc3BlY2lhbC5kZWxlZ2F0ZVR5cGUgfHwgdHlwZTtcblx0XHRcdGlmICggIXJmb2N1c01vcnBoLnRlc3QoIGJ1YmJsZVR5cGUgKyB0eXBlICkgKSB7XG5cdFx0XHRcdGN1ciA9IGN1ci5wYXJlbnROb2RlO1xuXHRcdFx0fVxuXHRcdFx0Zm9yICggOyBjdXI7IGN1ciA9IGN1ci5wYXJlbnROb2RlICkge1xuXHRcdFx0XHRldmVudFBhdGgucHVzaCggY3VyICk7XG5cdFx0XHRcdHRtcCA9IGN1cjtcblx0XHRcdH1cblxuXHRcdFx0Ly8gT25seSBhZGQgd2luZG93IGlmIHdlIGdvdCB0byBkb2N1bWVudCAoZS5nLiwgbm90IHBsYWluIG9iaiBvciBkZXRhY2hlZCBET00pXG5cdFx0XHRpZiAoIHRtcCA9PT0gKCBlbGVtLm93bmVyRG9jdW1lbnQgfHwgZG9jdW1lbnQgKSApIHtcblx0XHRcdFx0ZXZlbnRQYXRoLnB1c2goIHRtcC5kZWZhdWx0VmlldyB8fCB0bXAucGFyZW50V2luZG93IHx8IHdpbmRvdyApO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIEZpcmUgaGFuZGxlcnMgb24gdGhlIGV2ZW50IHBhdGhcblx0XHRpID0gMDtcblx0XHR3aGlsZSAoICggY3VyID0gZXZlbnRQYXRoWyBpKysgXSApICYmICFldmVudC5pc1Byb3BhZ2F0aW9uU3RvcHBlZCgpICkge1xuXHRcdFx0bGFzdEVsZW1lbnQgPSBjdXI7XG5cdFx0XHRldmVudC50eXBlID0gaSA+IDEgP1xuXHRcdFx0XHRidWJibGVUeXBlIDpcblx0XHRcdFx0c3BlY2lhbC5iaW5kVHlwZSB8fCB0eXBlO1xuXG5cdFx0XHQvLyBqUXVlcnkgaGFuZGxlclxuXHRcdFx0aGFuZGxlID0gKCBkYXRhUHJpdi5nZXQoIGN1ciwgXCJldmVudHNcIiApIHx8IHt9IClbIGV2ZW50LnR5cGUgXSAmJlxuXHRcdFx0XHRkYXRhUHJpdi5nZXQoIGN1ciwgXCJoYW5kbGVcIiApO1xuXHRcdFx0aWYgKCBoYW5kbGUgKSB7XG5cdFx0XHRcdGhhbmRsZS5hcHBseSggY3VyLCBkYXRhICk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIE5hdGl2ZSBoYW5kbGVyXG5cdFx0XHRoYW5kbGUgPSBvbnR5cGUgJiYgY3VyWyBvbnR5cGUgXTtcblx0XHRcdGlmICggaGFuZGxlICYmIGhhbmRsZS5hcHBseSAmJiBhY2NlcHREYXRhKCBjdXIgKSApIHtcblx0XHRcdFx0ZXZlbnQucmVzdWx0ID0gaGFuZGxlLmFwcGx5KCBjdXIsIGRhdGEgKTtcblx0XHRcdFx0aWYgKCBldmVudC5yZXN1bHQgPT09IGZhbHNlICkge1xuXHRcdFx0XHRcdGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdFx0ZXZlbnQudHlwZSA9IHR5cGU7XG5cblx0XHQvLyBJZiBub2JvZHkgcHJldmVudGVkIHRoZSBkZWZhdWx0IGFjdGlvbiwgZG8gaXQgbm93XG5cdFx0aWYgKCAhb25seUhhbmRsZXJzICYmICFldmVudC5pc0RlZmF1bHRQcmV2ZW50ZWQoKSApIHtcblxuXHRcdFx0aWYgKCAoICFzcGVjaWFsLl9kZWZhdWx0IHx8XG5cdFx0XHRcdHNwZWNpYWwuX2RlZmF1bHQuYXBwbHkoIGV2ZW50UGF0aC5wb3AoKSwgZGF0YSApID09PSBmYWxzZSApICYmXG5cdFx0XHRcdGFjY2VwdERhdGEoIGVsZW0gKSApIHtcblxuXHRcdFx0XHQvLyBDYWxsIGEgbmF0aXZlIERPTSBtZXRob2Qgb24gdGhlIHRhcmdldCB3aXRoIHRoZSBzYW1lIG5hbWUgYXMgdGhlIGV2ZW50LlxuXHRcdFx0XHQvLyBEb24ndCBkbyBkZWZhdWx0IGFjdGlvbnMgb24gd2luZG93LCB0aGF0J3Mgd2hlcmUgZ2xvYmFsIHZhcmlhYmxlcyBiZSAoIzYxNzApXG5cdFx0XHRcdGlmICggb250eXBlICYmIGlzRnVuY3Rpb24oIGVsZW1bIHR5cGUgXSApICYmICFpc1dpbmRvdyggZWxlbSApICkge1xuXG5cdFx0XHRcdFx0Ly8gRG9uJ3QgcmUtdHJpZ2dlciBhbiBvbkZPTyBldmVudCB3aGVuIHdlIGNhbGwgaXRzIEZPTygpIG1ldGhvZFxuXHRcdFx0XHRcdHRtcCA9IGVsZW1bIG9udHlwZSBdO1xuXG5cdFx0XHRcdFx0aWYgKCB0bXAgKSB7XG5cdFx0XHRcdFx0XHRlbGVtWyBvbnR5cGUgXSA9IG51bGw7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0Ly8gUHJldmVudCByZS10cmlnZ2VyaW5nIG9mIHRoZSBzYW1lIGV2ZW50LCBzaW5jZSB3ZSBhbHJlYWR5IGJ1YmJsZWQgaXQgYWJvdmVcblx0XHRcdFx0XHRqUXVlcnkuZXZlbnQudHJpZ2dlcmVkID0gdHlwZTtcblxuXHRcdFx0XHRcdGlmICggZXZlbnQuaXNQcm9wYWdhdGlvblN0b3BwZWQoKSApIHtcblx0XHRcdFx0XHRcdGxhc3RFbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoIHR5cGUsIHN0b3BQcm9wYWdhdGlvbkNhbGxiYWNrICk7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0ZWxlbVsgdHlwZSBdKCk7XG5cblx0XHRcdFx0XHRpZiAoIGV2ZW50LmlzUHJvcGFnYXRpb25TdG9wcGVkKCkgKSB7XG5cdFx0XHRcdFx0XHRsYXN0RWxlbWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCB0eXBlLCBzdG9wUHJvcGFnYXRpb25DYWxsYmFjayApO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdGpRdWVyeS5ldmVudC50cmlnZ2VyZWQgPSB1bmRlZmluZWQ7XG5cblx0XHRcdFx0XHRpZiAoIHRtcCApIHtcblx0XHRcdFx0XHRcdGVsZW1bIG9udHlwZSBdID0gdG1wO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHJldHVybiBldmVudC5yZXN1bHQ7XG5cdH0sXG5cblx0Ly8gUGlnZ3liYWNrIG9uIGEgZG9ub3IgZXZlbnQgdG8gc2ltdWxhdGUgYSBkaWZmZXJlbnQgb25lXG5cdC8vIFVzZWQgb25seSBmb3IgYGZvY3VzKGluIHwgb3V0KWAgZXZlbnRzXG5cdHNpbXVsYXRlOiBmdW5jdGlvbiggdHlwZSwgZWxlbSwgZXZlbnQgKSB7XG5cdFx0dmFyIGUgPSBqUXVlcnkuZXh0ZW5kKFxuXHRcdFx0bmV3IGpRdWVyeS5FdmVudCgpLFxuXHRcdFx0ZXZlbnQsXG5cdFx0XHR7XG5cdFx0XHRcdHR5cGU6IHR5cGUsXG5cdFx0XHRcdGlzU2ltdWxhdGVkOiB0cnVlXG5cdFx0XHR9XG5cdFx0KTtcblxuXHRcdGpRdWVyeS5ldmVudC50cmlnZ2VyKCBlLCBudWxsLCBlbGVtICk7XG5cdH1cblxufSApO1xuXG5qUXVlcnkuZm4uZXh0ZW5kKCB7XG5cblx0dHJpZ2dlcjogZnVuY3Rpb24oIHR5cGUsIGRhdGEgKSB7XG5cdFx0cmV0dXJuIHRoaXMuZWFjaCggZnVuY3Rpb24oKSB7XG5cdFx0XHRqUXVlcnkuZXZlbnQudHJpZ2dlciggdHlwZSwgZGF0YSwgdGhpcyApO1xuXHRcdH0gKTtcblx0fSxcblx0dHJpZ2dlckhhbmRsZXI6IGZ1bmN0aW9uKCB0eXBlLCBkYXRhICkge1xuXHRcdHZhciBlbGVtID0gdGhpc1sgMCBdO1xuXHRcdGlmICggZWxlbSApIHtcblx0XHRcdHJldHVybiBqUXVlcnkuZXZlbnQudHJpZ2dlciggdHlwZSwgZGF0YSwgZWxlbSwgdHJ1ZSApO1xuXHRcdH1cblx0fVxufSApO1xuXG5cbi8vIFN1cHBvcnQ6IEZpcmVmb3ggPD00NFxuLy8gRmlyZWZveCBkb2Vzbid0IGhhdmUgZm9jdXMoaW4gfCBvdXQpIGV2ZW50c1xuLy8gUmVsYXRlZCB0aWNrZXQgLSBodHRwczovL2J1Z3ppbGxhLm1vemlsbGEub3JnL3Nob3dfYnVnLmNnaT9pZD02ODc3ODdcbi8vXG4vLyBTdXBwb3J0OiBDaHJvbWUgPD00OCAtIDQ5LCBTYWZhcmkgPD05LjAgLSA5LjFcbi8vIGZvY3VzKGluIHwgb3V0KSBldmVudHMgZmlyZSBhZnRlciBmb2N1cyAmIGJsdXIgZXZlbnRzLFxuLy8gd2hpY2ggaXMgc3BlYyB2aW9sYXRpb24gLSBodHRwOi8vd3d3LnczLm9yZy9UUi9ET00tTGV2ZWwtMy1FdmVudHMvI2V2ZW50cy1mb2N1c2V2ZW50LWV2ZW50LW9yZGVyXG4vLyBSZWxhdGVkIHRpY2tldCAtIGh0dHBzOi8vYnVncy5jaHJvbWl1bS5vcmcvcC9jaHJvbWl1bS9pc3N1ZXMvZGV0YWlsP2lkPTQ0OTg1N1xuaWYgKCAhc3VwcG9ydC5mb2N1c2luICkge1xuXHRqUXVlcnkuZWFjaCggeyBmb2N1czogXCJmb2N1c2luXCIsIGJsdXI6IFwiZm9jdXNvdXRcIiB9LCBmdW5jdGlvbiggb3JpZywgZml4ICkge1xuXG5cdFx0Ly8gQXR0YWNoIGEgc2luZ2xlIGNhcHR1cmluZyBoYW5kbGVyIG9uIHRoZSBkb2N1bWVudCB3aGlsZSBzb21lb25lIHdhbnRzIGZvY3VzaW4vZm9jdXNvdXRcblx0XHR2YXIgaGFuZGxlciA9IGZ1bmN0aW9uKCBldmVudCApIHtcblx0XHRcdGpRdWVyeS5ldmVudC5zaW11bGF0ZSggZml4LCBldmVudC50YXJnZXQsIGpRdWVyeS5ldmVudC5maXgoIGV2ZW50ICkgKTtcblx0XHR9O1xuXG5cdFx0alF1ZXJ5LmV2ZW50LnNwZWNpYWxbIGZpeCBdID0ge1xuXHRcdFx0c2V0dXA6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHR2YXIgZG9jID0gdGhpcy5vd25lckRvY3VtZW50IHx8IHRoaXMsXG5cdFx0XHRcdFx0YXR0YWNoZXMgPSBkYXRhUHJpdi5hY2Nlc3MoIGRvYywgZml4ICk7XG5cblx0XHRcdFx0aWYgKCAhYXR0YWNoZXMgKSB7XG5cdFx0XHRcdFx0ZG9jLmFkZEV2ZW50TGlzdGVuZXIoIG9yaWcsIGhhbmRsZXIsIHRydWUgKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRkYXRhUHJpdi5hY2Nlc3MoIGRvYywgZml4LCAoIGF0dGFjaGVzIHx8IDAgKSArIDEgKTtcblx0XHRcdH0sXG5cdFx0XHR0ZWFyZG93bjogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHZhciBkb2MgPSB0aGlzLm93bmVyRG9jdW1lbnQgfHwgdGhpcyxcblx0XHRcdFx0XHRhdHRhY2hlcyA9IGRhdGFQcml2LmFjY2VzcyggZG9jLCBmaXggKSAtIDE7XG5cblx0XHRcdFx0aWYgKCAhYXR0YWNoZXMgKSB7XG5cdFx0XHRcdFx0ZG9jLnJlbW92ZUV2ZW50TGlzdGVuZXIoIG9yaWcsIGhhbmRsZXIsIHRydWUgKTtcblx0XHRcdFx0XHRkYXRhUHJpdi5yZW1vdmUoIGRvYywgZml4ICk7XG5cblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRkYXRhUHJpdi5hY2Nlc3MoIGRvYywgZml4LCBhdHRhY2hlcyApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fTtcblx0fSApO1xufVxudmFyIGxvY2F0aW9uID0gd2luZG93LmxvY2F0aW9uO1xuXG52YXIgbm9uY2UgPSBEYXRlLm5vdygpO1xuXG52YXIgcnF1ZXJ5ID0gKCAvXFw/LyApO1xuXG5cblxuLy8gQ3Jvc3MtYnJvd3NlciB4bWwgcGFyc2luZ1xualF1ZXJ5LnBhcnNlWE1MID0gZnVuY3Rpb24oIGRhdGEgKSB7XG5cdHZhciB4bWw7XG5cdGlmICggIWRhdGEgfHwgdHlwZW9mIGRhdGEgIT09IFwic3RyaW5nXCIgKSB7XG5cdFx0cmV0dXJuIG51bGw7XG5cdH1cblxuXHQvLyBTdXBwb3J0OiBJRSA5IC0gMTEgb25seVxuXHQvLyBJRSB0aHJvd3Mgb24gcGFyc2VGcm9tU3RyaW5nIHdpdGggaW52YWxpZCBpbnB1dC5cblx0dHJ5IHtcblx0XHR4bWwgPSAoIG5ldyB3aW5kb3cuRE9NUGFyc2VyKCkgKS5wYXJzZUZyb21TdHJpbmcoIGRhdGEsIFwidGV4dC94bWxcIiApO1xuXHR9IGNhdGNoICggZSApIHtcblx0XHR4bWwgPSB1bmRlZmluZWQ7XG5cdH1cblxuXHRpZiAoICF4bWwgfHwgeG1sLmdldEVsZW1lbnRzQnlUYWdOYW1lKCBcInBhcnNlcmVycm9yXCIgKS5sZW5ndGggKSB7XG5cdFx0alF1ZXJ5LmVycm9yKCBcIkludmFsaWQgWE1MOiBcIiArIGRhdGEgKTtcblx0fVxuXHRyZXR1cm4geG1sO1xufTtcblxuXG52YXJcblx0cmJyYWNrZXQgPSAvXFxbXFxdJC8sXG5cdHJDUkxGID0gL1xccj9cXG4vZyxcblx0cnN1Ym1pdHRlclR5cGVzID0gL14oPzpzdWJtaXR8YnV0dG9ufGltYWdlfHJlc2V0fGZpbGUpJC9pLFxuXHRyc3VibWl0dGFibGUgPSAvXig/OmlucHV0fHNlbGVjdHx0ZXh0YXJlYXxrZXlnZW4pL2k7XG5cbmZ1bmN0aW9uIGJ1aWxkUGFyYW1zKCBwcmVmaXgsIG9iaiwgdHJhZGl0aW9uYWwsIGFkZCApIHtcblx0dmFyIG5hbWU7XG5cblx0aWYgKCBBcnJheS5pc0FycmF5KCBvYmogKSApIHtcblxuXHRcdC8vIFNlcmlhbGl6ZSBhcnJheSBpdGVtLlxuXHRcdGpRdWVyeS5lYWNoKCBvYmosIGZ1bmN0aW9uKCBpLCB2ICkge1xuXHRcdFx0aWYgKCB0cmFkaXRpb25hbCB8fCByYnJhY2tldC50ZXN0KCBwcmVmaXggKSApIHtcblxuXHRcdFx0XHQvLyBUcmVhdCBlYWNoIGFycmF5IGl0ZW0gYXMgYSBzY2FsYXIuXG5cdFx0XHRcdGFkZCggcHJlZml4LCB2ICk7XG5cblx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0Ly8gSXRlbSBpcyBub24tc2NhbGFyIChhcnJheSBvciBvYmplY3QpLCBlbmNvZGUgaXRzIG51bWVyaWMgaW5kZXguXG5cdFx0XHRcdGJ1aWxkUGFyYW1zKFxuXHRcdFx0XHRcdHByZWZpeCArIFwiW1wiICsgKCB0eXBlb2YgdiA9PT0gXCJvYmplY3RcIiAmJiB2ICE9IG51bGwgPyBpIDogXCJcIiApICsgXCJdXCIsXG5cdFx0XHRcdFx0dixcblx0XHRcdFx0XHR0cmFkaXRpb25hbCxcblx0XHRcdFx0XHRhZGRcblx0XHRcdFx0KTtcblx0XHRcdH1cblx0XHR9ICk7XG5cblx0fSBlbHNlIGlmICggIXRyYWRpdGlvbmFsICYmIHRvVHlwZSggb2JqICkgPT09IFwib2JqZWN0XCIgKSB7XG5cblx0XHQvLyBTZXJpYWxpemUgb2JqZWN0IGl0ZW0uXG5cdFx0Zm9yICggbmFtZSBpbiBvYmogKSB7XG5cdFx0XHRidWlsZFBhcmFtcyggcHJlZml4ICsgXCJbXCIgKyBuYW1lICsgXCJdXCIsIG9ialsgbmFtZSBdLCB0cmFkaXRpb25hbCwgYWRkICk7XG5cdFx0fVxuXG5cdH0gZWxzZSB7XG5cblx0XHQvLyBTZXJpYWxpemUgc2NhbGFyIGl0ZW0uXG5cdFx0YWRkKCBwcmVmaXgsIG9iaiApO1xuXHR9XG59XG5cbi8vIFNlcmlhbGl6ZSBhbiBhcnJheSBvZiBmb3JtIGVsZW1lbnRzIG9yIGEgc2V0IG9mXG4vLyBrZXkvdmFsdWVzIGludG8gYSBxdWVyeSBzdHJpbmdcbmpRdWVyeS5wYXJhbSA9IGZ1bmN0aW9uKCBhLCB0cmFkaXRpb25hbCApIHtcblx0dmFyIHByZWZpeCxcblx0XHRzID0gW10sXG5cdFx0YWRkID0gZnVuY3Rpb24oIGtleSwgdmFsdWVPckZ1bmN0aW9uICkge1xuXG5cdFx0XHQvLyBJZiB2YWx1ZSBpcyBhIGZ1bmN0aW9uLCBpbnZva2UgaXQgYW5kIHVzZSBpdHMgcmV0dXJuIHZhbHVlXG5cdFx0XHR2YXIgdmFsdWUgPSBpc0Z1bmN0aW9uKCB2YWx1ZU9yRnVuY3Rpb24gKSA/XG5cdFx0XHRcdHZhbHVlT3JGdW5jdGlvbigpIDpcblx0XHRcdFx0dmFsdWVPckZ1bmN0aW9uO1xuXG5cdFx0XHRzWyBzLmxlbmd0aCBdID0gZW5jb2RlVVJJQ29tcG9uZW50KCBrZXkgKSArIFwiPVwiICtcblx0XHRcdFx0ZW5jb2RlVVJJQ29tcG9uZW50KCB2YWx1ZSA9PSBudWxsID8gXCJcIiA6IHZhbHVlICk7XG5cdFx0fTtcblxuXHRpZiAoIGEgPT0gbnVsbCApIHtcblx0XHRyZXR1cm4gXCJcIjtcblx0fVxuXG5cdC8vIElmIGFuIGFycmF5IHdhcyBwYXNzZWQgaW4sIGFzc3VtZSB0aGF0IGl0IGlzIGFuIGFycmF5IG9mIGZvcm0gZWxlbWVudHMuXG5cdGlmICggQXJyYXkuaXNBcnJheSggYSApIHx8ICggYS5qcXVlcnkgJiYgIWpRdWVyeS5pc1BsYWluT2JqZWN0KCBhICkgKSApIHtcblxuXHRcdC8vIFNlcmlhbGl6ZSB0aGUgZm9ybSBlbGVtZW50c1xuXHRcdGpRdWVyeS5lYWNoKCBhLCBmdW5jdGlvbigpIHtcblx0XHRcdGFkZCggdGhpcy5uYW1lLCB0aGlzLnZhbHVlICk7XG5cdFx0fSApO1xuXG5cdH0gZWxzZSB7XG5cblx0XHQvLyBJZiB0cmFkaXRpb25hbCwgZW5jb2RlIHRoZSBcIm9sZFwiIHdheSAodGhlIHdheSAxLjMuMiBvciBvbGRlclxuXHRcdC8vIGRpZCBpdCksIG90aGVyd2lzZSBlbmNvZGUgcGFyYW1zIHJlY3Vyc2l2ZWx5LlxuXHRcdGZvciAoIHByZWZpeCBpbiBhICkge1xuXHRcdFx0YnVpbGRQYXJhbXMoIHByZWZpeCwgYVsgcHJlZml4IF0sIHRyYWRpdGlvbmFsLCBhZGQgKTtcblx0XHR9XG5cdH1cblxuXHQvLyBSZXR1cm4gdGhlIHJlc3VsdGluZyBzZXJpYWxpemF0aW9uXG5cdHJldHVybiBzLmpvaW4oIFwiJlwiICk7XG59O1xuXG5qUXVlcnkuZm4uZXh0ZW5kKCB7XG5cdHNlcmlhbGl6ZTogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIGpRdWVyeS5wYXJhbSggdGhpcy5zZXJpYWxpemVBcnJheSgpICk7XG5cdH0sXG5cdHNlcmlhbGl6ZUFycmF5OiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5tYXAoIGZ1bmN0aW9uKCkge1xuXG5cdFx0XHQvLyBDYW4gYWRkIHByb3BIb29rIGZvciBcImVsZW1lbnRzXCIgdG8gZmlsdGVyIG9yIGFkZCBmb3JtIGVsZW1lbnRzXG5cdFx0XHR2YXIgZWxlbWVudHMgPSBqUXVlcnkucHJvcCggdGhpcywgXCJlbGVtZW50c1wiICk7XG5cdFx0XHRyZXR1cm4gZWxlbWVudHMgPyBqUXVlcnkubWFrZUFycmF5KCBlbGVtZW50cyApIDogdGhpcztcblx0XHR9IClcblx0XHQuZmlsdGVyKCBmdW5jdGlvbigpIHtcblx0XHRcdHZhciB0eXBlID0gdGhpcy50eXBlO1xuXG5cdFx0XHQvLyBVc2UgLmlzKCBcIjpkaXNhYmxlZFwiICkgc28gdGhhdCBmaWVsZHNldFtkaXNhYmxlZF0gd29ya3Ncblx0XHRcdHJldHVybiB0aGlzLm5hbWUgJiYgIWpRdWVyeSggdGhpcyApLmlzKCBcIjpkaXNhYmxlZFwiICkgJiZcblx0XHRcdFx0cnN1Ym1pdHRhYmxlLnRlc3QoIHRoaXMubm9kZU5hbWUgKSAmJiAhcnN1Ym1pdHRlclR5cGVzLnRlc3QoIHR5cGUgKSAmJlxuXHRcdFx0XHQoIHRoaXMuY2hlY2tlZCB8fCAhcmNoZWNrYWJsZVR5cGUudGVzdCggdHlwZSApICk7XG5cdFx0fSApXG5cdFx0Lm1hcCggZnVuY3Rpb24oIGksIGVsZW0gKSB7XG5cdFx0XHR2YXIgdmFsID0galF1ZXJ5KCB0aGlzICkudmFsKCk7XG5cblx0XHRcdGlmICggdmFsID09IG51bGwgKSB7XG5cdFx0XHRcdHJldHVybiBudWxsO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAoIEFycmF5LmlzQXJyYXkoIHZhbCApICkge1xuXHRcdFx0XHRyZXR1cm4galF1ZXJ5Lm1hcCggdmFsLCBmdW5jdGlvbiggdmFsICkge1xuXHRcdFx0XHRcdHJldHVybiB7IG5hbWU6IGVsZW0ubmFtZSwgdmFsdWU6IHZhbC5yZXBsYWNlKCByQ1JMRiwgXCJcXHJcXG5cIiApIH07XG5cdFx0XHRcdH0gKTtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIHsgbmFtZTogZWxlbS5uYW1lLCB2YWx1ZTogdmFsLnJlcGxhY2UoIHJDUkxGLCBcIlxcclxcblwiICkgfTtcblx0XHR9ICkuZ2V0KCk7XG5cdH1cbn0gKTtcblxuXG52YXJcblx0cjIwID0gLyUyMC9nLFxuXHRyaGFzaCA9IC8jLiokLyxcblx0cmFudGlDYWNoZSA9IC8oWz8mXSlfPVteJl0qLyxcblx0cmhlYWRlcnMgPSAvXiguKj8pOlsgXFx0XSooW15cXHJcXG5dKikkL21nLFxuXG5cdC8vICM3NjUzLCAjODEyNSwgIzgxNTI6IGxvY2FsIHByb3RvY29sIGRldGVjdGlvblxuXHRybG9jYWxQcm90b2NvbCA9IC9eKD86YWJvdXR8YXBwfGFwcC1zdG9yYWdlfC4rLWV4dGVuc2lvbnxmaWxlfHJlc3x3aWRnZXQpOiQvLFxuXHRybm9Db250ZW50ID0gL14oPzpHRVR8SEVBRCkkLyxcblx0cnByb3RvY29sID0gL15cXC9cXC8vLFxuXG5cdC8qIFByZWZpbHRlcnNcblx0ICogMSkgVGhleSBhcmUgdXNlZnVsIHRvIGludHJvZHVjZSBjdXN0b20gZGF0YVR5cGVzIChzZWUgYWpheC9qc29ucC5qcyBmb3IgYW4gZXhhbXBsZSlcblx0ICogMikgVGhlc2UgYXJlIGNhbGxlZDpcblx0ICogICAgLSBCRUZPUkUgYXNraW5nIGZvciBhIHRyYW5zcG9ydFxuXHQgKiAgICAtIEFGVEVSIHBhcmFtIHNlcmlhbGl6YXRpb24gKHMuZGF0YSBpcyBhIHN0cmluZyBpZiBzLnByb2Nlc3NEYXRhIGlzIHRydWUpXG5cdCAqIDMpIGtleSBpcyB0aGUgZGF0YVR5cGVcblx0ICogNCkgdGhlIGNhdGNoYWxsIHN5bWJvbCBcIipcIiBjYW4gYmUgdXNlZFxuXHQgKiA1KSBleGVjdXRpb24gd2lsbCBzdGFydCB3aXRoIHRyYW5zcG9ydCBkYXRhVHlwZSBhbmQgVEhFTiBjb250aW51ZSBkb3duIHRvIFwiKlwiIGlmIG5lZWRlZFxuXHQgKi9cblx0cHJlZmlsdGVycyA9IHt9LFxuXG5cdC8qIFRyYW5zcG9ydHMgYmluZGluZ3Ncblx0ICogMSkga2V5IGlzIHRoZSBkYXRhVHlwZVxuXHQgKiAyKSB0aGUgY2F0Y2hhbGwgc3ltYm9sIFwiKlwiIGNhbiBiZSB1c2VkXG5cdCAqIDMpIHNlbGVjdGlvbiB3aWxsIHN0YXJ0IHdpdGggdHJhbnNwb3J0IGRhdGFUeXBlIGFuZCBUSEVOIGdvIHRvIFwiKlwiIGlmIG5lZWRlZFxuXHQgKi9cblx0dHJhbnNwb3J0cyA9IHt9LFxuXG5cdC8vIEF2b2lkIGNvbW1lbnQtcHJvbG9nIGNoYXIgc2VxdWVuY2UgKCMxMDA5OCk7IG11c3QgYXBwZWFzZSBsaW50IGFuZCBldmFkZSBjb21wcmVzc2lvblxuXHRhbGxUeXBlcyA9IFwiKi9cIi5jb25jYXQoIFwiKlwiICksXG5cblx0Ly8gQW5jaG9yIHRhZyBmb3IgcGFyc2luZyB0aGUgZG9jdW1lbnQgb3JpZ2luXG5cdG9yaWdpbkFuY2hvciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoIFwiYVwiICk7XG5cdG9yaWdpbkFuY2hvci5ocmVmID0gbG9jYXRpb24uaHJlZjtcblxuLy8gQmFzZSBcImNvbnN0cnVjdG9yXCIgZm9yIGpRdWVyeS5hamF4UHJlZmlsdGVyIGFuZCBqUXVlcnkuYWpheFRyYW5zcG9ydFxuZnVuY3Rpb24gYWRkVG9QcmVmaWx0ZXJzT3JUcmFuc3BvcnRzKCBzdHJ1Y3R1cmUgKSB7XG5cblx0Ly8gZGF0YVR5cGVFeHByZXNzaW9uIGlzIG9wdGlvbmFsIGFuZCBkZWZhdWx0cyB0byBcIipcIlxuXHRyZXR1cm4gZnVuY3Rpb24oIGRhdGFUeXBlRXhwcmVzc2lvbiwgZnVuYyApIHtcblxuXHRcdGlmICggdHlwZW9mIGRhdGFUeXBlRXhwcmVzc2lvbiAhPT0gXCJzdHJpbmdcIiApIHtcblx0XHRcdGZ1bmMgPSBkYXRhVHlwZUV4cHJlc3Npb247XG5cdFx0XHRkYXRhVHlwZUV4cHJlc3Npb24gPSBcIipcIjtcblx0XHR9XG5cblx0XHR2YXIgZGF0YVR5cGUsXG5cdFx0XHRpID0gMCxcblx0XHRcdGRhdGFUeXBlcyA9IGRhdGFUeXBlRXhwcmVzc2lvbi50b0xvd2VyQ2FzZSgpLm1hdGNoKCBybm90aHRtbHdoaXRlICkgfHwgW107XG5cblx0XHRpZiAoIGlzRnVuY3Rpb24oIGZ1bmMgKSApIHtcblxuXHRcdFx0Ly8gRm9yIGVhY2ggZGF0YVR5cGUgaW4gdGhlIGRhdGFUeXBlRXhwcmVzc2lvblxuXHRcdFx0d2hpbGUgKCAoIGRhdGFUeXBlID0gZGF0YVR5cGVzWyBpKysgXSApICkge1xuXG5cdFx0XHRcdC8vIFByZXBlbmQgaWYgcmVxdWVzdGVkXG5cdFx0XHRcdGlmICggZGF0YVR5cGVbIDAgXSA9PT0gXCIrXCIgKSB7XG5cdFx0XHRcdFx0ZGF0YVR5cGUgPSBkYXRhVHlwZS5zbGljZSggMSApIHx8IFwiKlwiO1xuXHRcdFx0XHRcdCggc3RydWN0dXJlWyBkYXRhVHlwZSBdID0gc3RydWN0dXJlWyBkYXRhVHlwZSBdIHx8IFtdICkudW5zaGlmdCggZnVuYyApO1xuXG5cdFx0XHRcdC8vIE90aGVyd2lzZSBhcHBlbmRcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHQoIHN0cnVjdHVyZVsgZGF0YVR5cGUgXSA9IHN0cnVjdHVyZVsgZGF0YVR5cGUgXSB8fCBbXSApLnB1c2goIGZ1bmMgKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fTtcbn1cblxuLy8gQmFzZSBpbnNwZWN0aW9uIGZ1bmN0aW9uIGZvciBwcmVmaWx0ZXJzIGFuZCB0cmFuc3BvcnRzXG5mdW5jdGlvbiBpbnNwZWN0UHJlZmlsdGVyc09yVHJhbnNwb3J0cyggc3RydWN0dXJlLCBvcHRpb25zLCBvcmlnaW5hbE9wdGlvbnMsIGpxWEhSICkge1xuXG5cdHZhciBpbnNwZWN0ZWQgPSB7fSxcblx0XHRzZWVraW5nVHJhbnNwb3J0ID0gKCBzdHJ1Y3R1cmUgPT09IHRyYW5zcG9ydHMgKTtcblxuXHRmdW5jdGlvbiBpbnNwZWN0KCBkYXRhVHlwZSApIHtcblx0XHR2YXIgc2VsZWN0ZWQ7XG5cdFx0aW5zcGVjdGVkWyBkYXRhVHlwZSBdID0gdHJ1ZTtcblx0XHRqUXVlcnkuZWFjaCggc3RydWN0dXJlWyBkYXRhVHlwZSBdIHx8IFtdLCBmdW5jdGlvbiggXywgcHJlZmlsdGVyT3JGYWN0b3J5ICkge1xuXHRcdFx0dmFyIGRhdGFUeXBlT3JUcmFuc3BvcnQgPSBwcmVmaWx0ZXJPckZhY3RvcnkoIG9wdGlvbnMsIG9yaWdpbmFsT3B0aW9ucywganFYSFIgKTtcblx0XHRcdGlmICggdHlwZW9mIGRhdGFUeXBlT3JUcmFuc3BvcnQgPT09IFwic3RyaW5nXCIgJiZcblx0XHRcdFx0IXNlZWtpbmdUcmFuc3BvcnQgJiYgIWluc3BlY3RlZFsgZGF0YVR5cGVPclRyYW5zcG9ydCBdICkge1xuXG5cdFx0XHRcdG9wdGlvbnMuZGF0YVR5cGVzLnVuc2hpZnQoIGRhdGFUeXBlT3JUcmFuc3BvcnQgKTtcblx0XHRcdFx0aW5zcGVjdCggZGF0YVR5cGVPclRyYW5zcG9ydCApO1xuXHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHR9IGVsc2UgaWYgKCBzZWVraW5nVHJhbnNwb3J0ICkge1xuXHRcdFx0XHRyZXR1cm4gISggc2VsZWN0ZWQgPSBkYXRhVHlwZU9yVHJhbnNwb3J0ICk7XG5cdFx0XHR9XG5cdFx0fSApO1xuXHRcdHJldHVybiBzZWxlY3RlZDtcblx0fVxuXG5cdHJldHVybiBpbnNwZWN0KCBvcHRpb25zLmRhdGFUeXBlc1sgMCBdICkgfHwgIWluc3BlY3RlZFsgXCIqXCIgXSAmJiBpbnNwZWN0KCBcIipcIiApO1xufVxuXG4vLyBBIHNwZWNpYWwgZXh0ZW5kIGZvciBhamF4IG9wdGlvbnNcbi8vIHRoYXQgdGFrZXMgXCJmbGF0XCIgb3B0aW9ucyAobm90IHRvIGJlIGRlZXAgZXh0ZW5kZWQpXG4vLyBGaXhlcyAjOTg4N1xuZnVuY3Rpb24gYWpheEV4dGVuZCggdGFyZ2V0LCBzcmMgKSB7XG5cdHZhciBrZXksIGRlZXAsXG5cdFx0ZmxhdE9wdGlvbnMgPSBqUXVlcnkuYWpheFNldHRpbmdzLmZsYXRPcHRpb25zIHx8IHt9O1xuXG5cdGZvciAoIGtleSBpbiBzcmMgKSB7XG5cdFx0aWYgKCBzcmNbIGtleSBdICE9PSB1bmRlZmluZWQgKSB7XG5cdFx0XHQoIGZsYXRPcHRpb25zWyBrZXkgXSA/IHRhcmdldCA6ICggZGVlcCB8fCAoIGRlZXAgPSB7fSApICkgKVsga2V5IF0gPSBzcmNbIGtleSBdO1xuXHRcdH1cblx0fVxuXHRpZiAoIGRlZXAgKSB7XG5cdFx0alF1ZXJ5LmV4dGVuZCggdHJ1ZSwgdGFyZ2V0LCBkZWVwICk7XG5cdH1cblxuXHRyZXR1cm4gdGFyZ2V0O1xufVxuXG4vKiBIYW5kbGVzIHJlc3BvbnNlcyB0byBhbiBhamF4IHJlcXVlc3Q6XG4gKiAtIGZpbmRzIHRoZSByaWdodCBkYXRhVHlwZSAobWVkaWF0ZXMgYmV0d2VlbiBjb250ZW50LXR5cGUgYW5kIGV4cGVjdGVkIGRhdGFUeXBlKVxuICogLSByZXR1cm5zIHRoZSBjb3JyZXNwb25kaW5nIHJlc3BvbnNlXG4gKi9cbmZ1bmN0aW9uIGFqYXhIYW5kbGVSZXNwb25zZXMoIHMsIGpxWEhSLCByZXNwb25zZXMgKSB7XG5cblx0dmFyIGN0LCB0eXBlLCBmaW5hbERhdGFUeXBlLCBmaXJzdERhdGFUeXBlLFxuXHRcdGNvbnRlbnRzID0gcy5jb250ZW50cyxcblx0XHRkYXRhVHlwZXMgPSBzLmRhdGFUeXBlcztcblxuXHQvLyBSZW1vdmUgYXV0byBkYXRhVHlwZSBhbmQgZ2V0IGNvbnRlbnQtdHlwZSBpbiB0aGUgcHJvY2Vzc1xuXHR3aGlsZSAoIGRhdGFUeXBlc1sgMCBdID09PSBcIipcIiApIHtcblx0XHRkYXRhVHlwZXMuc2hpZnQoKTtcblx0XHRpZiAoIGN0ID09PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRjdCA9IHMubWltZVR5cGUgfHwganFYSFIuZ2V0UmVzcG9uc2VIZWFkZXIoIFwiQ29udGVudC1UeXBlXCIgKTtcblx0XHR9XG5cdH1cblxuXHQvLyBDaGVjayBpZiB3ZSdyZSBkZWFsaW5nIHdpdGggYSBrbm93biBjb250ZW50LXR5cGVcblx0aWYgKCBjdCApIHtcblx0XHRmb3IgKCB0eXBlIGluIGNvbnRlbnRzICkge1xuXHRcdFx0aWYgKCBjb250ZW50c1sgdHlwZSBdICYmIGNvbnRlbnRzWyB0eXBlIF0udGVzdCggY3QgKSApIHtcblx0XHRcdFx0ZGF0YVR5cGVzLnVuc2hpZnQoIHR5cGUgKTtcblx0XHRcdFx0YnJlYWs7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0Ly8gQ2hlY2sgdG8gc2VlIGlmIHdlIGhhdmUgYSByZXNwb25zZSBmb3IgdGhlIGV4cGVjdGVkIGRhdGFUeXBlXG5cdGlmICggZGF0YVR5cGVzWyAwIF0gaW4gcmVzcG9uc2VzICkge1xuXHRcdGZpbmFsRGF0YVR5cGUgPSBkYXRhVHlwZXNbIDAgXTtcblx0fSBlbHNlIHtcblxuXHRcdC8vIFRyeSBjb252ZXJ0aWJsZSBkYXRhVHlwZXNcblx0XHRmb3IgKCB0eXBlIGluIHJlc3BvbnNlcyApIHtcblx0XHRcdGlmICggIWRhdGFUeXBlc1sgMCBdIHx8IHMuY29udmVydGVyc1sgdHlwZSArIFwiIFwiICsgZGF0YVR5cGVzWyAwIF0gXSApIHtcblx0XHRcdFx0ZmluYWxEYXRhVHlwZSA9IHR5cGU7XG5cdFx0XHRcdGJyZWFrO1xuXHRcdFx0fVxuXHRcdFx0aWYgKCAhZmlyc3REYXRhVHlwZSApIHtcblx0XHRcdFx0Zmlyc3REYXRhVHlwZSA9IHR5cGU7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gT3IganVzdCB1c2UgZmlyc3Qgb25lXG5cdFx0ZmluYWxEYXRhVHlwZSA9IGZpbmFsRGF0YVR5cGUgfHwgZmlyc3REYXRhVHlwZTtcblx0fVxuXG5cdC8vIElmIHdlIGZvdW5kIGEgZGF0YVR5cGVcblx0Ly8gV2UgYWRkIHRoZSBkYXRhVHlwZSB0byB0aGUgbGlzdCBpZiBuZWVkZWRcblx0Ly8gYW5kIHJldHVybiB0aGUgY29ycmVzcG9uZGluZyByZXNwb25zZVxuXHRpZiAoIGZpbmFsRGF0YVR5cGUgKSB7XG5cdFx0aWYgKCBmaW5hbERhdGFUeXBlICE9PSBkYXRhVHlwZXNbIDAgXSApIHtcblx0XHRcdGRhdGFUeXBlcy51bnNoaWZ0KCBmaW5hbERhdGFUeXBlICk7XG5cdFx0fVxuXHRcdHJldHVybiByZXNwb25zZXNbIGZpbmFsRGF0YVR5cGUgXTtcblx0fVxufVxuXG4vKiBDaGFpbiBjb252ZXJzaW9ucyBnaXZlbiB0aGUgcmVxdWVzdCBhbmQgdGhlIG9yaWdpbmFsIHJlc3BvbnNlXG4gKiBBbHNvIHNldHMgdGhlIHJlc3BvbnNlWFhYIGZpZWxkcyBvbiB0aGUganFYSFIgaW5zdGFuY2VcbiAqL1xuZnVuY3Rpb24gYWpheENvbnZlcnQoIHMsIHJlc3BvbnNlLCBqcVhIUiwgaXNTdWNjZXNzICkge1xuXHR2YXIgY29udjIsIGN1cnJlbnQsIGNvbnYsIHRtcCwgcHJldixcblx0XHRjb252ZXJ0ZXJzID0ge30sXG5cblx0XHQvLyBXb3JrIHdpdGggYSBjb3B5IG9mIGRhdGFUeXBlcyBpbiBjYXNlIHdlIG5lZWQgdG8gbW9kaWZ5IGl0IGZvciBjb252ZXJzaW9uXG5cdFx0ZGF0YVR5cGVzID0gcy5kYXRhVHlwZXMuc2xpY2UoKTtcblxuXHQvLyBDcmVhdGUgY29udmVydGVycyBtYXAgd2l0aCBsb3dlcmNhc2VkIGtleXNcblx0aWYgKCBkYXRhVHlwZXNbIDEgXSApIHtcblx0XHRmb3IgKCBjb252IGluIHMuY29udmVydGVycyApIHtcblx0XHRcdGNvbnZlcnRlcnNbIGNvbnYudG9Mb3dlckNhc2UoKSBdID0gcy5jb252ZXJ0ZXJzWyBjb252IF07XG5cdFx0fVxuXHR9XG5cblx0Y3VycmVudCA9IGRhdGFUeXBlcy5zaGlmdCgpO1xuXG5cdC8vIENvbnZlcnQgdG8gZWFjaCBzZXF1ZW50aWFsIGRhdGFUeXBlXG5cdHdoaWxlICggY3VycmVudCApIHtcblxuXHRcdGlmICggcy5yZXNwb25zZUZpZWxkc1sgY3VycmVudCBdICkge1xuXHRcdFx0anFYSFJbIHMucmVzcG9uc2VGaWVsZHNbIGN1cnJlbnQgXSBdID0gcmVzcG9uc2U7XG5cdFx0fVxuXG5cdFx0Ly8gQXBwbHkgdGhlIGRhdGFGaWx0ZXIgaWYgcHJvdmlkZWRcblx0XHRpZiAoICFwcmV2ICYmIGlzU3VjY2VzcyAmJiBzLmRhdGFGaWx0ZXIgKSB7XG5cdFx0XHRyZXNwb25zZSA9IHMuZGF0YUZpbHRlciggcmVzcG9uc2UsIHMuZGF0YVR5cGUgKTtcblx0XHR9XG5cblx0XHRwcmV2ID0gY3VycmVudDtcblx0XHRjdXJyZW50ID0gZGF0YVR5cGVzLnNoaWZ0KCk7XG5cblx0XHRpZiAoIGN1cnJlbnQgKSB7XG5cblx0XHRcdC8vIFRoZXJlJ3Mgb25seSB3b3JrIHRvIGRvIGlmIGN1cnJlbnQgZGF0YVR5cGUgaXMgbm9uLWF1dG9cblx0XHRcdGlmICggY3VycmVudCA9PT0gXCIqXCIgKSB7XG5cblx0XHRcdFx0Y3VycmVudCA9IHByZXY7XG5cblx0XHRcdC8vIENvbnZlcnQgcmVzcG9uc2UgaWYgcHJldiBkYXRhVHlwZSBpcyBub24tYXV0byBhbmQgZGlmZmVycyBmcm9tIGN1cnJlbnRcblx0XHRcdH0gZWxzZSBpZiAoIHByZXYgIT09IFwiKlwiICYmIHByZXYgIT09IGN1cnJlbnQgKSB7XG5cblx0XHRcdFx0Ly8gU2VlayBhIGRpcmVjdCBjb252ZXJ0ZXJcblx0XHRcdFx0Y29udiA9IGNvbnZlcnRlcnNbIHByZXYgKyBcIiBcIiArIGN1cnJlbnQgXSB8fCBjb252ZXJ0ZXJzWyBcIiogXCIgKyBjdXJyZW50IF07XG5cblx0XHRcdFx0Ly8gSWYgbm9uZSBmb3VuZCwgc2VlayBhIHBhaXJcblx0XHRcdFx0aWYgKCAhY29udiApIHtcblx0XHRcdFx0XHRmb3IgKCBjb252MiBpbiBjb252ZXJ0ZXJzICkge1xuXG5cdFx0XHRcdFx0XHQvLyBJZiBjb252MiBvdXRwdXRzIGN1cnJlbnRcblx0XHRcdFx0XHRcdHRtcCA9IGNvbnYyLnNwbGl0KCBcIiBcIiApO1xuXHRcdFx0XHRcdFx0aWYgKCB0bXBbIDEgXSA9PT0gY3VycmVudCApIHtcblxuXHRcdFx0XHRcdFx0XHQvLyBJZiBwcmV2IGNhbiBiZSBjb252ZXJ0ZWQgdG8gYWNjZXB0ZWQgaW5wdXRcblx0XHRcdFx0XHRcdFx0Y29udiA9IGNvbnZlcnRlcnNbIHByZXYgKyBcIiBcIiArIHRtcFsgMCBdIF0gfHxcblx0XHRcdFx0XHRcdFx0XHRjb252ZXJ0ZXJzWyBcIiogXCIgKyB0bXBbIDAgXSBdO1xuXHRcdFx0XHRcdFx0XHRpZiAoIGNvbnYgKSB7XG5cblx0XHRcdFx0XHRcdFx0XHQvLyBDb25kZW5zZSBlcXVpdmFsZW5jZSBjb252ZXJ0ZXJzXG5cdFx0XHRcdFx0XHRcdFx0aWYgKCBjb252ID09PSB0cnVlICkge1xuXHRcdFx0XHRcdFx0XHRcdFx0Y29udiA9IGNvbnZlcnRlcnNbIGNvbnYyIF07XG5cblx0XHRcdFx0XHRcdFx0XHQvLyBPdGhlcndpc2UsIGluc2VydCB0aGUgaW50ZXJtZWRpYXRlIGRhdGFUeXBlXG5cdFx0XHRcdFx0XHRcdFx0fSBlbHNlIGlmICggY29udmVydGVyc1sgY29udjIgXSAhPT0gdHJ1ZSApIHtcblx0XHRcdFx0XHRcdFx0XHRcdGN1cnJlbnQgPSB0bXBbIDAgXTtcblx0XHRcdFx0XHRcdFx0XHRcdGRhdGFUeXBlcy51bnNoaWZ0KCB0bXBbIDEgXSApO1xuXHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIEFwcGx5IGNvbnZlcnRlciAoaWYgbm90IGFuIGVxdWl2YWxlbmNlKVxuXHRcdFx0XHRpZiAoIGNvbnYgIT09IHRydWUgKSB7XG5cblx0XHRcdFx0XHQvLyBVbmxlc3MgZXJyb3JzIGFyZSBhbGxvd2VkIHRvIGJ1YmJsZSwgY2F0Y2ggYW5kIHJldHVybiB0aGVtXG5cdFx0XHRcdFx0aWYgKCBjb252ICYmIHMudGhyb3dzICkge1xuXHRcdFx0XHRcdFx0cmVzcG9uc2UgPSBjb252KCByZXNwb25zZSApO1xuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHR0cnkge1xuXHRcdFx0XHRcdFx0XHRyZXNwb25zZSA9IGNvbnYoIHJlc3BvbnNlICk7XG5cdFx0XHRcdFx0XHR9IGNhdGNoICggZSApIHtcblx0XHRcdFx0XHRcdFx0cmV0dXJuIHtcblx0XHRcdFx0XHRcdFx0XHRzdGF0ZTogXCJwYXJzZXJlcnJvclwiLFxuXHRcdFx0XHRcdFx0XHRcdGVycm9yOiBjb252ID8gZSA6IFwiTm8gY29udmVyc2lvbiBmcm9tIFwiICsgcHJldiArIFwiIHRvIFwiICsgY3VycmVudFxuXHRcdFx0XHRcdFx0XHR9O1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdHJldHVybiB7IHN0YXRlOiBcInN1Y2Nlc3NcIiwgZGF0YTogcmVzcG9uc2UgfTtcbn1cblxualF1ZXJ5LmV4dGVuZCgge1xuXG5cdC8vIENvdW50ZXIgZm9yIGhvbGRpbmcgdGhlIG51bWJlciBvZiBhY3RpdmUgcXVlcmllc1xuXHRhY3RpdmU6IDAsXG5cblx0Ly8gTGFzdC1Nb2RpZmllZCBoZWFkZXIgY2FjaGUgZm9yIG5leHQgcmVxdWVzdFxuXHRsYXN0TW9kaWZpZWQ6IHt9LFxuXHRldGFnOiB7fSxcblxuXHRhamF4U2V0dGluZ3M6IHtcblx0XHR1cmw6IGxvY2F0aW9uLmhyZWYsXG5cdFx0dHlwZTogXCJHRVRcIixcblx0XHRpc0xvY2FsOiBybG9jYWxQcm90b2NvbC50ZXN0KCBsb2NhdGlvbi5wcm90b2NvbCApLFxuXHRcdGdsb2JhbDogdHJ1ZSxcblx0XHRwcm9jZXNzRGF0YTogdHJ1ZSxcblx0XHRhc3luYzogdHJ1ZSxcblx0XHRjb250ZW50VHlwZTogXCJhcHBsaWNhdGlvbi94LXd3dy1mb3JtLXVybGVuY29kZWQ7IGNoYXJzZXQ9VVRGLThcIixcblxuXHRcdC8qXG5cdFx0dGltZW91dDogMCxcblx0XHRkYXRhOiBudWxsLFxuXHRcdGRhdGFUeXBlOiBudWxsLFxuXHRcdHVzZXJuYW1lOiBudWxsLFxuXHRcdHBhc3N3b3JkOiBudWxsLFxuXHRcdGNhY2hlOiBudWxsLFxuXHRcdHRocm93czogZmFsc2UsXG5cdFx0dHJhZGl0aW9uYWw6IGZhbHNlLFxuXHRcdGhlYWRlcnM6IHt9LFxuXHRcdCovXG5cblx0XHRhY2NlcHRzOiB7XG5cdFx0XHRcIipcIjogYWxsVHlwZXMsXG5cdFx0XHR0ZXh0OiBcInRleHQvcGxhaW5cIixcblx0XHRcdGh0bWw6IFwidGV4dC9odG1sXCIsXG5cdFx0XHR4bWw6IFwiYXBwbGljYXRpb24veG1sLCB0ZXh0L3htbFwiLFxuXHRcdFx0anNvbjogXCJhcHBsaWNhdGlvbi9qc29uLCB0ZXh0L2phdmFzY3JpcHRcIlxuXHRcdH0sXG5cblx0XHRjb250ZW50czoge1xuXHRcdFx0eG1sOiAvXFxieG1sXFxiLyxcblx0XHRcdGh0bWw6IC9cXGJodG1sLyxcblx0XHRcdGpzb246IC9cXGJqc29uXFxiL1xuXHRcdH0sXG5cblx0XHRyZXNwb25zZUZpZWxkczoge1xuXHRcdFx0eG1sOiBcInJlc3BvbnNlWE1MXCIsXG5cdFx0XHR0ZXh0OiBcInJlc3BvbnNlVGV4dFwiLFxuXHRcdFx0anNvbjogXCJyZXNwb25zZUpTT05cIlxuXHRcdH0sXG5cblx0XHQvLyBEYXRhIGNvbnZlcnRlcnNcblx0XHQvLyBLZXlzIHNlcGFyYXRlIHNvdXJjZSAob3IgY2F0Y2hhbGwgXCIqXCIpIGFuZCBkZXN0aW5hdGlvbiB0eXBlcyB3aXRoIGEgc2luZ2xlIHNwYWNlXG5cdFx0Y29udmVydGVyczoge1xuXG5cdFx0XHQvLyBDb252ZXJ0IGFueXRoaW5nIHRvIHRleHRcblx0XHRcdFwiKiB0ZXh0XCI6IFN0cmluZyxcblxuXHRcdFx0Ly8gVGV4dCB0byBodG1sICh0cnVlID0gbm8gdHJhbnNmb3JtYXRpb24pXG5cdFx0XHRcInRleHQgaHRtbFwiOiB0cnVlLFxuXG5cdFx0XHQvLyBFdmFsdWF0ZSB0ZXh0IGFzIGEganNvbiBleHByZXNzaW9uXG5cdFx0XHRcInRleHQganNvblwiOiBKU09OLnBhcnNlLFxuXG5cdFx0XHQvLyBQYXJzZSB0ZXh0IGFzIHhtbFxuXHRcdFx0XCJ0ZXh0IHhtbFwiOiBqUXVlcnkucGFyc2VYTUxcblx0XHR9LFxuXG5cdFx0Ly8gRm9yIG9wdGlvbnMgdGhhdCBzaG91bGRuJ3QgYmUgZGVlcCBleHRlbmRlZDpcblx0XHQvLyB5b3UgY2FuIGFkZCB5b3VyIG93biBjdXN0b20gb3B0aW9ucyBoZXJlIGlmXG5cdFx0Ly8gYW5kIHdoZW4geW91IGNyZWF0ZSBvbmUgdGhhdCBzaG91bGRuJ3QgYmVcblx0XHQvLyBkZWVwIGV4dGVuZGVkIChzZWUgYWpheEV4dGVuZClcblx0XHRmbGF0T3B0aW9uczoge1xuXHRcdFx0dXJsOiB0cnVlLFxuXHRcdFx0Y29udGV4dDogdHJ1ZVxuXHRcdH1cblx0fSxcblxuXHQvLyBDcmVhdGVzIGEgZnVsbCBmbGVkZ2VkIHNldHRpbmdzIG9iamVjdCBpbnRvIHRhcmdldFxuXHQvLyB3aXRoIGJvdGggYWpheFNldHRpbmdzIGFuZCBzZXR0aW5ncyBmaWVsZHMuXG5cdC8vIElmIHRhcmdldCBpcyBvbWl0dGVkLCB3cml0ZXMgaW50byBhamF4U2V0dGluZ3MuXG5cdGFqYXhTZXR1cDogZnVuY3Rpb24oIHRhcmdldCwgc2V0dGluZ3MgKSB7XG5cdFx0cmV0dXJuIHNldHRpbmdzID9cblxuXHRcdFx0Ly8gQnVpbGRpbmcgYSBzZXR0aW5ncyBvYmplY3Rcblx0XHRcdGFqYXhFeHRlbmQoIGFqYXhFeHRlbmQoIHRhcmdldCwgalF1ZXJ5LmFqYXhTZXR0aW5ncyApLCBzZXR0aW5ncyApIDpcblxuXHRcdFx0Ly8gRXh0ZW5kaW5nIGFqYXhTZXR0aW5nc1xuXHRcdFx0YWpheEV4dGVuZCggalF1ZXJ5LmFqYXhTZXR0aW5ncywgdGFyZ2V0ICk7XG5cdH0sXG5cblx0YWpheFByZWZpbHRlcjogYWRkVG9QcmVmaWx0ZXJzT3JUcmFuc3BvcnRzKCBwcmVmaWx0ZXJzICksXG5cdGFqYXhUcmFuc3BvcnQ6IGFkZFRvUHJlZmlsdGVyc09yVHJhbnNwb3J0cyggdHJhbnNwb3J0cyApLFxuXG5cdC8vIE1haW4gbWV0aG9kXG5cdGFqYXg6IGZ1bmN0aW9uKCB1cmwsIG9wdGlvbnMgKSB7XG5cblx0XHQvLyBJZiB1cmwgaXMgYW4gb2JqZWN0LCBzaW11bGF0ZSBwcmUtMS41IHNpZ25hdHVyZVxuXHRcdGlmICggdHlwZW9mIHVybCA9PT0gXCJvYmplY3RcIiApIHtcblx0XHRcdG9wdGlvbnMgPSB1cmw7XG5cdFx0XHR1cmwgPSB1bmRlZmluZWQ7XG5cdFx0fVxuXG5cdFx0Ly8gRm9yY2Ugb3B0aW9ucyB0byBiZSBhbiBvYmplY3Rcblx0XHRvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuXHRcdHZhciB0cmFuc3BvcnQsXG5cblx0XHRcdC8vIFVSTCB3aXRob3V0IGFudGktY2FjaGUgcGFyYW1cblx0XHRcdGNhY2hlVVJMLFxuXG5cdFx0XHQvLyBSZXNwb25zZSBoZWFkZXJzXG5cdFx0XHRyZXNwb25zZUhlYWRlcnNTdHJpbmcsXG5cdFx0XHRyZXNwb25zZUhlYWRlcnMsXG5cblx0XHRcdC8vIHRpbWVvdXQgaGFuZGxlXG5cdFx0XHR0aW1lb3V0VGltZXIsXG5cblx0XHRcdC8vIFVybCBjbGVhbnVwIHZhclxuXHRcdFx0dXJsQW5jaG9yLFxuXG5cdFx0XHQvLyBSZXF1ZXN0IHN0YXRlIChiZWNvbWVzIGZhbHNlIHVwb24gc2VuZCBhbmQgdHJ1ZSB1cG9uIGNvbXBsZXRpb24pXG5cdFx0XHRjb21wbGV0ZWQsXG5cblx0XHRcdC8vIFRvIGtub3cgaWYgZ2xvYmFsIGV2ZW50cyBhcmUgdG8gYmUgZGlzcGF0Y2hlZFxuXHRcdFx0ZmlyZUdsb2JhbHMsXG5cblx0XHRcdC8vIExvb3AgdmFyaWFibGVcblx0XHRcdGksXG5cblx0XHRcdC8vIHVuY2FjaGVkIHBhcnQgb2YgdGhlIHVybFxuXHRcdFx0dW5jYWNoZWQsXG5cblx0XHRcdC8vIENyZWF0ZSB0aGUgZmluYWwgb3B0aW9ucyBvYmplY3Rcblx0XHRcdHMgPSBqUXVlcnkuYWpheFNldHVwKCB7fSwgb3B0aW9ucyApLFxuXG5cdFx0XHQvLyBDYWxsYmFja3MgY29udGV4dFxuXHRcdFx0Y2FsbGJhY2tDb250ZXh0ID0gcy5jb250ZXh0IHx8IHMsXG5cblx0XHRcdC8vIENvbnRleHQgZm9yIGdsb2JhbCBldmVudHMgaXMgY2FsbGJhY2tDb250ZXh0IGlmIGl0IGlzIGEgRE9NIG5vZGUgb3IgalF1ZXJ5IGNvbGxlY3Rpb25cblx0XHRcdGdsb2JhbEV2ZW50Q29udGV4dCA9IHMuY29udGV4dCAmJlxuXHRcdFx0XHQoIGNhbGxiYWNrQ29udGV4dC5ub2RlVHlwZSB8fCBjYWxsYmFja0NvbnRleHQuanF1ZXJ5ICkgP1xuXHRcdFx0XHRcdGpRdWVyeSggY2FsbGJhY2tDb250ZXh0ICkgOlxuXHRcdFx0XHRcdGpRdWVyeS5ldmVudCxcblxuXHRcdFx0Ly8gRGVmZXJyZWRzXG5cdFx0XHRkZWZlcnJlZCA9IGpRdWVyeS5EZWZlcnJlZCgpLFxuXHRcdFx0Y29tcGxldGVEZWZlcnJlZCA9IGpRdWVyeS5DYWxsYmFja3MoIFwib25jZSBtZW1vcnlcIiApLFxuXG5cdFx0XHQvLyBTdGF0dXMtZGVwZW5kZW50IGNhbGxiYWNrc1xuXHRcdFx0c3RhdHVzQ29kZSA9IHMuc3RhdHVzQ29kZSB8fCB7fSxcblxuXHRcdFx0Ly8gSGVhZGVycyAodGhleSBhcmUgc2VudCBhbGwgYXQgb25jZSlcblx0XHRcdHJlcXVlc3RIZWFkZXJzID0ge30sXG5cdFx0XHRyZXF1ZXN0SGVhZGVyc05hbWVzID0ge30sXG5cblx0XHRcdC8vIERlZmF1bHQgYWJvcnQgbWVzc2FnZVxuXHRcdFx0c3RyQWJvcnQgPSBcImNhbmNlbGVkXCIsXG5cblx0XHRcdC8vIEZha2UgeGhyXG5cdFx0XHRqcVhIUiA9IHtcblx0XHRcdFx0cmVhZHlTdGF0ZTogMCxcblxuXHRcdFx0XHQvLyBCdWlsZHMgaGVhZGVycyBoYXNodGFibGUgaWYgbmVlZGVkXG5cdFx0XHRcdGdldFJlc3BvbnNlSGVhZGVyOiBmdW5jdGlvbigga2V5ICkge1xuXHRcdFx0XHRcdHZhciBtYXRjaDtcblx0XHRcdFx0XHRpZiAoIGNvbXBsZXRlZCApIHtcblx0XHRcdFx0XHRcdGlmICggIXJlc3BvbnNlSGVhZGVycyApIHtcblx0XHRcdFx0XHRcdFx0cmVzcG9uc2VIZWFkZXJzID0ge307XG5cdFx0XHRcdFx0XHRcdHdoaWxlICggKCBtYXRjaCA9IHJoZWFkZXJzLmV4ZWMoIHJlc3BvbnNlSGVhZGVyc1N0cmluZyApICkgKSB7XG5cdFx0XHRcdFx0XHRcdFx0cmVzcG9uc2VIZWFkZXJzWyBtYXRjaFsgMSBdLnRvTG93ZXJDYXNlKCkgKyBcIiBcIiBdID1cblx0XHRcdFx0XHRcdFx0XHRcdCggcmVzcG9uc2VIZWFkZXJzWyBtYXRjaFsgMSBdLnRvTG93ZXJDYXNlKCkgKyBcIiBcIiBdIHx8IFtdIClcblx0XHRcdFx0XHRcdFx0XHRcdFx0LmNvbmNhdCggbWF0Y2hbIDIgXSApO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRtYXRjaCA9IHJlc3BvbnNlSGVhZGVyc1sga2V5LnRvTG93ZXJDYXNlKCkgKyBcIiBcIiBdO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRyZXR1cm4gbWF0Y2ggPT0gbnVsbCA/IG51bGwgOiBtYXRjaC5qb2luKCBcIiwgXCIgKTtcblx0XHRcdFx0fSxcblxuXHRcdFx0XHQvLyBSYXcgc3RyaW5nXG5cdFx0XHRcdGdldEFsbFJlc3BvbnNlSGVhZGVyczogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0cmV0dXJuIGNvbXBsZXRlZCA/IHJlc3BvbnNlSGVhZGVyc1N0cmluZyA6IG51bGw7XG5cdFx0XHRcdH0sXG5cblx0XHRcdFx0Ly8gQ2FjaGVzIHRoZSBoZWFkZXJcblx0XHRcdFx0c2V0UmVxdWVzdEhlYWRlcjogZnVuY3Rpb24oIG5hbWUsIHZhbHVlICkge1xuXHRcdFx0XHRcdGlmICggY29tcGxldGVkID09IG51bGwgKSB7XG5cdFx0XHRcdFx0XHRuYW1lID0gcmVxdWVzdEhlYWRlcnNOYW1lc1sgbmFtZS50b0xvd2VyQ2FzZSgpIF0gPVxuXHRcdFx0XHRcdFx0XHRyZXF1ZXN0SGVhZGVyc05hbWVzWyBuYW1lLnRvTG93ZXJDYXNlKCkgXSB8fCBuYW1lO1xuXHRcdFx0XHRcdFx0cmVxdWVzdEhlYWRlcnNbIG5hbWUgXSA9IHZhbHVlO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRyZXR1cm4gdGhpcztcblx0XHRcdFx0fSxcblxuXHRcdFx0XHQvLyBPdmVycmlkZXMgcmVzcG9uc2UgY29udGVudC10eXBlIGhlYWRlclxuXHRcdFx0XHRvdmVycmlkZU1pbWVUeXBlOiBmdW5jdGlvbiggdHlwZSApIHtcblx0XHRcdFx0XHRpZiAoIGNvbXBsZXRlZCA9PSBudWxsICkge1xuXHRcdFx0XHRcdFx0cy5taW1lVHlwZSA9IHR5cGU7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHJldHVybiB0aGlzO1xuXHRcdFx0XHR9LFxuXG5cdFx0XHRcdC8vIFN0YXR1cy1kZXBlbmRlbnQgY2FsbGJhY2tzXG5cdFx0XHRcdHN0YXR1c0NvZGU6IGZ1bmN0aW9uKCBtYXAgKSB7XG5cdFx0XHRcdFx0dmFyIGNvZGU7XG5cdFx0XHRcdFx0aWYgKCBtYXAgKSB7XG5cdFx0XHRcdFx0XHRpZiAoIGNvbXBsZXRlZCApIHtcblxuXHRcdFx0XHRcdFx0XHQvLyBFeGVjdXRlIHRoZSBhcHByb3ByaWF0ZSBjYWxsYmFja3Ncblx0XHRcdFx0XHRcdFx0anFYSFIuYWx3YXlzKCBtYXBbIGpxWEhSLnN0YXR1cyBdICk7XG5cdFx0XHRcdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdFx0XHRcdC8vIExhenktYWRkIHRoZSBuZXcgY2FsbGJhY2tzIGluIGEgd2F5IHRoYXQgcHJlc2VydmVzIG9sZCBvbmVzXG5cdFx0XHRcdFx0XHRcdGZvciAoIGNvZGUgaW4gbWFwICkge1xuXHRcdFx0XHRcdFx0XHRcdHN0YXR1c0NvZGVbIGNvZGUgXSA9IFsgc3RhdHVzQ29kZVsgY29kZSBdLCBtYXBbIGNvZGUgXSBdO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHJldHVybiB0aGlzO1xuXHRcdFx0XHR9LFxuXG5cdFx0XHRcdC8vIENhbmNlbCB0aGUgcmVxdWVzdFxuXHRcdFx0XHRhYm9ydDogZnVuY3Rpb24oIHN0YXR1c1RleHQgKSB7XG5cdFx0XHRcdFx0dmFyIGZpbmFsVGV4dCA9IHN0YXR1c1RleHQgfHwgc3RyQWJvcnQ7XG5cdFx0XHRcdFx0aWYgKCB0cmFuc3BvcnQgKSB7XG5cdFx0XHRcdFx0XHR0cmFuc3BvcnQuYWJvcnQoIGZpbmFsVGV4dCApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRkb25lKCAwLCBmaW5hbFRleHQgKTtcblx0XHRcdFx0XHRyZXR1cm4gdGhpcztcblx0XHRcdFx0fVxuXHRcdFx0fTtcblxuXHRcdC8vIEF0dGFjaCBkZWZlcnJlZHNcblx0XHRkZWZlcnJlZC5wcm9taXNlKCBqcVhIUiApO1xuXG5cdFx0Ly8gQWRkIHByb3RvY29sIGlmIG5vdCBwcm92aWRlZCAocHJlZmlsdGVycyBtaWdodCBleHBlY3QgaXQpXG5cdFx0Ly8gSGFuZGxlIGZhbHN5IHVybCBpbiB0aGUgc2V0dGluZ3Mgb2JqZWN0ICgjMTAwOTM6IGNvbnNpc3RlbmN5IHdpdGggb2xkIHNpZ25hdHVyZSlcblx0XHQvLyBXZSBhbHNvIHVzZSB0aGUgdXJsIHBhcmFtZXRlciBpZiBhdmFpbGFibGVcblx0XHRzLnVybCA9ICggKCB1cmwgfHwgcy51cmwgfHwgbG9jYXRpb24uaHJlZiApICsgXCJcIiApXG5cdFx0XHQucmVwbGFjZSggcnByb3RvY29sLCBsb2NhdGlvbi5wcm90b2NvbCArIFwiLy9cIiApO1xuXG5cdFx0Ly8gQWxpYXMgbWV0aG9kIG9wdGlvbiB0byB0eXBlIGFzIHBlciB0aWNrZXQgIzEyMDA0XG5cdFx0cy50eXBlID0gb3B0aW9ucy5tZXRob2QgfHwgb3B0aW9ucy50eXBlIHx8IHMubWV0aG9kIHx8IHMudHlwZTtcblxuXHRcdC8vIEV4dHJhY3QgZGF0YVR5cGVzIGxpc3Rcblx0XHRzLmRhdGFUeXBlcyA9ICggcy5kYXRhVHlwZSB8fCBcIipcIiApLnRvTG93ZXJDYXNlKCkubWF0Y2goIHJub3RodG1sd2hpdGUgKSB8fCBbIFwiXCIgXTtcblxuXHRcdC8vIEEgY3Jvc3MtZG9tYWluIHJlcXVlc3QgaXMgaW4gb3JkZXIgd2hlbiB0aGUgb3JpZ2luIGRvZXNuJ3QgbWF0Y2ggdGhlIGN1cnJlbnQgb3JpZ2luLlxuXHRcdGlmICggcy5jcm9zc0RvbWFpbiA9PSBudWxsICkge1xuXHRcdFx0dXJsQW5jaG9yID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCggXCJhXCIgKTtcblxuXHRcdFx0Ly8gU3VwcG9ydDogSUUgPD04IC0gMTEsIEVkZ2UgMTIgLSAxNVxuXHRcdFx0Ly8gSUUgdGhyb3dzIGV4Y2VwdGlvbiBvbiBhY2Nlc3NpbmcgdGhlIGhyZWYgcHJvcGVydHkgaWYgdXJsIGlzIG1hbGZvcm1lZCxcblx0XHRcdC8vIGUuZy4gaHR0cDovL2V4YW1wbGUuY29tOjgweC9cblx0XHRcdHRyeSB7XG5cdFx0XHRcdHVybEFuY2hvci5ocmVmID0gcy51cmw7XG5cblx0XHRcdFx0Ly8gU3VwcG9ydDogSUUgPD04IC0gMTEgb25seVxuXHRcdFx0XHQvLyBBbmNob3IncyBob3N0IHByb3BlcnR5IGlzbid0IGNvcnJlY3RseSBzZXQgd2hlbiBzLnVybCBpcyByZWxhdGl2ZVxuXHRcdFx0XHR1cmxBbmNob3IuaHJlZiA9IHVybEFuY2hvci5ocmVmO1xuXHRcdFx0XHRzLmNyb3NzRG9tYWluID0gb3JpZ2luQW5jaG9yLnByb3RvY29sICsgXCIvL1wiICsgb3JpZ2luQW5jaG9yLmhvc3QgIT09XG5cdFx0XHRcdFx0dXJsQW5jaG9yLnByb3RvY29sICsgXCIvL1wiICsgdXJsQW5jaG9yLmhvc3Q7XG5cdFx0XHR9IGNhdGNoICggZSApIHtcblxuXHRcdFx0XHQvLyBJZiB0aGVyZSBpcyBhbiBlcnJvciBwYXJzaW5nIHRoZSBVUkwsIGFzc3VtZSBpdCBpcyBjcm9zc0RvbWFpbixcblx0XHRcdFx0Ly8gaXQgY2FuIGJlIHJlamVjdGVkIGJ5IHRoZSB0cmFuc3BvcnQgaWYgaXQgaXMgaW52YWxpZFxuXHRcdFx0XHRzLmNyb3NzRG9tYWluID0gdHJ1ZTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyBDb252ZXJ0IGRhdGEgaWYgbm90IGFscmVhZHkgYSBzdHJpbmdcblx0XHRpZiAoIHMuZGF0YSAmJiBzLnByb2Nlc3NEYXRhICYmIHR5cGVvZiBzLmRhdGEgIT09IFwic3RyaW5nXCIgKSB7XG5cdFx0XHRzLmRhdGEgPSBqUXVlcnkucGFyYW0oIHMuZGF0YSwgcy50cmFkaXRpb25hbCApO1xuXHRcdH1cblxuXHRcdC8vIEFwcGx5IHByZWZpbHRlcnNcblx0XHRpbnNwZWN0UHJlZmlsdGVyc09yVHJhbnNwb3J0cyggcHJlZmlsdGVycywgcywgb3B0aW9ucywganFYSFIgKTtcblxuXHRcdC8vIElmIHJlcXVlc3Qgd2FzIGFib3J0ZWQgaW5zaWRlIGEgcHJlZmlsdGVyLCBzdG9wIHRoZXJlXG5cdFx0aWYgKCBjb21wbGV0ZWQgKSB7XG5cdFx0XHRyZXR1cm4ganFYSFI7XG5cdFx0fVxuXG5cdFx0Ly8gV2UgY2FuIGZpcmUgZ2xvYmFsIGV2ZW50cyBhcyBvZiBub3cgaWYgYXNrZWQgdG9cblx0XHQvLyBEb24ndCBmaXJlIGV2ZW50cyBpZiBqUXVlcnkuZXZlbnQgaXMgdW5kZWZpbmVkIGluIGFuIEFNRC11c2FnZSBzY2VuYXJpbyAoIzE1MTE4KVxuXHRcdGZpcmVHbG9iYWxzID0galF1ZXJ5LmV2ZW50ICYmIHMuZ2xvYmFsO1xuXG5cdFx0Ly8gV2F0Y2ggZm9yIGEgbmV3IHNldCBvZiByZXF1ZXN0c1xuXHRcdGlmICggZmlyZUdsb2JhbHMgJiYgalF1ZXJ5LmFjdGl2ZSsrID09PSAwICkge1xuXHRcdFx0alF1ZXJ5LmV2ZW50LnRyaWdnZXIoIFwiYWpheFN0YXJ0XCIgKTtcblx0XHR9XG5cblx0XHQvLyBVcHBlcmNhc2UgdGhlIHR5cGVcblx0XHRzLnR5cGUgPSBzLnR5cGUudG9VcHBlckNhc2UoKTtcblxuXHRcdC8vIERldGVybWluZSBpZiByZXF1ZXN0IGhhcyBjb250ZW50XG5cdFx0cy5oYXNDb250ZW50ID0gIXJub0NvbnRlbnQudGVzdCggcy50eXBlICk7XG5cblx0XHQvLyBTYXZlIHRoZSBVUkwgaW4gY2FzZSB3ZSdyZSB0b3lpbmcgd2l0aCB0aGUgSWYtTW9kaWZpZWQtU2luY2Vcblx0XHQvLyBhbmQvb3IgSWYtTm9uZS1NYXRjaCBoZWFkZXIgbGF0ZXIgb25cblx0XHQvLyBSZW1vdmUgaGFzaCB0byBzaW1wbGlmeSB1cmwgbWFuaXB1bGF0aW9uXG5cdFx0Y2FjaGVVUkwgPSBzLnVybC5yZXBsYWNlKCByaGFzaCwgXCJcIiApO1xuXG5cdFx0Ly8gTW9yZSBvcHRpb25zIGhhbmRsaW5nIGZvciByZXF1ZXN0cyB3aXRoIG5vIGNvbnRlbnRcblx0XHRpZiAoICFzLmhhc0NvbnRlbnQgKSB7XG5cblx0XHRcdC8vIFJlbWVtYmVyIHRoZSBoYXNoIHNvIHdlIGNhbiBwdXQgaXQgYmFja1xuXHRcdFx0dW5jYWNoZWQgPSBzLnVybC5zbGljZSggY2FjaGVVUkwubGVuZ3RoICk7XG5cblx0XHRcdC8vIElmIGRhdGEgaXMgYXZhaWxhYmxlIGFuZCBzaG91bGQgYmUgcHJvY2Vzc2VkLCBhcHBlbmQgZGF0YSB0byB1cmxcblx0XHRcdGlmICggcy5kYXRhICYmICggcy5wcm9jZXNzRGF0YSB8fCB0eXBlb2Ygcy5kYXRhID09PSBcInN0cmluZ1wiICkgKSB7XG5cdFx0XHRcdGNhY2hlVVJMICs9ICggcnF1ZXJ5LnRlc3QoIGNhY2hlVVJMICkgPyBcIiZcIiA6IFwiP1wiICkgKyBzLmRhdGE7XG5cblx0XHRcdFx0Ly8gIzk2ODI6IHJlbW92ZSBkYXRhIHNvIHRoYXQgaXQncyBub3QgdXNlZCBpbiBhbiBldmVudHVhbCByZXRyeVxuXHRcdFx0XHRkZWxldGUgcy5kYXRhO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBBZGQgb3IgdXBkYXRlIGFudGktY2FjaGUgcGFyYW0gaWYgbmVlZGVkXG5cdFx0XHRpZiAoIHMuY2FjaGUgPT09IGZhbHNlICkge1xuXHRcdFx0XHRjYWNoZVVSTCA9IGNhY2hlVVJMLnJlcGxhY2UoIHJhbnRpQ2FjaGUsIFwiJDFcIiApO1xuXHRcdFx0XHR1bmNhY2hlZCA9ICggcnF1ZXJ5LnRlc3QoIGNhY2hlVVJMICkgPyBcIiZcIiA6IFwiP1wiICkgKyBcIl89XCIgKyAoIG5vbmNlKysgKSArIHVuY2FjaGVkO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBQdXQgaGFzaCBhbmQgYW50aS1jYWNoZSBvbiB0aGUgVVJMIHRoYXQgd2lsbCBiZSByZXF1ZXN0ZWQgKGdoLTE3MzIpXG5cdFx0XHRzLnVybCA9IGNhY2hlVVJMICsgdW5jYWNoZWQ7XG5cblx0XHQvLyBDaGFuZ2UgJyUyMCcgdG8gJysnIGlmIHRoaXMgaXMgZW5jb2RlZCBmb3JtIGJvZHkgY29udGVudCAoZ2gtMjY1OClcblx0XHR9IGVsc2UgaWYgKCBzLmRhdGEgJiYgcy5wcm9jZXNzRGF0YSAmJlxuXHRcdFx0KCBzLmNvbnRlbnRUeXBlIHx8IFwiXCIgKS5pbmRleE9mKCBcImFwcGxpY2F0aW9uL3gtd3d3LWZvcm0tdXJsZW5jb2RlZFwiICkgPT09IDAgKSB7XG5cdFx0XHRzLmRhdGEgPSBzLmRhdGEucmVwbGFjZSggcjIwLCBcIitcIiApO1xuXHRcdH1cblxuXHRcdC8vIFNldCB0aGUgSWYtTW9kaWZpZWQtU2luY2UgYW5kL29yIElmLU5vbmUtTWF0Y2ggaGVhZGVyLCBpZiBpbiBpZk1vZGlmaWVkIG1vZGUuXG5cdFx0aWYgKCBzLmlmTW9kaWZpZWQgKSB7XG5cdFx0XHRpZiAoIGpRdWVyeS5sYXN0TW9kaWZpZWRbIGNhY2hlVVJMIF0gKSB7XG5cdFx0XHRcdGpxWEhSLnNldFJlcXVlc3RIZWFkZXIoIFwiSWYtTW9kaWZpZWQtU2luY2VcIiwgalF1ZXJ5Lmxhc3RNb2RpZmllZFsgY2FjaGVVUkwgXSApO1xuXHRcdFx0fVxuXHRcdFx0aWYgKCBqUXVlcnkuZXRhZ1sgY2FjaGVVUkwgXSApIHtcblx0XHRcdFx0anFYSFIuc2V0UmVxdWVzdEhlYWRlciggXCJJZi1Ob25lLU1hdGNoXCIsIGpRdWVyeS5ldGFnWyBjYWNoZVVSTCBdICk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gU2V0IHRoZSBjb3JyZWN0IGhlYWRlciwgaWYgZGF0YSBpcyBiZWluZyBzZW50XG5cdFx0aWYgKCBzLmRhdGEgJiYgcy5oYXNDb250ZW50ICYmIHMuY29udGVudFR5cGUgIT09IGZhbHNlIHx8IG9wdGlvbnMuY29udGVudFR5cGUgKSB7XG5cdFx0XHRqcVhIUi5zZXRSZXF1ZXN0SGVhZGVyKCBcIkNvbnRlbnQtVHlwZVwiLCBzLmNvbnRlbnRUeXBlICk7XG5cdFx0fVxuXG5cdFx0Ly8gU2V0IHRoZSBBY2NlcHRzIGhlYWRlciBmb3IgdGhlIHNlcnZlciwgZGVwZW5kaW5nIG9uIHRoZSBkYXRhVHlwZVxuXHRcdGpxWEhSLnNldFJlcXVlc3RIZWFkZXIoXG5cdFx0XHRcIkFjY2VwdFwiLFxuXHRcdFx0cy5kYXRhVHlwZXNbIDAgXSAmJiBzLmFjY2VwdHNbIHMuZGF0YVR5cGVzWyAwIF0gXSA/XG5cdFx0XHRcdHMuYWNjZXB0c1sgcy5kYXRhVHlwZXNbIDAgXSBdICtcblx0XHRcdFx0XHQoIHMuZGF0YVR5cGVzWyAwIF0gIT09IFwiKlwiID8gXCIsIFwiICsgYWxsVHlwZXMgKyBcIjsgcT0wLjAxXCIgOiBcIlwiICkgOlxuXHRcdFx0XHRzLmFjY2VwdHNbIFwiKlwiIF1cblx0XHQpO1xuXG5cdFx0Ly8gQ2hlY2sgZm9yIGhlYWRlcnMgb3B0aW9uXG5cdFx0Zm9yICggaSBpbiBzLmhlYWRlcnMgKSB7XG5cdFx0XHRqcVhIUi5zZXRSZXF1ZXN0SGVhZGVyKCBpLCBzLmhlYWRlcnNbIGkgXSApO1xuXHRcdH1cblxuXHRcdC8vIEFsbG93IGN1c3RvbSBoZWFkZXJzL21pbWV0eXBlcyBhbmQgZWFybHkgYWJvcnRcblx0XHRpZiAoIHMuYmVmb3JlU2VuZCAmJlxuXHRcdFx0KCBzLmJlZm9yZVNlbmQuY2FsbCggY2FsbGJhY2tDb250ZXh0LCBqcVhIUiwgcyApID09PSBmYWxzZSB8fCBjb21wbGV0ZWQgKSApIHtcblxuXHRcdFx0Ly8gQWJvcnQgaWYgbm90IGRvbmUgYWxyZWFkeSBhbmQgcmV0dXJuXG5cdFx0XHRyZXR1cm4ganFYSFIuYWJvcnQoKTtcblx0XHR9XG5cblx0XHQvLyBBYm9ydGluZyBpcyBubyBsb25nZXIgYSBjYW5jZWxsYXRpb25cblx0XHRzdHJBYm9ydCA9IFwiYWJvcnRcIjtcblxuXHRcdC8vIEluc3RhbGwgY2FsbGJhY2tzIG9uIGRlZmVycmVkc1xuXHRcdGNvbXBsZXRlRGVmZXJyZWQuYWRkKCBzLmNvbXBsZXRlICk7XG5cdFx0anFYSFIuZG9uZSggcy5zdWNjZXNzICk7XG5cdFx0anFYSFIuZmFpbCggcy5lcnJvciApO1xuXG5cdFx0Ly8gR2V0IHRyYW5zcG9ydFxuXHRcdHRyYW5zcG9ydCA9IGluc3BlY3RQcmVmaWx0ZXJzT3JUcmFuc3BvcnRzKCB0cmFuc3BvcnRzLCBzLCBvcHRpb25zLCBqcVhIUiApO1xuXG5cdFx0Ly8gSWYgbm8gdHJhbnNwb3J0LCB3ZSBhdXRvLWFib3J0XG5cdFx0aWYgKCAhdHJhbnNwb3J0ICkge1xuXHRcdFx0ZG9uZSggLTEsIFwiTm8gVHJhbnNwb3J0XCIgKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0anFYSFIucmVhZHlTdGF0ZSA9IDE7XG5cblx0XHRcdC8vIFNlbmQgZ2xvYmFsIGV2ZW50XG5cdFx0XHRpZiAoIGZpcmVHbG9iYWxzICkge1xuXHRcdFx0XHRnbG9iYWxFdmVudENvbnRleHQudHJpZ2dlciggXCJhamF4U2VuZFwiLCBbIGpxWEhSLCBzIF0gKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gSWYgcmVxdWVzdCB3YXMgYWJvcnRlZCBpbnNpZGUgYWpheFNlbmQsIHN0b3AgdGhlcmVcblx0XHRcdGlmICggY29tcGxldGVkICkge1xuXHRcdFx0XHRyZXR1cm4ganFYSFI7XG5cdFx0XHR9XG5cblx0XHRcdC8vIFRpbWVvdXRcblx0XHRcdGlmICggcy5hc3luYyAmJiBzLnRpbWVvdXQgPiAwICkge1xuXHRcdFx0XHR0aW1lb3V0VGltZXIgPSB3aW5kb3cuc2V0VGltZW91dCggZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0anFYSFIuYWJvcnQoIFwidGltZW91dFwiICk7XG5cdFx0XHRcdH0sIHMudGltZW91dCApO1xuXHRcdFx0fVxuXG5cdFx0XHR0cnkge1xuXHRcdFx0XHRjb21wbGV0ZWQgPSBmYWxzZTtcblx0XHRcdFx0dHJhbnNwb3J0LnNlbmQoIHJlcXVlc3RIZWFkZXJzLCBkb25lICk7XG5cdFx0XHR9IGNhdGNoICggZSApIHtcblxuXHRcdFx0XHQvLyBSZXRocm93IHBvc3QtY29tcGxldGlvbiBleGNlcHRpb25zXG5cdFx0XHRcdGlmICggY29tcGxldGVkICkge1xuXHRcdFx0XHRcdHRocm93IGU7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBQcm9wYWdhdGUgb3RoZXJzIGFzIHJlc3VsdHNcblx0XHRcdFx0ZG9uZSggLTEsIGUgKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyBDYWxsYmFjayBmb3Igd2hlbiBldmVyeXRoaW5nIGlzIGRvbmVcblx0XHRmdW5jdGlvbiBkb25lKCBzdGF0dXMsIG5hdGl2ZVN0YXR1c1RleHQsIHJlc3BvbnNlcywgaGVhZGVycyApIHtcblx0XHRcdHZhciBpc1N1Y2Nlc3MsIHN1Y2Nlc3MsIGVycm9yLCByZXNwb25zZSwgbW9kaWZpZWQsXG5cdFx0XHRcdHN0YXR1c1RleHQgPSBuYXRpdmVTdGF0dXNUZXh0O1xuXG5cdFx0XHQvLyBJZ25vcmUgcmVwZWF0IGludm9jYXRpb25zXG5cdFx0XHRpZiAoIGNvbXBsZXRlZCApIHtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXG5cdFx0XHRjb21wbGV0ZWQgPSB0cnVlO1xuXG5cdFx0XHQvLyBDbGVhciB0aW1lb3V0IGlmIGl0IGV4aXN0c1xuXHRcdFx0aWYgKCB0aW1lb3V0VGltZXIgKSB7XG5cdFx0XHRcdHdpbmRvdy5jbGVhclRpbWVvdXQoIHRpbWVvdXRUaW1lciApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBEZXJlZmVyZW5jZSB0cmFuc3BvcnQgZm9yIGVhcmx5IGdhcmJhZ2UgY29sbGVjdGlvblxuXHRcdFx0Ly8gKG5vIG1hdHRlciBob3cgbG9uZyB0aGUganFYSFIgb2JqZWN0IHdpbGwgYmUgdXNlZClcblx0XHRcdHRyYW5zcG9ydCA9IHVuZGVmaW5lZDtcblxuXHRcdFx0Ly8gQ2FjaGUgcmVzcG9uc2UgaGVhZGVyc1xuXHRcdFx0cmVzcG9uc2VIZWFkZXJzU3RyaW5nID0gaGVhZGVycyB8fCBcIlwiO1xuXG5cdFx0XHQvLyBTZXQgcmVhZHlTdGF0ZVxuXHRcdFx0anFYSFIucmVhZHlTdGF0ZSA9IHN0YXR1cyA+IDAgPyA0IDogMDtcblxuXHRcdFx0Ly8gRGV0ZXJtaW5lIGlmIHN1Y2Nlc3NmdWxcblx0XHRcdGlzU3VjY2VzcyA9IHN0YXR1cyA+PSAyMDAgJiYgc3RhdHVzIDwgMzAwIHx8IHN0YXR1cyA9PT0gMzA0O1xuXG5cdFx0XHQvLyBHZXQgcmVzcG9uc2UgZGF0YVxuXHRcdFx0aWYgKCByZXNwb25zZXMgKSB7XG5cdFx0XHRcdHJlc3BvbnNlID0gYWpheEhhbmRsZVJlc3BvbnNlcyggcywganFYSFIsIHJlc3BvbnNlcyApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBDb252ZXJ0IG5vIG1hdHRlciB3aGF0ICh0aGF0IHdheSByZXNwb25zZVhYWCBmaWVsZHMgYXJlIGFsd2F5cyBzZXQpXG5cdFx0XHRyZXNwb25zZSA9IGFqYXhDb252ZXJ0KCBzLCByZXNwb25zZSwganFYSFIsIGlzU3VjY2VzcyApO1xuXG5cdFx0XHQvLyBJZiBzdWNjZXNzZnVsLCBoYW5kbGUgdHlwZSBjaGFpbmluZ1xuXHRcdFx0aWYgKCBpc1N1Y2Nlc3MgKSB7XG5cblx0XHRcdFx0Ly8gU2V0IHRoZSBJZi1Nb2RpZmllZC1TaW5jZSBhbmQvb3IgSWYtTm9uZS1NYXRjaCBoZWFkZXIsIGlmIGluIGlmTW9kaWZpZWQgbW9kZS5cblx0XHRcdFx0aWYgKCBzLmlmTW9kaWZpZWQgKSB7XG5cdFx0XHRcdFx0bW9kaWZpZWQgPSBqcVhIUi5nZXRSZXNwb25zZUhlYWRlciggXCJMYXN0LU1vZGlmaWVkXCIgKTtcblx0XHRcdFx0XHRpZiAoIG1vZGlmaWVkICkge1xuXHRcdFx0XHRcdFx0alF1ZXJ5Lmxhc3RNb2RpZmllZFsgY2FjaGVVUkwgXSA9IG1vZGlmaWVkO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRtb2RpZmllZCA9IGpxWEhSLmdldFJlc3BvbnNlSGVhZGVyKCBcImV0YWdcIiApO1xuXHRcdFx0XHRcdGlmICggbW9kaWZpZWQgKSB7XG5cdFx0XHRcdFx0XHRqUXVlcnkuZXRhZ1sgY2FjaGVVUkwgXSA9IG1vZGlmaWVkO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIGlmIG5vIGNvbnRlbnRcblx0XHRcdFx0aWYgKCBzdGF0dXMgPT09IDIwNCB8fCBzLnR5cGUgPT09IFwiSEVBRFwiICkge1xuXHRcdFx0XHRcdHN0YXR1c1RleHQgPSBcIm5vY29udGVudFwiO1xuXG5cdFx0XHRcdC8vIGlmIG5vdCBtb2RpZmllZFxuXHRcdFx0XHR9IGVsc2UgaWYgKCBzdGF0dXMgPT09IDMwNCApIHtcblx0XHRcdFx0XHRzdGF0dXNUZXh0ID0gXCJub3Rtb2RpZmllZFwiO1xuXG5cdFx0XHRcdC8vIElmIHdlIGhhdmUgZGF0YSwgbGV0J3MgY29udmVydCBpdFxuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHN0YXR1c1RleHQgPSByZXNwb25zZS5zdGF0ZTtcblx0XHRcdFx0XHRzdWNjZXNzID0gcmVzcG9uc2UuZGF0YTtcblx0XHRcdFx0XHRlcnJvciA9IHJlc3BvbnNlLmVycm9yO1xuXHRcdFx0XHRcdGlzU3VjY2VzcyA9ICFlcnJvcjtcblx0XHRcdFx0fVxuXHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHQvLyBFeHRyYWN0IGVycm9yIGZyb20gc3RhdHVzVGV4dCBhbmQgbm9ybWFsaXplIGZvciBub24tYWJvcnRzXG5cdFx0XHRcdGVycm9yID0gc3RhdHVzVGV4dDtcblx0XHRcdFx0aWYgKCBzdGF0dXMgfHwgIXN0YXR1c1RleHQgKSB7XG5cdFx0XHRcdFx0c3RhdHVzVGV4dCA9IFwiZXJyb3JcIjtcblx0XHRcdFx0XHRpZiAoIHN0YXR1cyA8IDAgKSB7XG5cdFx0XHRcdFx0XHRzdGF0dXMgPSAwO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHQvLyBTZXQgZGF0YSBmb3IgdGhlIGZha2UgeGhyIG9iamVjdFxuXHRcdFx0anFYSFIuc3RhdHVzID0gc3RhdHVzO1xuXHRcdFx0anFYSFIuc3RhdHVzVGV4dCA9ICggbmF0aXZlU3RhdHVzVGV4dCB8fCBzdGF0dXNUZXh0ICkgKyBcIlwiO1xuXG5cdFx0XHQvLyBTdWNjZXNzL0Vycm9yXG5cdFx0XHRpZiAoIGlzU3VjY2VzcyApIHtcblx0XHRcdFx0ZGVmZXJyZWQucmVzb2x2ZVdpdGgoIGNhbGxiYWNrQ29udGV4dCwgWyBzdWNjZXNzLCBzdGF0dXNUZXh0LCBqcVhIUiBdICk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRkZWZlcnJlZC5yZWplY3RXaXRoKCBjYWxsYmFja0NvbnRleHQsIFsganFYSFIsIHN0YXR1c1RleHQsIGVycm9yIF0gKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gU3RhdHVzLWRlcGVuZGVudCBjYWxsYmFja3Ncblx0XHRcdGpxWEhSLnN0YXR1c0NvZGUoIHN0YXR1c0NvZGUgKTtcblx0XHRcdHN0YXR1c0NvZGUgPSB1bmRlZmluZWQ7XG5cblx0XHRcdGlmICggZmlyZUdsb2JhbHMgKSB7XG5cdFx0XHRcdGdsb2JhbEV2ZW50Q29udGV4dC50cmlnZ2VyKCBpc1N1Y2Nlc3MgPyBcImFqYXhTdWNjZXNzXCIgOiBcImFqYXhFcnJvclwiLFxuXHRcdFx0XHRcdFsganFYSFIsIHMsIGlzU3VjY2VzcyA/IHN1Y2Nlc3MgOiBlcnJvciBdICk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIENvbXBsZXRlXG5cdFx0XHRjb21wbGV0ZURlZmVycmVkLmZpcmVXaXRoKCBjYWxsYmFja0NvbnRleHQsIFsganFYSFIsIHN0YXR1c1RleHQgXSApO1xuXG5cdFx0XHRpZiAoIGZpcmVHbG9iYWxzICkge1xuXHRcdFx0XHRnbG9iYWxFdmVudENvbnRleHQudHJpZ2dlciggXCJhamF4Q29tcGxldGVcIiwgWyBqcVhIUiwgcyBdICk7XG5cblx0XHRcdFx0Ly8gSGFuZGxlIHRoZSBnbG9iYWwgQUpBWCBjb3VudGVyXG5cdFx0XHRcdGlmICggISggLS1qUXVlcnkuYWN0aXZlICkgKSB7XG5cdFx0XHRcdFx0alF1ZXJ5LmV2ZW50LnRyaWdnZXIoIFwiYWpheFN0b3BcIiApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGpxWEhSO1xuXHR9LFxuXG5cdGdldEpTT046IGZ1bmN0aW9uKCB1cmwsIGRhdGEsIGNhbGxiYWNrICkge1xuXHRcdHJldHVybiBqUXVlcnkuZ2V0KCB1cmwsIGRhdGEsIGNhbGxiYWNrLCBcImpzb25cIiApO1xuXHR9LFxuXG5cdGdldFNjcmlwdDogZnVuY3Rpb24oIHVybCwgY2FsbGJhY2sgKSB7XG5cdFx0cmV0dXJuIGpRdWVyeS5nZXQoIHVybCwgdW5kZWZpbmVkLCBjYWxsYmFjaywgXCJzY3JpcHRcIiApO1xuXHR9XG59ICk7XG5cbmpRdWVyeS5lYWNoKCBbIFwiZ2V0XCIsIFwicG9zdFwiIF0sIGZ1bmN0aW9uKCBpLCBtZXRob2QgKSB7XG5cdGpRdWVyeVsgbWV0aG9kIF0gPSBmdW5jdGlvbiggdXJsLCBkYXRhLCBjYWxsYmFjaywgdHlwZSApIHtcblxuXHRcdC8vIFNoaWZ0IGFyZ3VtZW50cyBpZiBkYXRhIGFyZ3VtZW50IHdhcyBvbWl0dGVkXG5cdFx0aWYgKCBpc0Z1bmN0aW9uKCBkYXRhICkgKSB7XG5cdFx0XHR0eXBlID0gdHlwZSB8fCBjYWxsYmFjaztcblx0XHRcdGNhbGxiYWNrID0gZGF0YTtcblx0XHRcdGRhdGEgPSB1bmRlZmluZWQ7XG5cdFx0fVxuXG5cdFx0Ly8gVGhlIHVybCBjYW4gYmUgYW4gb3B0aW9ucyBvYmplY3QgKHdoaWNoIHRoZW4gbXVzdCBoYXZlIC51cmwpXG5cdFx0cmV0dXJuIGpRdWVyeS5hamF4KCBqUXVlcnkuZXh0ZW5kKCB7XG5cdFx0XHR1cmw6IHVybCxcblx0XHRcdHR5cGU6IG1ldGhvZCxcblx0XHRcdGRhdGFUeXBlOiB0eXBlLFxuXHRcdFx0ZGF0YTogZGF0YSxcblx0XHRcdHN1Y2Nlc3M6IGNhbGxiYWNrXG5cdFx0fSwgalF1ZXJ5LmlzUGxhaW5PYmplY3QoIHVybCApICYmIHVybCApICk7XG5cdH07XG59ICk7XG5cblxualF1ZXJ5Ll9ldmFsVXJsID0gZnVuY3Rpb24oIHVybCwgb3B0aW9ucyApIHtcblx0cmV0dXJuIGpRdWVyeS5hamF4KCB7XG5cdFx0dXJsOiB1cmwsXG5cblx0XHQvLyBNYWtlIHRoaXMgZXhwbGljaXQsIHNpbmNlIHVzZXIgY2FuIG92ZXJyaWRlIHRoaXMgdGhyb3VnaCBhamF4U2V0dXAgKCMxMTI2NClcblx0XHR0eXBlOiBcIkdFVFwiLFxuXHRcdGRhdGFUeXBlOiBcInNjcmlwdFwiLFxuXHRcdGNhY2hlOiB0cnVlLFxuXHRcdGFzeW5jOiBmYWxzZSxcblx0XHRnbG9iYWw6IGZhbHNlLFxuXG5cdFx0Ly8gT25seSBldmFsdWF0ZSB0aGUgcmVzcG9uc2UgaWYgaXQgaXMgc3VjY2Vzc2Z1bCAoZ2gtNDEyNilcblx0XHQvLyBkYXRhRmlsdGVyIGlzIG5vdCBpbnZva2VkIGZvciBmYWlsdXJlIHJlc3BvbnNlcywgc28gdXNpbmcgaXQgaW5zdGVhZFxuXHRcdC8vIG9mIHRoZSBkZWZhdWx0IGNvbnZlcnRlciBpcyBrbHVkZ3kgYnV0IGl0IHdvcmtzLlxuXHRcdGNvbnZlcnRlcnM6IHtcblx0XHRcdFwidGV4dCBzY3JpcHRcIjogZnVuY3Rpb24oKSB7fVxuXHRcdH0sXG5cdFx0ZGF0YUZpbHRlcjogZnVuY3Rpb24oIHJlc3BvbnNlICkge1xuXHRcdFx0alF1ZXJ5Lmdsb2JhbEV2YWwoIHJlc3BvbnNlLCBvcHRpb25zICk7XG5cdFx0fVxuXHR9ICk7XG59O1xuXG5cbmpRdWVyeS5mbi5leHRlbmQoIHtcblx0d3JhcEFsbDogZnVuY3Rpb24oIGh0bWwgKSB7XG5cdFx0dmFyIHdyYXA7XG5cblx0XHRpZiAoIHRoaXNbIDAgXSApIHtcblx0XHRcdGlmICggaXNGdW5jdGlvbiggaHRtbCApICkge1xuXHRcdFx0XHRodG1sID0gaHRtbC5jYWxsKCB0aGlzWyAwIF0gKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gVGhlIGVsZW1lbnRzIHRvIHdyYXAgdGhlIHRhcmdldCBhcm91bmRcblx0XHRcdHdyYXAgPSBqUXVlcnkoIGh0bWwsIHRoaXNbIDAgXS5vd25lckRvY3VtZW50ICkuZXEoIDAgKS5jbG9uZSggdHJ1ZSApO1xuXG5cdFx0XHRpZiAoIHRoaXNbIDAgXS5wYXJlbnROb2RlICkge1xuXHRcdFx0XHR3cmFwLmluc2VydEJlZm9yZSggdGhpc1sgMCBdICk7XG5cdFx0XHR9XG5cblx0XHRcdHdyYXAubWFwKCBmdW5jdGlvbigpIHtcblx0XHRcdFx0dmFyIGVsZW0gPSB0aGlzO1xuXG5cdFx0XHRcdHdoaWxlICggZWxlbS5maXJzdEVsZW1lbnRDaGlsZCApIHtcblx0XHRcdFx0XHRlbGVtID0gZWxlbS5maXJzdEVsZW1lbnRDaGlsZDtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdHJldHVybiBlbGVtO1xuXHRcdFx0fSApLmFwcGVuZCggdGhpcyApO1xuXHRcdH1cblxuXHRcdHJldHVybiB0aGlzO1xuXHR9LFxuXG5cdHdyYXBJbm5lcjogZnVuY3Rpb24oIGh0bWwgKSB7XG5cdFx0aWYgKCBpc0Z1bmN0aW9uKCBodG1sICkgKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5lYWNoKCBmdW5jdGlvbiggaSApIHtcblx0XHRcdFx0alF1ZXJ5KCB0aGlzICkud3JhcElubmVyKCBodG1sLmNhbGwoIHRoaXMsIGkgKSApO1xuXHRcdFx0fSApO1xuXHRcdH1cblxuXHRcdHJldHVybiB0aGlzLmVhY2goIGZ1bmN0aW9uKCkge1xuXHRcdFx0dmFyIHNlbGYgPSBqUXVlcnkoIHRoaXMgKSxcblx0XHRcdFx0Y29udGVudHMgPSBzZWxmLmNvbnRlbnRzKCk7XG5cblx0XHRcdGlmICggY29udGVudHMubGVuZ3RoICkge1xuXHRcdFx0XHRjb250ZW50cy53cmFwQWxsKCBodG1sICk7XG5cblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHNlbGYuYXBwZW5kKCBodG1sICk7XG5cdFx0XHR9XG5cdFx0fSApO1xuXHR9LFxuXG5cdHdyYXA6IGZ1bmN0aW9uKCBodG1sICkge1xuXHRcdHZhciBodG1sSXNGdW5jdGlvbiA9IGlzRnVuY3Rpb24oIGh0bWwgKTtcblxuXHRcdHJldHVybiB0aGlzLmVhY2goIGZ1bmN0aW9uKCBpICkge1xuXHRcdFx0alF1ZXJ5KCB0aGlzICkud3JhcEFsbCggaHRtbElzRnVuY3Rpb24gPyBodG1sLmNhbGwoIHRoaXMsIGkgKSA6IGh0bWwgKTtcblx0XHR9ICk7XG5cdH0sXG5cblx0dW53cmFwOiBmdW5jdGlvbiggc2VsZWN0b3IgKSB7XG5cdFx0dGhpcy5wYXJlbnQoIHNlbGVjdG9yICkubm90KCBcImJvZHlcIiApLmVhY2goIGZ1bmN0aW9uKCkge1xuXHRcdFx0alF1ZXJ5KCB0aGlzICkucmVwbGFjZVdpdGgoIHRoaXMuY2hpbGROb2RlcyApO1xuXHRcdH0gKTtcblx0XHRyZXR1cm4gdGhpcztcblx0fVxufSApO1xuXG5cbmpRdWVyeS5leHByLnBzZXVkb3MuaGlkZGVuID0gZnVuY3Rpb24oIGVsZW0gKSB7XG5cdHJldHVybiAhalF1ZXJ5LmV4cHIucHNldWRvcy52aXNpYmxlKCBlbGVtICk7XG59O1xualF1ZXJ5LmV4cHIucHNldWRvcy52aXNpYmxlID0gZnVuY3Rpb24oIGVsZW0gKSB7XG5cdHJldHVybiAhISggZWxlbS5vZmZzZXRXaWR0aCB8fCBlbGVtLm9mZnNldEhlaWdodCB8fCBlbGVtLmdldENsaWVudFJlY3RzKCkubGVuZ3RoICk7XG59O1xuXG5cblxuXG5qUXVlcnkuYWpheFNldHRpbmdzLnhociA9IGZ1bmN0aW9uKCkge1xuXHR0cnkge1xuXHRcdHJldHVybiBuZXcgd2luZG93LlhNTEh0dHBSZXF1ZXN0KCk7XG5cdH0gY2F0Y2ggKCBlICkge31cbn07XG5cbnZhciB4aHJTdWNjZXNzU3RhdHVzID0ge1xuXG5cdFx0Ly8gRmlsZSBwcm90b2NvbCBhbHdheXMgeWllbGRzIHN0YXR1cyBjb2RlIDAsIGFzc3VtZSAyMDBcblx0XHQwOiAyMDAsXG5cblx0XHQvLyBTdXBwb3J0OiBJRSA8PTkgb25seVxuXHRcdC8vICMxNDUwOiBzb21ldGltZXMgSUUgcmV0dXJucyAxMjIzIHdoZW4gaXQgc2hvdWxkIGJlIDIwNFxuXHRcdDEyMjM6IDIwNFxuXHR9LFxuXHR4aHJTdXBwb3J0ZWQgPSBqUXVlcnkuYWpheFNldHRpbmdzLnhocigpO1xuXG5zdXBwb3J0LmNvcnMgPSAhIXhoclN1cHBvcnRlZCAmJiAoIFwid2l0aENyZWRlbnRpYWxzXCIgaW4geGhyU3VwcG9ydGVkICk7XG5zdXBwb3J0LmFqYXggPSB4aHJTdXBwb3J0ZWQgPSAhIXhoclN1cHBvcnRlZDtcblxualF1ZXJ5LmFqYXhUcmFuc3BvcnQoIGZ1bmN0aW9uKCBvcHRpb25zICkge1xuXHR2YXIgY2FsbGJhY2ssIGVycm9yQ2FsbGJhY2s7XG5cblx0Ly8gQ3Jvc3MgZG9tYWluIG9ubHkgYWxsb3dlZCBpZiBzdXBwb3J0ZWQgdGhyb3VnaCBYTUxIdHRwUmVxdWVzdFxuXHRpZiAoIHN1cHBvcnQuY29ycyB8fCB4aHJTdXBwb3J0ZWQgJiYgIW9wdGlvbnMuY3Jvc3NEb21haW4gKSB7XG5cdFx0cmV0dXJuIHtcblx0XHRcdHNlbmQ6IGZ1bmN0aW9uKCBoZWFkZXJzLCBjb21wbGV0ZSApIHtcblx0XHRcdFx0dmFyIGksXG5cdFx0XHRcdFx0eGhyID0gb3B0aW9ucy54aHIoKTtcblxuXHRcdFx0XHR4aHIub3Blbihcblx0XHRcdFx0XHRvcHRpb25zLnR5cGUsXG5cdFx0XHRcdFx0b3B0aW9ucy51cmwsXG5cdFx0XHRcdFx0b3B0aW9ucy5hc3luYyxcblx0XHRcdFx0XHRvcHRpb25zLnVzZXJuYW1lLFxuXHRcdFx0XHRcdG9wdGlvbnMucGFzc3dvcmRcblx0XHRcdFx0KTtcblxuXHRcdFx0XHQvLyBBcHBseSBjdXN0b20gZmllbGRzIGlmIHByb3ZpZGVkXG5cdFx0XHRcdGlmICggb3B0aW9ucy54aHJGaWVsZHMgKSB7XG5cdFx0XHRcdFx0Zm9yICggaSBpbiBvcHRpb25zLnhockZpZWxkcyApIHtcblx0XHRcdFx0XHRcdHhoclsgaSBdID0gb3B0aW9ucy54aHJGaWVsZHNbIGkgXTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBPdmVycmlkZSBtaW1lIHR5cGUgaWYgbmVlZGVkXG5cdFx0XHRcdGlmICggb3B0aW9ucy5taW1lVHlwZSAmJiB4aHIub3ZlcnJpZGVNaW1lVHlwZSApIHtcblx0XHRcdFx0XHR4aHIub3ZlcnJpZGVNaW1lVHlwZSggb3B0aW9ucy5taW1lVHlwZSApO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gWC1SZXF1ZXN0ZWQtV2l0aCBoZWFkZXJcblx0XHRcdFx0Ly8gRm9yIGNyb3NzLWRvbWFpbiByZXF1ZXN0cywgc2VlaW5nIGFzIGNvbmRpdGlvbnMgZm9yIGEgcHJlZmxpZ2h0IGFyZVxuXHRcdFx0XHQvLyBha2luIHRvIGEgamlnc2F3IHB1enpsZSwgd2Ugc2ltcGx5IG5ldmVyIHNldCBpdCB0byBiZSBzdXJlLlxuXHRcdFx0XHQvLyAoaXQgY2FuIGFsd2F5cyBiZSBzZXQgb24gYSBwZXItcmVxdWVzdCBiYXNpcyBvciBldmVuIHVzaW5nIGFqYXhTZXR1cClcblx0XHRcdFx0Ly8gRm9yIHNhbWUtZG9tYWluIHJlcXVlc3RzLCB3b24ndCBjaGFuZ2UgaGVhZGVyIGlmIGFscmVhZHkgcHJvdmlkZWQuXG5cdFx0XHRcdGlmICggIW9wdGlvbnMuY3Jvc3NEb21haW4gJiYgIWhlYWRlcnNbIFwiWC1SZXF1ZXN0ZWQtV2l0aFwiIF0gKSB7XG5cdFx0XHRcdFx0aGVhZGVyc1sgXCJYLVJlcXVlc3RlZC1XaXRoXCIgXSA9IFwiWE1MSHR0cFJlcXVlc3RcIjtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIFNldCBoZWFkZXJzXG5cdFx0XHRcdGZvciAoIGkgaW4gaGVhZGVycyApIHtcblx0XHRcdFx0XHR4aHIuc2V0UmVxdWVzdEhlYWRlciggaSwgaGVhZGVyc1sgaSBdICk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBDYWxsYmFja1xuXHRcdFx0XHRjYWxsYmFjayA9IGZ1bmN0aW9uKCB0eXBlICkge1xuXHRcdFx0XHRcdHJldHVybiBmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRcdGlmICggY2FsbGJhY2sgKSB7XG5cdFx0XHRcdFx0XHRcdGNhbGxiYWNrID0gZXJyb3JDYWxsYmFjayA9IHhoci5vbmxvYWQgPVxuXHRcdFx0XHRcdFx0XHRcdHhoci5vbmVycm9yID0geGhyLm9uYWJvcnQgPSB4aHIub250aW1lb3V0ID1cblx0XHRcdFx0XHRcdFx0XHRcdHhoci5vbnJlYWR5c3RhdGVjaGFuZ2UgPSBudWxsO1xuXG5cdFx0XHRcdFx0XHRcdGlmICggdHlwZSA9PT0gXCJhYm9ydFwiICkge1xuXHRcdFx0XHRcdFx0XHRcdHhoci5hYm9ydCgpO1xuXHRcdFx0XHRcdFx0XHR9IGVsc2UgaWYgKCB0eXBlID09PSBcImVycm9yXCIgKSB7XG5cblx0XHRcdFx0XHRcdFx0XHQvLyBTdXBwb3J0OiBJRSA8PTkgb25seVxuXHRcdFx0XHRcdFx0XHRcdC8vIE9uIGEgbWFudWFsIG5hdGl2ZSBhYm9ydCwgSUU5IHRocm93c1xuXHRcdFx0XHRcdFx0XHRcdC8vIGVycm9ycyBvbiBhbnkgcHJvcGVydHkgYWNjZXNzIHRoYXQgaXMgbm90IHJlYWR5U3RhdGVcblx0XHRcdFx0XHRcdFx0XHRpZiAoIHR5cGVvZiB4aHIuc3RhdHVzICE9PSBcIm51bWJlclwiICkge1xuXHRcdFx0XHRcdFx0XHRcdFx0Y29tcGxldGUoIDAsIFwiZXJyb3JcIiApO1xuXHRcdFx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRjb21wbGV0ZShcblxuXHRcdFx0XHRcdFx0XHRcdFx0XHQvLyBGaWxlOiBwcm90b2NvbCBhbHdheXMgeWllbGRzIHN0YXR1cyAwOyBzZWUgIzg2MDUsICMxNDIwN1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR4aHIuc3RhdHVzLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHR4aHIuc3RhdHVzVGV4dFxuXHRcdFx0XHRcdFx0XHRcdFx0KTtcblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRcdFx0Y29tcGxldGUoXG5cdFx0XHRcdFx0XHRcdFx0XHR4aHJTdWNjZXNzU3RhdHVzWyB4aHIuc3RhdHVzIF0gfHwgeGhyLnN0YXR1cyxcblx0XHRcdFx0XHRcdFx0XHRcdHhoci5zdGF0dXNUZXh0LFxuXG5cdFx0XHRcdFx0XHRcdFx0XHQvLyBTdXBwb3J0OiBJRSA8PTkgb25seVxuXHRcdFx0XHRcdFx0XHRcdFx0Ly8gSUU5IGhhcyBubyBYSFIyIGJ1dCB0aHJvd3Mgb24gYmluYXJ5ICh0cmFjLTExNDI2KVxuXHRcdFx0XHRcdFx0XHRcdFx0Ly8gRm9yIFhIUjIgbm9uLXRleHQsIGxldCB0aGUgY2FsbGVyIGhhbmRsZSBpdCAoZ2gtMjQ5OClcblx0XHRcdFx0XHRcdFx0XHRcdCggeGhyLnJlc3BvbnNlVHlwZSB8fCBcInRleHRcIiApICE9PSBcInRleHRcIiAgfHxcblx0XHRcdFx0XHRcdFx0XHRcdHR5cGVvZiB4aHIucmVzcG9uc2VUZXh0ICE9PSBcInN0cmluZ1wiID9cblx0XHRcdFx0XHRcdFx0XHRcdFx0eyBiaW5hcnk6IHhoci5yZXNwb25zZSB9IDpcblx0XHRcdFx0XHRcdFx0XHRcdFx0eyB0ZXh0OiB4aHIucmVzcG9uc2VUZXh0IH0sXG5cdFx0XHRcdFx0XHRcdFx0XHR4aHIuZ2V0QWxsUmVzcG9uc2VIZWFkZXJzKClcblx0XHRcdFx0XHRcdFx0XHQpO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fTtcblx0XHRcdFx0fTtcblxuXHRcdFx0XHQvLyBMaXN0ZW4gdG8gZXZlbnRzXG5cdFx0XHRcdHhoci5vbmxvYWQgPSBjYWxsYmFjaygpO1xuXHRcdFx0XHRlcnJvckNhbGxiYWNrID0geGhyLm9uZXJyb3IgPSB4aHIub250aW1lb3V0ID0gY2FsbGJhY2soIFwiZXJyb3JcIiApO1xuXG5cdFx0XHRcdC8vIFN1cHBvcnQ6IElFIDkgb25seVxuXHRcdFx0XHQvLyBVc2Ugb25yZWFkeXN0YXRlY2hhbmdlIHRvIHJlcGxhY2Ugb25hYm9ydFxuXHRcdFx0XHQvLyB0byBoYW5kbGUgdW5jYXVnaHQgYWJvcnRzXG5cdFx0XHRcdGlmICggeGhyLm9uYWJvcnQgIT09IHVuZGVmaW5lZCApIHtcblx0XHRcdFx0XHR4aHIub25hYm9ydCA9IGVycm9yQ2FsbGJhY2s7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0eGhyLm9ucmVhZHlzdGF0ZWNoYW5nZSA9IGZ1bmN0aW9uKCkge1xuXG5cdFx0XHRcdFx0XHQvLyBDaGVjayByZWFkeVN0YXRlIGJlZm9yZSB0aW1lb3V0IGFzIGl0IGNoYW5nZXNcblx0XHRcdFx0XHRcdGlmICggeGhyLnJlYWR5U3RhdGUgPT09IDQgKSB7XG5cblx0XHRcdFx0XHRcdFx0Ly8gQWxsb3cgb25lcnJvciB0byBiZSBjYWxsZWQgZmlyc3QsXG5cdFx0XHRcdFx0XHRcdC8vIGJ1dCB0aGF0IHdpbGwgbm90IGhhbmRsZSBhIG5hdGl2ZSBhYm9ydFxuXHRcdFx0XHRcdFx0XHQvLyBBbHNvLCBzYXZlIGVycm9yQ2FsbGJhY2sgdG8gYSB2YXJpYWJsZVxuXHRcdFx0XHRcdFx0XHQvLyBhcyB4aHIub25lcnJvciBjYW5ub3QgYmUgYWNjZXNzZWRcblx0XHRcdFx0XHRcdFx0d2luZG93LnNldFRpbWVvdXQoIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdFx0XHRcdGlmICggY2FsbGJhY2sgKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRlcnJvckNhbGxiYWNrKCk7XG5cdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHR9ICk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIENyZWF0ZSB0aGUgYWJvcnQgY2FsbGJhY2tcblx0XHRcdFx0Y2FsbGJhY2sgPSBjYWxsYmFjayggXCJhYm9ydFwiICk7XG5cblx0XHRcdFx0dHJ5IHtcblxuXHRcdFx0XHRcdC8vIERvIHNlbmQgdGhlIHJlcXVlc3QgKHRoaXMgbWF5IHJhaXNlIGFuIGV4Y2VwdGlvbilcblx0XHRcdFx0XHR4aHIuc2VuZCggb3B0aW9ucy5oYXNDb250ZW50ICYmIG9wdGlvbnMuZGF0YSB8fCBudWxsICk7XG5cdFx0XHRcdH0gY2F0Y2ggKCBlICkge1xuXG5cdFx0XHRcdFx0Ly8gIzE0NjgzOiBPbmx5IHJldGhyb3cgaWYgdGhpcyBoYXNuJ3QgYmVlbiBub3RpZmllZCBhcyBhbiBlcnJvciB5ZXRcblx0XHRcdFx0XHRpZiAoIGNhbGxiYWNrICkge1xuXHRcdFx0XHRcdFx0dGhyb3cgZTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH0sXG5cblx0XHRcdGFib3J0OiBmdW5jdGlvbigpIHtcblx0XHRcdFx0aWYgKCBjYWxsYmFjayApIHtcblx0XHRcdFx0XHRjYWxsYmFjaygpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fTtcblx0fVxufSApO1xuXG5cblxuXG4vLyBQcmV2ZW50IGF1dG8tZXhlY3V0aW9uIG9mIHNjcmlwdHMgd2hlbiBubyBleHBsaWNpdCBkYXRhVHlwZSB3YXMgcHJvdmlkZWQgKFNlZSBnaC0yNDMyKVxualF1ZXJ5LmFqYXhQcmVmaWx0ZXIoIGZ1bmN0aW9uKCBzICkge1xuXHRpZiAoIHMuY3Jvc3NEb21haW4gKSB7XG5cdFx0cy5jb250ZW50cy5zY3JpcHQgPSBmYWxzZTtcblx0fVxufSApO1xuXG4vLyBJbnN0YWxsIHNjcmlwdCBkYXRhVHlwZVxualF1ZXJ5LmFqYXhTZXR1cCgge1xuXHRhY2NlcHRzOiB7XG5cdFx0c2NyaXB0OiBcInRleHQvamF2YXNjcmlwdCwgYXBwbGljYXRpb24vamF2YXNjcmlwdCwgXCIgK1xuXHRcdFx0XCJhcHBsaWNhdGlvbi9lY21hc2NyaXB0LCBhcHBsaWNhdGlvbi94LWVjbWFzY3JpcHRcIlxuXHR9LFxuXHRjb250ZW50czoge1xuXHRcdHNjcmlwdDogL1xcYig/OmphdmF8ZWNtYSlzY3JpcHRcXGIvXG5cdH0sXG5cdGNvbnZlcnRlcnM6IHtcblx0XHRcInRleHQgc2NyaXB0XCI6IGZ1bmN0aW9uKCB0ZXh0ICkge1xuXHRcdFx0alF1ZXJ5Lmdsb2JhbEV2YWwoIHRleHQgKTtcblx0XHRcdHJldHVybiB0ZXh0O1xuXHRcdH1cblx0fVxufSApO1xuXG4vLyBIYW5kbGUgY2FjaGUncyBzcGVjaWFsIGNhc2UgYW5kIGNyb3NzRG9tYWluXG5qUXVlcnkuYWpheFByZWZpbHRlciggXCJzY3JpcHRcIiwgZnVuY3Rpb24oIHMgKSB7XG5cdGlmICggcy5jYWNoZSA9PT0gdW5kZWZpbmVkICkge1xuXHRcdHMuY2FjaGUgPSBmYWxzZTtcblx0fVxuXHRpZiAoIHMuY3Jvc3NEb21haW4gKSB7XG5cdFx0cy50eXBlID0gXCJHRVRcIjtcblx0fVxufSApO1xuXG4vLyBCaW5kIHNjcmlwdCB0YWcgaGFjayB0cmFuc3BvcnRcbmpRdWVyeS5hamF4VHJhbnNwb3J0KCBcInNjcmlwdFwiLCBmdW5jdGlvbiggcyApIHtcblxuXHQvLyBUaGlzIHRyYW5zcG9ydCBvbmx5IGRlYWxzIHdpdGggY3Jvc3MgZG9tYWluIG9yIGZvcmNlZC1ieS1hdHRycyByZXF1ZXN0c1xuXHRpZiAoIHMuY3Jvc3NEb21haW4gfHwgcy5zY3JpcHRBdHRycyApIHtcblx0XHR2YXIgc2NyaXB0LCBjYWxsYmFjaztcblx0XHRyZXR1cm4ge1xuXHRcdFx0c2VuZDogZnVuY3Rpb24oIF8sIGNvbXBsZXRlICkge1xuXHRcdFx0XHRzY3JpcHQgPSBqUXVlcnkoIFwiPHNjcmlwdD5cIiApXG5cdFx0XHRcdFx0LmF0dHIoIHMuc2NyaXB0QXR0cnMgfHwge30gKVxuXHRcdFx0XHRcdC5wcm9wKCB7IGNoYXJzZXQ6IHMuc2NyaXB0Q2hhcnNldCwgc3JjOiBzLnVybCB9IClcblx0XHRcdFx0XHQub24oIFwibG9hZCBlcnJvclwiLCBjYWxsYmFjayA9IGZ1bmN0aW9uKCBldnQgKSB7XG5cdFx0XHRcdFx0XHRzY3JpcHQucmVtb3ZlKCk7XG5cdFx0XHRcdFx0XHRjYWxsYmFjayA9IG51bGw7XG5cdFx0XHRcdFx0XHRpZiAoIGV2dCApIHtcblx0XHRcdFx0XHRcdFx0Y29tcGxldGUoIGV2dC50eXBlID09PSBcImVycm9yXCIgPyA0MDQgOiAyMDAsIGV2dC50eXBlICk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fSApO1xuXG5cdFx0XHRcdC8vIFVzZSBuYXRpdmUgRE9NIG1hbmlwdWxhdGlvbiB0byBhdm9pZCBvdXIgZG9tTWFuaXAgQUpBWCB0cmlja2VyeVxuXHRcdFx0XHRkb2N1bWVudC5oZWFkLmFwcGVuZENoaWxkKCBzY3JpcHRbIDAgXSApO1xuXHRcdFx0fSxcblx0XHRcdGFib3J0OiBmdW5jdGlvbigpIHtcblx0XHRcdFx0aWYgKCBjYWxsYmFjayApIHtcblx0XHRcdFx0XHRjYWxsYmFjaygpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fTtcblx0fVxufSApO1xuXG5cblxuXG52YXIgb2xkQ2FsbGJhY2tzID0gW10sXG5cdHJqc29ucCA9IC8oPSlcXD8oPz0mfCQpfFxcP1xcPy87XG5cbi8vIERlZmF1bHQganNvbnAgc2V0dGluZ3NcbmpRdWVyeS5hamF4U2V0dXAoIHtcblx0anNvbnA6IFwiY2FsbGJhY2tcIixcblx0anNvbnBDYWxsYmFjazogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIGNhbGxiYWNrID0gb2xkQ2FsbGJhY2tzLnBvcCgpIHx8ICggalF1ZXJ5LmV4cGFuZG8gKyBcIl9cIiArICggbm9uY2UrKyApICk7XG5cdFx0dGhpc1sgY2FsbGJhY2sgXSA9IHRydWU7XG5cdFx0cmV0dXJuIGNhbGxiYWNrO1xuXHR9XG59ICk7XG5cbi8vIERldGVjdCwgbm9ybWFsaXplIG9wdGlvbnMgYW5kIGluc3RhbGwgY2FsbGJhY2tzIGZvciBqc29ucCByZXF1ZXN0c1xualF1ZXJ5LmFqYXhQcmVmaWx0ZXIoIFwianNvbiBqc29ucFwiLCBmdW5jdGlvbiggcywgb3JpZ2luYWxTZXR0aW5ncywganFYSFIgKSB7XG5cblx0dmFyIGNhbGxiYWNrTmFtZSwgb3ZlcndyaXR0ZW4sIHJlc3BvbnNlQ29udGFpbmVyLFxuXHRcdGpzb25Qcm9wID0gcy5qc29ucCAhPT0gZmFsc2UgJiYgKCByanNvbnAudGVzdCggcy51cmwgKSA/XG5cdFx0XHRcInVybFwiIDpcblx0XHRcdHR5cGVvZiBzLmRhdGEgPT09IFwic3RyaW5nXCIgJiZcblx0XHRcdFx0KCBzLmNvbnRlbnRUeXBlIHx8IFwiXCIgKVxuXHRcdFx0XHRcdC5pbmRleE9mKCBcImFwcGxpY2F0aW9uL3gtd3d3LWZvcm0tdXJsZW5jb2RlZFwiICkgPT09IDAgJiZcblx0XHRcdFx0cmpzb25wLnRlc3QoIHMuZGF0YSApICYmIFwiZGF0YVwiXG5cdFx0KTtcblxuXHQvLyBIYW5kbGUgaWZmIHRoZSBleHBlY3RlZCBkYXRhIHR5cGUgaXMgXCJqc29ucFwiIG9yIHdlIGhhdmUgYSBwYXJhbWV0ZXIgdG8gc2V0XG5cdGlmICgganNvblByb3AgfHwgcy5kYXRhVHlwZXNbIDAgXSA9PT0gXCJqc29ucFwiICkge1xuXG5cdFx0Ly8gR2V0IGNhbGxiYWNrIG5hbWUsIHJlbWVtYmVyaW5nIHByZWV4aXN0aW5nIHZhbHVlIGFzc29jaWF0ZWQgd2l0aCBpdFxuXHRcdGNhbGxiYWNrTmFtZSA9IHMuanNvbnBDYWxsYmFjayA9IGlzRnVuY3Rpb24oIHMuanNvbnBDYWxsYmFjayApID9cblx0XHRcdHMuanNvbnBDYWxsYmFjaygpIDpcblx0XHRcdHMuanNvbnBDYWxsYmFjaztcblxuXHRcdC8vIEluc2VydCBjYWxsYmFjayBpbnRvIHVybCBvciBmb3JtIGRhdGFcblx0XHRpZiAoIGpzb25Qcm9wICkge1xuXHRcdFx0c1sganNvblByb3AgXSA9IHNbIGpzb25Qcm9wIF0ucmVwbGFjZSggcmpzb25wLCBcIiQxXCIgKyBjYWxsYmFja05hbWUgKTtcblx0XHR9IGVsc2UgaWYgKCBzLmpzb25wICE9PSBmYWxzZSApIHtcblx0XHRcdHMudXJsICs9ICggcnF1ZXJ5LnRlc3QoIHMudXJsICkgPyBcIiZcIiA6IFwiP1wiICkgKyBzLmpzb25wICsgXCI9XCIgKyBjYWxsYmFja05hbWU7XG5cdFx0fVxuXG5cdFx0Ly8gVXNlIGRhdGEgY29udmVydGVyIHRvIHJldHJpZXZlIGpzb24gYWZ0ZXIgc2NyaXB0IGV4ZWN1dGlvblxuXHRcdHMuY29udmVydGVyc1sgXCJzY3JpcHQganNvblwiIF0gPSBmdW5jdGlvbigpIHtcblx0XHRcdGlmICggIXJlc3BvbnNlQ29udGFpbmVyICkge1xuXHRcdFx0XHRqUXVlcnkuZXJyb3IoIGNhbGxiYWNrTmFtZSArIFwiIHdhcyBub3QgY2FsbGVkXCIgKTtcblx0XHRcdH1cblx0XHRcdHJldHVybiByZXNwb25zZUNvbnRhaW5lclsgMCBdO1xuXHRcdH07XG5cblx0XHQvLyBGb3JjZSBqc29uIGRhdGFUeXBlXG5cdFx0cy5kYXRhVHlwZXNbIDAgXSA9IFwianNvblwiO1xuXG5cdFx0Ly8gSW5zdGFsbCBjYWxsYmFja1xuXHRcdG92ZXJ3cml0dGVuID0gd2luZG93WyBjYWxsYmFja05hbWUgXTtcblx0XHR3aW5kb3dbIGNhbGxiYWNrTmFtZSBdID0gZnVuY3Rpb24oKSB7XG5cdFx0XHRyZXNwb25zZUNvbnRhaW5lciA9IGFyZ3VtZW50cztcblx0XHR9O1xuXG5cdFx0Ly8gQ2xlYW4tdXAgZnVuY3Rpb24gKGZpcmVzIGFmdGVyIGNvbnZlcnRlcnMpXG5cdFx0anFYSFIuYWx3YXlzKCBmdW5jdGlvbigpIHtcblxuXHRcdFx0Ly8gSWYgcHJldmlvdXMgdmFsdWUgZGlkbid0IGV4aXN0IC0gcmVtb3ZlIGl0XG5cdFx0XHRpZiAoIG92ZXJ3cml0dGVuID09PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRcdGpRdWVyeSggd2luZG93ICkucmVtb3ZlUHJvcCggY2FsbGJhY2tOYW1lICk7XG5cblx0XHRcdC8vIE90aGVyd2lzZSByZXN0b3JlIHByZWV4aXN0aW5nIHZhbHVlXG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR3aW5kb3dbIGNhbGxiYWNrTmFtZSBdID0gb3ZlcndyaXR0ZW47XG5cdFx0XHR9XG5cblx0XHRcdC8vIFNhdmUgYmFjayBhcyBmcmVlXG5cdFx0XHRpZiAoIHNbIGNhbGxiYWNrTmFtZSBdICkge1xuXG5cdFx0XHRcdC8vIE1ha2Ugc3VyZSB0aGF0IHJlLXVzaW5nIHRoZSBvcHRpb25zIGRvZXNuJ3Qgc2NyZXcgdGhpbmdzIGFyb3VuZFxuXHRcdFx0XHRzLmpzb25wQ2FsbGJhY2sgPSBvcmlnaW5hbFNldHRpbmdzLmpzb25wQ2FsbGJhY2s7XG5cblx0XHRcdFx0Ly8gU2F2ZSB0aGUgY2FsbGJhY2sgbmFtZSBmb3IgZnV0dXJlIHVzZVxuXHRcdFx0XHRvbGRDYWxsYmFja3MucHVzaCggY2FsbGJhY2tOYW1lICk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIENhbGwgaWYgaXQgd2FzIGEgZnVuY3Rpb24gYW5kIHdlIGhhdmUgYSByZXNwb25zZVxuXHRcdFx0aWYgKCByZXNwb25zZUNvbnRhaW5lciAmJiBpc0Z1bmN0aW9uKCBvdmVyd3JpdHRlbiApICkge1xuXHRcdFx0XHRvdmVyd3JpdHRlbiggcmVzcG9uc2VDb250YWluZXJbIDAgXSApO1xuXHRcdFx0fVxuXG5cdFx0XHRyZXNwb25zZUNvbnRhaW5lciA9IG92ZXJ3cml0dGVuID0gdW5kZWZpbmVkO1xuXHRcdH0gKTtcblxuXHRcdC8vIERlbGVnYXRlIHRvIHNjcmlwdFxuXHRcdHJldHVybiBcInNjcmlwdFwiO1xuXHR9XG59ICk7XG5cblxuXG5cbi8vIFN1cHBvcnQ6IFNhZmFyaSA4IG9ubHlcbi8vIEluIFNhZmFyaSA4IGRvY3VtZW50cyBjcmVhdGVkIHZpYSBkb2N1bWVudC5pbXBsZW1lbnRhdGlvbi5jcmVhdGVIVE1MRG9jdW1lbnRcbi8vIGNvbGxhcHNlIHNpYmxpbmcgZm9ybXM6IHRoZSBzZWNvbmQgb25lIGJlY29tZXMgYSBjaGlsZCBvZiB0aGUgZmlyc3Qgb25lLlxuLy8gQmVjYXVzZSBvZiB0aGF0LCB0aGlzIHNlY3VyaXR5IG1lYXN1cmUgaGFzIHRvIGJlIGRpc2FibGVkIGluIFNhZmFyaSA4LlxuLy8gaHR0cHM6Ly9idWdzLndlYmtpdC5vcmcvc2hvd19idWcuY2dpP2lkPTEzNzMzN1xuc3VwcG9ydC5jcmVhdGVIVE1MRG9jdW1lbnQgPSAoIGZ1bmN0aW9uKCkge1xuXHR2YXIgYm9keSA9IGRvY3VtZW50LmltcGxlbWVudGF0aW9uLmNyZWF0ZUhUTUxEb2N1bWVudCggXCJcIiApLmJvZHk7XG5cdGJvZHkuaW5uZXJIVE1MID0gXCI8Zm9ybT48L2Zvcm0+PGZvcm0+PC9mb3JtPlwiO1xuXHRyZXR1cm4gYm9keS5jaGlsZE5vZGVzLmxlbmd0aCA9PT0gMjtcbn0gKSgpO1xuXG5cbi8vIEFyZ3VtZW50IFwiZGF0YVwiIHNob3VsZCBiZSBzdHJpbmcgb2YgaHRtbFxuLy8gY29udGV4dCAob3B0aW9uYWwpOiBJZiBzcGVjaWZpZWQsIHRoZSBmcmFnbWVudCB3aWxsIGJlIGNyZWF0ZWQgaW4gdGhpcyBjb250ZXh0LFxuLy8gZGVmYXVsdHMgdG8gZG9jdW1lbnRcbi8vIGtlZXBTY3JpcHRzIChvcHRpb25hbCk6IElmIHRydWUsIHdpbGwgaW5jbHVkZSBzY3JpcHRzIHBhc3NlZCBpbiB0aGUgaHRtbCBzdHJpbmdcbmpRdWVyeS5wYXJzZUhUTUwgPSBmdW5jdGlvbiggZGF0YSwgY29udGV4dCwga2VlcFNjcmlwdHMgKSB7XG5cdGlmICggdHlwZW9mIGRhdGEgIT09IFwic3RyaW5nXCIgKSB7XG5cdFx0cmV0dXJuIFtdO1xuXHR9XG5cdGlmICggdHlwZW9mIGNvbnRleHQgPT09IFwiYm9vbGVhblwiICkge1xuXHRcdGtlZXBTY3JpcHRzID0gY29udGV4dDtcblx0XHRjb250ZXh0ID0gZmFsc2U7XG5cdH1cblxuXHR2YXIgYmFzZSwgcGFyc2VkLCBzY3JpcHRzO1xuXG5cdGlmICggIWNvbnRleHQgKSB7XG5cblx0XHQvLyBTdG9wIHNjcmlwdHMgb3IgaW5saW5lIGV2ZW50IGhhbmRsZXJzIGZyb20gYmVpbmcgZXhlY3V0ZWQgaW1tZWRpYXRlbHlcblx0XHQvLyBieSB1c2luZyBkb2N1bWVudC5pbXBsZW1lbnRhdGlvblxuXHRcdGlmICggc3VwcG9ydC5jcmVhdGVIVE1MRG9jdW1lbnQgKSB7XG5cdFx0XHRjb250ZXh0ID0gZG9jdW1lbnQuaW1wbGVtZW50YXRpb24uY3JlYXRlSFRNTERvY3VtZW50KCBcIlwiICk7XG5cblx0XHRcdC8vIFNldCB0aGUgYmFzZSBocmVmIGZvciB0aGUgY3JlYXRlZCBkb2N1bWVudFxuXHRcdFx0Ly8gc28gYW55IHBhcnNlZCBlbGVtZW50cyB3aXRoIFVSTHNcblx0XHRcdC8vIGFyZSBiYXNlZCBvbiB0aGUgZG9jdW1lbnQncyBVUkwgKGdoLTI5NjUpXG5cdFx0XHRiYXNlID0gY29udGV4dC5jcmVhdGVFbGVtZW50KCBcImJhc2VcIiApO1xuXHRcdFx0YmFzZS5ocmVmID0gZG9jdW1lbnQubG9jYXRpb24uaHJlZjtcblx0XHRcdGNvbnRleHQuaGVhZC5hcHBlbmRDaGlsZCggYmFzZSApO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRjb250ZXh0ID0gZG9jdW1lbnQ7XG5cdFx0fVxuXHR9XG5cblx0cGFyc2VkID0gcnNpbmdsZVRhZy5leGVjKCBkYXRhICk7XG5cdHNjcmlwdHMgPSAha2VlcFNjcmlwdHMgJiYgW107XG5cblx0Ly8gU2luZ2xlIHRhZ1xuXHRpZiAoIHBhcnNlZCApIHtcblx0XHRyZXR1cm4gWyBjb250ZXh0LmNyZWF0ZUVsZW1lbnQoIHBhcnNlZFsgMSBdICkgXTtcblx0fVxuXG5cdHBhcnNlZCA9IGJ1aWxkRnJhZ21lbnQoIFsgZGF0YSBdLCBjb250ZXh0LCBzY3JpcHRzICk7XG5cblx0aWYgKCBzY3JpcHRzICYmIHNjcmlwdHMubGVuZ3RoICkge1xuXHRcdGpRdWVyeSggc2NyaXB0cyApLnJlbW92ZSgpO1xuXHR9XG5cblx0cmV0dXJuIGpRdWVyeS5tZXJnZSggW10sIHBhcnNlZC5jaGlsZE5vZGVzICk7XG59O1xuXG5cbi8qKlxuICogTG9hZCBhIHVybCBpbnRvIGEgcGFnZVxuICovXG5qUXVlcnkuZm4ubG9hZCA9IGZ1bmN0aW9uKCB1cmwsIHBhcmFtcywgY2FsbGJhY2sgKSB7XG5cdHZhciBzZWxlY3RvciwgdHlwZSwgcmVzcG9uc2UsXG5cdFx0c2VsZiA9IHRoaXMsXG5cdFx0b2ZmID0gdXJsLmluZGV4T2YoIFwiIFwiICk7XG5cblx0aWYgKCBvZmYgPiAtMSApIHtcblx0XHRzZWxlY3RvciA9IHN0cmlwQW5kQ29sbGFwc2UoIHVybC5zbGljZSggb2ZmICkgKTtcblx0XHR1cmwgPSB1cmwuc2xpY2UoIDAsIG9mZiApO1xuXHR9XG5cblx0Ly8gSWYgaXQncyBhIGZ1bmN0aW9uXG5cdGlmICggaXNGdW5jdGlvbiggcGFyYW1zICkgKSB7XG5cblx0XHQvLyBXZSBhc3N1bWUgdGhhdCBpdCdzIHRoZSBjYWxsYmFja1xuXHRcdGNhbGxiYWNrID0gcGFyYW1zO1xuXHRcdHBhcmFtcyA9IHVuZGVmaW5lZDtcblxuXHQvLyBPdGhlcndpc2UsIGJ1aWxkIGEgcGFyYW0gc3RyaW5nXG5cdH0gZWxzZSBpZiAoIHBhcmFtcyAmJiB0eXBlb2YgcGFyYW1zID09PSBcIm9iamVjdFwiICkge1xuXHRcdHR5cGUgPSBcIlBPU1RcIjtcblx0fVxuXG5cdC8vIElmIHdlIGhhdmUgZWxlbWVudHMgdG8gbW9kaWZ5LCBtYWtlIHRoZSByZXF1ZXN0XG5cdGlmICggc2VsZi5sZW5ndGggPiAwICkge1xuXHRcdGpRdWVyeS5hamF4KCB7XG5cdFx0XHR1cmw6IHVybCxcblxuXHRcdFx0Ly8gSWYgXCJ0eXBlXCIgdmFyaWFibGUgaXMgdW5kZWZpbmVkLCB0aGVuIFwiR0VUXCIgbWV0aG9kIHdpbGwgYmUgdXNlZC5cblx0XHRcdC8vIE1ha2UgdmFsdWUgb2YgdGhpcyBmaWVsZCBleHBsaWNpdCBzaW5jZVxuXHRcdFx0Ly8gdXNlciBjYW4gb3ZlcnJpZGUgaXQgdGhyb3VnaCBhamF4U2V0dXAgbWV0aG9kXG5cdFx0XHR0eXBlOiB0eXBlIHx8IFwiR0VUXCIsXG5cdFx0XHRkYXRhVHlwZTogXCJodG1sXCIsXG5cdFx0XHRkYXRhOiBwYXJhbXNcblx0XHR9ICkuZG9uZSggZnVuY3Rpb24oIHJlc3BvbnNlVGV4dCApIHtcblxuXHRcdFx0Ly8gU2F2ZSByZXNwb25zZSBmb3IgdXNlIGluIGNvbXBsZXRlIGNhbGxiYWNrXG5cdFx0XHRyZXNwb25zZSA9IGFyZ3VtZW50cztcblxuXHRcdFx0c2VsZi5odG1sKCBzZWxlY3RvciA/XG5cblx0XHRcdFx0Ly8gSWYgYSBzZWxlY3RvciB3YXMgc3BlY2lmaWVkLCBsb2NhdGUgdGhlIHJpZ2h0IGVsZW1lbnRzIGluIGEgZHVtbXkgZGl2XG5cdFx0XHRcdC8vIEV4Y2x1ZGUgc2NyaXB0cyB0byBhdm9pZCBJRSAnUGVybWlzc2lvbiBEZW5pZWQnIGVycm9yc1xuXHRcdFx0XHRqUXVlcnkoIFwiPGRpdj5cIiApLmFwcGVuZCggalF1ZXJ5LnBhcnNlSFRNTCggcmVzcG9uc2VUZXh0ICkgKS5maW5kKCBzZWxlY3RvciApIDpcblxuXHRcdFx0XHQvLyBPdGhlcndpc2UgdXNlIHRoZSBmdWxsIHJlc3VsdFxuXHRcdFx0XHRyZXNwb25zZVRleHQgKTtcblxuXHRcdC8vIElmIHRoZSByZXF1ZXN0IHN1Y2NlZWRzLCB0aGlzIGZ1bmN0aW9uIGdldHMgXCJkYXRhXCIsIFwic3RhdHVzXCIsIFwianFYSFJcIlxuXHRcdC8vIGJ1dCB0aGV5IGFyZSBpZ25vcmVkIGJlY2F1c2UgcmVzcG9uc2Ugd2FzIHNldCBhYm92ZS5cblx0XHQvLyBJZiBpdCBmYWlscywgdGhpcyBmdW5jdGlvbiBnZXRzIFwianFYSFJcIiwgXCJzdGF0dXNcIiwgXCJlcnJvclwiXG5cdFx0fSApLmFsd2F5cyggY2FsbGJhY2sgJiYgZnVuY3Rpb24oIGpxWEhSLCBzdGF0dXMgKSB7XG5cdFx0XHRzZWxmLmVhY2goIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRjYWxsYmFjay5hcHBseSggdGhpcywgcmVzcG9uc2UgfHwgWyBqcVhIUi5yZXNwb25zZVRleHQsIHN0YXR1cywganFYSFIgXSApO1xuXHRcdFx0fSApO1xuXHRcdH0gKTtcblx0fVxuXG5cdHJldHVybiB0aGlzO1xufTtcblxuXG5cblxuLy8gQXR0YWNoIGEgYnVuY2ggb2YgZnVuY3Rpb25zIGZvciBoYW5kbGluZyBjb21tb24gQUpBWCBldmVudHNcbmpRdWVyeS5lYWNoKCBbXG5cdFwiYWpheFN0YXJ0XCIsXG5cdFwiYWpheFN0b3BcIixcblx0XCJhamF4Q29tcGxldGVcIixcblx0XCJhamF4RXJyb3JcIixcblx0XCJhamF4U3VjY2Vzc1wiLFxuXHRcImFqYXhTZW5kXCJcbl0sIGZ1bmN0aW9uKCBpLCB0eXBlICkge1xuXHRqUXVlcnkuZm5bIHR5cGUgXSA9IGZ1bmN0aW9uKCBmbiApIHtcblx0XHRyZXR1cm4gdGhpcy5vbiggdHlwZSwgZm4gKTtcblx0fTtcbn0gKTtcblxuXG5cblxualF1ZXJ5LmV4cHIucHNldWRvcy5hbmltYXRlZCA9IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRyZXR1cm4galF1ZXJ5LmdyZXAoIGpRdWVyeS50aW1lcnMsIGZ1bmN0aW9uKCBmbiApIHtcblx0XHRyZXR1cm4gZWxlbSA9PT0gZm4uZWxlbTtcblx0fSApLmxlbmd0aDtcbn07XG5cblxuXG5cbmpRdWVyeS5vZmZzZXQgPSB7XG5cdHNldE9mZnNldDogZnVuY3Rpb24oIGVsZW0sIG9wdGlvbnMsIGkgKSB7XG5cdFx0dmFyIGN1clBvc2l0aW9uLCBjdXJMZWZ0LCBjdXJDU1NUb3AsIGN1clRvcCwgY3VyT2Zmc2V0LCBjdXJDU1NMZWZ0LCBjYWxjdWxhdGVQb3NpdGlvbixcblx0XHRcdHBvc2l0aW9uID0galF1ZXJ5LmNzcyggZWxlbSwgXCJwb3NpdGlvblwiICksXG5cdFx0XHRjdXJFbGVtID0galF1ZXJ5KCBlbGVtICksXG5cdFx0XHRwcm9wcyA9IHt9O1xuXG5cdFx0Ly8gU2V0IHBvc2l0aW9uIGZpcnN0LCBpbi1jYXNlIHRvcC9sZWZ0IGFyZSBzZXQgZXZlbiBvbiBzdGF0aWMgZWxlbVxuXHRcdGlmICggcG9zaXRpb24gPT09IFwic3RhdGljXCIgKSB7XG5cdFx0XHRlbGVtLnN0eWxlLnBvc2l0aW9uID0gXCJyZWxhdGl2ZVwiO1xuXHRcdH1cblxuXHRcdGN1ck9mZnNldCA9IGN1ckVsZW0ub2Zmc2V0KCk7XG5cdFx0Y3VyQ1NTVG9wID0galF1ZXJ5LmNzcyggZWxlbSwgXCJ0b3BcIiApO1xuXHRcdGN1ckNTU0xlZnQgPSBqUXVlcnkuY3NzKCBlbGVtLCBcImxlZnRcIiApO1xuXHRcdGNhbGN1bGF0ZVBvc2l0aW9uID0gKCBwb3NpdGlvbiA9PT0gXCJhYnNvbHV0ZVwiIHx8IHBvc2l0aW9uID09PSBcImZpeGVkXCIgKSAmJlxuXHRcdFx0KCBjdXJDU1NUb3AgKyBjdXJDU1NMZWZ0ICkuaW5kZXhPZiggXCJhdXRvXCIgKSA+IC0xO1xuXG5cdFx0Ly8gTmVlZCB0byBiZSBhYmxlIHRvIGNhbGN1bGF0ZSBwb3NpdGlvbiBpZiBlaXRoZXJcblx0XHQvLyB0b3Agb3IgbGVmdCBpcyBhdXRvIGFuZCBwb3NpdGlvbiBpcyBlaXRoZXIgYWJzb2x1dGUgb3IgZml4ZWRcblx0XHRpZiAoIGNhbGN1bGF0ZVBvc2l0aW9uICkge1xuXHRcdFx0Y3VyUG9zaXRpb24gPSBjdXJFbGVtLnBvc2l0aW9uKCk7XG5cdFx0XHRjdXJUb3AgPSBjdXJQb3NpdGlvbi50b3A7XG5cdFx0XHRjdXJMZWZ0ID0gY3VyUG9zaXRpb24ubGVmdDtcblxuXHRcdH0gZWxzZSB7XG5cdFx0XHRjdXJUb3AgPSBwYXJzZUZsb2F0KCBjdXJDU1NUb3AgKSB8fCAwO1xuXHRcdFx0Y3VyTGVmdCA9IHBhcnNlRmxvYXQoIGN1ckNTU0xlZnQgKSB8fCAwO1xuXHRcdH1cblxuXHRcdGlmICggaXNGdW5jdGlvbiggb3B0aW9ucyApICkge1xuXG5cdFx0XHQvLyBVc2UgalF1ZXJ5LmV4dGVuZCBoZXJlIHRvIGFsbG93IG1vZGlmaWNhdGlvbiBvZiBjb29yZGluYXRlcyBhcmd1bWVudCAoZ2gtMTg0OClcblx0XHRcdG9wdGlvbnMgPSBvcHRpb25zLmNhbGwoIGVsZW0sIGksIGpRdWVyeS5leHRlbmQoIHt9LCBjdXJPZmZzZXQgKSApO1xuXHRcdH1cblxuXHRcdGlmICggb3B0aW9ucy50b3AgIT0gbnVsbCApIHtcblx0XHRcdHByb3BzLnRvcCA9ICggb3B0aW9ucy50b3AgLSBjdXJPZmZzZXQudG9wICkgKyBjdXJUb3A7XG5cdFx0fVxuXHRcdGlmICggb3B0aW9ucy5sZWZ0ICE9IG51bGwgKSB7XG5cdFx0XHRwcm9wcy5sZWZ0ID0gKCBvcHRpb25zLmxlZnQgLSBjdXJPZmZzZXQubGVmdCApICsgY3VyTGVmdDtcblx0XHR9XG5cblx0XHRpZiAoIFwidXNpbmdcIiBpbiBvcHRpb25zICkge1xuXHRcdFx0b3B0aW9ucy51c2luZy5jYWxsKCBlbGVtLCBwcm9wcyApO1xuXG5cdFx0fSBlbHNlIHtcblx0XHRcdGN1ckVsZW0uY3NzKCBwcm9wcyApO1xuXHRcdH1cblx0fVxufTtcblxualF1ZXJ5LmZuLmV4dGVuZCgge1xuXG5cdC8vIG9mZnNldCgpIHJlbGF0ZXMgYW4gZWxlbWVudCdzIGJvcmRlciBib3ggdG8gdGhlIGRvY3VtZW50IG9yaWdpblxuXHRvZmZzZXQ6IGZ1bmN0aW9uKCBvcHRpb25zICkge1xuXG5cdFx0Ly8gUHJlc2VydmUgY2hhaW5pbmcgZm9yIHNldHRlclxuXHRcdGlmICggYXJndW1lbnRzLmxlbmd0aCApIHtcblx0XHRcdHJldHVybiBvcHRpb25zID09PSB1bmRlZmluZWQgP1xuXHRcdFx0XHR0aGlzIDpcblx0XHRcdFx0dGhpcy5lYWNoKCBmdW5jdGlvbiggaSApIHtcblx0XHRcdFx0XHRqUXVlcnkub2Zmc2V0LnNldE9mZnNldCggdGhpcywgb3B0aW9ucywgaSApO1xuXHRcdFx0XHR9ICk7XG5cdFx0fVxuXG5cdFx0dmFyIHJlY3QsIHdpbixcblx0XHRcdGVsZW0gPSB0aGlzWyAwIF07XG5cblx0XHRpZiAoICFlbGVtICkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdC8vIFJldHVybiB6ZXJvcyBmb3IgZGlzY29ubmVjdGVkIGFuZCBoaWRkZW4gKGRpc3BsYXk6IG5vbmUpIGVsZW1lbnRzIChnaC0yMzEwKVxuXHRcdC8vIFN1cHBvcnQ6IElFIDw9MTEgb25seVxuXHRcdC8vIFJ1bm5pbmcgZ2V0Qm91bmRpbmdDbGllbnRSZWN0IG9uIGFcblx0XHQvLyBkaXNjb25uZWN0ZWQgbm9kZSBpbiBJRSB0aHJvd3MgYW4gZXJyb3Jcblx0XHRpZiAoICFlbGVtLmdldENsaWVudFJlY3RzKCkubGVuZ3RoICkge1xuXHRcdFx0cmV0dXJuIHsgdG9wOiAwLCBsZWZ0OiAwIH07XG5cdFx0fVxuXG5cdFx0Ly8gR2V0IGRvY3VtZW50LXJlbGF0aXZlIHBvc2l0aW9uIGJ5IGFkZGluZyB2aWV3cG9ydCBzY3JvbGwgdG8gdmlld3BvcnQtcmVsYXRpdmUgZ0JDUlxuXHRcdHJlY3QgPSBlbGVtLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuXHRcdHdpbiA9IGVsZW0ub3duZXJEb2N1bWVudC5kZWZhdWx0Vmlldztcblx0XHRyZXR1cm4ge1xuXHRcdFx0dG9wOiByZWN0LnRvcCArIHdpbi5wYWdlWU9mZnNldCxcblx0XHRcdGxlZnQ6IHJlY3QubGVmdCArIHdpbi5wYWdlWE9mZnNldFxuXHRcdH07XG5cdH0sXG5cblx0Ly8gcG9zaXRpb24oKSByZWxhdGVzIGFuIGVsZW1lbnQncyBtYXJnaW4gYm94IHRvIGl0cyBvZmZzZXQgcGFyZW50J3MgcGFkZGluZyBib3hcblx0Ly8gVGhpcyBjb3JyZXNwb25kcyB0byB0aGUgYmVoYXZpb3Igb2YgQ1NTIGFic29sdXRlIHBvc2l0aW9uaW5nXG5cdHBvc2l0aW9uOiBmdW5jdGlvbigpIHtcblx0XHRpZiAoICF0aGlzWyAwIF0gKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0dmFyIG9mZnNldFBhcmVudCwgb2Zmc2V0LCBkb2MsXG5cdFx0XHRlbGVtID0gdGhpc1sgMCBdLFxuXHRcdFx0cGFyZW50T2Zmc2V0ID0geyB0b3A6IDAsIGxlZnQ6IDAgfTtcblxuXHRcdC8vIHBvc2l0aW9uOmZpeGVkIGVsZW1lbnRzIGFyZSBvZmZzZXQgZnJvbSB0aGUgdmlld3BvcnQsIHdoaWNoIGl0c2VsZiBhbHdheXMgaGFzIHplcm8gb2Zmc2V0XG5cdFx0aWYgKCBqUXVlcnkuY3NzKCBlbGVtLCBcInBvc2l0aW9uXCIgKSA9PT0gXCJmaXhlZFwiICkge1xuXG5cdFx0XHQvLyBBc3N1bWUgcG9zaXRpb246Zml4ZWQgaW1wbGllcyBhdmFpbGFiaWxpdHkgb2YgZ2V0Qm91bmRpbmdDbGllbnRSZWN0XG5cdFx0XHRvZmZzZXQgPSBlbGVtLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuXG5cdFx0fSBlbHNlIHtcblx0XHRcdG9mZnNldCA9IHRoaXMub2Zmc2V0KCk7XG5cblx0XHRcdC8vIEFjY291bnQgZm9yIHRoZSAqcmVhbCogb2Zmc2V0IHBhcmVudCwgd2hpY2ggY2FuIGJlIHRoZSBkb2N1bWVudCBvciBpdHMgcm9vdCBlbGVtZW50XG5cdFx0XHQvLyB3aGVuIGEgc3RhdGljYWxseSBwb3NpdGlvbmVkIGVsZW1lbnQgaXMgaWRlbnRpZmllZFxuXHRcdFx0ZG9jID0gZWxlbS5vd25lckRvY3VtZW50O1xuXHRcdFx0b2Zmc2V0UGFyZW50ID0gZWxlbS5vZmZzZXRQYXJlbnQgfHwgZG9jLmRvY3VtZW50RWxlbWVudDtcblx0XHRcdHdoaWxlICggb2Zmc2V0UGFyZW50ICYmXG5cdFx0XHRcdCggb2Zmc2V0UGFyZW50ID09PSBkb2MuYm9keSB8fCBvZmZzZXRQYXJlbnQgPT09IGRvYy5kb2N1bWVudEVsZW1lbnQgKSAmJlxuXHRcdFx0XHRqUXVlcnkuY3NzKCBvZmZzZXRQYXJlbnQsIFwicG9zaXRpb25cIiApID09PSBcInN0YXRpY1wiICkge1xuXG5cdFx0XHRcdG9mZnNldFBhcmVudCA9IG9mZnNldFBhcmVudC5wYXJlbnROb2RlO1xuXHRcdFx0fVxuXHRcdFx0aWYgKCBvZmZzZXRQYXJlbnQgJiYgb2Zmc2V0UGFyZW50ICE9PSBlbGVtICYmIG9mZnNldFBhcmVudC5ub2RlVHlwZSA9PT0gMSApIHtcblxuXHRcdFx0XHQvLyBJbmNvcnBvcmF0ZSBib3JkZXJzIGludG8gaXRzIG9mZnNldCwgc2luY2UgdGhleSBhcmUgb3V0c2lkZSBpdHMgY29udGVudCBvcmlnaW5cblx0XHRcdFx0cGFyZW50T2Zmc2V0ID0galF1ZXJ5KCBvZmZzZXRQYXJlbnQgKS5vZmZzZXQoKTtcblx0XHRcdFx0cGFyZW50T2Zmc2V0LnRvcCArPSBqUXVlcnkuY3NzKCBvZmZzZXRQYXJlbnQsIFwiYm9yZGVyVG9wV2lkdGhcIiwgdHJ1ZSApO1xuXHRcdFx0XHRwYXJlbnRPZmZzZXQubGVmdCArPSBqUXVlcnkuY3NzKCBvZmZzZXRQYXJlbnQsIFwiYm9yZGVyTGVmdFdpZHRoXCIsIHRydWUgKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyBTdWJ0cmFjdCBwYXJlbnQgb2Zmc2V0cyBhbmQgZWxlbWVudCBtYXJnaW5zXG5cdFx0cmV0dXJuIHtcblx0XHRcdHRvcDogb2Zmc2V0LnRvcCAtIHBhcmVudE9mZnNldC50b3AgLSBqUXVlcnkuY3NzKCBlbGVtLCBcIm1hcmdpblRvcFwiLCB0cnVlICksXG5cdFx0XHRsZWZ0OiBvZmZzZXQubGVmdCAtIHBhcmVudE9mZnNldC5sZWZ0IC0galF1ZXJ5LmNzcyggZWxlbSwgXCJtYXJnaW5MZWZ0XCIsIHRydWUgKVxuXHRcdH07XG5cdH0sXG5cblx0Ly8gVGhpcyBtZXRob2Qgd2lsbCByZXR1cm4gZG9jdW1lbnRFbGVtZW50IGluIHRoZSBmb2xsb3dpbmcgY2FzZXM6XG5cdC8vIDEpIEZvciB0aGUgZWxlbWVudCBpbnNpZGUgdGhlIGlmcmFtZSB3aXRob3V0IG9mZnNldFBhcmVudCwgdGhpcyBtZXRob2Qgd2lsbCByZXR1cm5cblx0Ly8gICAgZG9jdW1lbnRFbGVtZW50IG9mIHRoZSBwYXJlbnQgd2luZG93XG5cdC8vIDIpIEZvciB0aGUgaGlkZGVuIG9yIGRldGFjaGVkIGVsZW1lbnRcblx0Ly8gMykgRm9yIGJvZHkgb3IgaHRtbCBlbGVtZW50LCBpLmUuIGluIGNhc2Ugb2YgdGhlIGh0bWwgbm9kZSAtIGl0IHdpbGwgcmV0dXJuIGl0c2VsZlxuXHQvL1xuXHQvLyBidXQgdGhvc2UgZXhjZXB0aW9ucyB3ZXJlIG5ldmVyIHByZXNlbnRlZCBhcyBhIHJlYWwgbGlmZSB1c2UtY2FzZXNcblx0Ly8gYW5kIG1pZ2h0IGJlIGNvbnNpZGVyZWQgYXMgbW9yZSBwcmVmZXJhYmxlIHJlc3VsdHMuXG5cdC8vXG5cdC8vIFRoaXMgbG9naWMsIGhvd2V2ZXIsIGlzIG5vdCBndWFyYW50ZWVkIGFuZCBjYW4gY2hhbmdlIGF0IGFueSBwb2ludCBpbiB0aGUgZnV0dXJlXG5cdG9mZnNldFBhcmVudDogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMubWFwKCBmdW5jdGlvbigpIHtcblx0XHRcdHZhciBvZmZzZXRQYXJlbnQgPSB0aGlzLm9mZnNldFBhcmVudDtcblxuXHRcdFx0d2hpbGUgKCBvZmZzZXRQYXJlbnQgJiYgalF1ZXJ5LmNzcyggb2Zmc2V0UGFyZW50LCBcInBvc2l0aW9uXCIgKSA9PT0gXCJzdGF0aWNcIiApIHtcblx0XHRcdFx0b2Zmc2V0UGFyZW50ID0gb2Zmc2V0UGFyZW50Lm9mZnNldFBhcmVudDtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIG9mZnNldFBhcmVudCB8fCBkb2N1bWVudEVsZW1lbnQ7XG5cdFx0fSApO1xuXHR9XG59ICk7XG5cbi8vIENyZWF0ZSBzY3JvbGxMZWZ0IGFuZCBzY3JvbGxUb3AgbWV0aG9kc1xualF1ZXJ5LmVhY2goIHsgc2Nyb2xsTGVmdDogXCJwYWdlWE9mZnNldFwiLCBzY3JvbGxUb3A6IFwicGFnZVlPZmZzZXRcIiB9LCBmdW5jdGlvbiggbWV0aG9kLCBwcm9wICkge1xuXHR2YXIgdG9wID0gXCJwYWdlWU9mZnNldFwiID09PSBwcm9wO1xuXG5cdGpRdWVyeS5mblsgbWV0aG9kIF0gPSBmdW5jdGlvbiggdmFsICkge1xuXHRcdHJldHVybiBhY2Nlc3MoIHRoaXMsIGZ1bmN0aW9uKCBlbGVtLCBtZXRob2QsIHZhbCApIHtcblxuXHRcdFx0Ly8gQ29hbGVzY2UgZG9jdW1lbnRzIGFuZCB3aW5kb3dzXG5cdFx0XHR2YXIgd2luO1xuXHRcdFx0aWYgKCBpc1dpbmRvdyggZWxlbSApICkge1xuXHRcdFx0XHR3aW4gPSBlbGVtO1xuXHRcdFx0fSBlbHNlIGlmICggZWxlbS5ub2RlVHlwZSA9PT0gOSApIHtcblx0XHRcdFx0d2luID0gZWxlbS5kZWZhdWx0Vmlldztcblx0XHRcdH1cblxuXHRcdFx0aWYgKCB2YWwgPT09IHVuZGVmaW5lZCApIHtcblx0XHRcdFx0cmV0dXJuIHdpbiA/IHdpblsgcHJvcCBdIDogZWxlbVsgbWV0aG9kIF07XG5cdFx0XHR9XG5cblx0XHRcdGlmICggd2luICkge1xuXHRcdFx0XHR3aW4uc2Nyb2xsVG8oXG5cdFx0XHRcdFx0IXRvcCA/IHZhbCA6IHdpbi5wYWdlWE9mZnNldCxcblx0XHRcdFx0XHR0b3AgPyB2YWwgOiB3aW4ucGFnZVlPZmZzZXRcblx0XHRcdFx0KTtcblxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0ZWxlbVsgbWV0aG9kIF0gPSB2YWw7XG5cdFx0XHR9XG5cdFx0fSwgbWV0aG9kLCB2YWwsIGFyZ3VtZW50cy5sZW5ndGggKTtcblx0fTtcbn0gKTtcblxuLy8gU3VwcG9ydDogU2FmYXJpIDw9NyAtIDkuMSwgQ2hyb21lIDw9MzcgLSA0OVxuLy8gQWRkIHRoZSB0b3AvbGVmdCBjc3NIb29rcyB1c2luZyBqUXVlcnkuZm4ucG9zaXRpb25cbi8vIFdlYmtpdCBidWc6IGh0dHBzOi8vYnVncy53ZWJraXQub3JnL3Nob3dfYnVnLmNnaT9pZD0yOTA4NFxuLy8gQmxpbmsgYnVnOiBodHRwczovL2J1Z3MuY2hyb21pdW0ub3JnL3AvY2hyb21pdW0vaXNzdWVzL2RldGFpbD9pZD01ODkzNDdcbi8vIGdldENvbXB1dGVkU3R5bGUgcmV0dXJucyBwZXJjZW50IHdoZW4gc3BlY2lmaWVkIGZvciB0b3AvbGVmdC9ib3R0b20vcmlnaHQ7XG4vLyByYXRoZXIgdGhhbiBtYWtlIHRoZSBjc3MgbW9kdWxlIGRlcGVuZCBvbiB0aGUgb2Zmc2V0IG1vZHVsZSwganVzdCBjaGVjayBmb3IgaXQgaGVyZVxualF1ZXJ5LmVhY2goIFsgXCJ0b3BcIiwgXCJsZWZ0XCIgXSwgZnVuY3Rpb24oIGksIHByb3AgKSB7XG5cdGpRdWVyeS5jc3NIb29rc1sgcHJvcCBdID0gYWRkR2V0SG9va0lmKCBzdXBwb3J0LnBpeGVsUG9zaXRpb24sXG5cdFx0ZnVuY3Rpb24oIGVsZW0sIGNvbXB1dGVkICkge1xuXHRcdFx0aWYgKCBjb21wdXRlZCApIHtcblx0XHRcdFx0Y29tcHV0ZWQgPSBjdXJDU1MoIGVsZW0sIHByb3AgKTtcblxuXHRcdFx0XHQvLyBJZiBjdXJDU1MgcmV0dXJucyBwZXJjZW50YWdlLCBmYWxsYmFjayB0byBvZmZzZXRcblx0XHRcdFx0cmV0dXJuIHJudW1ub25weC50ZXN0KCBjb21wdXRlZCApID9cblx0XHRcdFx0XHRqUXVlcnkoIGVsZW0gKS5wb3NpdGlvbigpWyBwcm9wIF0gKyBcInB4XCIgOlxuXHRcdFx0XHRcdGNvbXB1dGVkO1xuXHRcdFx0fVxuXHRcdH1cblx0KTtcbn0gKTtcblxuXG4vLyBDcmVhdGUgaW5uZXJIZWlnaHQsIGlubmVyV2lkdGgsIGhlaWdodCwgd2lkdGgsIG91dGVySGVpZ2h0IGFuZCBvdXRlcldpZHRoIG1ldGhvZHNcbmpRdWVyeS5lYWNoKCB7IEhlaWdodDogXCJoZWlnaHRcIiwgV2lkdGg6IFwid2lkdGhcIiB9LCBmdW5jdGlvbiggbmFtZSwgdHlwZSApIHtcblx0alF1ZXJ5LmVhY2goIHsgcGFkZGluZzogXCJpbm5lclwiICsgbmFtZSwgY29udGVudDogdHlwZSwgXCJcIjogXCJvdXRlclwiICsgbmFtZSB9LFxuXHRcdGZ1bmN0aW9uKCBkZWZhdWx0RXh0cmEsIGZ1bmNOYW1lICkge1xuXG5cdFx0Ly8gTWFyZ2luIGlzIG9ubHkgZm9yIG91dGVySGVpZ2h0LCBvdXRlcldpZHRoXG5cdFx0alF1ZXJ5LmZuWyBmdW5jTmFtZSBdID0gZnVuY3Rpb24oIG1hcmdpbiwgdmFsdWUgKSB7XG5cdFx0XHR2YXIgY2hhaW5hYmxlID0gYXJndW1lbnRzLmxlbmd0aCAmJiAoIGRlZmF1bHRFeHRyYSB8fCB0eXBlb2YgbWFyZ2luICE9PSBcImJvb2xlYW5cIiApLFxuXHRcdFx0XHRleHRyYSA9IGRlZmF1bHRFeHRyYSB8fCAoIG1hcmdpbiA9PT0gdHJ1ZSB8fCB2YWx1ZSA9PT0gdHJ1ZSA/IFwibWFyZ2luXCIgOiBcImJvcmRlclwiICk7XG5cblx0XHRcdHJldHVybiBhY2Nlc3MoIHRoaXMsIGZ1bmN0aW9uKCBlbGVtLCB0eXBlLCB2YWx1ZSApIHtcblx0XHRcdFx0dmFyIGRvYztcblxuXHRcdFx0XHRpZiAoIGlzV2luZG93KCBlbGVtICkgKSB7XG5cblx0XHRcdFx0XHQvLyAkKCB3aW5kb3cgKS5vdXRlcldpZHRoL0hlaWdodCByZXR1cm4gdy9oIGluY2x1ZGluZyBzY3JvbGxiYXJzIChnaC0xNzI5KVxuXHRcdFx0XHRcdHJldHVybiBmdW5jTmFtZS5pbmRleE9mKCBcIm91dGVyXCIgKSA9PT0gMCA/XG5cdFx0XHRcdFx0XHRlbGVtWyBcImlubmVyXCIgKyBuYW1lIF0gOlxuXHRcdFx0XHRcdFx0ZWxlbS5kb2N1bWVudC5kb2N1bWVudEVsZW1lbnRbIFwiY2xpZW50XCIgKyBuYW1lIF07XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBHZXQgZG9jdW1lbnQgd2lkdGggb3IgaGVpZ2h0XG5cdFx0XHRcdGlmICggZWxlbS5ub2RlVHlwZSA9PT0gOSApIHtcblx0XHRcdFx0XHRkb2MgPSBlbGVtLmRvY3VtZW50RWxlbWVudDtcblxuXHRcdFx0XHRcdC8vIEVpdGhlciBzY3JvbGxbV2lkdGgvSGVpZ2h0XSBvciBvZmZzZXRbV2lkdGgvSGVpZ2h0XSBvciBjbGllbnRbV2lkdGgvSGVpZ2h0XSxcblx0XHRcdFx0XHQvLyB3aGljaGV2ZXIgaXMgZ3JlYXRlc3Rcblx0XHRcdFx0XHRyZXR1cm4gTWF0aC5tYXgoXG5cdFx0XHRcdFx0XHRlbGVtLmJvZHlbIFwic2Nyb2xsXCIgKyBuYW1lIF0sIGRvY1sgXCJzY3JvbGxcIiArIG5hbWUgXSxcblx0XHRcdFx0XHRcdGVsZW0uYm9keVsgXCJvZmZzZXRcIiArIG5hbWUgXSwgZG9jWyBcIm9mZnNldFwiICsgbmFtZSBdLFxuXHRcdFx0XHRcdFx0ZG9jWyBcImNsaWVudFwiICsgbmFtZSBdXG5cdFx0XHRcdFx0KTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdHJldHVybiB2YWx1ZSA9PT0gdW5kZWZpbmVkID9cblxuXHRcdFx0XHRcdC8vIEdldCB3aWR0aCBvciBoZWlnaHQgb24gdGhlIGVsZW1lbnQsIHJlcXVlc3RpbmcgYnV0IG5vdCBmb3JjaW5nIHBhcnNlRmxvYXRcblx0XHRcdFx0XHRqUXVlcnkuY3NzKCBlbGVtLCB0eXBlLCBleHRyYSApIDpcblxuXHRcdFx0XHRcdC8vIFNldCB3aWR0aCBvciBoZWlnaHQgb24gdGhlIGVsZW1lbnRcblx0XHRcdFx0XHRqUXVlcnkuc3R5bGUoIGVsZW0sIHR5cGUsIHZhbHVlLCBleHRyYSApO1xuXHRcdFx0fSwgdHlwZSwgY2hhaW5hYmxlID8gbWFyZ2luIDogdW5kZWZpbmVkLCBjaGFpbmFibGUgKTtcblx0XHR9O1xuXHR9ICk7XG59ICk7XG5cblxualF1ZXJ5LmVhY2goICggXCJibHVyIGZvY3VzIGZvY3VzaW4gZm9jdXNvdXQgcmVzaXplIHNjcm9sbCBjbGljayBkYmxjbGljayBcIiArXG5cdFwibW91c2Vkb3duIG1vdXNldXAgbW91c2Vtb3ZlIG1vdXNlb3ZlciBtb3VzZW91dCBtb3VzZWVudGVyIG1vdXNlbGVhdmUgXCIgK1xuXHRcImNoYW5nZSBzZWxlY3Qgc3VibWl0IGtleWRvd24ga2V5cHJlc3Mga2V5dXAgY29udGV4dG1lbnVcIiApLnNwbGl0KCBcIiBcIiApLFxuXHRmdW5jdGlvbiggaSwgbmFtZSApIHtcblxuXHQvLyBIYW5kbGUgZXZlbnQgYmluZGluZ1xuXHRqUXVlcnkuZm5bIG5hbWUgXSA9IGZ1bmN0aW9uKCBkYXRhLCBmbiApIHtcblx0XHRyZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA+IDAgP1xuXHRcdFx0dGhpcy5vbiggbmFtZSwgbnVsbCwgZGF0YSwgZm4gKSA6XG5cdFx0XHR0aGlzLnRyaWdnZXIoIG5hbWUgKTtcblx0fTtcbn0gKTtcblxualF1ZXJ5LmZuLmV4dGVuZCgge1xuXHRob3ZlcjogZnVuY3Rpb24oIGZuT3ZlciwgZm5PdXQgKSB7XG5cdFx0cmV0dXJuIHRoaXMubW91c2VlbnRlciggZm5PdmVyICkubW91c2VsZWF2ZSggZm5PdXQgfHwgZm5PdmVyICk7XG5cdH1cbn0gKTtcblxuXG5cblxualF1ZXJ5LmZuLmV4dGVuZCgge1xuXG5cdGJpbmQ6IGZ1bmN0aW9uKCB0eXBlcywgZGF0YSwgZm4gKSB7XG5cdFx0cmV0dXJuIHRoaXMub24oIHR5cGVzLCBudWxsLCBkYXRhLCBmbiApO1xuXHR9LFxuXHR1bmJpbmQ6IGZ1bmN0aW9uKCB0eXBlcywgZm4gKSB7XG5cdFx0cmV0dXJuIHRoaXMub2ZmKCB0eXBlcywgbnVsbCwgZm4gKTtcblx0fSxcblxuXHRkZWxlZ2F0ZTogZnVuY3Rpb24oIHNlbGVjdG9yLCB0eXBlcywgZGF0YSwgZm4gKSB7XG5cdFx0cmV0dXJuIHRoaXMub24oIHR5cGVzLCBzZWxlY3RvciwgZGF0YSwgZm4gKTtcblx0fSxcblx0dW5kZWxlZ2F0ZTogZnVuY3Rpb24oIHNlbGVjdG9yLCB0eXBlcywgZm4gKSB7XG5cblx0XHQvLyAoIG5hbWVzcGFjZSApIG9yICggc2VsZWN0b3IsIHR5cGVzIFssIGZuXSApXG5cdFx0cmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPT09IDEgP1xuXHRcdFx0dGhpcy5vZmYoIHNlbGVjdG9yLCBcIioqXCIgKSA6XG5cdFx0XHR0aGlzLm9mZiggdHlwZXMsIHNlbGVjdG9yIHx8IFwiKipcIiwgZm4gKTtcblx0fVxufSApO1xuXG4vLyBCaW5kIGEgZnVuY3Rpb24gdG8gYSBjb250ZXh0LCBvcHRpb25hbGx5IHBhcnRpYWxseSBhcHBseWluZyBhbnlcbi8vIGFyZ3VtZW50cy5cbi8vIGpRdWVyeS5wcm94eSBpcyBkZXByZWNhdGVkIHRvIHByb21vdGUgc3RhbmRhcmRzIChzcGVjaWZpY2FsbHkgRnVuY3Rpb24jYmluZClcbi8vIEhvd2V2ZXIsIGl0IGlzIG5vdCBzbGF0ZWQgZm9yIHJlbW92YWwgYW55IHRpbWUgc29vblxualF1ZXJ5LnByb3h5ID0gZnVuY3Rpb24oIGZuLCBjb250ZXh0ICkge1xuXHR2YXIgdG1wLCBhcmdzLCBwcm94eTtcblxuXHRpZiAoIHR5cGVvZiBjb250ZXh0ID09PSBcInN0cmluZ1wiICkge1xuXHRcdHRtcCA9IGZuWyBjb250ZXh0IF07XG5cdFx0Y29udGV4dCA9IGZuO1xuXHRcdGZuID0gdG1wO1xuXHR9XG5cblx0Ly8gUXVpY2sgY2hlY2sgdG8gZGV0ZXJtaW5lIGlmIHRhcmdldCBpcyBjYWxsYWJsZSwgaW4gdGhlIHNwZWNcblx0Ly8gdGhpcyB0aHJvd3MgYSBUeXBlRXJyb3IsIGJ1dCB3ZSB3aWxsIGp1c3QgcmV0dXJuIHVuZGVmaW5lZC5cblx0aWYgKCAhaXNGdW5jdGlvbiggZm4gKSApIHtcblx0XHRyZXR1cm4gdW5kZWZpbmVkO1xuXHR9XG5cblx0Ly8gU2ltdWxhdGVkIGJpbmRcblx0YXJncyA9IHNsaWNlLmNhbGwoIGFyZ3VtZW50cywgMiApO1xuXHRwcm94eSA9IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiBmbi5hcHBseSggY29udGV4dCB8fCB0aGlzLCBhcmdzLmNvbmNhdCggc2xpY2UuY2FsbCggYXJndW1lbnRzICkgKSApO1xuXHR9O1xuXG5cdC8vIFNldCB0aGUgZ3VpZCBvZiB1bmlxdWUgaGFuZGxlciB0byB0aGUgc2FtZSBvZiBvcmlnaW5hbCBoYW5kbGVyLCBzbyBpdCBjYW4gYmUgcmVtb3ZlZFxuXHRwcm94eS5ndWlkID0gZm4uZ3VpZCA9IGZuLmd1aWQgfHwgalF1ZXJ5Lmd1aWQrKztcblxuXHRyZXR1cm4gcHJveHk7XG59O1xuXG5qUXVlcnkuaG9sZFJlYWR5ID0gZnVuY3Rpb24oIGhvbGQgKSB7XG5cdGlmICggaG9sZCApIHtcblx0XHRqUXVlcnkucmVhZHlXYWl0Kys7XG5cdH0gZWxzZSB7XG5cdFx0alF1ZXJ5LnJlYWR5KCB0cnVlICk7XG5cdH1cbn07XG5qUXVlcnkuaXNBcnJheSA9IEFycmF5LmlzQXJyYXk7XG5qUXVlcnkucGFyc2VKU09OID0gSlNPTi5wYXJzZTtcbmpRdWVyeS5ub2RlTmFtZSA9IG5vZGVOYW1lO1xualF1ZXJ5LmlzRnVuY3Rpb24gPSBpc0Z1bmN0aW9uO1xualF1ZXJ5LmlzV2luZG93ID0gaXNXaW5kb3c7XG5qUXVlcnkuY2FtZWxDYXNlID0gY2FtZWxDYXNlO1xualF1ZXJ5LnR5cGUgPSB0b1R5cGU7XG5cbmpRdWVyeS5ub3cgPSBEYXRlLm5vdztcblxualF1ZXJ5LmlzTnVtZXJpYyA9IGZ1bmN0aW9uKCBvYmogKSB7XG5cblx0Ly8gQXMgb2YgalF1ZXJ5IDMuMCwgaXNOdW1lcmljIGlzIGxpbWl0ZWQgdG9cblx0Ly8gc3RyaW5ncyBhbmQgbnVtYmVycyAocHJpbWl0aXZlcyBvciBvYmplY3RzKVxuXHQvLyB0aGF0IGNhbiBiZSBjb2VyY2VkIHRvIGZpbml0ZSBudW1iZXJzIChnaC0yNjYyKVxuXHR2YXIgdHlwZSA9IGpRdWVyeS50eXBlKCBvYmogKTtcblx0cmV0dXJuICggdHlwZSA9PT0gXCJudW1iZXJcIiB8fCB0eXBlID09PSBcInN0cmluZ1wiICkgJiZcblxuXHRcdC8vIHBhcnNlRmxvYXQgTmFOcyBudW1lcmljLWNhc3QgZmFsc2UgcG9zaXRpdmVzIChcIlwiKVxuXHRcdC8vIC4uLmJ1dCBtaXNpbnRlcnByZXRzIGxlYWRpbmctbnVtYmVyIHN0cmluZ3MsIHBhcnRpY3VsYXJseSBoZXggbGl0ZXJhbHMgKFwiMHguLi5cIilcblx0XHQvLyBzdWJ0cmFjdGlvbiBmb3JjZXMgaW5maW5pdGllcyB0byBOYU5cblx0XHQhaXNOYU4oIG9iaiAtIHBhcnNlRmxvYXQoIG9iaiApICk7XG59O1xuXG5cblxuXG4vLyBSZWdpc3RlciBhcyBhIG5hbWVkIEFNRCBtb2R1bGUsIHNpbmNlIGpRdWVyeSBjYW4gYmUgY29uY2F0ZW5hdGVkIHdpdGggb3RoZXJcbi8vIGZpbGVzIHRoYXQgbWF5IHVzZSBkZWZpbmUsIGJ1dCBub3QgdmlhIGEgcHJvcGVyIGNvbmNhdGVuYXRpb24gc2NyaXB0IHRoYXRcbi8vIHVuZGVyc3RhbmRzIGFub255bW91cyBBTUQgbW9kdWxlcy4gQSBuYW1lZCBBTUQgaXMgc2FmZXN0IGFuZCBtb3N0IHJvYnVzdFxuLy8gd2F5IHRvIHJlZ2lzdGVyLiBMb3dlcmNhc2UganF1ZXJ5IGlzIHVzZWQgYmVjYXVzZSBBTUQgbW9kdWxlIG5hbWVzIGFyZVxuLy8gZGVyaXZlZCBmcm9tIGZpbGUgbmFtZXMsIGFuZCBqUXVlcnkgaXMgbm9ybWFsbHkgZGVsaXZlcmVkIGluIGEgbG93ZXJjYXNlXG4vLyBmaWxlIG5hbWUuIERvIHRoaXMgYWZ0ZXIgY3JlYXRpbmcgdGhlIGdsb2JhbCBzbyB0aGF0IGlmIGFuIEFNRCBtb2R1bGUgd2FudHNcbi8vIHRvIGNhbGwgbm9Db25mbGljdCB0byBoaWRlIHRoaXMgdmVyc2lvbiBvZiBqUXVlcnksIGl0IHdpbGwgd29yay5cblxuLy8gTm90ZSB0aGF0IGZvciBtYXhpbXVtIHBvcnRhYmlsaXR5LCBsaWJyYXJpZXMgdGhhdCBhcmUgbm90IGpRdWVyeSBzaG91bGRcbi8vIGRlY2xhcmUgdGhlbXNlbHZlcyBhcyBhbm9ueW1vdXMgbW9kdWxlcywgYW5kIGF2b2lkIHNldHRpbmcgYSBnbG9iYWwgaWYgYW5cbi8vIEFNRCBsb2FkZXIgaXMgcHJlc2VudC4galF1ZXJ5IGlzIGEgc3BlY2lhbCBjYXNlLiBGb3IgbW9yZSBpbmZvcm1hdGlvbiwgc2VlXG4vLyBodHRwczovL2dpdGh1Yi5jb20vanJidXJrZS9yZXF1aXJlanMvd2lraS9VcGRhdGluZy1leGlzdGluZy1saWJyYXJpZXMjd2lraS1hbm9uXG5cbmlmICggdHlwZW9mIGRlZmluZSA9PT0gXCJmdW5jdGlvblwiICYmIGRlZmluZS5hbWQgKSB7XG5cdGRlZmluZSggXCJqcXVlcnlcIiwgW10sIGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiBqUXVlcnk7XG5cdH0gKTtcbn1cblxuXG5cblxudmFyXG5cblx0Ly8gTWFwIG92ZXIgalF1ZXJ5IGluIGNhc2Ugb2Ygb3ZlcndyaXRlXG5cdF9qUXVlcnkgPSB3aW5kb3cualF1ZXJ5LFxuXG5cdC8vIE1hcCBvdmVyIHRoZSAkIGluIGNhc2Ugb2Ygb3ZlcndyaXRlXG5cdF8kID0gd2luZG93LiQ7XG5cbmpRdWVyeS5ub0NvbmZsaWN0ID0gZnVuY3Rpb24oIGRlZXAgKSB7XG5cdGlmICggd2luZG93LiQgPT09IGpRdWVyeSApIHtcblx0XHR3aW5kb3cuJCA9IF8kO1xuXHR9XG5cblx0aWYgKCBkZWVwICYmIHdpbmRvdy5qUXVlcnkgPT09IGpRdWVyeSApIHtcblx0XHR3aW5kb3cualF1ZXJ5ID0gX2pRdWVyeTtcblx0fVxuXG5cdHJldHVybiBqUXVlcnk7XG59O1xuXG4vLyBFeHBvc2UgalF1ZXJ5IGFuZCAkIGlkZW50aWZpZXJzLCBldmVuIGluIEFNRFxuLy8gKCM3MTAyI2NvbW1lbnQ6MTAsIGh0dHBzOi8vZ2l0aHViLmNvbS9qcXVlcnkvanF1ZXJ5L3B1bGwvNTU3KVxuLy8gYW5kIENvbW1vbkpTIGZvciBicm93c2VyIGVtdWxhdG9ycyAoIzEzNTY2KVxuaWYgKCAhbm9HbG9iYWwgKSB7XG5cdHdpbmRvdy5qUXVlcnkgPSB3aW5kb3cuJCA9IGpRdWVyeTtcbn1cblxuXG5cblxucmV0dXJuIGpRdWVyeTtcbn0gKTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2pxdWVyeS9kaXN0L2pxdWVyeS5qc1xuLy8gbW9kdWxlIGlkID0gNjVcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///65\n");

/***/ }),
/* 66 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("Object.defineProperty(__webpack_exports__, \"__esModule\", { value: true });\n/* WEBPACK VAR INJECTION */(function(module) {/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_object_create__ = __webpack_require__(68);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_object_create___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_object_create__);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_babel_runtime_helpers_typeof__ = __webpack_require__(79);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_babel_runtime_helpers_typeof___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1_babel_runtime_helpers_typeof__);\n\n\n/*! WebUploader 0.1.5 */\n\n/* eslint-disable */\n/**\n * @fileOverview 让内部各个部件的代码可以用[amd](https://github.com/amdjs/amdjs-api/wiki/AMD)模块定义方式组织起来。\n *\n * AMD API 内部的简单不完全实现，请忽略。只有当WebUploader被合并成一个文件的时候才会引入。\n */\n(function (root, factory) {\n    var modules = {},\n\n\n    // 内部require, 简单不完全实现。\n    // https://github.com/amdjs/amdjs-api/wiki/require\n    _require = function _require(deps, callback) {\n        var args, len, i;\n\n        // 如果deps不是数组，则直接返回指定module\n        if (typeof deps === 'string') {\n            return getModule(deps);\n        } else {\n            args = [];\n            for (len = deps.length, i = 0; i < len; i++) {\n                args.push(getModule(deps[i]));\n            }\n\n            return callback.apply(null, args);\n        }\n    },\n\n\n    // 内部define，暂时不支持不指定id.\n    _define = function _define(id, deps, factory) {\n        if (arguments.length === 2) {\n            factory = deps;\n            deps = null;\n        }\n\n        _require(deps || [], function () {\n            setModule(id, factory, arguments);\n        });\n    },\n\n\n    // 设置module, 兼容CommonJs写法。\n    setModule = function setModule(id, factory, args) {\n        var module = {\n            exports: factory\n        },\n            returned;\n\n        if (typeof factory === 'function') {\n            args.length || (args = [_require, module.exports, module]);\n            returned = factory.apply(null, args);\n            returned !== undefined && (module.exports = returned);\n        }\n\n        modules[id] = module.exports;\n    },\n\n\n    // 根据id获取module\n    getModule = function getModule(id) {\n        var module = modules[id] || root[id];\n\n        if (!module) {\n            throw new Error('`' + id + '` is undefined');\n        }\n\n        return module;\n    },\n\n\n    // 将所有modules，将路径ids装换成对象。\n    exportsTo = function exportsTo(obj) {\n        var key, host, parts, part, last, ucFirst;\n\n        // make the first character upper case.\n        ucFirst = function ucFirst(str) {\n            return str && str.charAt(0).toUpperCase() + str.substr(1);\n        };\n\n        for (key in modules) {\n            host = obj;\n\n            if (!modules.hasOwnProperty(key)) {\n                continue;\n            }\n\n            parts = key.split('/');\n            last = ucFirst(parts.pop());\n\n            while (part = ucFirst(parts.shift())) {\n                host[part] = host[part] || {};\n                host = host[part];\n            }\n\n            host[last] = modules[key];\n        }\n\n        return obj;\n    },\n        makeExport = function makeExport(dollar) {\n        root.__dollar = dollar;\n\n        // exports every module.\n        return exportsTo(factory(root, _define, _require));\n    },\n        origin;\n\n    if (( false ? 'undefined' : __WEBPACK_IMPORTED_MODULE_1_babel_runtime_helpers_typeof___default()(module)) === 'object' && __WEBPACK_IMPORTED_MODULE_1_babel_runtime_helpers_typeof___default()(module.exports) === 'object') {\n\n        // For CommonJS and CommonJS-like environments where a proper window is present,\n        module.exports = makeExport();\n    } else if (typeof define === 'function' && __webpack_require__(101)) {\n\n        // Allow using this built library as an AMD module\n        // in another project. That other project will only\n        // see this AMD call, not the internal modules in\n        // the closure below.\n        define(['jquery'], makeExport);\n    } else {\n\n        // Browser globals case. Just assign the\n        // result to a property on the global.\n        origin = root.WebUploader;\n        root.WebUploader = makeExport();\n        root.WebUploader.noConflict = function () {\n            root.WebUploader = origin;\n        };\n    }\n})(window, function (window, define, require) {\n\n    /**\n     * @fileOverview jQuery or Zepto\n     */\n    define('dollar-third', [], function () {\n        var $ = window.__dollar || window.jQuery || window.Zepto;\n\n        if (!$) {\n            throw new Error('jQuery or Zepto not found!');\n        }\n\n        return $;\n    });\n    /**\n     * @fileOverview Dom 操作相关\n     */\n    define('dollar', ['dollar-third'], function (_) {\n        return _;\n    });\n    /**\n     * @fileOverview 使用jQuery的Promise\n     */\n    define('promise-third', ['dollar'], function ($) {\n        return {\n            Deferred: $.Deferred,\n            when: $.when,\n\n            isPromise: function isPromise(anything) {\n                return anything && typeof anything.then === 'function';\n            }\n        };\n    });\n    /**\n     * @fileOverview Promise/A+\n     */\n    define('promise', ['promise-third'], function (_) {\n        return _;\n    });\n    /**\n     * @fileOverview 基础类方法。\n     */\n\n    /**\n     * Web Uploader内部类的详细说明，以下提及的功能类，都可以在`WebUploader`这个变量中访问到。\n     *\n     * As you know, Web Uploader的每个文件都是用过[AMD](https://github.com/amdjs/amdjs-api/wiki/AMD)规范中的`define`组织起来的, 每个Module都会有个module id.\n     * 默认module id为该文件的路径，而此路径将会转化成名字空间存放在WebUploader中。如：\n     *\n     * * module `base`：WebUploader.Base\n     * * module `file`: WebUploader.File\n     * * module `lib/dnd`: WebUploader.Lib.Dnd\n     * * module `runtime/html5/dnd`: WebUploader.Runtime.Html5.Dnd\n     *\n     *\n     * 以下文档中对类的使用可能省略掉了`WebUploader`前缀。\n     * @module WebUploader\n     * @title WebUploader API文档\n     */\n    define('base', ['dollar', 'promise'], function ($, promise) {\n\n        var noop = function noop() {},\n            call = Function.call;\n\n        // http://jsperf.com/uncurrythis\n        // 反科里化\n        function uncurryThis(fn) {\n            return function () {\n                return call.apply(fn, arguments);\n            };\n        }\n\n        function bindFn(fn, context) {\n            return function () {\n                return fn.apply(context, arguments);\n            };\n        }\n\n        function createObject(proto) {\n            var f;\n\n            if (__WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_object_create___default.a) {\n                return __WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_object_create___default()(proto);\n            } else {\n                f = function f() {};\n                f.prototype = proto;\n                return new f();\n            }\n        }\n\n        /**\n         * 基础类，提供一些简单常用的方法。\n         * @class Base\n         */\n        return {\n\n            /**\n             * @property {String} version 当前版本号。\n             */\n            version: '0.1.5',\n\n            /**\n             * @property {jQuery|Zepto} $ 引用依赖的jQuery或者Zepto对象。\n             */\n            $: $,\n\n            Deferred: promise.Deferred,\n\n            isPromise: promise.isPromise,\n\n            when: promise.when,\n\n            /**\n             * @description  简单的浏览器检查结果。\n             *\n             * * `webkit`  webkit版本号，如果浏览器为非webkit内核，此属性为`undefined`。\n             * * `chrome`  chrome浏览器版本号，如果浏览器为chrome，此属性为`undefined`。\n             * * `ie`  ie浏览器版本号，如果浏览器为非ie，此属性为`undefined`。**暂不支持ie10+**\n             * * `firefox`  firefox浏览器版本号，如果浏览器为非firefox，此属性为`undefined`。\n             * * `safari`  safari浏览器版本号，如果浏览器为非safari，此属性为`undefined`。\n             * * `opera`  opera浏览器版本号，如果浏览器为非opera，此属性为`undefined`。\n             *\n             * @property {Object} [browser]\n             */\n            browser: function (ua) {\n                var ret = {},\n                    webkit = ua.match(/WebKit\\/([\\d.]+)/),\n                    chrome = ua.match(/Chrome\\/([\\d.]+)/) || ua.match(/CriOS\\/([\\d.]+)/),\n                    ie = ua.match(/MSIE\\s([\\d\\.]+)/) || ua.match(/(?:trident)(?:.*rv:([\\w.]+))?/i),\n                    firefox = ua.match(/Firefox\\/([\\d.]+)/),\n                    safari = ua.match(/Safari\\/([\\d.]+)/),\n                    opera = ua.match(/OPR\\/([\\d.]+)/);\n\n                webkit && (ret.webkit = parseFloat(webkit[1]));\n                chrome && (ret.chrome = parseFloat(chrome[1]));\n                ie && (ret.ie = parseFloat(ie[1]));\n                firefox && (ret.firefox = parseFloat(firefox[1]));\n                safari && (ret.safari = parseFloat(safari[1]));\n                opera && (ret.opera = parseFloat(opera[1]));\n\n                return ret;\n            }(navigator.userAgent),\n\n            /**\n             * @description  操作系统检查结果。\n             *\n             * * `android`  如果在android浏览器环境下，此值为对应的android版本号，否则为`undefined`。\n             * * `ios` 如果在ios浏览器环境下，此值为对应的ios版本号，否则为`undefined`。\n             * @property {Object} [os]\n             */\n            os: function (ua) {\n                var ret = {},\n\n\n                // osx = !!ua.match( /\\(Macintosh\\; Intel / ),\n                android = ua.match(/(?:Android);?[\\s\\/]+([\\d.]+)?/),\n                    ios = ua.match(/(?:iPad|iPod|iPhone).*OS\\s([\\d_]+)/);\n\n                // osx && (ret.osx = true);\n                android && (ret.android = parseFloat(android[1]));\n                ios && (ret.ios = parseFloat(ios[1].replace(/_/g, '.')));\n\n                return ret;\n            }(navigator.userAgent),\n\n            /**\n             * 实现类与类之间的继承。\n             * @method inherits\n             * @grammar Base.inherits( super ) => child\n             * @grammar Base.inherits( super, protos ) => child\n             * @grammar Base.inherits( super, protos, statics ) => child\n             * @param  {Class} super 父类\n             * @param  {Object | Function} [protos] 子类或者对象。如果对象中包含constructor，子类将是用此属性值。\n             * @param  {Function} [protos.constructor] 子类构造器，不指定的话将创建个临时的直接执行父类构造器的方法。\n             * @param  {Object} [statics] 静态属性或方法。\n             * @return {Class} 返回子类。\n             * @example\n             * function Person() {\n             *     console.log( 'Super' );\n             * }\n             * Person.prototype.hello = function() {\n             *     console.log( 'hello' );\n             * };\n             *\n             * var Manager = Base.inherits( Person, {\n             *     world: function() {\n             *         console.log( 'World' );\n             *     }\n             * });\n             *\n             * // 因为没有指定构造器，父类的构造器将会执行。\n             * var instance = new Manager();    // => Super\n             *\n             * // 继承子父类的方法\n             * instance.hello();    // => hello\n             * instance.world();    // => World\n             *\n             * // 子类的__super__属性指向父类\n             * console.log( Manager.__super__ === Person );    // => true\n             */\n            inherits: function inherits(Super, protos, staticProtos) {\n                var child;\n\n                if (typeof protos === 'function') {\n                    child = protos;\n                    protos = null;\n                } else if (protos && protos.hasOwnProperty('constructor')) {\n                    child = protos.constructor;\n                } else {\n                    child = function child() {\n                        return Super.apply(this, arguments);\n                    };\n                }\n\n                // 复制静态方法\n                $.extend(true, child, Super, staticProtos || {});\n\n                /* jshint camelcase: false */\n\n                // 让子类的__super__属性指向父类。\n                child.__super__ = Super.prototype;\n\n                // 构建原型，添加原型方法或属性。\n                // 暂时用Object.create实现。\n                child.prototype = createObject(Super.prototype);\n                protos && $.extend(true, child.prototype, protos);\n\n                return child;\n            },\n\n            /**\n             * 一个不做任何事情的方法。可以用来赋值给默认的callback.\n             * @method noop\n             */\n            noop: noop,\n\n            /**\n             * 返回一个新的方法，此方法将已指定的`context`来执行。\n             * @grammar Base.bindFn( fn, context ) => Function\n             * @method bindFn\n             * @example\n             * var doSomething = function() {\n             *         console.log( this.name );\n             *     },\n             *     obj = {\n             *         name: 'Object Name'\n             *     },\n             *     aliasFn = Base.bind( doSomething, obj );\n             *\n             *  aliasFn();    // => Object Name\n             *\n             */\n            bindFn: bindFn,\n\n            /**\n             * 引用Console.log如果存在的话，否则引用一个[空函数noop](#WebUploader:Base.noop)。\n             * @grammar Base.log( args... ) => undefined\n             * @method log\n             */\n            log: function () {\n                if (window.console) {\n                    return bindFn(console.log, console);\n                }\n                return noop;\n            }(),\n\n            nextTick: function () {\n\n                return function (cb) {\n                    setTimeout(cb, 1);\n                };\n\n                // @bug 当浏览器不在当前窗口时就停了。\n                // var next = window.requestAnimationFrame ||\n                //     window.webkitRequestAnimationFrame ||\n                //     window.mozRequestAnimationFrame ||\n                //     function( cb ) {\n                //         window.setTimeout( cb, 1000 / 60 );\n                //     };\n\n                // // fix: Uncaught TypeError: Illegal invocation\n                // return bindFn( next, window );\n            }(),\n\n            /**\n             * 被[uncurrythis](http://www.2ality.com/2011/11/uncurrying-this.html)的数组slice方法。\n             * 将用来将非数组对象转化成数组对象。\n             * @grammar Base.slice( target, start[, end] ) => Array\n             * @method slice\n             * @example\n             * function doSomthing() {\n             *     var args = Base.slice( arguments, 1 );\n             *     console.log( args );\n             * }\n             *\n             * doSomthing( 'ignored', 'arg2', 'arg3' );    // => Array [\"arg2\", \"arg3\"]\n             */\n            slice: uncurryThis([].slice),\n\n            /**\n             * 生成唯一的ID\n             * @method guid\n             * @grammar Base.guid() => String\n             * @grammar Base.guid( prefx ) => String\n             */\n            guid: function () {\n                var counter = 0;\n\n                return function (prefix) {\n                    var guid = (+new Date()).toString(32),\n                        i = 0;\n\n                    for (; i < 5; i++) {\n                        guid += Math.floor(Math.random() * 65535).toString(32);\n                    }\n\n                    return (prefix || 'wu_') + guid + (counter++).toString(32);\n                };\n            }(),\n\n            /**\n             * 格式化文件大小, 输出成带单位的字符串\n             * @method formatSize\n             * @grammar Base.formatSize( size ) => String\n             * @grammar Base.formatSize( size, pointLength ) => String\n             * @grammar Base.formatSize( size, pointLength, units ) => String\n             * @param {Number} size 文件大小\n             * @param {Number} [pointLength=2] 精确到的小数点数。\n             * @param {Array} [units=[ 'B', 'K', 'M', 'G', 'TB' ]] 单位数组。从字节，到千字节，一直往上指定。如果单位数组里面只指定了到了K(千字节)，同时文件大小大于M, 此方法的输出将还是显示成多少K.\n             * @example\n             * console.log( Base.formatSize( 100 ) );    // => 100B\n             * console.log( Base.formatSize( 1024 ) );    // => 1.00K\n             * console.log( Base.formatSize( 1024, 0 ) );    // => 1K\n             * console.log( Base.formatSize( 1024 * 1024 ) );    // => 1.00M\n             * console.log( Base.formatSize( 1024 * 1024 * 1024 ) );    // => 1.00G\n             * console.log( Base.formatSize( 1024 * 1024 * 1024, 0, ['B', 'KB', 'MB'] ) );    // => 1024MB\n             */\n            formatSize: function formatSize(size, pointLength, units) {\n                var unit;\n\n                units = units || ['B', 'K', 'M', 'G', 'TB'];\n\n                while ((unit = units.shift()) && size > 1024) {\n                    size = size / 1024;\n                }\n\n                return (unit === 'B' ? size : size.toFixed(pointLength || 2)) + unit;\n            }\n        };\n    });\n    /**\n     * 事件处理类，可以独立使用，也可以扩展给对象使用。\n     * @fileOverview Mediator\n     */\n    define('mediator', ['base'], function (Base) {\n        var $ = Base.$,\n            slice = [].slice,\n            separator = /\\s+/,\n            protos;\n\n        // 根据条件过滤出事件handlers.\n        function findHandlers(arr, name, callback, context) {\n            return $.grep(arr, function (handler) {\n                return handler && (!name || handler.e === name) && (!callback || handler.cb === callback || handler.cb._cb === callback) && (!context || handler.ctx === context);\n            });\n        }\n\n        function eachEvent(events, callback, iterator) {\n            // 不支持对象，只支持多个event用空格隔开\n            $.each((events || '').split(separator), function (_, key) {\n                iterator(key, callback);\n            });\n        }\n\n        function triggerHanders(events, args) {\n            var stoped = false,\n                i = -1,\n                len = events.length,\n                handler;\n\n            while (++i < len) {\n                handler = events[i];\n\n                if (handler.cb.apply(handler.ctx2, args) === false) {\n                    stoped = true;\n                    break;\n                }\n            }\n\n            return !stoped;\n        }\n\n        protos = {\n\n            /**\n             * 绑定事件。\n             *\n             * `callback`方法在执行时，arguments将会来源于trigger的时候携带的参数。如\n             * ```javascript\n             * var obj = {};\n             *\n             * // 使得obj有事件行为\n             * Mediator.installTo( obj );\n             *\n             * obj.on( 'testa', function( arg1, arg2 ) {\n             *     console.log( arg1, arg2 ); // => 'arg1', 'arg2'\n             * });\n             *\n             * obj.trigger( 'testa', 'arg1', 'arg2' );\n             * ```\n             *\n             * 如果`callback`中，某一个方法`return false`了，则后续的其他`callback`都不会被执行到。\n             * 切会影响到`trigger`方法的返回值，为`false`。\n             *\n             * `on`还可以用来添加一个特殊事件`all`, 这样所有的事件触发都会响应到。同时此类`callback`中的arguments有一个不同处，\n             * 就是第一个参数为`type`，记录当前是什么事件在触发。此类`callback`的优先级比脚低，会再正常`callback`执行完后触发。\n             * ```javascript\n             * obj.on( 'all', function( type, arg1, arg2 ) {\n             *     console.log( type, arg1, arg2 ); // => 'testa', 'arg1', 'arg2'\n             * });\n             * ```\n             *\n             * @method on\n             * @grammar on( name, callback[, context] ) => self\n             * @param  {String}   name     事件名，支持多个事件用空格隔开\n             * @param  {Function} callback 事件处理器\n             * @param  {Object}   [context]  事件处理器的上下文。\n             * @return {self} 返回自身，方便链式\n             * @chainable\n             * @class Mediator\n             */\n            on: function on(name, callback, context) {\n                var me = this,\n                    set;\n\n                if (!callback) {\n                    return this;\n                }\n\n                set = this._events || (this._events = []);\n\n                eachEvent(name, callback, function (name, callback) {\n                    var handler = { e: name };\n\n                    handler.cb = callback;\n                    handler.ctx = context;\n                    handler.ctx2 = context || me;\n                    handler.id = set.length;\n\n                    set.push(handler);\n                });\n\n                return this;\n            },\n\n            /**\n             * 绑定事件，且当handler执行完后，自动解除绑定。\n             * @method once\n             * @grammar once( name, callback[, context] ) => self\n             * @param  {String}   name     事件名\n             * @param  {Function} callback 事件处理器\n             * @param  {Object}   [context]  事件处理器的上下文。\n             * @return {self} 返回自身，方便链式\n             * @chainable\n             */\n            once: function once(name, callback, context) {\n                var me = this;\n\n                if (!callback) {\n                    return me;\n                }\n\n                eachEvent(name, callback, function (name, callback) {\n                    var once = function once() {\n                        me.off(name, once);\n                        return callback.apply(context || me, arguments);\n                    };\n\n                    once._cb = callback;\n                    me.on(name, once, context);\n                });\n\n                return me;\n            },\n\n            /**\n             * 解除事件绑定\n             * @method off\n             * @grammar off( [name[, callback[, context] ] ] ) => self\n             * @param  {String}   [name]     事件名\n             * @param  {Function} [callback] 事件处理器\n             * @param  {Object}   [context]  事件处理器的上下文。\n             * @return {self} 返回自身，方便链式\n             * @chainable\n             */\n            off: function off(name, cb, ctx) {\n                var events = this._events;\n\n                if (!events) {\n                    return this;\n                }\n\n                if (!name && !cb && !ctx) {\n                    this._events = [];\n                    return this;\n                }\n\n                eachEvent(name, cb, function (name, cb) {\n                    $.each(findHandlers(events, name, cb, ctx), function () {\n                        delete events[this.id];\n                    });\n                });\n\n                return this;\n            },\n\n            /**\n             * 触发事件\n             * @method trigger\n             * @grammar trigger( name[, args...] ) => self\n             * @param  {String}   type     事件名\n             * @param  {*} [...] 任意参数\n             * @return {Boolean} 如果handler中return false了，则返回false, 否则返回true\n             */\n            trigger: function trigger(type) {\n                var args, events, allEvents;\n\n                if (!this._events || !type) {\n                    return this;\n                }\n\n                args = slice.call(arguments, 1);\n                events = findHandlers(this._events, type);\n                allEvents = findHandlers(this._events, 'all');\n\n                return triggerHanders(events, args) && triggerHanders(allEvents, arguments);\n            }\n        };\n\n        /**\n         * 中介者，它本身是个单例，但可以通过[installTo](#WebUploader:Mediator:installTo)方法，使任何对象具备事件行为。\n         * 主要目的是负责模块与模块之间的合作，降低耦合度。\n         *\n         * @class Mediator\n         */\n        return $.extend({\n\n            /**\n             * 可以通过这个接口，使任何对象具备事件功能。\n             * @method installTo\n             * @param  {Object} obj 需要具备事件行为的对象。\n             * @return {Object} 返回obj.\n             */\n            installTo: function installTo(obj) {\n                return $.extend(obj, protos);\n            }\n\n        }, protos);\n    });\n    /**\n     * @fileOverview Uploader上传类\n     */\n    define('uploader', ['base', 'mediator'], function (Base, Mediator) {\n\n        var $ = Base.$;\n\n        /**\n         * 上传入口类。\n         * @class Uploader\n         * @constructor\n         * @grammar new Uploader( opts ) => Uploader\n         * @example\n         * var uploader = WebUploader.Uploader({\n         *     swf: 'path_of_swf/Uploader.swf',\n         *\n         *     // 开起分片上传。\n         *     chunked: true\n         * });\n         */\n        function Uploader(opts) {\n            this.options = $.extend(true, {}, Uploader.options, opts);\n            this._init(this.options);\n        }\n\n        // default Options\n        // widgets中有相应扩展\n        Uploader.options = {};\n        Mediator.installTo(Uploader.prototype);\n\n        // 批量添加纯命令式方法。\n        $.each({\n            upload: 'start-upload',\n            stop: 'stop-upload',\n            getFile: 'get-file',\n            getFiles: 'get-files',\n            addFile: 'add-file',\n            addFiles: 'add-file',\n            sort: 'sort-files',\n            removeFile: 'remove-file',\n            cancelFile: 'cancel-file',\n            skipFile: 'skip-file',\n            retry: 'retry',\n            isInProgress: 'is-in-progress',\n            makeThumb: 'make-thumb',\n            md5File: 'md5-file',\n            getDimension: 'get-dimension',\n            addButton: 'add-btn',\n            predictRuntimeType: 'predict-runtime-type',\n            refresh: 'refresh',\n            disable: 'disable',\n            enable: 'enable',\n            reset: 'reset'\n        }, function (fn, command) {\n            Uploader.prototype[fn] = function () {\n                return this.request(command, arguments);\n            };\n        });\n\n        $.extend(Uploader.prototype, {\n            state: 'pending',\n\n            _init: function _init(opts) {\n                var me = this;\n\n                me.request('init', opts, function () {\n                    me.state = 'ready';\n                    me.trigger('ready');\n                });\n            },\n\n            /**\n             * 获取或者设置Uploader配置项。\n             * @method option\n             * @grammar option( key ) => *\n             * @grammar option( key, val ) => self\n             * @example\n             *\n             * // 初始状态图片上传前不会压缩\n             * var uploader = new WebUploader.Uploader({\n             *     compress: null;\n             * });\n             *\n             * // 修改后图片上传前，尝试将图片压缩到1600 * 1600\n             * uploader.option( 'compress', {\n             *     width: 1600,\n             *     height: 1600\n             * });\n             */\n            option: function option(key, val) {\n                var opts = this.options;\n\n                // setter\n                if (arguments.length > 1) {\n\n                    if ($.isPlainObject(val) && $.isPlainObject(opts[key])) {\n                        $.extend(opts[key], val);\n                    } else {\n                        opts[key] = val;\n                    }\n                } else {\n                    // getter\n                    return key ? opts[key] : opts;\n                }\n            },\n\n            /**\n             * 获取文件统计信息。返回一个包含一下信息的对象。\n             * * `successNum` 上传成功的文件数\n             * * `progressNum` 上传中的文件数\n             * * `cancelNum` 被删除的文件数\n             * * `invalidNum` 无效的文件数\n             * * `uploadFailNum` 上传失败的文件数\n             * * `queueNum` 还在队列中的文件数\n             * * `interruptNum` 被暂停的文件数\n             * @method getStats\n             * @grammar getStats() => Object\n             */\n            getStats: function getStats() {\n                // return this._mgr.getStats.apply( this._mgr, arguments );\n                var stats = this.request('get-stats');\n\n                return stats ? {\n                    successNum: stats.numOfSuccess,\n                    progressNum: stats.numOfProgress,\n\n                    // who care?\n                    // queueFailNum: 0,\n                    cancelNum: stats.numOfCancel,\n                    invalidNum: stats.numOfInvalid,\n                    uploadFailNum: stats.numOfUploadFailed,\n                    queueNum: stats.numOfQueue,\n                    interruptNum: stats.numofInterrupt\n                } : {};\n            },\n\n            // 需要重写此方法来来支持opts.onEvent和instance.onEvent的处理器\n            trigger: function trigger(type /*, args...*/) {\n                var args = [].slice.call(arguments, 1),\n                    opts = this.options,\n                    name = 'on' + type.substring(0, 1).toUpperCase() + type.substring(1);\n\n                if (\n                // 调用通过on方法注册的handler.\n                Mediator.trigger.apply(this, arguments) === false ||\n\n                // 调用opts.onEvent\n                $.isFunction(opts[name]) && opts[name].apply(this, args) === false ||\n\n                // 调用this.onEvent\n                $.isFunction(this[name]) && this[name].apply(this, args) === false ||\n\n                // 广播所有uploader的事件。\n                Mediator.trigger.apply(Mediator, [this, type].concat(args)) === false) {\n\n                    return false;\n                }\n\n                return true;\n            },\n\n            /**\n             * 销毁 webuploader 实例\n             * @method destroy\n             * @grammar destroy() => undefined\n             */\n            destroy: function destroy() {\n                this.request('destroy', arguments);\n                this.off();\n            },\n\n            // widgets/widget.js将补充此方法的详细文档。\n            request: Base.noop\n        });\n\n        /**\n         * 创建Uploader实例，等同于new Uploader( opts );\n         * @method create\n         * @class Base\n         * @static\n         * @grammar Base.create( opts ) => Uploader\n         */\n        Base.create = Uploader.create = function (opts) {\n            return new Uploader(opts);\n        };\n\n        // 暴露Uploader，可以通过它来扩展业务逻辑。\n        Base.Uploader = Uploader;\n\n        return Uploader;\n    });\n    /**\n     * @fileOverview Runtime管理器，负责Runtime的选择, 连接\n     */\n    define('runtime/runtime', ['base', 'mediator'], function (Base, Mediator) {\n\n        var $ = Base.$,\n            factories = {},\n\n\n        // 获取对象的第一个key\n        getFirstKey = function getFirstKey(obj) {\n            for (var key in obj) {\n                if (obj.hasOwnProperty(key)) {\n                    return key;\n                }\n            }\n            return null;\n        };\n\n        // 接口类。\n        function Runtime(options) {\n            this.options = $.extend({\n                container: document.body\n            }, options);\n            this.uid = Base.guid('rt_');\n        }\n\n        $.extend(Runtime.prototype, {\n\n            getContainer: function getContainer() {\n                var opts = this.options,\n                    parent,\n                    container;\n\n                if (this._container) {\n                    return this._container;\n                }\n\n                parent = $(opts.container || document.body);\n                container = $(document.createElement('div'));\n\n                container.attr('id', 'rt_' + this.uid);\n                container.css({\n                    position: 'absolute',\n                    top: '0px',\n                    left: '0px',\n                    width: '1px',\n                    height: '1px',\n                    overflow: 'hidden'\n                });\n\n                parent.append(container);\n                parent.addClass('webuploader-container');\n                this._container = container;\n                this._parent = parent;\n                return container;\n            },\n\n            init: Base.noop,\n            exec: Base.noop,\n\n            destroy: function destroy() {\n                this._container && this._container.remove();\n                this._parent && this._parent.removeClass('webuploader-container');\n                this.off();\n            }\n        });\n\n        Runtime.orders = 'html5,flash';\n\n        /**\n         * 添加Runtime实现。\n         * @param {String} type    类型\n         * @param {Runtime} factory 具体Runtime实现。\n         */\n        Runtime.addRuntime = function (type, factory) {\n            factories[type] = factory;\n        };\n\n        Runtime.hasRuntime = function (type) {\n            return !!(type ? factories[type] : getFirstKey(factories));\n        };\n\n        Runtime.create = function (opts, orders) {\n            var type, runtime;\n\n            orders = orders || Runtime.orders;\n            $.each(orders.split(/\\s*,\\s*/g), function () {\n                if (factories[this]) {\n                    type = this;\n                    return false;\n                }\n            });\n\n            type = type || getFirstKey(factories);\n\n            if (!type) {\n                throw new Error('Runtime Error');\n            }\n\n            runtime = new factories[type](opts);\n            return runtime;\n        };\n\n        Mediator.installTo(Runtime.prototype);\n        return Runtime;\n    });\n\n    /**\n     * @fileOverview Runtime管理器，负责Runtime的选择, 连接\n     */\n    define('runtime/client', ['base', 'mediator', 'runtime/runtime'], function (Base, Mediator, Runtime) {\n\n        var cache;\n\n        cache = function () {\n            var obj = {};\n\n            return {\n                add: function add(runtime) {\n                    obj[runtime.uid] = runtime;\n                },\n\n                get: function get(ruid, standalone) {\n                    var i;\n\n                    if (ruid) {\n                        return obj[ruid];\n                    }\n\n                    for (i in obj) {\n                        // 有些类型不能重用，比如filepicker.\n                        if (standalone && obj[i].__standalone) {\n                            continue;\n                        }\n\n                        return obj[i];\n                    }\n\n                    return null;\n                },\n\n                remove: function remove(runtime) {\n                    delete obj[runtime.uid];\n                }\n            };\n        }();\n\n        function RuntimeClient(component, standalone) {\n            var deferred = Base.Deferred(),\n                runtime;\n\n            this.uid = Base.guid('client_');\n\n            // 允许runtime没有初始化之前，注册一些方法在初始化后执行。\n            this.runtimeReady = function (cb) {\n                return deferred.done(cb);\n            };\n\n            this.connectRuntime = function (opts, cb) {\n\n                // already connected.\n                if (runtime) {\n                    throw new Error('already connected!');\n                }\n\n                deferred.done(cb);\n\n                if (typeof opts === 'string' && cache.get(opts)) {\n                    runtime = cache.get(opts);\n                }\n\n                // 像filePicker只能独立存在，不能公用。\n                runtime = runtime || cache.get(null, standalone);\n\n                // 需要创建\n                if (!runtime) {\n                    runtime = Runtime.create(opts, opts.runtimeOrder);\n                    runtime.__promise = deferred.promise();\n                    runtime.once('ready', deferred.resolve);\n                    runtime.init();\n                    cache.add(runtime);\n                    runtime.__client = 1;\n                } else {\n                    // 来自cache\n                    Base.$.extend(runtime.options, opts);\n                    runtime.__promise.then(deferred.resolve);\n                    runtime.__client++;\n                }\n\n                standalone && (runtime.__standalone = standalone);\n                return runtime;\n            };\n\n            this.getRuntime = function () {\n                return runtime;\n            };\n\n            this.disconnectRuntime = function () {\n                if (!runtime) {\n                    return;\n                }\n\n                runtime.__client--;\n\n                if (runtime.__client <= 0) {\n                    cache.remove(runtime);\n                    delete runtime.__promise;\n                    runtime.destroy();\n                }\n\n                runtime = null;\n            };\n\n            this.exec = function () {\n                if (!runtime) {\n                    return;\n                }\n\n                var args = Base.slice(arguments);\n                component && args.unshift(component);\n\n                return runtime.exec.apply(this, args);\n            };\n\n            this.getRuid = function () {\n                return runtime && runtime.uid;\n            };\n\n            this.destroy = function (destroy) {\n                return function () {\n                    destroy && destroy.apply(this, arguments);\n                    this.trigger('destroy');\n                    this.off();\n                    this.exec('destroy');\n                    this.disconnectRuntime();\n                };\n            }(this.destroy);\n        }\n\n        Mediator.installTo(RuntimeClient.prototype);\n        return RuntimeClient;\n    });\n    /**\n     * @fileOverview 错误信息\n     */\n    define('lib/dnd', ['base', 'mediator', 'runtime/client'], function (Base, Mediator, RuntimeClent) {\n\n        var $ = Base.$;\n\n        function DragAndDrop(opts) {\n            opts = this.options = $.extend({}, DragAndDrop.options, opts);\n\n            opts.container = $(opts.container);\n\n            if (!opts.container.length) {\n                return;\n            }\n\n            RuntimeClent.call(this, 'DragAndDrop');\n        }\n\n        DragAndDrop.options = {\n            accept: null,\n            disableGlobalDnd: false\n        };\n\n        Base.inherits(RuntimeClent, {\n            constructor: DragAndDrop,\n\n            init: function init() {\n                var me = this;\n\n                me.connectRuntime(me.options, function () {\n                    me.exec('init');\n                    me.trigger('ready');\n                });\n            }\n        });\n\n        Mediator.installTo(DragAndDrop.prototype);\n\n        return DragAndDrop;\n    });\n    /**\n     * @fileOverview 组件基类。\n     */\n    define('widgets/widget', ['base', 'uploader'], function (Base, Uploader) {\n\n        var $ = Base.$,\n            _init2 = Uploader.prototype._init,\n            _destroy = Uploader.prototype.destroy,\n            IGNORE = {},\n            widgetClass = [];\n\n        function isArrayLike(obj) {\n            if (!obj) {\n                return false;\n            }\n\n            var length = obj.length,\n                type = $.type(obj);\n\n            if (obj.nodeType === 1 && length) {\n                return true;\n            }\n\n            return type === 'array' || type !== 'function' && type !== 'string' && (length === 0 || typeof length === 'number' && length > 0 && length - 1 in obj);\n        }\n\n        function Widget(uploader) {\n            this.owner = uploader;\n            this.options = uploader.options;\n        }\n\n        $.extend(Widget.prototype, {\n\n            init: Base.noop,\n\n            // 类Backbone的事件监听声明，监听uploader实例上的事件\n            // widget直接无法监听事件，事件只能通过uploader来传递\n            invoke: function invoke(apiName, args) {\n\n                /*\n                    {\n                        'make-thumb': 'makeThumb'\n                    }\n                 */\n                var map = this.responseMap;\n\n                // 如果无API响应声明则忽略\n                if (!map || !(apiName in map) || !(map[apiName] in this) || !$.isFunction(this[map[apiName]])) {\n\n                    return IGNORE;\n                }\n\n                return this[map[apiName]].apply(this, args);\n            },\n\n            /**\n             * 发送命令。当传入`callback`或者`handler`中返回`promise`时。返回一个当所有`handler`中的promise都完成后完成的新`promise`。\n             * @method request\n             * @grammar request( command, args ) => * | Promise\n             * @grammar request( command, args, callback ) => Promise\n             * @for  Uploader\n             */\n            request: function request() {\n                return this.owner.request.apply(this.owner, arguments);\n            }\n        });\n\n        // 扩展Uploader.\n        $.extend(Uploader.prototype, {\n\n            /**\n             * @property {String | Array} [disableWidgets=undefined]\n             * @namespace options\n             * @for Uploader\n             * @description 默认所有 Uploader.register 了的 widget 都会被加载，如果禁用某一部分，请通过此 option 指定黑名单。\n             */\n\n            // 覆写_init用来初始化widgets\n            _init: function _init() {\n                var me = this,\n                    widgets = me._widgets = [],\n                    deactives = me.options.disableWidgets || '';\n\n                $.each(widgetClass, function (_, klass) {\n                    (!deactives || !~deactives.indexOf(klass._name)) && widgets.push(new klass(me));\n                });\n\n                return _init2.apply(me, arguments);\n            },\n\n            request: function request(apiName, args, callback) {\n                var i = 0,\n                    widgets = this._widgets,\n                    len = widgets && widgets.length,\n                    rlts = [],\n                    dfds = [],\n                    widget,\n                    rlt,\n                    promise,\n                    key;\n\n                args = isArrayLike(args) ? args : [args];\n\n                for (; i < len; i++) {\n                    widget = widgets[i];\n                    rlt = widget.invoke(apiName, args);\n\n                    if (rlt !== IGNORE) {\n\n                        // Deferred对象\n                        if (Base.isPromise(rlt)) {\n                            dfds.push(rlt);\n                        } else {\n                            rlts.push(rlt);\n                        }\n                    }\n                }\n\n                // 如果有callback，则用异步方式。\n                if (callback || dfds.length) {\n                    promise = Base.when.apply(Base, dfds);\n                    key = promise.pipe ? 'pipe' : 'then';\n\n                    // 很重要不能删除。删除了会死循环。\n                    // 保证执行顺序。让callback总是在下一个 tick 中执行。\n                    return promise[key](function () {\n                        var deferred = Base.Deferred(),\n                            args = arguments;\n\n                        if (args.length === 1) {\n                            args = args[0];\n                        }\n\n                        setTimeout(function () {\n                            deferred.resolve(args);\n                        }, 1);\n\n                        return deferred.promise();\n                    })[callback ? key : 'done'](callback || Base.noop);\n                } else {\n                    return rlts[0];\n                }\n            },\n\n            destroy: function destroy() {\n                _destroy.apply(this, arguments);\n                this._widgets = null;\n            }\n        });\n\n        /**\n         * 添加组件\n         * @grammar Uploader.register(proto);\n         * @grammar Uploader.register(map, proto);\n         * @param  {object} responseMap API 名称与函数实现的映射\n         * @param  {object} proto 组件原型，构造函数通过 constructor 属性定义\n         * @method Uploader.register\n         * @for Uploader\n         * @example\n         * Uploader.register({\n         *     'make-thumb': 'makeThumb'\n         * }, {\n         *     init: function( options ) {},\n         *     makeThumb: function() {}\n         * });\n         *\n         * Uploader.register({\n         *     'make-thumb': function() {\n         *         \n         *     }\n         * });\n         */\n        Uploader.register = Widget.register = function (responseMap, widgetProto) {\n            var map = { init: 'init', destroy: 'destroy', name: 'anonymous' },\n                klass;\n\n            if (arguments.length === 1) {\n                widgetProto = responseMap;\n\n                // 自动生成 map 表。\n                $.each(widgetProto, function (key) {\n                    if (key[0] === '_' || key === 'name') {\n                        key === 'name' && (map.name = widgetProto.name);\n                        return;\n                    }\n\n                    map[key.replace(/[A-Z]/g, '-$&').toLowerCase()] = key;\n                });\n            } else {\n                map = $.extend(map, responseMap);\n            }\n\n            widgetProto.responseMap = map;\n            klass = Base.inherits(Widget, widgetProto);\n            klass._name = map.name;\n            widgetClass.push(klass);\n\n            return klass;\n        };\n\n        /**\n         * 删除插件，只有在注册时指定了名字的才能被删除。\n         * @grammar Uploader.unRegister(name);\n         * @param  {string} name 组件名字\n         * @method Uploader.unRegister\n         * @for Uploader\n         * @example\n         *\n         * Uploader.register({\n         *     name: 'custom',\n         *     \n         *     'make-thumb': function() {\n         *         \n         *     }\n         * });\n         *\n         * Uploader.unRegister('custom');\n         */\n        Uploader.unRegister = Widget.unRegister = function (name) {\n            if (!name || name === 'anonymous') {\n                return;\n            }\n\n            // 删除指定的插件。\n            for (var i = widgetClass.length; i--;) {\n                if (widgetClass[i]._name === name) {\n                    widgetClass.splice(i, 1);\n                }\n            }\n        };\n\n        return Widget;\n    });\n    /**\n     * @fileOverview DragAndDrop Widget。\n     */\n    define('widgets/filednd', ['base', 'uploader', 'lib/dnd', 'widgets/widget'], function (Base, Uploader, Dnd) {\n        var $ = Base.$;\n\n        Uploader.options.dnd = '';\n\n        /**\n         * @property {Selector} [dnd=undefined]  指定Drag And Drop拖拽的容器，如果不指定，则不启动。\n         * @namespace options\n         * @for Uploader\n         */\n\n        /**\n         * @property {Selector} [disableGlobalDnd=false]  是否禁掉整个页面的拖拽功能，如果不禁用，图片拖进来的时候会默认被浏览器打开。\n         * @namespace options\n         * @for Uploader\n         */\n\n        /**\n         * @event dndAccept\n         * @param {DataTransferItemList} items DataTransferItem\n         * @description 阻止此事件可以拒绝某些类型的文件拖入进来。目前只有 chrome 提供这样的 API，且只能通过 mime-type 验证。\n         * @for  Uploader\n         */\n        return Uploader.register({\n            name: 'dnd',\n\n            init: function init(opts) {\n\n                if (!opts.dnd || this.request('predict-runtime-type') !== 'html5') {\n                    return;\n                }\n\n                var me = this,\n                    deferred = Base.Deferred(),\n                    options = $.extend({}, {\n                    disableGlobalDnd: opts.disableGlobalDnd,\n                    container: opts.dnd,\n                    accept: opts.accept\n                }),\n                    dnd;\n\n                this.dnd = dnd = new Dnd(options);\n\n                dnd.once('ready', deferred.resolve);\n                dnd.on('drop', function (files) {\n                    me.request('add-file', [files]);\n                });\n\n                // 检测文件是否全部允许添加。\n                dnd.on('accept', function (items) {\n                    return me.owner.trigger('dndAccept', items);\n                });\n\n                dnd.init();\n\n                return deferred.promise();\n            },\n\n            destroy: function destroy() {\n                this.dnd && this.dnd.destroy();\n            }\n        });\n    });\n\n    /**\n     * @fileOverview 错误信息\n     */\n    define('lib/filepaste', ['base', 'mediator', 'runtime/client'], function (Base, Mediator, RuntimeClent) {\n\n        var $ = Base.$;\n\n        function FilePaste(opts) {\n            opts = this.options = $.extend({}, opts);\n            opts.container = $(opts.container || document.body);\n            RuntimeClent.call(this, 'FilePaste');\n        }\n\n        Base.inherits(RuntimeClent, {\n            constructor: FilePaste,\n\n            init: function init() {\n                var me = this;\n\n                me.connectRuntime(me.options, function () {\n                    me.exec('init');\n                    me.trigger('ready');\n                });\n            }\n        });\n\n        Mediator.installTo(FilePaste.prototype);\n\n        return FilePaste;\n    });\n    /**\n     * @fileOverview 组件基类。\n     */\n    define('widgets/filepaste', ['base', 'uploader', 'lib/filepaste', 'widgets/widget'], function (Base, Uploader, FilePaste) {\n        var $ = Base.$;\n\n        /**\n         * @property {Selector} [paste=undefined]  指定监听paste事件的容器，如果不指定，不启用此功能。此功能为通过粘贴来添加截屏的图片。建议设置为`document.body`.\n         * @namespace options\n         * @for Uploader\n         */\n        return Uploader.register({\n            name: 'paste',\n\n            init: function init(opts) {\n\n                if (!opts.paste || this.request('predict-runtime-type') !== 'html5') {\n                    return;\n                }\n\n                var me = this,\n                    deferred = Base.Deferred(),\n                    options = $.extend({}, {\n                    container: opts.paste,\n                    accept: opts.accept\n                }),\n                    paste;\n\n                this.paste = paste = new FilePaste(options);\n\n                paste.once('ready', deferred.resolve);\n                paste.on('paste', function (files) {\n                    me.owner.request('add-file', [files]);\n                });\n                paste.init();\n\n                return deferred.promise();\n            },\n\n            destroy: function destroy() {\n                this.paste && this.paste.destroy();\n            }\n        });\n    });\n    /**\n     * @fileOverview Blob\n     */\n    define('lib/blob', ['base', 'runtime/client'], function (Base, RuntimeClient) {\n\n        function Blob(ruid, source) {\n            var me = this;\n\n            me.source = source;\n            me.ruid = ruid;\n            this.size = source.size || 0;\n\n            // 如果没有指定 mimetype, 但是知道文件后缀。\n            if (!source.type && this.ext && ~'jpg,jpeg,png,gif,bmp'.indexOf(this.ext)) {\n                this.type = 'image/' + (this.ext === 'jpg' ? 'jpeg' : this.ext);\n            } else {\n                this.type = source.type || 'application/octet-stream';\n            }\n\n            RuntimeClient.call(me, 'Blob');\n            this.uid = source.uid || this.uid;\n\n            if (ruid) {\n                me.connectRuntime(ruid);\n            }\n        }\n\n        Base.inherits(RuntimeClient, {\n            constructor: Blob,\n\n            slice: function slice(start, end) {\n                return this.exec('slice', start, end);\n            },\n\n            getSource: function getSource() {\n                return this.source;\n            }\n        });\n\n        return Blob;\n    });\n    /**\n     * 为了统一化Flash的File和HTML5的File而存在。\n     * 以至于要调用Flash里面的File，也可以像调用HTML5版本的File一下。\n     * @fileOverview File\n     */\n    define('lib/file', ['base', 'lib/blob'], function (Base, Blob) {\n\n        var uid = 1,\n            rExt = /\\.([^.]+)$/;\n\n        function File(ruid, file) {\n            var ext;\n\n            this.name = file.name || 'untitled' + uid++;\n            ext = rExt.exec(file.name) ? RegExp.$1.toLowerCase() : '';\n\n            // todo 支持其他类型文件的转换。\n            // 如果有 mimetype, 但是文件名里面没有找出后缀规律\n            if (!ext && file.type) {\n                ext = /\\/(jpg|jpeg|png|gif|bmp)$/i.exec(file.type) ? RegExp.$1.toLowerCase() : '';\n                this.name += '.' + ext;\n            }\n\n            this.ext = ext;\n            this.lastModifiedDate = file.lastModifiedDate || new Date().toLocaleString();\n\n            Blob.apply(this, arguments);\n        }\n\n        return Base.inherits(Blob, File);\n    });\n\n    /**\n     * @fileOverview 错误信息\n     */\n    define('lib/filepicker', ['base', 'runtime/client', 'lib/file'], function (Base, RuntimeClent, File) {\n\n        var $ = Base.$;\n\n        function FilePicker(opts) {\n            opts = this.options = $.extend({}, FilePicker.options, opts);\n\n            opts.container = $(opts.id);\n\n            if (!opts.container.length) {\n                throw new Error('按钮指定错误');\n            }\n\n            opts.innerHTML = opts.innerHTML || opts.label || opts.container.html() || '';\n\n            opts.button = $(opts.button || document.createElement('div'));\n            opts.button.html(opts.innerHTML);\n            opts.container.html(opts.button);\n\n            RuntimeClent.call(this, 'FilePicker', true);\n        }\n\n        FilePicker.options = {\n            button: null,\n            container: null,\n            label: null,\n            innerHTML: null,\n            multiple: true,\n            accept: null,\n            name: 'file'\n        };\n\n        Base.inherits(RuntimeClent, {\n            constructor: FilePicker,\n\n            init: function init() {\n                var me = this,\n                    opts = me.options,\n                    button = opts.button;\n\n                button.addClass('webuploader-pick');\n\n                me.on('all', function (type) {\n                    var files;\n\n                    switch (type) {\n                        case 'mouseenter':\n                            button.addClass('webuploader-pick-hover');\n                            break;\n\n                        case 'mouseleave':\n                            button.removeClass('webuploader-pick-hover');\n                            break;\n\n                        case 'change':\n                            files = me.exec('getFiles');\n                            me.trigger('select', $.map(files, function (file) {\n                                file = new File(me.getRuid(), file);\n\n                                // 记录来源。\n                                file._refer = opts.container;\n                                return file;\n                            }), opts.container);\n                            break;\n                    }\n                });\n\n                me.connectRuntime(opts, function () {\n                    me.refresh();\n                    me.exec('init', opts);\n                    me.trigger('ready');\n                });\n\n                this._resizeHandler = Base.bindFn(this.refresh, this);\n                $(window).on('resize', this._resizeHandler);\n            },\n\n            refresh: function refresh() {\n                var shimContainer = this.getRuntime().getContainer(),\n                    button = this.options.button,\n                    width = button.outerWidth ? button.outerWidth() : button.width(),\n                    height = button.outerHeight ? button.outerHeight() : button.height(),\n                    pos = button.offset();\n\n                width && height && shimContainer.css({\n                    bottom: 'auto',\n                    right: 'auto',\n                    width: width + 'px',\n                    height: height + 'px'\n                }).offset(pos);\n            },\n\n            enable: function enable() {\n                var btn = this.options.button;\n\n                btn.removeClass('webuploader-pick-disable');\n                this.refresh();\n            },\n\n            disable: function disable() {\n                var btn = this.options.button;\n\n                this.getRuntime().getContainer().css({\n                    top: '-99999px'\n                });\n\n                btn.addClass('webuploader-pick-disable');\n            },\n\n            destroy: function destroy() {\n                var btn = this.options.button;\n                $(window).off('resize', this._resizeHandler);\n                btn.removeClass('webuploader-pick-disable webuploader-pick-hover ' + 'webuploader-pick');\n            }\n        });\n\n        return FilePicker;\n    });\n\n    /**\n     * @fileOverview 文件选择相关\n     */\n    define('widgets/filepicker', ['base', 'uploader', 'lib/filepicker', 'widgets/widget'], function (Base, Uploader, FilePicker) {\n        var $ = Base.$;\n\n        $.extend(Uploader.options, {\n\n            /**\n             * @property {Selector | Object} [pick=undefined]\n             * @namespace options\n             * @for Uploader\n             * @description 指定选择文件的按钮容器，不指定则不创建按钮。\n             *\n             * * `id` {Seletor|dom} 指定选择文件的按钮容器，不指定则不创建按钮。**注意** 这里虽然写的是 id, 但是不是只支持 id, 还支持 class, 或者 dom 节点。\n             * * `label` {String} 请采用 `innerHTML` 代替\n             * * `innerHTML` {String} 指定按钮文字。不指定时优先从指定的容器中看是否自带文字。\n             * * `multiple` {Boolean} 是否开起同时选择多个文件能力。\n             */\n            pick: null,\n\n            /**\n             * @property {Arroy} [accept=null]\n             * @namespace options\n             * @for Uploader\n             * @description 指定接受哪些类型的文件。 由于目前还有ext转mimeType表，所以这里需要分开指定。\n             *\n             * * `title` {String} 文字描述\n             * * `extensions` {String} 允许的文件后缀，不带点，多个用逗号分割。\n             * * `mimeTypes` {String} 多个用逗号分割。\n             *\n             * 如：\n             *\n             * ```\n             * {\n             *     title: 'Images',\n             *     extensions: 'gif,jpg,jpeg,bmp,png',\n             *     mimeTypes: 'image/*'\n             * }\n             * ```\n             */\n            accept: null /*{\n                         title: 'Images',\n                         extensions: 'gif,jpg,jpeg,bmp,png',\n                         mimeTypes: 'image/*'\n                         }*/\n        });\n\n        return Uploader.register({\n            name: 'picker',\n\n            init: function init(opts) {\n                this.pickers = [];\n                return opts.pick && this.addBtn(opts.pick);\n            },\n\n            refresh: function refresh() {\n                $.each(this.pickers, function () {\n                    this.refresh();\n                });\n            },\n\n            /**\n             * @method addButton\n             * @for Uploader\n             * @grammar addButton( pick ) => Promise\n             * @description\n             * 添加文件选择按钮，如果一个按钮不够，需要调用此方法来添加。参数跟[options.pick](#WebUploader:Uploader:options)一致。\n             * @example\n             * uploader.addButton({\n             *     id: '#btnContainer',\n             *     innerHTML: '选择文件'\n             * });\n             */\n            addBtn: function addBtn(pick) {\n                var me = this,\n                    opts = me.options,\n                    accept = opts.accept,\n                    promises = [];\n\n                if (!pick) {\n                    return;\n                }\n\n                $.isPlainObject(pick) || (pick = {\n                    id: pick\n                });\n\n                $(pick.id).each(function () {\n                    var options, picker, deferred;\n\n                    deferred = Base.Deferred();\n\n                    options = $.extend({}, pick, {\n                        accept: $.isPlainObject(accept) ? [accept] : accept,\n                        swf: opts.swf,\n                        runtimeOrder: opts.runtimeOrder,\n                        id: this\n                    });\n\n                    picker = new FilePicker(options);\n\n                    picker.once('ready', deferred.resolve);\n                    picker.on('select', function (files) {\n                        me.owner.request('add-file', [files]);\n                    });\n                    picker.init();\n\n                    me.pickers.push(picker);\n\n                    promises.push(deferred.promise());\n                });\n\n                return Base.when.apply(Base, promises);\n            },\n\n            disable: function disable() {\n                $.each(this.pickers, function () {\n                    this.disable();\n                });\n            },\n\n            enable: function enable() {\n                $.each(this.pickers, function () {\n                    this.enable();\n                });\n            },\n\n            destroy: function destroy() {\n                $.each(this.pickers, function () {\n                    this.destroy();\n                });\n                this.pickers = null;\n            }\n        });\n    });\n    /**\n     * @fileOverview Image\n     */\n    define('lib/image', ['base', 'runtime/client', 'lib/blob'], function (Base, RuntimeClient, Blob) {\n        var $ = Base.$;\n\n        // 构造器。\n        function Image(opts) {\n            this.options = $.extend({}, Image.options, opts);\n            RuntimeClient.call(this, 'Image');\n\n            this.on('load', function () {\n                this._info = this.exec('info');\n                this._meta = this.exec('meta');\n            });\n        }\n\n        // 默认选项。\n        Image.options = {\n\n            // 默认的图片处理质量\n            quality: 90,\n\n            // 是否裁剪\n            crop: false,\n\n            // 是否保留头部信息\n            preserveHeaders: false,\n\n            // 是否允许放大。\n            allowMagnify: false\n        };\n\n        // 继承RuntimeClient.\n        Base.inherits(RuntimeClient, {\n            constructor: Image,\n\n            info: function info(val) {\n\n                // setter\n                if (val) {\n                    this._info = val;\n                    return this;\n                }\n\n                // getter\n                return this._info;\n            },\n\n            meta: function meta(val) {\n\n                // setter\n                if (val) {\n                    this._meta = val;\n                    return this;\n                }\n\n                // getter\n                return this._meta;\n            },\n\n            loadFromBlob: function loadFromBlob(blob) {\n                var me = this,\n                    ruid = blob.getRuid();\n\n                this.connectRuntime(ruid, function () {\n                    me.exec('init', me.options);\n                    me.exec('loadFromBlob', blob);\n                });\n            },\n\n            resize: function resize() {\n                var args = Base.slice(arguments);\n                return this.exec.apply(this, ['resize'].concat(args));\n            },\n\n            crop: function crop() {\n                var args = Base.slice(arguments);\n                return this.exec.apply(this, ['crop'].concat(args));\n            },\n\n            getAsDataUrl: function getAsDataUrl(type) {\n                return this.exec('getAsDataUrl', type);\n            },\n\n            getAsBlob: function getAsBlob(type) {\n                var blob = this.exec('getAsBlob', type);\n\n                return new Blob(this.getRuid(), blob);\n            }\n        });\n\n        return Image;\n    });\n    /**\n     * @fileOverview 图片操作, 负责预览图片和上传前压缩图片\n     */\n    define('widgets/image', ['base', 'uploader', 'lib/image', 'widgets/widget'], function (Base, Uploader, Image) {\n\n        var $ = Base.$,\n            throttle;\n\n        // 根据要处理的文件大小来节流，一次不能处理太多，会卡。\n        throttle = function (max) {\n            var occupied = 0,\n                waiting = [],\n                tick = function tick() {\n                var item;\n\n                while (waiting.length && occupied < max) {\n                    item = waiting.shift();\n                    occupied += item[0];\n                    item[1]();\n                }\n            };\n\n            return function (emiter, size, cb) {\n                waiting.push([size, cb]);\n                emiter.once('destroy', function () {\n                    occupied -= size;\n                    setTimeout(tick, 1);\n                });\n                setTimeout(tick, 1);\n            };\n        }(5 * 1024 * 1024);\n\n        $.extend(Uploader.options, {\n\n            /**\n             * @property {Object} [thumb]\n             * @namespace options\n             * @for Uploader\n             * @description 配置生成缩略图的选项。\n             *\n             * 默认为：\n             *\n             * ```javascript\n             * {\n             *     width: 110,\n             *     height: 110,\n             *\n             *     // 图片质量，只有type为`image/jpeg`的时候才有效。\n             *     quality: 70,\n             *\n             *     // 是否允许放大，如果想要生成小图的时候不失真，此选项应该设置为false.\n             *     allowMagnify: true,\n             *\n             *     // 是否允许裁剪。\n             *     crop: true,\n             *\n             *     // 为空的话则保留原有图片格式。\n             *     // 否则强制转换成指定的类型。\n             *     type: 'image/jpeg'\n             * }\n             * ```\n             */\n            thumb: {\n                width: 110,\n                height: 110,\n                quality: 70,\n                allowMagnify: true,\n                crop: true,\n                preserveHeaders: false,\n\n                // 为空的话则保留原有图片格式。\n                // 否则强制转换成指定的类型。\n                // IE 8下面 base64 大小不能超过 32K 否则预览失败，而非 jpeg 编码的图片很可\n                // 能会超过 32k, 所以这里设置成预览的时候都是 image/jpeg\n                type: 'image/jpeg'\n            },\n\n            /**\n             * @property {Object} [compress]\n             * @namespace options\n             * @for Uploader\n             * @description 配置压缩的图片的选项。如果此选项为`false`, 则图片在上传前不进行压缩。\n             *\n             * 默认为：\n             *\n             * ```javascript\n             * {\n             *     width: 1600,\n             *     height: 1600,\n             *\n             *     // 图片质量，只有type为`image/jpeg`的时候才有效。\n             *     quality: 90,\n             *\n             *     // 是否允许放大，如果想要生成小图的时候不失真，此选项应该设置为false.\n             *     allowMagnify: false,\n             *\n             *     // 是否允许裁剪。\n             *     crop: false,\n             *\n             *     // 是否保留头部meta信息。\n             *     preserveHeaders: true,\n             *\n             *     // 如果发现压缩后文件大小比原来还大，则使用原来图片\n             *     // 此属性可能会影响图片自动纠正功能\n             *     noCompressIfLarger: false,\n             *\n             *     // 单位字节，如果图片大小小于此值，不会采用压缩。\n             *     compressSize: 0\n             * }\n             * ```\n             */\n            compress: {\n                width: 1600,\n                height: 1600,\n                quality: 90,\n                allowMagnify: false,\n                crop: false,\n                preserveHeaders: true\n            }\n        });\n\n        return Uploader.register({\n\n            name: 'image',\n\n            /**\n             * 生成缩略图，此过程为异步，所以需要传入`callback`。\n             * 通常情况在图片加入队里后调用此方法来生成预览图以增强交互效果。\n             *\n             * 当 width 或者 height 的值介于 0 - 1 时，被当成百分比使用。\n             *\n             * `callback`中可以接收到两个参数。\n             * * 第一个为error，如果生成缩略图有错误，此error将为真。\n             * * 第二个为ret, 缩略图的Data URL值。\n             *\n             * **注意**\n             * Date URL在IE6/7中不支持，所以不用调用此方法了，直接显示一张暂不支持预览图片好了。\n             * 也可以借助服务端，将 base64 数据传给服务端，生成一个临时文件供预览。\n             *\n             * @method makeThumb\n             * @grammar makeThumb( file, callback ) => undefined\n             * @grammar makeThumb( file, callback, width, height ) => undefined\n             * @for Uploader\n             * @example\n             *\n             * uploader.on( 'fileQueued', function( file ) {\n             *     var $li = ...;\n             *\n             *     uploader.makeThumb( file, function( error, ret ) {\n             *         if ( error ) {\n             *             $li.text('预览错误');\n             *         } else {\n             *             $li.append('<img alt=\"\" src=\"' + ret + '\" />');\n             *         }\n             *     });\n             *\n             * });\n             */\n            makeThumb: function makeThumb(file, cb, width, height) {\n                var opts, image;\n\n                file = this.request('get-file', file);\n\n                // 只预览图片格式。\n                if (!file.type.match(/^image/)) {\n                    cb(true);\n                    return;\n                }\n\n                opts = $.extend({}, this.options.thumb);\n\n                // 如果传入的是object.\n                if ($.isPlainObject(width)) {\n                    opts = $.extend(opts, width);\n                    width = null;\n                }\n\n                width = width || opts.width;\n                height = height || opts.height;\n\n                image = new Image(opts);\n\n                image.once('load', function () {\n                    file._info = file._info || image.info();\n                    file._meta = file._meta || image.meta();\n\n                    // 如果 width 的值介于 0 - 1\n                    // 说明设置的是百分比。\n                    if (width <= 1 && width > 0) {\n                        width = file._info.width * width;\n                    }\n\n                    // 同样的规则应用于 height\n                    if (height <= 1 && height > 0) {\n                        height = file._info.height * height;\n                    }\n\n                    image.resize(width, height);\n                });\n\n                // 当 resize 完后\n                image.once('complete', function () {\n                    cb(false, image.getAsDataUrl(opts.type));\n                    image.destroy();\n                });\n\n                image.once('error', function (reason) {\n                    cb(reason || true);\n                    image.destroy();\n                });\n\n                throttle(image, file.source.size, function () {\n                    file._info && image.info(file._info);\n                    file._meta && image.meta(file._meta);\n                    image.loadFromBlob(file.source);\n                });\n            },\n\n            beforeSendFile: function beforeSendFile(file) {\n                var opts = this.options.compress || this.options.resize,\n                    compressSize = opts && opts.compressSize || 0,\n                    noCompressIfLarger = opts && opts.noCompressIfLarger || false,\n                    image,\n                    deferred;\n\n                file = this.request('get-file', file);\n\n                // 只压缩 jpeg 图片格式。\n                // gif 可能会丢失针\n                // bmp png 基本上尺寸都不大，且压缩比比较小。\n                if (!opts || !~'image/jpeg,image/jpg'.indexOf(file.type) || file.size < compressSize || file._compressed) {\n                    return;\n                }\n\n                opts = $.extend({}, opts);\n                deferred = Base.Deferred();\n\n                image = new Image(opts);\n\n                deferred.always(function () {\n                    image.destroy();\n                    image = null;\n                });\n                image.once('error', deferred.reject);\n                image.once('load', function () {\n                    var width = opts.width,\n                        height = opts.height;\n\n                    file._info = file._info || image.info();\n                    file._meta = file._meta || image.meta();\n\n                    // 如果 width 的值介于 0 - 1\n                    // 说明设置的是百分比。\n                    if (width <= 1 && width > 0) {\n                        width = file._info.width * width;\n                    }\n\n                    // 同样的规则应用于 height\n                    if (height <= 1 && height > 0) {\n                        height = file._info.height * height;\n                    }\n\n                    image.resize(width, height);\n                });\n\n                image.once('complete', function () {\n                    var blob, size;\n\n                    // 移动端 UC / qq 浏览器的无图模式下\n                    // ctx.getImageData 处理大图的时候会报 Exception\n                    // INDEX_SIZE_ERR: DOM Exception 1\n                    try {\n                        blob = image.getAsBlob(opts.type);\n\n                        size = file.size;\n\n                        // 如果压缩后，比原来还大则不用压缩后的。\n                        if (!noCompressIfLarger || blob.size < size) {\n                            // file.source.destroy && file.source.destroy();\n                            file.source = blob;\n                            file.size = blob.size;\n\n                            file.trigger('resize', blob.size, size);\n                        }\n\n                        // 标记，避免重复压缩。\n                        file._compressed = true;\n                        deferred.resolve();\n                    } catch (e) {\n                        // 出错了直接继续，让其上传原始图片\n                        deferred.resolve();\n                    }\n                });\n\n                file._info && image.info(file._info);\n                file._meta && image.meta(file._meta);\n\n                image.loadFromBlob(file.source);\n                return deferred.promise();\n            }\n        });\n    });\n    /**\n     * @fileOverview 文件属性封装\n     */\n    define('file', ['base', 'mediator'], function (Base, Mediator) {\n\n        var $ = Base.$,\n            idPrefix = 'WU_FILE_',\n            idSuffix = 0,\n            rExt = /\\.([^.]+)$/,\n            statusMap = {};\n\n        function gid() {\n            return idPrefix + idSuffix++;\n        }\n\n        /**\n         * 文件类\n         * @class File\n         * @constructor 构造函数\n         * @grammar new File( source ) => File\n         * @param {Lib.File} source [lib.File](#Lib.File)实例, 此source对象是带有Runtime信息的。\n         */\n        function WUFile(source) {\n\n            /**\n             * 文件名，包括扩展名（后缀）\n             * @property name\n             * @type {string}\n             */\n            this.name = source.name || 'Untitled';\n\n            /**\n             * 文件体积（字节）\n             * @property size\n             * @type {uint}\n             * @default 0\n             */\n            this.size = source.size || 0;\n\n            /**\n             * 文件MIMETYPE类型，与文件类型的对应关系请参考[http://t.cn/z8ZnFny](http://t.cn/z8ZnFny)\n             * @property type\n             * @type {string}\n             * @default 'application/octet-stream'\n             */\n            this.type = source.type || 'application/octet-stream';\n\n            /**\n             * 文件最后修改日期\n             * @property lastModifiedDate\n             * @type {int}\n             * @default 当前时间戳\n             */\n            this.lastModifiedDate = source.lastModifiedDate || new Date() * 1;\n\n            /**\n             * 文件ID，每个对象具有唯一ID，与文件名无关\n             * @property id\n             * @type {string}\n             */\n            this.id = gid();\n\n            /**\n             * 文件扩展名，通过文件名获取，例如test.png的扩展名为png\n             * @property ext\n             * @type {string}\n             */\n            this.ext = rExt.exec(this.name) ? RegExp.$1 : '';\n\n            /**\n             * 状态文字说明。在不同的status语境下有不同的用途。\n             * @property statusText\n             * @type {string}\n             */\n            this.statusText = '';\n\n            // 存储文件状态，防止通过属性直接修改\n            statusMap[this.id] = WUFile.Status.INITED;\n\n            this.source = source;\n            this.loaded = 0;\n\n            this.on('error', function (msg) {\n                this.setStatus(WUFile.Status.ERROR, msg);\n            });\n        }\n\n        $.extend(WUFile.prototype, {\n\n            /**\n             * 设置状态，状态变化时会触发`change`事件。\n             * @method setStatus\n             * @grammar setStatus( status[, statusText] );\n             * @param {File.Status|String} status [文件状态值](#WebUploader:File:File.Status)\n             * @param {String} [statusText=''] 状态说明，常在error时使用，用http, abort,server等来标记是由于什么原因导致文件错误。\n             */\n            setStatus: function setStatus(status, text) {\n\n                var prevStatus = statusMap[this.id];\n\n                typeof text !== 'undefined' && (this.statusText = text);\n\n                if (status !== prevStatus) {\n                    statusMap[this.id] = status;\n                    /**\n                     * 文件状态变化\n                     * @event statuschange\n                     */\n                    this.trigger('statuschange', status, prevStatus);\n                }\n            },\n\n            /**\n             * 获取文件状态\n             * @return {File.Status}\n             * @example\n                     文件状态具体包括以下几种类型：\n                     {\n                         // 初始化\n                        INITED:     0,\n                        // 已入队列\n                        QUEUED:     1,\n                        // 正在上传\n                        PROGRESS:     2,\n                        // 上传出错\n                        ERROR:         3,\n                        // 上传成功\n                        COMPLETE:     4,\n                        // 上传取消\n                        CANCELLED:     5\n                    }\n             */\n            getStatus: function getStatus() {\n                return statusMap[this.id];\n            },\n\n            /**\n             * 获取文件原始信息。\n             * @return {*}\n             */\n            getSource: function getSource() {\n                return this.source;\n            },\n\n            destroy: function destroy() {\n                this.off();\n                delete statusMap[this.id];\n            }\n        });\n\n        Mediator.installTo(WUFile.prototype);\n\n        /**\n         * 文件状态值，具体包括以下几种类型：\n         * * `inited` 初始状态\n         * * `queued` 已经进入队列, 等待上传\n         * * `progress` 上传中\n         * * `complete` 上传完成。\n         * * `error` 上传出错，可重试\n         * * `interrupt` 上传中断，可续传。\n         * * `invalid` 文件不合格，不能重试上传。会自动从队列中移除。\n         * * `cancelled` 文件被移除。\n         * @property {Object} Status\n         * @namespace File\n         * @class File\n         * @static\n         */\n        WUFile.Status = {\n            INITED: 'inited', // 初始状态\n            QUEUED: 'queued', // 已经进入队列, 等待上传\n            PROGRESS: 'progress', // 上传中\n            ERROR: 'error', // 上传出错，可重试\n            COMPLETE: 'complete', // 上传完成。\n            CANCELLED: 'cancelled', // 上传取消。\n            INTERRUPT: 'interrupt', // 上传中断，可续传。\n            INVALID: 'invalid' // 文件不合格，不能重试上传。\n        };\n\n        return WUFile;\n    });\n\n    /**\n     * @fileOverview 文件队列\n     */\n    define('queue', ['base', 'mediator', 'file'], function (Base, Mediator, WUFile) {\n\n        var $ = Base.$,\n            STATUS = WUFile.Status;\n\n        /**\n         * 文件队列, 用来存储各个状态中的文件。\n         * @class Queue\n         * @extends Mediator\n         */\n        function Queue() {\n\n            /**\n             * 统计文件数。\n             * * `numOfQueue` 队列中的文件数。\n             * * `numOfSuccess` 上传成功的文件数\n             * * `numOfCancel` 被取消的文件数\n             * * `numOfProgress` 正在上传中的文件数\n             * * `numOfUploadFailed` 上传错误的文件数。\n             * * `numOfInvalid` 无效的文件数。\n             * * `numofDeleted` 被移除的文件数。\n             * @property {Object} stats\n             */\n            this.stats = {\n                numOfQueue: 0,\n                numOfSuccess: 0,\n                numOfCancel: 0,\n                numOfProgress: 0,\n                numOfUploadFailed: 0,\n                numOfInvalid: 0,\n                numofDeleted: 0,\n                numofInterrupt: 0\n            };\n\n            // 上传队列，仅包括等待上传的文件\n            this._queue = [];\n\n            // 存储所有文件\n            this._map = {};\n        }\n\n        $.extend(Queue.prototype, {\n\n            /**\n             * 将新文件加入对队列尾部\n             *\n             * @method append\n             * @param  {File} file   文件对象\n             */\n            append: function append(file) {\n                this._queue.push(file);\n                this._fileAdded(file);\n                return this;\n            },\n\n            /**\n             * 将新文件加入对队列头部\n             *\n             * @method prepend\n             * @param  {File} file   文件对象\n             */\n            prepend: function prepend(file) {\n                this._queue.unshift(file);\n                this._fileAdded(file);\n                return this;\n            },\n\n            /**\n             * 获取文件对象\n             *\n             * @method getFile\n             * @param  {String} fileId   文件ID\n             * @return {File}\n             */\n            getFile: function getFile(fileId) {\n                if (typeof fileId !== 'string') {\n                    return fileId;\n                }\n                return this._map[fileId];\n            },\n\n            /**\n             * 从队列中取出一个指定状态的文件。\n             * @grammar fetch( status ) => File\n             * @method fetch\n             * @param {String} status [文件状态值](#WebUploader:File:File.Status)\n             * @return {File} [File](#WebUploader:File)\n             */\n            fetch: function fetch(status) {\n                var len = this._queue.length,\n                    i,\n                    file;\n\n                status = status || STATUS.QUEUED;\n\n                for (i = 0; i < len; i++) {\n                    file = this._queue[i];\n\n                    if (status === file.getStatus()) {\n                        return file;\n                    }\n                }\n\n                return null;\n            },\n\n            /**\n             * 对队列进行排序，能够控制文件上传顺序。\n             * @grammar sort( fn ) => undefined\n             * @method sort\n             * @param {Function} fn 排序方法\n             */\n            sort: function sort(fn) {\n                if (typeof fn === 'function') {\n                    this._queue.sort(fn);\n                }\n            },\n\n            /**\n             * 获取指定类型的文件列表, 列表中每一个成员为[File](#WebUploader:File)对象。\n             * @grammar getFiles( [status1[, status2 ...]] ) => Array\n             * @method getFiles\n             * @param {String} [status] [文件状态值](#WebUploader:File:File.Status)\n             */\n            getFiles: function getFiles() {\n                var sts = [].slice.call(arguments, 0),\n                    ret = [],\n                    i = 0,\n                    len = this._queue.length,\n                    file;\n\n                for (; i < len; i++) {\n                    file = this._queue[i];\n\n                    if (sts.length && !~$.inArray(file.getStatus(), sts)) {\n                        continue;\n                    }\n\n                    ret.push(file);\n                }\n\n                return ret;\n            },\n\n            /**\n             * 在队列中删除文件。\n             * @grammar removeFile( file ) => Array\n             * @method removeFile\n             * @param {File} 文件对象。\n             */\n            removeFile: function removeFile(file) {\n                var me = this,\n                    existing = this._map[file.id];\n\n                if (existing) {\n                    delete this._map[file.id];\n                    file.destroy();\n                    this.stats.numofDeleted++;\n                }\n            },\n\n            _fileAdded: function _fileAdded(file) {\n                var me = this,\n                    existing = this._map[file.id];\n\n                if (!existing) {\n                    this._map[file.id] = file;\n\n                    file.on('statuschange', function (cur, pre) {\n                        me._onFileStatusChange(cur, pre);\n                    });\n                }\n            },\n\n            _onFileStatusChange: function _onFileStatusChange(curStatus, preStatus) {\n                var stats = this.stats;\n\n                switch (preStatus) {\n                    case STATUS.PROGRESS:\n                        stats.numOfProgress--;\n                        break;\n\n                    case STATUS.QUEUED:\n                        stats.numOfQueue--;\n                        break;\n\n                    case STATUS.ERROR:\n                        stats.numOfUploadFailed--;\n                        break;\n\n                    case STATUS.INVALID:\n                        stats.numOfInvalid--;\n                        break;\n\n                    case STATUS.INTERRUPT:\n                        stats.numofInterrupt--;\n                        break;\n                }\n\n                switch (curStatus) {\n                    case STATUS.QUEUED:\n                        stats.numOfQueue++;\n                        break;\n\n                    case STATUS.PROGRESS:\n                        stats.numOfProgress++;\n                        break;\n\n                    case STATUS.ERROR:\n                        stats.numOfUploadFailed++;\n                        break;\n\n                    case STATUS.COMPLETE:\n                        stats.numOfSuccess++;\n                        break;\n\n                    case STATUS.CANCELLED:\n                        stats.numOfCancel++;\n                        break;\n\n                    case STATUS.INVALID:\n                        stats.numOfInvalid++;\n                        break;\n\n                    case STATUS.INTERRUPT:\n                        stats.numofInterrupt++;\n                        break;\n                }\n            }\n\n        });\n\n        Mediator.installTo(Queue.prototype);\n\n        return Queue;\n    });\n    /**\n     * @fileOverview 队列\n     */\n    define('widgets/queue', ['base', 'uploader', 'queue', 'file', 'lib/file', 'runtime/client', 'widgets/widget'], function (Base, Uploader, Queue, WUFile, File, RuntimeClient) {\n\n        var $ = Base.$,\n            rExt = /\\.\\w+$/,\n            Status = WUFile.Status;\n\n        return Uploader.register({\n            name: 'queue',\n\n            init: function init(opts) {\n                var me = this,\n                    deferred,\n                    len,\n                    i,\n                    item,\n                    arr,\n                    accept,\n                    runtime;\n\n                if ($.isPlainObject(opts.accept)) {\n                    opts.accept = [opts.accept];\n                }\n\n                // accept中的中生成匹配正则。\n                if (opts.accept) {\n                    arr = [];\n\n                    for (i = 0, len = opts.accept.length; i < len; i++) {\n                        item = opts.accept[i].extensions;\n                        item && arr.push(item);\n                    }\n\n                    if (arr.length) {\n                        accept = '\\\\.' + arr.join(',').replace(/,/g, '$|\\\\.').replace(/\\*/g, '.*') + '$';\n                    }\n\n                    me.accept = new RegExp(accept, 'i');\n                }\n\n                me.queue = new Queue();\n                me.stats = me.queue.stats;\n\n                // 如果当前不是html5运行时，那就算了。\n                // 不执行后续操作\n                if (this.request('predict-runtime-type') !== 'html5') {\n                    return;\n                }\n\n                // 创建一个 html5 运行时的 placeholder\n                // 以至于外部添加原生 File 对象的时候能正确包裹一下供 webuploader 使用。\n                deferred = Base.Deferred();\n                this.placeholder = runtime = new RuntimeClient('Placeholder');\n                runtime.connectRuntime({\n                    runtimeOrder: 'html5'\n                }, function () {\n                    me._ruid = runtime.getRuid();\n                    deferred.resolve();\n                });\n                return deferred.promise();\n            },\n\n            // 为了支持外部直接添加一个原生File对象。\n            _wrapFile: function _wrapFile(file) {\n                if (!(file instanceof WUFile)) {\n\n                    if (!(file instanceof File)) {\n                        if (!this._ruid) {\n                            throw new Error('Can\\'t add external files.');\n                        }\n                        file = new File(this._ruid, file);\n                    }\n\n                    file = new WUFile(file);\n                }\n\n                return file;\n            },\n\n            // 判断文件是否可以被加入队列\n            acceptFile: function acceptFile(file) {\n                var invalid = !file || !file.size || this.accept &&\n\n                // 如果名字中有后缀，才做后缀白名单处理。\n                rExt.exec(file.name) && !this.accept.test(file.name);\n\n                return !invalid;\n            },\n\n            /**\n             * @event beforeFileQueued\n             * @param {File} file File对象\n             * @description 当文件被加入队列之前触发，此事件的handler返回值为`false`，则此文件不会被添加进入队列。\n             * @for  Uploader\n             */\n\n            /**\n             * @event fileQueued\n             * @param {File} file File对象\n             * @description 当文件被加入队列以后触发。\n             * @for  Uploader\n             */\n\n            _addFile: function _addFile(file) {\n                var me = this;\n\n                file = me._wrapFile(file);\n\n                // 不过类型判断允许不允许，先派送 `beforeFileQueued`\n                if (!me.owner.trigger('beforeFileQueued', file)) {\n                    return;\n                }\n\n                // 类型不匹配，则派送错误事件，并返回。\n                if (!me.acceptFile(file)) {\n                    me.owner.trigger('error', 'Q_TYPE_DENIED', file);\n                    return;\n                }\n\n                me.queue.append(file);\n                me.owner.trigger('fileQueued', file);\n                return file;\n            },\n\n            getFile: function getFile(fileId) {\n                return this.queue.getFile(fileId);\n            },\n\n            /**\n             * @event filesQueued\n             * @param {File} files 数组，内容为原始File(lib/File）对象。\n             * @description 当一批文件添加进队列以后触发。\n             * @for  Uploader\n             */\n\n            /**\n             * @property {Boolean} [auto=false]\n             * @namespace options\n             * @for Uploader\n             * @description 设置为 true 后，不需要手动调用上传，有文件选择即开始上传。\n             * \n             */\n\n            /**\n             * @method addFiles\n             * @grammar addFiles( file ) => undefined\n             * @grammar addFiles( [file1, file2 ...] ) => undefined\n             * @param {Array of File or File} [files] Files 对象 数组\n             * @description 添加文件到队列\n             * @for  Uploader\n             */\n            addFile: function addFile(files) {\n                var me = this;\n\n                if (!files.length) {\n                    files = [files];\n                }\n\n                files = $.map(files, function (file) {\n                    return me._addFile(file);\n                });\n\n                me.owner.trigger('filesQueued', files);\n\n                if (me.options.auto) {\n                    setTimeout(function () {\n                        me.request('start-upload');\n                    }, 20);\n                }\n            },\n\n            getStats: function getStats() {\n                return this.stats;\n            },\n\n            /**\n             * @event fileDequeued\n             * @param {File} file File对象\n             * @description 当文件被移除队列后触发。\n             * @for  Uploader\n             */\n\n            /**\n            * @method removeFile\n            * @grammar removeFile( file ) => undefined\n            * @grammar removeFile( id ) => undefined\n            * @grammar removeFile( file, true ) => undefined\n            * @grammar removeFile( id, true ) => undefined\n            * @param {File|id} file File对象或这File对象的id\n            * @description 移除某一文件, 默认只会标记文件状态为已取消，如果第二个参数为 `true` 则会从 queue 中移除。\n            * @for  Uploader\n            * @example\n            *\n            * $li.on('click', '.remove-this', function() {\n            *     uploader.removeFile( file );\n            * })\n            */\n            removeFile: function removeFile(file, remove) {\n                var me = this;\n\n                file = file.id ? file : me.queue.getFile(file);\n\n                this.request('cancel-file', file);\n\n                if (remove) {\n                    this.queue.removeFile(file);\n                }\n            },\n\n            /**\n             * @method getFiles\n             * @grammar getFiles() => Array\n             * @grammar getFiles( status1, status2, status... ) => Array\n             * @description 返回指定状态的文件集合，不传参数将返回所有状态的文件。\n             * @for  Uploader\n             * @example\n             * console.log( uploader.getFiles() );    // => all files\n             * console.log( uploader.getFiles('error') )    // => all error files.\n             */\n            getFiles: function getFiles() {\n                return this.queue.getFiles.apply(this.queue, arguments);\n            },\n\n            fetchFile: function fetchFile() {\n                return this.queue.fetch.apply(this.queue, arguments);\n            },\n\n            /**\n             * @method retry\n             * @grammar retry() => undefined\n             * @grammar retry( file ) => undefined\n             * @description 重试上传，重试指定文件，或者从出错的文件开始重新上传。\n             * @for  Uploader\n             * @example\n             * function retry() {\n             *     uploader.retry();\n             * }\n             */\n            retry: function retry(file, noForceStart) {\n                var me = this,\n                    files,\n                    i,\n                    len;\n\n                if (file) {\n                    file = file.id ? file : me.queue.getFile(file);\n                    file.setStatus(Status.QUEUED);\n                    noForceStart || me.request('start-upload');\n                    return;\n                }\n\n                files = me.queue.getFiles(Status.ERROR);\n                i = 0;\n                len = files.length;\n\n                for (; i < len; i++) {\n                    file = files[i];\n                    file.setStatus(Status.QUEUED);\n                }\n\n                me.request('start-upload');\n            },\n\n            /**\n             * @method sort\n             * @grammar sort( fn ) => undefined\n             * @description 排序队列中的文件，在上传之前调整可以控制上传顺序。\n             * @for  Uploader\n             */\n            sortFiles: function sortFiles() {\n                return this.queue.sort.apply(this.queue, arguments);\n            },\n\n            /**\n             * @event reset\n             * @description 当 uploader 被重置的时候触发。\n             * @for  Uploader\n             */\n\n            /**\n             * @method reset\n             * @grammar reset() => undefined\n             * @description 重置uploader。目前只重置了队列。\n             * @for  Uploader\n             * @example\n             * uploader.reset();\n             */\n            reset: function reset() {\n                this.owner.trigger('reset');\n                this.queue = new Queue();\n                this.stats = this.queue.stats;\n            },\n\n            destroy: function destroy() {\n                this.reset();\n                this.placeholder && this.placeholder.destroy();\n            }\n        });\n    });\n    /**\n     * @fileOverview 添加获取Runtime相关信息的方法。\n     */\n    define('widgets/runtime', ['uploader', 'runtime/runtime', 'widgets/widget'], function (Uploader, Runtime) {\n\n        Uploader.support = function () {\n            return Runtime.hasRuntime.apply(Runtime, arguments);\n        };\n\n        /**\n         * @property {Object} [runtimeOrder=html5,flash]\n         * @namespace options\n         * @for Uploader\n         * @description 指定运行时启动顺序。默认会想尝试 html5 是否支持，如果支持则使用 html5, 否则则使用 flash.\n         *\n         * 可以将此值设置成 `flash`，来强制使用 flash 运行时。\n         */\n\n        return Uploader.register({\n            name: 'runtime',\n\n            init: function init() {\n                if (!this.predictRuntimeType()) {\n                    throw Error('Runtime Error');\n                }\n            },\n\n            /**\n             * 预测Uploader将采用哪个`Runtime`\n             * @grammar predictRuntimeType() => String\n             * @method predictRuntimeType\n             * @for  Uploader\n             */\n            predictRuntimeType: function predictRuntimeType() {\n                var orders = this.options.runtimeOrder || Runtime.orders,\n                    type = this.type,\n                    i,\n                    len;\n\n                if (!type) {\n                    orders = orders.split(/\\s*,\\s*/g);\n\n                    for (i = 0, len = orders.length; i < len; i++) {\n                        if (Runtime.hasRuntime(orders[i])) {\n                            this.type = type = orders[i];\n                            break;\n                        }\n                    }\n                }\n\n                return type;\n            }\n        });\n    });\n    /**\n     * @fileOverview Transport\n     */\n    define('lib/transport', ['base', 'runtime/client', 'mediator'], function (Base, RuntimeClient, Mediator) {\n\n        var $ = Base.$;\n\n        function Transport(opts) {\n            var me = this;\n\n            opts = me.options = $.extend(true, {}, Transport.options, opts || {});\n            RuntimeClient.call(this, 'Transport');\n\n            this._blob = null;\n            this._formData = opts.formData || {};\n            this._headers = opts.headers || {};\n\n            this.on('progress', this._timeout);\n            this.on('load error', function () {\n                me.trigger('progress', 1);\n                clearTimeout(me._timer);\n            });\n        }\n\n        Transport.options = {\n            server: '',\n            method: 'POST',\n\n            // 跨域时，是否允许携带cookie, 只有html5 runtime才有效\n            withCredentials: false,\n            fileVal: 'file',\n            timeout: 2 * 60 * 1000, // 2分钟\n            formData: {},\n            headers: {},\n            sendAsBinary: false\n        };\n\n        $.extend(Transport.prototype, {\n\n            // 添加Blob, 只能添加一次，最后一次有效。\n            appendBlob: function appendBlob(key, blob, filename) {\n                var me = this,\n                    opts = me.options;\n\n                if (me.getRuid()) {\n                    me.disconnectRuntime();\n                }\n\n                // 连接到blob归属的同一个runtime.\n                me.connectRuntime(blob.ruid, function () {\n                    me.exec('init');\n                });\n\n                me._blob = blob;\n                opts.fileVal = key || opts.fileVal;\n                opts.filename = filename || opts.filename;\n            },\n\n            // 添加其他字段\n            append: function append(key, value) {\n                if ((typeof key === 'undefined' ? 'undefined' : __WEBPACK_IMPORTED_MODULE_1_babel_runtime_helpers_typeof___default()(key)) === 'object') {\n                    $.extend(this._formData, key);\n                } else {\n                    this._formData[key] = value;\n                }\n            },\n\n            setRequestHeader: function setRequestHeader(key, value) {\n                if ((typeof key === 'undefined' ? 'undefined' : __WEBPACK_IMPORTED_MODULE_1_babel_runtime_helpers_typeof___default()(key)) === 'object') {\n                    $.extend(this._headers, key);\n                } else {\n                    this._headers[key] = value;\n                }\n            },\n\n            send: function send(method) {\n                this.exec('send', method);\n                this._timeout();\n            },\n\n            abort: function abort() {\n                clearTimeout(this._timer);\n                return this.exec('abort');\n            },\n\n            destroy: function destroy() {\n                this.trigger('destroy');\n                this.off();\n                this.exec('destroy');\n                this.disconnectRuntime();\n            },\n\n            getResponse: function getResponse() {\n                return this.exec('getResponse');\n            },\n\n            getResponseAsJson: function getResponseAsJson() {\n                return this.exec('getResponseAsJson');\n            },\n\n            getStatus: function getStatus() {\n                return this.exec('getStatus');\n            },\n\n            _timeout: function _timeout() {\n                var me = this,\n                    duration = me.options.timeout;\n\n                if (!duration) {\n                    return;\n                }\n\n                clearTimeout(me._timer);\n                me._timer = setTimeout(function () {\n                    me.abort();\n                    me.trigger('error', 'timeout');\n                }, duration);\n            }\n\n        });\n\n        // 让Transport具备事件功能。\n        Mediator.installTo(Transport.prototype);\n\n        return Transport;\n    });\n    /**\n     * @fileOverview 负责文件上传相关。\n     */\n    define('widgets/upload', ['base', 'uploader', 'file', 'lib/transport', 'widgets/widget'], function (Base, Uploader, WUFile, Transport) {\n\n        var $ = Base.$,\n            isPromise = Base.isPromise,\n            Status = WUFile.Status;\n\n        // 添加默认配置项\n        $.extend(Uploader.options, {\n\n            /**\n             * @property {Boolean} [prepareNextFile=false]\n             * @namespace options\n             * @for Uploader\n             * @description 是否允许在文件传输时提前把下一个文件准备好。\n             * 对于一个文件的准备工作比较耗时，比如图片压缩，md5序列化。\n             * 如果能提前在当前文件传输期处理，可以节省总体耗时。\n             */\n            prepareNextFile: false,\n\n            /**\n             * @property {Boolean} [chunked=false]\n             * @namespace options\n             * @for Uploader\n             * @description 是否要分片处理大文件上传。\n             */\n            chunked: false,\n\n            /**\n             * @property {Boolean} [chunkSize=5242880]\n             * @namespace options\n             * @for Uploader\n             * @description 如果要分片，分多大一片？ 默认大小为5M.\n             */\n            chunkSize: 5 * 1024 * 1024,\n\n            /**\n             * @property {Boolean} [chunkRetry=2]\n             * @namespace options\n             * @for Uploader\n             * @description 如果某个分片由于网络问题出错，允许自动重传多少次？\n             */\n            chunkRetry: 2,\n\n            /**\n             * @property {Boolean} [threads=3]\n             * @namespace options\n             * @for Uploader\n             * @description 上传并发数。允许同时最大上传进程数。\n             */\n            threads: 3,\n\n            /**\n             * @property {Object} [formData={}]\n             * @namespace options\n             * @for Uploader\n             * @description 文件上传请求的参数表，每次发送都会发送此对象中的参数。\n             */\n            formData: {}\n\n            /**\n             * @property {Object} [fileVal='file']\n             * @namespace options\n             * @for Uploader\n             * @description 设置文件上传域的name。\n             */\n\n            /**\n             * @property {Object} [method='POST']\n             * @namespace options\n             * @for Uploader\n             * @description 文件上传方式，`POST`或者`GET`。\n             */\n\n            /**\n             * @property {Object} [sendAsBinary=false]\n             * @namespace options\n             * @for Uploader\n             * @description 是否已二进制的流的方式发送文件，这样整个上传内容`php://input`都为文件内容，\n             * 其他参数在$_GET数组中。\n             */\n        });\n\n        // 负责将文件切片。\n        function CuteFile(file, chunkSize) {\n            var pending = [],\n                blob = file.source,\n                total = blob.size,\n                chunks = chunkSize ? Math.ceil(total / chunkSize) : 1,\n                start = 0,\n                index = 0,\n                len,\n                api;\n\n            api = {\n                file: file,\n\n                has: function has() {\n                    return !!pending.length;\n                },\n\n                shift: function shift() {\n                    return pending.shift();\n                },\n\n                unshift: function unshift(block) {\n                    pending.unshift(block);\n                }\n            };\n\n            while (index < chunks) {\n                len = Math.min(chunkSize, total - start);\n\n                pending.push({\n                    file: file,\n                    start: start,\n                    end: chunkSize ? start + len : total,\n                    total: total,\n                    chunks: chunks,\n                    chunk: index++,\n                    cuted: api\n                });\n                start += len;\n            }\n\n            file.blocks = pending.concat();\n            file.remaning = pending.length;\n\n            return api;\n        }\n\n        Uploader.register({\n            name: 'upload',\n\n            init: function init() {\n                var owner = this.owner,\n                    me = this;\n\n                this.runing = false;\n                this.progress = false;\n\n                owner.on('startUpload', function () {\n                    me.progress = true;\n                }).on('uploadFinished', function () {\n                    me.progress = false;\n                });\n\n                // 记录当前正在传的数据，跟threads相关\n                this.pool = [];\n\n                // 缓存分好片的文件。\n                this.stack = [];\n\n                // 缓存即将上传的文件。\n                this.pending = [];\n\n                // 跟踪还有多少分片在上传中但是没有完成上传。\n                this.remaning = 0;\n                this.__tick = Base.bindFn(this._tick, this);\n\n                owner.on('uploadComplete', function (file) {\n\n                    // 把其他块取消了。\n                    file.blocks && $.each(file.blocks, function (_, v) {\n                        v.transport && (v.transport.abort(), v.transport.destroy());\n                        delete v.transport;\n                    });\n\n                    delete file.blocks;\n                    delete file.remaning;\n                });\n            },\n\n            reset: function reset() {\n                this.request('stop-upload', true);\n                this.runing = false;\n                this.pool = [];\n                this.stack = [];\n                this.pending = [];\n                this.remaning = 0;\n                this._trigged = false;\n                this._promise = null;\n            },\n\n            /**\n             * @event startUpload\n             * @description 当开始上传流程时触发。\n             * @for  Uploader\n             */\n\n            /**\n             * 开始上传。此方法可以从初始状态调用开始上传流程，也可以从暂停状态调用，继续上传流程。\n             *\n             * 可以指定开始某一个文件。\n             * @grammar upload() => undefined\n             * @grammar upload( file | fileId) => undefined\n             * @method upload\n             * @for  Uploader\n             */\n            startUpload: function startUpload(file) {\n                var me = this;\n\n                // 移出invalid的文件\n                $.each(me.request('get-files', Status.INVALID), function () {\n                    me.request('remove-file', this);\n                });\n\n                // 如果指定了开始某个文件，则只开始指定文件。\n                if (file) {\n                    file = file.id ? file : me.request('get-file', file);\n\n                    if (file.getStatus() === Status.INTERRUPT) {\n                        $.each(me.pool, function (_, v) {\n\n                            // 之前暂停过。\n                            if (v.file !== file) {\n                                return;\n                            }\n\n                            v.transport && v.transport.send();\n                        });\n\n                        file.setStatus(Status.QUEUED);\n                    } else if (file.getStatus() === Status.PROGRESS) {\n                        return;\n                    } else {\n                        file.setStatus(Status.QUEUED);\n                    }\n                } else {\n                    $.each(me.request('get-files', [Status.INITED]), function () {\n                        this.setStatus(Status.QUEUED);\n                    });\n                }\n\n                if (me.runing) {\n                    return;\n                }\n\n                me.runing = true;\n\n                var files = [];\n\n                // 如果有暂停的，则续传\n                $.each(me.pool, function (_, v) {\n                    var file = v.file;\n\n                    if (file.getStatus() === Status.INTERRUPT) {\n                        files.push(file);\n                        me._trigged = false;\n                        v.transport && v.transport.send();\n                    }\n                });\n\n                var file;\n                while (file = files.shift()) {\n                    file.setStatus(Status.PROGRESS);\n                }\n\n                file || $.each(me.request('get-files', Status.INTERRUPT), function () {\n                    this.setStatus(Status.PROGRESS);\n                });\n\n                me._trigged = false;\n                Base.nextTick(me.__tick);\n                me.owner.trigger('startUpload');\n            },\n\n            /**\n             * @event stopUpload\n             * @description 当开始上传流程暂停时触发。\n             * @for  Uploader\n             */\n\n            /**\n             * 暂停上传。第一个参数为是否中断上传当前正在上传的文件。\n             *\n             * 如果第一个参数是文件，则只暂停指定文件。\n             * @grammar stop() => undefined\n             * @grammar stop( true ) => undefined\n             * @grammar stop( file ) => undefined\n             * @method stop\n             * @for  Uploader\n             */\n            stopUpload: function stopUpload(file, interrupt) {\n                var me = this;\n\n                if (file === true) {\n                    interrupt = file;\n                    file = null;\n                }\n\n                if (me.runing === false) {\n                    return;\n                }\n\n                // 如果只是暂停某个文件。\n                if (file) {\n                    file = file.id ? file : me.request('get-file', file);\n\n                    if (file.getStatus() !== Status.PROGRESS && file.getStatus() !== Status.QUEUED) {\n                        return;\n                    }\n\n                    file.setStatus(Status.INTERRUPT);\n                    $.each(me.pool, function (_, v) {\n\n                        // 只 abort 指定的文件。\n                        if (v.file !== file) {\n                            return;\n                        }\n\n                        v.transport && v.transport.abort();\n                        me._putback(v);\n                        me._popBlock(v);\n                    });\n\n                    return Base.nextTick(me.__tick);\n                }\n\n                me.runing = false;\n\n                if (this._promise && this._promise.file) {\n                    this._promise.file.setStatus(Status.INTERRUPT);\n                }\n\n                interrupt && $.each(me.pool, function (_, v) {\n                    v.transport && v.transport.abort();\n                    v.file.setStatus(Status.INTERRUPT);\n                });\n\n                me.owner.trigger('stopUpload');\n            },\n\n            /**\n             * @method cancelFile\n             * @grammar cancelFile( file ) => undefined\n             * @grammar cancelFile( id ) => undefined\n             * @param {File|id} file File对象或这File对象的id\n             * @description 标记文件状态为已取消, 同时将中断文件传输。\n             * @for  Uploader\n             * @example\n             *\n             * $li.on('click', '.remove-this', function() {\n             *     uploader.cancelFile( file );\n             * })\n             */\n            cancelFile: function cancelFile(file) {\n                file = file.id ? file : this.request('get-file', file);\n\n                // 如果正在上传。\n                file.blocks && $.each(file.blocks, function (_, v) {\n                    var _tr = v.transport;\n\n                    if (_tr) {\n                        _tr.abort();\n                        _tr.destroy();\n                        delete v.transport;\n                    }\n                });\n\n                file.setStatus(Status.CANCELLED);\n                this.owner.trigger('fileDequeued', file);\n            },\n\n            /**\n             * 判断`Uplaode`r是否正在上传中。\n             * @grammar isInProgress() => Boolean\n             * @method isInProgress\n             * @for  Uploader\n             */\n            isInProgress: function isInProgress() {\n                return !!this.progress;\n            },\n\n            _getStats: function _getStats() {\n                return this.request('get-stats');\n            },\n\n            /**\n             * 掉过一个文件上传，直接标记指定文件为已上传状态。\n             * @grammar skipFile( file ) => undefined\n             * @method skipFile\n             * @for  Uploader\n             */\n            skipFile: function skipFile(file, status) {\n                file = file.id ? file : this.request('get-file', file);\n\n                file.setStatus(status || Status.COMPLETE);\n                file.skipped = true;\n\n                // 如果正在上传。\n                file.blocks && $.each(file.blocks, function (_, v) {\n                    var _tr = v.transport;\n\n                    if (_tr) {\n                        _tr.abort();\n                        _tr.destroy();\n                        delete v.transport;\n                    }\n                });\n\n                this.owner.trigger('uploadSkip', file);\n            },\n\n            /**\n             * @event uploadFinished\n             * @description 当所有文件上传结束时触发。\n             * @for  Uploader\n             */\n            _tick: function _tick() {\n                var me = this,\n                    opts = me.options,\n                    fn,\n                    val;\n\n                // 上一个promise还没有结束，则等待完成后再执行。\n                if (me._promise) {\n                    return me._promise.always(me.__tick);\n                }\n\n                // 还有位置，且还有文件要处理的话。\n                if (me.pool.length < opts.threads && (val = me._nextBlock())) {\n                    me._trigged = false;\n\n                    fn = function fn(val) {\n                        me._promise = null;\n\n                        // 有可能是reject过来的，所以要检测val的类型。\n                        val && val.file && me._startSend(val);\n                        Base.nextTick(me.__tick);\n                    };\n\n                    me._promise = isPromise(val) ? val.always(fn) : fn(val);\n\n                    // 没有要上传的了，且没有正在传输的了。\n                } else if (!me.remaning && !me._getStats().numOfQueue && !me._getStats().numofInterrupt) {\n                    me.runing = false;\n\n                    me._trigged || Base.nextTick(function () {\n                        me.owner.trigger('uploadFinished');\n                    });\n                    me._trigged = true;\n                }\n            },\n\n            _putback: function _putback(block) {\n                var idx;\n\n                block.cuted.unshift(block);\n                idx = this.stack.indexOf(block.cuted);\n\n                if (!~idx) {\n                    this.stack.unshift(block.cuted);\n                }\n            },\n\n            _getStack: function _getStack() {\n                var i = 0,\n                    act;\n\n                while (act = this.stack[i++]) {\n                    if (act.has() && act.file.getStatus() === Status.PROGRESS) {\n                        return act;\n                    } else if (!act.has() || act.file.getStatus() !== Status.PROGRESS && act.file.getStatus() !== Status.INTERRUPT) {\n\n                        // 把已经处理完了的，或者，状态为非 progress（上传中）、\n                        // interupt（暂停中） 的移除。\n                        this.stack.splice(--i, 1);\n                    }\n                }\n\n                return null;\n            },\n\n            _nextBlock: function _nextBlock() {\n                var me = this,\n                    opts = me.options,\n                    act,\n                    next,\n                    done,\n                    preparing;\n\n                // 如果当前文件还有没有需要传输的，则直接返回剩下的。\n                if (act = this._getStack()) {\n\n                    // 是否提前准备下一个文件\n                    if (opts.prepareNextFile && !me.pending.length) {\n                        me._prepareNextFile();\n                    }\n\n                    return act.shift();\n\n                    // 否则，如果正在运行，则准备下一个文件，并等待完成后返回下个分片。\n                } else if (me.runing) {\n\n                    // 如果缓存中有，则直接在缓存中取，没有则去queue中取。\n                    if (!me.pending.length && me._getStats().numOfQueue) {\n                        me._prepareNextFile();\n                    }\n\n                    next = me.pending.shift();\n                    done = function done(file) {\n                        if (!file) {\n                            return null;\n                        }\n\n                        act = CuteFile(file, opts.chunked ? opts.chunkSize : 0);\n                        me.stack.push(act);\n                        return act.shift();\n                    };\n\n                    // 文件可能还在prepare中，也有可能已经完全准备好了。\n                    if (isPromise(next)) {\n                        preparing = next.file;\n                        next = next[next.pipe ? 'pipe' : 'then'](done);\n                        next.file = preparing;\n                        return next;\n                    }\n\n                    return done(next);\n                }\n            },\n\n            /**\n             * @event uploadStart\n             * @param {File} file File对象\n             * @description 某个文件开始上传前触发，一个文件只会触发一次。\n             * @for  Uploader\n             */\n            _prepareNextFile: function _prepareNextFile() {\n                var me = this,\n                    file = me.request('fetch-file'),\n                    pending = me.pending,\n                    promise;\n\n                if (file) {\n                    promise = me.request('before-send-file', file, function () {\n\n                        // 有可能文件被skip掉了。文件被skip掉后，状态坑定不是Queued.\n                        if (file.getStatus() === Status.PROGRESS || file.getStatus() === Status.INTERRUPT) {\n                            return file;\n                        }\n\n                        return me._finishFile(file);\n                    });\n\n                    me.owner.trigger('uploadStart', file);\n                    file.setStatus(Status.PROGRESS);\n\n                    promise.file = file;\n\n                    // 如果还在pending中，则替换成文件本身。\n                    promise.done(function () {\n                        var idx = $.inArray(promise, pending);\n\n                        ~idx && pending.splice(idx, 1, file);\n                    });\n\n                    // befeore-send-file的钩子就有错误发生。\n                    promise.fail(function (reason) {\n                        file.setStatus(Status.ERROR, reason);\n                        me.owner.trigger('uploadError', file, reason);\n                        me.owner.trigger('uploadComplete', file);\n                    });\n\n                    pending.push(promise);\n                }\n            },\n\n            // 让出位置了，可以让其他分片开始上传\n            _popBlock: function _popBlock(block) {\n                var idx = $.inArray(block, this.pool);\n\n                this.pool.splice(idx, 1);\n                block.file.remaning--;\n                this.remaning--;\n            },\n\n            // 开始上传，可以被掉过。如果promise被reject了，则表示跳过此分片。\n            _startSend: function _startSend(block) {\n                var me = this,\n                    file = block.file,\n                    promise;\n\n                // 有可能在 before-send-file 的 promise 期间改变了文件状态。\n                // 如：暂停，取消\n                // 我们不能中断 promise, 但是可以在 promise 完后，不做上传操作。\n                if (file.getStatus() !== Status.PROGRESS) {\n\n                    // 如果是中断，则还需要放回去。\n                    if (file.getStatus() === Status.INTERRUPT) {\n                        me._putback(block);\n                    }\n\n                    return;\n                }\n\n                me.pool.push(block);\n                me.remaning++;\n\n                // 如果没有分片，则直接使用原始的。\n                // 不会丢失content-type信息。\n                block.blob = block.chunks === 1 ? file.source : file.source.slice(block.start, block.end);\n\n                // hook, 每个分片发送之前可能要做些异步的事情。\n                promise = me.request('before-send', block, function () {\n\n                    // 有可能文件已经上传出错了，所以不需要再传输了。\n                    if (file.getStatus() === Status.PROGRESS) {\n                        me._doSend(block);\n                    } else {\n                        me._popBlock(block);\n                        Base.nextTick(me.__tick);\n                    }\n                });\n\n                // 如果为fail了，则跳过此分片。\n                promise.fail(function () {\n                    if (file.remaning === 1) {\n                        me._finishFile(file).always(function () {\n                            block.percentage = 1;\n                            me._popBlock(block);\n                            me.owner.trigger('uploadComplete', file);\n                            Base.nextTick(me.__tick);\n                        });\n                    } else {\n                        block.percentage = 1;\n                        me.updateFileProgress(file);\n                        me._popBlock(block);\n                        Base.nextTick(me.__tick);\n                    }\n                });\n            },\n\n            /**\n             * @event uploadBeforeSend\n             * @param {Object} object\n             * @param {Object} data 默认的上传参数，可以扩展此对象来控制上传参数。\n             * @param {Object} headers 可以扩展此对象来控制上传头部。\n             * @description 当某个文件的分块在发送前触发，主要用来询问是否要添加附带参数，大文件在开起分片上传的前提下此事件可能会触发多次。\n             * @for  Uploader\n             */\n\n            /**\n             * @event uploadAccept\n             * @param {Object} object\n             * @param {Object} ret 服务端的返回数据，json格式，如果服务端不是json格式，从ret._raw中取数据，自行解析。\n             * @description 当某个文件上传到服务端响应后，会派送此事件来询问服务端响应是否有效。如果此事件handler返回值为`false`, 则此文件将派送`server`类型的`uploadError`事件。\n             * @for  Uploader\n             */\n\n            /**\n             * @event uploadProgress\n             * @param {File} file File对象\n             * @param {Number} percentage 上传进度\n             * @description 上传过程中触发，携带上传进度。\n             * @for  Uploader\n             */\n\n            /**\n             * @event uploadError\n             * @param {File} file File对象\n             * @param {String} reason 出错的code\n             * @description 当文件上传出错时触发。\n             * @for  Uploader\n             */\n\n            /**\n             * @event uploadSuccess\n             * @param {File} file File对象\n             * @param {Object} response 服务端返回的数据\n             * @description 当文件上传成功时触发。\n             * @for  Uploader\n             */\n\n            /**\n             * @event uploadComplete\n             * @param {File} [file] File对象\n             * @description 不管成功或者失败，文件上传完成时触发。\n             * @for  Uploader\n             */\n\n            // 做上传操作。\n            _doSend: function _doSend(block) {\n                var me = this,\n                    owner = me.owner,\n                    opts = me.options,\n                    file = block.file,\n                    tr = new Transport(opts),\n                    data = $.extend({}, opts.formData),\n                    headers = $.extend({}, opts.headers),\n                    requestAccept,\n                    ret;\n\n                block.transport = tr;\n\n                tr.on('destroy', function () {\n                    delete block.transport;\n                    me._popBlock(block);\n                    Base.nextTick(me.__tick);\n                });\n\n                // 广播上传进度。以文件为单位。\n                tr.on('progress', function (percentage) {\n                    block.percentage = percentage;\n                    me.updateFileProgress(file);\n                });\n\n                // 用来询问，是否返回的结果是有错误的。\n                requestAccept = function requestAccept(reject) {\n                    var fn;\n\n                    ret = tr.getResponseAsJson() || {};\n                    ret._raw = tr.getResponse();\n                    fn = function fn(value) {\n                        reject = value;\n                    };\n\n                    // 服务端响应了，不代表成功了，询问是否响应正确。\n                    if (!owner.trigger('uploadAccept', block, ret, fn)) {\n                        reject = reject || 'server';\n                    }\n\n                    return reject;\n                };\n\n                // 尝试重试，然后广播文件上传出错。\n                tr.on('error', function (type, flag) {\n                    block.retried = block.retried || 0;\n\n                    // 自动重试\n                    if (block.chunks > 1 && ~'http,abort'.indexOf(type) && block.retried < opts.chunkRetry) {\n\n                        block.retried++;\n                        tr.send();\n                    } else {\n\n                        // http status 500 ~ 600\n                        if (!flag && type === 'server') {\n                            type = requestAccept(type);\n                        }\n\n                        file.setStatus(Status.ERROR, type);\n                        owner.trigger('uploadError', file, type);\n                        owner.trigger('uploadComplete', file);\n                    }\n                });\n\n                // 上传成功\n                tr.on('load', function () {\n                    var reason;\n\n                    // 如果非预期，转向上传出错。\n                    if (reason = requestAccept()) {\n                        tr.trigger('error', reason, true);\n                        return;\n                    }\n\n                    // 全部上传完成。\n                    if (file.remaning === 1) {\n                        me._finishFile(file, ret);\n                    } else {\n                        tr.destroy();\n                    }\n                });\n\n                // 配置默认的上传字段。\n                data = $.extend(data, {\n                    id: file.id,\n                    name: file.name,\n                    type: file.type,\n                    lastModifiedDate: file.lastModifiedDate,\n                    size: file.size\n                });\n\n                block.chunks > 1 && $.extend(data, {\n                    chunks: block.chunks,\n                    chunk: block.chunk\n                });\n\n                // 在发送之间可以添加字段什么的。。。\n                // 如果默认的字段不够使用，可以通过监听此事件来扩展\n                owner.trigger('uploadBeforeSend', block, data, headers);\n\n                // 开始发送。\n                tr.appendBlob(opts.fileVal, block.blob, file.name);\n                tr.append(data);\n                tr.setRequestHeader(headers);\n                tr.send();\n            },\n\n            // 完成上传。\n            _finishFile: function _finishFile(file, ret, hds) {\n                var owner = this.owner;\n                //wqd 定制化修改\n                if (ret.F_CODE === \"0\") {\n                    file.setStatus(Status.COMPLETE);\n                    owner.trigger('uploadSuccess', file, ret, hds);\n                } else {\n                    // 如果外部已经标记为invalid什么的，不再改状态。\n                    if (file.getStatus() === Status.PROGRESS) {\n                        file.setStatus(Status.ERROR, ret);\n                    }\n                    owner.trigger('uploadError', file, ret);\n                }\n                owner.trigger('uploadComplete', file, ret);\n                /* return owner\n                        .request( 'after-send-file', arguments, function() {\n                            file.setStatus( Status.COMPLETE );\n                            owner.trigger( 'uploadSuccess', file, ret, hds );\n                        })\n                        .fail(function( reason ) {\n                                 // 如果外部已经标记为invalid什么的，不再改状态。\n                            if ( file.getStatus() === Status.PROGRESS ) {\n                                file.setStatus( Status.ERROR, reason );\n                            }\n                                 owner.trigger( 'uploadError', file, reason );\n                        })\n                        .always(function() {\n                            owner.trigger( 'uploadComplete', file );\n                        }); */\n            },\n\n            updateFileProgress: function updateFileProgress(file) {\n                var totalPercent = 0,\n                    uploaded = 0;\n\n                if (!file.blocks) {\n                    return;\n                }\n\n                $.each(file.blocks, function (_, v) {\n                    uploaded += (v.percentage || 0) * (v.end - v.start);\n                });\n\n                totalPercent = uploaded / file.size;\n                this.owner.trigger('uploadProgress', file, totalPercent || 0);\n            }\n\n        });\n    });\n    /**\n     * @fileOverview 各种验证，包括文件总大小是否超出、单文件是否超出和文件是否重复。\n     */\n\n    define('widgets/validator', ['base', 'uploader', 'file', 'widgets/widget'], function (Base, Uploader, WUFile) {\n\n        var $ = Base.$,\n            validators = {},\n            api;\n\n        /**\n         * @event error\n         * @param {String} type 错误类型。\n         * @description 当validate不通过时，会以派送错误事件的形式通知调用者。通过`upload.on('error', handler)`可以捕获到此类错误，目前有以下错误会在特定的情况下派送错来。\n         *\n         * * `Q_EXCEED_NUM_LIMIT` 在设置了`fileNumLimit`且尝试给`uploader`添加的文件数量超出这个值时派送。\n         * * `Q_EXCEED_SIZE_LIMIT` 在设置了`Q_EXCEED_SIZE_LIMIT`且尝试给`uploader`添加的文件总大小超出这个值时派送。\n         * * `Q_TYPE_DENIED` 当文件类型不满足时触发。。\n         * @for  Uploader\n         */\n\n        // 暴露给外面的api\n        api = {\n\n            // 添加验证器\n            addValidator: function addValidator(type, cb) {\n                validators[type] = cb;\n            },\n\n            // 移除验证器\n            removeValidator: function removeValidator(type) {\n                delete validators[type];\n            }\n        };\n\n        // 在Uploader初始化的时候启动Validators的初始化\n        Uploader.register({\n            name: 'validator',\n\n            init: function init() {\n                var me = this;\n                Base.nextTick(function () {\n                    $.each(validators, function () {\n                        this.call(me.owner);\n                    });\n                });\n            }\n        });\n\n        /**\n         * @property {int} [fileNumLimit=undefined]\n         * @namespace options\n         * @for Uploader\n         * @description 验证文件总数量, 超出则不允许加入队列。\n         */\n        api.addValidator('fileNumLimit', function () {\n            var uploader = this,\n                opts = uploader.options,\n                count = 0,\n                max = parseInt(opts.fileNumLimit, 10),\n                flag = true;\n\n            if (!max) {\n                return;\n            }\n\n            uploader.on('beforeFileQueued', function (file) {\n\n                if (count >= max && flag) {\n                    flag = false;\n                    this.trigger('error', 'Q_EXCEED_NUM_LIMIT', max, file);\n                    setTimeout(function () {\n                        flag = true;\n                    }, 1);\n                }\n\n                return count >= max ? false : true;\n            });\n\n            uploader.on('fileQueued', function () {\n                count++;\n            });\n\n            uploader.on('fileDequeued', function () {\n                count--;\n            });\n\n            uploader.on('reset', function () {\n                count = 0;\n            });\n        });\n\n        /**\n         * @property {int} [fileSizeLimit=undefined]\n         * @namespace options\n         * @for Uploader\n         * @description 验证文件总大小是否超出限制, 超出则不允许加入队列。\n         */\n        api.addValidator('fileSizeLimit', function () {\n            var uploader = this,\n                opts = uploader.options,\n                count = 0,\n                max = parseInt(opts.fileSizeLimit, 10),\n                flag = true;\n\n            if (!max) {\n                return;\n            }\n\n            uploader.on('beforeFileQueued', function (file) {\n                var invalid = count + file.size > max;\n\n                if (invalid && flag) {\n                    flag = false;\n                    this.trigger('error', 'Q_EXCEED_SIZE_LIMIT', max, file);\n                    setTimeout(function () {\n                        flag = true;\n                    }, 1);\n                }\n\n                return invalid ? false : true;\n            });\n\n            uploader.on('fileQueued', function (file) {\n                count += file.size;\n            });\n\n            uploader.on('fileDequeued', function (file) {\n                count -= file.size;\n            });\n\n            uploader.on('reset', function () {\n                count = 0;\n            });\n        });\n\n        /**\n         * @property {int} [fileSingleSizeLimit=undefined]\n         * @namespace options\n         * @for Uploader\n         * @description 验证单个文件大小是否超出限制, 超出则不允许加入队列。\n         */\n        api.addValidator('fileSingleSizeLimit', function () {\n            var uploader = this,\n                opts = uploader.options,\n                max = opts.fileSingleSizeLimit;\n\n            if (!max) {\n                return;\n            }\n\n            uploader.on('beforeFileQueued', function (file) {\n\n                if (file.size > max) {\n                    file.setStatus(WUFile.Status.INVALID, 'exceed_size');\n                    this.trigger('error', 'F_EXCEED_SIZE', max, file);\n                    return false;\n                }\n            });\n        });\n\n        /**\n         * @property {Boolean} [duplicate=undefined]\n         * @namespace options\n         * @for Uploader\n         * @description 去重， 根据文件名字、文件大小和最后修改时间来生成hash Key.\n         */\n        api.addValidator('duplicate', function () {\n            var uploader = this,\n                opts = uploader.options,\n                mapping = {};\n\n            if (opts.duplicate) {\n                return;\n            }\n\n            function hashString(str) {\n                var hash = 0,\n                    i = 0,\n                    len = str.length,\n                    _char;\n\n                for (; i < len; i++) {\n                    _char = str.charCodeAt(i);\n                    hash = _char + (hash << 6) + (hash << 16) - hash;\n                }\n\n                return hash;\n            }\n\n            uploader.on('beforeFileQueued', function (file) {\n                var hash = file.__hash || (file.__hash = hashString(file.name + file.size + file.lastModifiedDate));\n\n                // 已经重复了\n                if (mapping[hash]) {\n                    this.trigger('error', 'F_DUPLICATE', file);\n                    return false;\n                }\n            });\n\n            uploader.on('fileQueued', function (file) {\n                var hash = file.__hash;\n\n                hash && (mapping[hash] = true);\n            });\n\n            uploader.on('fileDequeued', function (file) {\n                var hash = file.__hash;\n\n                hash && delete mapping[hash];\n            });\n\n            uploader.on('reset', function () {\n                mapping = {};\n            });\n        });\n\n        return api;\n    });\n\n    /**\n     * @fileOverview Md5\n     */\n    define('lib/md5', ['runtime/client', 'mediator'], function (RuntimeClient, Mediator) {\n\n        function Md5() {\n            RuntimeClient.call(this, 'Md5');\n        }\n\n        // 让 Md5 具备事件功能。\n        Mediator.installTo(Md5.prototype);\n\n        Md5.prototype.loadFromBlob = function (blob) {\n            var me = this;\n\n            if (me.getRuid()) {\n                me.disconnectRuntime();\n            }\n\n            // 连接到blob归属的同一个runtime.\n            me.connectRuntime(blob.ruid, function () {\n                me.exec('init');\n                me.exec('loadFromBlob', blob);\n            });\n        };\n\n        Md5.prototype.getResult = function () {\n            return this.exec('getResult');\n        };\n\n        return Md5;\n    });\n    /**\n     * @fileOverview 图片操作, 负责预览图片和上传前压缩图片\n     */\n    define('widgets/md5', ['base', 'uploader', 'lib/md5', 'lib/blob', 'widgets/widget'], function (Base, Uploader, Md5, Blob) {\n\n        return Uploader.register({\n            name: 'md5',\n\n            /**\n             * 计算文件 md5 值，返回一个 promise 对象，可以监听 progress 进度。\n             *\n             *\n             * @method md5File\n             * @grammar md5File( file[, start[, end]] ) => promise\n             * @for Uploader\n             * @example\n             *\n             * uploader.on( 'fileQueued', function( file ) {\n             *     var $li = ...;\n             *\n             *     uploader.md5File( file )\n             *\n             *         // 及时显示进度\n             *         .progress(function(percentage) {\n             *             console.log('Percentage:', percentage);\n             *         })\n             *\n             *         // 完成\n             *         .then(function(val) {\n             *             console.log('md5 result:', val);\n             *         });\n             *\n             * });\n             */\n            md5File: function md5File(file, start, end) {\n                var md5 = new Md5(),\n                    deferred = Base.Deferred(),\n                    blob = file instanceof Blob ? file : this.request('get-file', file).source;\n\n                md5.on('progress load', function (e) {\n                    e = e || {};\n                    deferred.notify(e.total ? e.loaded / e.total : 1);\n                });\n\n                md5.on('complete', function () {\n                    deferred.resolve(md5.getResult());\n                });\n\n                md5.on('error', function (reason) {\n                    deferred.reject(reason);\n                });\n\n                if (arguments.length > 1) {\n                    start = start || 0;\n                    end = end || 0;\n                    start < 0 && (start = blob.size + start);\n                    end < 0 && (end = blob.size + end);\n                    end = Math.min(end, blob.size);\n                    blob = blob.slice(start, end);\n                }\n\n                md5.loadFromBlob(blob);\n\n                return deferred.promise();\n            }\n        });\n    });\n    /**\n     * @fileOverview Runtime管理器，负责Runtime的选择, 连接\n     */\n    define('runtime/compbase', [], function () {\n\n        function CompBase(owner, runtime) {\n\n            this.owner = owner;\n            this.options = owner.options;\n\n            this.getRuntime = function () {\n                return runtime;\n            };\n\n            this.getRuid = function () {\n                return runtime.uid;\n            };\n\n            this.trigger = function () {\n                return owner.trigger.apply(owner, arguments);\n            };\n        }\n\n        return CompBase;\n    });\n    /**\n     * @fileOverview Html5Runtime\n     */\n    define('runtime/html5/runtime', ['base', 'runtime/runtime', 'runtime/compbase'], function (Base, Runtime, CompBase) {\n\n        var type = 'html5',\n            components = {};\n\n        function Html5Runtime() {\n            var pool = {},\n                me = this,\n                destroy = this.destroy;\n\n            Runtime.apply(me, arguments);\n            me.type = type;\n\n            // 这个方法的调用者，实际上是RuntimeClient\n            me.exec = function (comp, fn /*, args...*/) {\n                var client = this,\n                    uid = client.uid,\n                    args = Base.slice(arguments, 2),\n                    instance;\n\n                if (components[comp]) {\n                    instance = pool[uid] = pool[uid] || new components[comp](client, me);\n\n                    if (instance[fn]) {\n                        return instance[fn].apply(instance, args);\n                    }\n                }\n            };\n\n            me.destroy = function () {\n                // @todo 删除池子中的所有实例\n                return destroy && destroy.apply(this, arguments);\n            };\n        }\n\n        Base.inherits(Runtime, {\n            constructor: Html5Runtime,\n\n            // 不需要连接其他程序，直接执行callback\n            init: function init() {\n                var me = this;\n                setTimeout(function () {\n                    me.trigger('ready');\n                }, 1);\n            }\n\n        });\n\n        // 注册Components\n        Html5Runtime.register = function (name, component) {\n            var klass = components[name] = Base.inherits(CompBase, component);\n            return klass;\n        };\n\n        // 注册html5运行时。\n        // 只有在支持的前提下注册。\n        if (window.Blob && window.FileReader && window.DataView) {\n            Runtime.addRuntime(type, Html5Runtime);\n        }\n\n        return Html5Runtime;\n    });\n    /**\n     * @fileOverview Blob Html实现\n     */\n    define('runtime/html5/blob', ['runtime/html5/runtime', 'lib/blob'], function (Html5Runtime, Blob) {\n\n        return Html5Runtime.register('Blob', {\n            slice: function slice(start, end) {\n                var blob = this.owner.source,\n                    slice = blob.slice || blob.webkitSlice || blob.mozSlice;\n\n                blob = slice.call(blob, start, end);\n\n                return new Blob(this.getRuid(), blob);\n            }\n        });\n    });\n    /**\n     * @fileOverview FilePaste\n     */\n    define('runtime/html5/dnd', ['base', 'runtime/html5/runtime', 'lib/file'], function (Base, Html5Runtime, File) {\n\n        var $ = Base.$,\n            prefix = 'webuploader-dnd-';\n\n        return Html5Runtime.register('DragAndDrop', {\n            init: function init() {\n                var elem = this.elem = this.options.container;\n\n                this.dragEnterHandler = Base.bindFn(this._dragEnterHandler, this);\n                this.dragOverHandler = Base.bindFn(this._dragOverHandler, this);\n                this.dragLeaveHandler = Base.bindFn(this._dragLeaveHandler, this);\n                this.dropHandler = Base.bindFn(this._dropHandler, this);\n                this.dndOver = false;\n\n                elem.on('dragenter', this.dragEnterHandler);\n                elem.on('dragover', this.dragOverHandler);\n                elem.on('dragleave', this.dragLeaveHandler);\n                elem.on('drop', this.dropHandler);\n\n                if (this.options.disableGlobalDnd) {\n                    $(document).on('dragover', this.dragOverHandler);\n                    $(document).on('drop', this.dropHandler);\n                }\n            },\n\n            _dragEnterHandler: function _dragEnterHandler(e) {\n                var me = this,\n                    denied = me._denied || false,\n                    items;\n\n                e = e.originalEvent || e;\n\n                if (!me.dndOver) {\n                    me.dndOver = true;\n\n                    // 注意只有 chrome 支持。\n                    items = e.dataTransfer.items;\n\n                    if (items && items.length) {\n                        me._denied = denied = !me.trigger('accept', items);\n                    }\n\n                    me.elem.addClass(prefix + 'over');\n                    me.elem[denied ? 'addClass' : 'removeClass'](prefix + 'denied');\n                }\n\n                e.dataTransfer.dropEffect = denied ? 'none' : 'copy';\n\n                return false;\n            },\n\n            _dragOverHandler: function _dragOverHandler(e) {\n                // 只处理框内的。\n                var parentElem = this.elem.parent().get(0);\n                if (parentElem && !$.contains(parentElem, e.currentTarget)) {\n                    return false;\n                }\n\n                clearTimeout(this._leaveTimer);\n                this._dragEnterHandler.call(this, e);\n\n                return false;\n            },\n\n            _dragLeaveHandler: function _dragLeaveHandler() {\n                var me = this,\n                    handler;\n\n                handler = function handler() {\n                    me.dndOver = false;\n                    me.elem.removeClass(prefix + 'over ' + prefix + 'denied');\n                };\n\n                clearTimeout(me._leaveTimer);\n                me._leaveTimer = setTimeout(handler, 100);\n                return false;\n            },\n\n            _dropHandler: function _dropHandler(e) {\n                var me = this,\n                    ruid = me.getRuid(),\n                    parentElem = me.elem.parent().get(0),\n                    dataTransfer,\n                    data;\n\n                // 只处理框内的。\n                if (parentElem && !$.contains(parentElem, e.currentTarget)) {\n                    return false;\n                }\n\n                e = e.originalEvent || e;\n                dataTransfer = e.dataTransfer;\n\n                // 如果是页面内拖拽，还不能处理，不阻止事件。\n                // 此处 ie11 下会报参数错误，\n                try {\n                    data = dataTransfer.getData('text/html');\n                } catch (err) {}\n\n                if (data) {\n                    return;\n                }\n\n                me._getTansferFiles(dataTransfer, function (results) {\n                    me.trigger('drop', $.map(results, function (file) {\n                        return new File(ruid, file);\n                    }));\n                });\n\n                me.dndOver = false;\n                me.elem.removeClass(prefix + 'over');\n                return false;\n            },\n\n            // 如果传入 callback 则去查看文件夹，否则只管当前文件夹。\n            _getTansferFiles: function _getTansferFiles(dataTransfer, callback) {\n                var results = [],\n                    promises = [],\n                    items,\n                    files,\n                    file,\n                    item,\n                    i,\n                    len,\n                    canAccessFolder;\n\n                items = dataTransfer.items;\n                files = dataTransfer.files;\n\n                canAccessFolder = !!(items && items[0].webkitGetAsEntry);\n\n                for (i = 0, len = files.length; i < len; i++) {\n                    file = files[i];\n                    item = items && items[i];\n\n                    if (canAccessFolder && item.webkitGetAsEntry().isDirectory) {\n\n                        promises.push(this._traverseDirectoryTree(item.webkitGetAsEntry(), results));\n                    } else {\n                        results.push(file);\n                    }\n                }\n\n                Base.when.apply(Base, promises).done(function () {\n\n                    if (!results.length) {\n                        return;\n                    }\n\n                    callback(results);\n                });\n            },\n\n            _traverseDirectoryTree: function _traverseDirectoryTree(entry, results) {\n                var deferred = Base.Deferred(),\n                    me = this;\n\n                if (entry.isFile) {\n                    entry.file(function (file) {\n                        results.push(file);\n                        deferred.resolve();\n                    });\n                } else if (entry.isDirectory) {\n                    entry.createReader().readEntries(function (entries) {\n                        var len = entries.length,\n                            promises = [],\n                            arr = [],\n                            // 为了保证顺序。\n                        i;\n\n                        for (i = 0; i < len; i++) {\n                            promises.push(me._traverseDirectoryTree(entries[i], arr));\n                        }\n\n                        Base.when.apply(Base, promises).then(function () {\n                            results.push.apply(results, arr);\n                            deferred.resolve();\n                        }, deferred.reject);\n                    });\n                }\n\n                return deferred.promise();\n            },\n\n            destroy: function destroy() {\n                var elem = this.elem;\n\n                // 还没 init 就调用 destroy\n                if (!elem) {\n                    return;\n                }\n\n                elem.off('dragenter', this.dragEnterHandler);\n                elem.off('dragover', this.dragOverHandler);\n                elem.off('dragleave', this.dragLeaveHandler);\n                elem.off('drop', this.dropHandler);\n\n                if (this.options.disableGlobalDnd) {\n                    $(document).off('dragover', this.dragOverHandler);\n                    $(document).off('drop', this.dropHandler);\n                }\n            }\n        });\n    });\n\n    /**\n     * @fileOverview FilePaste\n     */\n    define('runtime/html5/filepaste', ['base', 'runtime/html5/runtime', 'lib/file'], function (Base, Html5Runtime, File) {\n\n        return Html5Runtime.register('FilePaste', {\n            init: function init() {\n                var opts = this.options,\n                    elem = this.elem = opts.container,\n                    accept = '.*',\n                    arr,\n                    i,\n                    len,\n                    item;\n\n                // accetp的mimeTypes中生成匹配正则。\n                if (opts.accept) {\n                    arr = [];\n\n                    for (i = 0, len = opts.accept.length; i < len; i++) {\n                        item = opts.accept[i].mimeTypes;\n                        item && arr.push(item);\n                    }\n\n                    if (arr.length) {\n                        accept = arr.join(',');\n                        accept = accept.replace(/,/g, '|').replace(/\\*/g, '.*');\n                    }\n                }\n                this.accept = accept = new RegExp(accept, 'i');\n                this.hander = Base.bindFn(this._pasteHander, this);\n                elem.on('paste', this.hander);\n            },\n\n            _pasteHander: function _pasteHander(e) {\n                var allowed = [],\n                    ruid = this.getRuid(),\n                    items,\n                    item,\n                    blob,\n                    i,\n                    len;\n\n                e = e.originalEvent || e;\n                items = e.clipboardData.items;\n\n                for (i = 0, len = items.length; i < len; i++) {\n                    item = items[i];\n\n                    if (item.kind !== 'file' || !(blob = item.getAsFile())) {\n                        continue;\n                    }\n\n                    allowed.push(new File(ruid, blob));\n                }\n\n                if (allowed.length) {\n                    // 不阻止非文件粘贴（文字粘贴）的事件冒泡\n                    e.preventDefault();\n                    e.stopPropagation();\n                    this.trigger('paste', allowed);\n                }\n            },\n\n            destroy: function destroy() {\n                this.elem.off('paste', this.hander);\n            }\n        });\n    });\n\n    /**\n     * @fileOverview FilePicker\n     */\n    define('runtime/html5/filepicker', ['base', 'runtime/html5/runtime'], function (Base, Html5Runtime) {\n\n        var $ = Base.$;\n\n        return Html5Runtime.register('FilePicker', {\n            init: function init() {\n                var container = this.getRuntime().getContainer(),\n                    me = this,\n                    owner = me.owner,\n                    opts = me.options,\n                    label = this.label = $(document.createElement('label')),\n                    input = this.input = $(document.createElement('input')),\n                    arr,\n                    i,\n                    len,\n                    mouseHandler;\n\n                input.attr('type', 'file');\n                input.attr('name', opts.name);\n                input.addClass('webuploader-element-invisible');\n\n                label.on('click', function () {\n                    input.trigger('click');\n                });\n\n                label.css({\n                    opacity: 0,\n                    width: '100%',\n                    height: '100%',\n                    display: 'block',\n                    cursor: 'pointer',\n                    background: '#ffffff'\n                });\n\n                if (opts.multiple) {\n                    input.attr('multiple', 'multiple');\n                }\n\n                // @todo Firefox不支持单独指定后缀\n                if (opts.accept && opts.accept.length > 0) {\n                    arr = [];\n\n                    for (i = 0, len = opts.accept.length; i < len; i++) {\n                        arr.push(opts.accept[i].mimeTypes);\n                    }\n\n                    input.attr('accept', arr.join(','));\n                }\n\n                container.append(input);\n                container.append(label);\n\n                mouseHandler = function mouseHandler(e) {\n                    owner.trigger(e.type);\n                };\n\n                /* input.on( 'change', function( e ) {\n                    var fn = arguments.callee,\n                        clone;\n                         me.files = e.target.files;\n                         // reset input\n                    clone = this.cloneNode( true );\n                    clone.value = null;\n                    this.parentNode.replaceChild( clone, this );\n                         input.off();\n                    input = $( clone ).on( 'change', fn )\n                            .on( 'mouseenter mouseleave', mouseHandler );\n                         owner.trigger('change');\n                }); //wqd 20190507\n                */\n                var changeFn = function even(that, e) {\n\n                    var clone;\n\n                    me.files = e.target.files;\n\n                    // reset input\n                    clone = that.cloneNode(true);\n                    clone.value = null;\n                    that.parentNode.replaceChild(clone, that);\n\n                    input.off();\n                    input = $(clone).on('change', function (e) {\n                        even(this, e);\n                    }).on('mouseenter mouseleave', mouseHandler);\n\n                    owner.trigger('change');\n                };\n\n                input.on('change', function (e) {\n                    changeFn(this, e);\n                });\n                label.on('mouseenter mouseleave', mouseHandler);\n            },\n\n            getFiles: function getFiles() {\n                return this.files;\n            },\n\n            destroy: function destroy() {\n                this.input.off();\n                this.label.off();\n            }\n        });\n    });\n    /**\n     * Terms:\n     *\n     * Uint8Array, FileReader, BlobBuilder, atob, ArrayBuffer\n     * @fileOverview Image控件\n     */\n    define('runtime/html5/util', ['base'], function (Base) {\n\n        var urlAPI = window.createObjectURL && window || window.URL && URL.revokeObjectURL && URL || window.webkitURL,\n            createObjectURL = Base.noop,\n            revokeObjectURL = createObjectURL;\n\n        if (urlAPI) {\n\n            // 更安全的方式调用，比如android里面就能把context改成其他的对象。\n            createObjectURL = function createObjectURL() {\n                return urlAPI.createObjectURL.apply(urlAPI, arguments);\n            };\n\n            revokeObjectURL = function revokeObjectURL() {\n                return urlAPI.revokeObjectURL.apply(urlAPI, arguments);\n            };\n        }\n\n        return {\n            createObjectURL: createObjectURL,\n            revokeObjectURL: revokeObjectURL,\n\n            dataURL2Blob: function dataURL2Blob(dataURI) {\n                var byteStr, intArray, ab, i, mimetype, parts;\n\n                parts = dataURI.split(',');\n\n                if (~parts[0].indexOf('base64')) {\n                    byteStr = atob(parts[1]);\n                } else {\n                    byteStr = decodeURIComponent(parts[1]);\n                }\n\n                ab = new ArrayBuffer(byteStr.length);\n                intArray = new Uint8Array(ab);\n\n                for (i = 0; i < byteStr.length; i++) {\n                    intArray[i] = byteStr.charCodeAt(i);\n                }\n\n                mimetype = parts[0].split(':')[1].split(';')[0];\n\n                return this.arrayBufferToBlob(ab, mimetype);\n            },\n\n            dataURL2ArrayBuffer: function dataURL2ArrayBuffer(dataURI) {\n                var byteStr, intArray, i, parts;\n\n                parts = dataURI.split(',');\n\n                if (~parts[0].indexOf('base64')) {\n                    byteStr = atob(parts[1]);\n                } else {\n                    byteStr = decodeURIComponent(parts[1]);\n                }\n\n                intArray = new Uint8Array(byteStr.length);\n\n                for (i = 0; i < byteStr.length; i++) {\n                    intArray[i] = byteStr.charCodeAt(i);\n                }\n\n                return intArray.buffer;\n            },\n\n            arrayBufferToBlob: function arrayBufferToBlob(buffer, type) {\n                var builder = window.BlobBuilder || window.WebKitBlobBuilder,\n                    bb;\n\n                // android不支持直接new Blob, 只能借助blobbuilder.\n                if (builder) {\n                    bb = new builder();\n                    bb.append(buffer);\n                    return bb.getBlob(type);\n                }\n\n                return new Blob([buffer], type ? { type: type } : {});\n            },\n\n            // 抽出来主要是为了解决android下面canvas.toDataUrl不支持jpeg.\n            // 你得到的结果是png.\n            canvasToDataUrl: function canvasToDataUrl(canvas, type, quality) {\n                return canvas.toDataURL(type, quality / 100);\n            },\n\n            // imagemeat会复写这个方法，如果用户选择加载那个文件了的话。\n            parseMeta: function parseMeta(blob, callback) {\n                callback(false, {});\n            },\n\n            // imagemeat会复写这个方法，如果用户选择加载那个文件了的话。\n            updateImageHead: function updateImageHead(data) {\n                return data;\n            }\n        };\n    });\n    /**\n     * Terms:\n     *\n     * Uint8Array, FileReader, BlobBuilder, atob, ArrayBuffer\n     * @fileOverview Image控件\n     */\n    define('runtime/html5/imagemeta', ['runtime/html5/util'], function (Util) {\n\n        var api;\n\n        api = {\n            parsers: {\n                0xffe1: []\n            },\n\n            maxMetaDataSize: 262144,\n\n            parse: function parse(blob, cb) {\n                var me = this,\n                    fr = new FileReader();\n\n                fr.onload = function () {\n                    cb(false, me._parse(this.result));\n                    fr = fr.onload = fr.onerror = null;\n                };\n\n                fr.onerror = function (e) {\n                    cb(e.message);\n                    fr = fr.onload = fr.onerror = null;\n                };\n\n                blob = blob.slice(0, me.maxMetaDataSize);\n                fr.readAsArrayBuffer(blob.getSource());\n            },\n\n            _parse: function _parse(buffer, noParse) {\n                if (buffer.byteLength < 6) {\n                    return;\n                }\n\n                var dataview = new DataView(buffer),\n                    offset = 2,\n                    maxOffset = dataview.byteLength - 4,\n                    headLength = offset,\n                    ret = {},\n                    markerBytes,\n                    markerLength,\n                    parsers,\n                    i;\n\n                if (dataview.getUint16(0) === 0xffd8) {\n\n                    while (offset < maxOffset) {\n                        markerBytes = dataview.getUint16(offset);\n\n                        if (markerBytes >= 0xffe0 && markerBytes <= 0xffef || markerBytes === 0xfffe) {\n\n                            markerLength = dataview.getUint16(offset + 2) + 2;\n\n                            if (offset + markerLength > dataview.byteLength) {\n                                break;\n                            }\n\n                            parsers = api.parsers[markerBytes];\n\n                            if (!noParse && parsers) {\n                                for (i = 0; i < parsers.length; i += 1) {\n                                    parsers[i].call(api, dataview, offset, markerLength, ret);\n                                }\n                            }\n\n                            offset += markerLength;\n                            headLength = offset;\n                        } else {\n                            break;\n                        }\n                    }\n\n                    if (headLength > 6) {\n                        if (buffer.slice) {\n                            ret.imageHead = buffer.slice(2, headLength);\n                        } else {\n                            // Workaround for IE10, which does not yet\n                            // support ArrayBuffer.slice:\n                            ret.imageHead = new Uint8Array(buffer).subarray(2, headLength);\n                        }\n                    }\n                }\n\n                return ret;\n            },\n\n            updateImageHead: function updateImageHead(buffer, head) {\n                var data = this._parse(buffer, true),\n                    buf1,\n                    buf2,\n                    bodyoffset;\n\n                bodyoffset = 2;\n                if (data.imageHead) {\n                    bodyoffset = 2 + data.imageHead.byteLength;\n                }\n\n                if (buffer.slice) {\n                    buf2 = buffer.slice(bodyoffset);\n                } else {\n                    buf2 = new Uint8Array(buffer).subarray(bodyoffset);\n                }\n\n                buf1 = new Uint8Array(head.byteLength + 2 + buf2.byteLength);\n\n                buf1[0] = 0xFF;\n                buf1[1] = 0xD8;\n                buf1.set(new Uint8Array(head), 2);\n                buf1.set(new Uint8Array(buf2), head.byteLength + 2);\n\n                return buf1.buffer;\n            }\n        };\n\n        Util.parseMeta = function () {\n            return api.parse.apply(api, arguments);\n        };\n\n        Util.updateImageHead = function () {\n            return api.updateImageHead.apply(api, arguments);\n        };\n\n        return api;\n    });\n    /**\n     * 代码来自于：https://github.com/blueimp/JavaScript-Load-Image\n     * 暂时项目中只用了orientation.\n     *\n     * 去除了 Exif Sub IFD Pointer, GPS Info IFD Pointer, Exif Thumbnail.\n     * @fileOverview EXIF解析\n     */\n\n    // Sample\n    // ====================================\n    // Make : Apple\n    // Model : iPhone 4S\n    // Orientation : 1\n    // XResolution : 72 [72/1]\n    // YResolution : 72 [72/1]\n    // ResolutionUnit : 2\n    // Software : QuickTime 7.7.1\n    // DateTime : 2013:09:01 22:53:55\n    // ExifIFDPointer : 190\n    // ExposureTime : 0.058823529411764705 [1/17]\n    // FNumber : 2.4 [12/5]\n    // ExposureProgram : Normal program\n    // ISOSpeedRatings : 800\n    // ExifVersion : 0220\n    // DateTimeOriginal : 2013:09:01 22:52:51\n    // DateTimeDigitized : 2013:09:01 22:52:51\n    // ComponentsConfiguration : YCbCr\n    // ShutterSpeedValue : 4.058893515764426\n    // ApertureValue : 2.5260688216892597 [4845/1918]\n    // BrightnessValue : -0.3126686601998395\n    // MeteringMode : Pattern\n    // Flash : Flash did not fire, compulsory flash mode\n    // FocalLength : 4.28 [107/25]\n    // SubjectArea : [4 values]\n    // FlashpixVersion : 0100\n    // ColorSpace : 1\n    // PixelXDimension : 2448\n    // PixelYDimension : 3264\n    // SensingMethod : One-chip color area sensor\n    // ExposureMode : 0\n    // WhiteBalance : Auto white balance\n    // FocalLengthIn35mmFilm : 35\n    // SceneCaptureType : Standard\n    define('runtime/html5/imagemeta/exif', ['base', 'runtime/html5/imagemeta'], function (Base, ImageMeta) {\n\n        var EXIF = {};\n\n        EXIF.ExifMap = function () {\n            return this;\n        };\n\n        EXIF.ExifMap.prototype.map = {\n            'Orientation': 0x0112\n        };\n\n        EXIF.ExifMap.prototype.get = function (id) {\n            return this[id] || this[this.map[id]];\n        };\n\n        EXIF.exifTagTypes = {\n            // byte, 8-bit unsigned int:\n            1: {\n                getValue: function getValue(dataView, dataOffset) {\n                    return dataView.getUint8(dataOffset);\n                },\n                size: 1\n            },\n\n            // ascii, 8-bit byte:\n            2: {\n                getValue: function getValue(dataView, dataOffset) {\n                    return String.fromCharCode(dataView.getUint8(dataOffset));\n                },\n                size: 1,\n                ascii: true\n            },\n\n            // short, 16 bit int:\n            3: {\n                getValue: function getValue(dataView, dataOffset, littleEndian) {\n                    return dataView.getUint16(dataOffset, littleEndian);\n                },\n                size: 2\n            },\n\n            // long, 32 bit int:\n            4: {\n                getValue: function getValue(dataView, dataOffset, littleEndian) {\n                    return dataView.getUint32(dataOffset, littleEndian);\n                },\n                size: 4\n            },\n\n            // rational = two long values,\n            // first is numerator, second is denominator:\n            5: {\n                getValue: function getValue(dataView, dataOffset, littleEndian) {\n                    return dataView.getUint32(dataOffset, littleEndian) / dataView.getUint32(dataOffset + 4, littleEndian);\n                },\n                size: 8\n            },\n\n            // slong, 32 bit signed int:\n            9: {\n                getValue: function getValue(dataView, dataOffset, littleEndian) {\n                    return dataView.getInt32(dataOffset, littleEndian);\n                },\n                size: 4\n            },\n\n            // srational, two slongs, first is numerator, second is denominator:\n            10: {\n                getValue: function getValue(dataView, dataOffset, littleEndian) {\n                    return dataView.getInt32(dataOffset, littleEndian) / dataView.getInt32(dataOffset + 4, littleEndian);\n                },\n                size: 8\n            }\n        };\n\n        // undefined, 8-bit byte, value depending on field:\n        EXIF.exifTagTypes[7] = EXIF.exifTagTypes[1];\n\n        EXIF.getExifValue = function (dataView, tiffOffset, offset, type, length, littleEndian) {\n\n            var tagType = EXIF.exifTagTypes[type],\n                tagSize,\n                dataOffset,\n                values,\n                i,\n                str,\n                c;\n\n            if (!tagType) {\n                Base.log('Invalid Exif data: Invalid tag type.');\n                return;\n            }\n\n            tagSize = tagType.size * length;\n\n            // Determine if the value is contained in the dataOffset bytes,\n            // or if the value at the dataOffset is a pointer to the actual data:\n            dataOffset = tagSize > 4 ? tiffOffset + dataView.getUint32(offset + 8, littleEndian) : offset + 8;\n\n            if (dataOffset + tagSize > dataView.byteLength) {\n                Base.log('Invalid Exif data: Invalid data offset.');\n                return;\n            }\n\n            if (length === 1) {\n                return tagType.getValue(dataView, dataOffset, littleEndian);\n            }\n\n            values = [];\n\n            for (i = 0; i < length; i += 1) {\n                values[i] = tagType.getValue(dataView, dataOffset + i * tagType.size, littleEndian);\n            }\n\n            if (tagType.ascii) {\n                str = '';\n\n                // Concatenate the chars:\n                for (i = 0; i < values.length; i += 1) {\n                    c = values[i];\n\n                    // Ignore the terminating NULL byte(s):\n                    if (c === '\\0') {\n                        break;\n                    }\n                    str += c;\n                }\n\n                return str;\n            }\n            return values;\n        };\n\n        EXIF.parseExifTag = function (dataView, tiffOffset, offset, littleEndian, data) {\n\n            var tag = dataView.getUint16(offset, littleEndian);\n            data.exif[tag] = EXIF.getExifValue(dataView, tiffOffset, offset, dataView.getUint16(offset + 2, littleEndian), // tag type\n            dataView.getUint32(offset + 4, littleEndian), // tag length\n            littleEndian);\n        };\n\n        EXIF.parseExifTags = function (dataView, tiffOffset, dirOffset, littleEndian, data) {\n\n            var tagsNumber, dirEndOffset, i;\n\n            if (dirOffset + 6 > dataView.byteLength) {\n                Base.log('Invalid Exif data: Invalid directory offset.');\n                return;\n            }\n\n            tagsNumber = dataView.getUint16(dirOffset, littleEndian);\n            dirEndOffset = dirOffset + 2 + 12 * tagsNumber;\n\n            if (dirEndOffset + 4 > dataView.byteLength) {\n                Base.log('Invalid Exif data: Invalid directory size.');\n                return;\n            }\n\n            for (i = 0; i < tagsNumber; i += 1) {\n                this.parseExifTag(dataView, tiffOffset, dirOffset + 2 + 12 * i, // tag offset\n                littleEndian, data);\n            }\n\n            // Return the offset to the next directory:\n            return dataView.getUint32(dirEndOffset, littleEndian);\n        };\n\n        // EXIF.getExifThumbnail = function(dataView, offset, length) {\n        //     var hexData,\n        //         i,\n        //         b;\n        //     if (!length || offset + length > dataView.byteLength) {\n        //         Base.log('Invalid Exif data: Invalid thumbnail data.');\n        //         return;\n        //     }\n        //     hexData = [];\n        //     for (i = 0; i < length; i += 1) {\n        //         b = dataView.getUint8(offset + i);\n        //         hexData.push((b < 16 ? '0' : '') + b.toString(16));\n        //     }\n        //     return 'data:image/jpeg,%' + hexData.join('%');\n        // };\n\n        EXIF.parseExifData = function (dataView, offset, length, data) {\n\n            var tiffOffset = offset + 10,\n                littleEndian,\n                dirOffset;\n\n            // Check for the ASCII code for \"Exif\" (0x45786966):\n            if (dataView.getUint32(offset + 4) !== 0x45786966) {\n                // No Exif data, might be XMP data instead\n                return;\n            }\n            if (tiffOffset + 8 > dataView.byteLength) {\n                Base.log('Invalid Exif data: Invalid segment size.');\n                return;\n            }\n\n            // Check for the two null bytes:\n            if (dataView.getUint16(offset + 8) !== 0x0000) {\n                Base.log('Invalid Exif data: Missing byte alignment offset.');\n                return;\n            }\n\n            // Check the byte alignment:\n            switch (dataView.getUint16(tiffOffset)) {\n                case 0x4949:\n                    littleEndian = true;\n                    break;\n\n                case 0x4D4D:\n                    littleEndian = false;\n                    break;\n\n                default:\n                    Base.log('Invalid Exif data: Invalid byte alignment marker.');\n                    return;\n            }\n\n            // Check for the TIFF tag marker (0x002A):\n            if (dataView.getUint16(tiffOffset + 2, littleEndian) !== 0x002A) {\n                Base.log('Invalid Exif data: Missing TIFF marker.');\n                return;\n            }\n\n            // Retrieve the directory offset bytes, usually 0x00000008 or 8 decimal:\n            dirOffset = dataView.getUint32(tiffOffset + 4, littleEndian);\n            // Create the exif object to store the tags:\n            data.exif = new EXIF.ExifMap();\n            // Parse the tags of the main image directory and retrieve the\n            // offset to the next directory, usually the thumbnail directory:\n            dirOffset = EXIF.parseExifTags(dataView, tiffOffset, tiffOffset + dirOffset, littleEndian, data);\n\n            // 尝试读取缩略图\n            // if ( dirOffset ) {\n            //     thumbnailData = {exif: {}};\n            //     dirOffset = EXIF.parseExifTags(\n            //         dataView,\n            //         tiffOffset,\n            //         tiffOffset + dirOffset,\n            //         littleEndian,\n            //         thumbnailData\n            //     );\n\n            //     // Check for JPEG Thumbnail offset:\n            //     if (thumbnailData.exif[0x0201]) {\n            //         data.exif.Thumbnail = EXIF.getExifThumbnail(\n            //             dataView,\n            //             tiffOffset + thumbnailData.exif[0x0201],\n            //             thumbnailData.exif[0x0202] // Thumbnail data length\n            //         );\n            //     }\n            // }\n        };\n\n        ImageMeta.parsers[0xffe1].push(EXIF.parseExifData);\n        return EXIF;\n    });\n    /**\n     * 这个方式性能不行，但是可以解决android里面的toDataUrl的bug\n     * android里面toDataUrl('image/jpege')得到的结果却是png.\n     *\n     * 所以这里没辙，只能借助这个工具\n     * @fileOverview jpeg encoder\n     */\n    define('runtime/html5/jpegencoder', [], function (require, exports, module) {\n\n        /*\n          Copyright (c) 2008, Adobe Systems Incorporated\n          All rights reserved.\n               Redistribution and use in source and binary forms, with or without\n          modification, are permitted provided that the following conditions are\n          met:\n               * Redistributions of source code must retain the above copyright notice,\n            this list of conditions and the following disclaimer.\n               * Redistributions in binary form must reproduce the above copyright\n            notice, this list of conditions and the following disclaimer in the\n            documentation and/or other materials provided with the distribution.\n               * Neither the name of Adobe Systems Incorporated nor the names of its\n            contributors may be used to endorse or promote products derived from\n            this software without specific prior written permission.\n               THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS\n          IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,\n          THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR\n          PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR\n          CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,\n          EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\n          PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n          PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF\n          LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING\n          NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n          SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n        */\n        /*\n        JPEG encoder ported to JavaScript and optimized by Andreas Ritter, www.bytestrom.eu, 11/2009\n             Basic GUI blocking jpeg encoder\n        */\n\n        function JPEGEncoder(quality) {\n            var self = this;\n            var fround = Math.round;\n            var ffloor = Math.floor;\n            var YTable = new Array(64);\n            var UVTable = new Array(64);\n            var fdtbl_Y = new Array(64);\n            var fdtbl_UV = new Array(64);\n            var YDC_HT;\n            var UVDC_HT;\n            var YAC_HT;\n            var UVAC_HT;\n\n            var bitcode = new Array(65535);\n            var category = new Array(65535);\n            var outputfDCTQuant = new Array(64);\n            var DU = new Array(64);\n            var byteout = [];\n            var bytenew = 0;\n            var bytepos = 7;\n\n            var YDU = new Array(64);\n            var UDU = new Array(64);\n            var VDU = new Array(64);\n            var clt = new Array(256);\n            var RGB_YUV_TABLE = new Array(2048);\n            var currentQuality;\n\n            var ZigZag = [0, 1, 5, 6, 14, 15, 27, 28, 2, 4, 7, 13, 16, 26, 29, 42, 3, 8, 12, 17, 25, 30, 41, 43, 9, 11, 18, 24, 31, 40, 44, 53, 10, 19, 23, 32, 39, 45, 52, 54, 20, 22, 33, 38, 46, 51, 55, 60, 21, 34, 37, 47, 50, 56, 59, 61, 35, 36, 48, 49, 57, 58, 62, 63];\n\n            var std_dc_luminance_nrcodes = [0, 0, 1, 5, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0];\n            var std_dc_luminance_values = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11];\n            var std_ac_luminance_nrcodes = [0, 0, 2, 1, 3, 3, 2, 4, 3, 5, 5, 4, 4, 0, 0, 1, 0x7d];\n            var std_ac_luminance_values = [0x01, 0x02, 0x03, 0x00, 0x04, 0x11, 0x05, 0x12, 0x21, 0x31, 0x41, 0x06, 0x13, 0x51, 0x61, 0x07, 0x22, 0x71, 0x14, 0x32, 0x81, 0x91, 0xa1, 0x08, 0x23, 0x42, 0xb1, 0xc1, 0x15, 0x52, 0xd1, 0xf0, 0x24, 0x33, 0x62, 0x72, 0x82, 0x09, 0x0a, 0x16, 0x17, 0x18, 0x19, 0x1a, 0x25, 0x26, 0x27, 0x28, 0x29, 0x2a, 0x34, 0x35, 0x36, 0x37, 0x38, 0x39, 0x3a, 0x43, 0x44, 0x45, 0x46, 0x47, 0x48, 0x49, 0x4a, 0x53, 0x54, 0x55, 0x56, 0x57, 0x58, 0x59, 0x5a, 0x63, 0x64, 0x65, 0x66, 0x67, 0x68, 0x69, 0x6a, 0x73, 0x74, 0x75, 0x76, 0x77, 0x78, 0x79, 0x7a, 0x83, 0x84, 0x85, 0x86, 0x87, 0x88, 0x89, 0x8a, 0x92, 0x93, 0x94, 0x95, 0x96, 0x97, 0x98, 0x99, 0x9a, 0xa2, 0xa3, 0xa4, 0xa5, 0xa6, 0xa7, 0xa8, 0xa9, 0xaa, 0xb2, 0xb3, 0xb4, 0xb5, 0xb6, 0xb7, 0xb8, 0xb9, 0xba, 0xc2, 0xc3, 0xc4, 0xc5, 0xc6, 0xc7, 0xc8, 0xc9, 0xca, 0xd2, 0xd3, 0xd4, 0xd5, 0xd6, 0xd7, 0xd8, 0xd9, 0xda, 0xe1, 0xe2, 0xe3, 0xe4, 0xe5, 0xe6, 0xe7, 0xe8, 0xe9, 0xea, 0xf1, 0xf2, 0xf3, 0xf4, 0xf5, 0xf6, 0xf7, 0xf8, 0xf9, 0xfa];\n\n            var std_dc_chrominance_nrcodes = [0, 0, 3, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0];\n            var std_dc_chrominance_values = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11];\n            var std_ac_chrominance_nrcodes = [0, 0, 2, 1, 2, 4, 4, 3, 4, 7, 5, 4, 4, 0, 1, 2, 0x77];\n            var std_ac_chrominance_values = [0x00, 0x01, 0x02, 0x03, 0x11, 0x04, 0x05, 0x21, 0x31, 0x06, 0x12, 0x41, 0x51, 0x07, 0x61, 0x71, 0x13, 0x22, 0x32, 0x81, 0x08, 0x14, 0x42, 0x91, 0xa1, 0xb1, 0xc1, 0x09, 0x23, 0x33, 0x52, 0xf0, 0x15, 0x62, 0x72, 0xd1, 0x0a, 0x16, 0x24, 0x34, 0xe1, 0x25, 0xf1, 0x17, 0x18, 0x19, 0x1a, 0x26, 0x27, 0x28, 0x29, 0x2a, 0x35, 0x36, 0x37, 0x38, 0x39, 0x3a, 0x43, 0x44, 0x45, 0x46, 0x47, 0x48, 0x49, 0x4a, 0x53, 0x54, 0x55, 0x56, 0x57, 0x58, 0x59, 0x5a, 0x63, 0x64, 0x65, 0x66, 0x67, 0x68, 0x69, 0x6a, 0x73, 0x74, 0x75, 0x76, 0x77, 0x78, 0x79, 0x7a, 0x82, 0x83, 0x84, 0x85, 0x86, 0x87, 0x88, 0x89, 0x8a, 0x92, 0x93, 0x94, 0x95, 0x96, 0x97, 0x98, 0x99, 0x9a, 0xa2, 0xa3, 0xa4, 0xa5, 0xa6, 0xa7, 0xa8, 0xa9, 0xaa, 0xb2, 0xb3, 0xb4, 0xb5, 0xb6, 0xb7, 0xb8, 0xb9, 0xba, 0xc2, 0xc3, 0xc4, 0xc5, 0xc6, 0xc7, 0xc8, 0xc9, 0xca, 0xd2, 0xd3, 0xd4, 0xd5, 0xd6, 0xd7, 0xd8, 0xd9, 0xda, 0xe2, 0xe3, 0xe4, 0xe5, 0xe6, 0xe7, 0xe8, 0xe9, 0xea, 0xf2, 0xf3, 0xf4, 0xf5, 0xf6, 0xf7, 0xf8, 0xf9, 0xfa];\n\n            function initQuantTables(sf) {\n                var YQT = [16, 11, 10, 16, 24, 40, 51, 61, 12, 12, 14, 19, 26, 58, 60, 55, 14, 13, 16, 24, 40, 57, 69, 56, 14, 17, 22, 29, 51, 87, 80, 62, 18, 22, 37, 56, 68, 109, 103, 77, 24, 35, 55, 64, 81, 104, 113, 92, 49, 64, 78, 87, 103, 121, 120, 101, 72, 92, 95, 98, 112, 100, 103, 99];\n\n                for (var i = 0; i < 64; i++) {\n                    var t = ffloor((YQT[i] * sf + 50) / 100);\n                    if (t < 1) {\n                        t = 1;\n                    } else if (t > 255) {\n                        t = 255;\n                    }\n                    YTable[ZigZag[i]] = t;\n                }\n                var UVQT = [17, 18, 24, 47, 99, 99, 99, 99, 18, 21, 26, 66, 99, 99, 99, 99, 24, 26, 56, 99, 99, 99, 99, 99, 47, 66, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99];\n                for (var j = 0; j < 64; j++) {\n                    var u = ffloor((UVQT[j] * sf + 50) / 100);\n                    if (u < 1) {\n                        u = 1;\n                    } else if (u > 255) {\n                        u = 255;\n                    }\n                    UVTable[ZigZag[j]] = u;\n                }\n                var aasf = [1.0, 1.387039845, 1.306562965, 1.175875602, 1.0, 0.785694958, 0.541196100, 0.275899379];\n                var k = 0;\n                for (var row = 0; row < 8; row++) {\n                    for (var col = 0; col < 8; col++) {\n                        fdtbl_Y[k] = 1.0 / (YTable[ZigZag[k]] * aasf[row] * aasf[col] * 8.0);\n                        fdtbl_UV[k] = 1.0 / (UVTable[ZigZag[k]] * aasf[row] * aasf[col] * 8.0);\n                        k++;\n                    }\n                }\n            }\n\n            function computeHuffmanTbl(nrcodes, std_table) {\n                var codevalue = 0;\n                var pos_in_table = 0;\n                var HT = new Array();\n                for (var k = 1; k <= 16; k++) {\n                    for (var j = 1; j <= nrcodes[k]; j++) {\n                        HT[std_table[pos_in_table]] = [];\n                        HT[std_table[pos_in_table]][0] = codevalue;\n                        HT[std_table[pos_in_table]][1] = k;\n                        pos_in_table++;\n                        codevalue++;\n                    }\n                    codevalue *= 2;\n                }\n                return HT;\n            }\n\n            function initHuffmanTbl() {\n                YDC_HT = computeHuffmanTbl(std_dc_luminance_nrcodes, std_dc_luminance_values);\n                UVDC_HT = computeHuffmanTbl(std_dc_chrominance_nrcodes, std_dc_chrominance_values);\n                YAC_HT = computeHuffmanTbl(std_ac_luminance_nrcodes, std_ac_luminance_values);\n                UVAC_HT = computeHuffmanTbl(std_ac_chrominance_nrcodes, std_ac_chrominance_values);\n            }\n\n            function initCategoryNumber() {\n                var nrlower = 1;\n                var nrupper = 2;\n                for (var cat = 1; cat <= 15; cat++) {\n                    //Positive numbers\n                    for (var nr = nrlower; nr < nrupper; nr++) {\n                        category[32767 + nr] = cat;\n                        bitcode[32767 + nr] = [];\n                        bitcode[32767 + nr][1] = cat;\n                        bitcode[32767 + nr][0] = nr;\n                    }\n                    //Negative numbers\n                    for (var nrneg = -(nrupper - 1); nrneg <= -nrlower; nrneg++) {\n                        category[32767 + nrneg] = cat;\n                        bitcode[32767 + nrneg] = [];\n                        bitcode[32767 + nrneg][1] = cat;\n                        bitcode[32767 + nrneg][0] = nrupper - 1 + nrneg;\n                    }\n                    nrlower <<= 1;\n                    nrupper <<= 1;\n                }\n            }\n\n            function initRGBYUVTable() {\n                for (var i = 0; i < 256; i++) {\n                    RGB_YUV_TABLE[i] = 19595 * i;\n                    RGB_YUV_TABLE[i + 256 >> 0] = 38470 * i;\n                    RGB_YUV_TABLE[i + 512 >> 0] = 7471 * i + 0x8000;\n                    RGB_YUV_TABLE[i + 768 >> 0] = -11059 * i;\n                    RGB_YUV_TABLE[i + 1024 >> 0] = -21709 * i;\n                    RGB_YUV_TABLE[i + 1280 >> 0] = 32768 * i + 0x807FFF;\n                    RGB_YUV_TABLE[i + 1536 >> 0] = -27439 * i;\n                    RGB_YUV_TABLE[i + 1792 >> 0] = -5329 * i;\n                }\n            }\n\n            // IO functions\n            function writeBits(bs) {\n                var value = bs[0];\n                var posval = bs[1] - 1;\n                while (posval >= 0) {\n                    if (value & 1 << posval) {\n                        bytenew |= 1 << bytepos;\n                    }\n                    posval--;\n                    bytepos--;\n                    if (bytepos < 0) {\n                        if (bytenew == 0xFF) {\n                            writeByte(0xFF);\n                            writeByte(0);\n                        } else {\n                            writeByte(bytenew);\n                        }\n                        bytepos = 7;\n                        bytenew = 0;\n                    }\n                }\n            }\n\n            function writeByte(value) {\n                byteout.push(clt[value]); // write char directly instead of converting later\n            }\n\n            function writeWord(value) {\n                writeByte(value >> 8 & 0xFF);\n                writeByte(value & 0xFF);\n            }\n\n            // DCT & quantization core\n            function fDCTQuant(data, fdtbl) {\n                var d0, d1, d2, d3, d4, d5, d6, d7;\n                /* Pass 1: process rows. */\n                var dataOff = 0;\n                var i;\n                var I8 = 8;\n                var I64 = 64;\n                for (i = 0; i < I8; ++i) {\n                    d0 = data[dataOff];\n                    d1 = data[dataOff + 1];\n                    d2 = data[dataOff + 2];\n                    d3 = data[dataOff + 3];\n                    d4 = data[dataOff + 4];\n                    d5 = data[dataOff + 5];\n                    d6 = data[dataOff + 6];\n                    d7 = data[dataOff + 7];\n\n                    var tmp0 = d0 + d7;\n                    var tmp7 = d0 - d7;\n                    var tmp1 = d1 + d6;\n                    var tmp6 = d1 - d6;\n                    var tmp2 = d2 + d5;\n                    var tmp5 = d2 - d5;\n                    var tmp3 = d3 + d4;\n                    var tmp4 = d3 - d4;\n\n                    /* Even part */\n                    var tmp10 = tmp0 + tmp3; /* phase 2 */\n                    var tmp13 = tmp0 - tmp3;\n                    var tmp11 = tmp1 + tmp2;\n                    var tmp12 = tmp1 - tmp2;\n\n                    data[dataOff] = tmp10 + tmp11; /* phase 3 */\n                    data[dataOff + 4] = tmp10 - tmp11;\n\n                    var z1 = (tmp12 + tmp13) * 0.707106781; /* c4 */\n                    data[dataOff + 2] = tmp13 + z1; /* phase 5 */\n                    data[dataOff + 6] = tmp13 - z1;\n\n                    /* Odd part */\n                    tmp10 = tmp4 + tmp5; /* phase 2 */\n                    tmp11 = tmp5 + tmp6;\n                    tmp12 = tmp6 + tmp7;\n\n                    /* The rotator is modified from fig 4-8 to avoid extra negations. */\n                    var z5 = (tmp10 - tmp12) * 0.382683433; /* c6 */\n                    var z2 = 0.541196100 * tmp10 + z5; /* c2-c6 */\n                    var z4 = 1.306562965 * tmp12 + z5; /* c2+c6 */\n                    var z3 = tmp11 * 0.707106781; /* c4 */\n\n                    var z11 = tmp7 + z3; /* phase 5 */\n                    var z13 = tmp7 - z3;\n\n                    data[dataOff + 5] = z13 + z2; /* phase 6 */\n                    data[dataOff + 3] = z13 - z2;\n                    data[dataOff + 1] = z11 + z4;\n                    data[dataOff + 7] = z11 - z4;\n\n                    dataOff += 8; /* advance pointer to next row */\n                }\n\n                /* Pass 2: process columns. */\n                dataOff = 0;\n                for (i = 0; i < I8; ++i) {\n                    d0 = data[dataOff];\n                    d1 = data[dataOff + 8];\n                    d2 = data[dataOff + 16];\n                    d3 = data[dataOff + 24];\n                    d4 = data[dataOff + 32];\n                    d5 = data[dataOff + 40];\n                    d6 = data[dataOff + 48];\n                    d7 = data[dataOff + 56];\n\n                    var tmp0p2 = d0 + d7;\n                    var tmp7p2 = d0 - d7;\n                    var tmp1p2 = d1 + d6;\n                    var tmp6p2 = d1 - d6;\n                    var tmp2p2 = d2 + d5;\n                    var tmp5p2 = d2 - d5;\n                    var tmp3p2 = d3 + d4;\n                    var tmp4p2 = d3 - d4;\n\n                    /* Even part */\n                    var tmp10p2 = tmp0p2 + tmp3p2; /* phase 2 */\n                    var tmp13p2 = tmp0p2 - tmp3p2;\n                    var tmp11p2 = tmp1p2 + tmp2p2;\n                    var tmp12p2 = tmp1p2 - tmp2p2;\n\n                    data[dataOff] = tmp10p2 + tmp11p2; /* phase 3 */\n                    data[dataOff + 32] = tmp10p2 - tmp11p2;\n\n                    var z1p2 = (tmp12p2 + tmp13p2) * 0.707106781; /* c4 */\n                    data[dataOff + 16] = tmp13p2 + z1p2; /* phase 5 */\n                    data[dataOff + 48] = tmp13p2 - z1p2;\n\n                    /* Odd part */\n                    tmp10p2 = tmp4p2 + tmp5p2; /* phase 2 */\n                    tmp11p2 = tmp5p2 + tmp6p2;\n                    tmp12p2 = tmp6p2 + tmp7p2;\n\n                    /* The rotator is modified from fig 4-8 to avoid extra negations. */\n                    var z5p2 = (tmp10p2 - tmp12p2) * 0.382683433; /* c6 */\n                    var z2p2 = 0.541196100 * tmp10p2 + z5p2; /* c2-c6 */\n                    var z4p2 = 1.306562965 * tmp12p2 + z5p2; /* c2+c6 */\n                    var z3p2 = tmp11p2 * 0.707106781; /* c4 */\n\n                    var z11p2 = tmp7p2 + z3p2; /* phase 5 */\n                    var z13p2 = tmp7p2 - z3p2;\n\n                    data[dataOff + 40] = z13p2 + z2p2; /* phase 6 */\n                    data[dataOff + 24] = z13p2 - z2p2;\n                    data[dataOff + 8] = z11p2 + z4p2;\n                    data[dataOff + 56] = z11p2 - z4p2;\n\n                    dataOff++; /* advance pointer to next column */\n                }\n\n                // Quantize/descale the coefficients\n                var fDCTQuant;\n                for (i = 0; i < I64; ++i) {\n                    // Apply the quantization and scaling factor & Round to nearest integer\n                    fDCTQuant = data[i] * fdtbl[i];\n                    outputfDCTQuant[i] = fDCTQuant > 0.0 ? fDCTQuant + 0.5 | 0 : fDCTQuant - 0.5 | 0;\n                    //outputfDCTQuant[i] = fround(fDCTQuant);\n                }\n                return outputfDCTQuant;\n            }\n\n            function writeAPP0() {\n                writeWord(0xFFE0); // marker\n                writeWord(16); // length\n                writeByte(0x4A); // J\n                writeByte(0x46); // F\n                writeByte(0x49); // I\n                writeByte(0x46); // F\n                writeByte(0); // = \"JFIF\",'\\0'\n                writeByte(1); // versionhi\n                writeByte(1); // versionlo\n                writeByte(0); // xyunits\n                writeWord(1); // xdensity\n                writeWord(1); // ydensity\n                writeByte(0); // thumbnwidth\n                writeByte(0); // thumbnheight\n            }\n\n            function writeSOF0(width, height) {\n                writeWord(0xFFC0); // marker\n                writeWord(17); // length, truecolor YUV JPG\n                writeByte(8); // precision\n                writeWord(height);\n                writeWord(width);\n                writeByte(3); // nrofcomponents\n                writeByte(1); // IdY\n                writeByte(0x11); // HVY\n                writeByte(0); // QTY\n                writeByte(2); // IdU\n                writeByte(0x11); // HVU\n                writeByte(1); // QTU\n                writeByte(3); // IdV\n                writeByte(0x11); // HVV\n                writeByte(1); // QTV\n            }\n\n            function writeDQT() {\n                writeWord(0xFFDB); // marker\n                writeWord(132); // length\n                writeByte(0);\n                for (var i = 0; i < 64; i++) {\n                    writeByte(YTable[i]);\n                }\n                writeByte(1);\n                for (var j = 0; j < 64; j++) {\n                    writeByte(UVTable[j]);\n                }\n            }\n\n            function writeDHT() {\n                writeWord(0xFFC4); // marker\n                writeWord(0x01A2); // length\n\n                writeByte(0); // HTYDCinfo\n                for (var i = 0; i < 16; i++) {\n                    writeByte(std_dc_luminance_nrcodes[i + 1]);\n                }\n                for (var j = 0; j <= 11; j++) {\n                    writeByte(std_dc_luminance_values[j]);\n                }\n\n                writeByte(0x10); // HTYACinfo\n                for (var k = 0; k < 16; k++) {\n                    writeByte(std_ac_luminance_nrcodes[k + 1]);\n                }\n                for (var l = 0; l <= 161; l++) {\n                    writeByte(std_ac_luminance_values[l]);\n                }\n\n                writeByte(1); // HTUDCinfo\n                for (var m = 0; m < 16; m++) {\n                    writeByte(std_dc_chrominance_nrcodes[m + 1]);\n                }\n                for (var n = 0; n <= 11; n++) {\n                    writeByte(std_dc_chrominance_values[n]);\n                }\n\n                writeByte(0x11); // HTUACinfo\n                for (var o = 0; o < 16; o++) {\n                    writeByte(std_ac_chrominance_nrcodes[o + 1]);\n                }\n                for (var p = 0; p <= 161; p++) {\n                    writeByte(std_ac_chrominance_values[p]);\n                }\n            }\n\n            function writeSOS() {\n                writeWord(0xFFDA); // marker\n                writeWord(12); // length\n                writeByte(3); // nrofcomponents\n                writeByte(1); // IdY\n                writeByte(0); // HTY\n                writeByte(2); // IdU\n                writeByte(0x11); // HTU\n                writeByte(3); // IdV\n                writeByte(0x11); // HTV\n                writeByte(0); // Ss\n                writeByte(0x3f); // Se\n                writeByte(0); // Bf\n            }\n\n            function processDU(CDU, fdtbl, DC, HTDC, HTAC) {\n                var EOB = HTAC[0x00];\n                var M16zeroes = HTAC[0xF0];\n                var pos;\n                var I16 = 16;\n                var I63 = 63;\n                var I64 = 64;\n                var DU_DCT = fDCTQuant(CDU, fdtbl);\n                //ZigZag reorder\n                for (var j = 0; j < I64; ++j) {\n                    DU[ZigZag[j]] = DU_DCT[j];\n                }\n                var Diff = DU[0] - DC;DC = DU[0];\n                //Encode DC\n                if (Diff == 0) {\n                    writeBits(HTDC[0]); // Diff might be 0\n                } else {\n                    pos = 32767 + Diff;\n                    writeBits(HTDC[category[pos]]);\n                    writeBits(bitcode[pos]);\n                }\n                //Encode ACs\n                var end0pos = 63; // was const... which is crazy\n                for (; end0pos > 0 && DU[end0pos] == 0; end0pos--) {};\n                //end0pos = first element in reverse order !=0\n                if (end0pos == 0) {\n                    writeBits(EOB);\n                    return DC;\n                }\n                var i = 1;\n                var lng;\n                while (i <= end0pos) {\n                    var startpos = i;\n                    for (; DU[i] == 0 && i <= end0pos; ++i) {}\n                    var nrzeroes = i - startpos;\n                    if (nrzeroes >= I16) {\n                        lng = nrzeroes >> 4;\n                        for (var nrmarker = 1; nrmarker <= lng; ++nrmarker) {\n                            writeBits(M16zeroes);\n                        }nrzeroes = nrzeroes & 0xF;\n                    }\n                    pos = 32767 + DU[i];\n                    writeBits(HTAC[(nrzeroes << 4) + category[pos]]);\n                    writeBits(bitcode[pos]);\n                    i++;\n                }\n                if (end0pos != I63) {\n                    writeBits(EOB);\n                }\n                return DC;\n            }\n\n            function initCharLookupTable() {\n                var sfcc = String.fromCharCode;\n                for (var i = 0; i < 256; i++) {\n                    ///// ACHTUNG // 255\n                    clt[i] = sfcc(i);\n                }\n            }\n\n            this.encode = function (image, quality) // image data object\n            {\n                // var time_start = new Date().getTime();\n\n                if (quality) setQuality(quality);\n\n                // Initialize bit writer\n                byteout = new Array();\n                bytenew = 0;\n                bytepos = 7;\n\n                // Add JPEG headers\n                writeWord(0xFFD8); // SOI\n                writeAPP0();\n                writeDQT();\n                writeSOF0(image.width, image.height);\n                writeDHT();\n                writeSOS();\n\n                // Encode 8x8 macroblocks\n                var DCY = 0;\n                var DCU = 0;\n                var DCV = 0;\n\n                bytenew = 0;\n                bytepos = 7;\n\n                this.encode.displayName = \"_encode_\";\n\n                var imageData = image.data;\n                var width = image.width;\n                var height = image.height;\n\n                var quadWidth = width * 4;\n                var tripleWidth = width * 3;\n\n                var x,\n                    y = 0;\n                var r, g, b;\n                var start, p, col, row, pos;\n                while (y < height) {\n                    x = 0;\n                    while (x < quadWidth) {\n                        start = quadWidth * y + x;\n                        p = start;\n                        col = -1;\n                        row = 0;\n\n                        for (pos = 0; pos < 64; pos++) {\n                            row = pos >> 3; // /8\n                            col = (pos & 7) * 4; // %8\n                            p = start + row * quadWidth + col;\n\n                            if (y + row >= height) {\n                                // padding bottom\n                                p -= quadWidth * (y + 1 + row - height);\n                            }\n\n                            if (x + col >= quadWidth) {\n                                // padding right\n                                p -= x + col - quadWidth + 4;\n                            }\n\n                            r = imageData[p++];\n                            g = imageData[p++];\n                            b = imageData[p++];\n\n                            /* // calculate YUV values dynamically\n                            YDU[pos]=((( 0.29900)*r+( 0.58700)*g+( 0.11400)*b))-128; //-0x80\n                            UDU[pos]=(((-0.16874)*r+(-0.33126)*g+( 0.50000)*b));\n                            VDU[pos]=((( 0.50000)*r+(-0.41869)*g+(-0.08131)*b));\n                            */\n\n                            // use lookup table (slightly faster)\n                            YDU[pos] = (RGB_YUV_TABLE[r] + RGB_YUV_TABLE[g + 256 >> 0] + RGB_YUV_TABLE[b + 512 >> 0] >> 16) - 128;\n                            UDU[pos] = (RGB_YUV_TABLE[r + 768 >> 0] + RGB_YUV_TABLE[g + 1024 >> 0] + RGB_YUV_TABLE[b + 1280 >> 0] >> 16) - 128;\n                            VDU[pos] = (RGB_YUV_TABLE[r + 1280 >> 0] + RGB_YUV_TABLE[g + 1536 >> 0] + RGB_YUV_TABLE[b + 1792 >> 0] >> 16) - 128;\n                        }\n\n                        DCY = processDU(YDU, fdtbl_Y, DCY, YDC_HT, YAC_HT);\n                        DCU = processDU(UDU, fdtbl_UV, DCU, UVDC_HT, UVAC_HT);\n                        DCV = processDU(VDU, fdtbl_UV, DCV, UVDC_HT, UVAC_HT);\n                        x += 32;\n                    }\n                    y += 8;\n                }\n\n                ////////////////////////////////////////////////////////////////\n\n                // Do the bit alignment of the EOI marker\n                if (bytepos >= 0) {\n                    var fillbits = [];\n                    fillbits[1] = bytepos + 1;\n                    fillbits[0] = (1 << bytepos + 1) - 1;\n                    writeBits(fillbits);\n                }\n\n                writeWord(0xFFD9); //EOI\n\n                var jpegDataUri = 'data:image/jpeg;base64,' + btoa(byteout.join(''));\n\n                byteout = [];\n\n                // benchmarking\n                // var duration = new Date().getTime() - time_start;\n                // console.log('Encoding time: '+ currentQuality + 'ms');\n                //\n\n                return jpegDataUri;\n            };\n\n            function setQuality(quality) {\n                if (quality <= 0) {\n                    quality = 1;\n                }\n                if (quality > 100) {\n                    quality = 100;\n                }\n\n                if (currentQuality == quality) return; // don't recalc if unchanged\n\n                var sf = 0;\n                if (quality < 50) {\n                    sf = Math.floor(5000 / quality);\n                } else {\n                    sf = Math.floor(200 - quality * 2);\n                }\n\n                initQuantTables(sf);\n                currentQuality = quality;\n                // console.log('Quality set to: '+quality +'%');\n            }\n\n            function init() {\n                // var time_start = new Date().getTime();\n                if (!quality) quality = 50;\n                // Create tables\n                initCharLookupTable();\n                initHuffmanTbl();\n                initCategoryNumber();\n                initRGBYUVTable();\n\n                setQuality(quality);\n                // var duration = new Date().getTime() - time_start;\n                // console.log('Initialization '+ duration + 'ms');\n            }\n\n            init();\n        };\n\n        JPEGEncoder.encode = function (data, quality) {\n            var encoder = new JPEGEncoder(quality);\n\n            return encoder.encode(data);\n        };\n\n        return JPEGEncoder;\n    });\n    /**\n     * @fileOverview Fix android canvas.toDataUrl bug.\n     */\n    define('runtime/html5/androidpatch', ['runtime/html5/util', 'runtime/html5/jpegencoder', 'base'], function (Util, encoder, Base) {\n        var origin = Util.canvasToDataUrl,\n            supportJpeg;\n\n        Util.canvasToDataUrl = function (canvas, type, quality) {\n            var ctx, w, h, fragement, parts;\n\n            // 非android手机直接跳过。\n            if (!Base.os.android) {\n                return origin.apply(null, arguments);\n            }\n\n            // 检测是否canvas支持jpeg导出，根据数据格式来判断。\n            // JPEG 前两位分别是：255, 216\n            if (type === 'image/jpeg' && typeof supportJpeg === 'undefined') {\n                fragement = origin.apply(null, arguments);\n\n                parts = fragement.split(',');\n\n                if (~parts[0].indexOf('base64')) {\n                    fragement = atob(parts[1]);\n                } else {\n                    fragement = decodeURIComponent(parts[1]);\n                }\n\n                fragement = fragement.substring(0, 2);\n\n                supportJpeg = fragement.charCodeAt(0) === 255 && fragement.charCodeAt(1) === 216;\n            }\n\n            // 只有在android环境下才修复\n            if (type === 'image/jpeg' && !supportJpeg) {\n                w = canvas.width;\n                h = canvas.height;\n                ctx = canvas.getContext('2d');\n\n                return encoder.encode(ctx.getImageData(0, 0, w, h), quality);\n            }\n\n            return origin.apply(null, arguments);\n        };\n    });\n    /**\n     * @fileOverview Image\n     */\n    define('runtime/html5/image', ['base', 'runtime/html5/runtime', 'runtime/html5/util'], function (Base, Html5Runtime, Util) {\n\n        var BLANK = 'data:image/gif;base64,R0lGODlhAQABAAD/ACwAAAAAAQABAAACADs%3D';\n\n        return Html5Runtime.register('Image', {\n\n            // flag: 标记是否被修改过。\n            modified: false,\n\n            init: function init() {\n                var me = this,\n                    img = new Image();\n\n                img.onload = function () {\n\n                    me._info = {\n                        type: me.type,\n                        width: this.width,\n                        height: this.height\n                    };\n\n                    // 读取meta信息。\n                    if (!me._metas && 'image/jpeg' === me.type) {\n                        Util.parseMeta(me._blob, function (error, ret) {\n                            me._metas = ret;\n                            me.owner.trigger('load');\n                        });\n                    } else {\n                        me.owner.trigger('load');\n                    }\n                };\n\n                img.onerror = function () {\n                    me.owner.trigger('error');\n                };\n\n                me._img = img;\n            },\n\n            loadFromBlob: function loadFromBlob(blob) {\n                var me = this,\n                    img = me._img;\n\n                me._blob = blob;\n                me.type = blob.type;\n                img.src = Util.createObjectURL(blob.getSource());\n                me.owner.once('load', function () {\n                    Util.revokeObjectURL(img.src);\n                });\n            },\n\n            resize: function resize(width, height) {\n                var canvas = this._canvas || (this._canvas = document.createElement('canvas'));\n\n                this._resize(this._img, canvas, width, height);\n                this._blob = null; // 没用了，可以删掉了。\n                this.modified = true;\n                this.owner.trigger('complete', 'resize');\n            },\n\n            crop: function crop(x, y, w, h, s) {\n                var cvs = this._canvas || (this._canvas = document.createElement('canvas')),\n                    opts = this.options,\n                    img = this._img,\n                    iw = img.naturalWidth,\n                    ih = img.naturalHeight,\n                    orientation = this.getOrientation();\n\n                s = s || 1;\n\n                // todo 解决 orientation 的问题。\n                // values that require 90 degree rotation\n                // if ( ~[ 5, 6, 7, 8 ].indexOf( orientation ) ) {\n\n                //     switch ( orientation ) {\n                //         case 6:\n                //             tmp = x;\n                //             x = y;\n                //             y = iw * s - tmp - w;\n                //             console.log(ih * s, tmp, w)\n                //             break;\n                //     }\n\n                //     (w ^= h, h ^= w, w ^= h);\n                // }\n\n                cvs.width = w;\n                cvs.height = h;\n\n                opts.preserveHeaders || this._rotate2Orientaion(cvs, orientation);\n                this._renderImageToCanvas(cvs, img, -x, -y, iw * s, ih * s);\n\n                this._blob = null; // 没用了，可以删掉了。\n                this.modified = true;\n                this.owner.trigger('complete', 'crop');\n            },\n\n            getAsBlob: function getAsBlob(type) {\n                var blob = this._blob,\n                    opts = this.options,\n                    canvas;\n\n                type = type || this.type;\n\n                // blob需要重新生成。\n                if (this.modified || this.type !== type) {\n                    canvas = this._canvas;\n\n                    if (type === 'image/jpeg') {\n\n                        blob = Util.canvasToDataUrl(canvas, type, opts.quality);\n\n                        if (opts.preserveHeaders && this._metas && this._metas.imageHead) {\n\n                            blob = Util.dataURL2ArrayBuffer(blob);\n                            blob = Util.updateImageHead(blob, this._metas.imageHead);\n                            blob = Util.arrayBufferToBlob(blob, type);\n                            return blob;\n                        }\n                    } else {\n                        blob = Util.canvasToDataUrl(canvas, type);\n                    }\n\n                    blob = Util.dataURL2Blob(blob);\n                }\n\n                return blob;\n            },\n\n            getAsDataUrl: function getAsDataUrl(type) {\n                var opts = this.options;\n\n                type = type || this.type;\n\n                if (type === 'image/jpeg') {\n                    return Util.canvasToDataUrl(this._canvas, type, opts.quality);\n                } else {\n                    return this._canvas.toDataURL(type);\n                }\n            },\n\n            getOrientation: function getOrientation() {\n                return this._metas && this._metas.exif && this._metas.exif.get('Orientation') || 1;\n            },\n\n            info: function info(val) {\n\n                // setter\n                if (val) {\n                    this._info = val;\n                    return this;\n                }\n\n                // getter\n                return this._info;\n            },\n\n            meta: function meta(val) {\n\n                // setter\n                if (val) {\n                    this._meta = val;\n                    return this;\n                }\n\n                // getter\n                return this._meta;\n            },\n\n            destroy: function destroy() {\n                var canvas = this._canvas;\n                this._img.onload = null;\n\n                if (canvas) {\n                    canvas.getContext('2d').clearRect(0, 0, canvas.width, canvas.height);\n                    canvas.width = canvas.height = 0;\n                    this._canvas = null;\n                }\n\n                // 释放内存。非常重要，否则释放不了image的内存。\n                this._img.src = BLANK;\n                this._img = this._blob = null;\n            },\n\n            _resize: function _resize(img, cvs, width, height) {\n                var opts = this.options,\n                    naturalWidth = img.width,\n                    naturalHeight = img.height,\n                    orientation = this.getOrientation(),\n                    scale,\n                    w,\n                    h,\n                    x,\n                    y;\n\n                // values that require 90 degree rotation\n                if (~[5, 6, 7, 8].indexOf(orientation)) {\n\n                    // 交换width, height的值。\n                    width ^= height;\n                    height ^= width;\n                    width ^= height;\n                }\n\n                scale = Math[opts.crop ? 'max' : 'min'](width / naturalWidth, height / naturalHeight);\n\n                // 不允许放大。\n                opts.allowMagnify || (scale = Math.min(1, scale));\n\n                w = naturalWidth * scale;\n                h = naturalHeight * scale;\n\n                if (opts.crop) {\n                    cvs.width = width;\n                    cvs.height = height;\n                } else {\n                    cvs.width = w;\n                    cvs.height = h;\n                }\n\n                x = (cvs.width - w) / 2;\n                y = (cvs.height - h) / 2;\n\n                opts.preserveHeaders || this._rotate2Orientaion(cvs, orientation);\n\n                this._renderImageToCanvas(cvs, img, x, y, w, h);\n            },\n\n            _rotate2Orientaion: function _rotate2Orientaion(canvas, orientation) {\n                var width = canvas.width,\n                    height = canvas.height,\n                    ctx = canvas.getContext('2d');\n\n                switch (orientation) {\n                    case 5:\n                    case 6:\n                    case 7:\n                    case 8:\n                        canvas.width = height;\n                        canvas.height = width;\n                        break;\n                }\n\n                switch (orientation) {\n                    case 2:\n                        // horizontal flip\n                        ctx.translate(width, 0);\n                        ctx.scale(-1, 1);\n                        break;\n\n                    case 3:\n                        // 180 rotate left\n                        ctx.translate(width, height);\n                        ctx.rotate(Math.PI);\n                        break;\n\n                    case 4:\n                        // vertical flip\n                        ctx.translate(0, height);\n                        ctx.scale(1, -1);\n                        break;\n\n                    case 5:\n                        // vertical flip + 90 rotate right\n                        ctx.rotate(0.5 * Math.PI);\n                        ctx.scale(1, -1);\n                        break;\n\n                    case 6:\n                        // 90 rotate right\n                        ctx.rotate(0.5 * Math.PI);\n                        ctx.translate(0, -height);\n                        break;\n\n                    case 7:\n                        // horizontal flip + 90 rotate right\n                        ctx.rotate(0.5 * Math.PI);\n                        ctx.translate(width, -height);\n                        ctx.scale(-1, 1);\n                        break;\n\n                    case 8:\n                        // 90 rotate left\n                        ctx.rotate(-0.5 * Math.PI);\n                        ctx.translate(-width, 0);\n                        break;\n                }\n            },\n\n            // https://github.com/stomita/ios-imagefile-megapixel/\n            // blob/master/src/megapix-image.js\n            _renderImageToCanvas: function () {\n\n                // 如果不是ios, 不需要这么复杂！\n                if (!Base.os.ios) {\n                    return function (canvas) {\n                        var args = Base.slice(arguments, 1),\n                            ctx = canvas.getContext('2d');\n\n                        ctx.drawImage.apply(ctx, args);\n                    };\n                }\n\n                /**\n                 * Detecting vertical squash in loaded image.\n                 * Fixes a bug which squash image vertically while drawing into\n                 * canvas for some images.\n                 */\n                function detectVerticalSquash(img, iw, ih) {\n                    var canvas = document.createElement('canvas'),\n                        ctx = canvas.getContext('2d'),\n                        sy = 0,\n                        ey = ih,\n                        py = ih,\n                        data,\n                        alpha,\n                        ratio;\n\n                    canvas.width = 1;\n                    canvas.height = ih;\n                    ctx.drawImage(img, 0, 0);\n                    data = ctx.getImageData(0, 0, 1, ih).data;\n\n                    // search image edge pixel position in case\n                    // it is squashed vertically.\n                    while (py > sy) {\n                        alpha = data[(py - 1) * 4 + 3];\n\n                        if (alpha === 0) {\n                            ey = py;\n                        } else {\n                            sy = py;\n                        }\n\n                        py = ey + sy >> 1;\n                    }\n\n                    ratio = py / ih;\n                    return ratio === 0 ? 1 : ratio;\n                }\n\n                // fix ie7 bug\n                // http://stackoverflow.com/questions/11929099/\n                // html5-canvas-drawimage-ratio-bug-ios\n                if (Base.os.ios >= 7) {\n                    return function (canvas, img, x, y, w, h) {\n                        var iw = img.naturalWidth,\n                            ih = img.naturalHeight,\n                            vertSquashRatio = detectVerticalSquash(img, iw, ih);\n\n                        return canvas.getContext('2d').drawImage(img, 0, 0, iw * vertSquashRatio, ih * vertSquashRatio, x, y, w, h);\n                    };\n                }\n\n                /**\n                 * Detect subsampling in loaded image.\n                 * In iOS, larger images than 2M pixels may be\n                 * subsampled in rendering.\n                 */\n                function detectSubsampling(img) {\n                    var iw = img.naturalWidth,\n                        ih = img.naturalHeight,\n                        canvas,\n                        ctx;\n\n                    // subsampling may happen overmegapixel image\n                    if (iw * ih > 1024 * 1024) {\n                        canvas = document.createElement('canvas');\n                        canvas.width = canvas.height = 1;\n                        ctx = canvas.getContext('2d');\n                        ctx.drawImage(img, -iw + 1, 0);\n\n                        // subsampled image becomes half smaller in rendering size.\n                        // check alpha channel value to confirm image is covering\n                        // edge pixel or not. if alpha value is 0\n                        // image is not covering, hence subsampled.\n                        return ctx.getImageData(0, 0, 1, 1).data[3] === 0;\n                    } else {\n                        return false;\n                    }\n                }\n\n                return function (canvas, img, x, y, width, height) {\n                    var iw = img.naturalWidth,\n                        ih = img.naturalHeight,\n                        ctx = canvas.getContext('2d'),\n                        subsampled = detectSubsampling(img),\n                        doSquash = this.type === 'image/jpeg',\n                        d = 1024,\n                        sy = 0,\n                        dy = 0,\n                        tmpCanvas,\n                        tmpCtx,\n                        vertSquashRatio,\n                        dw,\n                        dh,\n                        sx,\n                        dx;\n\n                    if (subsampled) {\n                        iw /= 2;\n                        ih /= 2;\n                    }\n\n                    ctx.save();\n                    tmpCanvas = document.createElement('canvas');\n                    tmpCanvas.width = tmpCanvas.height = d;\n\n                    tmpCtx = tmpCanvas.getContext('2d');\n                    vertSquashRatio = doSquash ? detectVerticalSquash(img, iw, ih) : 1;\n\n                    dw = Math.ceil(d * width / iw);\n                    dh = Math.ceil(d * height / ih / vertSquashRatio);\n\n                    while (sy < ih) {\n                        sx = 0;\n                        dx = 0;\n                        while (sx < iw) {\n                            tmpCtx.clearRect(0, 0, d, d);\n                            tmpCtx.drawImage(img, -sx, -sy);\n                            ctx.drawImage(tmpCanvas, 0, 0, d, d, x + dx, y + dy, dw, dh);\n                            sx += d;\n                            dx += dw;\n                        }\n                        sy += d;\n                        dy += dh;\n                    }\n                    ctx.restore();\n                    tmpCanvas = tmpCtx = null;\n                };\n            }()\n        });\n    });\n    /**\n     * @fileOverview Transport\n     * @todo 支持chunked传输，优势：\n     * 可以将大文件分成小块，挨个传输，可以提高大文件成功率，当失败的时候，也只需要重传那小部分，\n     * 而不需要重头再传一次。另外断点续传也需要用chunked方式。\n     */\n    define('runtime/html5/transport', ['base', 'runtime/html5/runtime'], function (Base, Html5Runtime) {\n\n        var noop = Base.noop,\n            $ = Base.$;\n\n        return Html5Runtime.register('Transport', {\n            init: function init() {\n                this._status = 0;\n                this._response = null;\n            },\n\n            send: function send() {\n                var owner = this.owner,\n                    opts = this.options,\n                    xhr = this._initAjax(),\n                    blob = owner._blob,\n                    server = opts.server,\n                    formData,\n                    binary,\n                    fr;\n\n                if (opts.sendAsBinary) {\n                    server += (/\\?/.test(server) ? '&' : '?') + $.param(owner._formData);\n\n                    binary = blob.getSource();\n                } else {\n                    formData = new FormData();\n                    $.each(owner._formData, function (k, v) {\n                        formData.append(k, v);\n                    });\n\n                    formData.append(opts.fileVal, blob.getSource(), opts.filename || owner._formData.name || '');\n                }\n\n                if (opts.withCredentials && 'withCredentials' in xhr) {\n                    xhr.open(opts.method, server, true);\n                    xhr.withCredentials = true;\n                } else {\n                    xhr.open(opts.method, server);\n                }\n\n                this._setRequestHeader(xhr, opts.headers);\n\n                if (binary) {\n                    // 强制设置成 content-type 为文件流。\n                    xhr.overrideMimeType && xhr.overrideMimeType('application/octet-stream');\n\n                    // android直接发送blob会导致服务端接收到的是空文件。\n                    // bug详情。\n                    // https://code.google.com/p/android/issues/detail?id=39882\n                    // 所以先用fileReader读取出来再通过arraybuffer的方式发送。\n                    if (Base.os.android) {\n                        fr = new FileReader();\n\n                        fr.onload = function () {\n                            xhr.send(this.result);\n                            fr = fr.onload = null;\n                        };\n\n                        fr.readAsArrayBuffer(binary);\n                    } else {\n                        xhr.send(binary);\n                    }\n                } else {\n                    xhr.send(formData);\n                }\n            },\n\n            getResponse: function getResponse() {\n                return this._response;\n            },\n\n            getResponseAsJson: function getResponseAsJson() {\n                return this._parseJson(this._response);\n            },\n\n            getStatus: function getStatus() {\n                return this._status;\n            },\n\n            abort: function abort() {\n                var xhr = this._xhr;\n\n                if (xhr) {\n                    xhr.upload.onprogress = noop;\n                    xhr.onreadystatechange = noop;\n                    xhr.abort();\n\n                    this._xhr = xhr = null;\n                }\n            },\n\n            destroy: function destroy() {\n                this.abort();\n            },\n\n            _initAjax: function _initAjax() {\n                var me = this,\n                    xhr = new XMLHttpRequest(),\n                    opts = this.options;\n\n                if (opts.withCredentials && !('withCredentials' in xhr) && typeof XDomainRequest !== 'undefined') {\n                    xhr = new XDomainRequest();\n                }\n\n                xhr.upload.onprogress = function (e) {\n                    var percentage = 0;\n\n                    if (e.lengthComputable) {\n                        percentage = e.loaded / e.total;\n                    }\n\n                    return me.trigger('progress', percentage);\n                };\n\n                xhr.onreadystatechange = function () {\n\n                    if (xhr.readyState !== 4) {\n                        return;\n                    }\n\n                    xhr.upload.onprogress = noop;\n                    xhr.onreadystatechange = noop;\n                    me._xhr = null;\n                    me._status = xhr.status;\n\n                    if (xhr.status >= 200 && xhr.status < 300) {\n                        me._response = xhr.responseText;\n                        return me.trigger('load');\n                    } else if (xhr.status >= 500 && xhr.status < 600) {\n                        me._response = xhr.responseText;\n                        return me.trigger('error', 'server');\n                    }\n\n                    return me.trigger('error', me._status ? 'http' : 'abort');\n                };\n\n                me._xhr = xhr;\n                return xhr;\n            },\n\n            _setRequestHeader: function _setRequestHeader(xhr, headers) {\n                $.each(headers, function (key, val) {\n                    xhr.setRequestHeader(key, val);\n                });\n            },\n\n            _parseJson: function _parseJson(str) {\n                var json;\n\n                try {\n                    json = JSON.parse(str);\n                } catch (ex) {\n                    json = {};\n                }\n\n                return json;\n            }\n        });\n    });\n    /**\n     * @fileOverview  Transport flash实现\n     */\n    define('runtime/html5/md5', ['runtime/html5/runtime'], function (FlashRuntime) {\n\n        /*\n         * Fastest md5 implementation around (JKM md5)\n         * Credits: Joseph Myers\n         *\n         * @see http://www.myersdaily.org/joseph/javascript/md5-text.html\n         * @see http://jsperf.com/md5-shootout/7\n         */\n\n        /* this function is much faster,\n          so if possible we use it. Some IEs\n          are the only ones I know of that\n          need the idiotic second function,\n          generated by an if clause.  */\n        var add32 = function add32(a, b) {\n            return a + b & 0xFFFFFFFF;\n        },\n            cmn = function cmn(q, a, b, x, s, t) {\n            a = add32(add32(a, q), add32(x, t));\n            return add32(a << s | a >>> 32 - s, b);\n        },\n            ff = function ff(a, b, c, d, x, s, t) {\n            return cmn(b & c | ~b & d, a, b, x, s, t);\n        },\n            gg = function gg(a, b, c, d, x, s, t) {\n            return cmn(b & d | c & ~d, a, b, x, s, t);\n        },\n            hh = function hh(a, b, c, d, x, s, t) {\n            return cmn(b ^ c ^ d, a, b, x, s, t);\n        },\n            ii = function ii(a, b, c, d, x, s, t) {\n            return cmn(c ^ (b | ~d), a, b, x, s, t);\n        },\n            md5cycle = function md5cycle(x, k) {\n            var a = x[0],\n                b = x[1],\n                c = x[2],\n                d = x[3];\n\n            a = ff(a, b, c, d, k[0], 7, -680876936);\n            d = ff(d, a, b, c, k[1], 12, -389564586);\n            c = ff(c, d, a, b, k[2], 17, 606105819);\n            b = ff(b, c, d, a, k[3], 22, -1044525330);\n            a = ff(a, b, c, d, k[4], 7, -176418897);\n            d = ff(d, a, b, c, k[5], 12, 1200080426);\n            c = ff(c, d, a, b, k[6], 17, -1473231341);\n            b = ff(b, c, d, a, k[7], 22, -45705983);\n            a = ff(a, b, c, d, k[8], 7, 1770035416);\n            d = ff(d, a, b, c, k[9], 12, -1958414417);\n            c = ff(c, d, a, b, k[10], 17, -42063);\n            b = ff(b, c, d, a, k[11], 22, -1990404162);\n            a = ff(a, b, c, d, k[12], 7, 1804603682);\n            d = ff(d, a, b, c, k[13], 12, -40341101);\n            c = ff(c, d, a, b, k[14], 17, -1502002290);\n            b = ff(b, c, d, a, k[15], 22, 1236535329);\n\n            a = gg(a, b, c, d, k[1], 5, -165796510);\n            d = gg(d, a, b, c, k[6], 9, -1069501632);\n            c = gg(c, d, a, b, k[11], 14, 643717713);\n            b = gg(b, c, d, a, k[0], 20, -373897302);\n            a = gg(a, b, c, d, k[5], 5, -701558691);\n            d = gg(d, a, b, c, k[10], 9, 38016083);\n            c = gg(c, d, a, b, k[15], 14, -660478335);\n            b = gg(b, c, d, a, k[4], 20, -405537848);\n            a = gg(a, b, c, d, k[9], 5, 568446438);\n            d = gg(d, a, b, c, k[14], 9, -1019803690);\n            c = gg(c, d, a, b, k[3], 14, -187363961);\n            b = gg(b, c, d, a, k[8], 20, 1163531501);\n            a = gg(a, b, c, d, k[13], 5, -1444681467);\n            d = gg(d, a, b, c, k[2], 9, -51403784);\n            c = gg(c, d, a, b, k[7], 14, 1735328473);\n            b = gg(b, c, d, a, k[12], 20, -1926607734);\n\n            a = hh(a, b, c, d, k[5], 4, -378558);\n            d = hh(d, a, b, c, k[8], 11, -2022574463);\n            c = hh(c, d, a, b, k[11], 16, 1839030562);\n            b = hh(b, c, d, a, k[14], 23, -35309556);\n            a = hh(a, b, c, d, k[1], 4, -1530992060);\n            d = hh(d, a, b, c, k[4], 11, 1272893353);\n            c = hh(c, d, a, b, k[7], 16, -155497632);\n            b = hh(b, c, d, a, k[10], 23, -1094730640);\n            a = hh(a, b, c, d, k[13], 4, 681279174);\n            d = hh(d, a, b, c, k[0], 11, -358537222);\n            c = hh(c, d, a, b, k[3], 16, -722521979);\n            b = hh(b, c, d, a, k[6], 23, 76029189);\n            a = hh(a, b, c, d, k[9], 4, -640364487);\n            d = hh(d, a, b, c, k[12], 11, -421815835);\n            c = hh(c, d, a, b, k[15], 16, 530742520);\n            b = hh(b, c, d, a, k[2], 23, -995338651);\n\n            a = ii(a, b, c, d, k[0], 6, -198630844);\n            d = ii(d, a, b, c, k[7], 10, 1126891415);\n            c = ii(c, d, a, b, k[14], 15, -1416354905);\n            b = ii(b, c, d, a, k[5], 21, -57434055);\n            a = ii(a, b, c, d, k[12], 6, 1700485571);\n            d = ii(d, a, b, c, k[3], 10, -1894986606);\n            c = ii(c, d, a, b, k[10], 15, -1051523);\n            b = ii(b, c, d, a, k[1], 21, -2054922799);\n            a = ii(a, b, c, d, k[8], 6, 1873313359);\n            d = ii(d, a, b, c, k[15], 10, -30611744);\n            c = ii(c, d, a, b, k[6], 15, -1560198380);\n            b = ii(b, c, d, a, k[13], 21, 1309151649);\n            a = ii(a, b, c, d, k[4], 6, -145523070);\n            d = ii(d, a, b, c, k[11], 10, -1120210379);\n            c = ii(c, d, a, b, k[2], 15, 718787259);\n            b = ii(b, c, d, a, k[9], 21, -343485551);\n\n            x[0] = add32(a, x[0]);\n            x[1] = add32(b, x[1]);\n            x[2] = add32(c, x[2]);\n            x[3] = add32(d, x[3]);\n        },\n\n\n        /* there needs to be support for Unicode here,\n           * unless we pretend that we can redefine the MD-5\n           * algorithm for multi-byte characters (perhaps\n           * by adding every four 16-bit characters and\n           * shortening the sum to 32 bits). Otherwise\n           * I suggest performing MD-5 as if every character\n           * was two bytes--e.g., 0040 0025 = @%--but then\n           * how will an ordinary MD-5 sum be matched?\n           * There is no way to standardize text to something\n           * like UTF-8 before transformation; speed cost is\n           * utterly prohibitive. The JavaScript standard\n           * itself needs to look at this: it should start\n           * providing access to strings as preformed UTF-8\n           * 8-bit unsigned value arrays.\n           */\n        md5blk = function md5blk(s) {\n            var md5blks = [],\n                i; /* Andy King said do it this way. */\n\n            for (i = 0; i < 64; i += 4) {\n                md5blks[i >> 2] = s.charCodeAt(i) + (s.charCodeAt(i + 1) << 8) + (s.charCodeAt(i + 2) << 16) + (s.charCodeAt(i + 3) << 24);\n            }\n            return md5blks;\n        },\n            md5blk_array = function md5blk_array(a) {\n            var md5blks = [],\n                i; /* Andy King said do it this way. */\n\n            for (i = 0; i < 64; i += 4) {\n                md5blks[i >> 2] = a[i] + (a[i + 1] << 8) + (a[i + 2] << 16) + (a[i + 3] << 24);\n            }\n            return md5blks;\n        },\n            md51 = function md51(s) {\n            var n = s.length,\n                state = [1732584193, -271733879, -1732584194, 271733878],\n                i,\n                length,\n                tail,\n                tmp,\n                lo,\n                hi;\n\n            for (i = 64; i <= n; i += 64) {\n                md5cycle(state, md5blk(s.substring(i - 64, i)));\n            }\n            s = s.substring(i - 64);\n            length = s.length;\n            tail = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];\n            for (i = 0; i < length; i += 1) {\n                tail[i >> 2] |= s.charCodeAt(i) << (i % 4 << 3);\n            }\n            tail[i >> 2] |= 0x80 << (i % 4 << 3);\n            if (i > 55) {\n                md5cycle(state, tail);\n                for (i = 0; i < 16; i += 1) {\n                    tail[i] = 0;\n                }\n            }\n\n            // Beware that the final length might not fit in 32 bits so we take care of that\n            tmp = n * 8;\n            tmp = tmp.toString(16).match(/(.*?)(.{0,8})$/);\n            lo = parseInt(tmp[2], 16);\n            hi = parseInt(tmp[1], 16) || 0;\n\n            tail[14] = lo;\n            tail[15] = hi;\n\n            md5cycle(state, tail);\n            return state;\n        },\n            md51_array = function md51_array(a) {\n            var n = a.length,\n                state = [1732584193, -271733879, -1732584194, 271733878],\n                i,\n                length,\n                tail,\n                tmp,\n                lo,\n                hi;\n\n            for (i = 64; i <= n; i += 64) {\n                md5cycle(state, md5blk_array(a.subarray(i - 64, i)));\n            }\n\n            // Not sure if it is a bug, however IE10 will always produce a sub array of length 1\n            // containing the last element of the parent array if the sub array specified starts\n            // beyond the length of the parent array - weird.\n            // https://connect.microsoft.com/IE/feedback/details/771452/typed-array-subarray-issue\n            a = i - 64 < n ? a.subarray(i - 64) : new Uint8Array(0);\n\n            length = a.length;\n            tail = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];\n            for (i = 0; i < length; i += 1) {\n                tail[i >> 2] |= a[i] << (i % 4 << 3);\n            }\n\n            tail[i >> 2] |= 0x80 << (i % 4 << 3);\n            if (i > 55) {\n                md5cycle(state, tail);\n                for (i = 0; i < 16; i += 1) {\n                    tail[i] = 0;\n                }\n            }\n\n            // Beware that the final length might not fit in 32 bits so we take care of that\n            tmp = n * 8;\n            tmp = tmp.toString(16).match(/(.*?)(.{0,8})$/);\n            lo = parseInt(tmp[2], 16);\n            hi = parseInt(tmp[1], 16) || 0;\n\n            tail[14] = lo;\n            tail[15] = hi;\n\n            md5cycle(state, tail);\n\n            return state;\n        },\n            hex_chr = ['0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'a', 'b', 'c', 'd', 'e', 'f'],\n            rhex = function rhex(n) {\n            var s = '',\n                j;\n            for (j = 0; j < 4; j += 1) {\n                s += hex_chr[n >> j * 8 + 4 & 0x0F] + hex_chr[n >> j * 8 & 0x0F];\n            }\n            return s;\n        },\n            hex = function hex(x) {\n            var i;\n            for (i = 0; i < x.length; i += 1) {\n                x[i] = rhex(x[i]);\n            }\n            return x.join('');\n        },\n            md5 = function md5(s) {\n            return hex(md51(s));\n        },\n\n\n        ////////////////////////////////////////////////////////////////////////////\n\n        /**\n         * SparkMD5 OOP implementation.\n         *\n         * Use this class to perform an incremental md5, otherwise use the\n         * static methods instead.\n         */\n        SparkMD5 = function SparkMD5() {\n            // call reset to init the instance\n            this.reset();\n        };\n\n        // In some cases the fast add32 function cannot be used..\n        if (md5('hello') !== '5d41402abc4b2a76b9719d911017c592') {\n            add32 = function add32(x, y) {\n                var lsw = (x & 0xFFFF) + (y & 0xFFFF),\n                    msw = (x >> 16) + (y >> 16) + (lsw >> 16);\n                return msw << 16 | lsw & 0xFFFF;\n            };\n        }\n\n        /**\n         * Appends a string.\n         * A conversion will be applied if an utf8 string is detected.\n         *\n         * @param {String} str The string to be appended\n         *\n         * @return {SparkMD5} The instance itself\n         */\n        SparkMD5.prototype.append = function (str) {\n            // converts the string to utf8 bytes if necessary\n            if (/[\\u0080-\\uFFFF]/.test(str)) {\n                str = unescape(encodeURIComponent(str));\n            }\n\n            // then append as binary\n            this.appendBinary(str);\n\n            return this;\n        };\n\n        /**\n         * Appends a binary string.\n         *\n         * @param {String} contents The binary string to be appended\n         *\n         * @return {SparkMD5} The instance itself\n         */\n        SparkMD5.prototype.appendBinary = function (contents) {\n            this._buff += contents;\n            this._length += contents.length;\n\n            var length = this._buff.length,\n                i;\n\n            for (i = 64; i <= length; i += 64) {\n                md5cycle(this._state, md5blk(this._buff.substring(i - 64, i)));\n            }\n\n            this._buff = this._buff.substr(i - 64);\n\n            return this;\n        };\n\n        /**\n         * Finishes the incremental computation, reseting the internal state and\n         * returning the result.\n         * Use the raw parameter to obtain the raw result instead of the hex one.\n         *\n         * @param {Boolean} raw True to get the raw result, false to get the hex result\n         *\n         * @return {String|Array} The result\n         */\n        SparkMD5.prototype.end = function (raw) {\n            var buff = this._buff,\n                length = buff.length,\n                i,\n                tail = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n                ret;\n\n            for (i = 0; i < length; i += 1) {\n                tail[i >> 2] |= buff.charCodeAt(i) << (i % 4 << 3);\n            }\n\n            this._finish(tail, length);\n            ret = !!raw ? this._state : hex(this._state);\n\n            this.reset();\n\n            return ret;\n        };\n\n        /**\n         * Finish the final calculation based on the tail.\n         *\n         * @param {Array}  tail   The tail (will be modified)\n         * @param {Number} length The length of the remaining buffer\n         */\n        SparkMD5.prototype._finish = function (tail, length) {\n            var i = length,\n                tmp,\n                lo,\n                hi;\n\n            tail[i >> 2] |= 0x80 << (i % 4 << 3);\n            if (i > 55) {\n                md5cycle(this._state, tail);\n                for (i = 0; i < 16; i += 1) {\n                    tail[i] = 0;\n                }\n            }\n\n            // Do the final computation based on the tail and length\n            // Beware that the final length may not fit in 32 bits so we take care of that\n            tmp = this._length * 8;\n            tmp = tmp.toString(16).match(/(.*?)(.{0,8})$/);\n            lo = parseInt(tmp[2], 16);\n            hi = parseInt(tmp[1], 16) || 0;\n\n            tail[14] = lo;\n            tail[15] = hi;\n            md5cycle(this._state, tail);\n        };\n\n        /**\n         * Resets the internal state of the computation.\n         *\n         * @return {SparkMD5} The instance itself\n         */\n        SparkMD5.prototype.reset = function () {\n            this._buff = \"\";\n            this._length = 0;\n            this._state = [1732584193, -271733879, -1732584194, 271733878];\n\n            return this;\n        };\n\n        /**\n         * Releases memory used by the incremental buffer and other aditional\n         * resources. If you plan to use the instance again, use reset instead.\n         */\n        SparkMD5.prototype.destroy = function () {\n            delete this._state;\n            delete this._buff;\n            delete this._length;\n        };\n\n        /**\n         * Performs the md5 hash on a string.\n         * A conversion will be applied if utf8 string is detected.\n         *\n         * @param {String}  str The string\n         * @param {Boolean} raw True to get the raw result, false to get the hex result\n         *\n         * @return {String|Array} The result\n         */\n        SparkMD5.hash = function (str, raw) {\n            // converts the string to utf8 bytes if necessary\n            if (/[\\u0080-\\uFFFF]/.test(str)) {\n                str = unescape(encodeURIComponent(str));\n            }\n\n            var hash = md51(str);\n\n            return !!raw ? hash : hex(hash);\n        };\n\n        /**\n         * Performs the md5 hash on a binary string.\n         *\n         * @param {String}  content The binary string\n         * @param {Boolean} raw     True to get the raw result, false to get the hex result\n         *\n         * @return {String|Array} The result\n         */\n        SparkMD5.hashBinary = function (content, raw) {\n            var hash = md51(content);\n\n            return !!raw ? hash : hex(hash);\n        };\n\n        /**\n         * SparkMD5 OOP implementation for array buffers.\n         *\n         * Use this class to perform an incremental md5 ONLY for array buffers.\n         */\n        SparkMD5.ArrayBuffer = function () {\n            // call reset to init the instance\n            this.reset();\n        };\n\n        ////////////////////////////////////////////////////////////////////////////\n\n        /**\n         * Appends an array buffer.\n         *\n         * @param {ArrayBuffer} arr The array to be appended\n         *\n         * @return {SparkMD5.ArrayBuffer} The instance itself\n         */\n        SparkMD5.ArrayBuffer.prototype.append = function (arr) {\n            // TODO: we could avoid the concatenation here but the algorithm would be more complex\n            //       if you find yourself needing extra performance, please make a PR.\n            var buff = this._concatArrayBuffer(this._buff, arr),\n                length = buff.length,\n                i;\n\n            this._length += arr.byteLength;\n\n            for (i = 64; i <= length; i += 64) {\n                md5cycle(this._state, md5blk_array(buff.subarray(i - 64, i)));\n            }\n\n            // Avoids IE10 weirdness (documented above)\n            this._buff = i - 64 < length ? buff.subarray(i - 64) : new Uint8Array(0);\n\n            return this;\n        };\n\n        /**\n         * Finishes the incremental computation, reseting the internal state and\n         * returning the result.\n         * Use the raw parameter to obtain the raw result instead of the hex one.\n         *\n         * @param {Boolean} raw True to get the raw result, false to get the hex result\n         *\n         * @return {String|Array} The result\n         */\n        SparkMD5.ArrayBuffer.prototype.end = function (raw) {\n            var buff = this._buff,\n                length = buff.length,\n                tail = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n                i,\n                ret;\n\n            for (i = 0; i < length; i += 1) {\n                tail[i >> 2] |= buff[i] << (i % 4 << 3);\n            }\n\n            this._finish(tail, length);\n            ret = !!raw ? this._state : hex(this._state);\n\n            this.reset();\n\n            return ret;\n        };\n\n        SparkMD5.ArrayBuffer.prototype._finish = SparkMD5.prototype._finish;\n\n        /**\n         * Resets the internal state of the computation.\n         *\n         * @return {SparkMD5.ArrayBuffer} The instance itself\n         */\n        SparkMD5.ArrayBuffer.prototype.reset = function () {\n            this._buff = new Uint8Array(0);\n            this._length = 0;\n            this._state = [1732584193, -271733879, -1732584194, 271733878];\n\n            return this;\n        };\n\n        /**\n         * Releases memory used by the incremental buffer and other aditional\n         * resources. If you plan to use the instance again, use reset instead.\n         */\n        SparkMD5.ArrayBuffer.prototype.destroy = SparkMD5.prototype.destroy;\n\n        /**\n         * Concats two array buffers, returning a new one.\n         *\n         * @param  {ArrayBuffer} first  The first array buffer\n         * @param  {ArrayBuffer} second The second array buffer\n         *\n         * @return {ArrayBuffer} The new array buffer\n         */\n        SparkMD5.ArrayBuffer.prototype._concatArrayBuffer = function (first, second) {\n            var firstLength = first.length,\n                result = new Uint8Array(firstLength + second.byteLength);\n\n            result.set(first);\n            result.set(new Uint8Array(second), firstLength);\n\n            return result;\n        };\n\n        /**\n         * Performs the md5 hash on an array buffer.\n         *\n         * @param {ArrayBuffer} arr The array buffer\n         * @param {Boolean}     raw True to get the raw result, false to get the hex result\n         *\n         * @return {String|Array} The result\n         */\n        SparkMD5.ArrayBuffer.hash = function (arr, raw) {\n            var hash = md51_array(new Uint8Array(arr));\n\n            return !!raw ? hash : hex(hash);\n        };\n\n        return FlashRuntime.register('Md5', {\n            init: function init() {\n                // do nothing.\n            },\n\n            loadFromBlob: function loadFromBlob(file) {\n                var blob = file.getSource(),\n                    chunkSize = 2 * 1024 * 1024,\n                    chunks = Math.ceil(blob.size / chunkSize),\n                    chunk = 0,\n                    owner = this.owner,\n                    spark = new SparkMD5.ArrayBuffer(),\n                    me = this,\n                    blobSlice = blob.mozSlice || blob.webkitSlice || blob.slice,\n                    _loadNext,\n                    fr;\n\n                fr = new FileReader();\n\n                _loadNext = function loadNext() {\n                    var start, end;\n\n                    start = chunk * chunkSize;\n                    end = Math.min(start + chunkSize, blob.size);\n\n                    fr.onload = function (e) {\n                        spark.append(e.target.result);\n                        owner.trigger('progress', {\n                            total: file.size,\n                            loaded: end\n                        });\n                    };\n\n                    fr.onloadend = function () {\n                        fr.onloadend = fr.onload = null;\n\n                        if (++chunk < chunks) {\n                            setTimeout(_loadNext, 1);\n                        } else {\n                            setTimeout(function () {\n                                owner.trigger('load');\n                                me.result = spark.end();\n                                _loadNext = file = blob = spark = null;\n                                owner.trigger('complete');\n                            }, 50);\n                        }\n                    };\n\n                    fr.readAsArrayBuffer(blobSlice.call(blob, start, end));\n                };\n\n                _loadNext();\n            },\n\n            getResult: function getResult() {\n                return this.result;\n            }\n        });\n    });\n    /**\n     * @fileOverview FlashRuntime\n     */\n    define('runtime/flash/runtime', ['base', 'runtime/runtime', 'runtime/compbase'], function (Base, Runtime, CompBase) {\n\n        var $ = Base.$,\n            type = 'flash',\n            components = {};\n\n        function getFlashVersion() {\n            var version;\n\n            try {\n                version = navigator.plugins['Shockwave Flash'];\n                version = version.description;\n            } catch (ex) {\n                try {\n                    version = new ActiveXObject('ShockwaveFlash.ShockwaveFlash').GetVariable('$version');\n                } catch (ex2) {\n                    version = '0.0';\n                }\n            }\n            version = version.match(/\\d+/g);\n            return parseFloat(version[0] + '.' + version[1], 10);\n        }\n\n        function FlashRuntime() {\n            var pool = {},\n                clients = {},\n                destroy = this.destroy,\n                me = this,\n                jsreciver = Base.guid('webuploader_');\n\n            Runtime.apply(me, arguments);\n            me.type = type;\n\n            // 这个方法的调用者，实际上是RuntimeClient\n            me.exec = function (comp, fn /*, args...*/) {\n                var client = this,\n                    uid = client.uid,\n                    args = Base.slice(arguments, 2),\n                    instance;\n\n                clients[uid] = client;\n\n                if (components[comp]) {\n                    if (!pool[uid]) {\n                        pool[uid] = new components[comp](client, me);\n                    }\n\n                    instance = pool[uid];\n\n                    if (instance[fn]) {\n                        return instance[fn].apply(instance, args);\n                    }\n                }\n\n                return me.flashExec.apply(client, arguments);\n            };\n\n            function handler(evt, obj) {\n                var type = evt.type || evt,\n                    parts,\n                    uid;\n\n                parts = type.split('::');\n                uid = parts[0];\n                type = parts[1];\n\n                // console.log.apply( console, arguments );\n\n                if (type === 'Ready' && uid === me.uid) {\n                    me.trigger('ready');\n                } else if (clients[uid]) {\n                    clients[uid].trigger(type.toLowerCase(), evt, obj);\n                }\n\n                // Base.log( evt, obj );\n            }\n\n            // flash的接受器。\n            window[jsreciver] = function () {\n                var args = arguments;\n\n                // 为了能捕获得到。\n                setTimeout(function () {\n                    handler.apply(null, args);\n                }, 1);\n            };\n\n            this.jsreciver = jsreciver;\n\n            this.destroy = function () {\n                // @todo 删除池子中的所有实例\n                return destroy && destroy.apply(this, arguments);\n            };\n\n            this.flashExec = function (comp, fn) {\n                var flash = me.getFlash(),\n                    args = Base.slice(arguments, 2);\n\n                return flash.exec(this.uid, comp, fn, args);\n            };\n\n            // @todo\n        }\n\n        Base.inherits(Runtime, {\n            constructor: FlashRuntime,\n\n            init: function init() {\n                var container = this.getContainer(),\n                    opts = this.options,\n                    html;\n\n                // if not the minimal height, shims are not initialized\n                // in older browsers (e.g FF3.6, IE6,7,8, Safari 4.0,5.0, etc)\n                container.css({\n                    position: 'absolute',\n                    top: '-8px',\n                    left: '-8px',\n                    width: '9px',\n                    height: '9px',\n                    overflow: 'hidden'\n                });\n\n                // insert flash object\n                html = '<object id=\"' + this.uid + '\" type=\"application/' + 'x-shockwave-flash\" data=\"' + opts.swf + '\" ';\n\n                if (Base.browser.ie) {\n                    html += 'classid=\"clsid:d27cdb6e-ae6d-11cf-96b8-444553540000\" ';\n                }\n\n                html += 'width=\"100%\" height=\"100%\" style=\"outline:0\">' + '<param name=\"movie\" value=\"' + opts.swf + '\" />' + '<param name=\"flashvars\" value=\"uid=' + this.uid + '&jsreciver=' + this.jsreciver + '\" />' + '<param name=\"wmode\" value=\"transparent\" />' + '<param name=\"allowscriptaccess\" value=\"always\" />' + '</object>';\n\n                container.html(html);\n            },\n\n            getFlash: function getFlash() {\n                if (this._flash) {\n                    return this._flash;\n                }\n\n                this._flash = $('#' + this.uid).get(0);\n                return this._flash;\n            }\n\n        });\n\n        FlashRuntime.register = function (name, component) {\n            component = components[name] = Base.inherits(CompBase, $.extend({\n\n                // @todo fix this later\n                flashExec: function flashExec() {\n                    var owner = this.owner,\n                        runtime = this.getRuntime();\n\n                    return runtime.flashExec.apply(owner, arguments);\n                }\n            }, component));\n\n            return component;\n        };\n\n        if (getFlashVersion() >= 11.4) {\n            Runtime.addRuntime(type, FlashRuntime);\n        }\n\n        return FlashRuntime;\n    });\n    /**\n     * @fileOverview FilePicker\n     */\n    define('runtime/flash/filepicker', ['base', 'runtime/flash/runtime'], function (Base, FlashRuntime) {\n        var $ = Base.$;\n\n        return FlashRuntime.register('FilePicker', {\n            init: function init(opts) {\n                var copy = $.extend({}, opts),\n                    len,\n                    i;\n\n                // 修复Flash再没有设置title的情况下无法弹出flash文件选择框的bug.\n                len = copy.accept && copy.accept.length;\n                for (i = 0; i < len; i++) {\n                    if (!copy.accept[i].title) {\n                        copy.accept[i].title = 'Files';\n                    }\n                }\n\n                delete copy.button;\n                delete copy.id;\n                delete copy.container;\n\n                this.flashExec('FilePicker', 'init', copy);\n            },\n\n            destroy: function destroy() {\n                this.flashExec('FilePicker', 'destroy');\n            }\n        });\n    });\n    /**\n     * @fileOverview 图片压缩\n     */\n    define('runtime/flash/image', ['runtime/flash/runtime'], function (FlashRuntime) {\n\n        return FlashRuntime.register('Image', {\n            // init: function( options ) {\n            //     var owner = this.owner;\n\n            //     this.flashExec( 'Image', 'init', options );\n            //     owner.on( 'load', function() {\n            //         debugger;\n            //     });\n            // },\n\n            loadFromBlob: function loadFromBlob(blob) {\n                var owner = this.owner;\n\n                owner.info() && this.flashExec('Image', 'info', owner.info());\n                owner.meta() && this.flashExec('Image', 'meta', owner.meta());\n\n                this.flashExec('Image', 'loadFromBlob', blob.uid);\n            }\n        });\n    });\n    /**\n     * @fileOverview  Transport flash实现\n     */\n    define('runtime/flash/transport', ['base', 'runtime/flash/runtime', 'runtime/client'], function (Base, FlashRuntime, RuntimeClient) {\n        var $ = Base.$;\n\n        return FlashRuntime.register('Transport', {\n            init: function init() {\n                this._status = 0;\n                this._response = null;\n                this._responseJson = null;\n            },\n\n            send: function send() {\n                var owner = this.owner,\n                    opts = this.options,\n                    xhr = this._initAjax(),\n                    blob = owner._blob,\n                    server = opts.server,\n                    binary;\n\n                xhr.connectRuntime(blob.ruid);\n\n                if (opts.sendAsBinary) {\n                    server += (/\\?/.test(server) ? '&' : '?') + $.param(owner._formData);\n\n                    binary = blob.uid;\n                } else {\n                    $.each(owner._formData, function (k, v) {\n                        xhr.exec('append', k, v);\n                    });\n\n                    xhr.exec('appendBlob', opts.fileVal, blob.uid, opts.filename || owner._formData.name || '');\n                }\n\n                this._setRequestHeader(xhr, opts.headers);\n                xhr.exec('send', {\n                    method: opts.method,\n                    url: server,\n                    forceURLStream: opts.forceURLStream,\n                    mimeType: 'application/octet-stream'\n                }, binary);\n            },\n\n            getStatus: function getStatus() {\n                return this._status;\n            },\n\n            getResponse: function getResponse() {\n                return this._response || '';\n            },\n\n            getResponseAsJson: function getResponseAsJson() {\n                return this._responseJson;\n            },\n\n            abort: function abort() {\n                var xhr = this._xhr;\n\n                if (xhr) {\n                    xhr.exec('abort');\n                    xhr.destroy();\n                    this._xhr = xhr = null;\n                }\n            },\n\n            destroy: function destroy() {\n                this.abort();\n            },\n\n            _initAjax: function _initAjax() {\n                var me = this,\n                    xhr = new RuntimeClient('XMLHttpRequest');\n\n                xhr.on('uploadprogress progress', function (e) {\n                    var percent = e.loaded / e.total;\n                    percent = Math.min(1, Math.max(0, percent));\n                    return me.trigger('progress', percent);\n                });\n\n                xhr.on('load', function () {\n                    var status = xhr.exec('getStatus'),\n                        readBody = false,\n                        err = '',\n                        p;\n\n                    xhr.off();\n                    me._xhr = null;\n\n                    if (status >= 200 && status < 300) {\n                        readBody = true;\n                    } else if (status >= 500 && status < 600) {\n                        readBody = true;\n                        err = 'server';\n                    } else {\n                        err = 'http';\n                    }\n\n                    if (readBody) {\n                        me._response = xhr.exec('getResponse');\n                        me._response = decodeURIComponent(me._response);\n\n                        // flash 处理可能存在 bug, 没辙只能靠 js 了\n                        // try {\n                        //     me._responseJson = xhr.exec('getResponseAsJson');\n                        // } catch ( error ) {\n\n                        p = window.JSON && window.JSON.parse || function (s) {\n                            try {\n                                return new Function('return ' + s).call();\n                            } catch (err) {\n                                return {};\n                            }\n                        };\n                        me._responseJson = me._response ? p(me._response) : {};\n\n                        // }\n                    }\n\n                    xhr.destroy();\n                    xhr = null;\n\n                    return err ? me.trigger('error', err) : me.trigger('load');\n                });\n\n                xhr.on('error', function () {\n                    xhr.off();\n                    me._xhr = null;\n                    me.trigger('error', 'http');\n                });\n\n                me._xhr = xhr;\n                return xhr;\n            },\n\n            _setRequestHeader: function _setRequestHeader(xhr, headers) {\n                $.each(headers, function (key, val) {\n                    xhr.exec('setRequestHeader', key, val);\n                });\n            }\n        });\n    });\n    /**\n     * @fileOverview Blob Html实现\n     */\n    define('runtime/flash/blob', ['runtime/flash/runtime', 'lib/blob'], function (FlashRuntime, Blob) {\n\n        return FlashRuntime.register('Blob', {\n            slice: function slice(start, end) {\n                var blob = this.flashExec('Blob', 'slice', start, end);\n\n                return new Blob(blob.uid, blob);\n            }\n        });\n    });\n    /**\n     * @fileOverview  Md5 flash实现\n     */\n    define('runtime/flash/md5', ['runtime/flash/runtime'], function (FlashRuntime) {\n\n        return FlashRuntime.register('Md5', {\n            init: function init() {\n                // do nothing.\n            },\n\n            loadFromBlob: function loadFromBlob(blob) {\n                return this.flashExec('Md5', 'loadFromBlob', blob.uid);\n            }\n        });\n    });\n    /**\n     * @fileOverview 完全版本。\n     */\n    define('preset/all', ['base',\n\n    // widgets\n    'widgets/filednd', 'widgets/filepaste', 'widgets/filepicker', 'widgets/image', 'widgets/queue', 'widgets/runtime', 'widgets/upload', 'widgets/validator', 'widgets/md5',\n\n    // runtimes\n    // html5\n    'runtime/html5/blob', 'runtime/html5/dnd', 'runtime/html5/filepaste', 'runtime/html5/filepicker', 'runtime/html5/imagemeta/exif', 'runtime/html5/androidpatch', 'runtime/html5/image', 'runtime/html5/transport', 'runtime/html5/md5',\n\n    // flash\n    'runtime/flash/filepicker', 'runtime/flash/image', 'runtime/flash/transport', 'runtime/flash/blob', 'runtime/flash/md5'], function (Base) {\n        return Base;\n    });\n    /**\n     * @fileOverview 日志组件，主要用来收集错误信息，可以帮助 webuploader 更好的定位问题和发展。\n     *\n     * 如果您不想要启用此功能，请在打包的时候去掉 log 模块。\n     *\n     * 或者可以在初始化的时候通过 options.disableWidgets 属性禁用。\n     *\n     * 如：\n     * WebUploader.create({\n     *     ...\n     *\n     *     disableWidgets: 'log',\n     *\n     *     ...\n     * })\n     */\n    define('widgets/log', ['base', 'uploader', 'widgets/widget'], function (Base, Uploader) {\n        var $ = Base.$,\n            logUrl = ' http://static.tieba.baidu.com/tb/pms/img/st.gif??',\n            product = (location.hostname || location.host || 'protected').toLowerCase(),\n\n\n        // 只针对 baidu 内部产品用户做统计功能。\n        enable = product && /baidu/i.exec(product),\n            base;\n\n        if (!enable) {\n            return;\n        }\n\n        base = {\n            dv: 3,\n            master: 'webuploader',\n            online: /test/.exec(product) ? 0 : 1,\n            module: '',\n            product: product,\n            type: 0\n        };\n\n        function send(data) {\n            var obj = $.extend({}, base, data),\n                url = logUrl.replace(/^(.*)\\?/, '$1' + $.param(obj)),\n                image = new Image();\n\n            image.src = url;\n        }\n\n        return Uploader.register({\n            name: 'log',\n\n            init: function init() {\n                var owner = this.owner,\n                    count = 0,\n                    size = 0;\n\n                owner.on('error', function (code) {\n                    send({\n                        type: 2,\n                        c_error_code: code\n                    });\n                }).on('uploadError', function (file, reason) {\n                    send({\n                        type: 2,\n                        c_error_code: 'UPLOAD_ERROR',\n                        c_reason: '' + reason\n                    });\n                }).on('uploadComplete', function (file) {\n                    count++;\n                    size += file.size;\n                }).on('uploadFinished', function () {\n                    send({\n                        c_count: count,\n                        c_size: size\n                    });\n                    count = size = 0;\n                });\n\n                send({\n                    c_usage: 1\n                });\n            }\n        });\n    });\n    /**\n     * @fileOverview Uploader上传类\n     */\n    define('webuploader', ['preset/all', 'widgets/log'], function (preset) {\n        return preset;\n    });\n    return require('webuploader');\n});\n/* WEBPACK VAR INJECTION */}.call(__webpack_exports__, __webpack_require__(67)(module)))\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvY29tcG9uZW50cy93ZWJ1cGxvYWRlci93ZWJ1cGxvYWRlci0wLjEuNS93ZWJ1cGxvYWRlci5qcz9jNWVhIl0sIm5hbWVzIjpbInJvb3QiLCJmYWN0b3J5IiwibW9kdWxlcyIsIl9yZXF1aXJlIiwiZGVwcyIsImNhbGxiYWNrIiwiYXJncyIsImxlbiIsImkiLCJnZXRNb2R1bGUiLCJsZW5ndGgiLCJwdXNoIiwiYXBwbHkiLCJfZGVmaW5lIiwiaWQiLCJhcmd1bWVudHMiLCJzZXRNb2R1bGUiLCJtb2R1bGUiLCJleHBvcnRzIiwicmV0dXJuZWQiLCJ1bmRlZmluZWQiLCJFcnJvciIsImV4cG9ydHNUbyIsIm9iaiIsImtleSIsImhvc3QiLCJwYXJ0cyIsInBhcnQiLCJsYXN0IiwidWNGaXJzdCIsInN0ciIsImNoYXJBdCIsInRvVXBwZXJDYXNlIiwic3Vic3RyIiwiaGFzT3duUHJvcGVydHkiLCJzcGxpdCIsInBvcCIsInNoaWZ0IiwibWFrZUV4cG9ydCIsImRvbGxhciIsIl9fZG9sbGFyIiwib3JpZ2luIiwiZGVmaW5lIiwiV2ViVXBsb2FkZXIiLCJub0NvbmZsaWN0Iiwid2luZG93IiwicmVxdWlyZSIsIiQiLCJqUXVlcnkiLCJaZXB0byIsIl8iLCJEZWZlcnJlZCIsIndoZW4iLCJpc1Byb21pc2UiLCJhbnl0aGluZyIsInRoZW4iLCJwcm9taXNlIiwibm9vcCIsImNhbGwiLCJGdW5jdGlvbiIsInVuY3VycnlUaGlzIiwiZm4iLCJiaW5kRm4iLCJjb250ZXh0IiwiY3JlYXRlT2JqZWN0IiwicHJvdG8iLCJmIiwicHJvdG90eXBlIiwidmVyc2lvbiIsImJyb3dzZXIiLCJ1YSIsInJldCIsIndlYmtpdCIsIm1hdGNoIiwiY2hyb21lIiwiaWUiLCJmaXJlZm94Iiwic2FmYXJpIiwib3BlcmEiLCJwYXJzZUZsb2F0IiwibmF2aWdhdG9yIiwidXNlckFnZW50Iiwib3MiLCJhbmRyb2lkIiwiaW9zIiwicmVwbGFjZSIsImluaGVyaXRzIiwiU3VwZXIiLCJwcm90b3MiLCJzdGF0aWNQcm90b3MiLCJjaGlsZCIsImNvbnN0cnVjdG9yIiwiZXh0ZW5kIiwiX19zdXBlcl9fIiwibG9nIiwiY29uc29sZSIsIm5leHRUaWNrIiwiY2IiLCJzZXRUaW1lb3V0Iiwic2xpY2UiLCJndWlkIiwiY291bnRlciIsInByZWZpeCIsIkRhdGUiLCJ0b1N0cmluZyIsIk1hdGgiLCJmbG9vciIsInJhbmRvbSIsImZvcm1hdFNpemUiLCJzaXplIiwicG9pbnRMZW5ndGgiLCJ1bml0cyIsInVuaXQiLCJ0b0ZpeGVkIiwiQmFzZSIsInNlcGFyYXRvciIsImZpbmRIYW5kbGVycyIsImFyciIsIm5hbWUiLCJncmVwIiwiaGFuZGxlciIsImUiLCJfY2IiLCJjdHgiLCJlYWNoRXZlbnQiLCJldmVudHMiLCJpdGVyYXRvciIsImVhY2giLCJ0cmlnZ2VySGFuZGVycyIsInN0b3BlZCIsImN0eDIiLCJvbiIsIm1lIiwic2V0IiwiX2V2ZW50cyIsIm9uY2UiLCJvZmYiLCJ0cmlnZ2VyIiwidHlwZSIsImFsbEV2ZW50cyIsImluc3RhbGxUbyIsIk1lZGlhdG9yIiwiVXBsb2FkZXIiLCJvcHRzIiwib3B0aW9ucyIsIl9pbml0IiwidXBsb2FkIiwic3RvcCIsImdldEZpbGUiLCJnZXRGaWxlcyIsImFkZEZpbGUiLCJhZGRGaWxlcyIsInNvcnQiLCJyZW1vdmVGaWxlIiwiY2FuY2VsRmlsZSIsInNraXBGaWxlIiwicmV0cnkiLCJpc0luUHJvZ3Jlc3MiLCJtYWtlVGh1bWIiLCJtZDVGaWxlIiwiZ2V0RGltZW5zaW9uIiwiYWRkQnV0dG9uIiwicHJlZGljdFJ1bnRpbWVUeXBlIiwicmVmcmVzaCIsImRpc2FibGUiLCJlbmFibGUiLCJyZXNldCIsImNvbW1hbmQiLCJyZXF1ZXN0Iiwic3RhdGUiLCJvcHRpb24iLCJ2YWwiLCJpc1BsYWluT2JqZWN0IiwiZ2V0U3RhdHMiLCJzdGF0cyIsInN1Y2Nlc3NOdW0iLCJudW1PZlN1Y2Nlc3MiLCJwcm9ncmVzc051bSIsIm51bU9mUHJvZ3Jlc3MiLCJjYW5jZWxOdW0iLCJudW1PZkNhbmNlbCIsImludmFsaWROdW0iLCJudW1PZkludmFsaWQiLCJ1cGxvYWRGYWlsTnVtIiwibnVtT2ZVcGxvYWRGYWlsZWQiLCJxdWV1ZU51bSIsIm51bU9mUXVldWUiLCJpbnRlcnJ1cHROdW0iLCJudW1vZkludGVycnVwdCIsInN1YnN0cmluZyIsImlzRnVuY3Rpb24iLCJjb25jYXQiLCJkZXN0cm95IiwiY3JlYXRlIiwiZmFjdG9yaWVzIiwiZ2V0Rmlyc3RLZXkiLCJSdW50aW1lIiwiY29udGFpbmVyIiwiZG9jdW1lbnQiLCJib2R5IiwidWlkIiwiZ2V0Q29udGFpbmVyIiwicGFyZW50IiwiX2NvbnRhaW5lciIsImNyZWF0ZUVsZW1lbnQiLCJhdHRyIiwiY3NzIiwicG9zaXRpb24iLCJ0b3AiLCJsZWZ0Iiwid2lkdGgiLCJoZWlnaHQiLCJvdmVyZmxvdyIsImFwcGVuZCIsImFkZENsYXNzIiwiX3BhcmVudCIsImluaXQiLCJleGVjIiwicmVtb3ZlIiwicmVtb3ZlQ2xhc3MiLCJvcmRlcnMiLCJhZGRSdW50aW1lIiwiaGFzUnVudGltZSIsInJ1bnRpbWUiLCJjYWNoZSIsImFkZCIsImdldCIsInJ1aWQiLCJzdGFuZGFsb25lIiwiX19zdGFuZGFsb25lIiwiUnVudGltZUNsaWVudCIsImNvbXBvbmVudCIsImRlZmVycmVkIiwicnVudGltZVJlYWR5IiwiZG9uZSIsImNvbm5lY3RSdW50aW1lIiwicnVudGltZU9yZGVyIiwiX19wcm9taXNlIiwicmVzb2x2ZSIsIl9fY2xpZW50IiwiZ2V0UnVudGltZSIsImRpc2Nvbm5lY3RSdW50aW1lIiwidW5zaGlmdCIsImdldFJ1aWQiLCJSdW50aW1lQ2xlbnQiLCJEcmFnQW5kRHJvcCIsImFjY2VwdCIsImRpc2FibGVHbG9iYWxEbmQiLCJfZGVzdHJveSIsIklHTk9SRSIsIndpZGdldENsYXNzIiwiaXNBcnJheUxpa2UiLCJub2RlVHlwZSIsIldpZGdldCIsInVwbG9hZGVyIiwib3duZXIiLCJpbnZva2UiLCJhcGlOYW1lIiwibWFwIiwicmVzcG9uc2VNYXAiLCJ3aWRnZXRzIiwiX3dpZGdldHMiLCJkZWFjdGl2ZXMiLCJkaXNhYmxlV2lkZ2V0cyIsImtsYXNzIiwiaW5kZXhPZiIsIl9uYW1lIiwicmx0cyIsImRmZHMiLCJ3aWRnZXQiLCJybHQiLCJwaXBlIiwicmVnaXN0ZXIiLCJ3aWRnZXRQcm90byIsInRvTG93ZXJDYXNlIiwidW5SZWdpc3RlciIsInNwbGljZSIsIkRuZCIsImRuZCIsImZpbGVzIiwiaXRlbXMiLCJGaWxlUGFzdGUiLCJwYXN0ZSIsIkJsb2IiLCJzb3VyY2UiLCJleHQiLCJzdGFydCIsImVuZCIsImdldFNvdXJjZSIsInJFeHQiLCJGaWxlIiwiZmlsZSIsIlJlZ0V4cCIsIiQxIiwibGFzdE1vZGlmaWVkRGF0ZSIsInRvTG9jYWxlU3RyaW5nIiwiRmlsZVBpY2tlciIsImlubmVySFRNTCIsImxhYmVsIiwiaHRtbCIsImJ1dHRvbiIsIm11bHRpcGxlIiwiX3JlZmVyIiwiX3Jlc2l6ZUhhbmRsZXIiLCJzaGltQ29udGFpbmVyIiwib3V0ZXJXaWR0aCIsIm91dGVySGVpZ2h0IiwicG9zIiwib2Zmc2V0IiwiYm90dG9tIiwicmlnaHQiLCJidG4iLCJwaWNrIiwicGlja2VycyIsImFkZEJ0biIsInByb21pc2VzIiwicGlja2VyIiwic3dmIiwiSW1hZ2UiLCJfaW5mbyIsIl9tZXRhIiwicXVhbGl0eSIsImNyb3AiLCJwcmVzZXJ2ZUhlYWRlcnMiLCJhbGxvd01hZ25pZnkiLCJpbmZvIiwibWV0YSIsImxvYWRGcm9tQmxvYiIsImJsb2IiLCJyZXNpemUiLCJnZXRBc0RhdGFVcmwiLCJnZXRBc0Jsb2IiLCJ0aHJvdHRsZSIsIm1heCIsIm9jY3VwaWVkIiwid2FpdGluZyIsInRpY2siLCJpdGVtIiwiZW1pdGVyIiwidGh1bWIiLCJjb21wcmVzcyIsImltYWdlIiwicmVhc29uIiwiYmVmb3JlU2VuZEZpbGUiLCJjb21wcmVzc1NpemUiLCJub0NvbXByZXNzSWZMYXJnZXIiLCJfY29tcHJlc3NlZCIsImFsd2F5cyIsInJlamVjdCIsImlkUHJlZml4IiwiaWRTdWZmaXgiLCJzdGF0dXNNYXAiLCJnaWQiLCJXVUZpbGUiLCJzdGF0dXNUZXh0IiwiU3RhdHVzIiwiSU5JVEVEIiwibG9hZGVkIiwibXNnIiwic2V0U3RhdHVzIiwiRVJST1IiLCJzdGF0dXMiLCJ0ZXh0IiwicHJldlN0YXR1cyIsImdldFN0YXR1cyIsIlFVRVVFRCIsIlBST0dSRVNTIiwiQ09NUExFVEUiLCJDQU5DRUxMRUQiLCJJTlRFUlJVUFQiLCJJTlZBTElEIiwiU1RBVFVTIiwiUXVldWUiLCJudW1vZkRlbGV0ZWQiLCJfcXVldWUiLCJfbWFwIiwiX2ZpbGVBZGRlZCIsInByZXBlbmQiLCJmaWxlSWQiLCJmZXRjaCIsInN0cyIsImluQXJyYXkiLCJleGlzdGluZyIsImN1ciIsInByZSIsIl9vbkZpbGVTdGF0dXNDaGFuZ2UiLCJjdXJTdGF0dXMiLCJwcmVTdGF0dXMiLCJleHRlbnNpb25zIiwiam9pbiIsInF1ZXVlIiwicGxhY2Vob2xkZXIiLCJfcnVpZCIsIl93cmFwRmlsZSIsImFjY2VwdEZpbGUiLCJpbnZhbGlkIiwidGVzdCIsIl9hZGRGaWxlIiwiYXV0byIsImZldGNoRmlsZSIsIm5vRm9yY2VTdGFydCIsInNvcnRGaWxlcyIsInN1cHBvcnQiLCJUcmFuc3BvcnQiLCJfYmxvYiIsIl9mb3JtRGF0YSIsImZvcm1EYXRhIiwiX2hlYWRlcnMiLCJoZWFkZXJzIiwiX3RpbWVvdXQiLCJjbGVhclRpbWVvdXQiLCJfdGltZXIiLCJzZXJ2ZXIiLCJtZXRob2QiLCJ3aXRoQ3JlZGVudGlhbHMiLCJmaWxlVmFsIiwidGltZW91dCIsInNlbmRBc0JpbmFyeSIsImFwcGVuZEJsb2IiLCJmaWxlbmFtZSIsInZhbHVlIiwic2V0UmVxdWVzdEhlYWRlciIsInNlbmQiLCJhYm9ydCIsImdldFJlc3BvbnNlIiwiZ2V0UmVzcG9uc2VBc0pzb24iLCJkdXJhdGlvbiIsInByZXBhcmVOZXh0RmlsZSIsImNodW5rZWQiLCJjaHVua1NpemUiLCJjaHVua1JldHJ5IiwidGhyZWFkcyIsIkN1dGVGaWxlIiwicGVuZGluZyIsInRvdGFsIiwiY2h1bmtzIiwiY2VpbCIsImluZGV4IiwiYXBpIiwiaGFzIiwiYmxvY2siLCJtaW4iLCJjaHVuayIsImN1dGVkIiwiYmxvY2tzIiwicmVtYW5pbmciLCJydW5pbmciLCJwcm9ncmVzcyIsInBvb2wiLCJzdGFjayIsIl9fdGljayIsIl90aWNrIiwidiIsInRyYW5zcG9ydCIsIl90cmlnZ2VkIiwiX3Byb21pc2UiLCJzdGFydFVwbG9hZCIsInN0b3BVcGxvYWQiLCJpbnRlcnJ1cHQiLCJfcHV0YmFjayIsIl9wb3BCbG9jayIsIl90ciIsIl9nZXRTdGF0cyIsInNraXBwZWQiLCJfbmV4dEJsb2NrIiwiX3N0YXJ0U2VuZCIsImlkeCIsIl9nZXRTdGFjayIsImFjdCIsIm5leHQiLCJwcmVwYXJpbmciLCJfcHJlcGFyZU5leHRGaWxlIiwiX2ZpbmlzaEZpbGUiLCJmYWlsIiwiX2RvU2VuZCIsInBlcmNlbnRhZ2UiLCJ1cGRhdGVGaWxlUHJvZ3Jlc3MiLCJ0ciIsImRhdGEiLCJyZXF1ZXN0QWNjZXB0IiwiX3JhdyIsImZsYWciLCJyZXRyaWVkIiwiaGRzIiwiRl9DT0RFIiwidG90YWxQZXJjZW50IiwidXBsb2FkZWQiLCJ2YWxpZGF0b3JzIiwiYWRkVmFsaWRhdG9yIiwicmVtb3ZlVmFsaWRhdG9yIiwiY291bnQiLCJwYXJzZUludCIsImZpbGVOdW1MaW1pdCIsImZpbGVTaXplTGltaXQiLCJmaWxlU2luZ2xlU2l6ZUxpbWl0IiwibWFwcGluZyIsImR1cGxpY2F0ZSIsImhhc2hTdHJpbmciLCJoYXNoIiwiX2NoYXIiLCJjaGFyQ29kZUF0IiwiX19oYXNoIiwiTWQ1IiwiZ2V0UmVzdWx0IiwibWQ1Iiwibm90aWZ5IiwiQ29tcEJhc2UiLCJjb21wb25lbnRzIiwiSHRtbDVSdW50aW1lIiwiY29tcCIsImNsaWVudCIsImluc3RhbmNlIiwiRmlsZVJlYWRlciIsIkRhdGFWaWV3Iiwid2Via2l0U2xpY2UiLCJtb3pTbGljZSIsImVsZW0iLCJkcmFnRW50ZXJIYW5kbGVyIiwiX2RyYWdFbnRlckhhbmRsZXIiLCJkcmFnT3ZlckhhbmRsZXIiLCJfZHJhZ092ZXJIYW5kbGVyIiwiZHJhZ0xlYXZlSGFuZGxlciIsIl9kcmFnTGVhdmVIYW5kbGVyIiwiZHJvcEhhbmRsZXIiLCJfZHJvcEhhbmRsZXIiLCJkbmRPdmVyIiwiZGVuaWVkIiwiX2RlbmllZCIsIm9yaWdpbmFsRXZlbnQiLCJkYXRhVHJhbnNmZXIiLCJkcm9wRWZmZWN0IiwicGFyZW50RWxlbSIsImNvbnRhaW5zIiwiY3VycmVudFRhcmdldCIsIl9sZWF2ZVRpbWVyIiwiZ2V0RGF0YSIsImVyciIsIl9nZXRUYW5zZmVyRmlsZXMiLCJyZXN1bHRzIiwiY2FuQWNjZXNzRm9sZGVyIiwid2Via2l0R2V0QXNFbnRyeSIsImlzRGlyZWN0b3J5IiwiX3RyYXZlcnNlRGlyZWN0b3J5VHJlZSIsImVudHJ5IiwiaXNGaWxlIiwiY3JlYXRlUmVhZGVyIiwicmVhZEVudHJpZXMiLCJlbnRyaWVzIiwibWltZVR5cGVzIiwiaGFuZGVyIiwiX3Bhc3RlSGFuZGVyIiwiYWxsb3dlZCIsImNsaXBib2FyZERhdGEiLCJraW5kIiwiZ2V0QXNGaWxlIiwicHJldmVudERlZmF1bHQiLCJzdG9wUHJvcGFnYXRpb24iLCJpbnB1dCIsIm1vdXNlSGFuZGxlciIsIm9wYWNpdHkiLCJkaXNwbGF5IiwiY3Vyc29yIiwiYmFja2dyb3VuZCIsImNoYW5nZUZuIiwiZXZlbiIsInRoYXQiLCJjbG9uZSIsInRhcmdldCIsImNsb25lTm9kZSIsInBhcmVudE5vZGUiLCJyZXBsYWNlQ2hpbGQiLCJ1cmxBUEkiLCJjcmVhdGVPYmplY3RVUkwiLCJVUkwiLCJyZXZva2VPYmplY3RVUkwiLCJ3ZWJraXRVUkwiLCJkYXRhVVJMMkJsb2IiLCJkYXRhVVJJIiwiYnl0ZVN0ciIsImludEFycmF5IiwiYWIiLCJtaW1ldHlwZSIsImF0b2IiLCJkZWNvZGVVUklDb21wb25lbnQiLCJBcnJheUJ1ZmZlciIsIlVpbnQ4QXJyYXkiLCJhcnJheUJ1ZmZlclRvQmxvYiIsImRhdGFVUkwyQXJyYXlCdWZmZXIiLCJidWZmZXIiLCJidWlsZGVyIiwiQmxvYkJ1aWxkZXIiLCJXZWJLaXRCbG9iQnVpbGRlciIsImJiIiwiZ2V0QmxvYiIsImNhbnZhc1RvRGF0YVVybCIsImNhbnZhcyIsInRvRGF0YVVSTCIsInBhcnNlTWV0YSIsInVwZGF0ZUltYWdlSGVhZCIsIlV0aWwiLCJwYXJzZXJzIiwibWF4TWV0YURhdGFTaXplIiwicGFyc2UiLCJmciIsIm9ubG9hZCIsIl9wYXJzZSIsInJlc3VsdCIsIm9uZXJyb3IiLCJtZXNzYWdlIiwicmVhZEFzQXJyYXlCdWZmZXIiLCJub1BhcnNlIiwiYnl0ZUxlbmd0aCIsImRhdGF2aWV3IiwibWF4T2Zmc2V0IiwiaGVhZExlbmd0aCIsIm1hcmtlckJ5dGVzIiwibWFya2VyTGVuZ3RoIiwiZ2V0VWludDE2IiwiaW1hZ2VIZWFkIiwic3ViYXJyYXkiLCJoZWFkIiwiYnVmMSIsImJ1ZjIiLCJib2R5b2Zmc2V0IiwiSW1hZ2VNZXRhIiwiRVhJRiIsIkV4aWZNYXAiLCJleGlmVGFnVHlwZXMiLCJnZXRWYWx1ZSIsImRhdGFWaWV3IiwiZGF0YU9mZnNldCIsImdldFVpbnQ4IiwiU3RyaW5nIiwiZnJvbUNoYXJDb2RlIiwiYXNjaWkiLCJsaXR0bGVFbmRpYW4iLCJnZXRVaW50MzIiLCJnZXRJbnQzMiIsImdldEV4aWZWYWx1ZSIsInRpZmZPZmZzZXQiLCJ0YWdUeXBlIiwidGFnU2l6ZSIsInZhbHVlcyIsImMiLCJwYXJzZUV4aWZUYWciLCJ0YWciLCJleGlmIiwicGFyc2VFeGlmVGFncyIsImRpck9mZnNldCIsInRhZ3NOdW1iZXIiLCJkaXJFbmRPZmZzZXQiLCJwYXJzZUV4aWZEYXRhIiwiSlBFR0VuY29kZXIiLCJzZWxmIiwiZnJvdW5kIiwicm91bmQiLCJmZmxvb3IiLCJZVGFibGUiLCJBcnJheSIsIlVWVGFibGUiLCJmZHRibF9ZIiwiZmR0YmxfVVYiLCJZRENfSFQiLCJVVkRDX0hUIiwiWUFDX0hUIiwiVVZBQ19IVCIsImJpdGNvZGUiLCJjYXRlZ29yeSIsIm91dHB1dGZEQ1RRdWFudCIsIkRVIiwiYnl0ZW91dCIsImJ5dGVuZXciLCJieXRlcG9zIiwiWURVIiwiVURVIiwiVkRVIiwiY2x0IiwiUkdCX1lVVl9UQUJMRSIsImN1cnJlbnRRdWFsaXR5IiwiWmlnWmFnIiwic3RkX2RjX2x1bWluYW5jZV9ucmNvZGVzIiwic3RkX2RjX2x1bWluYW5jZV92YWx1ZXMiLCJzdGRfYWNfbHVtaW5hbmNlX25yY29kZXMiLCJzdGRfYWNfbHVtaW5hbmNlX3ZhbHVlcyIsInN0ZF9kY19jaHJvbWluYW5jZV9ucmNvZGVzIiwic3RkX2RjX2Nocm9taW5hbmNlX3ZhbHVlcyIsInN0ZF9hY19jaHJvbWluYW5jZV9ucmNvZGVzIiwic3RkX2FjX2Nocm9taW5hbmNlX3ZhbHVlcyIsImluaXRRdWFudFRhYmxlcyIsInNmIiwiWVFUIiwidCIsIlVWUVQiLCJqIiwidSIsImFhc2YiLCJrIiwicm93IiwiY29sIiwiY29tcHV0ZUh1ZmZtYW5UYmwiLCJucmNvZGVzIiwic3RkX3RhYmxlIiwiY29kZXZhbHVlIiwicG9zX2luX3RhYmxlIiwiSFQiLCJpbml0SHVmZm1hblRibCIsImluaXRDYXRlZ29yeU51bWJlciIsIm5ybG93ZXIiLCJucnVwcGVyIiwiY2F0IiwibnIiLCJucm5lZyIsImluaXRSR0JZVVZUYWJsZSIsIndyaXRlQml0cyIsImJzIiwicG9zdmFsIiwid3JpdGVCeXRlIiwid3JpdGVXb3JkIiwiZkRDVFF1YW50IiwiZmR0YmwiLCJkMCIsImQxIiwiZDIiLCJkMyIsImQ0IiwiZDUiLCJkNiIsImQ3IiwiZGF0YU9mZiIsIkk4IiwiSTY0IiwidG1wMCIsInRtcDciLCJ0bXAxIiwidG1wNiIsInRtcDIiLCJ0bXA1IiwidG1wMyIsInRtcDQiLCJ0bXAxMCIsInRtcDEzIiwidG1wMTEiLCJ0bXAxMiIsInoxIiwiejUiLCJ6MiIsIno0IiwiejMiLCJ6MTEiLCJ6MTMiLCJ0bXAwcDIiLCJ0bXA3cDIiLCJ0bXAxcDIiLCJ0bXA2cDIiLCJ0bXAycDIiLCJ0bXA1cDIiLCJ0bXAzcDIiLCJ0bXA0cDIiLCJ0bXAxMHAyIiwidG1wMTNwMiIsInRtcDExcDIiLCJ0bXAxMnAyIiwiejFwMiIsIno1cDIiLCJ6MnAyIiwiejRwMiIsInozcDIiLCJ6MTFwMiIsInoxM3AyIiwid3JpdGVBUFAwIiwid3JpdGVTT0YwIiwid3JpdGVEUVQiLCJ3cml0ZURIVCIsImwiLCJtIiwibiIsIm8iLCJwIiwid3JpdGVTT1MiLCJwcm9jZXNzRFUiLCJDRFUiLCJEQyIsIkhUREMiLCJIVEFDIiwiRU9CIiwiTTE2emVyb2VzIiwiSTE2IiwiSTYzIiwiRFVfRENUIiwiRGlmZiIsImVuZDBwb3MiLCJsbmciLCJzdGFydHBvcyIsIm5yemVyb2VzIiwibnJtYXJrZXIiLCJpbml0Q2hhckxvb2t1cFRhYmxlIiwic2ZjYyIsImVuY29kZSIsInNldFF1YWxpdHkiLCJEQ1kiLCJEQ1UiLCJEQ1YiLCJkaXNwbGF5TmFtZSIsImltYWdlRGF0YSIsInF1YWRXaWR0aCIsInRyaXBsZVdpZHRoIiwieCIsInkiLCJyIiwiZyIsImIiLCJmaWxsYml0cyIsImpwZWdEYXRhVXJpIiwiYnRvYSIsImVuY29kZXIiLCJzdXBwb3J0SnBlZyIsInciLCJoIiwiZnJhZ2VtZW50IiwiZ2V0Q29udGV4dCIsImdldEltYWdlRGF0YSIsIkJMQU5LIiwibW9kaWZpZWQiLCJpbWciLCJfbWV0YXMiLCJlcnJvciIsIl9pbWciLCJzcmMiLCJfY2FudmFzIiwiX3Jlc2l6ZSIsInMiLCJjdnMiLCJpdyIsIm5hdHVyYWxXaWR0aCIsImloIiwibmF0dXJhbEhlaWdodCIsIm9yaWVudGF0aW9uIiwiZ2V0T3JpZW50YXRpb24iLCJfcm90YXRlMk9yaWVudGFpb24iLCJfcmVuZGVySW1hZ2VUb0NhbnZhcyIsImNsZWFyUmVjdCIsInNjYWxlIiwidHJhbnNsYXRlIiwicm90YXRlIiwiUEkiLCJkcmF3SW1hZ2UiLCJkZXRlY3RWZXJ0aWNhbFNxdWFzaCIsInN5IiwiZXkiLCJweSIsImFscGhhIiwicmF0aW8iLCJ2ZXJ0U3F1YXNoUmF0aW8iLCJkZXRlY3RTdWJzYW1wbGluZyIsInN1YnNhbXBsZWQiLCJkb1NxdWFzaCIsImQiLCJkeSIsInRtcENhbnZhcyIsInRtcEN0eCIsImR3IiwiZGgiLCJzeCIsImR4Iiwic2F2ZSIsInJlc3RvcmUiLCJfc3RhdHVzIiwiX3Jlc3BvbnNlIiwieGhyIiwiX2luaXRBamF4IiwiYmluYXJ5IiwicGFyYW0iLCJGb3JtRGF0YSIsIm9wZW4iLCJfc2V0UmVxdWVzdEhlYWRlciIsIm92ZXJyaWRlTWltZVR5cGUiLCJfcGFyc2VKc29uIiwiX3hociIsIm9ucHJvZ3Jlc3MiLCJvbnJlYWR5c3RhdGVjaGFuZ2UiLCJYTUxIdHRwUmVxdWVzdCIsIlhEb21haW5SZXF1ZXN0IiwibGVuZ3RoQ29tcHV0YWJsZSIsInJlYWR5U3RhdGUiLCJyZXNwb25zZVRleHQiLCJqc29uIiwiSlNPTiIsImV4IiwiRmxhc2hSdW50aW1lIiwiYWRkMzIiLCJhIiwiY21uIiwicSIsImZmIiwiZ2ciLCJoaCIsImlpIiwibWQ1Y3ljbGUiLCJtZDVibGsiLCJtZDVibGtzIiwibWQ1YmxrX2FycmF5IiwibWQ1MSIsInRhaWwiLCJ0bXAiLCJsbyIsImhpIiwibWQ1MV9hcnJheSIsImhleF9jaHIiLCJyaGV4IiwiaGV4IiwiU3BhcmtNRDUiLCJsc3ciLCJtc3ciLCJ1bmVzY2FwZSIsImVuY29kZVVSSUNvbXBvbmVudCIsImFwcGVuZEJpbmFyeSIsImNvbnRlbnRzIiwiX2J1ZmYiLCJfbGVuZ3RoIiwiX3N0YXRlIiwicmF3IiwiYnVmZiIsIl9maW5pc2giLCJoYXNoQmluYXJ5IiwiY29udGVudCIsIl9jb25jYXRBcnJheUJ1ZmZlciIsImZpcnN0Iiwic2Vjb25kIiwiZmlyc3RMZW5ndGgiLCJzcGFyayIsImJsb2JTbGljZSIsImxvYWROZXh0Iiwib25sb2FkZW5kIiwiZ2V0Rmxhc2hWZXJzaW9uIiwicGx1Z2lucyIsImRlc2NyaXB0aW9uIiwiQWN0aXZlWE9iamVjdCIsIkdldFZhcmlhYmxlIiwiZXgyIiwiY2xpZW50cyIsImpzcmVjaXZlciIsImZsYXNoRXhlYyIsImV2dCIsImZsYXNoIiwiZ2V0Rmxhc2giLCJfZmxhc2giLCJjb3B5IiwidGl0bGUiLCJfcmVzcG9uc2VKc29uIiwidXJsIiwiZm9yY2VVUkxTdHJlYW0iLCJtaW1lVHlwZSIsInBlcmNlbnQiLCJyZWFkQm9keSIsImxvZ1VybCIsInByb2R1Y3QiLCJsb2NhdGlvbiIsImhvc3RuYW1lIiwiYmFzZSIsImR2IiwibWFzdGVyIiwib25saW5lIiwiY29kZSIsImNfZXJyb3JfY29kZSIsImNfcmVhc29uIiwiY19jb3VudCIsImNfc2l6ZSIsImNfdXNhZ2UiLCJwcmVzZXQiXSwibWFwcGluZ3MiOiI7Ozs7Ozs7QUFBQTs7QUFFQTtBQUNBOzs7OztBQUtBLENBQUMsVUFBVUEsSUFBVixFQUFnQkMsT0FBaEIsRUFBMEI7QUFDdkIsUUFBSUMsVUFBVSxFQUFkOzs7QUFFSTtBQUNBO0FBQ0FDLGVBQVcsU0FBWEEsUUFBVyxDQUFVQyxJQUFWLEVBQWdCQyxRQUFoQixFQUEyQjtBQUNsQyxZQUFJQyxJQUFKLEVBQVVDLEdBQVYsRUFBZUMsQ0FBZjs7QUFFQTtBQUNBLFlBQUssT0FBT0osSUFBUCxLQUFnQixRQUFyQixFQUFnQztBQUM1QixtQkFBT0ssVUFBV0wsSUFBWCxDQUFQO0FBQ0gsU0FGRCxNQUVPO0FBQ0hFLG1CQUFPLEVBQVA7QUFDQSxpQkFBS0MsTUFBTUgsS0FBS00sTUFBWCxFQUFtQkYsSUFBSSxDQUE1QixFQUErQkEsSUFBSUQsR0FBbkMsRUFBd0NDLEdBQXhDLEVBQThDO0FBQzFDRixxQkFBS0ssSUFBTCxDQUFXRixVQUFXTCxLQUFNSSxDQUFOLENBQVgsQ0FBWDtBQUNIOztBQUVELG1CQUFPSCxTQUFTTyxLQUFULENBQWdCLElBQWhCLEVBQXNCTixJQUF0QixDQUFQO0FBQ0g7QUFDSixLQWxCTDs7O0FBb0JJO0FBQ0FPLGNBQVUsU0FBVkEsT0FBVSxDQUFVQyxFQUFWLEVBQWNWLElBQWQsRUFBb0JILE9BQXBCLEVBQThCO0FBQ3BDLFlBQUtjLFVBQVVMLE1BQVYsS0FBcUIsQ0FBMUIsRUFBOEI7QUFD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UEwsQ0FPUSxhQVBSLEVBT3VCLFVBQVNnSyxJQUFULEVBQWVtRCxNQUFmLEVBQXVCO0FBQ3RDZ0YseUJBQUs7QUFDRDVSLDhCQUFNLENBREw7QUFFRHl6QixzQ0FBYyxjQUZiO0FBR0RDLGtDQUFVLEtBQUs5bUI7QUFIZCxxQkFBTDtBQUtILGlCQWJMLEVBY0tuTixFQWRMLENBY1EsZ0JBZFIsRUFjMEIsVUFBU2dLLElBQVQsRUFBZTtBQUNqQ3VNO0FBQ0E3WCw0QkFBUXNMLEtBQUt0TCxJQUFiO0FBQ0gsaUJBakJMLEVBa0JJc0IsRUFsQkosQ0FrQk8sZ0JBbEJQLEVBa0J5QixZQUFXO0FBQzVCbVMseUJBQUs7QUFDRCtoQixpQ0FBUzNkLEtBRFI7QUFFRDRkLGdDQUFRejFCO0FBRlAscUJBQUw7QUFJQTZYLDRCQUFRN1gsT0FBTyxDQUFmO0FBQ0gsaUJBeEJMOztBQTBCQXlULHFCQUFLO0FBQ0RpaUIsNkJBQVM7QUFEUixpQkFBTDtBQUdIO0FBckNvQixTQUFsQixDQUFQO0FBdUNILEtBekVEO0FBMEVBOzs7QUFHQTc1QixXQUFPLGFBQVAsRUFBcUIsQ0FDakIsWUFEaUIsRUFFakIsYUFGaUIsQ0FBckIsRUFHRyxVQUFVODVCLE1BQVYsRUFBbUI7QUFDbEIsZUFBT0EsTUFBUDtBQUNILEtBTEQ7QUFNQSxXQUFPMTVCLFFBQVEsYUFBUixDQUFQO0FBQ0gsQ0FsOFBELEUiLCJmaWxlIjoiNjYuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvKiEgV2ViVXBsb2FkZXIgMC4xLjUgKi9cblxuLyogZXNsaW50LWRpc2FibGUgKi9cbi8qKlxuICogQGZpbGVPdmVydmlldyDorqnlhoXpg6jlkITkuKrpg6jku7bnmoTku6PnoIHlj6/ku6XnlKhbYW1kXShodHRwczovL2dpdGh1Yi5jb20vYW1kanMvYW1kanMtYXBpL3dpa2kvQU1EKeaooeWdl+WumuS5ieaWueW8j+e7hOe7h+i1t+adpeOAglxuICpcbiAqIEFNRCBBUEkg5YaF6YOo55qE566A5Y2V5LiN5a6M5YWo5a6e546w77yM6K+35b+955Wl44CC5Y+q5pyJ5b2TV2ViVXBsb2FkZXLooqvlkIjlubbmiJDkuIDkuKrmlofku7bnmoTml7blgJnmiY3kvJrlvJXlhaXjgIJcbiAqL1xuKGZ1bmN0aW9uKCByb290LCBmYWN0b3J5ICkge1xuICAgIHZhciBtb2R1bGVzID0ge30sXG5cbiAgICAgICAgLy8g5YaF6YOocmVxdWlyZSwg566A5Y2V5LiN5a6M5YWo5a6e546w44CCXG4gICAgICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9hbWRqcy9hbWRqcy1hcGkvd2lraS9yZXF1aXJlXG4gICAgICAgIF9yZXF1aXJlID0gZnVuY3Rpb24oIGRlcHMsIGNhbGxiYWNrICkge1xuICAgICAgICAgICAgdmFyIGFyZ3MsIGxlbiwgaTtcblxuICAgICAgICAgICAgLy8g5aaC5p6cZGVwc+S4jeaYr+aVsOe7hO+8jOWImeebtOaOpei/lOWbnuaMh+Wumm1vZHVsZVxuICAgICAgICAgICAgaWYgKCB0eXBlb2YgZGVwcyA9PT0gJ3N0cmluZycgKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGdldE1vZHVsZSggZGVwcyApO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBhcmdzID0gW107XG4gICAgICAgICAgICAgICAgZm9yKCBsZW4gPSBkZXBzLmxlbmd0aCwgaSA9IDA7IGkgPCBsZW47IGkrKyApIHtcbiAgICAgICAgICAgICAgICAgICAgYXJncy5wdXNoKCBnZXRNb2R1bGUoIGRlcHNbIGkgXSApICk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcmV0dXJuIGNhbGxiYWNrLmFwcGx5KCBudWxsLCBhcmdzICk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgLy8g5YaF6YOoZGVmaW5l77yM5pqC5pe25LiN5pSv5oyB5LiN5oyH5a6aaWQuXG4gICAgICAgIF9kZWZpbmUgPSBmdW5jdGlvbiggaWQsIGRlcHMsIGZhY3RvcnkgKSB7XG4gICAgICAgICAgICBpZiAoIGFyZ3VtZW50cy5sZW5ndGggPT09IDIgKSB7XG4gICAgICAgICAgICAgICAgZmFjdG9yeSA9IGRlcHM7XG4gICAgICAgICAgICAgICAgZGVwcyA9IG51bGw7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIF9yZXF1aXJlKCBkZXBzIHx8IFtdLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICBzZXRNb2R1bGUoIGlkLCBmYWN0b3J5LCBhcmd1bWVudHMgKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8vIOiuvue9rm1vZHVsZSwg5YW85a65Q29tbW9uSnPlhpnms5XjgIJcbiAgICAgICAgc2V0TW9kdWxlID0gZnVuY3Rpb24oIGlkLCBmYWN0b3J5LCBhcmdzICkge1xuICAgICAgICAgICAgdmFyIG1vZHVsZSA9IHtcbiAgICAgICAgICAgICAgICAgICAgZXhwb3J0czogZmFjdG9yeVxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgcmV0dXJuZWQ7XG5cbiAgICAgICAgICAgIGlmICggdHlwZW9mIGZhY3RvcnkgPT09ICdmdW5jdGlvbicgKSB7XG4gICAgICAgICAgICAgICAgYXJncy5sZW5ndGggfHwgKGFyZ3MgPSBbIF9yZXF1aXJlLCBtb2R1bGUuZXhwb3J0cywgbW9kdWxlIF0pO1xuICAgICAgICAgICAgICAgIHJldHVybmVkID0gZmFjdG9yeS5hcHBseSggbnVsbCwgYXJncyApO1xuICAgICAgICAgICAgICAgIHJldHVybmVkICE9PSB1bmRlZmluZWQgJiYgKG1vZHVsZS5leHBvcnRzID0gcmV0dXJuZWQpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBtb2R1bGVzWyBpZCBdID0gbW9kdWxlLmV4cG9ydHM7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLy8g5qC55o2uaWTojrflj5Ztb2R1bGVcbiAgICAgICAgZ2V0TW9kdWxlID0gZnVuY3Rpb24oIGlkICkge1xuICAgICAgICAgICAgdmFyIG1vZHVsZSA9IG1vZHVsZXNbIGlkIF0gfHwgcm9vdFsgaWQgXTtcblxuICAgICAgICAgICAgaWYgKCAhbW9kdWxlICkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvciggJ2AnICsgaWQgKyAnYCBpcyB1bmRlZmluZWQnICk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBtb2R1bGU7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLy8g5bCG5omA5pyJbW9kdWxlc++8jOWwhui3r+W+hGlkc+ijheaNouaIkOWvueixoeOAglxuICAgICAgICBleHBvcnRzVG8gPSBmdW5jdGlvbiggb2JqICkge1xuICAgICAgICAgICAgdmFyIGtleSwgaG9zdCwgcGFydHMsIHBhcnQsIGxhc3QsIHVjRmlyc3Q7XG5cbiAgICAgICAgICAgIC8vIG1ha2UgdGhlIGZpcnN0IGNoYXJhY3RlciB1cHBlciBjYXNlLlxuICAgICAgICAgICAgdWNGaXJzdCA9IGZ1bmN0aW9uKCBzdHIgKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHN0ciAmJiAoc3RyLmNoYXJBdCggMCApLnRvVXBwZXJDYXNlKCkgKyBzdHIuc3Vic3RyKCAxICkpO1xuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgZm9yICgga2V5IGluIG1vZHVsZXMgKSB7XG4gICAgICAgICAgICAgICAgaG9zdCA9IG9iajtcblxuICAgICAgICAgICAgICAgIGlmICggIW1vZHVsZXMuaGFzT3duUHJvcGVydHkoIGtleSApICkge1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBwYXJ0cyA9IGtleS5zcGxpdCgnLycpO1xuICAgICAgICAgICAgICAgIGxhc3QgPSB1Y0ZpcnN0KCBwYXJ0cy5wb3AoKSApO1xuXG4gICAgICAgICAgICAgICAgd2hpbGUoIChwYXJ0ID0gdWNGaXJzdCggcGFydHMuc2hpZnQoKSApKSApIHtcbiAgICAgICAgICAgICAgICAgICAgaG9zdFsgcGFydCBdID0gaG9zdFsgcGFydCBdIHx8IHt9O1xuICAgICAgICAgICAgICAgICAgICBob3N0ID0gaG9zdFsgcGFydCBdO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGhvc3RbIGxhc3QgXSA9IG1vZHVsZXNbIGtleSBdO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gb2JqO1xuICAgICAgICB9LFxuXG4gICAgICAgIG1ha2VFeHBvcnQgPSBmdW5jdGlvbiggZG9sbGFyICkge1xuICAgICAgICAgICAgcm9vdC5fX2RvbGxhciA9IGRvbGxhcjtcblxuICAgICAgICAgICAgLy8gZXhwb3J0cyBldmVyeSBtb2R1bGUuXG4gICAgICAgICAgICByZXR1cm4gZXhwb3J0c1RvKCBmYWN0b3J5KCByb290LCBfZGVmaW5lLCBfcmVxdWlyZSApICk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgb3JpZ2luO1xuXG4gICAgaWYgKCB0eXBlb2YgbW9kdWxlID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgbW9kdWxlLmV4cG9ydHMgPT09ICdvYmplY3QnICkge1xuXG4gICAgICAgIC8vIEZvciBDb21tb25KUyBhbmQgQ29tbW9uSlMtbGlrZSBlbnZpcm9ubWVudHMgd2hlcmUgYSBwcm9wZXIgd2luZG93IGlzIHByZXNlbnQsXG4gICAgICAgIG1vZHVsZS5leHBvcnRzID0gbWFrZUV4cG9ydCgpO1xuICAgIH0gZWxzZSBpZiAoIHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCApIHtcblxuICAgICAgICAvLyBBbGxvdyB1c2luZyB0aGlzIGJ1aWx0IGxpYnJhcnkgYXMgYW4gQU1EIG1vZHVsZVxuICAgICAgICAvLyBpbiBhbm90aGVyIHByb2plY3QuIFRoYXQgb3RoZXIgcHJvamVjdCB3aWxsIG9ubHlcbiAgICAgICAgLy8gc2VlIHRoaXMgQU1EIGNhbGwsIG5vdCB0aGUgaW50ZXJuYWwgbW9kdWxlcyBpblxuICAgICAgICAvLyB0aGUgY2xvc3VyZSBiZWxvdy5cbiAgICAgICAgZGVmaW5lKFsgJ2pxdWVyeScgXSwgbWFrZUV4cG9ydCApO1xuICAgIH0gZWxzZSB7XG5cbiAgICAgICAgLy8gQnJvd3NlciBnbG9iYWxzIGNhc2UuIEp1c3QgYXNzaWduIHRoZVxuICAgICAgICAvLyByZXN1bHQgdG8gYSBwcm9wZXJ0eSBvbiB0aGUgZ2xvYmFsLlxuICAgICAgICBvcmlnaW4gPSByb290LldlYlVwbG9hZGVyO1xuICAgICAgICByb290LldlYlVwbG9hZGVyID0gbWFrZUV4cG9ydCgpO1xuICAgICAgICByb290LldlYlVwbG9hZGVyLm5vQ29uZmxpY3QgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHJvb3QuV2ViVXBsb2FkZXIgPSBvcmlnaW47XG4gICAgICAgIH07XG4gICAgfVxufSkoIHdpbmRvdywgZnVuY3Rpb24oIHdpbmRvdywgZGVmaW5lLCByZXF1aXJlICkge1xuXG5cbiAgICAvKipcbiAgICAgKiBAZmlsZU92ZXJ2aWV3IGpRdWVyeSBvciBaZXB0b1xuICAgICAqL1xuICAgIGRlZmluZSgnZG9sbGFyLXRoaXJkJyxbXSxmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyICQgPSB3aW5kb3cuX19kb2xsYXIgfHwgd2luZG93LmpRdWVyeSB8fCB3aW5kb3cuWmVwdG87XG4gICAgXG4gICAgICAgIGlmICggISQgKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2pRdWVyeSBvciBaZXB0byBub3QgZm91bmQhJyk7XG4gICAgICAgIH1cbiAgICBcbiAgICAgICAgcmV0dXJuICQ7XG4gICAgfSk7XG4gICAgLyoqXG4gICAgICogQGZpbGVPdmVydmlldyBEb20g5pON5L2c55u45YWzXG4gICAgICovXG4gICAgZGVmaW5lKCdkb2xsYXInLFtcbiAgICAgICAgJ2RvbGxhci10aGlyZCdcbiAgICBdLCBmdW5jdGlvbiggXyApIHtcbiAgICAgICAgcmV0dXJuIF87XG4gICAgfSk7XG4gICAgLyoqXG4gICAgICogQGZpbGVPdmVydmlldyDkvb/nlKhqUXVlcnnnmoRQcm9taXNlXG4gICAgICovXG4gICAgZGVmaW5lKCdwcm9taXNlLXRoaXJkJyxbXG4gICAgICAgICdkb2xsYXInXG4gICAgXSwgZnVuY3Rpb24oICQgKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBEZWZlcnJlZDogJC5EZWZlcnJlZCxcbiAgICAgICAgICAgIHdoZW46ICQud2hlbixcbiAgICBcbiAgICAgICAgICAgIGlzUHJvbWlzZTogZnVuY3Rpb24oIGFueXRoaW5nICkge1xuICAgICAgICAgICAgICAgIHJldHVybiBhbnl0aGluZyAmJiB0eXBlb2YgYW55dGhpbmcudGhlbiA9PT0gJ2Z1bmN0aW9uJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICB9KTtcbiAgICAvKipcbiAgICAgKiBAZmlsZU92ZXJ2aWV3IFByb21pc2UvQStcbiAgICAgKi9cbiAgICBkZWZpbmUoJ3Byb21pc2UnLFtcbiAgICAgICAgJ3Byb21pc2UtdGhpcmQnXG4gICAgXSwgZnVuY3Rpb24oIF8gKSB7XG4gICAgICAgIHJldHVybiBfO1xuICAgIH0pO1xuICAgIC8qKlxuICAgICAqIEBmaWxlT3ZlcnZpZXcg5Z+656GA57G75pa55rOV44CCXG4gICAgICovXG4gICAgXG4gICAgLyoqXG4gICAgICogV2ViIFVwbG9hZGVy5YaF6YOo57G755qE6K+m57uG6K+05piO77yM5Lul5LiL5o+Q5Y+K55qE5Yqf6IO957G777yM6YO95Y+v5Lul5ZyoYFdlYlVwbG9hZGVyYOi/meS4quWPmOmHj+S4reiuv+mXruWIsOOAglxuICAgICAqXG4gICAgICogQXMgeW91IGtub3csIFdlYiBVcGxvYWRlcueahOavj+S4quaWh+S7tumDveaYr+eUqOi/h1tBTURdKGh0dHBzOi8vZ2l0aHViLmNvbS9hbWRqcy9hbWRqcy1hcGkvd2lraS9BTUQp6KeE6IyD5Lit55qEYGRlZmluZWDnu4Tnu4fotbfmnaXnmoQsIOavj+S4qk1vZHVsZemDveS8muacieS4qm1vZHVsZSBpZC5cbiAgICAgKiDpu5jorqRtb2R1bGUgaWTkuLror6Xmlofku7bnmoTot6/lvoTvvIzogIzmraTot6/lvoTlsIbkvJrovazljJbmiJDlkI3lrZfnqbrpl7TlrZjmlL7lnKhXZWJVcGxvYWRlcuS4reOAguWmgu+8mlxuICAgICAqXG4gICAgICogKiBtb2R1bGUgYGJhc2Vg77yaV2ViVXBsb2FkZXIuQmFzZVxuICAgICAqICogbW9kdWxlIGBmaWxlYDogV2ViVXBsb2FkZXIuRmlsZVxuICAgICAqICogbW9kdWxlIGBsaWIvZG5kYDogV2ViVXBsb2FkZXIuTGliLkRuZFxuICAgICAqICogbW9kdWxlIGBydW50aW1lL2h0bWw1L2RuZGA6IFdlYlVwbG9hZGVyLlJ1bnRpbWUuSHRtbDUuRG5kXG4gICAgICpcbiAgICAgKlxuICAgICAqIOS7peS4i+aWh+aho+S4reWvueexu+eahOS9v+eUqOWPr+iDveecgeeVpeaOieS6hmBXZWJVcGxvYWRlcmDliY3nvIDjgIJcbiAgICAgKiBAbW9kdWxlIFdlYlVwbG9hZGVyXG4gICAgICogQHRpdGxlIFdlYlVwbG9hZGVyIEFQSeaWh+aho1xuICAgICAqL1xuICAgIGRlZmluZSgnYmFzZScsW1xuICAgICAgICAnZG9sbGFyJyxcbiAgICAgICAgJ3Byb21pc2UnXG4gICAgXSwgZnVuY3Rpb24oICQsIHByb21pc2UgKSB7XG4gICAgXG4gICAgICAgIHZhciBub29wID0gZnVuY3Rpb24oKSB7fSxcbiAgICAgICAgICAgIGNhbGwgPSBGdW5jdGlvbi5jYWxsO1xuICAgIFxuICAgICAgICAvLyBodHRwOi8vanNwZXJmLmNvbS91bmN1cnJ5dGhpc1xuICAgICAgICAvLyDlj43np5Hph4zljJZcbiAgICAgICAgZnVuY3Rpb24gdW5jdXJyeVRoaXMoIGZuICkge1xuICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBjYWxsLmFwcGx5KCBmbiwgYXJndW1lbnRzICk7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgXG4gICAgICAgIGZ1bmN0aW9uIGJpbmRGbiggZm4sIGNvbnRleHQgKSB7XG4gICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZuLmFwcGx5KCBjb250ZXh0LCBhcmd1bWVudHMgKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICBcbiAgICAgICAgZnVuY3Rpb24gY3JlYXRlT2JqZWN0KCBwcm90byApIHtcbiAgICAgICAgICAgIHZhciBmO1xuICAgIFxuICAgICAgICAgICAgaWYgKCBPYmplY3QuY3JlYXRlICkge1xuICAgICAgICAgICAgICAgIHJldHVybiBPYmplY3QuY3JlYXRlKCBwcm90byApO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBmID0gZnVuY3Rpb24oKSB7fTtcbiAgICAgICAgICAgICAgICBmLnByb3RvdHlwZSA9IHByb3RvO1xuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgZigpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgXG4gICAgXG4gICAgICAgIC8qKlxuICAgICAgICAgKiDln7rnoYDnsbvvvIzmj5DkvpvkuIDkupvnroDljZXluLjnlKjnmoTmlrnms5XjgIJcbiAgICAgICAgICogQGNsYXNzIEJhc2VcbiAgICAgICAgICovXG4gICAgICAgIHJldHVybiB7XG4gICAgXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIEBwcm9wZXJ0eSB7U3RyaW5nfSB2ZXJzaW9uIOW9k+WJjeeJiOacrOWPt+OAglxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICB2ZXJzaW9uOiAnMC4xLjUnLFxuICAgIFxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBAcHJvcGVydHkge2pRdWVyeXxaZXB0b30gJCDlvJXnlKjkvp3otZbnmoRqUXVlcnnmiJbogIVaZXB0b+WvueixoeOAglxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICAkOiAkLFxuICAgIFxuICAgICAgICAgICAgRGVmZXJyZWQ6IHByb21pc2UuRGVmZXJyZWQsXG4gICAgXG4gICAgICAgICAgICBpc1Byb21pc2U6IHByb21pc2UuaXNQcm9taXNlLFxuICAgIFxuICAgICAgICAgICAgd2hlbjogcHJvbWlzZS53aGVuLFxuICAgIFxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBAZGVzY3JpcHRpb24gIOeugOWNleeahOa1j+iniOWZqOajgOafpee7k+aenOOAglxuICAgICAgICAgICAgICpcbiAgICAgICAgICAgICAqICogYHdlYmtpdGAgIHdlYmtpdOeJiOacrOWPt++8jOWmguaenOa1j+iniOWZqOS4uumdnndlYmtpdOWGheaguO+8jOatpOWxnuaAp+S4umB1bmRlZmluZWRg44CCXG4gICAgICAgICAgICAgKiAqIGBjaHJvbWVgICBjaHJvbWXmtY/op4jlmajniYjmnKzlj7fvvIzlpoLmnpzmtY/op4jlmajkuLpjaHJvbWXvvIzmraTlsZ7mgKfkuLpgdW5kZWZpbmVkYOOAglxuICAgICAgICAgICAgICogKiBgaWVgICBpZea1j+iniOWZqOeJiOacrOWPt++8jOWmguaenOa1j+iniOWZqOS4uumdnmll77yM5q2k5bGe5oCn5Li6YHVuZGVmaW5lZGDjgIIqKuaaguS4jeaUr+aMgWllMTArKipcbiAgICAgICAgICAgICAqICogYGZpcmVmb3hgICBmaXJlZm945rWP6KeI5Zmo54mI5pys5Y+377yM5aaC5p6c5rWP6KeI5Zmo5Li66Z2eZmlyZWZveO+8jOatpOWxnuaAp+S4umB1bmRlZmluZWRg44CCXG4gICAgICAgICAgICAgKiAqIGBzYWZhcmlgICBzYWZhcmnmtY/op4jlmajniYjmnKzlj7fvvIzlpoLmnpzmtY/op4jlmajkuLrpnZ5zYWZhcmnvvIzmraTlsZ7mgKfkuLpgdW5kZWZpbmVkYOOAglxuICAgICAgICAgICAgICogKiBgb3BlcmFgICBvcGVyYea1j+iniOWZqOeJiOacrOWPt++8jOWmguaenOa1j+iniOWZqOS4uumdnm9wZXJh77yM5q2k5bGe5oCn5Li6YHVuZGVmaW5lZGDjgIJcbiAgICAgICAgICAgICAqXG4gICAgICAgICAgICAgKiBAcHJvcGVydHkge09iamVjdH0gW2Jyb3dzZXJdXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGJyb3dzZXI6IChmdW5jdGlvbiggdWEgKSB7XG4gICAgICAgICAgICAgICAgdmFyIHJldCA9IHt9LFxuICAgICAgICAgICAgICAgICAgICB3ZWJraXQgPSB1YS5tYXRjaCggL1dlYktpdFxcLyhbXFxkLl0rKS8gKSxcbiAgICAgICAgICAgICAgICAgICAgY2hyb21lID0gdWEubWF0Y2goIC9DaHJvbWVcXC8oW1xcZC5dKykvICkgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgIHVhLm1hdGNoKCAvQ3JpT1NcXC8oW1xcZC5dKykvICksXG4gICAgXG4gICAgICAgICAgICAgICAgICAgIGllID0gdWEubWF0Y2goIC9NU0lFXFxzKFtcXGRcXC5dKykvICkgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgIHVhLm1hdGNoKCAvKD86dHJpZGVudCkoPzouKnJ2OihbXFx3Ll0rKSk/L2kgKSxcbiAgICAgICAgICAgICAgICAgICAgZmlyZWZveCA9IHVhLm1hdGNoKCAvRmlyZWZveFxcLyhbXFxkLl0rKS8gKSxcbiAgICAgICAgICAgICAgICAgICAgc2FmYXJpID0gdWEubWF0Y2goIC9TYWZhcmlcXC8oW1xcZC5dKykvICksXG4gICAgICAgICAgICAgICAgICAgIG9wZXJhID0gdWEubWF0Y2goIC9PUFJcXC8oW1xcZC5dKykvICk7XG4gICAgXG4gICAgICAgICAgICAgICAgd2Via2l0ICYmIChyZXQud2Via2l0ID0gcGFyc2VGbG9hdCggd2Via2l0WyAxIF0gKSk7XG4gICAgICAgICAgICAgICAgY2hyb21lICYmIChyZXQuY2hyb21lID0gcGFyc2VGbG9hdCggY2hyb21lWyAxIF0gKSk7XG4gICAgICAgICAgICAgICAgaWUgJiYgKHJldC5pZSA9IHBhcnNlRmxvYXQoIGllWyAxIF0gKSk7XG4gICAgICAgICAgICAgICAgZmlyZWZveCAmJiAocmV0LmZpcmVmb3ggPSBwYXJzZUZsb2F0KCBmaXJlZm94WyAxIF0gKSk7XG4gICAgICAgICAgICAgICAgc2FmYXJpICYmIChyZXQuc2FmYXJpID0gcGFyc2VGbG9hdCggc2FmYXJpWyAxIF0gKSk7XG4gICAgICAgICAgICAgICAgb3BlcmEgJiYgKHJldC5vcGVyYSA9IHBhcnNlRmxvYXQoIG9wZXJhWyAxIF0gKSk7XG4gICAgXG4gICAgICAgICAgICAgICAgcmV0dXJuIHJldDtcbiAgICAgICAgICAgIH0pKCBuYXZpZ2F0b3IudXNlckFnZW50ICksXG4gICAgXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIEBkZXNjcmlwdGlvbiAg5pON5L2c57O757uf5qOA5p+l57uT5p6c44CCXG4gICAgICAgICAgICAgKlxuICAgICAgICAgICAgICogKiBgYW5kcm9pZGAgIOWmguaenOWcqGFuZHJvaWTmtY/op4jlmajnjq/looPkuIvvvIzmraTlgLzkuLrlr7nlupTnmoRhbmRyb2lk54mI5pys5Y+377yM5ZCm5YiZ5Li6YHVuZGVmaW5lZGDjgIJcbiAgICAgICAgICAgICAqICogYGlvc2Ag5aaC5p6c5ZyoaW9z5rWP6KeI5Zmo546v5aKD5LiL77yM5q2k5YC85Li65a+55bqU55qEaW9z54mI5pys5Y+377yM5ZCm5YiZ5Li6YHVuZGVmaW5lZGDjgIJcbiAgICAgICAgICAgICAqIEBwcm9wZXJ0eSB7T2JqZWN0fSBbb3NdXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIG9zOiAoZnVuY3Rpb24oIHVhICkge1xuICAgICAgICAgICAgICAgIHZhciByZXQgPSB7fSxcbiAgICBcbiAgICAgICAgICAgICAgICAgICAgLy8gb3N4ID0gISF1YS5tYXRjaCggL1xcKE1hY2ludG9zaFxcOyBJbnRlbCAvICksXG4gICAgICAgICAgICAgICAgICAgIGFuZHJvaWQgPSB1YS5tYXRjaCggLyg/OkFuZHJvaWQpOz9bXFxzXFwvXSsoW1xcZC5dKyk/LyApLFxuICAgICAgICAgICAgICAgICAgICBpb3MgPSB1YS5tYXRjaCggLyg/OmlQYWR8aVBvZHxpUGhvbmUpLipPU1xccyhbXFxkX10rKS8gKTtcbiAgICBcbiAgICAgICAgICAgICAgICAvLyBvc3ggJiYgKHJldC5vc3ggPSB0cnVlKTtcbiAgICAgICAgICAgICAgICBhbmRyb2lkICYmIChyZXQuYW5kcm9pZCA9IHBhcnNlRmxvYXQoIGFuZHJvaWRbIDEgXSApKTtcbiAgICAgICAgICAgICAgICBpb3MgJiYgKHJldC5pb3MgPSBwYXJzZUZsb2F0KCBpb3NbIDEgXS5yZXBsYWNlKCAvXy9nLCAnLicgKSApKTtcbiAgICBcbiAgICAgICAgICAgICAgICByZXR1cm4gcmV0O1xuICAgICAgICAgICAgfSkoIG5hdmlnYXRvci51c2VyQWdlbnQgKSxcbiAgICBcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICog5a6e546w57G75LiO57G75LmL6Ze055qE57un5om/44CCXG4gICAgICAgICAgICAgKiBAbWV0aG9kIGluaGVyaXRzXG4gICAgICAgICAgICAgKiBAZ3JhbW1hciBCYXNlLmluaGVyaXRzKCBzdXBlciApID0+IGNoaWxkXG4gICAgICAgICAgICAgKiBAZ3JhbW1hciBCYXNlLmluaGVyaXRzKCBzdXBlciwgcHJvdG9zICkgPT4gY2hpbGRcbiAgICAgICAgICAgICAqIEBncmFtbWFyIEJhc2UuaW5oZXJpdHMoIHN1cGVyLCBwcm90b3MsIHN0YXRpY3MgKSA9PiBjaGlsZFxuICAgICAgICAgICAgICogQHBhcmFtICB7Q2xhc3N9IHN1cGVyIOeItuexu1xuICAgICAgICAgICAgICogQHBhcmFtICB7T2JqZWN0IHwgRnVuY3Rpb259IFtwcm90b3NdIOWtkOexu+aIluiAheWvueixoeOAguWmguaenOWvueixoeS4reWMheWQq2NvbnN0cnVjdG9y77yM5a2Q57G75bCG5piv55So5q2k5bGe5oCn5YC844CCXG4gICAgICAgICAgICAgKiBAcGFyYW0gIHtGdW5jdGlvbn0gW3Byb3Rvcy5jb25zdHJ1Y3Rvcl0g5a2Q57G75p6E6YCg5Zmo77yM5LiN5oyH5a6a55qE6K+d5bCG5Yib5bu65Liq5Li05pe255qE55u05o6l5omn6KGM54i257G75p6E6YCg5Zmo55qE5pa55rOV44CCXG4gICAgICAgICAgICAgKiBAcGFyYW0gIHtPYmplY3R9IFtzdGF0aWNzXSDpnZnmgIHlsZ7mgKfmiJbmlrnms5XjgIJcbiAgICAgICAgICAgICAqIEByZXR1cm4ge0NsYXNzfSDov5Tlm57lrZDnsbvjgIJcbiAgICAgICAgICAgICAqIEBleGFtcGxlXG4gICAgICAgICAgICAgKiBmdW5jdGlvbiBQZXJzb24oKSB7XG4gICAgICAgICAgICAgKiAgICAgY29uc29sZS5sb2coICdTdXBlcicgKTtcbiAgICAgICAgICAgICAqIH1cbiAgICAgICAgICAgICAqIFBlcnNvbi5wcm90b3R5cGUuaGVsbG8gPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAqICAgICBjb25zb2xlLmxvZyggJ2hlbGxvJyApO1xuICAgICAgICAgICAgICogfTtcbiAgICAgICAgICAgICAqXG4gICAgICAgICAgICAgKiB2YXIgTWFuYWdlciA9IEJhc2UuaW5oZXJpdHMoIFBlcnNvbiwge1xuICAgICAgICAgICAgICogICAgIHdvcmxkOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAqICAgICAgICAgY29uc29sZS5sb2coICdXb3JsZCcgKTtcbiAgICAgICAgICAgICAqICAgICB9XG4gICAgICAgICAgICAgKiB9KTtcbiAgICAgICAgICAgICAqXG4gICAgICAgICAgICAgKiAvLyDlm6DkuLrmsqHmnInmjIflrprmnoTpgKDlmajvvIzniLbnsbvnmoTmnoTpgKDlmajlsIbkvJrmiafooYzjgIJcbiAgICAgICAgICAgICAqIHZhciBpbnN0YW5jZSA9IG5ldyBNYW5hZ2VyKCk7ICAgIC8vID0+IFN1cGVyXG4gICAgICAgICAgICAgKlxuICAgICAgICAgICAgICogLy8g57un5om/5a2Q54i257G755qE5pa55rOVXG4gICAgICAgICAgICAgKiBpbnN0YW5jZS5oZWxsbygpOyAgICAvLyA9PiBoZWxsb1xuICAgICAgICAgICAgICogaW5zdGFuY2Uud29ybGQoKTsgICAgLy8gPT4gV29ybGRcbiAgICAgICAgICAgICAqXG4gICAgICAgICAgICAgKiAvLyDlrZDnsbvnmoRfX3N1cGVyX1/lsZ7mgKfmjIflkJHniLbnsbtcbiAgICAgICAgICAgICAqIGNvbnNvbGUubG9nKCBNYW5hZ2VyLl9fc3VwZXJfXyA9PT0gUGVyc29uICk7ICAgIC8vID0+IHRydWVcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgaW5oZXJpdHM6IGZ1bmN0aW9uKCBTdXBlciwgcHJvdG9zLCBzdGF0aWNQcm90b3MgKSB7XG4gICAgICAgICAgICAgICAgdmFyIGNoaWxkO1xuICAgIFxuICAgICAgICAgICAgICAgIGlmICggdHlwZW9mIHByb3RvcyA9PT0gJ2Z1bmN0aW9uJyApIHtcbiAgICAgICAgICAgICAgICAgICAgY2hpbGQgPSBwcm90b3M7XG4gICAgICAgICAgICAgICAgICAgIHByb3RvcyA9IG51bGw7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmICggcHJvdG9zICYmIHByb3Rvcy5oYXNPd25Qcm9wZXJ0eSgnY29uc3RydWN0b3InKSApIHtcbiAgICAgICAgICAgICAgICAgICAgY2hpbGQgPSBwcm90b3MuY29uc3RydWN0b3I7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgY2hpbGQgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBTdXBlci5hcHBseSggdGhpcywgYXJndW1lbnRzICk7XG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgfVxuICAgIFxuICAgICAgICAgICAgICAgIC8vIOWkjeWItumdmeaAgeaWueazlVxuICAgICAgICAgICAgICAgICQuZXh0ZW5kKCB0cnVlLCBjaGlsZCwgU3VwZXIsIHN0YXRpY1Byb3RvcyB8fCB7fSApO1xuICAgIFxuICAgICAgICAgICAgICAgIC8qIGpzaGludCBjYW1lbGNhc2U6IGZhbHNlICovXG4gICAgXG4gICAgICAgICAgICAgICAgLy8g6K6p5a2Q57G755qEX19zdXBlcl9f5bGe5oCn5oyH5ZCR54i257G744CCXG4gICAgICAgICAgICAgICAgY2hpbGQuX19zdXBlcl9fID0gU3VwZXIucHJvdG90eXBlO1xuICAgIFxuICAgICAgICAgICAgICAgIC8vIOaehOW7uuWOn+Wei++8jOa3u+WKoOWOn+Wei+aWueazleaIluWxnuaAp+OAglxuICAgICAgICAgICAgICAgIC8vIOaaguaXtueUqE9iamVjdC5jcmVhdGXlrp7njrDjgIJcbiAgICAgICAgICAgICAgICBjaGlsZC5wcm90b3R5cGUgPSBjcmVhdGVPYmplY3QoIFN1cGVyLnByb3RvdHlwZSApO1xuICAgICAgICAgICAgICAgIHByb3RvcyAmJiAkLmV4dGVuZCggdHJ1ZSwgY2hpbGQucHJvdG90eXBlLCBwcm90b3MgKTtcbiAgICBcbiAgICAgICAgICAgICAgICByZXR1cm4gY2hpbGQ7XG4gICAgICAgICAgICB9LFxuICAgIFxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiDkuIDkuKrkuI3lgZrku7vkvZXkuovmg4XnmoTmlrnms5XjgILlj6/ku6XnlKjmnaXotYvlgLznu5npu5jorqTnmoRjYWxsYmFjay5cbiAgICAgICAgICAgICAqIEBtZXRob2Qgbm9vcFxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBub29wOiBub29wLFxuICAgIFxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiDov5Tlm57kuIDkuKrmlrDnmoTmlrnms5XvvIzmraTmlrnms5XlsIblt7LmjIflrprnmoRgY29udGV4dGDmnaXmiafooYzjgIJcbiAgICAgICAgICAgICAqIEBncmFtbWFyIEJhc2UuYmluZEZuKCBmbiwgY29udGV4dCApID0+IEZ1bmN0aW9uXG4gICAgICAgICAgICAgKiBAbWV0aG9kIGJpbmRGblxuICAgICAgICAgICAgICogQGV4YW1wbGVcbiAgICAgICAgICAgICAqIHZhciBkb1NvbWV0aGluZyA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICogICAgICAgICBjb25zb2xlLmxvZyggdGhpcy5uYW1lICk7XG4gICAgICAgICAgICAgKiAgICAgfSxcbiAgICAgICAgICAgICAqICAgICBvYmogPSB7XG4gICAgICAgICAgICAgKiAgICAgICAgIG5hbWU6ICdPYmplY3QgTmFtZSdcbiAgICAgICAgICAgICAqICAgICB9LFxuICAgICAgICAgICAgICogICAgIGFsaWFzRm4gPSBCYXNlLmJpbmQoIGRvU29tZXRoaW5nLCBvYmogKTtcbiAgICAgICAgICAgICAqXG4gICAgICAgICAgICAgKiAgYWxpYXNGbigpOyAgICAvLyA9PiBPYmplY3QgTmFtZVxuICAgICAgICAgICAgICpcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgYmluZEZuOiBiaW5kRm4sXG4gICAgXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIOW8leeUqENvbnNvbGUubG9n5aaC5p6c5a2Y5Zyo55qE6K+d77yM5ZCm5YiZ5byV55So5LiA5LiqW+epuuWHveaVsG5vb3BdKCNXZWJVcGxvYWRlcjpCYXNlLm5vb3Ap44CCXG4gICAgICAgICAgICAgKiBAZ3JhbW1hciBCYXNlLmxvZyggYXJncy4uLiApID0+IHVuZGVmaW5lZFxuICAgICAgICAgICAgICogQG1ldGhvZCBsb2dcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgbG9nOiAoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgaWYgKCB3aW5kb3cuY29uc29sZSApIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGJpbmRGbiggY29uc29sZS5sb2csIGNvbnNvbGUgKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5vb3A7XG4gICAgICAgICAgICB9KSgpLFxuICAgIFxuICAgICAgICAgICAgbmV4dFRpY2s6IChmdW5jdGlvbigpIHtcbiAgICBcbiAgICAgICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24oIGNiICkge1xuICAgICAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KCBjYiwgMSApO1xuICAgICAgICAgICAgICAgIH07XG4gICAgXG4gICAgICAgICAgICAgICAgLy8gQGJ1ZyDlvZPmtY/op4jlmajkuI3lnKjlvZPliY3nqpflj6Pml7blsLHlgZzkuobjgIJcbiAgICAgICAgICAgICAgICAvLyB2YXIgbmV4dCA9IHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUgfHxcbiAgICAgICAgICAgICAgICAvLyAgICAgd2luZG93LndlYmtpdFJlcXVlc3RBbmltYXRpb25GcmFtZSB8fFxuICAgICAgICAgICAgICAgIC8vICAgICB3aW5kb3cubW96UmVxdWVzdEFuaW1hdGlvbkZyYW1lIHx8XG4gICAgICAgICAgICAgICAgLy8gICAgIGZ1bmN0aW9uKCBjYiApIHtcbiAgICAgICAgICAgICAgICAvLyAgICAgICAgIHdpbmRvdy5zZXRUaW1lb3V0KCBjYiwgMTAwMCAvIDYwICk7XG4gICAgICAgICAgICAgICAgLy8gICAgIH07XG4gICAgXG4gICAgICAgICAgICAgICAgLy8gLy8gZml4OiBVbmNhdWdodCBUeXBlRXJyb3I6IElsbGVnYWwgaW52b2NhdGlvblxuICAgICAgICAgICAgICAgIC8vIHJldHVybiBiaW5kRm4oIG5leHQsIHdpbmRvdyApO1xuICAgICAgICAgICAgfSkoKSxcbiAgICBcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICog6KKrW3VuY3Vycnl0aGlzXShodHRwOi8vd3d3LjJhbGl0eS5jb20vMjAxMS8xMS91bmN1cnJ5aW5nLXRoaXMuaHRtbCnnmoTmlbDnu4RzbGljZeaWueazleOAglxuICAgICAgICAgICAgICog5bCG55So5p2l5bCG6Z2e5pWw57uE5a+56LGh6L2s5YyW5oiQ5pWw57uE5a+56LGh44CCXG4gICAgICAgICAgICAgKiBAZ3JhbW1hciBCYXNlLnNsaWNlKCB0YXJnZXQsIHN0YXJ0WywgZW5kXSApID0+IEFycmF5XG4gICAgICAgICAgICAgKiBAbWV0aG9kIHNsaWNlXG4gICAgICAgICAgICAgKiBAZXhhbXBsZVxuICAgICAgICAgICAgICogZnVuY3Rpb24gZG9Tb210aGluZygpIHtcbiAgICAgICAgICAgICAqICAgICB2YXIgYXJncyA9IEJhc2Uuc2xpY2UoIGFyZ3VtZW50cywgMSApO1xuICAgICAgICAgICAgICogICAgIGNvbnNvbGUubG9nKCBhcmdzICk7XG4gICAgICAgICAgICAgKiB9XG4gICAgICAgICAgICAgKlxuICAgICAgICAgICAgICogZG9Tb210aGluZyggJ2lnbm9yZWQnLCAnYXJnMicsICdhcmczJyApOyAgICAvLyA9PiBBcnJheSBbXCJhcmcyXCIsIFwiYXJnM1wiXVxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBzbGljZTogdW5jdXJyeVRoaXMoIFtdLnNsaWNlICksXG4gICAgXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIOeUn+aIkOWUr+S4gOeahElEXG4gICAgICAgICAgICAgKiBAbWV0aG9kIGd1aWRcbiAgICAgICAgICAgICAqIEBncmFtbWFyIEJhc2UuZ3VpZCgpID0+IFN0cmluZ1xuICAgICAgICAgICAgICogQGdyYW1tYXIgQmFzZS5ndWlkKCBwcmVmeCApID0+IFN0cmluZ1xuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBndWlkOiAoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgdmFyIGNvdW50ZXIgPSAwO1xuICAgIFxuICAgICAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiggcHJlZml4ICkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgZ3VpZCA9ICgrbmV3IERhdGUoKSkudG9TdHJpbmcoIDMyICksXG4gICAgICAgICAgICAgICAgICAgICAgICBpID0gMDtcbiAgICBcbiAgICAgICAgICAgICAgICAgICAgZm9yICggOyBpIDwgNTsgaSsrICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZ3VpZCArPSBNYXRoLmZsb29yKCBNYXRoLnJhbmRvbSgpICogNjU1MzUgKS50b1N0cmluZyggMzIgKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgIFxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gKHByZWZpeCB8fCAnd3VfJykgKyBndWlkICsgKGNvdW50ZXIrKykudG9TdHJpbmcoIDMyICk7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH0pKCksXG4gICAgXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIOagvOW8j+WMluaWh+S7tuWkp+Wwjywg6L6T5Ye65oiQ5bim5Y2V5L2N55qE5a2X56ym5LiyXG4gICAgICAgICAgICAgKiBAbWV0aG9kIGZvcm1hdFNpemVcbiAgICAgICAgICAgICAqIEBncmFtbWFyIEJhc2UuZm9ybWF0U2l6ZSggc2l6ZSApID0+IFN0cmluZ1xuICAgICAgICAgICAgICogQGdyYW1tYXIgQmFzZS5mb3JtYXRTaXplKCBzaXplLCBwb2ludExlbmd0aCApID0+IFN0cmluZ1xuICAgICAgICAgICAgICogQGdyYW1tYXIgQmFzZS5mb3JtYXRTaXplKCBzaXplLCBwb2ludExlbmd0aCwgdW5pdHMgKSA9PiBTdHJpbmdcbiAgICAgICAgICAgICAqIEBwYXJhbSB7TnVtYmVyfSBzaXplIOaWh+S7tuWkp+Wwj1xuICAgICAgICAgICAgICogQHBhcmFtIHtOdW1iZXJ9IFtwb2ludExlbmd0aD0yXSDnsr7noa7liLDnmoTlsI/mlbDngrnmlbDjgIJcbiAgICAgICAgICAgICAqIEBwYXJhbSB7QXJyYXl9IFt1bml0cz1bICdCJywgJ0snLCAnTScsICdHJywgJ1RCJyBdXSDljZXkvY3mlbDnu4TjgILku47lrZfoioLvvIzliLDljYPlrZfoioLvvIzkuIDnm7TlvoDkuIrmjIflrprjgILlpoLmnpzljZXkvY3mlbDnu4Tph4zpnaLlj6rmjIflrprkuobliLDkuoZLKOWNg+Wtl+iKginvvIzlkIzml7bmlofku7blpKflsI/lpKfkuo5NLCDmraTmlrnms5XnmoTovpPlh7rlsIbov5jmmK/mmL7npLrmiJDlpJrlsJFLLlxuICAgICAgICAgICAgICogQGV4YW1wbGVcbiAgICAgICAgICAgICAqIGNvbnNvbGUubG9nKCBCYXNlLmZvcm1hdFNpemUoIDEwMCApICk7ICAgIC8vID0+IDEwMEJcbiAgICAgICAgICAgICAqIGNvbnNvbGUubG9nKCBCYXNlLmZvcm1hdFNpemUoIDEwMjQgKSApOyAgICAvLyA9PiAxLjAwS1xuICAgICAgICAgICAgICogY29uc29sZS5sb2coIEJhc2UuZm9ybWF0U2l6ZSggMTAyNCwgMCApICk7ICAgIC8vID0+IDFLXG4gICAgICAgICAgICAgKiBjb25zb2xlLmxvZyggQmFzZS5mb3JtYXRTaXplKCAxMDI0ICogMTAyNCApICk7ICAgIC8vID0+IDEuMDBNXG4gICAgICAgICAgICAgKiBjb25zb2xlLmxvZyggQmFzZS5mb3JtYXRTaXplKCAxMDI0ICogMTAyNCAqIDEwMjQgKSApOyAgICAvLyA9PiAxLjAwR1xuICAgICAgICAgICAgICogY29uc29sZS5sb2coIEJhc2UuZm9ybWF0U2l6ZSggMTAyNCAqIDEwMjQgKiAxMDI0LCAwLCBbJ0InLCAnS0InLCAnTUInXSApICk7ICAgIC8vID0+IDEwMjRNQlxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBmb3JtYXRTaXplOiBmdW5jdGlvbiggc2l6ZSwgcG9pbnRMZW5ndGgsIHVuaXRzICkge1xuICAgICAgICAgICAgICAgIHZhciB1bml0O1xuICAgIFxuICAgICAgICAgICAgICAgIHVuaXRzID0gdW5pdHMgfHwgWyAnQicsICdLJywgJ00nLCAnRycsICdUQicgXTtcbiAgICBcbiAgICAgICAgICAgICAgICB3aGlsZSAoICh1bml0ID0gdW5pdHMuc2hpZnQoKSkgJiYgc2l6ZSA+IDEwMjQgKSB7XG4gICAgICAgICAgICAgICAgICAgIHNpemUgPSBzaXplIC8gMTAyNDtcbiAgICAgICAgICAgICAgICB9XG4gICAgXG4gICAgICAgICAgICAgICAgcmV0dXJuICh1bml0ID09PSAnQicgPyBzaXplIDogc2l6ZS50b0ZpeGVkKCBwb2ludExlbmd0aCB8fCAyICkpICtcbiAgICAgICAgICAgICAgICAgICAgICAgIHVuaXQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgfSk7XG4gICAgLyoqXG4gICAgICog5LqL5Lu25aSE55CG57G777yM5Y+v5Lul54us56uL5L2/55So77yM5Lmf5Y+v5Lul5omp5bGV57uZ5a+56LGh5L2/55So44CCXG4gICAgICogQGZpbGVPdmVydmlldyBNZWRpYXRvclxuICAgICAqL1xuICAgIGRlZmluZSgnbWVkaWF0b3InLFtcbiAgICAgICAgJ2Jhc2UnXG4gICAgXSwgZnVuY3Rpb24oIEJhc2UgKSB7XG4gICAgICAgIHZhciAkID0gQmFzZS4kLFxuICAgICAgICAgICAgc2xpY2UgPSBbXS5zbGljZSxcbiAgICAgICAgICAgIHNlcGFyYXRvciA9IC9cXHMrLyxcbiAgICAgICAgICAgIHByb3RvcztcbiAgICBcbiAgICAgICAgLy8g5qC55o2u5p2h5Lu26L+H5ruk5Ye65LqL5Lu2aGFuZGxlcnMuXG4gICAgICAgIGZ1bmN0aW9uIGZpbmRIYW5kbGVycyggYXJyLCBuYW1lLCBjYWxsYmFjaywgY29udGV4dCApIHtcbiAgICAgICAgICAgIHJldHVybiAkLmdyZXAoIGFyciwgZnVuY3Rpb24oIGhhbmRsZXIgKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGhhbmRsZXIgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICghbmFtZSB8fCBoYW5kbGVyLmUgPT09IG5hbWUpICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAoIWNhbGxiYWNrIHx8IGhhbmRsZXIuY2IgPT09IGNhbGxiYWNrIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICBoYW5kbGVyLmNiLl9jYiA9PT0gY2FsbGJhY2spICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAoIWNvbnRleHQgfHwgaGFuZGxlci5jdHggPT09IGNvbnRleHQpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICBcbiAgICAgICAgZnVuY3Rpb24gZWFjaEV2ZW50KCBldmVudHMsIGNhbGxiYWNrLCBpdGVyYXRvciApIHtcbiAgICAgICAgICAgIC8vIOS4jeaUr+aMgeWvueixoe+8jOWPquaUr+aMgeWkmuS4qmV2ZW5055So56m65qC86ZqU5byAXG4gICAgICAgICAgICAkLmVhY2goIChldmVudHMgfHwgJycpLnNwbGl0KCBzZXBhcmF0b3IgKSwgZnVuY3Rpb24oIF8sIGtleSApIHtcbiAgICAgICAgICAgICAgICBpdGVyYXRvcigga2V5LCBjYWxsYmFjayApO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICBcbiAgICAgICAgZnVuY3Rpb24gdHJpZ2dlckhhbmRlcnMoIGV2ZW50cywgYXJncyApIHtcbiAgICAgICAgICAgIHZhciBzdG9wZWQgPSBmYWxzZSxcbiAgICAgICAgICAgICAgICBpID0gLTEsXG4gICAgICAgICAgICAgICAgbGVuID0gZXZlbnRzLmxlbmd0aCxcbiAgICAgICAgICAgICAgICBoYW5kbGVyO1xuICAgIFxuICAgICAgICAgICAgd2hpbGUgKCArK2kgPCBsZW4gKSB7XG4gICAgICAgICAgICAgICAgaGFuZGxlciA9IGV2ZW50c1sgaSBdO1xuICAgIFxuICAgICAgICAgICAgICAgIGlmICggaGFuZGxlci5jYi5hcHBseSggaGFuZGxlci5jdHgyLCBhcmdzICkgPT09IGZhbHNlICkge1xuICAgICAgICAgICAgICAgICAgICBzdG9wZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgXG4gICAgICAgICAgICByZXR1cm4gIXN0b3BlZDtcbiAgICAgICAgfVxuICAgIFxuICAgICAgICBwcm90b3MgPSB7XG4gICAgXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIOe7keWumuS6i+S7tuOAglxuICAgICAgICAgICAgICpcbiAgICAgICAgICAgICAqIGBjYWxsYmFja2Dmlrnms5XlnKjmiafooYzml7bvvIxhcmd1bWVudHPlsIbkvJrmnaXmupDkuo50cmlnZ2Vy55qE5pe25YCZ5pC65bim55qE5Y+C5pWw44CC5aaCXG4gICAgICAgICAgICAgKiBgYGBqYXZhc2NyaXB0XG4gICAgICAgICAgICAgKiB2YXIgb2JqID0ge307XG4gICAgICAgICAgICAgKlxuICAgICAgICAgICAgICogLy8g5L2/5b6Xb2Jq5pyJ5LqL5Lu26KGM5Li6XG4gICAgICAgICAgICAgKiBNZWRpYXRvci5pbnN0YWxsVG8oIG9iaiApO1xuICAgICAgICAgICAgICpcbiAgICAgICAgICAgICAqIG9iai5vbiggJ3Rlc3RhJywgZnVuY3Rpb24oIGFyZzEsIGFyZzIgKSB7XG4gICAgICAgICAgICAgKiAgICAgY29uc29sZS5sb2coIGFyZzEsIGFyZzIgKTsgLy8gPT4gJ2FyZzEnLCAnYXJnMidcbiAgICAgICAgICAgICAqIH0pO1xuICAgICAgICAgICAgICpcbiAgICAgICAgICAgICAqIG9iai50cmlnZ2VyKCAndGVzdGEnLCAnYXJnMScsICdhcmcyJyApO1xuICAgICAgICAgICAgICogYGBgXG4gICAgICAgICAgICAgKlxuICAgICAgICAgICAgICog5aaC5p6cYGNhbGxiYWNrYOS4re+8jOafkOS4gOS4quaWueazlWByZXR1cm4gZmFsc2Vg5LqG77yM5YiZ5ZCO57ut55qE5YW25LuWYGNhbGxiYWNrYOmDveS4jeS8muiiq+aJp+ihjOWIsOOAglxuICAgICAgICAgICAgICog5YiH5Lya5b2x5ZON5YiwYHRyaWdnZXJg5pa55rOV55qE6L+U5Zue5YC877yM5Li6YGZhbHNlYOOAglxuICAgICAgICAgICAgICpcbiAgICAgICAgICAgICAqIGBvbmDov5jlj6/ku6XnlKjmnaXmt7vliqDkuIDkuKrnibnmrorkuovku7ZgYWxsYCwg6L+Z5qC35omA5pyJ55qE5LqL5Lu26Kem5Y+R6YO95Lya5ZON5bqU5Yiw44CC5ZCM5pe25q2k57G7YGNhbGxiYWNrYOS4reeahGFyZ3VtZW50c+acieS4gOS4quS4jeWQjOWkhO+8jFxuICAgICAgICAgICAgICog5bCx5piv56ys5LiA5Liq5Y+C5pWw5Li6YHR5cGVg77yM6K6w5b2V5b2T5YmN5piv5LuA5LmI5LqL5Lu25Zyo6Kem5Y+R44CC5q2k57G7YGNhbGxiYWNrYOeahOS8mOWFiOe6p+avlOiEmuS9ju+8jOS8muWGjeato+W4uGBjYWxsYmFja2DmiafooYzlrozlkI7op6blj5HjgIJcbiAgICAgICAgICAgICAqIGBgYGphdmFzY3JpcHRcbiAgICAgICAgICAgICAqIG9iai5vbiggJ2FsbCcsIGZ1bmN0aW9uKCB0eXBlLCBhcmcxLCBhcmcyICkge1xuICAgICAgICAgICAgICogICAgIGNvbnNvbGUubG9nKCB0eXBlLCBhcmcxLCBhcmcyICk7IC8vID0+ICd0ZXN0YScsICdhcmcxJywgJ2FyZzInXG4gICAgICAgICAgICAgKiB9KTtcbiAgICAgICAgICAgICAqIGBgYFxuICAgICAgICAgICAgICpcbiAgICAgICAgICAgICAqIEBtZXRob2Qgb25cbiAgICAgICAgICAgICAqIEBncmFtbWFyIG9uKCBuYW1lLCBjYWxsYmFja1ssIGNvbnRleHRdICkgPT4gc2VsZlxuICAgICAgICAgICAgICogQHBhcmFtICB7U3RyaW5nfSAgIG5hbWUgICAgIOS6i+S7tuWQje+8jOaUr+aMgeWkmuS4quS6i+S7tueUqOepuuagvOmalOW8gFxuICAgICAgICAgICAgICogQHBhcmFtICB7RnVuY3Rpb259IGNhbGxiYWNrIOS6i+S7tuWkhOeQhuWZqFxuICAgICAgICAgICAgICogQHBhcmFtICB7T2JqZWN0fSAgIFtjb250ZXh0XSAg5LqL5Lu25aSE55CG5Zmo55qE5LiK5LiL5paH44CCXG4gICAgICAgICAgICAgKiBAcmV0dXJuIHtzZWxmfSDov5Tlm57oh6rouqvvvIzmlrnkvr/pk77lvI9cbiAgICAgICAgICAgICAqIEBjaGFpbmFibGVcbiAgICAgICAgICAgICAqIEBjbGFzcyBNZWRpYXRvclxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBvbjogZnVuY3Rpb24oIG5hbWUsIGNhbGxiYWNrLCBjb250ZXh0ICkge1xuICAgICAgICAgICAgICAgIHZhciBtZSA9IHRoaXMsXG4gICAgICAgICAgICAgICAgICAgIHNldDtcbiAgICBcbiAgICAgICAgICAgICAgICBpZiAoICFjYWxsYmFjayApIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgICAgICAgICAgfVxuICAgIFxuICAgICAgICAgICAgICAgIHNldCA9IHRoaXMuX2V2ZW50cyB8fCAodGhpcy5fZXZlbnRzID0gW10pO1xuICAgIFxuICAgICAgICAgICAgICAgIGVhY2hFdmVudCggbmFtZSwgY2FsbGJhY2ssIGZ1bmN0aW9uKCBuYW1lLCBjYWxsYmFjayApIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGhhbmRsZXIgPSB7IGU6IG5hbWUgfTtcbiAgICBcbiAgICAgICAgICAgICAgICAgICAgaGFuZGxlci5jYiA9IGNhbGxiYWNrO1xuICAgICAgICAgICAgICAgICAgICBoYW5kbGVyLmN0eCA9IGNvbnRleHQ7XG4gICAgICAgICAgICAgICAgICAgIGhhbmRsZXIuY3R4MiA9IGNvbnRleHQgfHwgbWU7XG4gICAgICAgICAgICAgICAgICAgIGhhbmRsZXIuaWQgPSBzZXQubGVuZ3RoO1xuICAgIFxuICAgICAgICAgICAgICAgICAgICBzZXQucHVzaCggaGFuZGxlciApO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgIFxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICAgICAgfSxcbiAgICBcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICog57uR5a6a5LqL5Lu277yM5LiU5b2TaGFuZGxlcuaJp+ihjOWujOWQju+8jOiHquWKqOino+mZpOe7keWumuOAglxuICAgICAgICAgICAgICogQG1ldGhvZCBvbmNlXG4gICAgICAgICAgICAgKiBAZ3JhbW1hciBvbmNlKCBuYW1lLCBjYWxsYmFja1ssIGNvbnRleHRdICkgPT4gc2VsZlxuICAgICAgICAgICAgICogQHBhcmFtICB7U3RyaW5nfSAgIG5hbWUgICAgIOS6i+S7tuWQjVxuICAgICAgICAgICAgICogQHBhcmFtICB7RnVuY3Rpb259IGNhbGxiYWNrIOS6i+S7tuWkhOeQhuWZqFxuICAgICAgICAgICAgICogQHBhcmFtICB7T2JqZWN0fSAgIFtjb250ZXh0XSAg5LqL5Lu25aSE55CG5Zmo55qE5LiK5LiL5paH44CCXG4gICAgICAgICAgICAgKiBAcmV0dXJuIHtzZWxmfSDov5Tlm57oh6rouqvvvIzmlrnkvr/pk77lvI9cbiAgICAgICAgICAgICAqIEBjaGFpbmFibGVcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgb25jZTogZnVuY3Rpb24oIG5hbWUsIGNhbGxiYWNrLCBjb250ZXh0ICkge1xuICAgICAgICAgICAgICAgIHZhciBtZSA9IHRoaXM7XG4gICAgXG4gICAgICAgICAgICAgICAgaWYgKCAhY2FsbGJhY2sgKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBtZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgXG4gICAgICAgICAgICAgICAgZWFjaEV2ZW50KCBuYW1lLCBjYWxsYmFjaywgZnVuY3Rpb24oIG5hbWUsIGNhbGxiYWNrICkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgb25jZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1lLm9mZiggbmFtZSwgb25jZSApO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBjYWxsYmFjay5hcHBseSggY29udGV4dCB8fCBtZSwgYXJndW1lbnRzICk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgIFxuICAgICAgICAgICAgICAgICAgICBvbmNlLl9jYiA9IGNhbGxiYWNrO1xuICAgICAgICAgICAgICAgICAgICBtZS5vbiggbmFtZSwgb25jZSwgY29udGV4dCApO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgIFxuICAgICAgICAgICAgICAgIHJldHVybiBtZTtcbiAgICAgICAgICAgIH0sXG4gICAgXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIOino+mZpOS6i+S7tue7keWumlxuICAgICAgICAgICAgICogQG1ldGhvZCBvZmZcbiAgICAgICAgICAgICAqIEBncmFtbWFyIG9mZiggW25hbWVbLCBjYWxsYmFja1ssIGNvbnRleHRdIF0gXSApID0+IHNlbGZcbiAgICAgICAgICAgICAqIEBwYXJhbSAge1N0cmluZ30gICBbbmFtZV0gICAgIOS6i+S7tuWQjVxuICAgICAgICAgICAgICogQHBhcmFtICB7RnVuY3Rpb259IFtjYWxsYmFja10g5LqL5Lu25aSE55CG5ZmoXG4gICAgICAgICAgICAgKiBAcGFyYW0gIHtPYmplY3R9ICAgW2NvbnRleHRdICDkuovku7blpITnkIblmajnmoTkuIrkuIvmlofjgIJcbiAgICAgICAgICAgICAqIEByZXR1cm4ge3NlbGZ9IOi/lOWbnuiHqui6q++8jOaWueS+v+mTvuW8j1xuICAgICAgICAgICAgICogQGNoYWluYWJsZVxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBvZmY6IGZ1bmN0aW9uKCBuYW1lLCBjYiwgY3R4ICkge1xuICAgICAgICAgICAgICAgIHZhciBldmVudHMgPSB0aGlzLl9ldmVudHM7XG4gICAgXG4gICAgICAgICAgICAgICAgaWYgKCAhZXZlbnRzICkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgICAgICAgICB9XG4gICAgXG4gICAgICAgICAgICAgICAgaWYgKCAhbmFtZSAmJiAhY2IgJiYgIWN0eCApIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fZXZlbnRzID0gW107XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICAgICAgICAgIH1cbiAgICBcbiAgICAgICAgICAgICAgICBlYWNoRXZlbnQoIG5hbWUsIGNiLCBmdW5jdGlvbiggbmFtZSwgY2IgKSB7XG4gICAgICAgICAgICAgICAgICAgICQuZWFjaCggZmluZEhhbmRsZXJzKCBldmVudHMsIG5hbWUsIGNiLCBjdHggKSwgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkZWxldGUgZXZlbnRzWyB0aGlzLmlkIF07XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgIFxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICAgICAgfSxcbiAgICBcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICog6Kem5Y+R5LqL5Lu2XG4gICAgICAgICAgICAgKiBAbWV0aG9kIHRyaWdnZXJcbiAgICAgICAgICAgICAqIEBncmFtbWFyIHRyaWdnZXIoIG5hbWVbLCBhcmdzLi4uXSApID0+IHNlbGZcbiAgICAgICAgICAgICAqIEBwYXJhbSAge1N0cmluZ30gICB0eXBlICAgICDkuovku7blkI1cbiAgICAgICAgICAgICAqIEBwYXJhbSAgeyp9IFsuLi5dIOS7u+aEj+WPguaVsFxuICAgICAgICAgICAgICogQHJldHVybiB7Qm9vbGVhbn0g5aaC5p6caGFuZGxlcuS4rXJldHVybiBmYWxzZeS6hu+8jOWImei/lOWbnmZhbHNlLCDlkKbliJnov5Tlm550cnVlXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIHRyaWdnZXI6IGZ1bmN0aW9uKCB0eXBlICkge1xuICAgICAgICAgICAgICAgIHZhciBhcmdzLCBldmVudHMsIGFsbEV2ZW50cztcbiAgICBcbiAgICAgICAgICAgICAgICBpZiAoICF0aGlzLl9ldmVudHMgfHwgIXR5cGUgKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICAgICAgICAgIH1cbiAgICBcbiAgICAgICAgICAgICAgICBhcmdzID0gc2xpY2UuY2FsbCggYXJndW1lbnRzLCAxICk7XG4gICAgICAgICAgICAgICAgZXZlbnRzID0gZmluZEhhbmRsZXJzKCB0aGlzLl9ldmVudHMsIHR5cGUgKTtcbiAgICAgICAgICAgICAgICBhbGxFdmVudHMgPSBmaW5kSGFuZGxlcnMoIHRoaXMuX2V2ZW50cywgJ2FsbCcgKTtcbiAgICBcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJpZ2dlckhhbmRlcnMoIGV2ZW50cywgYXJncyApICYmXG4gICAgICAgICAgICAgICAgICAgICAgICB0cmlnZ2VySGFuZGVycyggYWxsRXZlbnRzLCBhcmd1bWVudHMgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICBcbiAgICAgICAgLyoqXG4gICAgICAgICAqIOS4reS7i+iAhe+8jOWug+acrOi6q+aYr+S4quWNleS+i++8jOS9huWPr+S7pemAmui/h1tpbnN0YWxsVG9dKCNXZWJVcGxvYWRlcjpNZWRpYXRvcjppbnN0YWxsVG8p5pa55rOV77yM5L2/5Lu75L2V5a+56LGh5YW35aSH5LqL5Lu26KGM5Li644CCXG4gICAgICAgICAqIOS4u+imgeebrueahOaYr+i0n+i0o+aooeWdl+S4juaooeWdl+S5i+mXtOeahOWQiOS9nO+8jOmZjeS9juiApuWQiOW6puOAglxuICAgICAgICAgKlxuICAgICAgICAgKiBAY2xhc3MgTWVkaWF0b3JcbiAgICAgICAgICovXG4gICAgICAgIHJldHVybiAkLmV4dGVuZCh7XG4gICAgXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIOWPr+S7pemAmui/h+i/meS4quaOpeWPo++8jOS9v+S7u+S9leWvueixoeWFt+Wkh+S6i+S7tuWKn+iDveOAglxuICAgICAgICAgICAgICogQG1ldGhvZCBpbnN0YWxsVG9cbiAgICAgICAgICAgICAqIEBwYXJhbSAge09iamVjdH0gb2JqIOmcgOimgeWFt+Wkh+S6i+S7tuihjOS4uueahOWvueixoeOAglxuICAgICAgICAgICAgICogQHJldHVybiB7T2JqZWN0fSDov5Tlm55vYmouXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGluc3RhbGxUbzogZnVuY3Rpb24oIG9iaiApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gJC5leHRlbmQoIG9iaiwgcHJvdG9zICk7XG4gICAgICAgICAgICB9XG4gICAgXG4gICAgICAgIH0sIHByb3RvcyApO1xuICAgIH0pO1xuICAgIC8qKlxuICAgICAqIEBmaWxlT3ZlcnZpZXcgVXBsb2FkZXLkuIrkvKDnsbtcbiAgICAgKi9cbiAgICBkZWZpbmUoJ3VwbG9hZGVyJyxbXG4gICAgICAgICdiYXNlJyxcbiAgICAgICAgJ21lZGlhdG9yJ1xuICAgIF0sIGZ1bmN0aW9uKCBCYXNlLCBNZWRpYXRvciApIHtcbiAgICBcbiAgICAgICAgdmFyICQgPSBCYXNlLiQ7XG4gICAgXG4gICAgICAgIC8qKlxuICAgICAgICAgKiDkuIrkvKDlhaXlj6PnsbvjgIJcbiAgICAgICAgICogQGNsYXNzIFVwbG9hZGVyXG4gICAgICAgICAqIEBjb25zdHJ1Y3RvclxuICAgICAgICAgKiBAZ3JhbW1hciBuZXcgVXBsb2FkZXIoIG9wdHMgKSA9PiBVcGxvYWRlclxuICAgICAgICAgKiBAZXhhbXBsZVxuICAgICAgICAgKiB2YXIgdXBsb2FkZXIgPSBXZWJVcGxvYWRlci5VcGxvYWRlcih7XG4gICAgICAgICAqICAgICBzd2Y6ICdwYXRoX29mX3N3Zi9VcGxvYWRlci5zd2YnLFxuICAgICAgICAgKlxuICAgICAgICAgKiAgICAgLy8g5byA6LW35YiG54mH5LiK5Lyg44CCXG4gICAgICAgICAqICAgICBjaHVua2VkOiB0cnVlXG4gICAgICAgICAqIH0pO1xuICAgICAgICAgKi9cbiAgICAgICAgZnVuY3Rpb24gVXBsb2FkZXIoIG9wdHMgKSB7XG4gICAgICAgICAgICB0aGlzLm9wdGlvbnMgPSAkLmV4dGVuZCggdHJ1ZSwge30sIFVwbG9hZGVyLm9wdGlvbnMsIG9wdHMgKTtcbiAgICAgICAgICAgIHRoaXMuX2luaXQoIHRoaXMub3B0aW9ucyApO1xuICAgICAgICB9XG4gICAgXG4gICAgICAgIC8vIGRlZmF1bHQgT3B0aW9uc1xuICAgICAgICAvLyB3aWRnZXRz5Lit5pyJ55u45bqU5omp5bGVXG4gICAgICAgIFVwbG9hZGVyLm9wdGlvbnMgPSB7fTtcbiAgICAgICAgTWVkaWF0b3IuaW5zdGFsbFRvKCBVcGxvYWRlci5wcm90b3R5cGUgKTtcbiAgICBcbiAgICAgICAgLy8g5om56YeP5re75Yqg57qv5ZG95Luk5byP5pa55rOV44CCXG4gICAgICAgICQuZWFjaCh7XG4gICAgICAgICAgICB1cGxvYWQ6ICdzdGFydC11cGxvYWQnLFxuICAgICAgICAgICAgc3RvcDogJ3N0b3AtdXBsb2FkJyxcbiAgICAgICAgICAgIGdldEZpbGU6ICdnZXQtZmlsZScsXG4gICAgICAgICAgICBnZXRGaWxlczogJ2dldC1maWxlcycsXG4gICAgICAgICAgICBhZGRGaWxlOiAnYWRkLWZpbGUnLFxuICAgICAgICAgICAgYWRkRmlsZXM6ICdhZGQtZmlsZScsXG4gICAgICAgICAgICBzb3J0OiAnc29ydC1maWxlcycsXG4gICAgICAgICAgICByZW1vdmVGaWxlOiAncmVtb3ZlLWZpbGUnLFxuICAgICAgICAgICAgY2FuY2VsRmlsZTogJ2NhbmNlbC1maWxlJyxcbiAgICAgICAgICAgIHNraXBGaWxlOiAnc2tpcC1maWxlJyxcbiAgICAgICAgICAgIHJldHJ5OiAncmV0cnknLFxuICAgICAgICAgICAgaXNJblByb2dyZXNzOiAnaXMtaW4tcHJvZ3Jlc3MnLFxuICAgICAgICAgICAgbWFrZVRodW1iOiAnbWFrZS10aHVtYicsXG4gICAgICAgICAgICBtZDVGaWxlOiAnbWQ1LWZpbGUnLFxuICAgICAgICAgICAgZ2V0RGltZW5zaW9uOiAnZ2V0LWRpbWVuc2lvbicsXG4gICAgICAgICAgICBhZGRCdXR0b246ICdhZGQtYnRuJyxcbiAgICAgICAgICAgIHByZWRpY3RSdW50aW1lVHlwZTogJ3ByZWRpY3QtcnVudGltZS10eXBlJyxcbiAgICAgICAgICAgIHJlZnJlc2g6ICdyZWZyZXNoJyxcbiAgICAgICAgICAgIGRpc2FibGU6ICdkaXNhYmxlJyxcbiAgICAgICAgICAgIGVuYWJsZTogJ2VuYWJsZScsXG4gICAgICAgICAgICByZXNldDogJ3Jlc2V0J1xuICAgICAgICB9LCBmdW5jdGlvbiggZm4sIGNvbW1hbmQgKSB7XG4gICAgICAgICAgICBVcGxvYWRlci5wcm90b3R5cGVbIGZuIF0gPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5yZXF1ZXN0KCBjb21tYW5kLCBhcmd1bWVudHMgKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0pO1xuICAgIFxuICAgICAgICAkLmV4dGVuZCggVXBsb2FkZXIucHJvdG90eXBlLCB7XG4gICAgICAgICAgICBzdGF0ZTogJ3BlbmRpbmcnLFxuICAgIFxuICAgICAgICAgICAgX2luaXQ6IGZ1bmN0aW9uKCBvcHRzICkge1xuICAgICAgICAgICAgICAgIHZhciBtZSA9IHRoaXM7XG4gICAgXG4gICAgICAgICAgICAgICAgbWUucmVxdWVzdCggJ2luaXQnLCBvcHRzLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgbWUuc3RhdGUgPSAncmVhZHknO1xuICAgICAgICAgICAgICAgICAgICBtZS50cmlnZ2VyKCdyZWFkeScpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSxcbiAgICBcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICog6I635Y+W5oiW6ICF6K6+572uVXBsb2FkZXLphY3nva7pobnjgIJcbiAgICAgICAgICAgICAqIEBtZXRob2Qgb3B0aW9uXG4gICAgICAgICAgICAgKiBAZ3JhbW1hciBvcHRpb24oIGtleSApID0+ICpcbiAgICAgICAgICAgICAqIEBncmFtbWFyIG9wdGlvbigga2V5LCB2YWwgKSA9PiBzZWxmXG4gICAgICAgICAgICAgKiBAZXhhbXBsZVxuICAgICAgICAgICAgICpcbiAgICAgICAgICAgICAqIC8vIOWIneWni+eKtuaAgeWbvueJh+S4iuS8oOWJjeS4jeS8muWOi+e8qVxuICAgICAgICAgICAgICogdmFyIHVwbG9hZGVyID0gbmV3IFdlYlVwbG9hZGVyLlVwbG9hZGVyKHtcbiAgICAgICAgICAgICAqICAgICBjb21wcmVzczogbnVsbDtcbiAgICAgICAgICAgICAqIH0pO1xuICAgICAgICAgICAgICpcbiAgICAgICAgICAgICAqIC8vIOS/ruaUueWQjuWbvueJh+S4iuS8oOWJje+8jOWwneivleWwhuWbvueJh+WOi+e8qeWIsDE2MDAgKiAxNjAwXG4gICAgICAgICAgICAgKiB1cGxvYWRlci5vcHRpb24oICdjb21wcmVzcycsIHtcbiAgICAgICAgICAgICAqICAgICB3aWR0aDogMTYwMCxcbiAgICAgICAgICAgICAqICAgICBoZWlnaHQ6IDE2MDBcbiAgICAgICAgICAgICAqIH0pO1xuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBvcHRpb246IGZ1bmN0aW9uKCBrZXksIHZhbCApIHtcbiAgICAgICAgICAgICAgICB2YXIgb3B0cyA9IHRoaXMub3B0aW9ucztcbiAgICBcbiAgICAgICAgICAgICAgICAvLyBzZXR0ZXJcbiAgICAgICAgICAgICAgICBpZiAoIGFyZ3VtZW50cy5sZW5ndGggPiAxICkge1xuICAgIFxuICAgICAgICAgICAgICAgICAgICBpZiAoICQuaXNQbGFpbk9iamVjdCggdmFsICkgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAkLmlzUGxhaW5PYmplY3QoIG9wdHNbIGtleSBdICkgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAkLmV4dGVuZCggb3B0c1sga2V5IF0sIHZhbCApO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgb3B0c1sga2V5IF0gPSB2YWw7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICBcbiAgICAgICAgICAgICAgICB9IGVsc2UgeyAgICAvLyBnZXR0ZXJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGtleSA/IG9wdHNbIGtleSBdIDogb3B0cztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgIFxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiDojrflj5bmlofku7bnu5/orqHkv6Hmga/jgILov5Tlm57kuIDkuKrljIXlkKvkuIDkuIvkv6Hmga/nmoTlr7nosaHjgIJcbiAgICAgICAgICAgICAqICogYHN1Y2Nlc3NOdW1gIOS4iuS8oOaIkOWKn+eahOaWh+S7tuaVsFxuICAgICAgICAgICAgICogKiBgcHJvZ3Jlc3NOdW1gIOS4iuS8oOS4reeahOaWh+S7tuaVsFxuICAgICAgICAgICAgICogKiBgY2FuY2VsTnVtYCDooqvliKDpmaTnmoTmlofku7bmlbBcbiAgICAgICAgICAgICAqICogYGludmFsaWROdW1gIOaXoOaViOeahOaWh+S7tuaVsFxuICAgICAgICAgICAgICogKiBgdXBsb2FkRmFpbE51bWAg5LiK5Lyg5aSx6LSl55qE5paH5Lu25pWwXG4gICAgICAgICAgICAgKiAqIGBxdWV1ZU51bWAg6L+Y5Zyo6Zif5YiX5Lit55qE5paH5Lu25pWwXG4gICAgICAgICAgICAgKiAqIGBpbnRlcnJ1cHROdW1gIOiiq+aaguWBnOeahOaWh+S7tuaVsFxuICAgICAgICAgICAgICogQG1ldGhvZCBnZXRTdGF0c1xuICAgICAgICAgICAgICogQGdyYW1tYXIgZ2V0U3RhdHMoKSA9PiBPYmplY3RcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgZ2V0U3RhdHM6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIC8vIHJldHVybiB0aGlzLl9tZ3IuZ2V0U3RhdHMuYXBwbHkoIHRoaXMuX21nciwgYXJndW1lbnRzICk7XG4gICAgICAgICAgICAgICAgdmFyIHN0YXRzID0gdGhpcy5yZXF1ZXN0KCdnZXQtc3RhdHMnKTtcbiAgICBcbiAgICAgICAgICAgICAgICByZXR1cm4gc3RhdHMgPyB7XG4gICAgICAgICAgICAgICAgICAgIHN1Y2Nlc3NOdW06IHN0YXRzLm51bU9mU3VjY2VzcyxcbiAgICAgICAgICAgICAgICAgICAgcHJvZ3Jlc3NOdW06IHN0YXRzLm51bU9mUHJvZ3Jlc3MsXG4gICAgXG4gICAgICAgICAgICAgICAgICAgIC8vIHdobyBjYXJlP1xuICAgICAgICAgICAgICAgICAgICAvLyBxdWV1ZUZhaWxOdW06IDAsXG4gICAgICAgICAgICAgICAgICAgIGNhbmNlbE51bTogc3RhdHMubnVtT2ZDYW5jZWwsXG4gICAgICAgICAgICAgICAgICAgIGludmFsaWROdW06IHN0YXRzLm51bU9mSW52YWxpZCxcbiAgICAgICAgICAgICAgICAgICAgdXBsb2FkRmFpbE51bTogc3RhdHMubnVtT2ZVcGxvYWRGYWlsZWQsXG4gICAgICAgICAgICAgICAgICAgIHF1ZXVlTnVtOiBzdGF0cy5udW1PZlF1ZXVlLFxuICAgICAgICAgICAgICAgICAgICBpbnRlcnJ1cHROdW06IHN0YXRzLm51bW9mSW50ZXJydXB0XG4gICAgICAgICAgICAgICAgfSA6IHt9O1xuICAgICAgICAgICAgfSxcbiAgICBcbiAgICAgICAgICAgIC8vIOmcgOimgemHjeWGmeatpOaWueazleadpeadpeaUr+aMgW9wdHMub25FdmVudOWSjGluc3RhbmNlLm9uRXZlbnTnmoTlpITnkIblmahcbiAgICAgICAgICAgIHRyaWdnZXI6IGZ1bmN0aW9uKCB0eXBlLyosIGFyZ3MuLi4qLyApIHtcbiAgICAgICAgICAgICAgICB2YXIgYXJncyA9IFtdLnNsaWNlLmNhbGwoIGFyZ3VtZW50cywgMSApLFxuICAgICAgICAgICAgICAgICAgICBvcHRzID0gdGhpcy5vcHRpb25zLFxuICAgICAgICAgICAgICAgICAgICBuYW1lID0gJ29uJyArIHR5cGUuc3Vic3RyaW5nKCAwLCAxICkudG9VcHBlckNhc2UoKSArXG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlLnN1YnN0cmluZyggMSApO1xuICAgIFxuICAgICAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIOiwg+eUqOmAmui/h29u5pa55rOV5rOo5YaM55qEaGFuZGxlci5cbiAgICAgICAgICAgICAgICAgICAgICAgIE1lZGlhdG9yLnRyaWdnZXIuYXBwbHkoIHRoaXMsIGFyZ3VtZW50cyApID09PSBmYWxzZSB8fFxuICAgIFxuICAgICAgICAgICAgICAgICAgICAgICAgLy8g6LCD55Sob3B0cy5vbkV2ZW50XG4gICAgICAgICAgICAgICAgICAgICAgICAkLmlzRnVuY3Rpb24oIG9wdHNbIG5hbWUgXSApICYmXG4gICAgICAgICAgICAgICAgICAgICAgICBvcHRzWyBuYW1lIF0uYXBwbHkoIHRoaXMsIGFyZ3MgKSA9PT0gZmFsc2UgfHxcbiAgICBcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIOiwg+eUqHRoaXMub25FdmVudFxuICAgICAgICAgICAgICAgICAgICAgICAgJC5pc0Z1bmN0aW9uKCB0aGlzWyBuYW1lIF0gKSAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpc1sgbmFtZSBdLmFwcGx5KCB0aGlzLCBhcmdzICkgPT09IGZhbHNlIHx8XG4gICAgXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyDlub/mkq3miYDmnIl1cGxvYWRlcueahOS6i+S7tuOAglxuICAgICAgICAgICAgICAgICAgICAgICAgTWVkaWF0b3IudHJpZ2dlci5hcHBseSggTWVkaWF0b3IsXG4gICAgICAgICAgICAgICAgICAgICAgICBbIHRoaXMsIHR5cGUgXS5jb25jYXQoIGFyZ3MgKSApID09PSBmYWxzZSApIHtcbiAgICBcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICBcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH0sXG4gICAgXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIOmUgOavgSB3ZWJ1cGxvYWRlciDlrp7kvotcbiAgICAgICAgICAgICAqIEBtZXRob2QgZGVzdHJveVxuICAgICAgICAgICAgICogQGdyYW1tYXIgZGVzdHJveSgpID0+IHVuZGVmaW5lZFxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBkZXN0cm95OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnJlcXVlc3QoICdkZXN0cm95JywgYXJndW1lbnRzICk7XG4gICAgICAgICAgICAgICAgdGhpcy5vZmYoKTtcbiAgICAgICAgICAgIH0sXG4gICAgXG4gICAgICAgICAgICAvLyB3aWRnZXRzL3dpZGdldC5qc+WwhuihpeWFheatpOaWueazleeahOivpue7huaWh+aho+OAglxuICAgICAgICAgICAgcmVxdWVzdDogQmFzZS5ub29wXG4gICAgICAgIH0pO1xuICAgIFxuICAgICAgICAvKipcbiAgICAgICAgICog5Yib5bu6VXBsb2FkZXLlrp7kvovvvIznrYnlkIzkuo5uZXcgVXBsb2FkZXIoIG9wdHMgKTtcbiAgICAgICAgICogQG1ldGhvZCBjcmVhdGVcbiAgICAgICAgICogQGNsYXNzIEJhc2VcbiAgICAgICAgICogQHN0YXRpY1xuICAgICAgICAgKiBAZ3JhbW1hciBCYXNlLmNyZWF0ZSggb3B0cyApID0+IFVwbG9hZGVyXG4gICAgICAgICAqL1xuICAgICAgICBCYXNlLmNyZWF0ZSA9IFVwbG9hZGVyLmNyZWF0ZSA9IGZ1bmN0aW9uKCBvcHRzICkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBVcGxvYWRlciggb3B0cyApO1xuICAgICAgICB9O1xuICAgIFxuICAgICAgICAvLyDmmrTpnLJVcGxvYWRlcu+8jOWPr+S7pemAmui/h+Wug+adpeaJqeWxleS4muWKoemAu+i+keOAglxuICAgICAgICBCYXNlLlVwbG9hZGVyID0gVXBsb2FkZXI7XG4gICAgXG4gICAgICAgIHJldHVybiBVcGxvYWRlcjtcbiAgICB9KTtcbiAgICAvKipcbiAgICAgKiBAZmlsZU92ZXJ2aWV3IFJ1bnRpbWXnrqHnkIblmajvvIzotJ/otKNSdW50aW1l55qE6YCJ5oupLCDov57mjqVcbiAgICAgKi9cbiAgICBkZWZpbmUoJ3J1bnRpbWUvcnVudGltZScsW1xuICAgICAgICAnYmFzZScsXG4gICAgICAgICdtZWRpYXRvcidcbiAgICBdLCBmdW5jdGlvbiggQmFzZSwgTWVkaWF0b3IgKSB7XG4gICAgXG4gICAgICAgIHZhciAkID0gQmFzZS4kLFxuICAgICAgICAgICAgZmFjdG9yaWVzID0ge30sXG4gICAgXG4gICAgICAgICAgICAvLyDojrflj5blr7nosaHnmoTnrKzkuIDkuKprZXlcbiAgICAgICAgICAgIGdldEZpcnN0S2V5ID0gZnVuY3Rpb24oIG9iaiApIHtcbiAgICAgICAgICAgICAgICBmb3IgKCB2YXIga2V5IGluIG9iaiApIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCBvYmouaGFzT3duUHJvcGVydHkoIGtleSApICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGtleTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH07XG4gICAgXG4gICAgICAgIC8vIOaOpeWPo+exu+OAglxuICAgICAgICBmdW5jdGlvbiBSdW50aW1lKCBvcHRpb25zICkge1xuICAgICAgICAgICAgdGhpcy5vcHRpb25zID0gJC5leHRlbmQoe1xuICAgICAgICAgICAgICAgIGNvbnRhaW5lcjogZG9jdW1lbnQuYm9keVxuICAgICAgICAgICAgfSwgb3B0aW9ucyApO1xuICAgICAgICAgICAgdGhpcy51aWQgPSBCYXNlLmd1aWQoJ3J0XycpO1xuICAgICAgICB9XG4gICAgXG4gICAgICAgICQuZXh0ZW5kKCBSdW50aW1lLnByb3RvdHlwZSwge1xuICAgIFxuICAgICAgICAgICAgZ2V0Q29udGFpbmVyOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICB2YXIgb3B0cyA9IHRoaXMub3B0aW9ucyxcbiAgICAgICAgICAgICAgICAgICAgcGFyZW50LCBjb250YWluZXI7XG4gICAgXG4gICAgICAgICAgICAgICAgaWYgKCB0aGlzLl9jb250YWluZXIgKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9jb250YWluZXI7XG4gICAgICAgICAgICAgICAgfVxuICAgIFxuICAgICAgICAgICAgICAgIHBhcmVudCA9ICQoIG9wdHMuY29udGFpbmVyIHx8IGRvY3VtZW50LmJvZHkgKTtcbiAgICAgICAgICAgICAgICBjb250YWluZXIgPSAkKCBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKSApO1xuICAgIFxuICAgICAgICAgICAgICAgIGNvbnRhaW5lci5hdHRyKCAnaWQnLCAncnRfJyArIHRoaXMudWlkICk7XG4gICAgICAgICAgICAgICAgY29udGFpbmVyLmNzcyh7XG4gICAgICAgICAgICAgICAgICAgIHBvc2l0aW9uOiAnYWJzb2x1dGUnLFxuICAgICAgICAgICAgICAgICAgICB0b3A6ICcwcHgnLFxuICAgICAgICAgICAgICAgICAgICBsZWZ0OiAnMHB4JyxcbiAgICAgICAgICAgICAgICAgICAgd2lkdGg6ICcxcHgnLFxuICAgICAgICAgICAgICAgICAgICBoZWlnaHQ6ICcxcHgnLFxuICAgICAgICAgICAgICAgICAgICBvdmVyZmxvdzogJ2hpZGRlbidcbiAgICAgICAgICAgICAgICB9KTtcbiAgICBcbiAgICAgICAgICAgICAgICBwYXJlbnQuYXBwZW5kKCBjb250YWluZXIgKTtcbiAgICAgICAgICAgICAgICBwYXJlbnQuYWRkQ2xhc3MoJ3dlYnVwbG9hZGVyLWNvbnRhaW5lcicpO1xuICAgICAgICAgICAgICAgIHRoaXMuX2NvbnRhaW5lciA9IGNvbnRhaW5lcjtcbiAgICAgICAgICAgICAgICB0aGlzLl9wYXJlbnQgPSBwYXJlbnQ7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNvbnRhaW5lcjtcbiAgICAgICAgICAgIH0sXG4gICAgXG4gICAgICAgICAgICBpbml0OiBCYXNlLm5vb3AsXG4gICAgICAgICAgICBleGVjOiBCYXNlLm5vb3AsXG4gICAgXG4gICAgICAgICAgICBkZXN0cm95OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9jb250YWluZXIgJiYgdGhpcy5fY29udGFpbmVyLnJlbW92ZSgpO1xuICAgICAgICAgICAgICAgIHRoaXMuX3BhcmVudCAmJiB0aGlzLl9wYXJlbnQucmVtb3ZlQ2xhc3MoJ3dlYnVwbG9hZGVyLWNvbnRhaW5lcicpO1xuICAgICAgICAgICAgICAgIHRoaXMub2ZmKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIFxuICAgICAgICBSdW50aW1lLm9yZGVycyA9ICdodG1sNSxmbGFzaCc7XG4gICAgXG4gICAgXG4gICAgICAgIC8qKlxuICAgICAgICAgKiDmt7vliqBSdW50aW1l5a6e546w44CCXG4gICAgICAgICAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlICAgIOexu+Wei1xuICAgICAgICAgKiBAcGFyYW0ge1J1bnRpbWV9IGZhY3Rvcnkg5YW35L2TUnVudGltZeWunueOsOOAglxuICAgICAgICAgKi9cbiAgICAgICAgUnVudGltZS5hZGRSdW50aW1lID0gZnVuY3Rpb24oIHR5cGUsIGZhY3RvcnkgKSB7XG4gICAgICAgICAgICBmYWN0b3JpZXNbIHR5cGUgXSA9IGZhY3Rvcnk7XG4gICAgICAgIH07XG4gICAgXG4gICAgICAgIFJ1bnRpbWUuaGFzUnVudGltZSA9IGZ1bmN0aW9uKCB0eXBlICkge1xuICAgICAgICAgICAgcmV0dXJuICEhKHR5cGUgPyBmYWN0b3JpZXNbIHR5cGUgXSA6IGdldEZpcnN0S2V5KCBmYWN0b3JpZXMgKSk7XG4gICAgICAgIH07XG4gICAgXG4gICAgICAgIFJ1bnRpbWUuY3JlYXRlID0gZnVuY3Rpb24oIG9wdHMsIG9yZGVycyApIHtcbiAgICAgICAgICAgIHZhciB0eXBlLCBydW50aW1lO1xuICAgIFxuICAgICAgICAgICAgb3JkZXJzID0gb3JkZXJzIHx8IFJ1bnRpbWUub3JkZXJzO1xuICAgICAgICAgICAgJC5lYWNoKCBvcmRlcnMuc3BsaXQoIC9cXHMqLFxccyovZyApLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICBpZiAoIGZhY3Rvcmllc1sgdGhpcyBdICkge1xuICAgICAgICAgICAgICAgICAgICB0eXBlID0gdGhpcztcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgIFxuICAgICAgICAgICAgdHlwZSA9IHR5cGUgfHwgZ2V0Rmlyc3RLZXkoIGZhY3RvcmllcyApO1xuICAgIFxuICAgICAgICAgICAgaWYgKCAhdHlwZSApIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1J1bnRpbWUgRXJyb3InKTtcbiAgICAgICAgICAgIH1cbiAgICBcbiAgICAgICAgICAgIHJ1bnRpbWUgPSBuZXcgZmFjdG9yaWVzWyB0eXBlIF0oIG9wdHMgKTtcbiAgICAgICAgICAgIHJldHVybiBydW50aW1lO1xuICAgICAgICB9O1xuICAgIFxuICAgICAgICBNZWRpYXRvci5pbnN0YWxsVG8oIFJ1bnRpbWUucHJvdG90eXBlICk7XG4gICAgICAgIHJldHVybiBSdW50aW1lO1xuICAgIH0pO1xuICAgIFxuICAgIC8qKlxuICAgICAqIEBmaWxlT3ZlcnZpZXcgUnVudGltZeeuoeeQhuWZqO+8jOi0n+i0o1J1bnRpbWXnmoTpgInmi6ksIOi/nuaOpVxuICAgICAqL1xuICAgIGRlZmluZSgncnVudGltZS9jbGllbnQnLFtcbiAgICAgICAgJ2Jhc2UnLFxuICAgICAgICAnbWVkaWF0b3InLFxuICAgICAgICAncnVudGltZS9ydW50aW1lJ1xuICAgIF0sIGZ1bmN0aW9uKCBCYXNlLCBNZWRpYXRvciwgUnVudGltZSApIHtcbiAgICBcbiAgICAgICAgdmFyIGNhY2hlO1xuICAgIFxuICAgICAgICBjYWNoZSA9IChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHZhciBvYmogPSB7fTtcbiAgICBcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgYWRkOiBmdW5jdGlvbiggcnVudGltZSApIHtcbiAgICAgICAgICAgICAgICAgICAgb2JqWyBydW50aW1lLnVpZCBdID0gcnVudGltZTtcbiAgICAgICAgICAgICAgICB9LFxuICAgIFxuICAgICAgICAgICAgICAgIGdldDogZnVuY3Rpb24oIHJ1aWQsIHN0YW5kYWxvbmUgKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBpO1xuICAgIFxuICAgICAgICAgICAgICAgICAgICBpZiAoIHJ1aWQgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gb2JqWyBydWlkIF07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICBcbiAgICAgICAgICAgICAgICAgICAgZm9yICggaSBpbiBvYmogKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyDmnInkupvnsbvlnovkuI3og73ph43nlKjvvIzmr5TlpoJmaWxlcGlja2VyLlxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCBzdGFuZGFsb25lICYmIG9ialsgaSBdLl9fc3RhbmRhbG9uZSApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICBcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBvYmpbIGkgXTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgIFxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgICAgICB9LFxuICAgIFxuICAgICAgICAgICAgICAgIHJlbW92ZTogZnVuY3Rpb24oIHJ1bnRpbWUgKSB7XG4gICAgICAgICAgICAgICAgICAgIGRlbGV0ZSBvYmpbIHJ1bnRpbWUudWlkIF07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSkoKTtcbiAgICBcbiAgICAgICAgZnVuY3Rpb24gUnVudGltZUNsaWVudCggY29tcG9uZW50LCBzdGFuZGFsb25lICkge1xuICAgICAgICAgICAgdmFyIGRlZmVycmVkID0gQmFzZS5EZWZlcnJlZCgpLFxuICAgICAgICAgICAgICAgIHJ1bnRpbWU7XG4gICAgXG4gICAgICAgICAgICB0aGlzLnVpZCA9IEJhc2UuZ3VpZCgnY2xpZW50XycpO1xuICAgIFxuICAgICAgICAgICAgLy8g5YWB6K64cnVudGltZeayoeacieWIneWni+WMluS5i+WJje+8jOazqOWGjOS4gOS6m+aWueazleWcqOWIneWni+WMluWQjuaJp+ihjOOAglxuICAgICAgICAgICAgdGhpcy5ydW50aW1lUmVhZHkgPSBmdW5jdGlvbiggY2IgKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGRlZmVycmVkLmRvbmUoIGNiICk7XG4gICAgICAgICAgICB9O1xuICAgIFxuICAgICAgICAgICAgdGhpcy5jb25uZWN0UnVudGltZSA9IGZ1bmN0aW9uKCBvcHRzLCBjYiApIHtcbiAgICBcbiAgICAgICAgICAgICAgICAvLyBhbHJlYWR5IGNvbm5lY3RlZC5cbiAgICAgICAgICAgICAgICBpZiAoIHJ1bnRpbWUgKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignYWxyZWFkeSBjb25uZWN0ZWQhJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgIFxuICAgICAgICAgICAgICAgIGRlZmVycmVkLmRvbmUoIGNiICk7XG4gICAgXG4gICAgICAgICAgICAgICAgaWYgKCB0eXBlb2Ygb3B0cyA9PT0gJ3N0cmluZycgJiYgY2FjaGUuZ2V0KCBvcHRzICkgKSB7XG4gICAgICAgICAgICAgICAgICAgIHJ1bnRpbWUgPSBjYWNoZS5nZXQoIG9wdHMgKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgXG4gICAgICAgICAgICAgICAgLy8g5YOPZmlsZVBpY2tlcuWPquiDveeLrOeri+WtmOWcqO+8jOS4jeiDveWFrOeUqOOAglxuICAgICAgICAgICAgICAgIHJ1bnRpbWUgPSBydW50aW1lIHx8IGNhY2hlLmdldCggbnVsbCwgc3RhbmRhbG9uZSApO1xuICAgIFxuICAgICAgICAgICAgICAgIC8vIOmcgOimgeWIm+W7ulxuICAgICAgICAgICAgICAgIGlmICggIXJ1bnRpbWUgKSB7XG4gICAgICAgICAgICAgICAgICAgIHJ1bnRpbWUgPSBSdW50aW1lLmNyZWF0ZSggb3B0cywgb3B0cy5ydW50aW1lT3JkZXIgKTtcbiAgICAgICAgICAgICAgICAgICAgcnVudGltZS5fX3Byb21pc2UgPSBkZWZlcnJlZC5wcm9taXNlKCk7XG4gICAgICAgICAgICAgICAgICAgIHJ1bnRpbWUub25jZSggJ3JlYWR5JywgZGVmZXJyZWQucmVzb2x2ZSApO1xuICAgICAgICAgICAgICAgICAgICBydW50aW1lLmluaXQoKTtcbiAgICAgICAgICAgICAgICAgICAgY2FjaGUuYWRkKCBydW50aW1lICk7XG4gICAgICAgICAgICAgICAgICAgIHJ1bnRpbWUuX19jbGllbnQgPSAxO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIOadpeiHqmNhY2hlXG4gICAgICAgICAgICAgICAgICAgIEJhc2UuJC5leHRlbmQoIHJ1bnRpbWUub3B0aW9ucywgb3B0cyApO1xuICAgICAgICAgICAgICAgICAgICBydW50aW1lLl9fcHJvbWlzZS50aGVuKCBkZWZlcnJlZC5yZXNvbHZlICk7XG4gICAgICAgICAgICAgICAgICAgIHJ1bnRpbWUuX19jbGllbnQrKztcbiAgICAgICAgICAgICAgICB9XG4gICAgXG4gICAgICAgICAgICAgICAgc3RhbmRhbG9uZSAmJiAocnVudGltZS5fX3N0YW5kYWxvbmUgPSBzdGFuZGFsb25lKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gcnVudGltZTtcbiAgICAgICAgICAgIH07XG4gICAgXG4gICAgICAgICAgICB0aGlzLmdldFJ1bnRpbWUgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcnVudGltZTtcbiAgICAgICAgICAgIH07XG4gICAgXG4gICAgICAgICAgICB0aGlzLmRpc2Nvbm5lY3RSdW50aW1lID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgaWYgKCAhcnVudGltZSApIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICBcbiAgICAgICAgICAgICAgICBydW50aW1lLl9fY2xpZW50LS07XG4gICAgXG4gICAgICAgICAgICAgICAgaWYgKCBydW50aW1lLl9fY2xpZW50IDw9IDAgKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhY2hlLnJlbW92ZSggcnVudGltZSApO1xuICAgICAgICAgICAgICAgICAgICBkZWxldGUgcnVudGltZS5fX3Byb21pc2U7XG4gICAgICAgICAgICAgICAgICAgIHJ1bnRpbWUuZGVzdHJveSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICBcbiAgICAgICAgICAgICAgICBydW50aW1lID0gbnVsbDtcbiAgICAgICAgICAgIH07XG4gICAgXG4gICAgICAgICAgICB0aGlzLmV4ZWMgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICBpZiAoICFydW50aW1lICkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgIFxuICAgICAgICAgICAgICAgIHZhciBhcmdzID0gQmFzZS5zbGljZSggYXJndW1lbnRzICk7XG4gICAgICAgICAgICAgICAgY29tcG9uZW50ICYmIGFyZ3MudW5zaGlmdCggY29tcG9uZW50ICk7XG4gICAgXG4gICAgICAgICAgICAgICAgcmV0dXJuIHJ1bnRpbWUuZXhlYy5hcHBseSggdGhpcywgYXJncyApO1xuICAgICAgICAgICAgfTtcbiAgICBcbiAgICAgICAgICAgIHRoaXMuZ2V0UnVpZCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBydW50aW1lICYmIHJ1bnRpbWUudWlkO1xuICAgICAgICAgICAgfTtcbiAgICBcbiAgICAgICAgICAgIHRoaXMuZGVzdHJveSA9IChmdW5jdGlvbiggZGVzdHJveSApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIGRlc3Ryb3kgJiYgZGVzdHJveS5hcHBseSggdGhpcywgYXJndW1lbnRzICk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMudHJpZ2dlcignZGVzdHJveScpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLm9mZigpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmV4ZWMoJ2Rlc3Ryb3knKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kaXNjb25uZWN0UnVudGltZSgpO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9KSggdGhpcy5kZXN0cm95ICk7XG4gICAgICAgIH1cbiAgICBcbiAgICAgICAgTWVkaWF0b3IuaW5zdGFsbFRvKCBSdW50aW1lQ2xpZW50LnByb3RvdHlwZSApO1xuICAgICAgICByZXR1cm4gUnVudGltZUNsaWVudDtcbiAgICB9KTtcbiAgICAvKipcbiAgICAgKiBAZmlsZU92ZXJ2aWV3IOmUmeivr+S/oeaBr1xuICAgICAqL1xuICAgIGRlZmluZSgnbGliL2RuZCcsW1xuICAgICAgICAnYmFzZScsXG4gICAgICAgICdtZWRpYXRvcicsXG4gICAgICAgICdydW50aW1lL2NsaWVudCdcbiAgICBdLCBmdW5jdGlvbiggQmFzZSwgTWVkaWF0b3IsIFJ1bnRpbWVDbGVudCApIHtcbiAgICBcbiAgICAgICAgdmFyICQgPSBCYXNlLiQ7XG4gICAgXG4gICAgICAgIGZ1bmN0aW9uIERyYWdBbmREcm9wKCBvcHRzICkge1xuICAgICAgICAgICAgb3B0cyA9IHRoaXMub3B0aW9ucyA9ICQuZXh0ZW5kKHt9LCBEcmFnQW5kRHJvcC5vcHRpb25zLCBvcHRzICk7XG4gICAgXG4gICAgICAgICAgICBvcHRzLmNvbnRhaW5lciA9ICQoIG9wdHMuY29udGFpbmVyICk7XG4gICAgXG4gICAgICAgICAgICBpZiAoICFvcHRzLmNvbnRhaW5lci5sZW5ndGggKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgIFxuICAgICAgICAgICAgUnVudGltZUNsZW50LmNhbGwoIHRoaXMsICdEcmFnQW5kRHJvcCcgKTtcbiAgICAgICAgfVxuICAgIFxuICAgICAgICBEcmFnQW5kRHJvcC5vcHRpb25zID0ge1xuICAgICAgICAgICAgYWNjZXB0OiBudWxsLFxuICAgICAgICAgICAgZGlzYWJsZUdsb2JhbERuZDogZmFsc2VcbiAgICAgICAgfTtcbiAgICBcbiAgICAgICAgQmFzZS5pbmhlcml0cyggUnVudGltZUNsZW50LCB7XG4gICAgICAgICAgICBjb25zdHJ1Y3RvcjogRHJhZ0FuZERyb3AsXG4gICAgXG4gICAgICAgICAgICBpbml0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICB2YXIgbWUgPSB0aGlzO1xuICAgIFxuICAgICAgICAgICAgICAgIG1lLmNvbm5lY3RSdW50aW1lKCBtZS5vcHRpb25zLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgbWUuZXhlYygnaW5pdCcpO1xuICAgICAgICAgICAgICAgICAgICBtZS50cmlnZ2VyKCdyZWFkeScpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICBcbiAgICAgICAgTWVkaWF0b3IuaW5zdGFsbFRvKCBEcmFnQW5kRHJvcC5wcm90b3R5cGUgKTtcbiAgICBcbiAgICAgICAgcmV0dXJuIERyYWdBbmREcm9wO1xuICAgIH0pO1xuICAgIC8qKlxuICAgICAqIEBmaWxlT3ZlcnZpZXcg57uE5Lu25Z+657G744CCXG4gICAgICovXG4gICAgZGVmaW5lKCd3aWRnZXRzL3dpZGdldCcsW1xuICAgICAgICAnYmFzZScsXG4gICAgICAgICd1cGxvYWRlcidcbiAgICBdLCBmdW5jdGlvbiggQmFzZSwgVXBsb2FkZXIgKSB7XG4gICAgXG4gICAgICAgIHZhciAkID0gQmFzZS4kLFxuICAgICAgICAgICAgX2luaXQgPSBVcGxvYWRlci5wcm90b3R5cGUuX2luaXQsXG4gICAgICAgICAgICBfZGVzdHJveSA9IFVwbG9hZGVyLnByb3RvdHlwZS5kZXN0cm95LFxuICAgICAgICAgICAgSUdOT1JFID0ge30sXG4gICAgICAgICAgICB3aWRnZXRDbGFzcyA9IFtdO1xuICAgIFxuICAgICAgICBmdW5jdGlvbiBpc0FycmF5TGlrZSggb2JqICkge1xuICAgICAgICAgICAgaWYgKCAhb2JqICkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICBcbiAgICAgICAgICAgIHZhciBsZW5ndGggPSBvYmoubGVuZ3RoLFxuICAgICAgICAgICAgICAgIHR5cGUgPSAkLnR5cGUoIG9iaiApO1xuICAgIFxuICAgICAgICAgICAgaWYgKCBvYmoubm9kZVR5cGUgPT09IDEgJiYgbGVuZ3RoICkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgIFxuICAgICAgICAgICAgcmV0dXJuIHR5cGUgPT09ICdhcnJheScgfHwgdHlwZSAhPT0gJ2Z1bmN0aW9uJyAmJiB0eXBlICE9PSAnc3RyaW5nJyAmJlxuICAgICAgICAgICAgICAgICAgICAobGVuZ3RoID09PSAwIHx8IHR5cGVvZiBsZW5ndGggPT09ICdudW1iZXInICYmIGxlbmd0aCA+IDAgJiZcbiAgICAgICAgICAgICAgICAgICAgKGxlbmd0aCAtIDEpIGluIG9iaik7XG4gICAgICAgIH1cbiAgICBcbiAgICAgICAgZnVuY3Rpb24gV2lkZ2V0KCB1cGxvYWRlciApIHtcbiAgICAgICAgICAgIHRoaXMub3duZXIgPSB1cGxvYWRlcjtcbiAgICAgICAgICAgIHRoaXMub3B0aW9ucyA9IHVwbG9hZGVyLm9wdGlvbnM7XG4gICAgICAgIH1cbiAgICBcbiAgICAgICAgJC5leHRlbmQoIFdpZGdldC5wcm90b3R5cGUsIHtcbiAgICBcbiAgICAgICAgICAgIGluaXQ6IEJhc2Uubm9vcCxcbiAgICBcbiAgICAgICAgICAgIC8vIOexu0JhY2tib25l55qE5LqL5Lu255uR5ZCs5aOw5piO77yM55uR5ZCsdXBsb2FkZXLlrp7kvovkuIrnmoTkuovku7ZcbiAgICAgICAgICAgIC8vIHdpZGdldOebtOaOpeaXoOazleebkeWQrOS6i+S7tu+8jOS6i+S7tuWPquiDvemAmui/h3VwbG9hZGVy5p2l5Lyg6YCSXG4gICAgICAgICAgICBpbnZva2U6IGZ1bmN0aW9uKCBhcGlOYW1lLCBhcmdzICkge1xuICAgIFxuICAgICAgICAgICAgICAgIC8qXG4gICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICdtYWtlLXRodW1iJzogJ21ha2VUaHVtYidcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgIHZhciBtYXAgPSB0aGlzLnJlc3BvbnNlTWFwO1xuICAgIFxuICAgICAgICAgICAgICAgIC8vIOWmguaenOaXoEFQSeWTjeW6lOWjsOaYjuWImeW/veeVpVxuICAgICAgICAgICAgICAgIGlmICggIW1hcCB8fCAhKGFwaU5hbWUgaW4gbWFwKSB8fCAhKG1hcFsgYXBpTmFtZSBdIGluIHRoaXMpIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAhJC5pc0Z1bmN0aW9uKCB0aGlzWyBtYXBbIGFwaU5hbWUgXSBdICkgKSB7XG4gICAgXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBJR05PUkU7XG4gICAgICAgICAgICAgICAgfVxuICAgIFxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzWyBtYXBbIGFwaU5hbWUgXSBdLmFwcGx5KCB0aGlzLCBhcmdzICk7XG4gICAgXG4gICAgICAgICAgICB9LFxuICAgIFxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiDlj5HpgIHlkb3ku6TjgILlvZPkvKDlhaVgY2FsbGJhY2tg5oiW6ICFYGhhbmRsZXJg5Lit6L+U5ZueYHByb21pc2Vg5pe244CC6L+U5Zue5LiA5Liq5b2T5omA5pyJYGhhbmRsZXJg5Lit55qEcHJvbWlzZemDveWujOaIkOWQjuWujOaIkOeahOaWsGBwcm9taXNlYOOAglxuICAgICAgICAgICAgICogQG1ldGhvZCByZXF1ZXN0XG4gICAgICAgICAgICAgKiBAZ3JhbW1hciByZXF1ZXN0KCBjb21tYW5kLCBhcmdzICkgPT4gKiB8IFByb21pc2VcbiAgICAgICAgICAgICAqIEBncmFtbWFyIHJlcXVlc3QoIGNvbW1hbmQsIGFyZ3MsIGNhbGxiYWNrICkgPT4gUHJvbWlzZVxuICAgICAgICAgICAgICogQGZvciAgVXBsb2FkZXJcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgcmVxdWVzdDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMub3duZXIucmVxdWVzdC5hcHBseSggdGhpcy5vd25lciwgYXJndW1lbnRzICk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIFxuICAgICAgICAvLyDmianlsZVVcGxvYWRlci5cbiAgICAgICAgJC5leHRlbmQoIFVwbG9hZGVyLnByb3RvdHlwZSwge1xuICAgIFxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBAcHJvcGVydHkge1N0cmluZyB8IEFycmF5fSBbZGlzYWJsZVdpZGdldHM9dW5kZWZpbmVkXVxuICAgICAgICAgICAgICogQG5hbWVzcGFjZSBvcHRpb25zXG4gICAgICAgICAgICAgKiBAZm9yIFVwbG9hZGVyXG4gICAgICAgICAgICAgKiBAZGVzY3JpcHRpb24g6buY6K6k5omA5pyJIFVwbG9hZGVyLnJlZ2lzdGVyIOS6hueahCB3aWRnZXQg6YO95Lya6KKr5Yqg6L2977yM5aaC5p6c56aB55So5p+Q5LiA6YOo5YiG77yM6K+36YCa6L+H5q2kIG9wdGlvbiDmjIflrprpu5HlkI3ljZXjgIJcbiAgICAgICAgICAgICAqL1xuICAgIFxuICAgICAgICAgICAgLy8g6KaG5YaZX2luaXTnlKjmnaXliJ3lp4vljJZ3aWRnZXRzXG4gICAgICAgICAgICBfaW5pdDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgdmFyIG1lID0gdGhpcyxcbiAgICAgICAgICAgICAgICAgICAgd2lkZ2V0cyA9IG1lLl93aWRnZXRzID0gW10sXG4gICAgICAgICAgICAgICAgICAgIGRlYWN0aXZlcyA9IG1lLm9wdGlvbnMuZGlzYWJsZVdpZGdldHMgfHwgJyc7XG4gICAgXG4gICAgICAgICAgICAgICAgJC5lYWNoKCB3aWRnZXRDbGFzcywgZnVuY3Rpb24oIF8sIGtsYXNzICkge1xuICAgICAgICAgICAgICAgICAgICAoIWRlYWN0aXZlcyB8fCAhfmRlYWN0aXZlcy5pbmRleE9mKCBrbGFzcy5fbmFtZSApKSAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgd2lkZ2V0cy5wdXNoKCBuZXcga2xhc3MoIG1lICkgKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICBcbiAgICAgICAgICAgICAgICByZXR1cm4gX2luaXQuYXBwbHkoIG1lLCBhcmd1bWVudHMgKTtcbiAgICAgICAgICAgIH0sXG4gICAgXG4gICAgICAgICAgICByZXF1ZXN0OiBmdW5jdGlvbiggYXBpTmFtZSwgYXJncywgY2FsbGJhY2sgKSB7XG4gICAgICAgICAgICAgICAgdmFyIGkgPSAwLFxuICAgICAgICAgICAgICAgICAgICB3aWRnZXRzID0gdGhpcy5fd2lkZ2V0cyxcbiAgICAgICAgICAgICAgICAgICAgbGVuID0gd2lkZ2V0cyAmJiB3aWRnZXRzLmxlbmd0aCxcbiAgICAgICAgICAgICAgICAgICAgcmx0cyA9IFtdLFxuICAgICAgICAgICAgICAgICAgICBkZmRzID0gW10sXG4gICAgICAgICAgICAgICAgICAgIHdpZGdldCwgcmx0LCBwcm9taXNlLCBrZXk7XG4gICAgXG4gICAgICAgICAgICAgICAgYXJncyA9IGlzQXJyYXlMaWtlKCBhcmdzICkgPyBhcmdzIDogWyBhcmdzIF07XG4gICAgXG4gICAgICAgICAgICAgICAgZm9yICggOyBpIDwgbGVuOyBpKysgKSB7XG4gICAgICAgICAgICAgICAgICAgIHdpZGdldCA9IHdpZGdldHNbIGkgXTtcbiAgICAgICAgICAgICAgICAgICAgcmx0ID0gd2lkZ2V0Lmludm9rZSggYXBpTmFtZSwgYXJncyApO1xuICAgIFxuICAgICAgICAgICAgICAgICAgICBpZiAoIHJsdCAhPT0gSUdOT1JFICkge1xuICAgIFxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gRGVmZXJyZWTlr7nosaFcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICggQmFzZS5pc1Byb21pc2UoIHJsdCApICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRmZHMucHVzaCggcmx0ICk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJsdHMucHVzaCggcmx0ICk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgXG4gICAgICAgICAgICAgICAgLy8g5aaC5p6c5pyJY2FsbGJhY2vvvIzliJnnlKjlvILmraXmlrnlvI/jgIJcbiAgICAgICAgICAgICAgICBpZiAoIGNhbGxiYWNrIHx8IGRmZHMubGVuZ3RoICkge1xuICAgICAgICAgICAgICAgICAgICBwcm9taXNlID0gQmFzZS53aGVuLmFwcGx5KCBCYXNlLCBkZmRzICk7XG4gICAgICAgICAgICAgICAgICAgIGtleSA9IHByb21pc2UucGlwZSA/ICdwaXBlJyA6ICd0aGVuJztcbiAgICBcbiAgICAgICAgICAgICAgICAgICAgLy8g5b6I6YeN6KaB5LiN6IO95Yig6Zmk44CC5Yig6Zmk5LqG5Lya5q275b6q546v44CCXG4gICAgICAgICAgICAgICAgICAgIC8vIOS/neivgeaJp+ihjOmhuuW6j+OAguiuqWNhbGxiYWNr5oC75piv5Zyo5LiL5LiA5LiqIHRpY2sg5Lit5omn6KGM44CCXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBwcm9taXNlWyBrZXkgXShmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGRlZmVycmVkID0gQmFzZS5EZWZlcnJlZCgpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXJncyA9IGFyZ3VtZW50cztcbiAgICBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCBhcmdzLmxlbmd0aCA9PT0gMSApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFyZ3MgPSBhcmdzWyAwIF07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlZmVycmVkLnJlc29sdmUoIGFyZ3MgKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSwgMSApO1xuICAgIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZGVmZXJyZWQucHJvbWlzZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pWyBjYWxsYmFjayA/IGtleSA6ICdkb25lJyBdKCBjYWxsYmFjayB8fCBCYXNlLm5vb3AgKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmx0c1sgMCBdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgXG4gICAgICAgICAgICBkZXN0cm95OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICBfZGVzdHJveS5hcHBseSggdGhpcywgYXJndW1lbnRzICk7XG4gICAgICAgICAgICAgICAgdGhpcy5fd2lkZ2V0cyA9IG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIFxuICAgICAgICAvKipcbiAgICAgICAgICog5re75Yqg57uE5Lu2XG4gICAgICAgICAqIEBncmFtbWFyIFVwbG9hZGVyLnJlZ2lzdGVyKHByb3RvKTtcbiAgICAgICAgICogQGdyYW1tYXIgVXBsb2FkZXIucmVnaXN0ZXIobWFwLCBwcm90byk7XG4gICAgICAgICAqIEBwYXJhbSAge29iamVjdH0gcmVzcG9uc2VNYXAgQVBJIOWQjeensOS4juWHveaVsOWunueOsOeahOaYoOWwhFxuICAgICAgICAgKiBAcGFyYW0gIHtvYmplY3R9IHByb3RvIOe7hOS7tuWOn+Wei++8jOaehOmAoOWHveaVsOmAmui/hyBjb25zdHJ1Y3RvciDlsZ7mgKflrprkuYlcbiAgICAgICAgICogQG1ldGhvZCBVcGxvYWRlci5yZWdpc3RlclxuICAgICAgICAgKiBAZm9yIFVwbG9hZGVyXG4gICAgICAgICAqIEBleGFtcGxlXG4gICAgICAgICAqIFVwbG9hZGVyLnJlZ2lzdGVyKHtcbiAgICAgICAgICogICAgICdtYWtlLXRodW1iJzogJ21ha2VUaHVtYidcbiAgICAgICAgICogfSwge1xuICAgICAgICAgKiAgICAgaW5pdDogZnVuY3Rpb24oIG9wdGlvbnMgKSB7fSxcbiAgICAgICAgICogICAgIG1ha2VUaHVtYjogZnVuY3Rpb24oKSB7fVxuICAgICAgICAgKiB9KTtcbiAgICAgICAgICpcbiAgICAgICAgICogVXBsb2FkZXIucmVnaXN0ZXIoe1xuICAgICAgICAgKiAgICAgJ21ha2UtdGh1bWInOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICogICAgICAgICBcbiAgICAgICAgICogICAgIH1cbiAgICAgICAgICogfSk7XG4gICAgICAgICAqL1xuICAgICAgICBVcGxvYWRlci5yZWdpc3RlciA9IFdpZGdldC5yZWdpc3RlciA9IGZ1bmN0aW9uKCByZXNwb25zZU1hcCwgd2lkZ2V0UHJvdG8gKSB7XG4gICAgICAgICAgICB2YXIgbWFwID0geyBpbml0OiAnaW5pdCcsIGRlc3Ryb3k6ICdkZXN0cm95JywgbmFtZTogJ2Fub255bW91cycgfSxcbiAgICAgICAgICAgICAgICBrbGFzcztcbiAgICBcbiAgICAgICAgICAgIGlmICggYXJndW1lbnRzLmxlbmd0aCA9PT0gMSApIHtcbiAgICAgICAgICAgICAgICB3aWRnZXRQcm90byA9IHJlc3BvbnNlTWFwO1xuICAgIFxuICAgICAgICAgICAgICAgIC8vIOiHquWKqOeUn+aIkCBtYXAg6KGo44CCXG4gICAgICAgICAgICAgICAgJC5lYWNoKHdpZGdldFByb3RvLCBmdW5jdGlvbihrZXkpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCBrZXlbMF0gPT09ICdfJyB8fCBrZXkgPT09ICduYW1lJyApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGtleSA9PT0gJ25hbWUnICYmIChtYXAubmFtZSA9IHdpZGdldFByb3RvLm5hbWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgXG4gICAgICAgICAgICAgICAgICAgIG1hcFtrZXkucmVwbGFjZSgvW0EtWl0vZywgJy0kJicpLnRvTG93ZXJDYXNlKCldID0ga2V5O1xuICAgICAgICAgICAgICAgIH0pO1xuICAgIFxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBtYXAgPSAkLmV4dGVuZCggbWFwLCByZXNwb25zZU1hcCApO1xuICAgICAgICAgICAgfVxuICAgIFxuICAgICAgICAgICAgd2lkZ2V0UHJvdG8ucmVzcG9uc2VNYXAgPSBtYXA7XG4gICAgICAgICAgICBrbGFzcyA9IEJhc2UuaW5oZXJpdHMoIFdpZGdldCwgd2lkZ2V0UHJvdG8gKTtcbiAgICAgICAgICAgIGtsYXNzLl9uYW1lID0gbWFwLm5hbWU7XG4gICAgICAgICAgICB3aWRnZXRDbGFzcy5wdXNoKCBrbGFzcyApO1xuICAgIFxuICAgICAgICAgICAgcmV0dXJuIGtsYXNzO1xuICAgICAgICB9O1xuICAgIFxuICAgICAgICAvKipcbiAgICAgICAgICog5Yig6Zmk5o+S5Lu277yM5Y+q5pyJ5Zyo5rOo5YaM5pe25oyH5a6a5LqG5ZCN5a2X55qE5omN6IO96KKr5Yig6Zmk44CCXG4gICAgICAgICAqIEBncmFtbWFyIFVwbG9hZGVyLnVuUmVnaXN0ZXIobmFtZSk7XG4gICAgICAgICAqIEBwYXJhbSAge3N0cmluZ30gbmFtZSDnu4Tku7blkI3lrZdcbiAgICAgICAgICogQG1ldGhvZCBVcGxvYWRlci51blJlZ2lzdGVyXG4gICAgICAgICAqIEBmb3IgVXBsb2FkZXJcbiAgICAgICAgICogQGV4YW1wbGVcbiAgICAgICAgICpcbiAgICAgICAgICogVXBsb2FkZXIucmVnaXN0ZXIoe1xuICAgICAgICAgKiAgICAgbmFtZTogJ2N1c3RvbScsXG4gICAgICAgICAqICAgICBcbiAgICAgICAgICogICAgICdtYWtlLXRodW1iJzogZnVuY3Rpb24oKSB7XG4gICAgICAgICAqICAgICAgICAgXG4gICAgICAgICAqICAgICB9XG4gICAgICAgICAqIH0pO1xuICAgICAgICAgKlxuICAgICAgICAgKiBVcGxvYWRlci51blJlZ2lzdGVyKCdjdXN0b20nKTtcbiAgICAgICAgICovXG4gICAgICAgIFVwbG9hZGVyLnVuUmVnaXN0ZXIgPSBXaWRnZXQudW5SZWdpc3RlciA9IGZ1bmN0aW9uKCBuYW1lICkge1xuICAgICAgICAgICAgaWYgKCAhbmFtZSB8fCBuYW1lID09PSAnYW5vbnltb3VzJyApIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIC8vIOWIoOmZpOaMh+WumueahOaPkuS7tuOAglxuICAgICAgICAgICAgZm9yICggdmFyIGkgPSB3aWRnZXRDbGFzcy5sZW5ndGg7IGktLTsgKSB7XG4gICAgICAgICAgICAgICAgaWYgKCB3aWRnZXRDbGFzc1tpXS5fbmFtZSA9PT0gbmFtZSApIHtcbiAgICAgICAgICAgICAgICAgICAgd2lkZ2V0Q2xhc3Muc3BsaWNlKGksIDEpXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgIFxuICAgICAgICByZXR1cm4gV2lkZ2V0O1xuICAgIH0pO1xuICAgIC8qKlxuICAgICAqIEBmaWxlT3ZlcnZpZXcgRHJhZ0FuZERyb3AgV2lkZ2V044CCXG4gICAgICovXG4gICAgZGVmaW5lKCd3aWRnZXRzL2ZpbGVkbmQnLFtcbiAgICAgICAgJ2Jhc2UnLFxuICAgICAgICAndXBsb2FkZXInLFxuICAgICAgICAnbGliL2RuZCcsXG4gICAgICAgICd3aWRnZXRzL3dpZGdldCdcbiAgICBdLCBmdW5jdGlvbiggQmFzZSwgVXBsb2FkZXIsIERuZCApIHtcbiAgICAgICAgdmFyICQgPSBCYXNlLiQ7XG4gICAgXG4gICAgICAgIFVwbG9hZGVyLm9wdGlvbnMuZG5kID0gJyc7XG4gICAgXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcHJvcGVydHkge1NlbGVjdG9yfSBbZG5kPXVuZGVmaW5lZF0gIOaMh+WumkRyYWcgQW5kIERyb3Dmi5bmi73nmoTlrrnlmajvvIzlpoLmnpzkuI3mjIflrprvvIzliJnkuI3lkK/liqjjgIJcbiAgICAgICAgICogQG5hbWVzcGFjZSBvcHRpb25zXG4gICAgICAgICAqIEBmb3IgVXBsb2FkZXJcbiAgICAgICAgICovXG4gICAgICAgIFxuICAgICAgICAvKipcbiAgICAgICAgICogQHByb3BlcnR5IHtTZWxlY3Rvcn0gW2Rpc2FibGVHbG9iYWxEbmQ9ZmFsc2VdICDmmK/lkKbnpoHmjonmlbTkuKrpobXpnaLnmoTmi5bmi73lip/og73vvIzlpoLmnpzkuI3npoHnlKjvvIzlm77niYfmi5bov5vmnaXnmoTml7blgJnkvJrpu5jorqTooqvmtY/op4jlmajmiZPlvIDjgIJcbiAgICAgICAgICogQG5hbWVzcGFjZSBvcHRpb25zXG4gICAgICAgICAqIEBmb3IgVXBsb2FkZXJcbiAgICAgICAgICovXG4gICAgXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAZXZlbnQgZG5kQWNjZXB0XG4gICAgICAgICAqIEBwYXJhbSB7RGF0YVRyYW5zZmVySXRlbUxpc3R9IGl0ZW1zIERhdGFUcmFuc2Zlckl0ZW1cbiAgICAgICAgICogQGRlc2NyaXB0aW9uIOmYu+atouatpOS6i+S7tuWPr+S7peaLkue7neafkOS6m+exu+Wei+eahOaWh+S7tuaLluWFpei/m+adpeOAguebruWJjeWPquaciSBjaHJvbWUg5o+Q5L6b6L+Z5qC355qEIEFQSe+8jOS4lOWPquiDvemAmui/hyBtaW1lLXR5cGUg6aqM6K+B44CCXG4gICAgICAgICAqIEBmb3IgIFVwbG9hZGVyXG4gICAgICAgICAqL1xuICAgICAgICByZXR1cm4gVXBsb2FkZXIucmVnaXN0ZXIoe1xuICAgICAgICAgICAgbmFtZTogJ2RuZCcsXG4gICAgICAgICAgICBcbiAgICAgICAgICAgIGluaXQ6IGZ1bmN0aW9uKCBvcHRzICkge1xuICAgIFxuICAgICAgICAgICAgICAgIGlmICggIW9wdHMuZG5kIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnJlcXVlc3QoJ3ByZWRpY3QtcnVudGltZS10eXBlJykgIT09ICdodG1sNScgKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgXG4gICAgICAgICAgICAgICAgdmFyIG1lID0gdGhpcyxcbiAgICAgICAgICAgICAgICAgICAgZGVmZXJyZWQgPSBCYXNlLkRlZmVycmVkKCksXG4gICAgICAgICAgICAgICAgICAgIG9wdGlvbnMgPSAkLmV4dGVuZCh7fSwge1xuICAgICAgICAgICAgICAgICAgICAgICAgZGlzYWJsZUdsb2JhbERuZDogb3B0cy5kaXNhYmxlR2xvYmFsRG5kLFxuICAgICAgICAgICAgICAgICAgICAgICAgY29udGFpbmVyOiBvcHRzLmRuZCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGFjY2VwdDogb3B0cy5hY2NlcHRcbiAgICAgICAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICAgICAgICAgIGRuZDtcbiAgICBcbiAgICAgICAgICAgICAgICB0aGlzLmRuZCA9IGRuZCA9IG5ldyBEbmQoIG9wdGlvbnMgKTtcbiAgICBcbiAgICAgICAgICAgICAgICBkbmQub25jZSggJ3JlYWR5JywgZGVmZXJyZWQucmVzb2x2ZSApO1xuICAgICAgICAgICAgICAgIGRuZC5vbiggJ2Ryb3AnLCBmdW5jdGlvbiggZmlsZXMgKSB7XG4gICAgICAgICAgICAgICAgICAgIG1lLnJlcXVlc3QoICdhZGQtZmlsZScsIFsgZmlsZXMgXSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgXG4gICAgICAgICAgICAgICAgLy8g5qOA5rWL5paH5Lu25piv5ZCm5YWo6YOo5YWB6K645re75Yqg44CCXG4gICAgICAgICAgICAgICAgZG5kLm9uKCAnYWNjZXB0JywgZnVuY3Rpb24oIGl0ZW1zICkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbWUub3duZXIudHJpZ2dlciggJ2RuZEFjY2VwdCcsIGl0ZW1zICk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgXG4gICAgICAgICAgICAgICAgZG5kLmluaXQoKTtcbiAgICBcbiAgICAgICAgICAgICAgICByZXR1cm4gZGVmZXJyZWQucHJvbWlzZSgpO1xuICAgICAgICAgICAgfSxcbiAgICBcbiAgICAgICAgICAgIGRlc3Ryb3k6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHRoaXMuZG5kICYmIHRoaXMuZG5kLmRlc3Ryb3koKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfSk7XG4gICAgXG4gICAgLyoqXG4gICAgICogQGZpbGVPdmVydmlldyDplJnor6/kv6Hmga9cbiAgICAgKi9cbiAgICBkZWZpbmUoJ2xpYi9maWxlcGFzdGUnLFtcbiAgICAgICAgJ2Jhc2UnLFxuICAgICAgICAnbWVkaWF0b3InLFxuICAgICAgICAncnVudGltZS9jbGllbnQnXG4gICAgXSwgZnVuY3Rpb24oIEJhc2UsIE1lZGlhdG9yLCBSdW50aW1lQ2xlbnQgKSB7XG4gICAgXG4gICAgICAgIHZhciAkID0gQmFzZS4kO1xuICAgIFxuICAgICAgICBmdW5jdGlvbiBGaWxlUGFzdGUoIG9wdHMgKSB7XG4gICAgICAgICAgICBvcHRzID0gdGhpcy5vcHRpb25zID0gJC5leHRlbmQoe30sIG9wdHMgKTtcbiAgICAgICAgICAgIG9wdHMuY29udGFpbmVyID0gJCggb3B0cy5jb250YWluZXIgfHwgZG9jdW1lbnQuYm9keSApO1xuICAgICAgICAgICAgUnVudGltZUNsZW50LmNhbGwoIHRoaXMsICdGaWxlUGFzdGUnICk7XG4gICAgICAgIH1cbiAgICBcbiAgICAgICAgQmFzZS5pbmhlcml0cyggUnVudGltZUNsZW50LCB7XG4gICAgICAgICAgICBjb25zdHJ1Y3RvcjogRmlsZVBhc3RlLFxuICAgIFxuICAgICAgICAgICAgaW5pdDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgdmFyIG1lID0gdGhpcztcbiAgICBcbiAgICAgICAgICAgICAgICBtZS5jb25uZWN0UnVudGltZSggbWUub3B0aW9ucywgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIG1lLmV4ZWMoJ2luaXQnKTtcbiAgICAgICAgICAgICAgICAgICAgbWUudHJpZ2dlcigncmVhZHknKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgXG4gICAgICAgIE1lZGlhdG9yLmluc3RhbGxUbyggRmlsZVBhc3RlLnByb3RvdHlwZSApO1xuICAgIFxuICAgICAgICByZXR1cm4gRmlsZVBhc3RlO1xuICAgIH0pO1xuICAgIC8qKlxuICAgICAqIEBmaWxlT3ZlcnZpZXcg57uE5Lu25Z+657G744CCXG4gICAgICovXG4gICAgZGVmaW5lKCd3aWRnZXRzL2ZpbGVwYXN0ZScsW1xuICAgICAgICAnYmFzZScsXG4gICAgICAgICd1cGxvYWRlcicsXG4gICAgICAgICdsaWIvZmlsZXBhc3RlJyxcbiAgICAgICAgJ3dpZGdldHMvd2lkZ2V0J1xuICAgIF0sIGZ1bmN0aW9uKCBCYXNlLCBVcGxvYWRlciwgRmlsZVBhc3RlICkge1xuICAgICAgICB2YXIgJCA9IEJhc2UuJDtcbiAgICBcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwcm9wZXJ0eSB7U2VsZWN0b3J9IFtwYXN0ZT11bmRlZmluZWRdICDmjIflrprnm5HlkKxwYXN0ZeS6i+S7tueahOWuueWZqO+8jOWmguaenOS4jeaMh+Wumu+8jOS4jeWQr+eUqOatpOWKn+iDveOAguatpOWKn+iDveS4uumAmui/h+eymOi0tOadpea3u+WKoOaIquWxj+eahOWbvueJh+OAguW7uuiuruiuvue9ruS4umBkb2N1bWVudC5ib2R5YC5cbiAgICAgICAgICogQG5hbWVzcGFjZSBvcHRpb25zXG4gICAgICAgICAqIEBmb3IgVXBsb2FkZXJcbiAgICAgICAgICovXG4gICAgICAgIHJldHVybiBVcGxvYWRlci5yZWdpc3Rlcih7XG4gICAgICAgICAgICBuYW1lOiAncGFzdGUnLFxuICAgICAgICAgICAgXG4gICAgICAgICAgICBpbml0OiBmdW5jdGlvbiggb3B0cyApIHtcbiAgICBcbiAgICAgICAgICAgICAgICBpZiAoICFvcHRzLnBhc3RlIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnJlcXVlc3QoJ3ByZWRpY3QtcnVudGltZS10eXBlJykgIT09ICdodG1sNScgKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgXG4gICAgICAgICAgICAgICAgdmFyIG1lID0gdGhpcyxcbiAgICAgICAgICAgICAgICAgICAgZGVmZXJyZWQgPSBCYXNlLkRlZmVycmVkKCksXG4gICAgICAgICAgICAgICAgICAgIG9wdGlvbnMgPSAkLmV4dGVuZCh7fSwge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29udGFpbmVyOiBvcHRzLnBhc3RlLFxuICAgICAgICAgICAgICAgICAgICAgICAgYWNjZXB0OiBvcHRzLmFjY2VwdFxuICAgICAgICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgICAgICAgICAgcGFzdGU7XG4gICAgXG4gICAgICAgICAgICAgICAgdGhpcy5wYXN0ZSA9IHBhc3RlID0gbmV3IEZpbGVQYXN0ZSggb3B0aW9ucyApO1xuICAgIFxuICAgICAgICAgICAgICAgIHBhc3RlLm9uY2UoICdyZWFkeScsIGRlZmVycmVkLnJlc29sdmUgKTtcbiAgICAgICAgICAgICAgICBwYXN0ZS5vbiggJ3Bhc3RlJywgZnVuY3Rpb24oIGZpbGVzICkge1xuICAgICAgICAgICAgICAgICAgICBtZS5vd25lci5yZXF1ZXN0KCAnYWRkLWZpbGUnLCBbIGZpbGVzIF0pO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHBhc3RlLmluaXQoKTtcbiAgICBcbiAgICAgICAgICAgICAgICByZXR1cm4gZGVmZXJyZWQucHJvbWlzZSgpO1xuICAgICAgICAgICAgfSxcbiAgICBcbiAgICAgICAgICAgIGRlc3Ryb3k6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHRoaXMucGFzdGUgJiYgdGhpcy5wYXN0ZS5kZXN0cm95KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH0pO1xuICAgIC8qKlxuICAgICAqIEBmaWxlT3ZlcnZpZXcgQmxvYlxuICAgICAqL1xuICAgIGRlZmluZSgnbGliL2Jsb2InLFtcbiAgICAgICAgJ2Jhc2UnLFxuICAgICAgICAncnVudGltZS9jbGllbnQnXG4gICAgXSwgZnVuY3Rpb24oIEJhc2UsIFJ1bnRpbWVDbGllbnQgKSB7XG4gICAgXG4gICAgICAgIGZ1bmN0aW9uIEJsb2IoIHJ1aWQsIHNvdXJjZSApIHtcbiAgICAgICAgICAgIHZhciBtZSA9IHRoaXM7XG4gICAgXG4gICAgICAgICAgICBtZS5zb3VyY2UgPSBzb3VyY2U7XG4gICAgICAgICAgICBtZS5ydWlkID0gcnVpZDtcbiAgICAgICAgICAgIHRoaXMuc2l6ZSA9IHNvdXJjZS5zaXplIHx8IDA7XG4gICAgXG4gICAgICAgICAgICAvLyDlpoLmnpzmsqHmnInmjIflrpogbWltZXR5cGUsIOS9huaYr+efpemBk+aWh+S7tuWQjue8gOOAglxuICAgICAgICAgICAgaWYgKCAhc291cmNlLnR5cGUgJiYgdGhpcy5leHQgJiZcbiAgICAgICAgICAgICAgICAgICAgfidqcGcsanBlZyxwbmcsZ2lmLGJtcCcuaW5kZXhPZiggdGhpcy5leHQgKSApIHtcbiAgICAgICAgICAgICAgICB0aGlzLnR5cGUgPSAnaW1hZ2UvJyArICh0aGlzLmV4dCA9PT0gJ2pwZycgPyAnanBlZycgOiB0aGlzLmV4dCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMudHlwZSA9IHNvdXJjZS50eXBlIHx8ICdhcHBsaWNhdGlvbi9vY3RldC1zdHJlYW0nO1xuICAgICAgICAgICAgfVxuICAgIFxuICAgICAgICAgICAgUnVudGltZUNsaWVudC5jYWxsKCBtZSwgJ0Jsb2InICk7XG4gICAgICAgICAgICB0aGlzLnVpZCA9IHNvdXJjZS51aWQgfHwgdGhpcy51aWQ7XG4gICAgXG4gICAgICAgICAgICBpZiAoIHJ1aWQgKSB7XG4gICAgICAgICAgICAgICAgbWUuY29ubmVjdFJ1bnRpbWUoIHJ1aWQgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIFxuICAgICAgICBCYXNlLmluaGVyaXRzKCBSdW50aW1lQ2xpZW50LCB7XG4gICAgICAgICAgICBjb25zdHJ1Y3RvcjogQmxvYixcbiAgICBcbiAgICAgICAgICAgIHNsaWNlOiBmdW5jdGlvbiggc3RhcnQsIGVuZCApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5leGVjKCAnc2xpY2UnLCBzdGFydCwgZW5kICk7XG4gICAgICAgICAgICB9LFxuICAgIFxuICAgICAgICAgICAgZ2V0U291cmNlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5zb3VyY2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIFxuICAgICAgICByZXR1cm4gQmxvYjtcbiAgICB9KTtcbiAgICAvKipcbiAgICAgKiDkuLrkuobnu5/kuIDljJZGbGFzaOeahEZpbGXlkoxIVE1MNeeahEZpbGXogIzlrZjlnKjjgIJcbiAgICAgKiDku6Xoh7Pkuo7opoHosIPnlKhGbGFzaOmHjOmdoueahEZpbGXvvIzkuZ/lj6/ku6Xlg4/osIPnlKhIVE1MNeeJiOacrOeahEZpbGXkuIDkuIvjgIJcbiAgICAgKiBAZmlsZU92ZXJ2aWV3IEZpbGVcbiAgICAgKi9cbiAgICBkZWZpbmUoJ2xpYi9maWxlJyxbXG4gICAgICAgICdiYXNlJyxcbiAgICAgICAgJ2xpYi9ibG9iJ1xuICAgIF0sIGZ1bmN0aW9uKCBCYXNlLCBCbG9iICkge1xuICAgIFxuICAgICAgICB2YXIgdWlkID0gMSxcbiAgICAgICAgICAgIHJFeHQgPSAvXFwuKFteLl0rKSQvO1xuICAgIFxuICAgICAgICBmdW5jdGlvbiBGaWxlKCBydWlkLCBmaWxlICkge1xuICAgICAgICAgICAgdmFyIGV4dDtcbiAgICBcbiAgICAgICAgICAgIHRoaXMubmFtZSA9IGZpbGUubmFtZSB8fCAoJ3VudGl0bGVkJyArIHVpZCsrKTtcbiAgICAgICAgICAgIGV4dCA9IHJFeHQuZXhlYyggZmlsZS5uYW1lICkgPyBSZWdFeHAuJDEudG9Mb3dlckNhc2UoKSA6ICcnO1xuICAgIFxuICAgICAgICAgICAgLy8gdG9kbyDmlK/mjIHlhbbku5bnsbvlnovmlofku7bnmoTovazmjaLjgIJcbiAgICAgICAgICAgIC8vIOWmguaenOaciSBtaW1ldHlwZSwg5L2G5piv5paH5Lu25ZCN6YeM6Z2i5rKh5pyJ5om+5Ye65ZCO57yA6KeE5b6LXG4gICAgICAgICAgICBpZiAoICFleHQgJiYgZmlsZS50eXBlICkge1xuICAgICAgICAgICAgICAgIGV4dCA9IC9cXC8oanBnfGpwZWd8cG5nfGdpZnxibXApJC9pLmV4ZWMoIGZpbGUudHlwZSApID9cbiAgICAgICAgICAgICAgICAgICAgICAgIFJlZ0V4cC4kMS50b0xvd2VyQ2FzZSgpIDogJyc7XG4gICAgICAgICAgICAgICAgdGhpcy5uYW1lICs9ICcuJyArIGV4dDtcbiAgICAgICAgICAgIH1cbiAgICBcbiAgICAgICAgICAgIHRoaXMuZXh0ID0gZXh0O1xuICAgICAgICAgICAgdGhpcy5sYXN0TW9kaWZpZWREYXRlID0gZmlsZS5sYXN0TW9kaWZpZWREYXRlIHx8XG4gICAgICAgICAgICAgICAgICAgIChuZXcgRGF0ZSgpKS50b0xvY2FsZVN0cmluZygpO1xuICAgIFxuICAgICAgICAgICAgQmxvYi5hcHBseSggdGhpcywgYXJndW1lbnRzICk7XG4gICAgICAgIH1cbiAgICBcbiAgICAgICAgcmV0dXJuIEJhc2UuaW5oZXJpdHMoIEJsb2IsIEZpbGUgKTtcbiAgICB9KTtcbiAgICBcbiAgICAvKipcbiAgICAgKiBAZmlsZU92ZXJ2aWV3IOmUmeivr+S/oeaBr1xuICAgICAqL1xuICAgIGRlZmluZSgnbGliL2ZpbGVwaWNrZXInLFtcbiAgICAgICAgJ2Jhc2UnLFxuICAgICAgICAncnVudGltZS9jbGllbnQnLFxuICAgICAgICAnbGliL2ZpbGUnXG4gICAgXSwgZnVuY3Rpb24oIEJhc2UsIFJ1bnRpbWVDbGVudCwgRmlsZSApIHtcbiAgICBcbiAgICAgICAgdmFyICQgPSBCYXNlLiQ7XG4gICAgXG4gICAgICAgIGZ1bmN0aW9uIEZpbGVQaWNrZXIoIG9wdHMgKSB7XG4gICAgICAgICAgICBvcHRzID0gdGhpcy5vcHRpb25zID0gJC5leHRlbmQoe30sIEZpbGVQaWNrZXIub3B0aW9ucywgb3B0cyApO1xuICAgIFxuICAgICAgICAgICAgb3B0cy5jb250YWluZXIgPSAkKCBvcHRzLmlkICk7XG4gICAgXG4gICAgICAgICAgICBpZiAoICFvcHRzLmNvbnRhaW5lci5sZW5ndGggKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCfmjInpkq7mjIflrprplJnor68nKTtcbiAgICAgICAgICAgIH1cbiAgICBcbiAgICAgICAgICAgIG9wdHMuaW5uZXJIVE1MID0gb3B0cy5pbm5lckhUTUwgfHwgb3B0cy5sYWJlbCB8fFxuICAgICAgICAgICAgICAgICAgICBvcHRzLmNvbnRhaW5lci5odG1sKCkgfHwgJyc7XG4gICAgXG4gICAgICAgICAgICBvcHRzLmJ1dHRvbiA9ICQoIG9wdHMuYnV0dG9uIHx8IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpICk7XG4gICAgICAgICAgICBvcHRzLmJ1dHRvbi5odG1sKCBvcHRzLmlubmVySFRNTCApO1xuICAgICAgICAgICAgb3B0cy5jb250YWluZXIuaHRtbCggb3B0cy5idXR0b24gKTtcbiAgICBcbiAgICAgICAgICAgIFJ1bnRpbWVDbGVudC5jYWxsKCB0aGlzLCAnRmlsZVBpY2tlcicsIHRydWUgKTtcbiAgICAgICAgfVxuICAgIFxuICAgICAgICBGaWxlUGlja2VyLm9wdGlvbnMgPSB7XG4gICAgICAgICAgICBidXR0b246IG51bGwsXG4gICAgICAgICAgICBjb250YWluZXI6IG51bGwsXG4gICAgICAgICAgICBsYWJlbDogbnVsbCxcbiAgICAgICAgICAgIGlubmVySFRNTDogbnVsbCxcbiAgICAgICAgICAgIG11bHRpcGxlOiB0cnVlLFxuICAgICAgICAgICAgYWNjZXB0OiBudWxsLFxuICAgICAgICAgICAgbmFtZTogJ2ZpbGUnXG4gICAgICAgIH07XG4gICAgXG4gICAgICAgIEJhc2UuaW5oZXJpdHMoIFJ1bnRpbWVDbGVudCwge1xuICAgICAgICAgICAgY29uc3RydWN0b3I6IEZpbGVQaWNrZXIsXG4gICAgXG4gICAgICAgICAgICBpbml0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICB2YXIgbWUgPSB0aGlzLFxuICAgICAgICAgICAgICAgICAgICBvcHRzID0gbWUub3B0aW9ucyxcbiAgICAgICAgICAgICAgICAgICAgYnV0dG9uID0gb3B0cy5idXR0b247XG4gICAgXG4gICAgICAgICAgICAgICAgYnV0dG9uLmFkZENsYXNzKCd3ZWJ1cGxvYWRlci1waWNrJyk7XG4gICAgXG4gICAgICAgICAgICAgICAgbWUub24oICdhbGwnLCBmdW5jdGlvbiggdHlwZSApIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGZpbGVzO1xuICAgIFxuICAgICAgICAgICAgICAgICAgICBzd2l0Y2ggKCB0eXBlICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAnbW91c2VlbnRlcic6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnV0dG9uLmFkZENsYXNzKCd3ZWJ1cGxvYWRlci1waWNrLWhvdmVyJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgXG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlICdtb3VzZWxlYXZlJzpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBidXR0b24ucmVtb3ZlQ2xhc3MoJ3dlYnVwbG9hZGVyLXBpY2staG92ZXInKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICBcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJ2NoYW5nZSc6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZmlsZXMgPSBtZS5leGVjKCdnZXRGaWxlcycpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1lLnRyaWdnZXIoICdzZWxlY3QnLCAkLm1hcCggZmlsZXMsIGZ1bmN0aW9uKCBmaWxlICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmaWxlID0gbmV3IEZpbGUoIG1lLmdldFJ1aWQoKSwgZmlsZSApO1xuICAgIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyDorrDlvZXmnaXmupDjgIJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZmlsZS5fcmVmZXIgPSBvcHRzLmNvbnRhaW5lcjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZpbGU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSksIG9wdHMuY29udGFpbmVyICk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICBcbiAgICAgICAgICAgICAgICBtZS5jb25uZWN0UnVudGltZSggb3B0cywgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIG1lLnJlZnJlc2goKTtcbiAgICAgICAgICAgICAgICAgICAgbWUuZXhlYyggJ2luaXQnLCBvcHRzICk7XG4gICAgICAgICAgICAgICAgICAgIG1lLnRyaWdnZXIoJ3JlYWR5Jyk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgXG4gICAgICAgICAgICAgICAgdGhpcy5fcmVzaXplSGFuZGxlciA9IEJhc2UuYmluZEZuKCB0aGlzLnJlZnJlc2gsIHRoaXMgKTtcbiAgICAgICAgICAgICAgICAkKCB3aW5kb3cgKS5vbiggJ3Jlc2l6ZScsIHRoaXMuX3Jlc2l6ZUhhbmRsZXIgKTtcbiAgICAgICAgICAgIH0sXG4gICAgXG4gICAgICAgICAgICByZWZyZXNoOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICB2YXIgc2hpbUNvbnRhaW5lciA9IHRoaXMuZ2V0UnVudGltZSgpLmdldENvbnRhaW5lcigpLFxuICAgICAgICAgICAgICAgICAgICBidXR0b24gPSB0aGlzLm9wdGlvbnMuYnV0dG9uLFxuICAgICAgICAgICAgICAgICAgICB3aWR0aCA9IGJ1dHRvbi5vdXRlcldpZHRoID9cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBidXR0b24ub3V0ZXJXaWR0aCgpIDogYnV0dG9uLndpZHRoKCksXG4gICAgXG4gICAgICAgICAgICAgICAgICAgIGhlaWdodCA9IGJ1dHRvbi5vdXRlckhlaWdodCA/XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnV0dG9uLm91dGVySGVpZ2h0KCkgOiBidXR0b24uaGVpZ2h0KCksXG4gICAgXG4gICAgICAgICAgICAgICAgICAgIHBvcyA9IGJ1dHRvbi5vZmZzZXQoKTtcbiAgICBcbiAgICAgICAgICAgICAgICB3aWR0aCAmJiBoZWlnaHQgJiYgc2hpbUNvbnRhaW5lci5jc3Moe1xuICAgICAgICAgICAgICAgICAgICBib3R0b206ICdhdXRvJyxcbiAgICAgICAgICAgICAgICAgICAgcmlnaHQ6ICdhdXRvJyxcbiAgICAgICAgICAgICAgICAgICAgd2lkdGg6IHdpZHRoICsgJ3B4JyxcbiAgICAgICAgICAgICAgICAgICAgaGVpZ2h0OiBoZWlnaHQgKyAncHgnXG4gICAgICAgICAgICAgICAgfSkub2Zmc2V0KCBwb3MgKTtcbiAgICAgICAgICAgIH0sXG4gICAgXG4gICAgICAgICAgICBlbmFibGU6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHZhciBidG4gPSB0aGlzLm9wdGlvbnMuYnV0dG9uO1xuICAgIFxuICAgICAgICAgICAgICAgIGJ0bi5yZW1vdmVDbGFzcygnd2VidXBsb2FkZXItcGljay1kaXNhYmxlJyk7XG4gICAgICAgICAgICAgICAgdGhpcy5yZWZyZXNoKCk7XG4gICAgICAgICAgICB9LFxuICAgIFxuICAgICAgICAgICAgZGlzYWJsZTogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgdmFyIGJ0biA9IHRoaXMub3B0aW9ucy5idXR0b247XG4gICAgXG4gICAgICAgICAgICAgICAgdGhpcy5nZXRSdW50aW1lKCkuZ2V0Q29udGFpbmVyKCkuY3NzKHtcbiAgICAgICAgICAgICAgICAgICAgdG9wOiAnLTk5OTk5cHgnXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgXG4gICAgICAgICAgICAgICAgYnRuLmFkZENsYXNzKCd3ZWJ1cGxvYWRlci1waWNrLWRpc2FibGUnKTtcbiAgICAgICAgICAgIH0sXG4gICAgXG4gICAgICAgICAgICBkZXN0cm95OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICB2YXIgYnRuID0gdGhpcy5vcHRpb25zLmJ1dHRvbjtcbiAgICAgICAgICAgICAgICAkKCB3aW5kb3cgKS5vZmYoICdyZXNpemUnLCB0aGlzLl9yZXNpemVIYW5kbGVyICk7XG4gICAgICAgICAgICAgICAgYnRuLnJlbW92ZUNsYXNzKCd3ZWJ1cGxvYWRlci1waWNrLWRpc2FibGUgd2VidXBsb2FkZXItcGljay1ob3ZlciAnICtcbiAgICAgICAgICAgICAgICAgICAgJ3dlYnVwbG9hZGVyLXBpY2snKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgXG4gICAgICAgIHJldHVybiBGaWxlUGlja2VyO1xuICAgIH0pO1xuICAgIFxuICAgIC8qKlxuICAgICAqIEBmaWxlT3ZlcnZpZXcg5paH5Lu26YCJ5oup55u45YWzXG4gICAgICovXG4gICAgZGVmaW5lKCd3aWRnZXRzL2ZpbGVwaWNrZXInLFtcbiAgICAgICAgJ2Jhc2UnLFxuICAgICAgICAndXBsb2FkZXInLFxuICAgICAgICAnbGliL2ZpbGVwaWNrZXInLFxuICAgICAgICAnd2lkZ2V0cy93aWRnZXQnXG4gICAgXSwgZnVuY3Rpb24oIEJhc2UsIFVwbG9hZGVyLCBGaWxlUGlja2VyICkge1xuICAgICAgICB2YXIgJCA9IEJhc2UuJDtcbiAgICBcbiAgICAgICAgJC5leHRlbmQoIFVwbG9hZGVyLm9wdGlvbnMsIHtcbiAgICBcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogQHByb3BlcnR5IHtTZWxlY3RvciB8IE9iamVjdH0gW3BpY2s9dW5kZWZpbmVkXVxuICAgICAgICAgICAgICogQG5hbWVzcGFjZSBvcHRpb25zXG4gICAgICAgICAgICAgKiBAZm9yIFVwbG9hZGVyXG4gICAgICAgICAgICAgKiBAZGVzY3JpcHRpb24g5oyH5a6a6YCJ5oup5paH5Lu255qE5oyJ6ZKu5a655Zmo77yM5LiN5oyH5a6a5YiZ5LiN5Yib5bu65oyJ6ZKu44CCXG4gICAgICAgICAgICAgKlxuICAgICAgICAgICAgICogKiBgaWRgIHtTZWxldG9yfGRvbX0g5oyH5a6a6YCJ5oup5paH5Lu255qE5oyJ6ZKu5a655Zmo77yM5LiN5oyH5a6a5YiZ5LiN5Yib5bu65oyJ6ZKu44CCKirms6jmhI8qKiDov5nph4zomb3nhLblhpnnmoTmmK8gaWQsIOS9huaYr+S4jeaYr+WPquaUr+aMgSBpZCwg6L+Y5pSv5oyBIGNsYXNzLCDmiJbogIUgZG9tIOiKgueCueOAglxuICAgICAgICAgICAgICogKiBgbGFiZWxgIHtTdHJpbmd9IOivt+mHh+eUqCBgaW5uZXJIVE1MYCDku6Pmm79cbiAgICAgICAgICAgICAqICogYGlubmVySFRNTGAge1N0cmluZ30g5oyH5a6a5oyJ6ZKu5paH5a2X44CC5LiN5oyH5a6a5pe25LyY5YWI5LuO5oyH5a6a55qE5a655Zmo5Lit55yL5piv5ZCm6Ieq5bim5paH5a2X44CCXG4gICAgICAgICAgICAgKiAqIGBtdWx0aXBsZWAge0Jvb2xlYW59IOaYr+WQpuW8gOi1t+WQjOaXtumAieaLqeWkmuS4quaWh+S7tuiDveWKm+OAglxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBwaWNrOiBudWxsLFxuICAgIFxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBAcHJvcGVydHkge0Fycm95fSBbYWNjZXB0PW51bGxdXG4gICAgICAgICAgICAgKiBAbmFtZXNwYWNlIG9wdGlvbnNcbiAgICAgICAgICAgICAqIEBmb3IgVXBsb2FkZXJcbiAgICAgICAgICAgICAqIEBkZXNjcmlwdGlvbiDmjIflrprmjqXlj5flk6rkupvnsbvlnovnmoTmlofku7bjgIIg55Sx5LqO55uu5YmN6L+Y5pyJZXh06L2sbWltZVR5cGXooajvvIzmiYDku6Xov5nph4zpnIDopoHliIblvIDmjIflrprjgIJcbiAgICAgICAgICAgICAqXG4gICAgICAgICAgICAgKiAqIGB0aXRsZWAge1N0cmluZ30g5paH5a2X5o+P6L+wXG4gICAgICAgICAgICAgKiAqIGBleHRlbnNpb25zYCB7U3RyaW5nfSDlhYHorrjnmoTmlofku7blkI7nvIDvvIzkuI3luKbngrnvvIzlpJrkuKrnlKjpgJflj7fliIblibLjgIJcbiAgICAgICAgICAgICAqICogYG1pbWVUeXBlc2Age1N0cmluZ30g5aSa5Liq55So6YCX5Y+35YiG5Ymy44CCXG4gICAgICAgICAgICAgKlxuICAgICAgICAgICAgICog5aaC77yaXG4gICAgICAgICAgICAgKlxuICAgICAgICAgICAgICogYGBgXG4gICAgICAgICAgICAgKiB7XG4gICAgICAgICAgICAgKiAgICAgdGl0bGU6ICdJbWFnZXMnLFxuICAgICAgICAgICAgICogICAgIGV4dGVuc2lvbnM6ICdnaWYsanBnLGpwZWcsYm1wLHBuZycsXG4gICAgICAgICAgICAgKiAgICAgbWltZVR5cGVzOiAnaW1hZ2UvKidcbiAgICAgICAgICAgICAqIH1cbiAgICAgICAgICAgICAqIGBgYFxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBhY2NlcHQ6IG51bGwvKntcbiAgICAgICAgICAgICAgICB0aXRsZTogJ0ltYWdlcycsXG4gICAgICAgICAgICAgICAgZXh0ZW5zaW9uczogJ2dpZixqcGcsanBlZyxibXAscG5nJyxcbiAgICAgICAgICAgICAgICBtaW1lVHlwZXM6ICdpbWFnZS8qJ1xuICAgICAgICAgICAgfSovXG4gICAgICAgIH0pO1xuICAgIFxuICAgICAgICByZXR1cm4gVXBsb2FkZXIucmVnaXN0ZXIoe1xuICAgICAgICAgICAgbmFtZTogJ3BpY2tlcicsXG4gICAgXG4gICAgICAgICAgICBpbml0OiBmdW5jdGlvbiggb3B0cyApIHtcbiAgICAgICAgICAgICAgICB0aGlzLnBpY2tlcnMgPSBbXTtcbiAgICAgICAgICAgICAgICByZXR1cm4gb3B0cy5waWNrICYmIHRoaXMuYWRkQnRuKCBvcHRzLnBpY2sgKTtcbiAgICAgICAgICAgIH0sXG4gICAgXG4gICAgICAgICAgICByZWZyZXNoOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAkLmVhY2goIHRoaXMucGlja2VycywgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucmVmcmVzaCgpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSxcbiAgICBcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogQG1ldGhvZCBhZGRCdXR0b25cbiAgICAgICAgICAgICAqIEBmb3IgVXBsb2FkZXJcbiAgICAgICAgICAgICAqIEBncmFtbWFyIGFkZEJ1dHRvbiggcGljayApID0+IFByb21pc2VcbiAgICAgICAgICAgICAqIEBkZXNjcmlwdGlvblxuICAgICAgICAgICAgICog5re75Yqg5paH5Lu26YCJ5oup5oyJ6ZKu77yM5aaC5p6c5LiA5Liq5oyJ6ZKu5LiN5aSf77yM6ZyA6KaB6LCD55So5q2k5pa55rOV5p2l5re75Yqg44CC5Y+C5pWw6LefW29wdGlvbnMucGlja10oI1dlYlVwbG9hZGVyOlVwbG9hZGVyOm9wdGlvbnMp5LiA6Ie044CCXG4gICAgICAgICAgICAgKiBAZXhhbXBsZVxuICAgICAgICAgICAgICogdXBsb2FkZXIuYWRkQnV0dG9uKHtcbiAgICAgICAgICAgICAqICAgICBpZDogJyNidG5Db250YWluZXInLFxuICAgICAgICAgICAgICogICAgIGlubmVySFRNTDogJ+mAieaLqeaWh+S7tidcbiAgICAgICAgICAgICAqIH0pO1xuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBhZGRCdG46IGZ1bmN0aW9uKCBwaWNrICkge1xuICAgICAgICAgICAgICAgIHZhciBtZSA9IHRoaXMsXG4gICAgICAgICAgICAgICAgICAgIG9wdHMgPSBtZS5vcHRpb25zLFxuICAgICAgICAgICAgICAgICAgICBhY2NlcHQgPSBvcHRzLmFjY2VwdCxcbiAgICAgICAgICAgICAgICAgICAgcHJvbWlzZXMgPSBbXTtcbiAgICBcbiAgICAgICAgICAgICAgICBpZiAoICFwaWNrICkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgIFxuICAgICAgICAgICAgICAgICQuaXNQbGFpbk9iamVjdCggcGljayApIHx8IChwaWNrID0ge1xuICAgICAgICAgICAgICAgICAgICBpZDogcGlja1xuICAgICAgICAgICAgICAgIH0pO1xuICAgIFxuICAgICAgICAgICAgICAgICQoIHBpY2suaWQgKS5lYWNoKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgb3B0aW9ucywgcGlja2VyLCBkZWZlcnJlZDtcbiAgICBcbiAgICAgICAgICAgICAgICAgICAgZGVmZXJyZWQgPSBCYXNlLkRlZmVycmVkKCk7XG4gICAgXG4gICAgICAgICAgICAgICAgICAgIG9wdGlvbnMgPSAkLmV4dGVuZCh7fSwgcGljaywge1xuICAgICAgICAgICAgICAgICAgICAgICAgYWNjZXB0OiAkLmlzUGxhaW5PYmplY3QoIGFjY2VwdCApID8gWyBhY2NlcHQgXSA6IGFjY2VwdCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHN3Zjogb3B0cy5zd2YsXG4gICAgICAgICAgICAgICAgICAgICAgICBydW50aW1lT3JkZXI6IG9wdHMucnVudGltZU9yZGVyLFxuICAgICAgICAgICAgICAgICAgICAgICAgaWQ6IHRoaXNcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgXG4gICAgICAgICAgICAgICAgICAgIHBpY2tlciA9IG5ldyBGaWxlUGlja2VyKCBvcHRpb25zICk7XG4gICAgXG4gICAgICAgICAgICAgICAgICAgIHBpY2tlci5vbmNlKCAncmVhZHknLCBkZWZlcnJlZC5yZXNvbHZlICk7XG4gICAgICAgICAgICAgICAgICAgIHBpY2tlci5vbiggJ3NlbGVjdCcsIGZ1bmN0aW9uKCBmaWxlcyApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1lLm93bmVyLnJlcXVlc3QoICdhZGQtZmlsZScsIFsgZmlsZXMgXSk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBwaWNrZXIuaW5pdCgpO1xuICAgIFxuICAgICAgICAgICAgICAgICAgICBtZS5waWNrZXJzLnB1c2goIHBpY2tlciApO1xuICAgIFxuICAgICAgICAgICAgICAgICAgICBwcm9taXNlcy5wdXNoKCBkZWZlcnJlZC5wcm9taXNlKCkgKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICBcbiAgICAgICAgICAgICAgICByZXR1cm4gQmFzZS53aGVuLmFwcGx5KCBCYXNlLCBwcm9taXNlcyApO1xuICAgICAgICAgICAgfSxcbiAgICBcbiAgICAgICAgICAgIGRpc2FibGU6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICQuZWFjaCggdGhpcy5waWNrZXJzLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kaXNhYmxlKCk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9LFxuICAgIFxuICAgICAgICAgICAgZW5hYmxlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAkLmVhY2goIHRoaXMucGlja2VycywgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZW5hYmxlKCk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9LFxuICAgIFxuICAgICAgICAgICAgZGVzdHJveTogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgJC5lYWNoKCB0aGlzLnBpY2tlcnMsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmRlc3Ryb3koKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB0aGlzLnBpY2tlcnMgPSBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9KTtcbiAgICAvKipcbiAgICAgKiBAZmlsZU92ZXJ2aWV3IEltYWdlXG4gICAgICovXG4gICAgZGVmaW5lKCdsaWIvaW1hZ2UnLFtcbiAgICAgICAgJ2Jhc2UnLFxuICAgICAgICAncnVudGltZS9jbGllbnQnLFxuICAgICAgICAnbGliL2Jsb2InXG4gICAgXSwgZnVuY3Rpb24oIEJhc2UsIFJ1bnRpbWVDbGllbnQsIEJsb2IgKSB7XG4gICAgICAgIHZhciAkID0gQmFzZS4kO1xuICAgIFxuICAgICAgICAvLyDmnoTpgKDlmajjgIJcbiAgICAgICAgZnVuY3Rpb24gSW1hZ2UoIG9wdHMgKSB7XG4gICAgICAgICAgICB0aGlzLm9wdGlvbnMgPSAkLmV4dGVuZCh7fSwgSW1hZ2Uub3B0aW9ucywgb3B0cyApO1xuICAgICAgICAgICAgUnVudGltZUNsaWVudC5jYWxsKCB0aGlzLCAnSW1hZ2UnICk7XG4gICAgXG4gICAgICAgICAgICB0aGlzLm9uKCAnbG9hZCcsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHRoaXMuX2luZm8gPSB0aGlzLmV4ZWMoJ2luZm8nKTtcbiAgICAgICAgICAgICAgICB0aGlzLl9tZXRhID0gdGhpcy5leGVjKCdtZXRhJyk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIFxuICAgICAgICAvLyDpu5jorqTpgInpobnjgIJcbiAgICAgICAgSW1hZ2Uub3B0aW9ucyA9IHtcbiAgICBcbiAgICAgICAgICAgIC8vIOm7mOiupOeahOWbvueJh+WkhOeQhui0qOmHj1xuICAgICAgICAgICAgcXVhbGl0eTogOTAsXG4gICAgXG4gICAgICAgICAgICAvLyDmmK/lkKboo4HliapcbiAgICAgICAgICAgIGNyb3A6IGZhbHNlLFxuICAgIFxuICAgICAgICAgICAgLy8g5piv5ZCm5L+d55WZ5aS06YOo5L+h5oGvXG4gICAgICAgICAgICBwcmVzZXJ2ZUhlYWRlcnM6IGZhbHNlLFxuICAgIFxuICAgICAgICAgICAgLy8g5piv5ZCm5YWB6K645pS+5aSn44CCXG4gICAgICAgICAgICBhbGxvd01hZ25pZnk6IGZhbHNlXG4gICAgICAgIH07XG4gICAgXG4gICAgICAgIC8vIOe7p+aJv1J1bnRpbWVDbGllbnQuXG4gICAgICAgIEJhc2UuaW5oZXJpdHMoIFJ1bnRpbWVDbGllbnQsIHtcbiAgICAgICAgICAgIGNvbnN0cnVjdG9yOiBJbWFnZSxcbiAgICBcbiAgICAgICAgICAgIGluZm86IGZ1bmN0aW9uKCB2YWwgKSB7XG4gICAgXG4gICAgICAgICAgICAgICAgLy8gc2V0dGVyXG4gICAgICAgICAgICAgICAgaWYgKCB2YWwgKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2luZm8gPSB2YWw7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICAgICAgICAgIH1cbiAgICBcbiAgICAgICAgICAgICAgICAvLyBnZXR0ZXJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5faW5mbztcbiAgICAgICAgICAgIH0sXG4gICAgXG4gICAgICAgICAgICBtZXRhOiBmdW5jdGlvbiggdmFsICkge1xuICAgIFxuICAgICAgICAgICAgICAgIC8vIHNldHRlclxuICAgICAgICAgICAgICAgIGlmICggdmFsICkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9tZXRhID0gdmFsO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgICAgICAgICB9XG4gICAgXG4gICAgICAgICAgICAgICAgLy8gZ2V0dGVyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX21ldGE7XG4gICAgICAgICAgICB9LFxuICAgIFxuICAgICAgICAgICAgbG9hZEZyb21CbG9iOiBmdW5jdGlvbiggYmxvYiApIHtcbiAgICAgICAgICAgICAgICB2YXIgbWUgPSB0aGlzLFxuICAgICAgICAgICAgICAgICAgICBydWlkID0gYmxvYi5nZXRSdWlkKCk7XG4gICAgXG4gICAgICAgICAgICAgICAgdGhpcy5jb25uZWN0UnVudGltZSggcnVpZCwgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIG1lLmV4ZWMoICdpbml0JywgbWUub3B0aW9ucyApO1xuICAgICAgICAgICAgICAgICAgICBtZS5leGVjKCAnbG9hZEZyb21CbG9iJywgYmxvYiApO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSxcbiAgICBcbiAgICAgICAgICAgIHJlc2l6ZTogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgdmFyIGFyZ3MgPSBCYXNlLnNsaWNlKCBhcmd1bWVudHMgKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5leGVjLmFwcGx5KCB0aGlzLCBbICdyZXNpemUnIF0uY29uY2F0KCBhcmdzICkgKTtcbiAgICAgICAgICAgIH0sXG4gICAgXG4gICAgICAgICAgICBjcm9wOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICB2YXIgYXJncyA9IEJhc2Uuc2xpY2UoIGFyZ3VtZW50cyApO1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmV4ZWMuYXBwbHkoIHRoaXMsIFsgJ2Nyb3AnIF0uY29uY2F0KCBhcmdzICkgKTtcbiAgICAgICAgICAgIH0sXG4gICAgXG4gICAgICAgICAgICBnZXRBc0RhdGFVcmw6IGZ1bmN0aW9uKCB0eXBlICkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmV4ZWMoICdnZXRBc0RhdGFVcmwnLCB0eXBlICk7XG4gICAgICAgICAgICB9LFxuICAgIFxuICAgICAgICAgICAgZ2V0QXNCbG9iOiBmdW5jdGlvbiggdHlwZSApIHtcbiAgICAgICAgICAgICAgICB2YXIgYmxvYiA9IHRoaXMuZXhlYyggJ2dldEFzQmxvYicsIHR5cGUgKTtcbiAgICBcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IEJsb2IoIHRoaXMuZ2V0UnVpZCgpLCBibG9iICk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIFxuICAgICAgICByZXR1cm4gSW1hZ2U7XG4gICAgfSk7XG4gICAgLyoqXG4gICAgICogQGZpbGVPdmVydmlldyDlm77niYfmk43kvZwsIOi0n+i0o+mihOiniOWbvueJh+WSjOS4iuS8oOWJjeWOi+e8qeWbvueJh1xuICAgICAqL1xuICAgIGRlZmluZSgnd2lkZ2V0cy9pbWFnZScsW1xuICAgICAgICAnYmFzZScsXG4gICAgICAgICd1cGxvYWRlcicsXG4gICAgICAgICdsaWIvaW1hZ2UnLFxuICAgICAgICAnd2lkZ2V0cy93aWRnZXQnXG4gICAgXSwgZnVuY3Rpb24oIEJhc2UsIFVwbG9hZGVyLCBJbWFnZSApIHtcbiAgICBcbiAgICAgICAgdmFyICQgPSBCYXNlLiQsXG4gICAgICAgICAgICB0aHJvdHRsZTtcbiAgICBcbiAgICAgICAgLy8g5qC55o2u6KaB5aSE55CG55qE5paH5Lu25aSn5bCP5p2l6IqC5rWB77yM5LiA5qyh5LiN6IO95aSE55CG5aSq5aSa77yM5Lya5Y2h44CCXG4gICAgICAgIHRocm90dGxlID0gKGZ1bmN0aW9uKCBtYXggKSB7XG4gICAgICAgICAgICB2YXIgb2NjdXBpZWQgPSAwLFxuICAgICAgICAgICAgICAgIHdhaXRpbmcgPSBbXSxcbiAgICAgICAgICAgICAgICB0aWNrID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBpdGVtO1xuICAgIFxuICAgICAgICAgICAgICAgICAgICB3aGlsZSAoIHdhaXRpbmcubGVuZ3RoICYmIG9jY3VwaWVkIDwgbWF4ICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaXRlbSA9IHdhaXRpbmcuc2hpZnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIG9jY3VwaWVkICs9IGl0ZW1bIDAgXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGl0ZW1bIDEgXSgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfTtcbiAgICBcbiAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiggZW1pdGVyLCBzaXplLCBjYiApIHtcbiAgICAgICAgICAgICAgICB3YWl0aW5nLnB1c2goWyBzaXplLCBjYiBdKTtcbiAgICAgICAgICAgICAgICBlbWl0ZXIub25jZSggJ2Rlc3Ryb3knLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgb2NjdXBpZWQgLT0gc2l6ZTtcbiAgICAgICAgICAgICAgICAgICAgc2V0VGltZW91dCggdGljaywgMSApO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHNldFRpbWVvdXQoIHRpY2ssIDEgKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0pKCA1ICogMTAyNCAqIDEwMjQgKTtcbiAgICBcbiAgICAgICAgJC5leHRlbmQoIFVwbG9hZGVyLm9wdGlvbnMsIHtcbiAgICBcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogQHByb3BlcnR5IHtPYmplY3R9IFt0aHVtYl1cbiAgICAgICAgICAgICAqIEBuYW1lc3BhY2Ugb3B0aW9uc1xuICAgICAgICAgICAgICogQGZvciBVcGxvYWRlclxuICAgICAgICAgICAgICogQGRlc2NyaXB0aW9uIOmFjee9rueUn+aIkOe8qeeVpeWbvueahOmAiemhueOAglxuICAgICAgICAgICAgICpcbiAgICAgICAgICAgICAqIOm7mOiupOS4uu+8mlxuICAgICAgICAgICAgICpcbiAgICAgICAgICAgICAqIGBgYGphdmFzY3JpcHRcbiAgICAgICAgICAgICAqIHtcbiAgICAgICAgICAgICAqICAgICB3aWR0aDogMTEwLFxuICAgICAgICAgICAgICogICAgIGhlaWdodDogMTEwLFxuICAgICAgICAgICAgICpcbiAgICAgICAgICAgICAqICAgICAvLyDlm77niYfotKjph4/vvIzlj6rmnIl0eXBl5Li6YGltYWdlL2pwZWdg55qE5pe25YCZ5omN5pyJ5pWI44CCXG4gICAgICAgICAgICAgKiAgICAgcXVhbGl0eTogNzAsXG4gICAgICAgICAgICAgKlxuICAgICAgICAgICAgICogICAgIC8vIOaYr+WQpuWFgeiuuOaUvuWkp++8jOWmguaenOaDs+imgeeUn+aIkOWwj+WbvueahOaXtuWAmeS4jeWkseecn++8jOatpOmAiemhueW6lOivpeiuvue9ruS4umZhbHNlLlxuICAgICAgICAgICAgICogICAgIGFsbG93TWFnbmlmeTogdHJ1ZSxcbiAgICAgICAgICAgICAqXG4gICAgICAgICAgICAgKiAgICAgLy8g5piv5ZCm5YWB6K646KOB5Ymq44CCXG4gICAgICAgICAgICAgKiAgICAgY3JvcDogdHJ1ZSxcbiAgICAgICAgICAgICAqXG4gICAgICAgICAgICAgKiAgICAgLy8g5Li656m655qE6K+d5YiZ5L+d55WZ5Y6f5pyJ5Zu+54mH5qC85byP44CCXG4gICAgICAgICAgICAgKiAgICAgLy8g5ZCm5YiZ5by65Yi26L2s5o2i5oiQ5oyH5a6a55qE57G75Z6L44CCXG4gICAgICAgICAgICAgKiAgICAgdHlwZTogJ2ltYWdlL2pwZWcnXG4gICAgICAgICAgICAgKiB9XG4gICAgICAgICAgICAgKiBgYGBcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgdGh1bWI6IHtcbiAgICAgICAgICAgICAgICB3aWR0aDogMTEwLFxuICAgICAgICAgICAgICAgIGhlaWdodDogMTEwLFxuICAgICAgICAgICAgICAgIHF1YWxpdHk6IDcwLFxuICAgICAgICAgICAgICAgIGFsbG93TWFnbmlmeTogdHJ1ZSxcbiAgICAgICAgICAgICAgICBjcm9wOiB0cnVlLFxuICAgICAgICAgICAgICAgIHByZXNlcnZlSGVhZGVyczogZmFsc2UsXG4gICAgXG4gICAgICAgICAgICAgICAgLy8g5Li656m655qE6K+d5YiZ5L+d55WZ5Y6f5pyJ5Zu+54mH5qC85byP44CCXG4gICAgICAgICAgICAgICAgLy8g5ZCm5YiZ5by65Yi26L2s5o2i5oiQ5oyH5a6a55qE57G75Z6L44CCXG4gICAgICAgICAgICAgICAgLy8gSUUgOOS4i+mdoiBiYXNlNjQg5aSn5bCP5LiN6IO96LaF6L+HIDMySyDlkKbliJnpooTop4jlpLHotKXvvIzogIzpnZ4ganBlZyDnvJbnoIHnmoTlm77niYflvojlj69cbiAgICAgICAgICAgICAgICAvLyDog73kvJrotoXov4cgMzJrLCDmiYDku6Xov5nph4zorr7nva7miJDpooTop4jnmoTml7blgJnpg73mmK8gaW1hZ2UvanBlZ1xuICAgICAgICAgICAgICAgIHR5cGU6ICdpbWFnZS9qcGVnJ1xuICAgICAgICAgICAgfSxcbiAgICBcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogQHByb3BlcnR5IHtPYmplY3R9IFtjb21wcmVzc11cbiAgICAgICAgICAgICAqIEBuYW1lc3BhY2Ugb3B0aW9uc1xuICAgICAgICAgICAgICogQGZvciBVcGxvYWRlclxuICAgICAgICAgICAgICogQGRlc2NyaXB0aW9uIOmFjee9ruWOi+e8qeeahOWbvueJh+eahOmAiemhueOAguWmguaenOatpOmAiemhueS4umBmYWxzZWAsIOWImeWbvueJh+WcqOS4iuS8oOWJjeS4jei/m+ihjOWOi+e8qeOAglxuICAgICAgICAgICAgICpcbiAgICAgICAgICAgICAqIOm7mOiupOS4uu+8mlxuICAgICAgICAgICAgICpcbiAgICAgICAgICAgICAqIGBgYGphdmFzY3JpcHRcbiAgICAgICAgICAgICAqIHtcbiAgICAgICAgICAgICAqICAgICB3aWR0aDogMTYwMCxcbiAgICAgICAgICAgICAqICAgICBoZWlnaHQ6IDE2MDAsXG4gICAgICAgICAgICAgKlxuICAgICAgICAgICAgICogICAgIC8vIOWbvueJh+i0qOmHj++8jOWPquaciXR5cGXkuLpgaW1hZ2UvanBlZ2DnmoTml7blgJnmiY3mnInmlYjjgIJcbiAgICAgICAgICAgICAqICAgICBxdWFsaXR5OiA5MCxcbiAgICAgICAgICAgICAqXG4gICAgICAgICAgICAgKiAgICAgLy8g5piv5ZCm5YWB6K645pS+5aSn77yM5aaC5p6c5oOz6KaB55Sf5oiQ5bCP5Zu+55qE5pe25YCZ5LiN5aSx55yf77yM5q2k6YCJ6aG55bqU6K+l6K6+572u5Li6ZmFsc2UuXG4gICAgICAgICAgICAgKiAgICAgYWxsb3dNYWduaWZ5OiBmYWxzZSxcbiAgICAgICAgICAgICAqXG4gICAgICAgICAgICAgKiAgICAgLy8g5piv5ZCm5YWB6K646KOB5Ymq44CCXG4gICAgICAgICAgICAgKiAgICAgY3JvcDogZmFsc2UsXG4gICAgICAgICAgICAgKlxuICAgICAgICAgICAgICogICAgIC8vIOaYr+WQpuS/neeVmeWktOmDqG1ldGHkv6Hmga/jgIJcbiAgICAgICAgICAgICAqICAgICBwcmVzZXJ2ZUhlYWRlcnM6IHRydWUsXG4gICAgICAgICAgICAgKlxuICAgICAgICAgICAgICogICAgIC8vIOWmguaenOWPkeeOsOWOi+e8qeWQjuaWh+S7tuWkp+Wwj+avlOWOn+adpei/mOWkp++8jOWImeS9v+eUqOWOn+adpeWbvueJh1xuICAgICAgICAgICAgICogICAgIC8vIOatpOWxnuaAp+WPr+iDveS8muW9seWTjeWbvueJh+iHquWKqOe6oOato+WKn+iDvVxuICAgICAgICAgICAgICogICAgIG5vQ29tcHJlc3NJZkxhcmdlcjogZmFsc2UsXG4gICAgICAgICAgICAgKlxuICAgICAgICAgICAgICogICAgIC8vIOWNleS9jeWtl+iKgu+8jOWmguaenOWbvueJh+Wkp+Wwj+Wwj+S6juatpOWAvO+8jOS4jeS8mumHh+eUqOWOi+e8qeOAglxuICAgICAgICAgICAgICogICAgIGNvbXByZXNzU2l6ZTogMFxuICAgICAgICAgICAgICogfVxuICAgICAgICAgICAgICogYGBgXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGNvbXByZXNzOiB7XG4gICAgICAgICAgICAgICAgd2lkdGg6IDE2MDAsXG4gICAgICAgICAgICAgICAgaGVpZ2h0OiAxNjAwLFxuICAgICAgICAgICAgICAgIHF1YWxpdHk6IDkwLFxuICAgICAgICAgICAgICAgIGFsbG93TWFnbmlmeTogZmFsc2UsXG4gICAgICAgICAgICAgICAgY3JvcDogZmFsc2UsXG4gICAgICAgICAgICAgICAgcHJlc2VydmVIZWFkZXJzOiB0cnVlXG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIFxuICAgICAgICByZXR1cm4gVXBsb2FkZXIucmVnaXN0ZXIoe1xuICAgIFxuICAgICAgICAgICAgbmFtZTogJ2ltYWdlJyxcbiAgICBcbiAgICBcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICog55Sf5oiQ57yp55Wl5Zu+77yM5q2k6L+H56iL5Li65byC5q2l77yM5omA5Lul6ZyA6KaB5Lyg5YWlYGNhbGxiYWNrYOOAglxuICAgICAgICAgICAgICog6YCa5bi45oOF5Ya15Zyo5Zu+54mH5Yqg5YWl6Zif6YeM5ZCO6LCD55So5q2k5pa55rOV5p2l55Sf5oiQ6aKE6KeI5Zu+5Lul5aKe5by65Lqk5LqS5pWI5p6c44CCXG4gICAgICAgICAgICAgKlxuICAgICAgICAgICAgICog5b2TIHdpZHRoIOaIluiAhSBoZWlnaHQg55qE5YC85LuL5LqOIDAgLSAxIOaXtu+8jOiiq+W9k+aIkOeZvuWIhuavlOS9v+eUqOOAglxuICAgICAgICAgICAgICpcbiAgICAgICAgICAgICAqIGBjYWxsYmFja2DkuK3lj6/ku6XmjqXmlLbliLDkuKTkuKrlj4LmlbDjgIJcbiAgICAgICAgICAgICAqICog56ys5LiA5Liq5Li6ZXJyb3LvvIzlpoLmnpznlJ/miJDnvKnnlaXlm77mnInplJnor6/vvIzmraRlcnJvcuWwhuS4uuecn+OAglxuICAgICAgICAgICAgICogKiDnrKzkuozkuKrkuLpyZXQsIOe8qeeVpeWbvueahERhdGEgVVJM5YC844CCXG4gICAgICAgICAgICAgKlxuICAgICAgICAgICAgICogKirms6jmhI8qKlxuICAgICAgICAgICAgICogRGF0ZSBVUkzlnKhJRTYvN+S4reS4jeaUr+aMge+8jOaJgOS7peS4jeeUqOiwg+eUqOatpOaWueazleS6hu+8jOebtOaOpeaYvuekuuS4gOW8oOaaguS4jeaUr+aMgemihOiniOWbvueJh+WlveS6huOAglxuICAgICAgICAgICAgICog5Lmf5Y+v5Lul5YCf5Yqp5pyN5Yqh56uv77yM5bCGIGJhc2U2NCDmlbDmja7kvKDnu5nmnI3liqHnq6/vvIznlJ/miJDkuIDkuKrkuLTml7bmlofku7bkvpvpooTop4jjgIJcbiAgICAgICAgICAgICAqXG4gICAgICAgICAgICAgKiBAbWV0aG9kIG1ha2VUaHVtYlxuICAgICAgICAgICAgICogQGdyYW1tYXIgbWFrZVRodW1iKCBmaWxlLCBjYWxsYmFjayApID0+IHVuZGVmaW5lZFxuICAgICAgICAgICAgICogQGdyYW1tYXIgbWFrZVRodW1iKCBmaWxlLCBjYWxsYmFjaywgd2lkdGgsIGhlaWdodCApID0+IHVuZGVmaW5lZFxuICAgICAgICAgICAgICogQGZvciBVcGxvYWRlclxuICAgICAgICAgICAgICogQGV4YW1wbGVcbiAgICAgICAgICAgICAqXG4gICAgICAgICAgICAgKiB1cGxvYWRlci5vbiggJ2ZpbGVRdWV1ZWQnLCBmdW5jdGlvbiggZmlsZSApIHtcbiAgICAgICAgICAgICAqICAgICB2YXIgJGxpID0gLi4uO1xuICAgICAgICAgICAgICpcbiAgICAgICAgICAgICAqICAgICB1cGxvYWRlci5tYWtlVGh1bWIoIGZpbGUsIGZ1bmN0aW9uKCBlcnJvciwgcmV0ICkge1xuICAgICAgICAgICAgICogICAgICAgICBpZiAoIGVycm9yICkge1xuICAgICAgICAgICAgICogICAgICAgICAgICAgJGxpLnRleHQoJ+mihOiniOmUmeivrycpO1xuICAgICAgICAgICAgICogICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICogICAgICAgICAgICAgJGxpLmFwcGVuZCgnPGltZyBhbHQ9XCJcIiBzcmM9XCInICsgcmV0ICsgJ1wiIC8+Jyk7XG4gICAgICAgICAgICAgKiAgICAgICAgIH1cbiAgICAgICAgICAgICAqICAgICB9KTtcbiAgICAgICAgICAgICAqXG4gICAgICAgICAgICAgKiB9KTtcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgbWFrZVRodW1iOiBmdW5jdGlvbiggZmlsZSwgY2IsIHdpZHRoLCBoZWlnaHQgKSB7XG4gICAgICAgICAgICAgICAgdmFyIG9wdHMsIGltYWdlO1xuICAgIFxuICAgICAgICAgICAgICAgIGZpbGUgPSB0aGlzLnJlcXVlc3QoICdnZXQtZmlsZScsIGZpbGUgKTtcbiAgICBcbiAgICAgICAgICAgICAgICAvLyDlj6rpooTop4jlm77niYfmoLzlvI/jgIJcbiAgICAgICAgICAgICAgICBpZiAoICFmaWxlLnR5cGUubWF0Y2goIC9eaW1hZ2UvICkgKSB7XG4gICAgICAgICAgICAgICAgICAgIGNiKCB0cnVlICk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgXG4gICAgICAgICAgICAgICAgb3B0cyA9ICQuZXh0ZW5kKHt9LCB0aGlzLm9wdGlvbnMudGh1bWIgKTtcbiAgICBcbiAgICAgICAgICAgICAgICAvLyDlpoLmnpzkvKDlhaXnmoTmmK9vYmplY3QuXG4gICAgICAgICAgICAgICAgaWYgKCAkLmlzUGxhaW5PYmplY3QoIHdpZHRoICkgKSB7XG4gICAgICAgICAgICAgICAgICAgIG9wdHMgPSAkLmV4dGVuZCggb3B0cywgd2lkdGggKTtcbiAgICAgICAgICAgICAgICAgICAgd2lkdGggPSBudWxsO1xuICAgICAgICAgICAgICAgIH1cbiAgICBcbiAgICAgICAgICAgICAgICB3aWR0aCA9IHdpZHRoIHx8IG9wdHMud2lkdGg7XG4gICAgICAgICAgICAgICAgaGVpZ2h0ID0gaGVpZ2h0IHx8IG9wdHMuaGVpZ2h0O1xuICAgIFxuICAgICAgICAgICAgICAgIGltYWdlID0gbmV3IEltYWdlKCBvcHRzICk7XG4gICAgXG4gICAgICAgICAgICAgICAgaW1hZ2Uub25jZSggJ2xvYWQnLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgZmlsZS5faW5mbyA9IGZpbGUuX2luZm8gfHwgaW1hZ2UuaW5mbygpO1xuICAgICAgICAgICAgICAgICAgICBmaWxlLl9tZXRhID0gZmlsZS5fbWV0YSB8fCBpbWFnZS5tZXRhKCk7XG4gICAgXG4gICAgICAgICAgICAgICAgICAgIC8vIOWmguaenCB3aWR0aCDnmoTlgLzku4vkuo4gMCAtIDFcbiAgICAgICAgICAgICAgICAgICAgLy8g6K+05piO6K6+572u55qE5piv55m+5YiG5q+U44CCXG4gICAgICAgICAgICAgICAgICAgIGlmICggd2lkdGggPD0gMSAmJiB3aWR0aCA+IDAgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB3aWR0aCA9IGZpbGUuX2luZm8ud2lkdGggKiB3aWR0aDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgIFxuICAgICAgICAgICAgICAgICAgICAvLyDlkIzmoLfnmoTop4TliJnlupTnlKjkuo4gaGVpZ2h0XG4gICAgICAgICAgICAgICAgICAgIGlmICggaGVpZ2h0IDw9IDEgJiYgaGVpZ2h0ID4gMCApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGhlaWdodCA9IGZpbGUuX2luZm8uaGVpZ2h0ICogaGVpZ2h0O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgXG4gICAgICAgICAgICAgICAgICAgIGltYWdlLnJlc2l6ZSggd2lkdGgsIGhlaWdodCApO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgIFxuICAgICAgICAgICAgICAgIC8vIOW9kyByZXNpemUg5a6M5ZCOXG4gICAgICAgICAgICAgICAgaW1hZ2Uub25jZSggJ2NvbXBsZXRlJywgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIGNiKCBmYWxzZSwgaW1hZ2UuZ2V0QXNEYXRhVXJsKCBvcHRzLnR5cGUgKSApO1xuICAgICAgICAgICAgICAgICAgICBpbWFnZS5kZXN0cm95KCk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgXG4gICAgICAgICAgICAgICAgaW1hZ2Uub25jZSggJ2Vycm9yJywgZnVuY3Rpb24oIHJlYXNvbiApIHtcbiAgICAgICAgICAgICAgICAgICAgY2IoIHJlYXNvbiB8fCB0cnVlICk7XG4gICAgICAgICAgICAgICAgICAgIGltYWdlLmRlc3Ryb3koKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICBcbiAgICAgICAgICAgICAgICB0aHJvdHRsZSggaW1hZ2UsIGZpbGUuc291cmNlLnNpemUsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICBmaWxlLl9pbmZvICYmIGltYWdlLmluZm8oIGZpbGUuX2luZm8gKTtcbiAgICAgICAgICAgICAgICAgICAgZmlsZS5fbWV0YSAmJiBpbWFnZS5tZXRhKCBmaWxlLl9tZXRhICk7XG4gICAgICAgICAgICAgICAgICAgIGltYWdlLmxvYWRGcm9tQmxvYiggZmlsZS5zb3VyY2UgKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0sXG4gICAgXG4gICAgICAgICAgICBiZWZvcmVTZW5kRmlsZTogZnVuY3Rpb24oIGZpbGUgKSB7XG4gICAgICAgICAgICAgICAgdmFyIG9wdHMgPSB0aGlzLm9wdGlvbnMuY29tcHJlc3MgfHwgdGhpcy5vcHRpb25zLnJlc2l6ZSxcbiAgICAgICAgICAgICAgICAgICAgY29tcHJlc3NTaXplID0gb3B0cyAmJiBvcHRzLmNvbXByZXNzU2l6ZSB8fCAwLFxuICAgICAgICAgICAgICAgICAgICBub0NvbXByZXNzSWZMYXJnZXIgPSBvcHRzICYmIG9wdHMubm9Db21wcmVzc0lmTGFyZ2VyIHx8IGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICBpbWFnZSwgZGVmZXJyZWQ7XG4gICAgXG4gICAgICAgICAgICAgICAgZmlsZSA9IHRoaXMucmVxdWVzdCggJ2dldC1maWxlJywgZmlsZSApO1xuICAgIFxuICAgICAgICAgICAgICAgIC8vIOWPquWOi+e8qSBqcGVnIOWbvueJh+agvOW8j+OAglxuICAgICAgICAgICAgICAgIC8vIGdpZiDlj6/og73kvJrkuKLlpLHpkohcbiAgICAgICAgICAgICAgICAvLyBibXAgcG5nIOWfuuacrOS4iuWwuuWvuOmDveS4jeWkp++8jOS4lOWOi+e8qeavlOavlOi+g+Wwj+OAglxuICAgICAgICAgICAgICAgIGlmICggIW9wdHMgfHwgIX4naW1hZ2UvanBlZyxpbWFnZS9qcGcnLmluZGV4T2YoIGZpbGUudHlwZSApIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICBmaWxlLnNpemUgPCBjb21wcmVzc1NpemUgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgIGZpbGUuX2NvbXByZXNzZWQgKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgXG4gICAgICAgICAgICAgICAgb3B0cyA9ICQuZXh0ZW5kKHt9LCBvcHRzICk7XG4gICAgICAgICAgICAgICAgZGVmZXJyZWQgPSBCYXNlLkRlZmVycmVkKCk7XG4gICAgXG4gICAgICAgICAgICAgICAgaW1hZ2UgPSBuZXcgSW1hZ2UoIG9wdHMgKTtcbiAgICBcbiAgICAgICAgICAgICAgICBkZWZlcnJlZC5hbHdheXMoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIGltYWdlLmRlc3Ryb3koKTtcbiAgICAgICAgICAgICAgICAgICAgaW1hZ2UgPSBudWxsO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGltYWdlLm9uY2UoICdlcnJvcicsIGRlZmVycmVkLnJlamVjdCApO1xuICAgICAgICAgICAgICAgIGltYWdlLm9uY2UoICdsb2FkJywgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciB3aWR0aCA9IG9wdHMud2lkdGgsXG4gICAgICAgICAgICAgICAgICAgICAgICBoZWlnaHQgPSBvcHRzLmhlaWdodDtcbiAgICBcbiAgICAgICAgICAgICAgICAgICAgZmlsZS5faW5mbyA9IGZpbGUuX2luZm8gfHwgaW1hZ2UuaW5mbygpO1xuICAgICAgICAgICAgICAgICAgICBmaWxlLl9tZXRhID0gZmlsZS5fbWV0YSB8fCBpbWFnZS5tZXRhKCk7XG4gICAgXG4gICAgICAgICAgICAgICAgICAgIC8vIOWmguaenCB3aWR0aCDnmoTlgLzku4vkuo4gMCAtIDFcbiAgICAgICAgICAgICAgICAgICAgLy8g6K+05piO6K6+572u55qE5piv55m+5YiG5q+U44CCXG4gICAgICAgICAgICAgICAgICAgIGlmICggd2lkdGggPD0gMSAmJiB3aWR0aCA+IDAgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB3aWR0aCA9IGZpbGUuX2luZm8ud2lkdGggKiB3aWR0aDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgIFxuICAgICAgICAgICAgICAgICAgICAvLyDlkIzmoLfnmoTop4TliJnlupTnlKjkuo4gaGVpZ2h0XG4gICAgICAgICAgICAgICAgICAgIGlmICggaGVpZ2h0IDw9IDEgJiYgaGVpZ2h0ID4gMCApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGhlaWdodCA9IGZpbGUuX2luZm8uaGVpZ2h0ICogaGVpZ2h0O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgXG4gICAgICAgICAgICAgICAgICAgIGltYWdlLnJlc2l6ZSggd2lkdGgsIGhlaWdodCApO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgIFxuICAgICAgICAgICAgICAgIGltYWdlLm9uY2UoICdjb21wbGV0ZScsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgYmxvYiwgc2l6ZTtcbiAgICBcbiAgICAgICAgICAgICAgICAgICAgLy8g56e75Yqo56uvIFVDIC8gcXEg5rWP6KeI5Zmo55qE5peg5Zu+5qih5byP5LiLXG4gICAgICAgICAgICAgICAgICAgIC8vIGN0eC5nZXRJbWFnZURhdGEg5aSE55CG5aSn5Zu+55qE5pe25YCZ5Lya5oqlIEV4Y2VwdGlvblxuICAgICAgICAgICAgICAgICAgICAvLyBJTkRFWF9TSVpFX0VSUjogRE9NIEV4Y2VwdGlvbiAxXG4gICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBibG9iID0gaW1hZ2UuZ2V0QXNCbG9iKCBvcHRzLnR5cGUgKTtcbiAgICBcbiAgICAgICAgICAgICAgICAgICAgICAgIHNpemUgPSBmaWxlLnNpemU7XG4gICAgXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyDlpoLmnpzljovnvKnlkI7vvIzmr5Tljp/mnaXov5jlpKfliJnkuI3nlKjljovnvKnlkI7nmoTjgIJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICggIW5vQ29tcHJlc3NJZkxhcmdlciB8fCBibG9iLnNpemUgPCBzaXplICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGZpbGUuc291cmNlLmRlc3Ryb3kgJiYgZmlsZS5zb3VyY2UuZGVzdHJveSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZpbGUuc291cmNlID0gYmxvYjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmaWxlLnNpemUgPSBibG9iLnNpemU7XG4gICAgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZmlsZS50cmlnZ2VyKCAncmVzaXplJywgYmxvYi5zaXplLCBzaXplICk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyDmoIforrDvvIzpgb/lhY3ph43lpI3ljovnvKnjgIJcbiAgICAgICAgICAgICAgICAgICAgICAgIGZpbGUuX2NvbXByZXNzZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgZGVmZXJyZWQucmVzb2x2ZSgpO1xuICAgICAgICAgICAgICAgICAgICB9IGNhdGNoICggZSApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIOWHuumUmeS6huebtOaOpee7p+e7re+8jOiuqeWFtuS4iuS8oOWOn+Wni+WbvueJh1xuICAgICAgICAgICAgICAgICAgICAgICAgZGVmZXJyZWQucmVzb2x2ZSgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgXG4gICAgICAgICAgICAgICAgZmlsZS5faW5mbyAmJiBpbWFnZS5pbmZvKCBmaWxlLl9pbmZvICk7XG4gICAgICAgICAgICAgICAgZmlsZS5fbWV0YSAmJiBpbWFnZS5tZXRhKCBmaWxlLl9tZXRhICk7XG4gICAgXG4gICAgICAgICAgICAgICAgaW1hZ2UubG9hZEZyb21CbG9iKCBmaWxlLnNvdXJjZSApO1xuICAgICAgICAgICAgICAgIHJldHVybiBkZWZlcnJlZC5wcm9taXNlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH0pO1xuICAgIC8qKlxuICAgICAqIEBmaWxlT3ZlcnZpZXcg5paH5Lu25bGe5oCn5bCB6KOFXG4gICAgICovXG4gICAgZGVmaW5lKCdmaWxlJyxbXG4gICAgICAgICdiYXNlJyxcbiAgICAgICAgJ21lZGlhdG9yJ1xuICAgIF0sIGZ1bmN0aW9uKCBCYXNlLCBNZWRpYXRvciApIHtcbiAgICBcbiAgICAgICAgdmFyICQgPSBCYXNlLiQsXG4gICAgICAgICAgICBpZFByZWZpeCA9ICdXVV9GSUxFXycsXG4gICAgICAgICAgICBpZFN1ZmZpeCA9IDAsXG4gICAgICAgICAgICByRXh0ID0gL1xcLihbXi5dKykkLyxcbiAgICAgICAgICAgIHN0YXR1c01hcCA9IHt9O1xuICAgIFxuICAgICAgICBmdW5jdGlvbiBnaWQoKSB7XG4gICAgICAgICAgICByZXR1cm4gaWRQcmVmaXggKyBpZFN1ZmZpeCsrO1xuICAgICAgICB9XG4gICAgXG4gICAgICAgIC8qKlxuICAgICAgICAgKiDmlofku7bnsbtcbiAgICAgICAgICogQGNsYXNzIEZpbGVcbiAgICAgICAgICogQGNvbnN0cnVjdG9yIOaehOmAoOWHveaVsFxuICAgICAgICAgKiBAZ3JhbW1hciBuZXcgRmlsZSggc291cmNlICkgPT4gRmlsZVxuICAgICAgICAgKiBAcGFyYW0ge0xpYi5GaWxlfSBzb3VyY2UgW2xpYi5GaWxlXSgjTGliLkZpbGUp5a6e5L6LLCDmraRzb3VyY2Xlr7nosaHmmK/luKbmnIlSdW50aW1l5L+h5oGv55qE44CCXG4gICAgICAgICAqL1xuICAgICAgICBmdW5jdGlvbiBXVUZpbGUoIHNvdXJjZSApIHtcbiAgICBcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICog5paH5Lu25ZCN77yM5YyF5ous5omp5bGV5ZCN77yI5ZCO57yA77yJXG4gICAgICAgICAgICAgKiBAcHJvcGVydHkgbmFtZVxuICAgICAgICAgICAgICogQHR5cGUge3N0cmluZ31cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgdGhpcy5uYW1lID0gc291cmNlLm5hbWUgfHwgJ1VudGl0bGVkJztcbiAgICBcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICog5paH5Lu25L2T56ev77yI5a2X6IqC77yJXG4gICAgICAgICAgICAgKiBAcHJvcGVydHkgc2l6ZVxuICAgICAgICAgICAgICogQHR5cGUge3VpbnR9XG4gICAgICAgICAgICAgKiBAZGVmYXVsdCAwXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIHRoaXMuc2l6ZSA9IHNvdXJjZS5zaXplIHx8IDA7XG4gICAgXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIOaWh+S7tk1JTUVUWVBF57G75Z6L77yM5LiO5paH5Lu257G75Z6L55qE5a+55bqU5YWz57O76K+35Y+C6ICDW2h0dHA6Ly90LmNuL3o4Wm5GbnldKGh0dHA6Ly90LmNuL3o4Wm5GbnkpXG4gICAgICAgICAgICAgKiBAcHJvcGVydHkgdHlwZVxuICAgICAgICAgICAgICogQHR5cGUge3N0cmluZ31cbiAgICAgICAgICAgICAqIEBkZWZhdWx0ICdhcHBsaWNhdGlvbi9vY3RldC1zdHJlYW0nXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIHRoaXMudHlwZSA9IHNvdXJjZS50eXBlIHx8ICdhcHBsaWNhdGlvbi9vY3RldC1zdHJlYW0nO1xuICAgIFxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiDmlofku7bmnIDlkI7kv67mlLnml6XmnJ9cbiAgICAgICAgICAgICAqIEBwcm9wZXJ0eSBsYXN0TW9kaWZpZWREYXRlXG4gICAgICAgICAgICAgKiBAdHlwZSB7aW50fVxuICAgICAgICAgICAgICogQGRlZmF1bHQg5b2T5YmN5pe26Ze05oizXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIHRoaXMubGFzdE1vZGlmaWVkRGF0ZSA9IHNvdXJjZS5sYXN0TW9kaWZpZWREYXRlIHx8IChuZXcgRGF0ZSgpICogMSk7XG4gICAgXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIOaWh+S7tklE77yM5q+P5Liq5a+56LGh5YW35pyJ5ZSv5LiASUTvvIzkuI7mlofku7blkI3ml6DlhbNcbiAgICAgICAgICAgICAqIEBwcm9wZXJ0eSBpZFxuICAgICAgICAgICAgICogQHR5cGUge3N0cmluZ31cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgdGhpcy5pZCA9IGdpZCgpO1xuICAgIFxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiDmlofku7bmianlsZXlkI3vvIzpgJrov4fmlofku7blkI3ojrflj5bvvIzkvovlpoJ0ZXN0LnBuZ+eahOaJqeWxleWQjeS4unBuZ1xuICAgICAgICAgICAgICogQHByb3BlcnR5IGV4dFxuICAgICAgICAgICAgICogQHR5cGUge3N0cmluZ31cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgdGhpcy5leHQgPSByRXh0LmV4ZWMoIHRoaXMubmFtZSApID8gUmVnRXhwLiQxIDogJyc7XG4gICAgXG4gICAgXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIOeKtuaAgeaWh+Wtl+ivtOaYjuOAguWcqOS4jeWQjOeahHN0YXR1c+ivreWig+S4i+acieS4jeWQjOeahOeUqOmAlOOAglxuICAgICAgICAgICAgICogQHByb3BlcnR5IHN0YXR1c1RleHRcbiAgICAgICAgICAgICAqIEB0eXBlIHtzdHJpbmd9XG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIHRoaXMuc3RhdHVzVGV4dCA9ICcnO1xuICAgIFxuICAgICAgICAgICAgLy8g5a2Y5YKo5paH5Lu254q25oCB77yM6Ziy5q2i6YCa6L+H5bGe5oCn55u05o6l5L+u5pS5XG4gICAgICAgICAgICBzdGF0dXNNYXBbIHRoaXMuaWQgXSA9IFdVRmlsZS5TdGF0dXMuSU5JVEVEO1xuICAgIFxuICAgICAgICAgICAgdGhpcy5zb3VyY2UgPSBzb3VyY2U7XG4gICAgICAgICAgICB0aGlzLmxvYWRlZCA9IDA7XG4gICAgXG4gICAgICAgICAgICB0aGlzLm9uKCAnZXJyb3InLCBmdW5jdGlvbiggbXNnICkge1xuICAgICAgICAgICAgICAgIHRoaXMuc2V0U3RhdHVzKCBXVUZpbGUuU3RhdHVzLkVSUk9SLCBtc2cgKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgXG4gICAgICAgICQuZXh0ZW5kKCBXVUZpbGUucHJvdG90eXBlLCB7XG4gICAgXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIOiuvue9rueKtuaAge+8jOeKtuaAgeWPmOWMluaXtuS8muinpuWPkWBjaGFuZ2Vg5LqL5Lu244CCXG4gICAgICAgICAgICAgKiBAbWV0aG9kIHNldFN0YXR1c1xuICAgICAgICAgICAgICogQGdyYW1tYXIgc2V0U3RhdHVzKCBzdGF0dXNbLCBzdGF0dXNUZXh0XSApO1xuICAgICAgICAgICAgICogQHBhcmFtIHtGaWxlLlN0YXR1c3xTdHJpbmd9IHN0YXR1cyBb5paH5Lu254q25oCB5YC8XSgjV2ViVXBsb2FkZXI6RmlsZTpGaWxlLlN0YXR1cylcbiAgICAgICAgICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbc3RhdHVzVGV4dD0nJ10g54q25oCB6K+05piO77yM5bi45ZyoZXJyb3Lml7bkvb/nlKjvvIznlKhodHRwLCBhYm9ydCxzZXJ2ZXLnrYnmnaXmoIforrDmmK/nlLHkuo7ku4DkuYjljp/lm6Dlr7zoh7Tmlofku7bplJnor6/jgIJcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgc2V0U3RhdHVzOiBmdW5jdGlvbiggc3RhdHVzLCB0ZXh0ICkge1xuICAgIFxuICAgICAgICAgICAgICAgIHZhciBwcmV2U3RhdHVzID0gc3RhdHVzTWFwWyB0aGlzLmlkIF07XG4gICAgXG4gICAgICAgICAgICAgICAgdHlwZW9mIHRleHQgIT09ICd1bmRlZmluZWQnICYmICh0aGlzLnN0YXR1c1RleHQgPSB0ZXh0KTtcbiAgICBcbiAgICAgICAgICAgICAgICBpZiAoIHN0YXR1cyAhPT0gcHJldlN0YXR1cyApIHtcbiAgICAgICAgICAgICAgICAgICAgc3RhdHVzTWFwWyB0aGlzLmlkIF0gPSBzdGF0dXM7XG4gICAgICAgICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAgICAgICAgKiDmlofku7bnirbmgIHlj5jljJZcbiAgICAgICAgICAgICAgICAgICAgICogQGV2ZW50IHN0YXR1c2NoYW5nZVxuICAgICAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICAgICAgdGhpcy50cmlnZ2VyKCAnc3RhdHVzY2hhbmdlJywgc3RhdHVzLCBwcmV2U3RhdHVzICk7XG4gICAgICAgICAgICAgICAgfVxuICAgIFxuICAgICAgICAgICAgfSxcbiAgICBcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICog6I635Y+W5paH5Lu254q25oCBXG4gICAgICAgICAgICAgKiBAcmV0dXJuIHtGaWxlLlN0YXR1c31cbiAgICAgICAgICAgICAqIEBleGFtcGxlXG4gICAgICAgICAgICAgICAgICAgICDmlofku7bnirbmgIHlhbfkvZPljIXmi6zku6XkuIvlh6Dnp43nsbvlnovvvJpcbiAgICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAvLyDliJ3lp4vljJZcbiAgICAgICAgICAgICAgICAgICAgICAgIElOSVRFRDogICAgIDAsXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyDlt7LlhaXpmJ/liJdcbiAgICAgICAgICAgICAgICAgICAgICAgIFFVRVVFRDogICAgIDEsXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyDmraPlnKjkuIrkvKBcbiAgICAgICAgICAgICAgICAgICAgICAgIFBST0dSRVNTOiAgICAgMixcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIOS4iuS8oOWHuumUmVxuICAgICAgICAgICAgICAgICAgICAgICAgRVJST1I6ICAgICAgICAgMyxcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIOS4iuS8oOaIkOWKn1xuICAgICAgICAgICAgICAgICAgICAgICAgQ09NUExFVEU6ICAgICA0LFxuICAgICAgICAgICAgICAgICAgICAgICAgLy8g5LiK5Lyg5Y+W5raIXG4gICAgICAgICAgICAgICAgICAgICAgICBDQU5DRUxMRUQ6ICAgICA1XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgZ2V0U3RhdHVzOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gc3RhdHVzTWFwWyB0aGlzLmlkIF07XG4gICAgICAgICAgICB9LFxuICAgIFxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiDojrflj5bmlofku7bljp/lp4vkv6Hmga/jgIJcbiAgICAgICAgICAgICAqIEByZXR1cm4geyp9XG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGdldFNvdXJjZTogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuc291cmNlO1xuICAgICAgICAgICAgfSxcbiAgICBcbiAgICAgICAgICAgIGRlc3Ryb3k6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHRoaXMub2ZmKCk7XG4gICAgICAgICAgICAgICAgZGVsZXRlIHN0YXR1c01hcFsgdGhpcy5pZCBdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICBcbiAgICAgICAgTWVkaWF0b3IuaW5zdGFsbFRvKCBXVUZpbGUucHJvdG90eXBlICk7XG4gICAgXG4gICAgICAgIC8qKlxuICAgICAgICAgKiDmlofku7bnirbmgIHlgLzvvIzlhbfkvZPljIXmi6zku6XkuIvlh6Dnp43nsbvlnovvvJpcbiAgICAgICAgICogKiBgaW5pdGVkYCDliJ3lp4vnirbmgIFcbiAgICAgICAgICogKiBgcXVldWVkYCDlt7Lnu4/ov5vlhaXpmJ/liJcsIOetieW+heS4iuS8oFxuICAgICAgICAgKiAqIGBwcm9ncmVzc2Ag5LiK5Lyg5LitXG4gICAgICAgICAqICogYGNvbXBsZXRlYCDkuIrkvKDlrozmiJDjgIJcbiAgICAgICAgICogKiBgZXJyb3JgIOS4iuS8oOWHuumUme+8jOWPr+mHjeivlVxuICAgICAgICAgKiAqIGBpbnRlcnJ1cHRgIOS4iuS8oOS4reaWre+8jOWPr+e7reS8oOOAglxuICAgICAgICAgKiAqIGBpbnZhbGlkYCDmlofku7bkuI3lkIjmoLzvvIzkuI3og73ph43or5XkuIrkvKDjgILkvJroh6rliqjku47pmJ/liJfkuK3np7vpmaTjgIJcbiAgICAgICAgICogKiBgY2FuY2VsbGVkYCDmlofku7booqvnp7vpmaTjgIJcbiAgICAgICAgICogQHByb3BlcnR5IHtPYmplY3R9IFN0YXR1c1xuICAgICAgICAgKiBAbmFtZXNwYWNlIEZpbGVcbiAgICAgICAgICogQGNsYXNzIEZpbGVcbiAgICAgICAgICogQHN0YXRpY1xuICAgICAgICAgKi9cbiAgICAgICAgV1VGaWxlLlN0YXR1cyA9IHtcbiAgICAgICAgICAgIElOSVRFRDogICAgICdpbml0ZWQnLCAgICAvLyDliJ3lp4vnirbmgIFcbiAgICAgICAgICAgIFFVRVVFRDogICAgICdxdWV1ZWQnLCAgICAvLyDlt7Lnu4/ov5vlhaXpmJ/liJcsIOetieW+heS4iuS8oFxuICAgICAgICAgICAgUFJPR1JFU1M6ICAgJ3Byb2dyZXNzJywgICAgLy8g5LiK5Lyg5LitXG4gICAgICAgICAgICBFUlJPUjogICAgICAnZXJyb3InLCAgICAvLyDkuIrkvKDlh7rplJnvvIzlj6/ph43or5VcbiAgICAgICAgICAgIENPTVBMRVRFOiAgICdjb21wbGV0ZScsICAgIC8vIOS4iuS8oOWujOaIkOOAglxuICAgICAgICAgICAgQ0FOQ0VMTEVEOiAgJ2NhbmNlbGxlZCcsICAgIC8vIOS4iuS8oOWPlua2iOOAglxuICAgICAgICAgICAgSU5URVJSVVBUOiAgJ2ludGVycnVwdCcsICAgIC8vIOS4iuS8oOS4reaWre+8jOWPr+e7reS8oOOAglxuICAgICAgICAgICAgSU5WQUxJRDogICAgJ2ludmFsaWQnICAgIC8vIOaWh+S7tuS4jeWQiOagvO+8jOS4jeiDvemHjeivleS4iuS8oOOAglxuICAgICAgICB9O1xuICAgIFxuICAgICAgICByZXR1cm4gV1VGaWxlO1xuICAgIH0pO1xuICAgIFxuICAgIC8qKlxuICAgICAqIEBmaWxlT3ZlcnZpZXcg5paH5Lu26Zif5YiXXG4gICAgICovXG4gICAgZGVmaW5lKCdxdWV1ZScsW1xuICAgICAgICAnYmFzZScsXG4gICAgICAgICdtZWRpYXRvcicsXG4gICAgICAgICdmaWxlJ1xuICAgIF0sIGZ1bmN0aW9uKCBCYXNlLCBNZWRpYXRvciwgV1VGaWxlICkge1xuICAgIFxuICAgICAgICB2YXIgJCA9IEJhc2UuJCxcbiAgICAgICAgICAgIFNUQVRVUyA9IFdVRmlsZS5TdGF0dXM7XG4gICAgXG4gICAgICAgIC8qKlxuICAgICAgICAgKiDmlofku7bpmJ/liJcsIOeUqOadpeWtmOWCqOWQhOS4queKtuaAgeS4reeahOaWh+S7tuOAglxuICAgICAgICAgKiBAY2xhc3MgUXVldWVcbiAgICAgICAgICogQGV4dGVuZHMgTWVkaWF0b3JcbiAgICAgICAgICovXG4gICAgICAgIGZ1bmN0aW9uIFF1ZXVlKCkge1xuICAgIFxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiDnu5/orqHmlofku7bmlbDjgIJcbiAgICAgICAgICAgICAqICogYG51bU9mUXVldWVgIOmYn+WIl+S4reeahOaWh+S7tuaVsOOAglxuICAgICAgICAgICAgICogKiBgbnVtT2ZTdWNjZXNzYCDkuIrkvKDmiJDlip/nmoTmlofku7bmlbBcbiAgICAgICAgICAgICAqICogYG51bU9mQ2FuY2VsYCDooqvlj5bmtojnmoTmlofku7bmlbBcbiAgICAgICAgICAgICAqICogYG51bU9mUHJvZ3Jlc3NgIOato+WcqOS4iuS8oOS4reeahOaWh+S7tuaVsFxuICAgICAgICAgICAgICogKiBgbnVtT2ZVcGxvYWRGYWlsZWRgIOS4iuS8oOmUmeivr+eahOaWh+S7tuaVsOOAglxuICAgICAgICAgICAgICogKiBgbnVtT2ZJbnZhbGlkYCDml6DmlYjnmoTmlofku7bmlbDjgIJcbiAgICAgICAgICAgICAqICogYG51bW9mRGVsZXRlZGAg6KKr56e76Zmk55qE5paH5Lu25pWw44CCXG4gICAgICAgICAgICAgKiBAcHJvcGVydHkge09iamVjdH0gc3RhdHNcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgdGhpcy5zdGF0cyA9IHtcbiAgICAgICAgICAgICAgICBudW1PZlF1ZXVlOiAwLFxuICAgICAgICAgICAgICAgIG51bU9mU3VjY2VzczogMCxcbiAgICAgICAgICAgICAgICBudW1PZkNhbmNlbDogMCxcbiAgICAgICAgICAgICAgICBudW1PZlByb2dyZXNzOiAwLFxuICAgICAgICAgICAgICAgIG51bU9mVXBsb2FkRmFpbGVkOiAwLFxuICAgICAgICAgICAgICAgIG51bU9mSW52YWxpZDogMCxcbiAgICAgICAgICAgICAgICBudW1vZkRlbGV0ZWQ6IDAsXG4gICAgICAgICAgICAgICAgbnVtb2ZJbnRlcnJ1cHQ6IDBcbiAgICAgICAgICAgIH07XG4gICAgXG4gICAgICAgICAgICAvLyDkuIrkvKDpmJ/liJfvvIzku4XljIXmi6znrYnlvoXkuIrkvKDnmoTmlofku7ZcbiAgICAgICAgICAgIHRoaXMuX3F1ZXVlID0gW107XG4gICAgXG4gICAgICAgICAgICAvLyDlrZjlgqjmiYDmnInmlofku7ZcbiAgICAgICAgICAgIHRoaXMuX21hcCA9IHt9O1xuICAgICAgICB9XG4gICAgXG4gICAgICAgICQuZXh0ZW5kKCBRdWV1ZS5wcm90b3R5cGUsIHtcbiAgICBcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICog5bCG5paw5paH5Lu25Yqg5YWl5a+56Zif5YiX5bC+6YOoXG4gICAgICAgICAgICAgKlxuICAgICAgICAgICAgICogQG1ldGhvZCBhcHBlbmRcbiAgICAgICAgICAgICAqIEBwYXJhbSAge0ZpbGV9IGZpbGUgICDmlofku7blr7nosaFcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgYXBwZW5kOiBmdW5jdGlvbiggZmlsZSApIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9xdWV1ZS5wdXNoKCBmaWxlICk7XG4gICAgICAgICAgICAgICAgdGhpcy5fZmlsZUFkZGVkKCBmaWxlICk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgICAgICB9LFxuICAgIFxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiDlsIbmlrDmlofku7bliqDlhaXlr7npmJ/liJflpLTpg6hcbiAgICAgICAgICAgICAqXG4gICAgICAgICAgICAgKiBAbWV0aG9kIHByZXBlbmRcbiAgICAgICAgICAgICAqIEBwYXJhbSAge0ZpbGV9IGZpbGUgICDmlofku7blr7nosaFcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgcHJlcGVuZDogZnVuY3Rpb24oIGZpbGUgKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fcXVldWUudW5zaGlmdCggZmlsZSApO1xuICAgICAgICAgICAgICAgIHRoaXMuX2ZpbGVBZGRlZCggZmlsZSApO1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICAgICAgfSxcbiAgICBcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICog6I635Y+W5paH5Lu25a+56LGhXG4gICAgICAgICAgICAgKlxuICAgICAgICAgICAgICogQG1ldGhvZCBnZXRGaWxlXG4gICAgICAgICAgICAgKiBAcGFyYW0gIHtTdHJpbmd9IGZpbGVJZCAgIOaWh+S7tklEXG4gICAgICAgICAgICAgKiBAcmV0dXJuIHtGaWxlfVxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBnZXRGaWxlOiBmdW5jdGlvbiggZmlsZUlkICkge1xuICAgICAgICAgICAgICAgIGlmICggdHlwZW9mIGZpbGVJZCAhPT0gJ3N0cmluZycgKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmaWxlSWQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9tYXBbIGZpbGVJZCBdO1xuICAgICAgICAgICAgfSxcbiAgICBcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICog5LuO6Zif5YiX5Lit5Y+W5Ye65LiA5Liq5oyH5a6a54q25oCB55qE5paH5Lu244CCXG4gICAgICAgICAgICAgKiBAZ3JhbW1hciBmZXRjaCggc3RhdHVzICkgPT4gRmlsZVxuICAgICAgICAgICAgICogQG1ldGhvZCBmZXRjaFxuICAgICAgICAgICAgICogQHBhcmFtIHtTdHJpbmd9IHN0YXR1cyBb5paH5Lu254q25oCB5YC8XSgjV2ViVXBsb2FkZXI6RmlsZTpGaWxlLlN0YXR1cylcbiAgICAgICAgICAgICAqIEByZXR1cm4ge0ZpbGV9IFtGaWxlXSgjV2ViVXBsb2FkZXI6RmlsZSlcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgZmV0Y2g6IGZ1bmN0aW9uKCBzdGF0dXMgKSB7XG4gICAgICAgICAgICAgICAgdmFyIGxlbiA9IHRoaXMuX3F1ZXVlLmxlbmd0aCxcbiAgICAgICAgICAgICAgICAgICAgaSwgZmlsZTtcbiAgICBcbiAgICAgICAgICAgICAgICBzdGF0dXMgPSBzdGF0dXMgfHwgU1RBVFVTLlFVRVVFRDtcbiAgICBcbiAgICAgICAgICAgICAgICBmb3IgKCBpID0gMDsgaSA8IGxlbjsgaSsrICkge1xuICAgICAgICAgICAgICAgICAgICBmaWxlID0gdGhpcy5fcXVldWVbIGkgXTtcbiAgICBcbiAgICAgICAgICAgICAgICAgICAgaWYgKCBzdGF0dXMgPT09IGZpbGUuZ2V0U3RhdHVzKCkgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmlsZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICBcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH0sXG4gICAgXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIOWvuemYn+WIl+i/m+ihjOaOkuW6j++8jOiDveWkn+aOp+WItuaWh+S7tuS4iuS8oOmhuuW6j+OAglxuICAgICAgICAgICAgICogQGdyYW1tYXIgc29ydCggZm4gKSA9PiB1bmRlZmluZWRcbiAgICAgICAgICAgICAqIEBtZXRob2Qgc29ydFxuICAgICAgICAgICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZm4g5o6S5bqP5pa55rOVXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIHNvcnQ6IGZ1bmN0aW9uKCBmbiApIHtcbiAgICAgICAgICAgICAgICBpZiAoIHR5cGVvZiBmbiA9PT0gJ2Z1bmN0aW9uJyApIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fcXVldWUuc29ydCggZm4gKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgIFxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiDojrflj5bmjIflrprnsbvlnovnmoTmlofku7bliJfooagsIOWIl+ihqOS4reavj+S4gOS4quaIkOWRmOS4ultGaWxlXSgjV2ViVXBsb2FkZXI6RmlsZSnlr7nosaHjgIJcbiAgICAgICAgICAgICAqIEBncmFtbWFyIGdldEZpbGVzKCBbc3RhdHVzMVssIHN0YXR1czIgLi4uXV0gKSA9PiBBcnJheVxuICAgICAgICAgICAgICogQG1ldGhvZCBnZXRGaWxlc1xuICAgICAgICAgICAgICogQHBhcmFtIHtTdHJpbmd9IFtzdGF0dXNdIFvmlofku7bnirbmgIHlgLxdKCNXZWJVcGxvYWRlcjpGaWxlOkZpbGUuU3RhdHVzKVxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBnZXRGaWxlczogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgdmFyIHN0cyA9IFtdLnNsaWNlLmNhbGwoIGFyZ3VtZW50cywgMCApLFxuICAgICAgICAgICAgICAgICAgICByZXQgPSBbXSxcbiAgICAgICAgICAgICAgICAgICAgaSA9IDAsXG4gICAgICAgICAgICAgICAgICAgIGxlbiA9IHRoaXMuX3F1ZXVlLmxlbmd0aCxcbiAgICAgICAgICAgICAgICAgICAgZmlsZTtcbiAgICBcbiAgICAgICAgICAgICAgICBmb3IgKCA7IGkgPCBsZW47IGkrKyApIHtcbiAgICAgICAgICAgICAgICAgICAgZmlsZSA9IHRoaXMuX3F1ZXVlWyBpIF07XG4gICAgXG4gICAgICAgICAgICAgICAgICAgIGlmICggc3RzLmxlbmd0aCAmJiAhfiQuaW5BcnJheSggZmlsZS5nZXRTdGF0dXMoKSwgc3RzICkgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgIFxuICAgICAgICAgICAgICAgICAgICByZXQucHVzaCggZmlsZSApO1xuICAgICAgICAgICAgICAgIH1cbiAgICBcbiAgICAgICAgICAgICAgICByZXR1cm4gcmV0O1xuICAgICAgICAgICAgfSxcbiAgICBcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICog5Zyo6Zif5YiX5Lit5Yig6Zmk5paH5Lu244CCXG4gICAgICAgICAgICAgKiBAZ3JhbW1hciByZW1vdmVGaWxlKCBmaWxlICkgPT4gQXJyYXlcbiAgICAgICAgICAgICAqIEBtZXRob2QgcmVtb3ZlRmlsZVxuICAgICAgICAgICAgICogQHBhcmFtIHtGaWxlfSDmlofku7blr7nosaHjgIJcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgcmVtb3ZlRmlsZTogZnVuY3Rpb24oIGZpbGUgKSB7XG4gICAgICAgICAgICAgICAgdmFyIG1lID0gdGhpcyxcbiAgICAgICAgICAgICAgICAgICAgZXhpc3RpbmcgPSB0aGlzLl9tYXBbIGZpbGUuaWQgXTtcbiAgICBcbiAgICAgICAgICAgICAgICBpZiAoIGV4aXN0aW5nICkge1xuICAgICAgICAgICAgICAgICAgICBkZWxldGUgdGhpcy5fbWFwWyBmaWxlLmlkIF07XG4gICAgICAgICAgICAgICAgICAgIGZpbGUuZGVzdHJveSgpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnN0YXRzLm51bW9mRGVsZXRlZCsrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgXG4gICAgICAgICAgICBfZmlsZUFkZGVkOiBmdW5jdGlvbiggZmlsZSApIHtcbiAgICAgICAgICAgICAgICB2YXIgbWUgPSB0aGlzLFxuICAgICAgICAgICAgICAgICAgICBleGlzdGluZyA9IHRoaXMuX21hcFsgZmlsZS5pZCBdO1xuICAgIFxuICAgICAgICAgICAgICAgIGlmICggIWV4aXN0aW5nICkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9tYXBbIGZpbGUuaWQgXSA9IGZpbGU7XG4gICAgXG4gICAgICAgICAgICAgICAgICAgIGZpbGUub24oICdzdGF0dXNjaGFuZ2UnLCBmdW5jdGlvbiggY3VyLCBwcmUgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBtZS5fb25GaWxlU3RhdHVzQ2hhbmdlKCBjdXIsIHByZSApO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgIFxuICAgICAgICAgICAgX29uRmlsZVN0YXR1c0NoYW5nZTogZnVuY3Rpb24oIGN1clN0YXR1cywgcHJlU3RhdHVzICkge1xuICAgICAgICAgICAgICAgIHZhciBzdGF0cyA9IHRoaXMuc3RhdHM7XG4gICAgXG4gICAgICAgICAgICAgICAgc3dpdGNoICggcHJlU3RhdHVzICkge1xuICAgICAgICAgICAgICAgICAgICBjYXNlIFNUQVRVUy5QUk9HUkVTUzpcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YXRzLm51bU9mUHJvZ3Jlc3MtLTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgIFxuICAgICAgICAgICAgICAgICAgICBjYXNlIFNUQVRVUy5RVUVVRUQ6XG4gICAgICAgICAgICAgICAgICAgICAgICBzdGF0cy5udW1PZlF1ZXVlIC0tO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgU1RBVFVTLkVSUk9SOlxuICAgICAgICAgICAgICAgICAgICAgICAgc3RhdHMubnVtT2ZVcGxvYWRGYWlsZWQtLTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgIFxuICAgICAgICAgICAgICAgICAgICBjYXNlIFNUQVRVUy5JTlZBTElEOlxuICAgICAgICAgICAgICAgICAgICAgICAgc3RhdHMubnVtT2ZJbnZhbGlkLS07XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICBcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBTVEFUVVMuSU5URVJSVVBUOlxuICAgICAgICAgICAgICAgICAgICAgICAgc3RhdHMubnVtb2ZJbnRlcnJ1cHQtLTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICBcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKCBjdXJTdGF0dXMgKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgU1RBVFVTLlFVRVVFRDpcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YXRzLm51bU9mUXVldWUrKztcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgIFxuICAgICAgICAgICAgICAgICAgICBjYXNlIFNUQVRVUy5QUk9HUkVTUzpcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YXRzLm51bU9mUHJvZ3Jlc3MrKztcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgIFxuICAgICAgICAgICAgICAgICAgICBjYXNlIFNUQVRVUy5FUlJPUjpcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YXRzLm51bU9mVXBsb2FkRmFpbGVkKys7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICBcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBTVEFUVVMuQ09NUExFVEU6XG4gICAgICAgICAgICAgICAgICAgICAgICBzdGF0cy5udW1PZlN1Y2Nlc3MrKztcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgIFxuICAgICAgICAgICAgICAgICAgICBjYXNlIFNUQVRVUy5DQU5DRUxMRUQ6XG4gICAgICAgICAgICAgICAgICAgICAgICBzdGF0cy5udW1PZkNhbmNlbCsrO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgXG4gICAgXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgU1RBVFVTLklOVkFMSUQ6XG4gICAgICAgICAgICAgICAgICAgICAgICBzdGF0cy5udW1PZkludmFsaWQrKztcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgIFxuICAgICAgICAgICAgICAgICAgICBjYXNlIFNUQVRVUy5JTlRFUlJVUFQ6XG4gICAgICAgICAgICAgICAgICAgICAgICBzdGF0cy5udW1vZkludGVycnVwdCsrO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgIFxuICAgICAgICB9KTtcbiAgICBcbiAgICAgICAgTWVkaWF0b3IuaW5zdGFsbFRvKCBRdWV1ZS5wcm90b3R5cGUgKTtcbiAgICBcbiAgICAgICAgcmV0dXJuIFF1ZXVlO1xuICAgIH0pO1xuICAgIC8qKlxuICAgICAqIEBmaWxlT3ZlcnZpZXcg6Zif5YiXXG4gICAgICovXG4gICAgZGVmaW5lKCd3aWRnZXRzL3F1ZXVlJyxbXG4gICAgICAgICdiYXNlJyxcbiAgICAgICAgJ3VwbG9hZGVyJyxcbiAgICAgICAgJ3F1ZXVlJyxcbiAgICAgICAgJ2ZpbGUnLFxuICAgICAgICAnbGliL2ZpbGUnLFxuICAgICAgICAncnVudGltZS9jbGllbnQnLFxuICAgICAgICAnd2lkZ2V0cy93aWRnZXQnXG4gICAgXSwgZnVuY3Rpb24oIEJhc2UsIFVwbG9hZGVyLCBRdWV1ZSwgV1VGaWxlLCBGaWxlLCBSdW50aW1lQ2xpZW50ICkge1xuICAgIFxuICAgICAgICB2YXIgJCA9IEJhc2UuJCxcbiAgICAgICAgICAgIHJFeHQgPSAvXFwuXFx3KyQvLFxuICAgICAgICAgICAgU3RhdHVzID0gV1VGaWxlLlN0YXR1cztcbiAgICBcbiAgICAgICAgcmV0dXJuIFVwbG9hZGVyLnJlZ2lzdGVyKHtcbiAgICAgICAgICAgIG5hbWU6ICdxdWV1ZScsXG4gICAgXG4gICAgICAgICAgICBpbml0OiBmdW5jdGlvbiggb3B0cyApIHtcbiAgICAgICAgICAgICAgICB2YXIgbWUgPSB0aGlzLFxuICAgICAgICAgICAgICAgICAgICBkZWZlcnJlZCwgbGVuLCBpLCBpdGVtLCBhcnIsIGFjY2VwdCwgcnVudGltZTtcbiAgICBcbiAgICAgICAgICAgICAgICBpZiAoICQuaXNQbGFpbk9iamVjdCggb3B0cy5hY2NlcHQgKSApIHtcbiAgICAgICAgICAgICAgICAgICAgb3B0cy5hY2NlcHQgPSBbIG9wdHMuYWNjZXB0IF07XG4gICAgICAgICAgICAgICAgfVxuICAgIFxuICAgICAgICAgICAgICAgIC8vIGFjY2VwdOS4reeahOS4reeUn+aIkOWMuemFjeato+WImeOAglxuICAgICAgICAgICAgICAgIGlmICggb3B0cy5hY2NlcHQgKSB7XG4gICAgICAgICAgICAgICAgICAgIGFyciA9IFtdO1xuICAgIFxuICAgICAgICAgICAgICAgICAgICBmb3IgKCBpID0gMCwgbGVuID0gb3B0cy5hY2NlcHQubGVuZ3RoOyBpIDwgbGVuOyBpKysgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpdGVtID0gb3B0cy5hY2NlcHRbIGkgXS5leHRlbnNpb25zO1xuICAgICAgICAgICAgICAgICAgICAgICAgaXRlbSAmJiBhcnIucHVzaCggaXRlbSApO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgXG4gICAgICAgICAgICAgICAgICAgIGlmICggYXJyLmxlbmd0aCApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFjY2VwdCA9ICdcXFxcLicgKyBhcnIuam9pbignLCcpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5yZXBsYWNlKCAvLC9nLCAnJHxcXFxcLicgKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAucmVwbGFjZSggL1xcKi9nLCAnLionICkgKyAnJCc7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICBcbiAgICAgICAgICAgICAgICAgICAgbWUuYWNjZXB0ID0gbmV3IFJlZ0V4cCggYWNjZXB0LCAnaScgKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgXG4gICAgICAgICAgICAgICAgbWUucXVldWUgPSBuZXcgUXVldWUoKTtcbiAgICAgICAgICAgICAgICBtZS5zdGF0cyA9IG1lLnF1ZXVlLnN0YXRzO1xuICAgIFxuICAgICAgICAgICAgICAgIC8vIOWmguaenOW9k+WJjeS4jeaYr2h0bWw16L+Q6KGM5pe277yM6YKj5bCx566X5LqG44CCXG4gICAgICAgICAgICAgICAgLy8g5LiN5omn6KGM5ZCO57ut5pON5L2cXG4gICAgICAgICAgICAgICAgaWYgKCB0aGlzLnJlcXVlc3QoJ3ByZWRpY3QtcnVudGltZS10eXBlJykgIT09ICdodG1sNScgKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgXG4gICAgICAgICAgICAgICAgLy8g5Yib5bu65LiA5LiqIGh0bWw1IOi/kOihjOaXtueahCBwbGFjZWhvbGRlclxuICAgICAgICAgICAgICAgIC8vIOS7peiHs+S6juWklumDqOa3u+WKoOWOn+eUnyBGaWxlIOWvueixoeeahOaXtuWAmeiDveato+ehruWMheijueS4gOS4i+S+myB3ZWJ1cGxvYWRlciDkvb/nlKjjgIJcbiAgICAgICAgICAgICAgICBkZWZlcnJlZCA9IEJhc2UuRGVmZXJyZWQoKTtcbiAgICAgICAgICAgICAgICB0aGlzLnBsYWNlaG9sZGVyID0gcnVudGltZSA9IG5ldyBSdW50aW1lQ2xpZW50KCdQbGFjZWhvbGRlcicpO1xuICAgICAgICAgICAgICAgIHJ1bnRpbWUuY29ubmVjdFJ1bnRpbWUoe1xuICAgICAgICAgICAgICAgICAgICBydW50aW1lT3JkZXI6ICdodG1sNSdcbiAgICAgICAgICAgICAgICB9LCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgbWUuX3J1aWQgPSBydW50aW1lLmdldFJ1aWQoKTtcbiAgICAgICAgICAgICAgICAgICAgZGVmZXJyZWQucmVzb2x2ZSgpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHJldHVybiBkZWZlcnJlZC5wcm9taXNlKCk7XG4gICAgICAgICAgICB9LFxuICAgIFxuICAgIFxuICAgICAgICAgICAgLy8g5Li65LqG5pSv5oyB5aSW6YOo55u05o6l5re75Yqg5LiA5Liq5Y6f55SfRmlsZeWvueixoeOAglxuICAgICAgICAgICAgX3dyYXBGaWxlOiBmdW5jdGlvbiggZmlsZSApIHtcbiAgICAgICAgICAgICAgICBpZiAoICEoZmlsZSBpbnN0YW5jZW9mIFdVRmlsZSkgKSB7XG4gICAgXG4gICAgICAgICAgICAgICAgICAgIGlmICggIShmaWxlIGluc3RhbmNlb2YgRmlsZSkgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoICF0aGlzLl9ydWlkICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQ2FuXFwndCBhZGQgZXh0ZXJuYWwgZmlsZXMuJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBmaWxlID0gbmV3IEZpbGUoIHRoaXMuX3J1aWQsIGZpbGUgKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgIFxuICAgICAgICAgICAgICAgICAgICBmaWxlID0gbmV3IFdVRmlsZSggZmlsZSApO1xuICAgICAgICAgICAgICAgIH1cbiAgICBcbiAgICAgICAgICAgICAgICByZXR1cm4gZmlsZTtcbiAgICAgICAgICAgIH0sXG4gICAgXG4gICAgICAgICAgICAvLyDliKTmlq3mlofku7bmmK/lkKblj6/ku6XooqvliqDlhaXpmJ/liJdcbiAgICAgICAgICAgIGFjY2VwdEZpbGU6IGZ1bmN0aW9uKCBmaWxlICkge1xuICAgICAgICAgICAgICAgIHZhciBpbnZhbGlkID0gIWZpbGUgfHwgIWZpbGUuc2l6ZSB8fCB0aGlzLmFjY2VwdCAmJlxuICAgIFxuICAgICAgICAgICAgICAgICAgICAgICAgLy8g5aaC5p6c5ZCN5a2X5Lit5pyJ5ZCO57yA77yM5omN5YGa5ZCO57yA55m95ZCN5Y2V5aSE55CG44CCXG4gICAgICAgICAgICAgICAgICAgICAgICByRXh0LmV4ZWMoIGZpbGUubmFtZSApICYmICF0aGlzLmFjY2VwdC50ZXN0KCBmaWxlLm5hbWUgKTtcbiAgICBcbiAgICAgICAgICAgICAgICByZXR1cm4gIWludmFsaWQ7XG4gICAgICAgICAgICB9LFxuICAgIFxuICAgIFxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBAZXZlbnQgYmVmb3JlRmlsZVF1ZXVlZFxuICAgICAgICAgICAgICogQHBhcmFtIHtGaWxlfSBmaWxlIEZpbGXlr7nosaFcbiAgICAgICAgICAgICAqIEBkZXNjcmlwdGlvbiDlvZPmlofku7booqvliqDlhaXpmJ/liJfkuYvliY3op6blj5HvvIzmraTkuovku7bnmoRoYW5kbGVy6L+U5Zue5YC85Li6YGZhbHNlYO+8jOWImeatpOaWh+S7tuS4jeS8muiiq+a3u+WKoOi/m+WFpemYn+WIl+OAglxuICAgICAgICAgICAgICogQGZvciAgVXBsb2FkZXJcbiAgICAgICAgICAgICAqL1xuICAgIFxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBAZXZlbnQgZmlsZVF1ZXVlZFxuICAgICAgICAgICAgICogQHBhcmFtIHtGaWxlfSBmaWxlIEZpbGXlr7nosaFcbiAgICAgICAgICAgICAqIEBkZXNjcmlwdGlvbiDlvZPmlofku7booqvliqDlhaXpmJ/liJfku6XlkI7op6blj5HjgIJcbiAgICAgICAgICAgICAqIEBmb3IgIFVwbG9hZGVyXG4gICAgICAgICAgICAgKi9cbiAgICBcbiAgICAgICAgICAgIF9hZGRGaWxlOiBmdW5jdGlvbiggZmlsZSApIHtcbiAgICAgICAgICAgICAgICB2YXIgbWUgPSB0aGlzO1xuICAgIFxuICAgICAgICAgICAgICAgIGZpbGUgPSBtZS5fd3JhcEZpbGUoIGZpbGUgKTtcbiAgICBcbiAgICAgICAgICAgICAgICAvLyDkuI3ov4fnsbvlnovliKTmlq3lhYHorrjkuI3lhYHorrjvvIzlhYjmtL7pgIEgYGJlZm9yZUZpbGVRdWV1ZWRgXG4gICAgICAgICAgICAgICAgaWYgKCAhbWUub3duZXIudHJpZ2dlciggJ2JlZm9yZUZpbGVRdWV1ZWQnLCBmaWxlICkgKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgXG4gICAgICAgICAgICAgICAgLy8g57G75Z6L5LiN5Yy56YWN77yM5YiZ5rS+6YCB6ZSZ6K+v5LqL5Lu277yM5bm26L+U5Zue44CCXG4gICAgICAgICAgICAgICAgaWYgKCAhbWUuYWNjZXB0RmlsZSggZmlsZSApICkge1xuICAgICAgICAgICAgICAgICAgICBtZS5vd25lci50cmlnZ2VyKCAnZXJyb3InLCAnUV9UWVBFX0RFTklFRCcsIGZpbGUgKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICBcbiAgICAgICAgICAgICAgICBtZS5xdWV1ZS5hcHBlbmQoIGZpbGUgKTtcbiAgICAgICAgICAgICAgICBtZS5vd25lci50cmlnZ2VyKCAnZmlsZVF1ZXVlZCcsIGZpbGUgKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmlsZTtcbiAgICAgICAgICAgIH0sXG4gICAgXG4gICAgICAgICAgICBnZXRGaWxlOiBmdW5jdGlvbiggZmlsZUlkICkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnF1ZXVlLmdldEZpbGUoIGZpbGVJZCApO1xuICAgICAgICAgICAgfSxcbiAgICBcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogQGV2ZW50IGZpbGVzUXVldWVkXG4gICAgICAgICAgICAgKiBAcGFyYW0ge0ZpbGV9IGZpbGVzIOaVsOe7hO+8jOWGheWuueS4uuWOn+Wni0ZpbGUobGliL0ZpbGXvvInlr7nosaHjgIJcbiAgICAgICAgICAgICAqIEBkZXNjcmlwdGlvbiDlvZPkuIDmibnmlofku7bmt7vliqDov5vpmJ/liJfku6XlkI7op6blj5HjgIJcbiAgICAgICAgICAgICAqIEBmb3IgIFVwbG9hZGVyXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIFxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBAcHJvcGVydHkge0Jvb2xlYW59IFthdXRvPWZhbHNlXVxuICAgICAgICAgICAgICogQG5hbWVzcGFjZSBvcHRpb25zXG4gICAgICAgICAgICAgKiBAZm9yIFVwbG9hZGVyXG4gICAgICAgICAgICAgKiBAZGVzY3JpcHRpb24g6K6+572u5Li6IHRydWUg5ZCO77yM5LiN6ZyA6KaB5omL5Yqo6LCD55So5LiK5Lyg77yM5pyJ5paH5Lu26YCJ5oup5Y2z5byA5aeL5LiK5Lyg44CCXG4gICAgICAgICAgICAgKiBcbiAgICAgICAgICAgICAqL1xuICAgIFxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBAbWV0aG9kIGFkZEZpbGVzXG4gICAgICAgICAgICAgKiBAZ3JhbW1hciBhZGRGaWxlcyggZmlsZSApID0+IHVuZGVmaW5lZFxuICAgICAgICAgICAgICogQGdyYW1tYXIgYWRkRmlsZXMoIFtmaWxlMSwgZmlsZTIgLi4uXSApID0+IHVuZGVmaW5lZFxuICAgICAgICAgICAgICogQHBhcmFtIHtBcnJheSBvZiBGaWxlIG9yIEZpbGV9IFtmaWxlc10gRmlsZXMg5a+56LGhIOaVsOe7hFxuICAgICAgICAgICAgICogQGRlc2NyaXB0aW9uIOa3u+WKoOaWh+S7tuWIsOmYn+WIl1xuICAgICAgICAgICAgICogQGZvciAgVXBsb2FkZXJcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgYWRkRmlsZTogZnVuY3Rpb24oIGZpbGVzICkge1xuICAgICAgICAgICAgICAgIHZhciBtZSA9IHRoaXM7XG4gICAgXG4gICAgICAgICAgICAgICAgaWYgKCAhZmlsZXMubGVuZ3RoICkge1xuICAgICAgICAgICAgICAgICAgICBmaWxlcyA9IFsgZmlsZXMgXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgXG4gICAgICAgICAgICAgICAgZmlsZXMgPSAkLm1hcCggZmlsZXMsIGZ1bmN0aW9uKCBmaWxlICkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbWUuX2FkZEZpbGUoIGZpbGUgKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICBcbiAgICAgICAgICAgICAgICBtZS5vd25lci50cmlnZ2VyKCAnZmlsZXNRdWV1ZWQnLCBmaWxlcyApO1xuICAgIFxuICAgICAgICAgICAgICAgIGlmICggbWUub3B0aW9ucy5hdXRvICkge1xuICAgICAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbWUucmVxdWVzdCgnc3RhcnQtdXBsb2FkJyk7XG4gICAgICAgICAgICAgICAgICAgIH0sIDIwICk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICBcbiAgICAgICAgICAgIGdldFN0YXRzOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5zdGF0cztcbiAgICAgICAgICAgIH0sXG4gICAgXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIEBldmVudCBmaWxlRGVxdWV1ZWRcbiAgICAgICAgICAgICAqIEBwYXJhbSB7RmlsZX0gZmlsZSBGaWxl5a+56LGhXG4gICAgICAgICAgICAgKiBAZGVzY3JpcHRpb24g5b2T5paH5Lu26KKr56e76Zmk6Zif5YiX5ZCO6Kem5Y+R44CCXG4gICAgICAgICAgICAgKiBAZm9yICBVcGxvYWRlclxuICAgICAgICAgICAgICovXG4gICAgXG4gICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBAbWV0aG9kIHJlbW92ZUZpbGVcbiAgICAgICAgICAgICAqIEBncmFtbWFyIHJlbW92ZUZpbGUoIGZpbGUgKSA9PiB1bmRlZmluZWRcbiAgICAgICAgICAgICAqIEBncmFtbWFyIHJlbW92ZUZpbGUoIGlkICkgPT4gdW5kZWZpbmVkXG4gICAgICAgICAgICAgKiBAZ3JhbW1hciByZW1vdmVGaWxlKCBmaWxlLCB0cnVlICkgPT4gdW5kZWZpbmVkXG4gICAgICAgICAgICAgKiBAZ3JhbW1hciByZW1vdmVGaWxlKCBpZCwgdHJ1ZSApID0+IHVuZGVmaW5lZFxuICAgICAgICAgICAgICogQHBhcmFtIHtGaWxlfGlkfSBmaWxlIEZpbGXlr7nosaHmiJbov5lGaWxl5a+56LGh55qEaWRcbiAgICAgICAgICAgICAqIEBkZXNjcmlwdGlvbiDnp7vpmaTmn5DkuIDmlofku7YsIOm7mOiupOWPquS8muagh+iusOaWh+S7tueKtuaAgeS4uuW3suWPlua2iO+8jOWmguaenOesrOS6jOS4quWPguaVsOS4uiBgdHJ1ZWAg5YiZ5Lya5LuOIHF1ZXVlIOS4reenu+mZpOOAglxuICAgICAgICAgICAgICogQGZvciAgVXBsb2FkZXJcbiAgICAgICAgICAgICAqIEBleGFtcGxlXG4gICAgICAgICAgICAgKlxuICAgICAgICAgICAgICogJGxpLm9uKCdjbGljaycsICcucmVtb3ZlLXRoaXMnLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAqICAgICB1cGxvYWRlci5yZW1vdmVGaWxlKCBmaWxlICk7XG4gICAgICAgICAgICAgKiB9KVxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICByZW1vdmVGaWxlOiBmdW5jdGlvbiggZmlsZSwgcmVtb3ZlICkge1xuICAgICAgICAgICAgICAgIHZhciBtZSA9IHRoaXM7XG4gICAgXG4gICAgICAgICAgICAgICAgZmlsZSA9IGZpbGUuaWQgPyBmaWxlIDogbWUucXVldWUuZ2V0RmlsZSggZmlsZSApO1xuICAgIFxuICAgICAgICAgICAgICAgIHRoaXMucmVxdWVzdCggJ2NhbmNlbC1maWxlJywgZmlsZSApO1xuICAgIFxuICAgICAgICAgICAgICAgIGlmICggcmVtb3ZlICkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnF1ZXVlLnJlbW92ZUZpbGUoIGZpbGUgKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgIFxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBAbWV0aG9kIGdldEZpbGVzXG4gICAgICAgICAgICAgKiBAZ3JhbW1hciBnZXRGaWxlcygpID0+IEFycmF5XG4gICAgICAgICAgICAgKiBAZ3JhbW1hciBnZXRGaWxlcyggc3RhdHVzMSwgc3RhdHVzMiwgc3RhdHVzLi4uICkgPT4gQXJyYXlcbiAgICAgICAgICAgICAqIEBkZXNjcmlwdGlvbiDov5Tlm57mjIflrprnirbmgIHnmoTmlofku7bpm4blkIjvvIzkuI3kvKDlj4LmlbDlsIbov5Tlm57miYDmnInnirbmgIHnmoTmlofku7bjgIJcbiAgICAgICAgICAgICAqIEBmb3IgIFVwbG9hZGVyXG4gICAgICAgICAgICAgKiBAZXhhbXBsZVxuICAgICAgICAgICAgICogY29uc29sZS5sb2coIHVwbG9hZGVyLmdldEZpbGVzKCkgKTsgICAgLy8gPT4gYWxsIGZpbGVzXG4gICAgICAgICAgICAgKiBjb25zb2xlLmxvZyggdXBsb2FkZXIuZ2V0RmlsZXMoJ2Vycm9yJykgKSAgICAvLyA9PiBhbGwgZXJyb3IgZmlsZXMuXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGdldEZpbGVzOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5xdWV1ZS5nZXRGaWxlcy5hcHBseSggdGhpcy5xdWV1ZSwgYXJndW1lbnRzICk7XG4gICAgICAgICAgICB9LFxuICAgIFxuICAgICAgICAgICAgZmV0Y2hGaWxlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5xdWV1ZS5mZXRjaC5hcHBseSggdGhpcy5xdWV1ZSwgYXJndW1lbnRzICk7XG4gICAgICAgICAgICB9LFxuICAgIFxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBAbWV0aG9kIHJldHJ5XG4gICAgICAgICAgICAgKiBAZ3JhbW1hciByZXRyeSgpID0+IHVuZGVmaW5lZFxuICAgICAgICAgICAgICogQGdyYW1tYXIgcmV0cnkoIGZpbGUgKSA9PiB1bmRlZmluZWRcbiAgICAgICAgICAgICAqIEBkZXNjcmlwdGlvbiDph43or5XkuIrkvKDvvIzph43or5XmjIflrprmlofku7bvvIzmiJbogIXku47lh7rplJnnmoTmlofku7blvIDlp4vph43mlrDkuIrkvKDjgIJcbiAgICAgICAgICAgICAqIEBmb3IgIFVwbG9hZGVyXG4gICAgICAgICAgICAgKiBAZXhhbXBsZVxuICAgICAgICAgICAgICogZnVuY3Rpb24gcmV0cnkoKSB7XG4gICAgICAgICAgICAgKiAgICAgdXBsb2FkZXIucmV0cnkoKTtcbiAgICAgICAgICAgICAqIH1cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgcmV0cnk6IGZ1bmN0aW9uKCBmaWxlLCBub0ZvcmNlU3RhcnQgKSB7XG4gICAgICAgICAgICAgICAgdmFyIG1lID0gdGhpcyxcbiAgICAgICAgICAgICAgICAgICAgZmlsZXMsIGksIGxlbjtcbiAgICBcbiAgICAgICAgICAgICAgICBpZiAoIGZpbGUgKSB7XG4gICAgICAgICAgICAgICAgICAgIGZpbGUgPSBmaWxlLmlkID8gZmlsZSA6IG1lLnF1ZXVlLmdldEZpbGUoIGZpbGUgKTtcbiAgICAgICAgICAgICAgICAgICAgZmlsZS5zZXRTdGF0dXMoIFN0YXR1cy5RVUVVRUQgKTtcbiAgICAgICAgICAgICAgICAgICAgbm9Gb3JjZVN0YXJ0IHx8IG1lLnJlcXVlc3QoJ3N0YXJ0LXVwbG9hZCcpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgIFxuICAgICAgICAgICAgICAgIGZpbGVzID0gbWUucXVldWUuZ2V0RmlsZXMoIFN0YXR1cy5FUlJPUiApO1xuICAgICAgICAgICAgICAgIGkgPSAwO1xuICAgICAgICAgICAgICAgIGxlbiA9IGZpbGVzLmxlbmd0aDtcbiAgICBcbiAgICAgICAgICAgICAgICBmb3IgKCA7IGkgPCBsZW47IGkrKyApIHtcbiAgICAgICAgICAgICAgICAgICAgZmlsZSA9IGZpbGVzWyBpIF07XG4gICAgICAgICAgICAgICAgICAgIGZpbGUuc2V0U3RhdHVzKCBTdGF0dXMuUVVFVUVEICk7XG4gICAgICAgICAgICAgICAgfVxuICAgIFxuICAgICAgICAgICAgICAgIG1lLnJlcXVlc3QoJ3N0YXJ0LXVwbG9hZCcpO1xuICAgICAgICAgICAgfSxcbiAgICBcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogQG1ldGhvZCBzb3J0XG4gICAgICAgICAgICAgKiBAZ3JhbW1hciBzb3J0KCBmbiApID0+IHVuZGVmaW5lZFxuICAgICAgICAgICAgICogQGRlc2NyaXB0aW9uIOaOkuW6j+mYn+WIl+S4reeahOaWh+S7tu+8jOWcqOS4iuS8oOS5i+WJjeiwg+aVtOWPr+S7peaOp+WItuS4iuS8oOmhuuW6j+OAglxuICAgICAgICAgICAgICogQGZvciAgVXBsb2FkZXJcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgc29ydEZpbGVzOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5xdWV1ZS5zb3J0LmFwcGx5KCB0aGlzLnF1ZXVlLCBhcmd1bWVudHMgKTtcbiAgICAgICAgICAgIH0sXG4gICAgXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIEBldmVudCByZXNldFxuICAgICAgICAgICAgICogQGRlc2NyaXB0aW9uIOW9kyB1cGxvYWRlciDooqvph43nva7nmoTml7blgJnop6blj5HjgIJcbiAgICAgICAgICAgICAqIEBmb3IgIFVwbG9hZGVyXG4gICAgICAgICAgICAgKi9cbiAgICBcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogQG1ldGhvZCByZXNldFxuICAgICAgICAgICAgICogQGdyYW1tYXIgcmVzZXQoKSA9PiB1bmRlZmluZWRcbiAgICAgICAgICAgICAqIEBkZXNjcmlwdGlvbiDph43nva51cGxvYWRlcuOAguebruWJjeWPqumHjee9ruS6humYn+WIl+OAglxuICAgICAgICAgICAgICogQGZvciAgVXBsb2FkZXJcbiAgICAgICAgICAgICAqIEBleGFtcGxlXG4gICAgICAgICAgICAgKiB1cGxvYWRlci5yZXNldCgpO1xuICAgICAgICAgICAgICovXG4gICAgICAgICAgICByZXNldDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5vd25lci50cmlnZ2VyKCdyZXNldCcpO1xuICAgICAgICAgICAgICAgIHRoaXMucXVldWUgPSBuZXcgUXVldWUoKTtcbiAgICAgICAgICAgICAgICB0aGlzLnN0YXRzID0gdGhpcy5xdWV1ZS5zdGF0cztcbiAgICAgICAgICAgIH0sXG4gICAgXG4gICAgICAgICAgICBkZXN0cm95OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnJlc2V0KCk7XG4gICAgICAgICAgICAgICAgdGhpcy5wbGFjZWhvbGRlciAmJiB0aGlzLnBsYWNlaG9sZGVyLmRlc3Ryb3koKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgXG4gICAgfSk7XG4gICAgLyoqXG4gICAgICogQGZpbGVPdmVydmlldyDmt7vliqDojrflj5ZSdW50aW1l55u45YWz5L+h5oGv55qE5pa55rOV44CCXG4gICAgICovXG4gICAgZGVmaW5lKCd3aWRnZXRzL3J1bnRpbWUnLFtcbiAgICAgICAgJ3VwbG9hZGVyJyxcbiAgICAgICAgJ3J1bnRpbWUvcnVudGltZScsXG4gICAgICAgICd3aWRnZXRzL3dpZGdldCdcbiAgICBdLCBmdW5jdGlvbiggVXBsb2FkZXIsIFJ1bnRpbWUgKSB7XG4gICAgXG4gICAgICAgIFVwbG9hZGVyLnN1cHBvcnQgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHJldHVybiBSdW50aW1lLmhhc1J1bnRpbWUuYXBwbHkoIFJ1bnRpbWUsIGFyZ3VtZW50cyApO1xuICAgICAgICB9O1xuICAgIFxuICAgICAgICAvKipcbiAgICAgICAgICogQHByb3BlcnR5IHtPYmplY3R9IFtydW50aW1lT3JkZXI9aHRtbDUsZmxhc2hdXG4gICAgICAgICAqIEBuYW1lc3BhY2Ugb3B0aW9uc1xuICAgICAgICAgKiBAZm9yIFVwbG9hZGVyXG4gICAgICAgICAqIEBkZXNjcmlwdGlvbiDmjIflrprov5DooYzml7blkK/liqjpobrluo/jgILpu5jorqTkvJrmg7PlsJ3or5UgaHRtbDUg5piv5ZCm5pSv5oyB77yM5aaC5p6c5pSv5oyB5YiZ5L2/55SoIGh0bWw1LCDlkKbliJnliJnkvb/nlKggZmxhc2guXG4gICAgICAgICAqXG4gICAgICAgICAqIOWPr+S7peWwhuatpOWAvOiuvue9ruaIkCBgZmxhc2hg77yM5p2l5by65Yi25L2/55SoIGZsYXNoIOi/kOihjOaXtuOAglxuICAgICAgICAgKi9cbiAgICBcbiAgICAgICAgcmV0dXJuIFVwbG9hZGVyLnJlZ2lzdGVyKHtcbiAgICAgICAgICAgIG5hbWU6ICdydW50aW1lJyxcbiAgICBcbiAgICAgICAgICAgIGluaXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIGlmICggIXRoaXMucHJlZGljdFJ1bnRpbWVUeXBlKCkgKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IEVycm9yKCdSdW50aW1lIEVycm9yJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICBcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICog6aKE5rWLVXBsb2FkZXLlsIbph4fnlKjlk6rkuKpgUnVudGltZWBcbiAgICAgICAgICAgICAqIEBncmFtbWFyIHByZWRpY3RSdW50aW1lVHlwZSgpID0+IFN0cmluZ1xuICAgICAgICAgICAgICogQG1ldGhvZCBwcmVkaWN0UnVudGltZVR5cGVcbiAgICAgICAgICAgICAqIEBmb3IgIFVwbG9hZGVyXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIHByZWRpY3RSdW50aW1lVHlwZTogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgdmFyIG9yZGVycyA9IHRoaXMub3B0aW9ucy5ydW50aW1lT3JkZXIgfHwgUnVudGltZS5vcmRlcnMsXG4gICAgICAgICAgICAgICAgICAgIHR5cGUgPSB0aGlzLnR5cGUsXG4gICAgICAgICAgICAgICAgICAgIGksIGxlbjtcbiAgICBcbiAgICAgICAgICAgICAgICBpZiAoICF0eXBlICkge1xuICAgICAgICAgICAgICAgICAgICBvcmRlcnMgPSBvcmRlcnMuc3BsaXQoIC9cXHMqLFxccyovZyApO1xuICAgIFxuICAgICAgICAgICAgICAgICAgICBmb3IgKCBpID0gMCwgbGVuID0gb3JkZXJzLmxlbmd0aDsgaSA8IGxlbjsgaSsrICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCBSdW50aW1lLmhhc1J1bnRpbWUoIG9yZGVyc1sgaSBdICkgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy50eXBlID0gdHlwZSA9IG9yZGVyc1sgaSBdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgIFxuICAgICAgICAgICAgICAgIHJldHVybiB0eXBlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9KTtcbiAgICAvKipcbiAgICAgKiBAZmlsZU92ZXJ2aWV3IFRyYW5zcG9ydFxuICAgICAqL1xuICAgIGRlZmluZSgnbGliL3RyYW5zcG9ydCcsW1xuICAgICAgICAnYmFzZScsXG4gICAgICAgICdydW50aW1lL2NsaWVudCcsXG4gICAgICAgICdtZWRpYXRvcidcbiAgICBdLCBmdW5jdGlvbiggQmFzZSwgUnVudGltZUNsaWVudCwgTWVkaWF0b3IgKSB7XG4gICAgXG4gICAgICAgIHZhciAkID0gQmFzZS4kO1xuICAgIFxuICAgICAgICBmdW5jdGlvbiBUcmFuc3BvcnQoIG9wdHMgKSB7XG4gICAgICAgICAgICB2YXIgbWUgPSB0aGlzO1xuICAgIFxuICAgICAgICAgICAgb3B0cyA9IG1lLm9wdGlvbnMgPSAkLmV4dGVuZCggdHJ1ZSwge30sIFRyYW5zcG9ydC5vcHRpb25zLCBvcHRzIHx8IHt9ICk7XG4gICAgICAgICAgICBSdW50aW1lQ2xpZW50LmNhbGwoIHRoaXMsICdUcmFuc3BvcnQnICk7XG4gICAgXG4gICAgICAgICAgICB0aGlzLl9ibG9iID0gbnVsbDtcbiAgICAgICAgICAgIHRoaXMuX2Zvcm1EYXRhID0gb3B0cy5mb3JtRGF0YSB8fCB7fTtcbiAgICAgICAgICAgIHRoaXMuX2hlYWRlcnMgPSBvcHRzLmhlYWRlcnMgfHwge307XG4gICAgXG4gICAgICAgICAgICB0aGlzLm9uKCAncHJvZ3Jlc3MnLCB0aGlzLl90aW1lb3V0ICk7XG4gICAgICAgICAgICB0aGlzLm9uKCAnbG9hZCBlcnJvcicsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIG1lLnRyaWdnZXIoICdwcm9ncmVzcycsIDEgKTtcbiAgICAgICAgICAgICAgICBjbGVhclRpbWVvdXQoIG1lLl90aW1lciApO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICBcbiAgICAgICAgVHJhbnNwb3J0Lm9wdGlvbnMgPSB7XG4gICAgICAgICAgICBzZXJ2ZXI6ICcnLFxuICAgICAgICAgICAgbWV0aG9kOiAnUE9TVCcsXG4gICAgXG4gICAgICAgICAgICAvLyDot6jln5/ml7bvvIzmmK/lkKblhYHorrjmkLrluKZjb29raWUsIOWPquaciWh0bWw1IHJ1bnRpbWXmiY3mnInmlYhcbiAgICAgICAgICAgIHdpdGhDcmVkZW50aWFsczogZmFsc2UsXG4gICAgICAgICAgICBmaWxlVmFsOiAnZmlsZScsXG4gICAgICAgICAgICB0aW1lb3V0OiAyICogNjAgKiAxMDAwLCAgICAvLyAy5YiG6ZKfXG4gICAgICAgICAgICBmb3JtRGF0YToge30sXG4gICAgICAgICAgICBoZWFkZXJzOiB7fSxcbiAgICAgICAgICAgIHNlbmRBc0JpbmFyeTogZmFsc2VcbiAgICAgICAgfTtcbiAgICBcbiAgICAgICAgJC5leHRlbmQoIFRyYW5zcG9ydC5wcm90b3R5cGUsIHtcbiAgICBcbiAgICAgICAgICAgIC8vIOa3u+WKoEJsb2IsIOWPquiDvea3u+WKoOS4gOasoe+8jOacgOWQjuS4gOasoeacieaViOOAglxuICAgICAgICAgICAgYXBwZW5kQmxvYjogZnVuY3Rpb24oIGtleSwgYmxvYiwgZmlsZW5hbWUgKSB7XG4gICAgICAgICAgICAgICAgdmFyIG1lID0gdGhpcyxcbiAgICAgICAgICAgICAgICAgICAgb3B0cyA9IG1lLm9wdGlvbnM7XG4gICAgXG4gICAgICAgICAgICAgICAgaWYgKCBtZS5nZXRSdWlkKCkgKSB7XG4gICAgICAgICAgICAgICAgICAgIG1lLmRpc2Nvbm5lY3RSdW50aW1lKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgIFxuICAgICAgICAgICAgICAgIC8vIOi/nuaOpeWIsGJsb2LlvZLlsZ7nmoTlkIzkuIDkuKpydW50aW1lLlxuICAgICAgICAgICAgICAgIG1lLmNvbm5lY3RSdW50aW1lKCBibG9iLnJ1aWQsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICBtZS5leGVjKCdpbml0Jyk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgXG4gICAgICAgICAgICAgICAgbWUuX2Jsb2IgPSBibG9iO1xuICAgICAgICAgICAgICAgIG9wdHMuZmlsZVZhbCA9IGtleSB8fCBvcHRzLmZpbGVWYWw7XG4gICAgICAgICAgICAgICAgb3B0cy5maWxlbmFtZSA9IGZpbGVuYW1lIHx8IG9wdHMuZmlsZW5hbWU7XG4gICAgICAgICAgICB9LFxuICAgIFxuICAgICAgICAgICAgLy8g5re75Yqg5YW25LuW5a2X5q61XG4gICAgICAgICAgICBhcHBlbmQ6IGZ1bmN0aW9uKCBrZXksIHZhbHVlICkge1xuICAgICAgICAgICAgICAgIGlmICggdHlwZW9mIGtleSA9PT0gJ29iamVjdCcgKSB7XG4gICAgICAgICAgICAgICAgICAgICQuZXh0ZW5kKCB0aGlzLl9mb3JtRGF0YSwga2V5ICk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fZm9ybURhdGFbIGtleSBdID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICBcbiAgICAgICAgICAgIHNldFJlcXVlc3RIZWFkZXI6IGZ1bmN0aW9uKCBrZXksIHZhbHVlICkge1xuICAgICAgICAgICAgICAgIGlmICggdHlwZW9mIGtleSA9PT0gJ29iamVjdCcgKSB7XG4gICAgICAgICAgICAgICAgICAgICQuZXh0ZW5kKCB0aGlzLl9oZWFkZXJzLCBrZXkgKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9oZWFkZXJzWyBrZXkgXSA9IHZhbHVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgXG4gICAgICAgICAgICBzZW5kOiBmdW5jdGlvbiggbWV0aG9kICkge1xuICAgICAgICAgICAgICAgIHRoaXMuZXhlYyggJ3NlbmQnLCBtZXRob2QgKTtcbiAgICAgICAgICAgICAgICB0aGlzLl90aW1lb3V0KCk7XG4gICAgICAgICAgICB9LFxuICAgIFxuICAgICAgICAgICAgYWJvcnQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIGNsZWFyVGltZW91dCggdGhpcy5fdGltZXIgKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5leGVjKCdhYm9ydCcpO1xuICAgICAgICAgICAgfSxcbiAgICBcbiAgICAgICAgICAgIGRlc3Ryb3k6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHRoaXMudHJpZ2dlcignZGVzdHJveScpO1xuICAgICAgICAgICAgICAgIHRoaXMub2ZmKCk7XG4gICAgICAgICAgICAgICAgdGhpcy5leGVjKCdkZXN0cm95Jyk7XG4gICAgICAgICAgICAgICAgdGhpcy5kaXNjb25uZWN0UnVudGltZSgpO1xuICAgICAgICAgICAgfSxcbiAgICBcbiAgICAgICAgICAgIGdldFJlc3BvbnNlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5leGVjKCdnZXRSZXNwb25zZScpO1xuICAgICAgICAgICAgfSxcbiAgICBcbiAgICAgICAgICAgIGdldFJlc3BvbnNlQXNKc29uOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5leGVjKCdnZXRSZXNwb25zZUFzSnNvbicpO1xuICAgICAgICAgICAgfSxcbiAgICBcbiAgICAgICAgICAgIGdldFN0YXR1czogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZXhlYygnZ2V0U3RhdHVzJyk7XG4gICAgICAgICAgICB9LFxuICAgIFxuICAgICAgICAgICAgX3RpbWVvdXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHZhciBtZSA9IHRoaXMsXG4gICAgICAgICAgICAgICAgICAgIGR1cmF0aW9uID0gbWUub3B0aW9ucy50aW1lb3V0O1xuICAgIFxuICAgICAgICAgICAgICAgIGlmICggIWR1cmF0aW9uICkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgIFxuICAgICAgICAgICAgICAgIGNsZWFyVGltZW91dCggbWUuX3RpbWVyICk7XG4gICAgICAgICAgICAgICAgbWUuX3RpbWVyID0gc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgbWUuYWJvcnQoKTtcbiAgICAgICAgICAgICAgICAgICAgbWUudHJpZ2dlciggJ2Vycm9yJywgJ3RpbWVvdXQnICk7XG4gICAgICAgICAgICAgICAgfSwgZHVyYXRpb24gKTtcbiAgICAgICAgICAgIH1cbiAgICBcbiAgICAgICAgfSk7XG4gICAgXG4gICAgICAgIC8vIOiuqVRyYW5zcG9ydOWFt+Wkh+S6i+S7tuWKn+iDveOAglxuICAgICAgICBNZWRpYXRvci5pbnN0YWxsVG8oIFRyYW5zcG9ydC5wcm90b3R5cGUgKTtcbiAgICBcbiAgICAgICAgcmV0dXJuIFRyYW5zcG9ydDtcbiAgICB9KTtcbiAgICAvKipcbiAgICAgKiBAZmlsZU92ZXJ2aWV3IOi0n+i0o+aWh+S7tuS4iuS8oOebuOWFs+OAglxuICAgICAqL1xuICAgIGRlZmluZSgnd2lkZ2V0cy91cGxvYWQnLFtcbiAgICAgICAgJ2Jhc2UnLFxuICAgICAgICAndXBsb2FkZXInLFxuICAgICAgICAnZmlsZScsXG4gICAgICAgICdsaWIvdHJhbnNwb3J0JyxcbiAgICAgICAgJ3dpZGdldHMvd2lkZ2V0J1xuICAgIF0sIGZ1bmN0aW9uKCBCYXNlLCBVcGxvYWRlciwgV1VGaWxlLCBUcmFuc3BvcnQgKSB7XG4gICAgXG4gICAgICAgIHZhciAkID0gQmFzZS4kLFxuICAgICAgICAgICAgaXNQcm9taXNlID0gQmFzZS5pc1Byb21pc2UsXG4gICAgICAgICAgICBTdGF0dXMgPSBXVUZpbGUuU3RhdHVzO1xuICAgIFxuICAgICAgICAvLyDmt7vliqDpu5jorqTphY3nva7poblcbiAgICAgICAgJC5leHRlbmQoIFVwbG9hZGVyLm9wdGlvbnMsIHtcbiAgICBcbiAgICBcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogQHByb3BlcnR5IHtCb29sZWFufSBbcHJlcGFyZU5leHRGaWxlPWZhbHNlXVxuICAgICAgICAgICAgICogQG5hbWVzcGFjZSBvcHRpb25zXG4gICAgICAgICAgICAgKiBAZm9yIFVwbG9hZGVyXG4gICAgICAgICAgICAgKiBAZGVzY3JpcHRpb24g5piv5ZCm5YWB6K645Zyo5paH5Lu25Lyg6L6T5pe25o+Q5YmN5oqK5LiL5LiA5Liq5paH5Lu25YeG5aSH5aW944CCXG4gICAgICAgICAgICAgKiDlr7nkuo7kuIDkuKrmlofku7bnmoTlh4blpIflt6XkvZzmr5TovoPogJfml7bvvIzmr5TlpoLlm77niYfljovnvKnvvIxtZDXluo/liJfljJbjgIJcbiAgICAgICAgICAgICAqIOWmguaenOiDveaPkOWJjeWcqOW9k+WJjeaWh+S7tuS8oOi+k+acn+WkhOeQhu+8jOWPr+S7peiKguecgeaAu+S9k+iAl+aXtuOAglxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBwcmVwYXJlTmV4dEZpbGU6IGZhbHNlLFxuICAgIFxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBAcHJvcGVydHkge0Jvb2xlYW59IFtjaHVua2VkPWZhbHNlXVxuICAgICAgICAgICAgICogQG5hbWVzcGFjZSBvcHRpb25zXG4gICAgICAgICAgICAgKiBAZm9yIFVwbG9hZGVyXG4gICAgICAgICAgICAgKiBAZGVzY3JpcHRpb24g5piv5ZCm6KaB5YiG54mH5aSE55CG5aSn5paH5Lu25LiK5Lyg44CCXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGNodW5rZWQ6IGZhbHNlLFxuICAgIFxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBAcHJvcGVydHkge0Jvb2xlYW59IFtjaHVua1NpemU9NTI0Mjg4MF1cbiAgICAgICAgICAgICAqIEBuYW1lc3BhY2Ugb3B0aW9uc1xuICAgICAgICAgICAgICogQGZvciBVcGxvYWRlclxuICAgICAgICAgICAgICogQGRlc2NyaXB0aW9uIOWmguaenOimgeWIhueJh++8jOWIhuWkmuWkp+S4gOeJh++8nyDpu5jorqTlpKflsI/kuLo1TS5cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgY2h1bmtTaXplOiA1ICogMTAyNCAqIDEwMjQsXG4gICAgXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIEBwcm9wZXJ0eSB7Qm9vbGVhbn0gW2NodW5rUmV0cnk9Ml1cbiAgICAgICAgICAgICAqIEBuYW1lc3BhY2Ugb3B0aW9uc1xuICAgICAgICAgICAgICogQGZvciBVcGxvYWRlclxuICAgICAgICAgICAgICogQGRlc2NyaXB0aW9uIOWmguaenOafkOS4quWIhueJh+eUseS6jue9kee7nOmXrumimOWHuumUme+8jOWFgeiuuOiHquWKqOmHjeS8oOWkmuWwkeasoe+8n1xuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBjaHVua1JldHJ5OiAyLFxuICAgIFxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBAcHJvcGVydHkge0Jvb2xlYW59IFt0aHJlYWRzPTNdXG4gICAgICAgICAgICAgKiBAbmFtZXNwYWNlIG9wdGlvbnNcbiAgICAgICAgICAgICAqIEBmb3IgVXBsb2FkZXJcbiAgICAgICAgICAgICAqIEBkZXNjcmlwdGlvbiDkuIrkvKDlubblj5HmlbDjgILlhYHorrjlkIzml7bmnIDlpKfkuIrkvKDov5vnqIvmlbDjgIJcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgdGhyZWFkczogMyxcbiAgICBcbiAgICBcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogQHByb3BlcnR5IHtPYmplY3R9IFtmb3JtRGF0YT17fV1cbiAgICAgICAgICAgICAqIEBuYW1lc3BhY2Ugb3B0aW9uc1xuICAgICAgICAgICAgICogQGZvciBVcGxvYWRlclxuICAgICAgICAgICAgICogQGRlc2NyaXB0aW9uIOaWh+S7tuS4iuS8oOivt+axgueahOWPguaVsOihqO+8jOavj+asoeWPkemAgemDveS8muWPkemAgeatpOWvueixoeS4reeahOWPguaVsOOAglxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBmb3JtRGF0YToge31cbiAgICBcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogQHByb3BlcnR5IHtPYmplY3R9IFtmaWxlVmFsPSdmaWxlJ11cbiAgICAgICAgICAgICAqIEBuYW1lc3BhY2Ugb3B0aW9uc1xuICAgICAgICAgICAgICogQGZvciBVcGxvYWRlclxuICAgICAgICAgICAgICogQGRlc2NyaXB0aW9uIOiuvue9ruaWh+S7tuS4iuS8oOWfn+eahG5hbWXjgIJcbiAgICAgICAgICAgICAqL1xuICAgIFxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBAcHJvcGVydHkge09iamVjdH0gW21ldGhvZD0nUE9TVCddXG4gICAgICAgICAgICAgKiBAbmFtZXNwYWNlIG9wdGlvbnNcbiAgICAgICAgICAgICAqIEBmb3IgVXBsb2FkZXJcbiAgICAgICAgICAgICAqIEBkZXNjcmlwdGlvbiDmlofku7bkuIrkvKDmlrnlvI/vvIxgUE9TVGDmiJbogIVgR0VUYOOAglxuICAgICAgICAgICAgICovXG4gICAgXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIEBwcm9wZXJ0eSB7T2JqZWN0fSBbc2VuZEFzQmluYXJ5PWZhbHNlXVxuICAgICAgICAgICAgICogQG5hbWVzcGFjZSBvcHRpb25zXG4gICAgICAgICAgICAgKiBAZm9yIFVwbG9hZGVyXG4gICAgICAgICAgICAgKiBAZGVzY3JpcHRpb24g5piv5ZCm5bey5LqM6L+b5Yi255qE5rWB55qE5pa55byP5Y+R6YCB5paH5Lu277yM6L+Z5qC35pW05Liq5LiK5Lyg5YaF5a65YHBocDovL2lucHV0YOmDveS4uuaWh+S7tuWGheWuue+8jFxuICAgICAgICAgICAgICog5YW25LuW5Y+C5pWw5ZyoJF9HRVTmlbDnu4TkuK3jgIJcbiAgICAgICAgICAgICAqL1xuICAgICAgICB9KTtcbiAgICBcbiAgICAgICAgLy8g6LSf6LSj5bCG5paH5Lu25YiH54mH44CCXG4gICAgICAgIGZ1bmN0aW9uIEN1dGVGaWxlKCBmaWxlLCBjaHVua1NpemUgKSB7XG4gICAgICAgICAgICB2YXIgcGVuZGluZyA9IFtdLFxuICAgICAgICAgICAgICAgIGJsb2IgPSBmaWxlLnNvdXJjZSxcbiAgICAgICAgICAgICAgICB0b3RhbCA9IGJsb2Iuc2l6ZSxcbiAgICAgICAgICAgICAgICBjaHVua3MgPSBjaHVua1NpemUgPyBNYXRoLmNlaWwoIHRvdGFsIC8gY2h1bmtTaXplICkgOiAxLFxuICAgICAgICAgICAgICAgIHN0YXJ0ID0gMCxcbiAgICAgICAgICAgICAgICBpbmRleCA9IDAsXG4gICAgICAgICAgICAgICAgbGVuLCBhcGk7XG4gICAgXG4gICAgICAgICAgICBhcGkgPSB7XG4gICAgICAgICAgICAgICAgZmlsZTogZmlsZSxcbiAgICBcbiAgICAgICAgICAgICAgICBoYXM6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gISFwZW5kaW5nLmxlbmd0aDtcbiAgICAgICAgICAgICAgICB9LFxuICAgIFxuICAgICAgICAgICAgICAgIHNoaWZ0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHBlbmRpbmcuc2hpZnQoKTtcbiAgICAgICAgICAgICAgICB9LFxuICAgIFxuICAgICAgICAgICAgICAgIHVuc2hpZnQ6IGZ1bmN0aW9uKCBibG9jayApIHtcbiAgICAgICAgICAgICAgICAgICAgcGVuZGluZy51bnNoaWZ0KCBibG9jayApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgXG4gICAgICAgICAgICB3aGlsZSAoIGluZGV4IDwgY2h1bmtzICkge1xuICAgICAgICAgICAgICAgIGxlbiA9IE1hdGgubWluKCBjaHVua1NpemUsIHRvdGFsIC0gc3RhcnQgKTtcbiAgICBcbiAgICAgICAgICAgICAgICBwZW5kaW5nLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICBmaWxlOiBmaWxlLFxuICAgICAgICAgICAgICAgICAgICBzdGFydDogc3RhcnQsXG4gICAgICAgICAgICAgICAgICAgIGVuZDogY2h1bmtTaXplID8gKHN0YXJ0ICsgbGVuKSA6IHRvdGFsLFxuICAgICAgICAgICAgICAgICAgICB0b3RhbDogdG90YWwsXG4gICAgICAgICAgICAgICAgICAgIGNodW5rczogY2h1bmtzLFxuICAgICAgICAgICAgICAgICAgICBjaHVuazogaW5kZXgrKyxcbiAgICAgICAgICAgICAgICAgICAgY3V0ZWQ6IGFwaVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHN0YXJ0ICs9IGxlbjtcbiAgICAgICAgICAgIH1cbiAgICBcbiAgICAgICAgICAgIGZpbGUuYmxvY2tzID0gcGVuZGluZy5jb25jYXQoKTtcbiAgICAgICAgICAgIGZpbGUucmVtYW5pbmcgPSBwZW5kaW5nLmxlbmd0aDtcbiAgICBcbiAgICAgICAgICAgIHJldHVybiBhcGk7XG4gICAgICAgIH1cbiAgICBcbiAgICAgICAgVXBsb2FkZXIucmVnaXN0ZXIoe1xuICAgICAgICAgICAgbmFtZTogJ3VwbG9hZCcsXG4gICAgXG4gICAgICAgICAgICBpbml0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICB2YXIgb3duZXIgPSB0aGlzLm93bmVyLFxuICAgICAgICAgICAgICAgICAgICBtZSA9IHRoaXM7XG4gICAgXG4gICAgICAgICAgICAgICAgdGhpcy5ydW5pbmcgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICB0aGlzLnByb2dyZXNzID0gZmFsc2U7XG4gICAgXG4gICAgICAgICAgICAgICAgb3duZXJcbiAgICAgICAgICAgICAgICAgICAgLm9uKCAnc3RhcnRVcGxvYWQnLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1lLnByb2dyZXNzID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAgICAgLm9uKCAndXBsb2FkRmluaXNoZWQnLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1lLnByb2dyZXNzID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgIFxuICAgICAgICAgICAgICAgIC8vIOiusOW9leW9k+WJjeato+WcqOS8oOeahOaVsOaNru+8jOi3n3RocmVhZHPnm7jlhbNcbiAgICAgICAgICAgICAgICB0aGlzLnBvb2wgPSBbXTtcbiAgICBcbiAgICAgICAgICAgICAgICAvLyDnvJPlrZjliIblpb3niYfnmoTmlofku7bjgIJcbiAgICAgICAgICAgICAgICB0aGlzLnN0YWNrID0gW107XG4gICAgXG4gICAgICAgICAgICAgICAgLy8g57yT5a2Y5Y2z5bCG5LiK5Lyg55qE5paH5Lu244CCXG4gICAgICAgICAgICAgICAgdGhpcy5wZW5kaW5nID0gW107XG4gICAgXG4gICAgICAgICAgICAgICAgLy8g6Lef6Liq6L+Y5pyJ5aSa5bCR5YiG54mH5Zyo5LiK5Lyg5Lit5L2G5piv5rKh5pyJ5a6M5oiQ5LiK5Lyg44CCXG4gICAgICAgICAgICAgICAgdGhpcy5yZW1hbmluZyA9IDA7XG4gICAgICAgICAgICAgICAgdGhpcy5fX3RpY2sgPSBCYXNlLmJpbmRGbiggdGhpcy5fdGljaywgdGhpcyApO1xuICAgIFxuICAgICAgICAgICAgICAgIG93bmVyLm9uKCAndXBsb2FkQ29tcGxldGUnLCBmdW5jdGlvbiggZmlsZSApIHtcbiAgICBcbiAgICAgICAgICAgICAgICAgICAgLy8g5oqK5YW25LuW5Z2X5Y+W5raI5LqG44CCXG4gICAgICAgICAgICAgICAgICAgIGZpbGUuYmxvY2tzICYmICQuZWFjaCggZmlsZS5ibG9ja3MsIGZ1bmN0aW9uKCBfLCB2ICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdi50cmFuc3BvcnQgJiYgKHYudHJhbnNwb3J0LmFib3J0KCksIHYudHJhbnNwb3J0LmRlc3Ryb3koKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBkZWxldGUgdi50cmFuc3BvcnQ7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgIFxuICAgICAgICAgICAgICAgICAgICBkZWxldGUgZmlsZS5ibG9ja3M7XG4gICAgICAgICAgICAgICAgICAgIGRlbGV0ZSBmaWxlLnJlbWFuaW5nO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSxcbiAgICBcbiAgICAgICAgICAgIHJlc2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnJlcXVlc3QoICdzdG9wLXVwbG9hZCcsIHRydWUgKTtcbiAgICAgICAgICAgICAgICB0aGlzLnJ1bmluZyA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIHRoaXMucG9vbCA9IFtdO1xuICAgICAgICAgICAgICAgIHRoaXMuc3RhY2sgPSBbXTtcbiAgICAgICAgICAgICAgICB0aGlzLnBlbmRpbmcgPSBbXTtcbiAgICAgICAgICAgICAgICB0aGlzLnJlbWFuaW5nID0gMDtcbiAgICAgICAgICAgICAgICB0aGlzLl90cmlnZ2VkID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgdGhpcy5fcHJvbWlzZSA9IG51bGw7XG4gICAgICAgICAgICB9LFxuICAgIFxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBAZXZlbnQgc3RhcnRVcGxvYWRcbiAgICAgICAgICAgICAqIEBkZXNjcmlwdGlvbiDlvZPlvIDlp4vkuIrkvKDmtYHnqIvml7bop6blj5HjgIJcbiAgICAgICAgICAgICAqIEBmb3IgIFVwbG9hZGVyXG4gICAgICAgICAgICAgKi9cbiAgICBcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICog5byA5aeL5LiK5Lyg44CC5q2k5pa55rOV5Y+v5Lul5LuO5Yid5aeL54q25oCB6LCD55So5byA5aeL5LiK5Lyg5rWB56iL77yM5Lmf5Y+v5Lul5LuO5pqC5YGc54q25oCB6LCD55So77yM57un57ut5LiK5Lyg5rWB56iL44CCXG4gICAgICAgICAgICAgKlxuICAgICAgICAgICAgICog5Y+v5Lul5oyH5a6a5byA5aeL5p+Q5LiA5Liq5paH5Lu244CCXG4gICAgICAgICAgICAgKiBAZ3JhbW1hciB1cGxvYWQoKSA9PiB1bmRlZmluZWRcbiAgICAgICAgICAgICAqIEBncmFtbWFyIHVwbG9hZCggZmlsZSB8IGZpbGVJZCkgPT4gdW5kZWZpbmVkXG4gICAgICAgICAgICAgKiBAbWV0aG9kIHVwbG9hZFxuICAgICAgICAgICAgICogQGZvciAgVXBsb2FkZXJcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgc3RhcnRVcGxvYWQ6IGZ1bmN0aW9uKGZpbGUpIHtcbiAgICAgICAgICAgICAgICB2YXIgbWUgPSB0aGlzO1xuICAgIFxuICAgICAgICAgICAgICAgIC8vIOenu+WHumludmFsaWTnmoTmlofku7ZcbiAgICAgICAgICAgICAgICAkLmVhY2goIG1lLnJlcXVlc3QoICdnZXQtZmlsZXMnLCBTdGF0dXMuSU5WQUxJRCApLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgbWUucmVxdWVzdCggJ3JlbW92ZS1maWxlJywgdGhpcyApO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgIFxuICAgICAgICAgICAgICAgIC8vIOWmguaenOaMh+WumuS6huW8gOWni+afkOS4quaWh+S7tu+8jOWImeWPquW8gOWni+aMh+WumuaWh+S7tuOAglxuICAgICAgICAgICAgICAgIGlmICggZmlsZSApIHtcbiAgICAgICAgICAgICAgICAgICAgZmlsZSA9IGZpbGUuaWQgPyBmaWxlIDogbWUucmVxdWVzdCggJ2dldC1maWxlJywgZmlsZSApO1xuICAgIFxuICAgICAgICAgICAgICAgICAgICBpZiAoZmlsZS5nZXRTdGF0dXMoKSA9PT0gU3RhdHVzLklOVEVSUlVQVCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgJC5lYWNoKCBtZS5wb29sLCBmdW5jdGlvbiggXywgdiApIHtcbiAgICBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyDkuYvliY3mmoLlgZzov4fjgIJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodi5maWxlICE9PSBmaWxlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdi50cmFuc3BvcnQgJiYgdi50cmFuc3BvcnQuc2VuZCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgXG4gICAgICAgICAgICAgICAgICAgICAgICBmaWxlLnNldFN0YXR1cyggU3RhdHVzLlFVRVVFRCApO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGZpbGUuZ2V0U3RhdHVzKCkgPT09IFN0YXR1cy5QUk9HUkVTUykge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgZmlsZS5zZXRTdGF0dXMoIFN0YXR1cy5RVUVVRUQgKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICQuZWFjaCggbWUucmVxdWVzdCggJ2dldC1maWxlcycsIFsgU3RhdHVzLklOSVRFRCBdICksIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5zZXRTdGF0dXMoIFN0YXR1cy5RVUVVRUQgKTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgIFxuICAgICAgICAgICAgICAgIGlmICggbWUucnVuaW5nICkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgIFxuICAgICAgICAgICAgICAgIG1lLnJ1bmluZyA9IHRydWU7XG4gICAgXG4gICAgICAgICAgICAgICAgdmFyIGZpbGVzID0gW107XG4gICAgXG4gICAgICAgICAgICAgICAgLy8g5aaC5p6c5pyJ5pqC5YGc55qE77yM5YiZ57ut5LygXG4gICAgICAgICAgICAgICAgJC5lYWNoKCBtZS5wb29sLCBmdW5jdGlvbiggXywgdiApIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGZpbGUgPSB2LmZpbGU7XG4gICAgXG4gICAgICAgICAgICAgICAgICAgIGlmICggZmlsZS5nZXRTdGF0dXMoKSA9PT0gU3RhdHVzLklOVEVSUlVQVCApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZpbGVzLnB1c2goZmlsZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBtZS5fdHJpZ2dlZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgdi50cmFuc3BvcnQgJiYgdi50cmFuc3BvcnQuc2VuZCgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgXG4gICAgICAgICAgICAgICAgdmFyIGZpbGU7XG4gICAgICAgICAgICAgICAgd2hpbGUgKCAoZmlsZSA9IGZpbGVzLnNoaWZ0KCkpICkge1xuICAgICAgICAgICAgICAgICAgICBmaWxlLnNldFN0YXR1cyggU3RhdHVzLlBST0dSRVNTICk7XG4gICAgICAgICAgICAgICAgfVxuICAgIFxuICAgICAgICAgICAgICAgIGZpbGUgfHwgJC5lYWNoKCBtZS5yZXF1ZXN0KCAnZ2V0LWZpbGVzJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIFN0YXR1cy5JTlRFUlJVUFQgKSwgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc2V0U3RhdHVzKCBTdGF0dXMuUFJPR1JFU1MgKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICBcbiAgICAgICAgICAgICAgICBtZS5fdHJpZ2dlZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIEJhc2UubmV4dFRpY2soIG1lLl9fdGljayApO1xuICAgICAgICAgICAgICAgIG1lLm93bmVyLnRyaWdnZXIoJ3N0YXJ0VXBsb2FkJyk7XG4gICAgICAgICAgICB9LFxuICAgIFxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBAZXZlbnQgc3RvcFVwbG9hZFxuICAgICAgICAgICAgICogQGRlc2NyaXB0aW9uIOW9k+W8gOWni+S4iuS8oOa1geeoi+aaguWBnOaXtuinpuWPkeOAglxuICAgICAgICAgICAgICogQGZvciAgVXBsb2FkZXJcbiAgICAgICAgICAgICAqL1xuICAgIFxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiDmmoLlgZzkuIrkvKDjgILnrKzkuIDkuKrlj4LmlbDkuLrmmK/lkKbkuK3mlq3kuIrkvKDlvZPliY3mraPlnKjkuIrkvKDnmoTmlofku7bjgIJcbiAgICAgICAgICAgICAqXG4gICAgICAgICAgICAgKiDlpoLmnpznrKzkuIDkuKrlj4LmlbDmmK/mlofku7bvvIzliJnlj6rmmoLlgZzmjIflrprmlofku7bjgIJcbiAgICAgICAgICAgICAqIEBncmFtbWFyIHN0b3AoKSA9PiB1bmRlZmluZWRcbiAgICAgICAgICAgICAqIEBncmFtbWFyIHN0b3AoIHRydWUgKSA9PiB1bmRlZmluZWRcbiAgICAgICAgICAgICAqIEBncmFtbWFyIHN0b3AoIGZpbGUgKSA9PiB1bmRlZmluZWRcbiAgICAgICAgICAgICAqIEBtZXRob2Qgc3RvcFxuICAgICAgICAgICAgICogQGZvciAgVXBsb2FkZXJcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgc3RvcFVwbG9hZDogZnVuY3Rpb24oIGZpbGUsIGludGVycnVwdCApIHtcbiAgICAgICAgICAgICAgICB2YXIgbWUgPSB0aGlzO1xuICAgIFxuICAgICAgICAgICAgICAgIGlmIChmaWxlID09PSB0cnVlKSB7XG4gICAgICAgICAgICAgICAgICAgIGludGVycnVwdCA9IGZpbGU7XG4gICAgICAgICAgICAgICAgICAgIGZpbGUgPSBudWxsO1xuICAgICAgICAgICAgICAgIH1cbiAgICBcbiAgICAgICAgICAgICAgICBpZiAoIG1lLnJ1bmluZyA9PT0gZmFsc2UgKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgXG4gICAgICAgICAgICAgICAgLy8g5aaC5p6c5Y+q5piv5pqC5YGc5p+Q5Liq5paH5Lu244CCXG4gICAgICAgICAgICAgICAgaWYgKCBmaWxlICkge1xuICAgICAgICAgICAgICAgICAgICBmaWxlID0gZmlsZS5pZCA/IGZpbGUgOiBtZS5yZXF1ZXN0KCAnZ2V0LWZpbGUnLCBmaWxlICk7XG4gICAgXG4gICAgICAgICAgICAgICAgICAgIGlmICggZmlsZS5nZXRTdGF0dXMoKSAhPT0gU3RhdHVzLlBST0dSRVNTICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZmlsZS5nZXRTdGF0dXMoKSAhPT0gU3RhdHVzLlFVRVVFRCApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgIFxuICAgICAgICAgICAgICAgICAgICBmaWxlLnNldFN0YXR1cyggU3RhdHVzLklOVEVSUlVQVCApO1xuICAgICAgICAgICAgICAgICAgICAkLmVhY2goIG1lLnBvb2wsIGZ1bmN0aW9uKCBfLCB2ICkge1xuICAgIFxuICAgICAgICAgICAgICAgICAgICAgICAgLy8g5Y+qIGFib3J0IOaMh+WumueahOaWh+S7tuOAglxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHYuZmlsZSAhPT0gZmlsZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICBcbiAgICAgICAgICAgICAgICAgICAgICAgIHYudHJhbnNwb3J0ICYmIHYudHJhbnNwb3J0LmFib3J0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBtZS5fcHV0YmFjayh2KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1lLl9wb3BCbG9jayh2KTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBCYXNlLm5leHRUaWNrKCBtZS5fX3RpY2sgKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgXG4gICAgICAgICAgICAgICAgbWUucnVuaW5nID0gZmFsc2U7XG4gICAgXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuX3Byb21pc2UgJiYgdGhpcy5fcHJvbWlzZS5maWxlKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3Byb21pc2UuZmlsZS5zZXRTdGF0dXMoIFN0YXR1cy5JTlRFUlJVUFQgKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgXG4gICAgICAgICAgICAgICAgaW50ZXJydXB0ICYmICQuZWFjaCggbWUucG9vbCwgZnVuY3Rpb24oIF8sIHYgKSB7XG4gICAgICAgICAgICAgICAgICAgIHYudHJhbnNwb3J0ICYmIHYudHJhbnNwb3J0LmFib3J0KCk7XG4gICAgICAgICAgICAgICAgICAgIHYuZmlsZS5zZXRTdGF0dXMoIFN0YXR1cy5JTlRFUlJVUFQgKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICBcbiAgICAgICAgICAgICAgICBtZS5vd25lci50cmlnZ2VyKCdzdG9wVXBsb2FkJyk7XG4gICAgICAgICAgICB9LFxuICAgIFxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBAbWV0aG9kIGNhbmNlbEZpbGVcbiAgICAgICAgICAgICAqIEBncmFtbWFyIGNhbmNlbEZpbGUoIGZpbGUgKSA9PiB1bmRlZmluZWRcbiAgICAgICAgICAgICAqIEBncmFtbWFyIGNhbmNlbEZpbGUoIGlkICkgPT4gdW5kZWZpbmVkXG4gICAgICAgICAgICAgKiBAcGFyYW0ge0ZpbGV8aWR9IGZpbGUgRmlsZeWvueixoeaIlui/mUZpbGXlr7nosaHnmoRpZFxuICAgICAgICAgICAgICogQGRlc2NyaXB0aW9uIOagh+iusOaWh+S7tueKtuaAgeS4uuW3suWPlua2iCwg5ZCM5pe25bCG5Lit5pat5paH5Lu25Lyg6L6T44CCXG4gICAgICAgICAgICAgKiBAZm9yICBVcGxvYWRlclxuICAgICAgICAgICAgICogQGV4YW1wbGVcbiAgICAgICAgICAgICAqXG4gICAgICAgICAgICAgKiAkbGkub24oJ2NsaWNrJywgJy5yZW1vdmUtdGhpcycsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICogICAgIHVwbG9hZGVyLmNhbmNlbEZpbGUoIGZpbGUgKTtcbiAgICAgICAgICAgICAqIH0pXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGNhbmNlbEZpbGU6IGZ1bmN0aW9uKCBmaWxlICkge1xuICAgICAgICAgICAgICAgIGZpbGUgPSBmaWxlLmlkID8gZmlsZSA6IHRoaXMucmVxdWVzdCggJ2dldC1maWxlJywgZmlsZSApO1xuICAgIFxuICAgICAgICAgICAgICAgIC8vIOWmguaenOato+WcqOS4iuS8oOOAglxuICAgICAgICAgICAgICAgIGZpbGUuYmxvY2tzICYmICQuZWFjaCggZmlsZS5ibG9ja3MsIGZ1bmN0aW9uKCBfLCB2ICkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgX3RyID0gdi50cmFuc3BvcnQ7XG4gICAgXG4gICAgICAgICAgICAgICAgICAgIGlmICggX3RyICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgX3RyLmFib3J0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBfdHIuZGVzdHJveSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgZGVsZXRlIHYudHJhbnNwb3J0O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgXG4gICAgICAgICAgICAgICAgZmlsZS5zZXRTdGF0dXMoIFN0YXR1cy5DQU5DRUxMRUQgKTtcbiAgICAgICAgICAgICAgICB0aGlzLm93bmVyLnRyaWdnZXIoICdmaWxlRGVxdWV1ZWQnLCBmaWxlICk7XG4gICAgICAgICAgICB9LFxuICAgIFxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiDliKTmlq1gVXBsYW9kZWBy5piv5ZCm5q2j5Zyo5LiK5Lyg5Lit44CCXG4gICAgICAgICAgICAgKiBAZ3JhbW1hciBpc0luUHJvZ3Jlc3MoKSA9PiBCb29sZWFuXG4gICAgICAgICAgICAgKiBAbWV0aG9kIGlzSW5Qcm9ncmVzc1xuICAgICAgICAgICAgICogQGZvciAgVXBsb2FkZXJcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgaXNJblByb2dyZXNzOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gISF0aGlzLnByb2dyZXNzO1xuICAgICAgICAgICAgfSxcbiAgICBcbiAgICAgICAgICAgIF9nZXRTdGF0czogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMucmVxdWVzdCgnZ2V0LXN0YXRzJyk7XG4gICAgICAgICAgICB9LFxuICAgIFxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiDmjonov4fkuIDkuKrmlofku7bkuIrkvKDvvIznm7TmjqXmoIforrDmjIflrprmlofku7bkuLrlt7LkuIrkvKDnirbmgIHjgIJcbiAgICAgICAgICAgICAqIEBncmFtbWFyIHNraXBGaWxlKCBmaWxlICkgPT4gdW5kZWZpbmVkXG4gICAgICAgICAgICAgKiBAbWV0aG9kIHNraXBGaWxlXG4gICAgICAgICAgICAgKiBAZm9yICBVcGxvYWRlclxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBza2lwRmlsZTogZnVuY3Rpb24oIGZpbGUsIHN0YXR1cyApIHtcbiAgICAgICAgICAgICAgICBmaWxlID0gZmlsZS5pZCA/IGZpbGUgOiB0aGlzLnJlcXVlc3QoICdnZXQtZmlsZScsIGZpbGUgKTtcbiAgICBcbiAgICAgICAgICAgICAgICBmaWxlLnNldFN0YXR1cyggc3RhdHVzIHx8IFN0YXR1cy5DT01QTEVURSApO1xuICAgICAgICAgICAgICAgIGZpbGUuc2tpcHBlZCA9IHRydWU7XG4gICAgXG4gICAgICAgICAgICAgICAgLy8g5aaC5p6c5q2j5Zyo5LiK5Lyg44CCXG4gICAgICAgICAgICAgICAgZmlsZS5ibG9ja3MgJiYgJC5lYWNoKCBmaWxlLmJsb2NrcywgZnVuY3Rpb24oIF8sIHYgKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBfdHIgPSB2LnRyYW5zcG9ydDtcbiAgICBcbiAgICAgICAgICAgICAgICAgICAgaWYgKCBfdHIgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBfdHIuYWJvcnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIF90ci5kZXN0cm95KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBkZWxldGUgdi50cmFuc3BvcnQ7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICBcbiAgICAgICAgICAgICAgICB0aGlzLm93bmVyLnRyaWdnZXIoICd1cGxvYWRTa2lwJywgZmlsZSApO1xuICAgICAgICAgICAgfSxcbiAgICBcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogQGV2ZW50IHVwbG9hZEZpbmlzaGVkXG4gICAgICAgICAgICAgKiBAZGVzY3JpcHRpb24g5b2T5omA5pyJ5paH5Lu25LiK5Lyg57uT5p2f5pe26Kem5Y+R44CCXG4gICAgICAgICAgICAgKiBAZm9yICBVcGxvYWRlclxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBfdGljazogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgdmFyIG1lID0gdGhpcyxcbiAgICAgICAgICAgICAgICAgICAgb3B0cyA9IG1lLm9wdGlvbnMsXG4gICAgICAgICAgICAgICAgICAgIGZuLCB2YWw7XG4gICAgXG4gICAgICAgICAgICAgICAgLy8g5LiK5LiA5LiqcHJvbWlzZei/mOayoeaciee7k+adn++8jOWImeetieW+heWujOaIkOWQjuWGjeaJp+ihjOOAglxuICAgICAgICAgICAgICAgIGlmICggbWUuX3Byb21pc2UgKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBtZS5fcHJvbWlzZS5hbHdheXMoIG1lLl9fdGljayApO1xuICAgICAgICAgICAgICAgIH1cbiAgICBcbiAgICAgICAgICAgICAgICAvLyDov5jmnInkvY3nva7vvIzkuJTov5jmnInmlofku7bopoHlpITnkIbnmoTor53jgIJcbiAgICAgICAgICAgICAgICBpZiAoIG1lLnBvb2wubGVuZ3RoIDwgb3B0cy50aHJlYWRzICYmICh2YWwgPSBtZS5fbmV4dEJsb2NrKCkpICkge1xuICAgICAgICAgICAgICAgICAgICBtZS5fdHJpZ2dlZCA9IGZhbHNlO1xuICAgIFxuICAgICAgICAgICAgICAgICAgICBmbiA9IGZ1bmN0aW9uKCB2YWwgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBtZS5fcHJvbWlzZSA9IG51bGw7XG4gICAgXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyDmnInlj6/og73mmK9yZWplY3Tov4fmnaXnmoTvvIzmiYDku6XopoHmo4DmtYt2YWznmoTnsbvlnovjgIJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbCAmJiB2YWwuZmlsZSAmJiBtZS5fc3RhcnRTZW5kKCB2YWwgKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIEJhc2UubmV4dFRpY2soIG1lLl9fdGljayApO1xuICAgICAgICAgICAgICAgICAgICB9O1xuICAgIFxuICAgICAgICAgICAgICAgICAgICBtZS5fcHJvbWlzZSA9IGlzUHJvbWlzZSggdmFsICkgPyB2YWwuYWx3YXlzKCBmbiApIDogZm4oIHZhbCApO1xuICAgIFxuICAgICAgICAgICAgICAgIC8vIOayoeacieimgeS4iuS8oOeahOS6hu+8jOS4lOayoeacieato+WcqOS8oOi+k+eahOS6huOAglxuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoICFtZS5yZW1hbmluZyAmJiAhbWUuX2dldFN0YXRzKCkubnVtT2ZRdWV1ZSAmJlxuICAgICAgICAgICAgICAgICAgICAhbWUuX2dldFN0YXRzKCkubnVtb2ZJbnRlcnJ1cHQgKSB7XG4gICAgICAgICAgICAgICAgICAgIG1lLnJ1bmluZyA9IGZhbHNlO1xuICAgIFxuICAgICAgICAgICAgICAgICAgICBtZS5fdHJpZ2dlZCB8fCBCYXNlLm5leHRUaWNrKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbWUub3duZXIudHJpZ2dlcigndXBsb2FkRmluaXNoZWQnKTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIG1lLl90cmlnZ2VkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgIFxuICAgICAgICAgICAgX3B1dGJhY2s6IGZ1bmN0aW9uKGJsb2NrKSB7XG4gICAgICAgICAgICAgICAgdmFyIGlkeDtcbiAgICBcbiAgICAgICAgICAgICAgICBibG9jay5jdXRlZC51bnNoaWZ0KGJsb2NrKTtcbiAgICAgICAgICAgICAgICBpZHggPSB0aGlzLnN0YWNrLmluZGV4T2YoYmxvY2suY3V0ZWQpO1xuICAgIFxuICAgICAgICAgICAgICAgIGlmICghfmlkeCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnN0YWNrLnVuc2hpZnQoYmxvY2suY3V0ZWQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgXG4gICAgICAgICAgICBfZ2V0U3RhY2s6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHZhciBpID0gMCxcbiAgICAgICAgICAgICAgICAgICAgYWN0O1xuICAgIFxuICAgICAgICAgICAgICAgIHdoaWxlICggKGFjdCA9IHRoaXMuc3RhY2tbIGkrKyBdKSApIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCBhY3QuaGFzKCkgJiYgYWN0LmZpbGUuZ2V0U3RhdHVzKCkgPT09IFN0YXR1cy5QUk9HUkVTUyApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBhY3Q7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoIWFjdC5oYXMoKSB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFjdC5maWxlLmdldFN0YXR1cygpICE9PSBTdGF0dXMuUFJPR1JFU1MgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhY3QuZmlsZS5nZXRTdGF0dXMoKSAhPT0gU3RhdHVzLklOVEVSUlVQVCApIHtcbiAgICBcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIOaKiuW3sue7j+WkhOeQhuWujOS6hueahO+8jOaIluiAhe+8jOeKtuaAgeS4uumdniBwcm9ncmVzc++8iOS4iuS8oOS4re+8ieOAgVxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gaW50ZXJ1cHTvvIjmmoLlgZzkuK3vvIkg55qE56e76Zmk44CCXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnN0YWNrLnNwbGljZSggLS1pLCAxICk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgXG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9LFxuICAgIFxuICAgICAgICAgICAgX25leHRCbG9jazogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgdmFyIG1lID0gdGhpcyxcbiAgICAgICAgICAgICAgICAgICAgb3B0cyA9IG1lLm9wdGlvbnMsXG4gICAgICAgICAgICAgICAgICAgIGFjdCwgbmV4dCwgZG9uZSwgcHJlcGFyaW5nO1xuICAgIFxuICAgICAgICAgICAgICAgIC8vIOWmguaenOW9k+WJjeaWh+S7tui/mOacieayoeaciemcgOimgeS8oOi+k+eahO+8jOWImeebtOaOpei/lOWbnuWJqeS4i+eahOOAglxuICAgICAgICAgICAgICAgIGlmICggKGFjdCA9IHRoaXMuX2dldFN0YWNrKCkpICkge1xuICAgIFxuICAgICAgICAgICAgICAgICAgICAvLyDmmK/lkKbmj5DliY3lh4blpIfkuIvkuIDkuKrmlofku7ZcbiAgICAgICAgICAgICAgICAgICAgaWYgKCBvcHRzLnByZXBhcmVOZXh0RmlsZSAmJiAhbWUucGVuZGluZy5sZW5ndGggKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBtZS5fcHJlcGFyZU5leHRGaWxlKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICBcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGFjdC5zaGlmdCgpO1xuICAgIFxuICAgICAgICAgICAgICAgIC8vIOWQpuWIme+8jOWmguaenOato+WcqOi/kOihjO+8jOWImeWHhuWkh+S4i+S4gOS4quaWh+S7tu+8jOW5tuetieW+heWujOaIkOWQjui/lOWbnuS4i+S4quWIhueJh+OAglxuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoIG1lLnJ1bmluZyApIHtcbiAgICBcbiAgICAgICAgICAgICAgICAgICAgLy8g5aaC5p6c57yT5a2Y5Lit5pyJ77yM5YiZ55u05o6l5Zyo57yT5a2Y5Lit5Y+W77yM5rKh5pyJ5YiZ5Y67cXVldWXkuK3lj5bjgIJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCAhbWUucGVuZGluZy5sZW5ndGggJiYgbWUuX2dldFN0YXRzKCkubnVtT2ZRdWV1ZSApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1lLl9wcmVwYXJlTmV4dEZpbGUoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgIFxuICAgICAgICAgICAgICAgICAgICBuZXh0ID0gbWUucGVuZGluZy5zaGlmdCgpO1xuICAgICAgICAgICAgICAgICAgICBkb25lID0gZnVuY3Rpb24oIGZpbGUgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoICFmaWxlICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgIFxuICAgICAgICAgICAgICAgICAgICAgICAgYWN0ID0gQ3V0ZUZpbGUoIGZpbGUsIG9wdHMuY2h1bmtlZCA/IG9wdHMuY2h1bmtTaXplIDogMCApO1xuICAgICAgICAgICAgICAgICAgICAgICAgbWUuc3RhY2sucHVzaChhY3QpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGFjdC5zaGlmdCgpO1xuICAgICAgICAgICAgICAgICAgICB9O1xuICAgIFxuICAgICAgICAgICAgICAgICAgICAvLyDmlofku7blj6/og73ov5jlnKhwcmVwYXJl5Lit77yM5Lmf5pyJ5Y+v6IO95bey57uP5a6M5YWo5YeG5aSH5aW95LqG44CCXG4gICAgICAgICAgICAgICAgICAgIGlmICggaXNQcm9taXNlKCBuZXh0KSApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHByZXBhcmluZyA9IG5leHQuZmlsZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5leHQgPSBuZXh0WyBuZXh0LnBpcGUgPyAncGlwZScgOiAndGhlbicgXSggZG9uZSApO1xuICAgICAgICAgICAgICAgICAgICAgICAgbmV4dC5maWxlID0gcHJlcGFyaW5nO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5leHQ7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICBcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGRvbmUoIG5leHQgKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgIFxuICAgIFxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBAZXZlbnQgdXBsb2FkU3RhcnRcbiAgICAgICAgICAgICAqIEBwYXJhbSB7RmlsZX0gZmlsZSBGaWxl5a+56LGhXG4gICAgICAgICAgICAgKiBAZGVzY3JpcHRpb24g5p+Q5Liq5paH5Lu25byA5aeL5LiK5Lyg5YmN6Kem5Y+R77yM5LiA5Liq5paH5Lu25Y+q5Lya6Kem5Y+R5LiA5qyh44CCXG4gICAgICAgICAgICAgKiBAZm9yICBVcGxvYWRlclxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBfcHJlcGFyZU5leHRGaWxlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICB2YXIgbWUgPSB0aGlzLFxuICAgICAgICAgICAgICAgICAgICBmaWxlID0gbWUucmVxdWVzdCgnZmV0Y2gtZmlsZScpLFxuICAgICAgICAgICAgICAgICAgICBwZW5kaW5nID0gbWUucGVuZGluZyxcbiAgICAgICAgICAgICAgICAgICAgcHJvbWlzZTtcbiAgICBcbiAgICAgICAgICAgICAgICBpZiAoIGZpbGUgKSB7XG4gICAgICAgICAgICAgICAgICAgIHByb21pc2UgPSBtZS5yZXF1ZXN0KCAnYmVmb3JlLXNlbmQtZmlsZScsIGZpbGUsIGZ1bmN0aW9uKCkge1xuICAgIFxuICAgICAgICAgICAgICAgICAgICAgICAgLy8g5pyJ5Y+v6IO95paH5Lu26KKrc2tpcOaOieS6huOAguaWh+S7tuiiq3NraXDmjonlkI7vvIznirbmgIHlnZHlrprkuI3mmK9RdWV1ZWQuXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIGZpbGUuZ2V0U3RhdHVzKCkgPT09IFN0YXR1cy5QUk9HUkVTUyB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZpbGUuZ2V0U3RhdHVzKCkgPT09IFN0YXR1cy5JTlRFUlJVUFQgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZpbGU7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbWUuX2ZpbmlzaEZpbGUoIGZpbGUgKTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgXG4gICAgICAgICAgICAgICAgICAgIG1lLm93bmVyLnRyaWdnZXIoICd1cGxvYWRTdGFydCcsIGZpbGUgKTtcbiAgICAgICAgICAgICAgICAgICAgZmlsZS5zZXRTdGF0dXMoIFN0YXR1cy5QUk9HUkVTUyApO1xuICAgIFxuICAgICAgICAgICAgICAgICAgICBwcm9taXNlLmZpbGUgPSBmaWxlO1xuICAgIFxuICAgICAgICAgICAgICAgICAgICAvLyDlpoLmnpzov5jlnKhwZW5kaW5n5Lit77yM5YiZ5pu/5o2i5oiQ5paH5Lu25pys6Lqr44CCXG4gICAgICAgICAgICAgICAgICAgIHByb21pc2UuZG9uZShmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBpZHggPSAkLmluQXJyYXkoIHByb21pc2UsIHBlbmRpbmcgKTtcbiAgICBcbiAgICAgICAgICAgICAgICAgICAgICAgIH5pZHggJiYgcGVuZGluZy5zcGxpY2UoIGlkeCwgMSwgZmlsZSApO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICBcbiAgICAgICAgICAgICAgICAgICAgLy8gYmVmZW9yZS1zZW5kLWZpbGXnmoTpkqnlrZDlsLHmnInplJnor6/lj5HnlJ/jgIJcbiAgICAgICAgICAgICAgICAgICAgcHJvbWlzZS5mYWlsKGZ1bmN0aW9uKCByZWFzb24gKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBmaWxlLnNldFN0YXR1cyggU3RhdHVzLkVSUk9SLCByZWFzb24gKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1lLm93bmVyLnRyaWdnZXIoICd1cGxvYWRFcnJvcicsIGZpbGUsIHJlYXNvbiApO1xuICAgICAgICAgICAgICAgICAgICAgICAgbWUub3duZXIudHJpZ2dlciggJ3VwbG9hZENvbXBsZXRlJywgZmlsZSApO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICBcbiAgICAgICAgICAgICAgICAgICAgcGVuZGluZy5wdXNoKCBwcm9taXNlICk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICBcbiAgICAgICAgICAgIC8vIOiuqeWHuuS9jee9ruS6hu+8jOWPr+S7peiuqeWFtuS7luWIhueJh+W8gOWni+S4iuS8oFxuICAgICAgICAgICAgX3BvcEJsb2NrOiBmdW5jdGlvbiggYmxvY2sgKSB7XG4gICAgICAgICAgICAgICAgdmFyIGlkeCA9ICQuaW5BcnJheSggYmxvY2ssIHRoaXMucG9vbCApO1xuICAgIFxuICAgICAgICAgICAgICAgIHRoaXMucG9vbC5zcGxpY2UoIGlkeCwgMSApO1xuICAgICAgICAgICAgICAgIGJsb2NrLmZpbGUucmVtYW5pbmctLTtcbiAgICAgICAgICAgICAgICB0aGlzLnJlbWFuaW5nLS07XG4gICAgICAgICAgICB9LFxuICAgIFxuICAgICAgICAgICAgLy8g5byA5aeL5LiK5Lyg77yM5Y+v5Lul6KKr5o6J6L+H44CC5aaC5p6ccHJvbWlzZeiiq3JlamVjdOS6hu+8jOWImeihqOekuui3s+i/h+atpOWIhueJh+OAglxuICAgICAgICAgICAgX3N0YXJ0U2VuZDogZnVuY3Rpb24oIGJsb2NrICkge1xuICAgICAgICAgICAgICAgIHZhciBtZSA9IHRoaXMsXG4gICAgICAgICAgICAgICAgICAgIGZpbGUgPSBibG9jay5maWxlLFxuICAgICAgICAgICAgICAgICAgICBwcm9taXNlO1xuICAgIFxuICAgICAgICAgICAgICAgIC8vIOacieWPr+iDveWcqCBiZWZvcmUtc2VuZC1maWxlIOeahCBwcm9taXNlIOacn+mXtOaUueWPmOS6huaWh+S7tueKtuaAgeOAglxuICAgICAgICAgICAgICAgIC8vIOWmgu+8muaaguWBnO+8jOWPlua2iFxuICAgICAgICAgICAgICAgIC8vIOaIkeS7rOS4jeiDveS4reaWrSBwcm9taXNlLCDkvYbmmK/lj6/ku6XlnKggcHJvbWlzZSDlrozlkI7vvIzkuI3lgZrkuIrkvKDmk43kvZzjgIJcbiAgICAgICAgICAgICAgICBpZiAoIGZpbGUuZ2V0U3RhdHVzKCkgIT09IFN0YXR1cy5QUk9HUkVTUyApIHtcbiAgICBcbiAgICAgICAgICAgICAgICAgICAgLy8g5aaC5p6c5piv5Lit5pat77yM5YiZ6L+Y6ZyA6KaB5pS+5Zue5Y6744CCXG4gICAgICAgICAgICAgICAgICAgIGlmIChmaWxlLmdldFN0YXR1cygpID09PSBTdGF0dXMuSU5URVJSVVBUKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBtZS5fcHV0YmFjayhibG9jayk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICBcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICBcbiAgICAgICAgICAgICAgICBtZS5wb29sLnB1c2goIGJsb2NrICk7XG4gICAgICAgICAgICAgICAgbWUucmVtYW5pbmcrKztcbiAgICBcbiAgICAgICAgICAgICAgICAvLyDlpoLmnpzmsqHmnInliIbniYfvvIzliJnnm7TmjqXkvb/nlKjljp/lp4vnmoTjgIJcbiAgICAgICAgICAgICAgICAvLyDkuI3kvJrkuKLlpLFjb250ZW50LXR5cGXkv6Hmga/jgIJcbiAgICAgICAgICAgICAgICBibG9jay5ibG9iID0gYmxvY2suY2h1bmtzID09PSAxID8gZmlsZS5zb3VyY2UgOlxuICAgICAgICAgICAgICAgICAgICAgICAgZmlsZS5zb3VyY2Uuc2xpY2UoIGJsb2NrLnN0YXJ0LCBibG9jay5lbmQgKTtcbiAgICBcbiAgICAgICAgICAgICAgICAvLyBob29rLCDmr4/kuKrliIbniYflj5HpgIHkuYvliY3lj6/og73opoHlgZrkupvlvILmraXnmoTkuovmg4XjgIJcbiAgICAgICAgICAgICAgICBwcm9taXNlID0gbWUucmVxdWVzdCggJ2JlZm9yZS1zZW5kJywgYmxvY2ssIGZ1bmN0aW9uKCkge1xuICAgIFxuICAgICAgICAgICAgICAgICAgICAvLyDmnInlj6/og73mlofku7blt7Lnu4/kuIrkvKDlh7rplJnkuobvvIzmiYDku6XkuI3pnIDopoHlho3kvKDovpPkuobjgIJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCBmaWxlLmdldFN0YXR1cygpID09PSBTdGF0dXMuUFJPR1JFU1MgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBtZS5fZG9TZW5kKCBibG9jayApO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgbWUuX3BvcEJsb2NrKCBibG9jayApO1xuICAgICAgICAgICAgICAgICAgICAgICAgQmFzZS5uZXh0VGljayggbWUuX190aWNrICk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICBcbiAgICAgICAgICAgICAgICAvLyDlpoLmnpzkuLpmYWls5LqG77yM5YiZ6Lez6L+H5q2k5YiG54mH44CCXG4gICAgICAgICAgICAgICAgcHJvbWlzZS5mYWlsKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIGZpbGUucmVtYW5pbmcgPT09IDEgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBtZS5fZmluaXNoRmlsZSggZmlsZSApLmFsd2F5cyhmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBibG9jay5wZXJjZW50YWdlID0gMTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtZS5fcG9wQmxvY2soIGJsb2NrICk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWUub3duZXIudHJpZ2dlciggJ3VwbG9hZENvbXBsZXRlJywgZmlsZSApO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIEJhc2UubmV4dFRpY2soIG1lLl9fdGljayApO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBibG9jay5wZXJjZW50YWdlID0gMTtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1lLnVwZGF0ZUZpbGVQcm9ncmVzcyggZmlsZSApO1xuICAgICAgICAgICAgICAgICAgICAgICAgbWUuX3BvcEJsb2NrKCBibG9jayApO1xuICAgICAgICAgICAgICAgICAgICAgICAgQmFzZS5uZXh0VGljayggbWUuX190aWNrICk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0sXG4gICAgXG4gICAgXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIEBldmVudCB1cGxvYWRCZWZvcmVTZW5kXG4gICAgICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0XG4gICAgICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gZGF0YSDpu5jorqTnmoTkuIrkvKDlj4LmlbDvvIzlj6/ku6XmianlsZXmraTlr7nosaHmnaXmjqfliLbkuIrkvKDlj4LmlbDjgIJcbiAgICAgICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBoZWFkZXJzIOWPr+S7peaJqeWxleatpOWvueixoeadpeaOp+WItuS4iuS8oOWktOmDqOOAglxuICAgICAgICAgICAgICogQGRlc2NyaXB0aW9uIOW9k+afkOS4quaWh+S7tueahOWIhuWdl+WcqOWPkemAgeWJjeinpuWPke+8jOS4u+imgeeUqOadpeivoumXruaYr+WQpuimgea3u+WKoOmZhOW4puWPguaVsO+8jOWkp+aWh+S7tuWcqOW8gOi1t+WIhueJh+S4iuS8oOeahOWJjeaPkOS4i+atpOS6i+S7tuWPr+iDveS8muinpuWPkeWkmuasoeOAglxuICAgICAgICAgICAgICogQGZvciAgVXBsb2FkZXJcbiAgICAgICAgICAgICAqL1xuICAgIFxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBAZXZlbnQgdXBsb2FkQWNjZXB0XG4gICAgICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0XG4gICAgICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gcmV0IOacjeWKoeerr+eahOi/lOWbnuaVsOaNru+8jGpzb27moLzlvI/vvIzlpoLmnpzmnI3liqHnq6/kuI3mmK9qc29u5qC85byP77yM5LuOcmV0Ll9yYXfkuK3lj5bmlbDmja7vvIzoh6rooYzop6PmnpDjgIJcbiAgICAgICAgICAgICAqIEBkZXNjcmlwdGlvbiDlvZPmn5DkuKrmlofku7bkuIrkvKDliLDmnI3liqHnq6/lk43lupTlkI7vvIzkvJrmtL7pgIHmraTkuovku7bmnaXor6Lpl67mnI3liqHnq6/lk43lupTmmK/lkKbmnInmlYjjgILlpoLmnpzmraTkuovku7ZoYW5kbGVy6L+U5Zue5YC85Li6YGZhbHNlYCwg5YiZ5q2k5paH5Lu25bCG5rS+6YCBYHNlcnZlcmDnsbvlnovnmoRgdXBsb2FkRXJyb3Jg5LqL5Lu244CCXG4gICAgICAgICAgICAgKiBAZm9yICBVcGxvYWRlclxuICAgICAgICAgICAgICovXG4gICAgXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIEBldmVudCB1cGxvYWRQcm9ncmVzc1xuICAgICAgICAgICAgICogQHBhcmFtIHtGaWxlfSBmaWxlIEZpbGXlr7nosaFcbiAgICAgICAgICAgICAqIEBwYXJhbSB7TnVtYmVyfSBwZXJjZW50YWdlIOS4iuS8oOi/m+W6plxuICAgICAgICAgICAgICogQGRlc2NyaXB0aW9uIOS4iuS8oOi/h+eoi+S4reinpuWPke+8jOaQuuW4puS4iuS8oOi/m+W6puOAglxuICAgICAgICAgICAgICogQGZvciAgVXBsb2FkZXJcbiAgICAgICAgICAgICAqL1xuICAgIFxuICAgIFxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBAZXZlbnQgdXBsb2FkRXJyb3JcbiAgICAgICAgICAgICAqIEBwYXJhbSB7RmlsZX0gZmlsZSBGaWxl5a+56LGhXG4gICAgICAgICAgICAgKiBAcGFyYW0ge1N0cmluZ30gcmVhc29uIOWHuumUmeeahGNvZGVcbiAgICAgICAgICAgICAqIEBkZXNjcmlwdGlvbiDlvZPmlofku7bkuIrkvKDlh7rplJnml7bop6blj5HjgIJcbiAgICAgICAgICAgICAqIEBmb3IgIFVwbG9hZGVyXG4gICAgICAgICAgICAgKi9cbiAgICBcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogQGV2ZW50IHVwbG9hZFN1Y2Nlc3NcbiAgICAgICAgICAgICAqIEBwYXJhbSB7RmlsZX0gZmlsZSBGaWxl5a+56LGhXG4gICAgICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gcmVzcG9uc2Ug5pyN5Yqh56uv6L+U5Zue55qE5pWw5o2uXG4gICAgICAgICAgICAgKiBAZGVzY3JpcHRpb24g5b2T5paH5Lu25LiK5Lyg5oiQ5Yqf5pe26Kem5Y+R44CCXG4gICAgICAgICAgICAgKiBAZm9yICBVcGxvYWRlclxuICAgICAgICAgICAgICovXG4gICAgXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIEBldmVudCB1cGxvYWRDb21wbGV0ZVxuICAgICAgICAgICAgICogQHBhcmFtIHtGaWxlfSBbZmlsZV0gRmlsZeWvueixoVxuICAgICAgICAgICAgICogQGRlc2NyaXB0aW9uIOS4jeeuoeaIkOWKn+aIluiAheWksei0pe+8jOaWh+S7tuS4iuS8oOWujOaIkOaXtuinpuWPkeOAglxuICAgICAgICAgICAgICogQGZvciAgVXBsb2FkZXJcbiAgICAgICAgICAgICAqL1xuICAgIFxuICAgICAgICAgICAgLy8g5YGa5LiK5Lyg5pON5L2c44CCXG4gICAgICAgICAgICBfZG9TZW5kOiBmdW5jdGlvbiggYmxvY2sgKSB7XG4gICAgICAgICAgICAgICAgdmFyIG1lID0gdGhpcyxcbiAgICAgICAgICAgICAgICAgICAgb3duZXIgPSBtZS5vd25lcixcbiAgICAgICAgICAgICAgICAgICAgb3B0cyA9IG1lLm9wdGlvbnMsXG4gICAgICAgICAgICAgICAgICAgIGZpbGUgPSBibG9jay5maWxlLFxuICAgICAgICAgICAgICAgICAgICB0ciA9IG5ldyBUcmFuc3BvcnQoIG9wdHMgKSxcbiAgICAgICAgICAgICAgICAgICAgZGF0YSA9ICQuZXh0ZW5kKHt9LCBvcHRzLmZvcm1EYXRhICksXG4gICAgICAgICAgICAgICAgICAgIGhlYWRlcnMgPSAkLmV4dGVuZCh7fSwgb3B0cy5oZWFkZXJzICksXG4gICAgICAgICAgICAgICAgICAgIHJlcXVlc3RBY2NlcHQsIHJldDtcbiAgICBcbiAgICAgICAgICAgICAgICBibG9jay50cmFuc3BvcnQgPSB0cjtcbiAgICBcbiAgICAgICAgICAgICAgICB0ci5vbiggJ2Rlc3Ryb3knLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgZGVsZXRlIGJsb2NrLnRyYW5zcG9ydDtcbiAgICAgICAgICAgICAgICAgICAgbWUuX3BvcEJsb2NrKCBibG9jayApO1xuICAgICAgICAgICAgICAgICAgICBCYXNlLm5leHRUaWNrKCBtZS5fX3RpY2sgKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICBcbiAgICAgICAgICAgICAgICAvLyDlub/mkq3kuIrkvKDov5vluqbjgILku6Xmlofku7bkuLrljZXkvY3jgIJcbiAgICAgICAgICAgICAgICB0ci5vbiggJ3Byb2dyZXNzJywgZnVuY3Rpb24oIHBlcmNlbnRhZ2UgKSB7XG4gICAgICAgICAgICAgICAgICAgIGJsb2NrLnBlcmNlbnRhZ2UgPSBwZXJjZW50YWdlO1xuICAgICAgICAgICAgICAgICAgICBtZS51cGRhdGVGaWxlUHJvZ3Jlc3MoIGZpbGUgKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICBcbiAgICAgICAgICAgICAgICAvLyDnlKjmnaXor6Lpl67vvIzmmK/lkKbov5Tlm57nmoTnu5PmnpzmmK/mnInplJnor6/nmoTjgIJcbiAgICAgICAgICAgICAgICByZXF1ZXN0QWNjZXB0ID0gZnVuY3Rpb24oIHJlamVjdCApIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGZuO1xuICAgIFxuICAgICAgICAgICAgICAgICAgICByZXQgPSB0ci5nZXRSZXNwb25zZUFzSnNvbigpIHx8IHt9O1xuICAgICAgICAgICAgICAgICAgICByZXQuX3JhdyA9IHRyLmdldFJlc3BvbnNlKCk7XG4gICAgICAgICAgICAgICAgICAgIGZuID0gZnVuY3Rpb24oIHZhbHVlICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVqZWN0ID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgXG4gICAgICAgICAgICAgICAgICAgIC8vIOacjeWKoeerr+WTjeW6lOS6hu+8jOS4jeS7o+ihqOaIkOWKn+S6hu+8jOivoumXruaYr+WQpuWTjeW6lOato+ehruOAglxuICAgICAgICAgICAgICAgICAgICBpZiAoICFvd25lci50cmlnZ2VyKCAndXBsb2FkQWNjZXB0JywgYmxvY2ssIHJldCwgZm4gKSApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlamVjdCA9IHJlamVjdCB8fCAnc2VydmVyJztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgIFxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVqZWN0O1xuICAgICAgICAgICAgICAgIH07XG4gICAgXG4gICAgICAgICAgICAgICAgLy8g5bCd6K+V6YeN6K+V77yM54S25ZCO5bm/5pKt5paH5Lu25LiK5Lyg5Ye66ZSZ44CCXG4gICAgICAgICAgICAgICAgdHIub24oICdlcnJvcicsIGZ1bmN0aW9uKCB0eXBlLCBmbGFnICkge1xuICAgICAgICAgICAgICAgICAgICBibG9jay5yZXRyaWVkID0gYmxvY2sucmV0cmllZCB8fCAwO1xuICAgIFxuICAgICAgICAgICAgICAgICAgICAvLyDoh6rliqjph43or5VcbiAgICAgICAgICAgICAgICAgICAgaWYgKCBibG9jay5jaHVua3MgPiAxICYmIH4naHR0cCxhYm9ydCcuaW5kZXhPZiggdHlwZSApICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYmxvY2sucmV0cmllZCA8IG9wdHMuY2h1bmtSZXRyeSApIHtcbiAgICBcbiAgICAgICAgICAgICAgICAgICAgICAgIGJsb2NrLnJldHJpZWQrKztcbiAgICAgICAgICAgICAgICAgICAgICAgIHRyLnNlbmQoKTtcbiAgICBcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICBcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGh0dHAgc3RhdHVzIDUwMCB+IDYwMFxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCAhZmxhZyAmJiB0eXBlID09PSAnc2VydmVyJyApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlID0gcmVxdWVzdEFjY2VwdCggdHlwZSApO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgIFxuICAgICAgICAgICAgICAgICAgICAgICAgZmlsZS5zZXRTdGF0dXMoIFN0YXR1cy5FUlJPUiwgdHlwZSApO1xuICAgICAgICAgICAgICAgICAgICAgICAgb3duZXIudHJpZ2dlciggJ3VwbG9hZEVycm9yJywgZmlsZSwgdHlwZSApO1xuICAgICAgICAgICAgICAgICAgICAgICAgb3duZXIudHJpZ2dlciggJ3VwbG9hZENvbXBsZXRlJywgZmlsZSApO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgXG4gICAgICAgICAgICAgICAgLy8g5LiK5Lyg5oiQ5YqfXG4gICAgICAgICAgICAgICAgdHIub24oICdsb2FkJywgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciByZWFzb247XG4gICAgXG4gICAgICAgICAgICAgICAgICAgIC8vIOWmguaenOmdnumihOacn++8jOi9rOWQkeS4iuS8oOWHuumUmeOAglxuICAgICAgICAgICAgICAgICAgICBpZiAoIChyZWFzb24gPSByZXF1ZXN0QWNjZXB0KCkpICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdHIudHJpZ2dlciggJ2Vycm9yJywgcmVhc29uLCB0cnVlICk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICBcbiAgICAgICAgICAgICAgICAgICAgLy8g5YWo6YOo5LiK5Lyg5a6M5oiQ44CCXG4gICAgICAgICAgICAgICAgICAgIGlmICggZmlsZS5yZW1hbmluZyA9PT0gMSApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1lLl9maW5pc2hGaWxlKCBmaWxlLCByZXQgKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRyLmRlc3Ryb3koKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgIFxuICAgICAgICAgICAgICAgIC8vIOmFjee9rum7mOiupOeahOS4iuS8oOWtl+auteOAglxuICAgICAgICAgICAgICAgIGRhdGEgPSAkLmV4dGVuZCggZGF0YSwge1xuICAgICAgICAgICAgICAgICAgICBpZDogZmlsZS5pZCxcbiAgICAgICAgICAgICAgICAgICAgbmFtZTogZmlsZS5uYW1lLFxuICAgICAgICAgICAgICAgICAgICB0eXBlOiBmaWxlLnR5cGUsXG4gICAgICAgICAgICAgICAgICAgIGxhc3RNb2RpZmllZERhdGU6IGZpbGUubGFzdE1vZGlmaWVkRGF0ZSxcbiAgICAgICAgICAgICAgICAgICAgc2l6ZTogZmlsZS5zaXplXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgXG4gICAgICAgICAgICAgICAgYmxvY2suY2h1bmtzID4gMSAmJiAkLmV4dGVuZCggZGF0YSwge1xuICAgICAgICAgICAgICAgICAgICBjaHVua3M6IGJsb2NrLmNodW5rcyxcbiAgICAgICAgICAgICAgICAgICAgY2h1bms6IGJsb2NrLmNodW5rXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgXG4gICAgICAgICAgICAgICAgLy8g5Zyo5Y+R6YCB5LmL6Ze05Y+v5Lul5re75Yqg5a2X5q615LuA5LmI55qE44CC44CC44CCXG4gICAgICAgICAgICAgICAgLy8g5aaC5p6c6buY6K6k55qE5a2X5q615LiN5aSf5L2/55So77yM5Y+v5Lul6YCa6L+H55uR5ZCs5q2k5LqL5Lu25p2l5omp5bGVXG4gICAgICAgICAgICAgICAgb3duZXIudHJpZ2dlciggJ3VwbG9hZEJlZm9yZVNlbmQnLCBibG9jaywgZGF0YSwgaGVhZGVycyApO1xuICAgIFxuICAgICAgICAgICAgICAgIC8vIOW8gOWni+WPkemAgeOAglxuICAgICAgICAgICAgICAgIHRyLmFwcGVuZEJsb2IoIG9wdHMuZmlsZVZhbCwgYmxvY2suYmxvYiwgZmlsZS5uYW1lICk7XG4gICAgICAgICAgICAgICAgdHIuYXBwZW5kKCBkYXRhICk7XG4gICAgICAgICAgICAgICAgdHIuc2V0UmVxdWVzdEhlYWRlciggaGVhZGVycyApO1xuICAgICAgICAgICAgICAgIHRyLnNlbmQoKTtcbiAgICAgICAgICAgIH0sXG4gICAgXG4gICAgICAgICAgICAvLyDlrozmiJDkuIrkvKDjgIJcbiAgICAgICAgICAgIF9maW5pc2hGaWxlOiBmdW5jdGlvbiggZmlsZSwgcmV0LCBoZHMgKSB7XG4gICAgICAgICAgICAgICAgdmFyIG93bmVyID0gdGhpcy5vd25lcjtcbiAgICAgICAgICAgICAgICAvL3dxZCDlrprliLbljJbkv67mlLlcbiAgICAgICAgICAgICAgICBpZihyZXQuRl9DT0RFID09PSBcIjBcIil7XG4gICAgICAgICAgICAgICAgICAgIGZpbGUuc2V0U3RhdHVzKCBTdGF0dXMuQ09NUExFVEUgKTtcbiAgICAgICAgICAgICAgICAgICAgb3duZXIudHJpZ2dlciggJ3VwbG9hZFN1Y2Nlc3MnLCBmaWxlLCByZXQsIGhkcyApO1xuICAgICAgICAgICAgICAgIH1lbHNle1xuICAgICAgICAgICAgICAgICAgICAvLyDlpoLmnpzlpJbpg6jlt7Lnu4/moIforrDkuLppbnZhbGlk5LuA5LmI55qE77yM5LiN5YaN5pS554q25oCB44CCXG4gICAgICAgICAgICAgICAgICAgIGlmICggZmlsZS5nZXRTdGF0dXMoKSA9PT0gU3RhdHVzLlBST0dSRVNTICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZmlsZS5zZXRTdGF0dXMoIFN0YXR1cy5FUlJPUiwgcmV0ICk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgb3duZXIudHJpZ2dlciggJ3VwbG9hZEVycm9yJywgZmlsZSwgcmV0ICk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIG93bmVyLnRyaWdnZXIoICd1cGxvYWRDb21wbGV0ZScsIGZpbGUscmV0ICk7XG4gICAgICAgICAgICAgICAgLyogcmV0dXJuIG93bmVyXG4gICAgICAgICAgICAgICAgICAgICAgICAucmVxdWVzdCggJ2FmdGVyLXNlbmQtZmlsZScsIGFyZ3VtZW50cywgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZmlsZS5zZXRTdGF0dXMoIFN0YXR1cy5DT01QTEVURSApO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG93bmVyLnRyaWdnZXIoICd1cGxvYWRTdWNjZXNzJywgZmlsZSwgcmV0LCBoZHMgKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgICAgICAgICAuZmFpbChmdW5jdGlvbiggcmVhc29uICkge1xuICAgIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIOWmguaenOWklumDqOW3sue7j+agh+iusOS4umludmFsaWTku4DkuYjnmoTvvIzkuI3lho3mlLnnirbmgIHjgIJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIGZpbGUuZ2V0U3RhdHVzKCkgPT09IFN0YXR1cy5QUk9HUkVTUyApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZmlsZS5zZXRTdGF0dXMoIFN0YXR1cy5FUlJPUiwgcmVhc29uICk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG93bmVyLnRyaWdnZXIoICd1cGxvYWRFcnJvcicsIGZpbGUsIHJlYXNvbiApO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAgICAgICAgIC5hbHdheXMoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb3duZXIudHJpZ2dlciggJ3VwbG9hZENvbXBsZXRlJywgZmlsZSApO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSk7ICovXG4gICAgICAgICAgICB9LFxuICAgIFxuICAgICAgICAgICAgdXBkYXRlRmlsZVByb2dyZXNzOiBmdW5jdGlvbihmaWxlKSB7XG4gICAgICAgICAgICAgICAgdmFyIHRvdGFsUGVyY2VudCA9IDAsXG4gICAgICAgICAgICAgICAgICAgIHVwbG9hZGVkID0gMDtcbiAgICBcbiAgICAgICAgICAgICAgICBpZiAoIWZpbGUuYmxvY2tzKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgXG4gICAgICAgICAgICAgICAgJC5lYWNoKCBmaWxlLmJsb2NrcywgZnVuY3Rpb24oIF8sIHYgKSB7XG4gICAgICAgICAgICAgICAgICAgIHVwbG9hZGVkICs9ICh2LnBlcmNlbnRhZ2UgfHwgMCkgKiAodi5lbmQgLSB2LnN0YXJ0KTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICBcbiAgICAgICAgICAgICAgICB0b3RhbFBlcmNlbnQgPSB1cGxvYWRlZCAvIGZpbGUuc2l6ZTtcbiAgICAgICAgICAgICAgICB0aGlzLm93bmVyLnRyaWdnZXIoICd1cGxvYWRQcm9ncmVzcycsIGZpbGUsIHRvdGFsUGVyY2VudCB8fCAwICk7XG4gICAgICAgICAgICB9XG4gICAgXG4gICAgICAgIH0pO1xuICAgIH0pO1xuICAgIC8qKlxuICAgICAqIEBmaWxlT3ZlcnZpZXcg5ZCE56eN6aqM6K+B77yM5YyF5ous5paH5Lu25oC75aSn5bCP5piv5ZCm6LaF5Ye644CB5Y2V5paH5Lu25piv5ZCm6LaF5Ye65ZKM5paH5Lu25piv5ZCm6YeN5aSN44CCXG4gICAgICovXG4gICAgXG4gICAgZGVmaW5lKCd3aWRnZXRzL3ZhbGlkYXRvcicsW1xuICAgICAgICAnYmFzZScsXG4gICAgICAgICd1cGxvYWRlcicsXG4gICAgICAgICdmaWxlJyxcbiAgICAgICAgJ3dpZGdldHMvd2lkZ2V0J1xuICAgIF0sIGZ1bmN0aW9uKCBCYXNlLCBVcGxvYWRlciwgV1VGaWxlICkge1xuICAgIFxuICAgICAgICB2YXIgJCA9IEJhc2UuJCxcbiAgICAgICAgICAgIHZhbGlkYXRvcnMgPSB7fSxcbiAgICAgICAgICAgIGFwaTtcbiAgICBcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBldmVudCBlcnJvclxuICAgICAgICAgKiBAcGFyYW0ge1N0cmluZ30gdHlwZSDplJnor6/nsbvlnovjgIJcbiAgICAgICAgICogQGRlc2NyaXB0aW9uIOW9k3ZhbGlkYXRl5LiN6YCa6L+H5pe277yM5Lya5Lul5rS+6YCB6ZSZ6K+v5LqL5Lu255qE5b2i5byP6YCa55+l6LCD55So6ICF44CC6YCa6L+HYHVwbG9hZC5vbignZXJyb3InLCBoYW5kbGVyKWDlj6/ku6XmjZXojrfliLDmraTnsbvplJnor6/vvIznm67liY3mnInku6XkuIvplJnor6/kvJrlnKjnibnlrprnmoTmg4XlhrXkuIvmtL7pgIHplJnmnaXjgIJcbiAgICAgICAgICpcbiAgICAgICAgICogKiBgUV9FWENFRURfTlVNX0xJTUlUYCDlnKjorr7nva7kuoZgZmlsZU51bUxpbWl0YOS4lOWwneivlee7mWB1cGxvYWRlcmDmt7vliqDnmoTmlofku7bmlbDph4/otoXlh7rov5nkuKrlgLzml7bmtL7pgIHjgIJcbiAgICAgICAgICogKiBgUV9FWENFRURfU0laRV9MSU1JVGAg5Zyo6K6+572u5LqGYFFfRVhDRUVEX1NJWkVfTElNSVRg5LiU5bCd6K+V57uZYHVwbG9hZGVyYOa3u+WKoOeahOaWh+S7tuaAu+Wkp+Wwj+i2heWHuui/meS4quWAvOaXtua0vumAgeOAglxuICAgICAgICAgKiAqIGBRX1RZUEVfREVOSUVEYCDlvZPmlofku7bnsbvlnovkuI3mu6HotrPml7bop6blj5HjgILjgIJcbiAgICAgICAgICogQGZvciAgVXBsb2FkZXJcbiAgICAgICAgICovXG4gICAgXG4gICAgICAgIC8vIOaatOmcsue7meWklumdoueahGFwaVxuICAgICAgICBhcGkgPSB7XG4gICAgXG4gICAgICAgICAgICAvLyDmt7vliqDpqozor4HlmahcbiAgICAgICAgICAgIGFkZFZhbGlkYXRvcjogZnVuY3Rpb24oIHR5cGUsIGNiICkge1xuICAgICAgICAgICAgICAgIHZhbGlkYXRvcnNbIHR5cGUgXSA9IGNiO1xuICAgICAgICAgICAgfSxcbiAgICBcbiAgICAgICAgICAgIC8vIOenu+mZpOmqjOivgeWZqFxuICAgICAgICAgICAgcmVtb3ZlVmFsaWRhdG9yOiBmdW5jdGlvbiggdHlwZSApIHtcbiAgICAgICAgICAgICAgICBkZWxldGUgdmFsaWRhdG9yc1sgdHlwZSBdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgIFxuICAgICAgICAvLyDlnKhVcGxvYWRlcuWIneWni+WMlueahOaXtuWAmeWQr+WKqFZhbGlkYXRvcnPnmoTliJ3lp4vljJZcbiAgICAgICAgVXBsb2FkZXIucmVnaXN0ZXIoe1xuICAgICAgICAgICAgbmFtZTogJ3ZhbGlkYXRvcicsXG4gICAgXG4gICAgICAgICAgICBpbml0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICB2YXIgbWUgPSB0aGlzO1xuICAgICAgICAgICAgICAgIEJhc2UubmV4dFRpY2soZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICQuZWFjaCggdmFsaWRhdG9ycywgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmNhbGwoIG1lLm93bmVyICk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICBcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwcm9wZXJ0eSB7aW50fSBbZmlsZU51bUxpbWl0PXVuZGVmaW5lZF1cbiAgICAgICAgICogQG5hbWVzcGFjZSBvcHRpb25zXG4gICAgICAgICAqIEBmb3IgVXBsb2FkZXJcbiAgICAgICAgICogQGRlc2NyaXB0aW9uIOmqjOivgeaWh+S7tuaAu+aVsOmHjywg6LaF5Ye65YiZ5LiN5YWB6K645Yqg5YWl6Zif5YiX44CCXG4gICAgICAgICAqL1xuICAgICAgICBhcGkuYWRkVmFsaWRhdG9yKCAnZmlsZU51bUxpbWl0JywgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB2YXIgdXBsb2FkZXIgPSB0aGlzLFxuICAgICAgICAgICAgICAgIG9wdHMgPSB1cGxvYWRlci5vcHRpb25zLFxuICAgICAgICAgICAgICAgIGNvdW50ID0gMCxcbiAgICAgICAgICAgICAgICBtYXggPSBwYXJzZUludCggb3B0cy5maWxlTnVtTGltaXQsIDEwICksXG4gICAgICAgICAgICAgICAgZmxhZyA9IHRydWU7XG4gICAgXG4gICAgICAgICAgICBpZiAoICFtYXggKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgIFxuICAgICAgICAgICAgdXBsb2FkZXIub24oICdiZWZvcmVGaWxlUXVldWVkJywgZnVuY3Rpb24oIGZpbGUgKSB7XG4gICAgXG4gICAgICAgICAgICAgICAgaWYgKCBjb3VudCA+PSBtYXggJiYgZmxhZyApIHtcbiAgICAgICAgICAgICAgICAgICAgZmxhZyA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnRyaWdnZXIoICdlcnJvcicsICdRX0VYQ0VFRF9OVU1fTElNSVQnLCBtYXgsIGZpbGUgKTtcbiAgICAgICAgICAgICAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZsYWcgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB9LCAxICk7XG4gICAgICAgICAgICAgICAgfVxuICAgIFxuICAgICAgICAgICAgICAgIHJldHVybiBjb3VudCA+PSBtYXggPyBmYWxzZSA6IHRydWU7XG4gICAgICAgICAgICB9KTtcbiAgICBcbiAgICAgICAgICAgIHVwbG9hZGVyLm9uKCAnZmlsZVF1ZXVlZCcsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIGNvdW50Kys7XG4gICAgICAgICAgICB9KTtcbiAgICBcbiAgICAgICAgICAgIHVwbG9hZGVyLm9uKCAnZmlsZURlcXVldWVkJywgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgY291bnQtLTtcbiAgICAgICAgICAgIH0pO1xuICAgIFxuICAgICAgICAgICAgdXBsb2FkZXIub24oICdyZXNldCcsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIGNvdW50ID0gMDtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICBcbiAgICBcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwcm9wZXJ0eSB7aW50fSBbZmlsZVNpemVMaW1pdD11bmRlZmluZWRdXG4gICAgICAgICAqIEBuYW1lc3BhY2Ugb3B0aW9uc1xuICAgICAgICAgKiBAZm9yIFVwbG9hZGVyXG4gICAgICAgICAqIEBkZXNjcmlwdGlvbiDpqozor4Hmlofku7bmgLvlpKflsI/mmK/lkKbotoXlh7rpmZDliLYsIOi2heWHuuWImeS4jeWFgeiuuOWKoOWFpemYn+WIl+OAglxuICAgICAgICAgKi9cbiAgICAgICAgYXBpLmFkZFZhbGlkYXRvciggJ2ZpbGVTaXplTGltaXQnLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHZhciB1cGxvYWRlciA9IHRoaXMsXG4gICAgICAgICAgICAgICAgb3B0cyA9IHVwbG9hZGVyLm9wdGlvbnMsXG4gICAgICAgICAgICAgICAgY291bnQgPSAwLFxuICAgICAgICAgICAgICAgIG1heCA9IHBhcnNlSW50KCBvcHRzLmZpbGVTaXplTGltaXQsIDEwICksXG4gICAgICAgICAgICAgICAgZmxhZyA9IHRydWU7XG4gICAgXG4gICAgICAgICAgICBpZiAoICFtYXggKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgIFxuICAgICAgICAgICAgdXBsb2FkZXIub24oICdiZWZvcmVGaWxlUXVldWVkJywgZnVuY3Rpb24oIGZpbGUgKSB7XG4gICAgICAgICAgICAgICAgdmFyIGludmFsaWQgPSBjb3VudCArIGZpbGUuc2l6ZSA+IG1heDtcbiAgICBcbiAgICAgICAgICAgICAgICBpZiAoIGludmFsaWQgJiYgZmxhZyApIHtcbiAgICAgICAgICAgICAgICAgICAgZmxhZyA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnRyaWdnZXIoICdlcnJvcicsICdRX0VYQ0VFRF9TSVpFX0xJTUlUJywgbWF4LCBmaWxlICk7XG4gICAgICAgICAgICAgICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBmbGFnID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgfSwgMSApO1xuICAgICAgICAgICAgICAgIH1cbiAgICBcbiAgICAgICAgICAgICAgICByZXR1cm4gaW52YWxpZCA/IGZhbHNlIDogdHJ1ZTtcbiAgICAgICAgICAgIH0pO1xuICAgIFxuICAgICAgICAgICAgdXBsb2FkZXIub24oICdmaWxlUXVldWVkJywgZnVuY3Rpb24oIGZpbGUgKSB7XG4gICAgICAgICAgICAgICAgY291bnQgKz0gZmlsZS5zaXplO1xuICAgICAgICAgICAgfSk7XG4gICAgXG4gICAgICAgICAgICB1cGxvYWRlci5vbiggJ2ZpbGVEZXF1ZXVlZCcsIGZ1bmN0aW9uKCBmaWxlICkge1xuICAgICAgICAgICAgICAgIGNvdW50IC09IGZpbGUuc2l6ZTtcbiAgICAgICAgICAgIH0pO1xuICAgIFxuICAgICAgICAgICAgdXBsb2FkZXIub24oICdyZXNldCcsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIGNvdW50ID0gMDtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICBcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwcm9wZXJ0eSB7aW50fSBbZmlsZVNpbmdsZVNpemVMaW1pdD11bmRlZmluZWRdXG4gICAgICAgICAqIEBuYW1lc3BhY2Ugb3B0aW9uc1xuICAgICAgICAgKiBAZm9yIFVwbG9hZGVyXG4gICAgICAgICAqIEBkZXNjcmlwdGlvbiDpqozor4HljZXkuKrmlofku7blpKflsI/mmK/lkKbotoXlh7rpmZDliLYsIOi2heWHuuWImeS4jeWFgeiuuOWKoOWFpemYn+WIl+OAglxuICAgICAgICAgKi9cbiAgICAgICAgYXBpLmFkZFZhbGlkYXRvciggJ2ZpbGVTaW5nbGVTaXplTGltaXQnLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHZhciB1cGxvYWRlciA9IHRoaXMsXG4gICAgICAgICAgICAgICAgb3B0cyA9IHVwbG9hZGVyLm9wdGlvbnMsXG4gICAgICAgICAgICAgICAgbWF4ID0gb3B0cy5maWxlU2luZ2xlU2l6ZUxpbWl0O1xuICAgIFxuICAgICAgICAgICAgaWYgKCAhbWF4ICkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICBcbiAgICAgICAgICAgIHVwbG9hZGVyLm9uKCAnYmVmb3JlRmlsZVF1ZXVlZCcsIGZ1bmN0aW9uKCBmaWxlICkge1xuICAgIFxuICAgICAgICAgICAgICAgIGlmICggZmlsZS5zaXplID4gbWF4ICkge1xuICAgICAgICAgICAgICAgICAgICBmaWxlLnNldFN0YXR1cyggV1VGaWxlLlN0YXR1cy5JTlZBTElELCAnZXhjZWVkX3NpemUnICk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMudHJpZ2dlciggJ2Vycm9yJywgJ0ZfRVhDRUVEX1NJWkUnLCBtYXgsIGZpbGUgKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICBcbiAgICAgICAgICAgIH0pO1xuICAgIFxuICAgICAgICB9KTtcbiAgICBcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwcm9wZXJ0eSB7Qm9vbGVhbn0gW2R1cGxpY2F0ZT11bmRlZmluZWRdXG4gICAgICAgICAqIEBuYW1lc3BhY2Ugb3B0aW9uc1xuICAgICAgICAgKiBAZm9yIFVwbG9hZGVyXG4gICAgICAgICAqIEBkZXNjcmlwdGlvbiDljrvph43vvIwg5qC55o2u5paH5Lu25ZCN5a2X44CB5paH5Lu25aSn5bCP5ZKM5pyA5ZCO5L+u5pS55pe26Ze05p2l55Sf5oiQaGFzaCBLZXkuXG4gICAgICAgICAqL1xuICAgICAgICBhcGkuYWRkVmFsaWRhdG9yKCAnZHVwbGljYXRlJywgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB2YXIgdXBsb2FkZXIgPSB0aGlzLFxuICAgICAgICAgICAgICAgIG9wdHMgPSB1cGxvYWRlci5vcHRpb25zLFxuICAgICAgICAgICAgICAgIG1hcHBpbmcgPSB7fTtcbiAgICBcbiAgICAgICAgICAgIGlmICggb3B0cy5kdXBsaWNhdGUgKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgIFxuICAgICAgICAgICAgZnVuY3Rpb24gaGFzaFN0cmluZyggc3RyICkge1xuICAgICAgICAgICAgICAgIHZhciBoYXNoID0gMCxcbiAgICAgICAgICAgICAgICAgICAgaSA9IDAsXG4gICAgICAgICAgICAgICAgICAgIGxlbiA9IHN0ci5sZW5ndGgsXG4gICAgICAgICAgICAgICAgICAgIF9jaGFyO1xuICAgIFxuICAgICAgICAgICAgICAgIGZvciAoIDsgaSA8IGxlbjsgaSsrICkge1xuICAgICAgICAgICAgICAgICAgICBfY2hhciA9IHN0ci5jaGFyQ29kZUF0KCBpICk7XG4gICAgICAgICAgICAgICAgICAgIGhhc2ggPSBfY2hhciArIChoYXNoIDw8IDYpICsgKGhhc2ggPDwgMTYpIC0gaGFzaDtcbiAgICAgICAgICAgICAgICB9XG4gICAgXG4gICAgICAgICAgICAgICAgcmV0dXJuIGhhc2g7XG4gICAgICAgICAgICB9XG4gICAgXG4gICAgICAgICAgICB1cGxvYWRlci5vbiggJ2JlZm9yZUZpbGVRdWV1ZWQnLCBmdW5jdGlvbiggZmlsZSApIHtcbiAgICAgICAgICAgICAgICB2YXIgaGFzaCA9IGZpbGUuX19oYXNoIHx8IChmaWxlLl9faGFzaCA9IGhhc2hTdHJpbmcoIGZpbGUubmFtZSArXG4gICAgICAgICAgICAgICAgICAgICAgICBmaWxlLnNpemUgKyBmaWxlLmxhc3RNb2RpZmllZERhdGUgKSk7XG4gICAgXG4gICAgICAgICAgICAgICAgLy8g5bey57uP6YeN5aSN5LqGXG4gICAgICAgICAgICAgICAgaWYgKCBtYXBwaW5nWyBoYXNoIF0gKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMudHJpZ2dlciggJ2Vycm9yJywgJ0ZfRFVQTElDQVRFJywgZmlsZSApO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgXG4gICAgICAgICAgICB1cGxvYWRlci5vbiggJ2ZpbGVRdWV1ZWQnLCBmdW5jdGlvbiggZmlsZSApIHtcbiAgICAgICAgICAgICAgICB2YXIgaGFzaCA9IGZpbGUuX19oYXNoO1xuICAgIFxuICAgICAgICAgICAgICAgIGhhc2ggJiYgKG1hcHBpbmdbIGhhc2ggXSA9IHRydWUpO1xuICAgICAgICAgICAgfSk7XG4gICAgXG4gICAgICAgICAgICB1cGxvYWRlci5vbiggJ2ZpbGVEZXF1ZXVlZCcsIGZ1bmN0aW9uKCBmaWxlICkge1xuICAgICAgICAgICAgICAgIHZhciBoYXNoID0gZmlsZS5fX2hhc2g7XG4gICAgXG4gICAgICAgICAgICAgICAgaGFzaCAmJiAoZGVsZXRlIG1hcHBpbmdbIGhhc2ggXSk7XG4gICAgICAgICAgICB9KTtcbiAgICBcbiAgICAgICAgICAgIHVwbG9hZGVyLm9uKCAncmVzZXQnLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICBtYXBwaW5nID0ge307XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgXG4gICAgICAgIHJldHVybiBhcGk7XG4gICAgfSk7XG4gICAgXG4gICAgLyoqXG4gICAgICogQGZpbGVPdmVydmlldyBNZDVcbiAgICAgKi9cbiAgICBkZWZpbmUoJ2xpYi9tZDUnLFtcbiAgICAgICAgJ3J1bnRpbWUvY2xpZW50JyxcbiAgICAgICAgJ21lZGlhdG9yJ1xuICAgIF0sIGZ1bmN0aW9uKCBSdW50aW1lQ2xpZW50LCBNZWRpYXRvciApIHtcbiAgICBcbiAgICAgICAgZnVuY3Rpb24gTWQ1KCkge1xuICAgICAgICAgICAgUnVudGltZUNsaWVudC5jYWxsKCB0aGlzLCAnTWQ1JyApO1xuICAgICAgICB9XG4gICAgXG4gICAgICAgIC8vIOiuqSBNZDUg5YW35aSH5LqL5Lu25Yqf6IO944CCXG4gICAgICAgIE1lZGlhdG9yLmluc3RhbGxUbyggTWQ1LnByb3RvdHlwZSApO1xuICAgIFxuICAgICAgICBNZDUucHJvdG90eXBlLmxvYWRGcm9tQmxvYiA9IGZ1bmN0aW9uKCBibG9iICkge1xuICAgICAgICAgICAgdmFyIG1lID0gdGhpcztcbiAgICBcbiAgICAgICAgICAgIGlmICggbWUuZ2V0UnVpZCgpICkge1xuICAgICAgICAgICAgICAgIG1lLmRpc2Nvbm5lY3RSdW50aW1lKCk7XG4gICAgICAgICAgICB9XG4gICAgXG4gICAgICAgICAgICAvLyDov57mjqXliLBibG9i5b2S5bGe55qE5ZCM5LiA5LiqcnVudGltZS5cbiAgICAgICAgICAgIG1lLmNvbm5lY3RSdW50aW1lKCBibG9iLnJ1aWQsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIG1lLmV4ZWMoJ2luaXQnKTtcbiAgICAgICAgICAgICAgICBtZS5leGVjKCAnbG9hZEZyb21CbG9iJywgYmxvYiApO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH07XG4gICAgXG4gICAgICAgIE1kNS5wcm90b3R5cGUuZ2V0UmVzdWx0ID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5leGVjKCdnZXRSZXN1bHQnKTtcbiAgICAgICAgfTtcbiAgICBcbiAgICAgICAgcmV0dXJuIE1kNTtcbiAgICB9KTtcbiAgICAvKipcbiAgICAgKiBAZmlsZU92ZXJ2aWV3IOWbvueJh+aTjeS9nCwg6LSf6LSj6aKE6KeI5Zu+54mH5ZKM5LiK5Lyg5YmN5Y6L57yp5Zu+54mHXG4gICAgICovXG4gICAgZGVmaW5lKCd3aWRnZXRzL21kNScsW1xuICAgICAgICAnYmFzZScsXG4gICAgICAgICd1cGxvYWRlcicsXG4gICAgICAgICdsaWIvbWQ1JyxcbiAgICAgICAgJ2xpYi9ibG9iJyxcbiAgICAgICAgJ3dpZGdldHMvd2lkZ2V0J1xuICAgIF0sIGZ1bmN0aW9uKCBCYXNlLCBVcGxvYWRlciwgTWQ1LCBCbG9iICkge1xuICAgIFxuICAgICAgICByZXR1cm4gVXBsb2FkZXIucmVnaXN0ZXIoe1xuICAgICAgICAgICAgbmFtZTogJ21kNScsXG4gICAgXG4gICAgXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIOiuoeeul+aWh+S7tiBtZDUg5YC877yM6L+U5Zue5LiA5LiqIHByb21pc2Ug5a+56LGh77yM5Y+v5Lul55uR5ZCsIHByb2dyZXNzIOi/m+W6puOAglxuICAgICAgICAgICAgICpcbiAgICAgICAgICAgICAqXG4gICAgICAgICAgICAgKiBAbWV0aG9kIG1kNUZpbGVcbiAgICAgICAgICAgICAqIEBncmFtbWFyIG1kNUZpbGUoIGZpbGVbLCBzdGFydFssIGVuZF1dICkgPT4gcHJvbWlzZVxuICAgICAgICAgICAgICogQGZvciBVcGxvYWRlclxuICAgICAgICAgICAgICogQGV4YW1wbGVcbiAgICAgICAgICAgICAqXG4gICAgICAgICAgICAgKiB1cGxvYWRlci5vbiggJ2ZpbGVRdWV1ZWQnLCBmdW5jdGlvbiggZmlsZSApIHtcbiAgICAgICAgICAgICAqICAgICB2YXIgJGxpID0gLi4uO1xuICAgICAgICAgICAgICpcbiAgICAgICAgICAgICAqICAgICB1cGxvYWRlci5tZDVGaWxlKCBmaWxlIClcbiAgICAgICAgICAgICAqXG4gICAgICAgICAgICAgKiAgICAgICAgIC8vIOWPiuaXtuaYvuekuui/m+W6plxuICAgICAgICAgICAgICogICAgICAgICAucHJvZ3Jlc3MoZnVuY3Rpb24ocGVyY2VudGFnZSkge1xuICAgICAgICAgICAgICogICAgICAgICAgICAgY29uc29sZS5sb2coJ1BlcmNlbnRhZ2U6JywgcGVyY2VudGFnZSk7XG4gICAgICAgICAgICAgKiAgICAgICAgIH0pXG4gICAgICAgICAgICAgKlxuICAgICAgICAgICAgICogICAgICAgICAvLyDlrozmiJBcbiAgICAgICAgICAgICAqICAgICAgICAgLnRoZW4oZnVuY3Rpb24odmFsKSB7XG4gICAgICAgICAgICAgKiAgICAgICAgICAgICBjb25zb2xlLmxvZygnbWQ1IHJlc3VsdDonLCB2YWwpO1xuICAgICAgICAgICAgICogICAgICAgICB9KTtcbiAgICAgICAgICAgICAqXG4gICAgICAgICAgICAgKiB9KTtcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgbWQ1RmlsZTogZnVuY3Rpb24oIGZpbGUsIHN0YXJ0LCBlbmQgKSB7XG4gICAgICAgICAgICAgICAgdmFyIG1kNSA9IG5ldyBNZDUoKSxcbiAgICAgICAgICAgICAgICAgICAgZGVmZXJyZWQgPSBCYXNlLkRlZmVycmVkKCksXG4gICAgICAgICAgICAgICAgICAgIGJsb2IgPSAoZmlsZSBpbnN0YW5jZW9mIEJsb2IpID8gZmlsZSA6XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnJlcXVlc3QoICdnZXQtZmlsZScsIGZpbGUgKS5zb3VyY2U7XG4gICAgXG4gICAgICAgICAgICAgICAgbWQ1Lm9uKCAncHJvZ3Jlc3MgbG9hZCcsIGZ1bmN0aW9uKCBlICkge1xuICAgICAgICAgICAgICAgICAgICBlID0gZSB8fCB7fTtcbiAgICAgICAgICAgICAgICAgICAgZGVmZXJyZWQubm90aWZ5KCBlLnRvdGFsID8gZS5sb2FkZWQgLyBlLnRvdGFsIDogMSApO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgIFxuICAgICAgICAgICAgICAgIG1kNS5vbiggJ2NvbXBsZXRlJywgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIGRlZmVycmVkLnJlc29sdmUoIG1kNS5nZXRSZXN1bHQoKSApO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgIFxuICAgICAgICAgICAgICAgIG1kNS5vbiggJ2Vycm9yJywgZnVuY3Rpb24oIHJlYXNvbiApIHtcbiAgICAgICAgICAgICAgICAgICAgZGVmZXJyZWQucmVqZWN0KCByZWFzb24gKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICBcbiAgICAgICAgICAgICAgICBpZiAoIGFyZ3VtZW50cy5sZW5ndGggPiAxICkge1xuICAgICAgICAgICAgICAgICAgICBzdGFydCA9IHN0YXJ0IHx8IDA7XG4gICAgICAgICAgICAgICAgICAgIGVuZCA9IGVuZCB8fCAwO1xuICAgICAgICAgICAgICAgICAgICBzdGFydCA8IDAgJiYgKHN0YXJ0ID0gYmxvYi5zaXplICsgc3RhcnQpO1xuICAgICAgICAgICAgICAgICAgICBlbmQgPCAwICYmIChlbmQgPSBibG9iLnNpemUgKyBlbmQpO1xuICAgICAgICAgICAgICAgICAgICBlbmQgPSBNYXRoLm1pbiggZW5kLCBibG9iLnNpemUgKTtcbiAgICAgICAgICAgICAgICAgICAgYmxvYiA9IGJsb2Iuc2xpY2UoIHN0YXJ0LCBlbmQgKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgXG4gICAgICAgICAgICAgICAgbWQ1LmxvYWRGcm9tQmxvYiggYmxvYiApO1xuICAgIFxuICAgICAgICAgICAgICAgIHJldHVybiBkZWZlcnJlZC5wcm9taXNlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH0pO1xuICAgIC8qKlxuICAgICAqIEBmaWxlT3ZlcnZpZXcgUnVudGltZeeuoeeQhuWZqO+8jOi0n+i0o1J1bnRpbWXnmoTpgInmi6ksIOi/nuaOpVxuICAgICAqL1xuICAgIGRlZmluZSgncnVudGltZS9jb21wYmFzZScsW10sZnVuY3Rpb24oKSB7XG4gICAgXG4gICAgICAgIGZ1bmN0aW9uIENvbXBCYXNlKCBvd25lciwgcnVudGltZSApIHtcbiAgICBcbiAgICAgICAgICAgIHRoaXMub3duZXIgPSBvd25lcjtcbiAgICAgICAgICAgIHRoaXMub3B0aW9ucyA9IG93bmVyLm9wdGlvbnM7XG4gICAgXG4gICAgICAgICAgICB0aGlzLmdldFJ1bnRpbWUgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcnVudGltZTtcbiAgICAgICAgICAgIH07XG4gICAgXG4gICAgICAgICAgICB0aGlzLmdldFJ1aWQgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcnVudGltZS51aWQ7XG4gICAgICAgICAgICB9O1xuICAgIFxuICAgICAgICAgICAgdGhpcy50cmlnZ2VyID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG93bmVyLnRyaWdnZXIuYXBwbHkoIG93bmVyLCBhcmd1bWVudHMgKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICBcbiAgICAgICAgcmV0dXJuIENvbXBCYXNlO1xuICAgIH0pO1xuICAgIC8qKlxuICAgICAqIEBmaWxlT3ZlcnZpZXcgSHRtbDVSdW50aW1lXG4gICAgICovXG4gICAgZGVmaW5lKCdydW50aW1lL2h0bWw1L3J1bnRpbWUnLFtcbiAgICAgICAgJ2Jhc2UnLFxuICAgICAgICAncnVudGltZS9ydW50aW1lJyxcbiAgICAgICAgJ3J1bnRpbWUvY29tcGJhc2UnXG4gICAgXSwgZnVuY3Rpb24oIEJhc2UsIFJ1bnRpbWUsIENvbXBCYXNlICkge1xuICAgIFxuICAgICAgICB2YXIgdHlwZSA9ICdodG1sNScsXG4gICAgICAgICAgICBjb21wb25lbnRzID0ge307XG4gICAgXG4gICAgICAgIGZ1bmN0aW9uIEh0bWw1UnVudGltZSgpIHtcbiAgICAgICAgICAgIHZhciBwb29sID0ge30sXG4gICAgICAgICAgICAgICAgbWUgPSB0aGlzLFxuICAgICAgICAgICAgICAgIGRlc3Ryb3kgPSB0aGlzLmRlc3Ryb3k7XG4gICAgXG4gICAgICAgICAgICBSdW50aW1lLmFwcGx5KCBtZSwgYXJndW1lbnRzICk7XG4gICAgICAgICAgICBtZS50eXBlID0gdHlwZTtcbiAgICBcbiAgICBcbiAgICAgICAgICAgIC8vIOi/meS4quaWueazleeahOiwg+eUqOiAhe+8jOWunumZheS4iuaYr1J1bnRpbWVDbGllbnRcbiAgICAgICAgICAgIG1lLmV4ZWMgPSBmdW5jdGlvbiggY29tcCwgZm4vKiwgYXJncy4uLiovKSB7XG4gICAgICAgICAgICAgICAgdmFyIGNsaWVudCA9IHRoaXMsXG4gICAgICAgICAgICAgICAgICAgIHVpZCA9IGNsaWVudC51aWQsXG4gICAgICAgICAgICAgICAgICAgIGFyZ3MgPSBCYXNlLnNsaWNlKCBhcmd1bWVudHMsIDIgKSxcbiAgICAgICAgICAgICAgICAgICAgaW5zdGFuY2U7XG4gICAgXG4gICAgICAgICAgICAgICAgaWYgKCBjb21wb25lbnRzWyBjb21wIF0gKSB7XG4gICAgICAgICAgICAgICAgICAgIGluc3RhbmNlID0gcG9vbFsgdWlkIF0gPSBwb29sWyB1aWQgXSB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5ldyBjb21wb25lbnRzWyBjb21wIF0oIGNsaWVudCwgbWUgKTtcbiAgICBcbiAgICAgICAgICAgICAgICAgICAgaWYgKCBpbnN0YW5jZVsgZm4gXSApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBpbnN0YW5jZVsgZm4gXS5hcHBseSggaW5zdGFuY2UsIGFyZ3MgKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgXG4gICAgICAgICAgICBtZS5kZXN0cm95ID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgLy8gQHRvZG8g5Yig6Zmk5rGg5a2Q5Lit55qE5omA5pyJ5a6e5L6LXG4gICAgICAgICAgICAgICAgcmV0dXJuIGRlc3Ryb3kgJiYgZGVzdHJveS5hcHBseSggdGhpcywgYXJndW1lbnRzICk7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgXG4gICAgICAgIEJhc2UuaW5oZXJpdHMoIFJ1bnRpbWUsIHtcbiAgICAgICAgICAgIGNvbnN0cnVjdG9yOiBIdG1sNVJ1bnRpbWUsXG4gICAgXG4gICAgICAgICAgICAvLyDkuI3pnIDopoHov57mjqXlhbbku5bnqIvluo/vvIznm7TmjqXmiafooYxjYWxsYmFja1xuICAgICAgICAgICAgaW5pdDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgdmFyIG1lID0gdGhpcztcbiAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICBtZS50cmlnZ2VyKCdyZWFkeScpO1xuICAgICAgICAgICAgICAgIH0sIDEgKTtcbiAgICAgICAgICAgIH1cbiAgICBcbiAgICAgICAgfSk7XG4gICAgXG4gICAgICAgIC8vIOazqOWGjENvbXBvbmVudHNcbiAgICAgICAgSHRtbDVSdW50aW1lLnJlZ2lzdGVyID0gZnVuY3Rpb24oIG5hbWUsIGNvbXBvbmVudCApIHtcbiAgICAgICAgICAgIHZhciBrbGFzcyA9IGNvbXBvbmVudHNbIG5hbWUgXSA9IEJhc2UuaW5oZXJpdHMoIENvbXBCYXNlLCBjb21wb25lbnQgKTtcbiAgICAgICAgICAgIHJldHVybiBrbGFzcztcbiAgICAgICAgfTtcbiAgICBcbiAgICAgICAgLy8g5rOo5YaMaHRtbDXov5DooYzml7bjgIJcbiAgICAgICAgLy8g5Y+q5pyJ5Zyo5pSv5oyB55qE5YmN5o+Q5LiL5rOo5YaM44CCXG4gICAgICAgIGlmICggd2luZG93LkJsb2IgJiYgd2luZG93LkZpbGVSZWFkZXIgJiYgd2luZG93LkRhdGFWaWV3ICkge1xuICAgICAgICAgICAgUnVudGltZS5hZGRSdW50aW1lKCB0eXBlLCBIdG1sNVJ1bnRpbWUgKTtcbiAgICAgICAgfVxuICAgIFxuICAgICAgICByZXR1cm4gSHRtbDVSdW50aW1lO1xuICAgIH0pO1xuICAgIC8qKlxuICAgICAqIEBmaWxlT3ZlcnZpZXcgQmxvYiBIdG1s5a6e546wXG4gICAgICovXG4gICAgZGVmaW5lKCdydW50aW1lL2h0bWw1L2Jsb2InLFtcbiAgICAgICAgJ3J1bnRpbWUvaHRtbDUvcnVudGltZScsXG4gICAgICAgICdsaWIvYmxvYidcbiAgICBdLCBmdW5jdGlvbiggSHRtbDVSdW50aW1lLCBCbG9iICkge1xuICAgIFxuICAgICAgICByZXR1cm4gSHRtbDVSdW50aW1lLnJlZ2lzdGVyKCAnQmxvYicsIHtcbiAgICAgICAgICAgIHNsaWNlOiBmdW5jdGlvbiggc3RhcnQsIGVuZCApIHtcbiAgICAgICAgICAgICAgICB2YXIgYmxvYiA9IHRoaXMub3duZXIuc291cmNlLFxuICAgICAgICAgICAgICAgICAgICBzbGljZSA9IGJsb2Iuc2xpY2UgfHwgYmxvYi53ZWJraXRTbGljZSB8fCBibG9iLm1velNsaWNlO1xuICAgIFxuICAgICAgICAgICAgICAgIGJsb2IgPSBzbGljZS5jYWxsKCBibG9iLCBzdGFydCwgZW5kICk7XG4gICAgXG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBCbG9iKCB0aGlzLmdldFJ1aWQoKSwgYmxvYiApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9KTtcbiAgICAvKipcbiAgICAgKiBAZmlsZU92ZXJ2aWV3IEZpbGVQYXN0ZVxuICAgICAqL1xuICAgIGRlZmluZSgncnVudGltZS9odG1sNS9kbmQnLFtcbiAgICAgICAgJ2Jhc2UnLFxuICAgICAgICAncnVudGltZS9odG1sNS9ydW50aW1lJyxcbiAgICAgICAgJ2xpYi9maWxlJ1xuICAgIF0sIGZ1bmN0aW9uKCBCYXNlLCBIdG1sNVJ1bnRpbWUsIEZpbGUgKSB7XG4gICAgXG4gICAgICAgIHZhciAkID0gQmFzZS4kLFxuICAgICAgICAgICAgcHJlZml4ID0gJ3dlYnVwbG9hZGVyLWRuZC0nO1xuICAgIFxuICAgICAgICByZXR1cm4gSHRtbDVSdW50aW1lLnJlZ2lzdGVyKCAnRHJhZ0FuZERyb3AnLCB7XG4gICAgICAgICAgICBpbml0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICB2YXIgZWxlbSA9IHRoaXMuZWxlbSA9IHRoaXMub3B0aW9ucy5jb250YWluZXI7XG4gICAgXG4gICAgICAgICAgICAgICAgdGhpcy5kcmFnRW50ZXJIYW5kbGVyID0gQmFzZS5iaW5kRm4oIHRoaXMuX2RyYWdFbnRlckhhbmRsZXIsIHRoaXMgKTtcbiAgICAgICAgICAgICAgICB0aGlzLmRyYWdPdmVySGFuZGxlciA9IEJhc2UuYmluZEZuKCB0aGlzLl9kcmFnT3ZlckhhbmRsZXIsIHRoaXMgKTtcbiAgICAgICAgICAgICAgICB0aGlzLmRyYWdMZWF2ZUhhbmRsZXIgPSBCYXNlLmJpbmRGbiggdGhpcy5fZHJhZ0xlYXZlSGFuZGxlciwgdGhpcyApO1xuICAgICAgICAgICAgICAgIHRoaXMuZHJvcEhhbmRsZXIgPSBCYXNlLmJpbmRGbiggdGhpcy5fZHJvcEhhbmRsZXIsIHRoaXMgKTtcbiAgICAgICAgICAgICAgICB0aGlzLmRuZE92ZXIgPSBmYWxzZTtcbiAgICBcbiAgICAgICAgICAgICAgICBlbGVtLm9uKCAnZHJhZ2VudGVyJywgdGhpcy5kcmFnRW50ZXJIYW5kbGVyICk7XG4gICAgICAgICAgICAgICAgZWxlbS5vbiggJ2RyYWdvdmVyJywgdGhpcy5kcmFnT3ZlckhhbmRsZXIgKTtcbiAgICAgICAgICAgICAgICBlbGVtLm9uKCAnZHJhZ2xlYXZlJywgdGhpcy5kcmFnTGVhdmVIYW5kbGVyICk7XG4gICAgICAgICAgICAgICAgZWxlbS5vbiggJ2Ryb3AnLCB0aGlzLmRyb3BIYW5kbGVyICk7XG4gICAgXG4gICAgICAgICAgICAgICAgaWYgKCB0aGlzLm9wdGlvbnMuZGlzYWJsZUdsb2JhbERuZCApIHtcbiAgICAgICAgICAgICAgICAgICAgJCggZG9jdW1lbnQgKS5vbiggJ2RyYWdvdmVyJywgdGhpcy5kcmFnT3ZlckhhbmRsZXIgKTtcbiAgICAgICAgICAgICAgICAgICAgJCggZG9jdW1lbnQgKS5vbiggJ2Ryb3AnLCB0aGlzLmRyb3BIYW5kbGVyICk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICBcbiAgICAgICAgICAgIF9kcmFnRW50ZXJIYW5kbGVyOiBmdW5jdGlvbiggZSApIHtcbiAgICAgICAgICAgICAgICB2YXIgbWUgPSB0aGlzLFxuICAgICAgICAgICAgICAgICAgICBkZW5pZWQgPSBtZS5fZGVuaWVkIHx8IGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICBpdGVtcztcbiAgICBcbiAgICAgICAgICAgICAgICBlID0gZS5vcmlnaW5hbEV2ZW50IHx8IGU7XG4gICAgXG4gICAgICAgICAgICAgICAgaWYgKCAhbWUuZG5kT3ZlciApIHtcbiAgICAgICAgICAgICAgICAgICAgbWUuZG5kT3ZlciA9IHRydWU7XG4gICAgXG4gICAgICAgICAgICAgICAgICAgIC8vIOazqOaEj+WPquaciSBjaHJvbWUg5pSv5oyB44CCXG4gICAgICAgICAgICAgICAgICAgIGl0ZW1zID0gZS5kYXRhVHJhbnNmZXIuaXRlbXM7XG4gICAgXG4gICAgICAgICAgICAgICAgICAgIGlmICggaXRlbXMgJiYgaXRlbXMubGVuZ3RoICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbWUuX2RlbmllZCA9IGRlbmllZCA9ICFtZS50cmlnZ2VyKCAnYWNjZXB0JywgaXRlbXMgKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgIFxuICAgICAgICAgICAgICAgICAgICBtZS5lbGVtLmFkZENsYXNzKCBwcmVmaXggKyAnb3ZlcicgKTtcbiAgICAgICAgICAgICAgICAgICAgbWUuZWxlbVsgZGVuaWVkID8gJ2FkZENsYXNzJyA6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJ3JlbW92ZUNsYXNzJyBdKCBwcmVmaXggKyAnZGVuaWVkJyApO1xuICAgICAgICAgICAgICAgIH1cbiAgICBcbiAgICAgICAgICAgICAgICBlLmRhdGFUcmFuc2Zlci5kcm9wRWZmZWN0ID0gZGVuaWVkID8gJ25vbmUnIDogJ2NvcHknO1xuICAgIFxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH0sXG4gICAgXG4gICAgICAgICAgICBfZHJhZ092ZXJIYW5kbGVyOiBmdW5jdGlvbiggZSApIHtcbiAgICAgICAgICAgICAgICAvLyDlj6rlpITnkIbmoYblhoXnmoTjgIJcbiAgICAgICAgICAgICAgICB2YXIgcGFyZW50RWxlbSA9IHRoaXMuZWxlbS5wYXJlbnQoKS5nZXQoIDAgKTtcbiAgICAgICAgICAgICAgICBpZiAoIHBhcmVudEVsZW0gJiYgISQuY29udGFpbnMoIHBhcmVudEVsZW0sIGUuY3VycmVudFRhcmdldCApICkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgIFxuICAgICAgICAgICAgICAgIGNsZWFyVGltZW91dCggdGhpcy5fbGVhdmVUaW1lciApO1xuICAgICAgICAgICAgICAgIHRoaXMuX2RyYWdFbnRlckhhbmRsZXIuY2FsbCggdGhpcywgZSApO1xuICAgIFxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH0sXG4gICAgXG4gICAgICAgICAgICBfZHJhZ0xlYXZlSGFuZGxlcjogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgdmFyIG1lID0gdGhpcyxcbiAgICAgICAgICAgICAgICAgICAgaGFuZGxlcjtcbiAgICBcbiAgICAgICAgICAgICAgICBoYW5kbGVyID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIG1lLmRuZE92ZXIgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgbWUuZWxlbS5yZW1vdmVDbGFzcyggcHJlZml4ICsgJ292ZXIgJyArIHByZWZpeCArICdkZW5pZWQnICk7XG4gICAgICAgICAgICAgICAgfTtcbiAgICBcbiAgICAgICAgICAgICAgICBjbGVhclRpbWVvdXQoIG1lLl9sZWF2ZVRpbWVyICk7XG4gICAgICAgICAgICAgICAgbWUuX2xlYXZlVGltZXIgPSBzZXRUaW1lb3V0KCBoYW5kbGVyLCAxMDAgKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9LFxuICAgIFxuICAgICAgICAgICAgX2Ryb3BIYW5kbGVyOiBmdW5jdGlvbiggZSApIHtcbiAgICAgICAgICAgICAgICB2YXIgbWUgPSB0aGlzLFxuICAgICAgICAgICAgICAgICAgICBydWlkID0gbWUuZ2V0UnVpZCgpLFxuICAgICAgICAgICAgICAgICAgICBwYXJlbnRFbGVtID0gbWUuZWxlbS5wYXJlbnQoKS5nZXQoIDAgKSxcbiAgICAgICAgICAgICAgICAgICAgZGF0YVRyYW5zZmVyLCBkYXRhO1xuICAgIFxuICAgICAgICAgICAgICAgIC8vIOWPquWkhOeQhuahhuWGheeahOOAglxuICAgICAgICAgICAgICAgIGlmICggcGFyZW50RWxlbSAmJiAhJC5jb250YWlucyggcGFyZW50RWxlbSwgZS5jdXJyZW50VGFyZ2V0ICkgKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgXG4gICAgICAgICAgICAgICAgZSA9IGUub3JpZ2luYWxFdmVudCB8fCBlO1xuICAgICAgICAgICAgICAgIGRhdGFUcmFuc2ZlciA9IGUuZGF0YVRyYW5zZmVyO1xuICAgIFxuICAgICAgICAgICAgICAgIC8vIOWmguaenOaYr+mhtemdouWGheaLluaLve+8jOi/mOS4jeiDveWkhOeQhu+8jOS4jemYu+atouS6i+S7tuOAglxuICAgICAgICAgICAgICAgIC8vIOatpOWkhCBpZTExIOS4i+S8muaKpeWPguaVsOmUmeivr++8jFxuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIGRhdGEgPSBkYXRhVHJhbnNmZXIuZ2V0RGF0YSgndGV4dC9odG1sJyk7XG4gICAgICAgICAgICAgICAgfSBjYXRjaCggZXJyICkge1xuICAgICAgICAgICAgICAgIH1cbiAgICBcbiAgICAgICAgICAgICAgICBpZiAoIGRhdGEgKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgXG4gICAgICAgICAgICAgICAgbWUuX2dldFRhbnNmZXJGaWxlcyggZGF0YVRyYW5zZmVyLCBmdW5jdGlvbiggcmVzdWx0cyApIHtcbiAgICAgICAgICAgICAgICAgICAgbWUudHJpZ2dlciggJ2Ryb3AnLCAkLm1hcCggcmVzdWx0cywgZnVuY3Rpb24oIGZpbGUgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3IEZpbGUoIHJ1aWQsIGZpbGUgKTtcbiAgICAgICAgICAgICAgICAgICAgfSkgKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICBcbiAgICAgICAgICAgICAgICBtZS5kbmRPdmVyID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgbWUuZWxlbS5yZW1vdmVDbGFzcyggcHJlZml4ICsgJ292ZXInICk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfSxcbiAgICBcbiAgICAgICAgICAgIC8vIOWmguaenOS8oOWFpSBjYWxsYmFjayDliJnljrvmn6XnnIvmlofku7blpLnvvIzlkKbliJnlj6rnrqHlvZPliY3mlofku7blpLnjgIJcbiAgICAgICAgICAgIF9nZXRUYW5zZmVyRmlsZXM6IGZ1bmN0aW9uKCBkYXRhVHJhbnNmZXIsIGNhbGxiYWNrICkge1xuICAgICAgICAgICAgICAgIHZhciByZXN1bHRzICA9IFtdLFxuICAgICAgICAgICAgICAgICAgICBwcm9taXNlcyA9IFtdLFxuICAgICAgICAgICAgICAgICAgICBpdGVtcywgZmlsZXMsIGZpbGUsIGl0ZW0sIGksIGxlbiwgY2FuQWNjZXNzRm9sZGVyO1xuICAgIFxuICAgICAgICAgICAgICAgIGl0ZW1zID0gZGF0YVRyYW5zZmVyLml0ZW1zO1xuICAgICAgICAgICAgICAgIGZpbGVzID0gZGF0YVRyYW5zZmVyLmZpbGVzO1xuICAgIFxuICAgICAgICAgICAgICAgIGNhbkFjY2Vzc0ZvbGRlciA9ICEhKGl0ZW1zICYmIGl0ZW1zWyAwIF0ud2Via2l0R2V0QXNFbnRyeSk7XG4gICAgXG4gICAgICAgICAgICAgICAgZm9yICggaSA9IDAsIGxlbiA9IGZpbGVzLmxlbmd0aDsgaSA8IGxlbjsgaSsrICkge1xuICAgICAgICAgICAgICAgICAgICBmaWxlID0gZmlsZXNbIGkgXTtcbiAgICAgICAgICAgICAgICAgICAgaXRlbSA9IGl0ZW1zICYmIGl0ZW1zWyBpIF07XG4gICAgXG4gICAgICAgICAgICAgICAgICAgIGlmICggY2FuQWNjZXNzRm9sZGVyICYmIGl0ZW0ud2Via2l0R2V0QXNFbnRyeSgpLmlzRGlyZWN0b3J5ICkge1xuICAgIFxuICAgICAgICAgICAgICAgICAgICAgICAgcHJvbWlzZXMucHVzaCggdGhpcy5fdHJhdmVyc2VEaXJlY3RvcnlUcmVlKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpdGVtLndlYmtpdEdldEFzRW50cnkoKSwgcmVzdWx0cyApICk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHRzLnB1c2goIGZpbGUgKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICBcbiAgICAgICAgICAgICAgICBCYXNlLndoZW4uYXBwbHkoIEJhc2UsIHByb21pc2VzICkuZG9uZShmdW5jdGlvbigpIHtcbiAgICBcbiAgICAgICAgICAgICAgICAgICAgaWYgKCAhcmVzdWx0cy5sZW5ndGggKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICBcbiAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2soIHJlc3VsdHMgKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0sXG4gICAgXG4gICAgICAgICAgICBfdHJhdmVyc2VEaXJlY3RvcnlUcmVlOiBmdW5jdGlvbiggZW50cnksIHJlc3VsdHMgKSB7XG4gICAgICAgICAgICAgICAgdmFyIGRlZmVycmVkID0gQmFzZS5EZWZlcnJlZCgpLFxuICAgICAgICAgICAgICAgICAgICBtZSA9IHRoaXM7XG4gICAgXG4gICAgICAgICAgICAgICAgaWYgKCBlbnRyeS5pc0ZpbGUgKSB7XG4gICAgICAgICAgICAgICAgICAgIGVudHJ5LmZpbGUoZnVuY3Rpb24oIGZpbGUgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHRzLnB1c2goIGZpbGUgKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlZmVycmVkLnJlc29sdmUoKTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmICggZW50cnkuaXNEaXJlY3RvcnkgKSB7XG4gICAgICAgICAgICAgICAgICAgIGVudHJ5LmNyZWF0ZVJlYWRlcigpLnJlYWRFbnRyaWVzKGZ1bmN0aW9uKCBlbnRyaWVzICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGxlbiA9IGVudHJpZXMubGVuZ3RoLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByb21pc2VzID0gW10sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYXJyID0gW10sICAgIC8vIOS4uuS6huS/neivgemhuuW6j+OAglxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGk7XG4gICAgXG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKCBpID0gMDsgaSA8IGxlbjsgaSsrICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByb21pc2VzLnB1c2goIG1lLl90cmF2ZXJzZURpcmVjdG9yeVRyZWUoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbnRyaWVzWyBpIF0sIGFyciApICk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgXG4gICAgICAgICAgICAgICAgICAgICAgICBCYXNlLndoZW4uYXBwbHkoIEJhc2UsIHByb21pc2VzICkudGhlbihmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHRzLnB1c2guYXBwbHkoIHJlc3VsdHMsIGFyciApO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlZmVycmVkLnJlc29sdmUoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sIGRlZmVycmVkLnJlamVjdCApO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgXG4gICAgICAgICAgICAgICAgcmV0dXJuIGRlZmVycmVkLnByb21pc2UoKTtcbiAgICAgICAgICAgIH0sXG4gICAgXG4gICAgICAgICAgICBkZXN0cm95OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICB2YXIgZWxlbSA9IHRoaXMuZWxlbTtcbiAgICBcbiAgICAgICAgICAgICAgICAvLyDov5jmsqEgaW5pdCDlsLHosIPnlKggZGVzdHJveVxuICAgICAgICAgICAgICAgIGlmICghZWxlbSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIGVsZW0ub2ZmKCAnZHJhZ2VudGVyJywgdGhpcy5kcmFnRW50ZXJIYW5kbGVyICk7XG4gICAgICAgICAgICAgICAgZWxlbS5vZmYoICdkcmFnb3ZlcicsIHRoaXMuZHJhZ092ZXJIYW5kbGVyICk7XG4gICAgICAgICAgICAgICAgZWxlbS5vZmYoICdkcmFnbGVhdmUnLCB0aGlzLmRyYWdMZWF2ZUhhbmRsZXIgKTtcbiAgICAgICAgICAgICAgICBlbGVtLm9mZiggJ2Ryb3AnLCB0aGlzLmRyb3BIYW5kbGVyICk7XG4gICAgXG4gICAgICAgICAgICAgICAgaWYgKCB0aGlzLm9wdGlvbnMuZGlzYWJsZUdsb2JhbERuZCApIHtcbiAgICAgICAgICAgICAgICAgICAgJCggZG9jdW1lbnQgKS5vZmYoICdkcmFnb3ZlcicsIHRoaXMuZHJhZ092ZXJIYW5kbGVyICk7XG4gICAgICAgICAgICAgICAgICAgICQoIGRvY3VtZW50ICkub2ZmKCAnZHJvcCcsIHRoaXMuZHJvcEhhbmRsZXIgKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH0pO1xuICAgIFxuICAgIC8qKlxuICAgICAqIEBmaWxlT3ZlcnZpZXcgRmlsZVBhc3RlXG4gICAgICovXG4gICAgZGVmaW5lKCdydW50aW1lL2h0bWw1L2ZpbGVwYXN0ZScsW1xuICAgICAgICAnYmFzZScsXG4gICAgICAgICdydW50aW1lL2h0bWw1L3J1bnRpbWUnLFxuICAgICAgICAnbGliL2ZpbGUnXG4gICAgXSwgZnVuY3Rpb24oIEJhc2UsIEh0bWw1UnVudGltZSwgRmlsZSApIHtcbiAgICBcbiAgICAgICAgcmV0dXJuIEh0bWw1UnVudGltZS5yZWdpc3RlciggJ0ZpbGVQYXN0ZScsIHtcbiAgICAgICAgICAgIGluaXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHZhciBvcHRzID0gdGhpcy5vcHRpb25zLFxuICAgICAgICAgICAgICAgICAgICBlbGVtID0gdGhpcy5lbGVtID0gb3B0cy5jb250YWluZXIsXG4gICAgICAgICAgICAgICAgICAgIGFjY2VwdCA9ICcuKicsXG4gICAgICAgICAgICAgICAgICAgIGFyciwgaSwgbGVuLCBpdGVtO1xuICAgIFxuICAgICAgICAgICAgICAgIC8vIGFjY2V0cOeahG1pbWVUeXBlc+S4reeUn+aIkOWMuemFjeato+WImeOAglxuICAgICAgICAgICAgICAgIGlmICggb3B0cy5hY2NlcHQgKSB7XG4gICAgICAgICAgICAgICAgICAgIGFyciA9IFtdO1xuICAgIFxuICAgICAgICAgICAgICAgICAgICBmb3IgKCBpID0gMCwgbGVuID0gb3B0cy5hY2NlcHQubGVuZ3RoOyBpIDwgbGVuOyBpKysgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpdGVtID0gb3B0cy5hY2NlcHRbIGkgXS5taW1lVHlwZXM7XG4gICAgICAgICAgICAgICAgICAgICAgICBpdGVtICYmIGFyci5wdXNoKCBpdGVtICk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICBcbiAgICAgICAgICAgICAgICAgICAgaWYgKCBhcnIubGVuZ3RoICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYWNjZXB0ID0gYXJyLmpvaW4oJywnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFjY2VwdCA9IGFjY2VwdC5yZXBsYWNlKCAvLC9nLCAnfCcgKS5yZXBsYWNlKCAvXFwqL2csICcuKicgKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLmFjY2VwdCA9IGFjY2VwdCA9IG5ldyBSZWdFeHAoIGFjY2VwdCwgJ2knICk7XG4gICAgICAgICAgICAgICAgdGhpcy5oYW5kZXIgPSBCYXNlLmJpbmRGbiggdGhpcy5fcGFzdGVIYW5kZXIsIHRoaXMgKTtcbiAgICAgICAgICAgICAgICBlbGVtLm9uKCAncGFzdGUnLCB0aGlzLmhhbmRlciApO1xuICAgICAgICAgICAgfSxcbiAgICBcbiAgICAgICAgICAgIF9wYXN0ZUhhbmRlcjogZnVuY3Rpb24oIGUgKSB7XG4gICAgICAgICAgICAgICAgdmFyIGFsbG93ZWQgPSBbXSxcbiAgICAgICAgICAgICAgICAgICAgcnVpZCA9IHRoaXMuZ2V0UnVpZCgpLFxuICAgICAgICAgICAgICAgICAgICBpdGVtcywgaXRlbSwgYmxvYiwgaSwgbGVuO1xuICAgIFxuICAgICAgICAgICAgICAgIGUgPSBlLm9yaWdpbmFsRXZlbnQgfHwgZTtcbiAgICAgICAgICAgICAgICBpdGVtcyA9IGUuY2xpcGJvYXJkRGF0YS5pdGVtcztcbiAgICBcbiAgICAgICAgICAgICAgICBmb3IgKCBpID0gMCwgbGVuID0gaXRlbXMubGVuZ3RoOyBpIDwgbGVuOyBpKysgKSB7XG4gICAgICAgICAgICAgICAgICAgIGl0ZW0gPSBpdGVtc1sgaSBdO1xuICAgIFxuICAgICAgICAgICAgICAgICAgICBpZiAoIGl0ZW0ua2luZCAhPT0gJ2ZpbGUnIHx8ICEoYmxvYiA9IGl0ZW0uZ2V0QXNGaWxlKCkpICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICBcbiAgICAgICAgICAgICAgICAgICAgYWxsb3dlZC5wdXNoKCBuZXcgRmlsZSggcnVpZCwgYmxvYiApICk7XG4gICAgICAgICAgICAgICAgfVxuICAgIFxuICAgICAgICAgICAgICAgIGlmICggYWxsb3dlZC5sZW5ndGggKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIOS4jemYu+atoumdnuaWh+S7tueymOi0tO+8iOaWh+Wtl+eymOi0tO+8ieeahOS6i+S7tuWGkuazoVxuICAgICAgICAgICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICAgICAgICAgIGUuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMudHJpZ2dlciggJ3Bhc3RlJywgYWxsb3dlZCApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgXG4gICAgICAgICAgICBkZXN0cm95OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmVsZW0ub2ZmKCAncGFzdGUnLCB0aGlzLmhhbmRlciApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9KTtcbiAgICBcbiAgICAvKipcbiAgICAgKiBAZmlsZU92ZXJ2aWV3IEZpbGVQaWNrZXJcbiAgICAgKi9cbiAgICBkZWZpbmUoJ3J1bnRpbWUvaHRtbDUvZmlsZXBpY2tlcicsW1xuICAgICAgICAnYmFzZScsXG4gICAgICAgICdydW50aW1lL2h0bWw1L3J1bnRpbWUnXG4gICAgXSwgZnVuY3Rpb24oIEJhc2UsIEh0bWw1UnVudGltZSApIHtcbiAgICBcbiAgICAgICAgdmFyICQgPSBCYXNlLiQ7XG4gICAgXG4gICAgICAgIHJldHVybiBIdG1sNVJ1bnRpbWUucmVnaXN0ZXIoICdGaWxlUGlja2VyJywge1xuICAgICAgICAgICAgaW5pdDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgdmFyIGNvbnRhaW5lciA9IHRoaXMuZ2V0UnVudGltZSgpLmdldENvbnRhaW5lcigpLFxuICAgICAgICAgICAgICAgICAgICBtZSA9IHRoaXMsXG4gICAgICAgICAgICAgICAgICAgIG93bmVyID0gbWUub3duZXIsXG4gICAgICAgICAgICAgICAgICAgIG9wdHMgPSBtZS5vcHRpb25zLFxuICAgICAgICAgICAgICAgICAgICBsYWJlbCA9IHRoaXMubGFiZWwgPSAkKCBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdsYWJlbCcpICksXG4gICAgICAgICAgICAgICAgICAgIGlucHV0ID0gIHRoaXMuaW5wdXQgPSAkKCBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdpbnB1dCcpICksXG4gICAgICAgICAgICAgICAgICAgIGFyciwgaSwgbGVuLCBtb3VzZUhhbmRsZXI7XG4gICAgXG4gICAgICAgICAgICAgICAgaW5wdXQuYXR0ciggJ3R5cGUnLCAnZmlsZScgKTtcbiAgICAgICAgICAgICAgICBpbnB1dC5hdHRyKCAnbmFtZScsIG9wdHMubmFtZSApO1xuICAgICAgICAgICAgICAgIGlucHV0LmFkZENsYXNzKCd3ZWJ1cGxvYWRlci1lbGVtZW50LWludmlzaWJsZScpO1xuICAgIFxuICAgICAgICAgICAgICAgIGxhYmVsLm9uKCAnY2xpY2snLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgaW5wdXQudHJpZ2dlcignY2xpY2snKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICBcbiAgICAgICAgICAgICAgICBsYWJlbC5jc3Moe1xuICAgICAgICAgICAgICAgICAgICBvcGFjaXR5OiAwLFxuICAgICAgICAgICAgICAgICAgICB3aWR0aDogJzEwMCUnLFxuICAgICAgICAgICAgICAgICAgICBoZWlnaHQ6ICcxMDAlJyxcbiAgICAgICAgICAgICAgICAgICAgZGlzcGxheTogJ2Jsb2NrJyxcbiAgICAgICAgICAgICAgICAgICAgY3Vyc29yOiAncG9pbnRlcicsXG4gICAgICAgICAgICAgICAgICAgIGJhY2tncm91bmQ6ICcjZmZmZmZmJ1xuICAgICAgICAgICAgICAgIH0pO1xuICAgIFxuICAgICAgICAgICAgICAgIGlmICggb3B0cy5tdWx0aXBsZSApIHtcbiAgICAgICAgICAgICAgICAgICAgaW5wdXQuYXR0ciggJ211bHRpcGxlJywgJ211bHRpcGxlJyApO1xuICAgICAgICAgICAgICAgIH1cbiAgICBcbiAgICAgICAgICAgICAgICAvLyBAdG9kbyBGaXJlZm945LiN5pSv5oyB5Y2V54us5oyH5a6a5ZCO57yAXG4gICAgICAgICAgICAgICAgaWYgKCBvcHRzLmFjY2VwdCAmJiBvcHRzLmFjY2VwdC5sZW5ndGggPiAwICkge1xuICAgICAgICAgICAgICAgICAgICBhcnIgPSBbXTtcbiAgICBcbiAgICAgICAgICAgICAgICAgICAgZm9yICggaSA9IDAsIGxlbiA9IG9wdHMuYWNjZXB0Lmxlbmd0aDsgaSA8IGxlbjsgaSsrICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYXJyLnB1c2goIG9wdHMuYWNjZXB0WyBpIF0ubWltZVR5cGVzICk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICBcbiAgICAgICAgICAgICAgICAgICAgaW5wdXQuYXR0ciggJ2FjY2VwdCcsIGFyci5qb2luKCcsJykgKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgXG4gICAgICAgICAgICAgICAgY29udGFpbmVyLmFwcGVuZCggaW5wdXQgKTtcbiAgICAgICAgICAgICAgICBjb250YWluZXIuYXBwZW5kKCBsYWJlbCApO1xuICAgIFxuICAgICAgICAgICAgICAgIG1vdXNlSGFuZGxlciA9IGZ1bmN0aW9uKCBlICkge1xuICAgICAgICAgICAgICAgICAgICBvd25lci50cmlnZ2VyKCBlLnR5cGUgKTtcbiAgICAgICAgICAgICAgICB9O1xuICAgIFxuICAgICAgICAgICAgICAgIC8qIGlucHV0Lm9uKCAnY2hhbmdlJywgZnVuY3Rpb24oIGUgKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBmbiA9IGFyZ3VtZW50cy5jYWxsZWUsXG4gICAgICAgICAgICAgICAgICAgICAgICBjbG9uZTtcbiAgICBcbiAgICAgICAgICAgICAgICAgICAgbWUuZmlsZXMgPSBlLnRhcmdldC5maWxlcztcbiAgICBcbiAgICAgICAgICAgICAgICAgICAgLy8gcmVzZXQgaW5wdXRcbiAgICAgICAgICAgICAgICAgICAgY2xvbmUgPSB0aGlzLmNsb25lTm9kZSggdHJ1ZSApO1xuICAgICAgICAgICAgICAgICAgICBjbG9uZS52YWx1ZSA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucGFyZW50Tm9kZS5yZXBsYWNlQ2hpbGQoIGNsb25lLCB0aGlzICk7XG4gICAgXG4gICAgICAgICAgICAgICAgICAgIGlucHV0Lm9mZigpO1xuICAgICAgICAgICAgICAgICAgICBpbnB1dCA9ICQoIGNsb25lICkub24oICdjaGFuZ2UnLCBmbiApXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLm9uKCAnbW91c2VlbnRlciBtb3VzZWxlYXZlJywgbW91c2VIYW5kbGVyICk7XG4gICAgXG4gICAgICAgICAgICAgICAgICAgIG93bmVyLnRyaWdnZXIoJ2NoYW5nZScpO1xuICAgICAgICAgICAgICAgIH0pOyAvL3dxZCAyMDE5MDUwN1xuICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICB2YXIgY2hhbmdlRm4gPSAoZnVuY3Rpb24gZXZlbih0aGF0LCBlKXtcbiBcbiAgICAgICAgICAgICAgICAgICAgdmFyIGNsb25lO1xuICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgbWUuZmlsZXMgPSBlLnRhcmdldC5maWxlcztcbiAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgIC8vIHJlc2V0IGlucHV0XG4gICAgICAgICAgICAgICAgICAgIGNsb25lID0gdGhhdC5jbG9uZU5vZGUoIHRydWUgKTtcbiAgICAgICAgICAgICAgICAgICAgY2xvbmUudmFsdWUgPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICB0aGF0LnBhcmVudE5vZGUucmVwbGFjZUNoaWxkKCBjbG9uZSwgdGhhdCApO1xuICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgaW5wdXQub2ZmKCk7XG4gICAgICAgICAgICAgICAgICAgIGlucHV0ID0gJChjbG9uZSkub24oJ2NoYW5nZScsIGZ1bmN0aW9uKGUpe1xuICAgICAgICAgICAgICAgICAgICBldmVuKHRoaXMsIGUpO1xuICAgICAgICAgICAgICAgICAgICB9KS5vbignbW91c2VlbnRlciBtb3VzZWxlYXZlJywgbW91c2VIYW5kbGVyKTtcbiAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgIG93bmVyLnRyaWdnZXIoJ2NoYW5nZScpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICBcbiAgICAgICAgICAgICAgICBpbnB1dC5vbignY2hhbmdlJywgZnVuY3Rpb24oZSl7XG4gICAgICAgICAgICAgICAgICAgIGNoYW5nZUZuKHRoaXMsIGUpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGxhYmVsLm9uKCAnbW91c2VlbnRlciBtb3VzZWxlYXZlJywgbW91c2VIYW5kbGVyICk7XG4gICAgXG4gICAgICAgICAgICB9LFxuICAgIFxuICAgIFxuICAgICAgICAgICAgZ2V0RmlsZXM6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmZpbGVzO1xuICAgICAgICAgICAgfSxcbiAgICBcbiAgICAgICAgICAgIGRlc3Ryb3k6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHRoaXMuaW5wdXQub2ZmKCk7XG4gICAgICAgICAgICAgICAgdGhpcy5sYWJlbC5vZmYoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfSk7XG4gICAgLyoqXG4gICAgICogVGVybXM6XG4gICAgICpcbiAgICAgKiBVaW50OEFycmF5LCBGaWxlUmVhZGVyLCBCbG9iQnVpbGRlciwgYXRvYiwgQXJyYXlCdWZmZXJcbiAgICAgKiBAZmlsZU92ZXJ2aWV3IEltYWdl5o6n5Lu2XG4gICAgICovXG4gICAgZGVmaW5lKCdydW50aW1lL2h0bWw1L3V0aWwnLFtcbiAgICAgICAgJ2Jhc2UnXG4gICAgXSwgZnVuY3Rpb24oIEJhc2UgKSB7XG4gICAgXG4gICAgICAgIHZhciB1cmxBUEkgPSB3aW5kb3cuY3JlYXRlT2JqZWN0VVJMICYmIHdpbmRvdyB8fFxuICAgICAgICAgICAgICAgIHdpbmRvdy5VUkwgJiYgVVJMLnJldm9rZU9iamVjdFVSTCAmJiBVUkwgfHxcbiAgICAgICAgICAgICAgICB3aW5kb3cud2Via2l0VVJMLFxuICAgICAgICAgICAgY3JlYXRlT2JqZWN0VVJMID0gQmFzZS5ub29wLFxuICAgICAgICAgICAgcmV2b2tlT2JqZWN0VVJMID0gY3JlYXRlT2JqZWN0VVJMO1xuICAgIFxuICAgICAgICBpZiAoIHVybEFQSSApIHtcbiAgICBcbiAgICAgICAgICAgIC8vIOabtOWuieWFqOeahOaWueW8j+iwg+eUqO+8jOavlOWmgmFuZHJvaWTph4zpnaLlsLHog73miopjb250ZXh05pS55oiQ5YW25LuW55qE5a+56LGh44CCXG4gICAgICAgICAgICBjcmVhdGVPYmplY3RVUkwgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdXJsQVBJLmNyZWF0ZU9iamVjdFVSTC5hcHBseSggdXJsQVBJLCBhcmd1bWVudHMgKTtcbiAgICAgICAgICAgIH07XG4gICAgXG4gICAgICAgICAgICByZXZva2VPYmplY3RVUkwgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdXJsQVBJLnJldm9rZU9iamVjdFVSTC5hcHBseSggdXJsQVBJLCBhcmd1bWVudHMgKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICBcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGNyZWF0ZU9iamVjdFVSTDogY3JlYXRlT2JqZWN0VVJMLFxuICAgICAgICAgICAgcmV2b2tlT2JqZWN0VVJMOiByZXZva2VPYmplY3RVUkwsXG4gICAgXG4gICAgICAgICAgICBkYXRhVVJMMkJsb2I6IGZ1bmN0aW9uKCBkYXRhVVJJICkge1xuICAgICAgICAgICAgICAgIHZhciBieXRlU3RyLCBpbnRBcnJheSwgYWIsIGksIG1pbWV0eXBlLCBwYXJ0cztcbiAgICBcbiAgICAgICAgICAgICAgICBwYXJ0cyA9IGRhdGFVUkkuc3BsaXQoJywnKTtcbiAgICBcbiAgICAgICAgICAgICAgICBpZiAoIH5wYXJ0c1sgMCBdLmluZGV4T2YoJ2Jhc2U2NCcpICkge1xuICAgICAgICAgICAgICAgICAgICBieXRlU3RyID0gYXRvYiggcGFydHNbIDEgXSApO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGJ5dGVTdHIgPSBkZWNvZGVVUklDb21wb25lbnQoIHBhcnRzWyAxIF0gKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgXG4gICAgICAgICAgICAgICAgYWIgPSBuZXcgQXJyYXlCdWZmZXIoIGJ5dGVTdHIubGVuZ3RoICk7XG4gICAgICAgICAgICAgICAgaW50QXJyYXkgPSBuZXcgVWludDhBcnJheSggYWIgKTtcbiAgICBcbiAgICAgICAgICAgICAgICBmb3IgKCBpID0gMDsgaSA8IGJ5dGVTdHIubGVuZ3RoOyBpKysgKSB7XG4gICAgICAgICAgICAgICAgICAgIGludEFycmF5WyBpIF0gPSBieXRlU3RyLmNoYXJDb2RlQXQoIGkgKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgXG4gICAgICAgICAgICAgICAgbWltZXR5cGUgPSBwYXJ0c1sgMCBdLnNwbGl0KCc6JylbIDEgXS5zcGxpdCgnOycpWyAwIF07XG4gICAgXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuYXJyYXlCdWZmZXJUb0Jsb2IoIGFiLCBtaW1ldHlwZSApO1xuICAgICAgICAgICAgfSxcbiAgICBcbiAgICAgICAgICAgIGRhdGFVUkwyQXJyYXlCdWZmZXI6IGZ1bmN0aW9uKCBkYXRhVVJJICkge1xuICAgICAgICAgICAgICAgIHZhciBieXRlU3RyLCBpbnRBcnJheSwgaSwgcGFydHM7XG4gICAgXG4gICAgICAgICAgICAgICAgcGFydHMgPSBkYXRhVVJJLnNwbGl0KCcsJyk7XG4gICAgXG4gICAgICAgICAgICAgICAgaWYgKCB+cGFydHNbIDAgXS5pbmRleE9mKCdiYXNlNjQnKSApIHtcbiAgICAgICAgICAgICAgICAgICAgYnl0ZVN0ciA9IGF0b2IoIHBhcnRzWyAxIF0gKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBieXRlU3RyID0gZGVjb2RlVVJJQ29tcG9uZW50KCBwYXJ0c1sgMSBdICk7XG4gICAgICAgICAgICAgICAgfVxuICAgIFxuICAgICAgICAgICAgICAgIGludEFycmF5ID0gbmV3IFVpbnQ4QXJyYXkoIGJ5dGVTdHIubGVuZ3RoICk7XG4gICAgXG4gICAgICAgICAgICAgICAgZm9yICggaSA9IDA7IGkgPCBieXRlU3RyLmxlbmd0aDsgaSsrICkge1xuICAgICAgICAgICAgICAgICAgICBpbnRBcnJheVsgaSBdID0gYnl0ZVN0ci5jaGFyQ29kZUF0KCBpICk7XG4gICAgICAgICAgICAgICAgfVxuICAgIFxuICAgICAgICAgICAgICAgIHJldHVybiBpbnRBcnJheS5idWZmZXI7XG4gICAgICAgICAgICB9LFxuICAgIFxuICAgICAgICAgICAgYXJyYXlCdWZmZXJUb0Jsb2I6IGZ1bmN0aW9uKCBidWZmZXIsIHR5cGUgKSB7XG4gICAgICAgICAgICAgICAgdmFyIGJ1aWxkZXIgPSB3aW5kb3cuQmxvYkJ1aWxkZXIgfHwgd2luZG93LldlYktpdEJsb2JCdWlsZGVyLFxuICAgICAgICAgICAgICAgICAgICBiYjtcbiAgICBcbiAgICAgICAgICAgICAgICAvLyBhbmRyb2lk5LiN5pSv5oyB55u05o6lbmV3IEJsb2IsIOWPquiDveWAn+WKqWJsb2JidWlsZGVyLlxuICAgICAgICAgICAgICAgIGlmICggYnVpbGRlciApIHtcbiAgICAgICAgICAgICAgICAgICAgYmIgPSBuZXcgYnVpbGRlcigpO1xuICAgICAgICAgICAgICAgICAgICBiYi5hcHBlbmQoIGJ1ZmZlciApO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gYmIuZ2V0QmxvYiggdHlwZSApO1xuICAgICAgICAgICAgICAgIH1cbiAgICBcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IEJsb2IoWyBidWZmZXIgXSwgdHlwZSA/IHsgdHlwZTogdHlwZSB9IDoge30gKTtcbiAgICAgICAgICAgIH0sXG4gICAgXG4gICAgICAgICAgICAvLyDmir3lh7rmnaXkuLvopoHmmK/kuLrkuobop6PlhrNhbmRyb2lk5LiL6Z2iY2FudmFzLnRvRGF0YVVybOS4jeaUr+aMgWpwZWcuXG4gICAgICAgICAgICAvLyDkvaDlvpfliLDnmoTnu5PmnpzmmK9wbmcuXG4gICAgICAgICAgICBjYW52YXNUb0RhdGFVcmw6IGZ1bmN0aW9uKCBjYW52YXMsIHR5cGUsIHF1YWxpdHkgKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNhbnZhcy50b0RhdGFVUkwoIHR5cGUsIHF1YWxpdHkgLyAxMDAgKTtcbiAgICAgICAgICAgIH0sXG4gICAgXG4gICAgICAgICAgICAvLyBpbWFnZW1lYXTkvJrlpI3lhpnov5nkuKrmlrnms5XvvIzlpoLmnpznlKjmiLfpgInmi6nliqDovb3pgqPkuKrmlofku7bkuobnmoTor53jgIJcbiAgICAgICAgICAgIHBhcnNlTWV0YTogZnVuY3Rpb24oIGJsb2IsIGNhbGxiYWNrICkge1xuICAgICAgICAgICAgICAgIGNhbGxiYWNrKCBmYWxzZSwge30pO1xuICAgICAgICAgICAgfSxcbiAgICBcbiAgICAgICAgICAgIC8vIGltYWdlbWVhdOS8muWkjeWGmei/meS4quaWueazle+8jOWmguaenOeUqOaIt+mAieaLqeWKoOi9vemCo+S4quaWh+S7tuS6hueahOivneOAglxuICAgICAgICAgICAgdXBkYXRlSW1hZ2VIZWFkOiBmdW5jdGlvbiggZGF0YSApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZGF0YTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICB9KTtcbiAgICAvKipcbiAgICAgKiBUZXJtczpcbiAgICAgKlxuICAgICAqIFVpbnQ4QXJyYXksIEZpbGVSZWFkZXIsIEJsb2JCdWlsZGVyLCBhdG9iLCBBcnJheUJ1ZmZlclxuICAgICAqIEBmaWxlT3ZlcnZpZXcgSW1hZ2Xmjqfku7ZcbiAgICAgKi9cbiAgICBkZWZpbmUoJ3J1bnRpbWUvaHRtbDUvaW1hZ2VtZXRhJyxbXG4gICAgICAgICdydW50aW1lL2h0bWw1L3V0aWwnXG4gICAgXSwgZnVuY3Rpb24oIFV0aWwgKSB7XG4gICAgXG4gICAgICAgIHZhciBhcGk7XG4gICAgXG4gICAgICAgIGFwaSA9IHtcbiAgICAgICAgICAgIHBhcnNlcnM6IHtcbiAgICAgICAgICAgICAgICAweGZmZTE6IFtdXG4gICAgICAgICAgICB9LFxuICAgIFxuICAgICAgICAgICAgbWF4TWV0YURhdGFTaXplOiAyNjIxNDQsXG4gICAgXG4gICAgICAgICAgICBwYXJzZTogZnVuY3Rpb24oIGJsb2IsIGNiICkge1xuICAgICAgICAgICAgICAgIHZhciBtZSA9IHRoaXMsXG4gICAgICAgICAgICAgICAgICAgIGZyID0gbmV3IEZpbGVSZWFkZXIoKTtcbiAgICBcbiAgICAgICAgICAgICAgICBmci5vbmxvYWQgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgY2IoIGZhbHNlLCBtZS5fcGFyc2UoIHRoaXMucmVzdWx0ICkgKTtcbiAgICAgICAgICAgICAgICAgICAgZnIgPSBmci5vbmxvYWQgPSBmci5vbmVycm9yID0gbnVsbDtcbiAgICAgICAgICAgICAgICB9O1xuICAgIFxuICAgICAgICAgICAgICAgIGZyLm9uZXJyb3IgPSBmdW5jdGlvbiggZSApIHtcbiAgICAgICAgICAgICAgICAgICAgY2IoIGUubWVzc2FnZSApO1xuICAgICAgICAgICAgICAgICAgICBmciA9IGZyLm9ubG9hZCA9IGZyLm9uZXJyb3IgPSBudWxsO1xuICAgICAgICAgICAgICAgIH07XG4gICAgXG4gICAgICAgICAgICAgICAgYmxvYiA9IGJsb2Iuc2xpY2UoIDAsIG1lLm1heE1ldGFEYXRhU2l6ZSApO1xuICAgICAgICAgICAgICAgIGZyLnJlYWRBc0FycmF5QnVmZmVyKCBibG9iLmdldFNvdXJjZSgpICk7XG4gICAgICAgICAgICB9LFxuICAgIFxuICAgICAgICAgICAgX3BhcnNlOiBmdW5jdGlvbiggYnVmZmVyLCBub1BhcnNlICkge1xuICAgICAgICAgICAgICAgIGlmICggYnVmZmVyLmJ5dGVMZW5ndGggPCA2ICkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgIFxuICAgICAgICAgICAgICAgIHZhciBkYXRhdmlldyA9IG5ldyBEYXRhVmlldyggYnVmZmVyICksXG4gICAgICAgICAgICAgICAgICAgIG9mZnNldCA9IDIsXG4gICAgICAgICAgICAgICAgICAgIG1heE9mZnNldCA9IGRhdGF2aWV3LmJ5dGVMZW5ndGggLSA0LFxuICAgICAgICAgICAgICAgICAgICBoZWFkTGVuZ3RoID0gb2Zmc2V0LFxuICAgICAgICAgICAgICAgICAgICByZXQgPSB7fSxcbiAgICAgICAgICAgICAgICAgICAgbWFya2VyQnl0ZXMsIG1hcmtlckxlbmd0aCwgcGFyc2VycywgaTtcbiAgICBcbiAgICAgICAgICAgICAgICBpZiAoIGRhdGF2aWV3LmdldFVpbnQxNiggMCApID09PSAweGZmZDggKSB7XG4gICAgXG4gICAgICAgICAgICAgICAgICAgIHdoaWxlICggb2Zmc2V0IDwgbWF4T2Zmc2V0ICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbWFya2VyQnl0ZXMgPSBkYXRhdmlldy5nZXRVaW50MTYoIG9mZnNldCApO1xuICAgIFxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCBtYXJrZXJCeXRlcyA+PSAweGZmZTAgJiYgbWFya2VyQnl0ZXMgPD0gMHhmZmVmIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1hcmtlckJ5dGVzID09PSAweGZmZmUgKSB7XG4gICAgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWFya2VyTGVuZ3RoID0gZGF0YXZpZXcuZ2V0VWludDE2KCBvZmZzZXQgKyAyICkgKyAyO1xuICAgIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICggb2Zmc2V0ICsgbWFya2VyTGVuZ3RoID4gZGF0YXZpZXcuYnl0ZUxlbmd0aCApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhcnNlcnMgPSBhcGkucGFyc2Vyc1sgbWFya2VyQnl0ZXMgXTtcbiAgICBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoICFub1BhcnNlICYmIHBhcnNlcnMgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAoIGkgPSAwOyBpIDwgcGFyc2Vycy5sZW5ndGg7IGkgKz0gMSApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhcnNlcnNbIGkgXS5jYWxsKCBhcGksIGRhdGF2aWV3LCBvZmZzZXQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1hcmtlckxlbmd0aCwgcmV0ICk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb2Zmc2V0ICs9IG1hcmtlckxlbmd0aDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBoZWFkTGVuZ3RoID0gb2Zmc2V0O1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgIFxuICAgICAgICAgICAgICAgICAgICBpZiAoIGhlYWRMZW5ndGggPiA2ICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCBidWZmZXIuc2xpY2UgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0LmltYWdlSGVhZCA9IGJ1ZmZlci5zbGljZSggMiwgaGVhZExlbmd0aCApO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBXb3JrYXJvdW5kIGZvciBJRTEwLCB3aGljaCBkb2VzIG5vdCB5ZXRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBzdXBwb3J0IEFycmF5QnVmZmVyLnNsaWNlOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldC5pbWFnZUhlYWQgPSBuZXcgVWludDhBcnJheSggYnVmZmVyIClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5zdWJhcnJheSggMiwgaGVhZExlbmd0aCApO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgIFxuICAgICAgICAgICAgICAgIHJldHVybiByZXQ7XG4gICAgICAgICAgICB9LFxuICAgIFxuICAgICAgICAgICAgdXBkYXRlSW1hZ2VIZWFkOiBmdW5jdGlvbiggYnVmZmVyLCBoZWFkICkge1xuICAgICAgICAgICAgICAgIHZhciBkYXRhID0gdGhpcy5fcGFyc2UoIGJ1ZmZlciwgdHJ1ZSApLFxuICAgICAgICAgICAgICAgICAgICBidWYxLCBidWYyLCBib2R5b2Zmc2V0O1xuICAgIFxuICAgIFxuICAgICAgICAgICAgICAgIGJvZHlvZmZzZXQgPSAyO1xuICAgICAgICAgICAgICAgIGlmICggZGF0YS5pbWFnZUhlYWQgKSB7XG4gICAgICAgICAgICAgICAgICAgIGJvZHlvZmZzZXQgPSAyICsgZGF0YS5pbWFnZUhlYWQuYnl0ZUxlbmd0aDtcbiAgICAgICAgICAgICAgICB9XG4gICAgXG4gICAgICAgICAgICAgICAgaWYgKCBidWZmZXIuc2xpY2UgKSB7XG4gICAgICAgICAgICAgICAgICAgIGJ1ZjIgPSBidWZmZXIuc2xpY2UoIGJvZHlvZmZzZXQgKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBidWYyID0gbmV3IFVpbnQ4QXJyYXkoIGJ1ZmZlciApLnN1YmFycmF5KCBib2R5b2Zmc2V0ICk7XG4gICAgICAgICAgICAgICAgfVxuICAgIFxuICAgICAgICAgICAgICAgIGJ1ZjEgPSBuZXcgVWludDhBcnJheSggaGVhZC5ieXRlTGVuZ3RoICsgMiArIGJ1ZjIuYnl0ZUxlbmd0aCApO1xuICAgIFxuICAgICAgICAgICAgICAgIGJ1ZjFbIDAgXSA9IDB4RkY7XG4gICAgICAgICAgICAgICAgYnVmMVsgMSBdID0gMHhEODtcbiAgICAgICAgICAgICAgICBidWYxLnNldCggbmV3IFVpbnQ4QXJyYXkoIGhlYWQgKSwgMiApO1xuICAgICAgICAgICAgICAgIGJ1ZjEuc2V0KCBuZXcgVWludDhBcnJheSggYnVmMiApLCBoZWFkLmJ5dGVMZW5ndGggKyAyICk7XG4gICAgXG4gICAgICAgICAgICAgICAgcmV0dXJuIGJ1ZjEuYnVmZmVyO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgIFxuICAgICAgICBVdGlsLnBhcnNlTWV0YSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgcmV0dXJuIGFwaS5wYXJzZS5hcHBseSggYXBpLCBhcmd1bWVudHMgKTtcbiAgICAgICAgfTtcbiAgICBcbiAgICAgICAgVXRpbC51cGRhdGVJbWFnZUhlYWQgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHJldHVybiBhcGkudXBkYXRlSW1hZ2VIZWFkLmFwcGx5KCBhcGksIGFyZ3VtZW50cyApO1xuICAgICAgICB9O1xuICAgIFxuICAgICAgICByZXR1cm4gYXBpO1xuICAgIH0pO1xuICAgIC8qKlxuICAgICAqIOS7o+eggeadpeiHquS6ju+8mmh0dHBzOi8vZ2l0aHViLmNvbS9ibHVlaW1wL0phdmFTY3JpcHQtTG9hZC1JbWFnZVxuICAgICAqIOaaguaXtumhueebruS4reWPqueUqOS6hm9yaWVudGF0aW9uLlxuICAgICAqXG4gICAgICog5Y676Zmk5LqGIEV4aWYgU3ViIElGRCBQb2ludGVyLCBHUFMgSW5mbyBJRkQgUG9pbnRlciwgRXhpZiBUaHVtYm5haWwuXG4gICAgICogQGZpbGVPdmVydmlldyBFWElG6Kej5p6QXG4gICAgICovXG4gICAgXG4gICAgLy8gU2FtcGxlXG4gICAgLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gICAgLy8gTWFrZSA6IEFwcGxlXG4gICAgLy8gTW9kZWwgOiBpUGhvbmUgNFNcbiAgICAvLyBPcmllbnRhdGlvbiA6IDFcbiAgICAvLyBYUmVzb2x1dGlvbiA6IDcyIFs3Mi8xXVxuICAgIC8vIFlSZXNvbHV0aW9uIDogNzIgWzcyLzFdXG4gICAgLy8gUmVzb2x1dGlvblVuaXQgOiAyXG4gICAgLy8gU29mdHdhcmUgOiBRdWlja1RpbWUgNy43LjFcbiAgICAvLyBEYXRlVGltZSA6IDIwMTM6MDk6MDEgMjI6NTM6NTVcbiAgICAvLyBFeGlmSUZEUG9pbnRlciA6IDE5MFxuICAgIC8vIEV4cG9zdXJlVGltZSA6IDAuMDU4ODIzNTI5NDExNzY0NzA1IFsxLzE3XVxuICAgIC8vIEZOdW1iZXIgOiAyLjQgWzEyLzVdXG4gICAgLy8gRXhwb3N1cmVQcm9ncmFtIDogTm9ybWFsIHByb2dyYW1cbiAgICAvLyBJU09TcGVlZFJhdGluZ3MgOiA4MDBcbiAgICAvLyBFeGlmVmVyc2lvbiA6IDAyMjBcbiAgICAvLyBEYXRlVGltZU9yaWdpbmFsIDogMjAxMzowOTowMSAyMjo1Mjo1MVxuICAgIC8vIERhdGVUaW1lRGlnaXRpemVkIDogMjAxMzowOTowMSAyMjo1Mjo1MVxuICAgIC8vIENvbXBvbmVudHNDb25maWd1cmF0aW9uIDogWUNiQ3JcbiAgICAvLyBTaHV0dGVyU3BlZWRWYWx1ZSA6IDQuMDU4ODkzNTE1NzY0NDI2XG4gICAgLy8gQXBlcnR1cmVWYWx1ZSA6IDIuNTI2MDY4ODIxNjg5MjU5NyBbNDg0NS8xOTE4XVxuICAgIC8vIEJyaWdodG5lc3NWYWx1ZSA6IC0wLjMxMjY2ODY2MDE5OTgzOTVcbiAgICAvLyBNZXRlcmluZ01vZGUgOiBQYXR0ZXJuXG4gICAgLy8gRmxhc2ggOiBGbGFzaCBkaWQgbm90IGZpcmUsIGNvbXB1bHNvcnkgZmxhc2ggbW9kZVxuICAgIC8vIEZvY2FsTGVuZ3RoIDogNC4yOCBbMTA3LzI1XVxuICAgIC8vIFN1YmplY3RBcmVhIDogWzQgdmFsdWVzXVxuICAgIC8vIEZsYXNocGl4VmVyc2lvbiA6IDAxMDBcbiAgICAvLyBDb2xvclNwYWNlIDogMVxuICAgIC8vIFBpeGVsWERpbWVuc2lvbiA6IDI0NDhcbiAgICAvLyBQaXhlbFlEaW1lbnNpb24gOiAzMjY0XG4gICAgLy8gU2Vuc2luZ01ldGhvZCA6IE9uZS1jaGlwIGNvbG9yIGFyZWEgc2Vuc29yXG4gICAgLy8gRXhwb3N1cmVNb2RlIDogMFxuICAgIC8vIFdoaXRlQmFsYW5jZSA6IEF1dG8gd2hpdGUgYmFsYW5jZVxuICAgIC8vIEZvY2FsTGVuZ3RoSW4zNW1tRmlsbSA6IDM1XG4gICAgLy8gU2NlbmVDYXB0dXJlVHlwZSA6IFN0YW5kYXJkXG4gICAgZGVmaW5lKCdydW50aW1lL2h0bWw1L2ltYWdlbWV0YS9leGlmJyxbXG4gICAgICAgICdiYXNlJyxcbiAgICAgICAgJ3J1bnRpbWUvaHRtbDUvaW1hZ2VtZXRhJ1xuICAgIF0sIGZ1bmN0aW9uKCBCYXNlLCBJbWFnZU1ldGEgKSB7XG4gICAgXG4gICAgICAgIHZhciBFWElGID0ge307XG4gICAgXG4gICAgICAgIEVYSUYuRXhpZk1hcCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH07XG4gICAgXG4gICAgICAgIEVYSUYuRXhpZk1hcC5wcm90b3R5cGUubWFwID0ge1xuICAgICAgICAgICAgJ09yaWVudGF0aW9uJzogMHgwMTEyXG4gICAgICAgIH07XG4gICAgXG4gICAgICAgIEVYSUYuRXhpZk1hcC5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24oIGlkICkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXNbIGlkIF0gfHwgdGhpc1sgdGhpcy5tYXBbIGlkIF0gXTtcbiAgICAgICAgfTtcbiAgICBcbiAgICAgICAgRVhJRi5leGlmVGFnVHlwZXMgPSB7XG4gICAgICAgICAgICAvLyBieXRlLCA4LWJpdCB1bnNpZ25lZCBpbnQ6XG4gICAgICAgICAgICAxOiB7XG4gICAgICAgICAgICAgICAgZ2V0VmFsdWU6IGZ1bmN0aW9uKCBkYXRhVmlldywgZGF0YU9mZnNldCApIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGRhdGFWaWV3LmdldFVpbnQ4KCBkYXRhT2Zmc2V0ICk7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBzaXplOiAxXG4gICAgICAgICAgICB9LFxuICAgIFxuICAgICAgICAgICAgLy8gYXNjaWksIDgtYml0IGJ5dGU6XG4gICAgICAgICAgICAyOiB7XG4gICAgICAgICAgICAgICAgZ2V0VmFsdWU6IGZ1bmN0aW9uKCBkYXRhVmlldywgZGF0YU9mZnNldCApIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUoIGRhdGFWaWV3LmdldFVpbnQ4KCBkYXRhT2Zmc2V0ICkgKTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHNpemU6IDEsXG4gICAgICAgICAgICAgICAgYXNjaWk6IHRydWVcbiAgICAgICAgICAgIH0sXG4gICAgXG4gICAgICAgICAgICAvLyBzaG9ydCwgMTYgYml0IGludDpcbiAgICAgICAgICAgIDM6IHtcbiAgICAgICAgICAgICAgICBnZXRWYWx1ZTogZnVuY3Rpb24oIGRhdGFWaWV3LCBkYXRhT2Zmc2V0LCBsaXR0bGVFbmRpYW4gKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBkYXRhVmlldy5nZXRVaW50MTYoIGRhdGFPZmZzZXQsIGxpdHRsZUVuZGlhbiApO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgc2l6ZTogMlxuICAgICAgICAgICAgfSxcbiAgICBcbiAgICAgICAgICAgIC8vIGxvbmcsIDMyIGJpdCBpbnQ6XG4gICAgICAgICAgICA0OiB7XG4gICAgICAgICAgICAgICAgZ2V0VmFsdWU6IGZ1bmN0aW9uKCBkYXRhVmlldywgZGF0YU9mZnNldCwgbGl0dGxlRW5kaWFuICkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZGF0YVZpZXcuZ2V0VWludDMyKCBkYXRhT2Zmc2V0LCBsaXR0bGVFbmRpYW4gKTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHNpemU6IDRcbiAgICAgICAgICAgIH0sXG4gICAgXG4gICAgICAgICAgICAvLyByYXRpb25hbCA9IHR3byBsb25nIHZhbHVlcyxcbiAgICAgICAgICAgIC8vIGZpcnN0IGlzIG51bWVyYXRvciwgc2Vjb25kIGlzIGRlbm9taW5hdG9yOlxuICAgICAgICAgICAgNToge1xuICAgICAgICAgICAgICAgIGdldFZhbHVlOiBmdW5jdGlvbiggZGF0YVZpZXcsIGRhdGFPZmZzZXQsIGxpdHRsZUVuZGlhbiApIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGRhdGFWaWV3LmdldFVpbnQzMiggZGF0YU9mZnNldCwgbGl0dGxlRW5kaWFuICkgL1xuICAgICAgICAgICAgICAgICAgICAgICAgZGF0YVZpZXcuZ2V0VWludDMyKCBkYXRhT2Zmc2V0ICsgNCwgbGl0dGxlRW5kaWFuICk7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBzaXplOiA4XG4gICAgICAgICAgICB9LFxuICAgIFxuICAgICAgICAgICAgLy8gc2xvbmcsIDMyIGJpdCBzaWduZWQgaW50OlxuICAgICAgICAgICAgOToge1xuICAgICAgICAgICAgICAgIGdldFZhbHVlOiBmdW5jdGlvbiggZGF0YVZpZXcsIGRhdGFPZmZzZXQsIGxpdHRsZUVuZGlhbiApIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGRhdGFWaWV3LmdldEludDMyKCBkYXRhT2Zmc2V0LCBsaXR0bGVFbmRpYW4gKTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHNpemU6IDRcbiAgICAgICAgICAgIH0sXG4gICAgXG4gICAgICAgICAgICAvLyBzcmF0aW9uYWwsIHR3byBzbG9uZ3MsIGZpcnN0IGlzIG51bWVyYXRvciwgc2Vjb25kIGlzIGRlbm9taW5hdG9yOlxuICAgICAgICAgICAgMTA6IHtcbiAgICAgICAgICAgICAgICBnZXRWYWx1ZTogZnVuY3Rpb24oIGRhdGFWaWV3LCBkYXRhT2Zmc2V0LCBsaXR0bGVFbmRpYW4gKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBkYXRhVmlldy5nZXRJbnQzMiggZGF0YU9mZnNldCwgbGl0dGxlRW5kaWFuICkgL1xuICAgICAgICAgICAgICAgICAgICAgICAgZGF0YVZpZXcuZ2V0SW50MzIoIGRhdGFPZmZzZXQgKyA0LCBsaXR0bGVFbmRpYW4gKTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHNpemU6IDhcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICBcbiAgICAgICAgLy8gdW5kZWZpbmVkLCA4LWJpdCBieXRlLCB2YWx1ZSBkZXBlbmRpbmcgb24gZmllbGQ6XG4gICAgICAgIEVYSUYuZXhpZlRhZ1R5cGVzWyA3IF0gPSBFWElGLmV4aWZUYWdUeXBlc1sgMSBdO1xuICAgIFxuICAgICAgICBFWElGLmdldEV4aWZWYWx1ZSA9IGZ1bmN0aW9uKCBkYXRhVmlldywgdGlmZk9mZnNldCwgb2Zmc2V0LCB0eXBlLCBsZW5ndGgsXG4gICAgICAgICAgICAgICAgbGl0dGxlRW5kaWFuICkge1xuICAgIFxuICAgICAgICAgICAgdmFyIHRhZ1R5cGUgPSBFWElGLmV4aWZUYWdUeXBlc1sgdHlwZSBdLFxuICAgICAgICAgICAgICAgIHRhZ1NpemUsIGRhdGFPZmZzZXQsIHZhbHVlcywgaSwgc3RyLCBjO1xuICAgIFxuICAgICAgICAgICAgaWYgKCAhdGFnVHlwZSApIHtcbiAgICAgICAgICAgICAgICBCYXNlLmxvZygnSW52YWxpZCBFeGlmIGRhdGE6IEludmFsaWQgdGFnIHR5cGUuJyk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgIFxuICAgICAgICAgICAgdGFnU2l6ZSA9IHRhZ1R5cGUuc2l6ZSAqIGxlbmd0aDtcbiAgICBcbiAgICAgICAgICAgIC8vIERldGVybWluZSBpZiB0aGUgdmFsdWUgaXMgY29udGFpbmVkIGluIHRoZSBkYXRhT2Zmc2V0IGJ5dGVzLFxuICAgICAgICAgICAgLy8gb3IgaWYgdGhlIHZhbHVlIGF0IHRoZSBkYXRhT2Zmc2V0IGlzIGEgcG9pbnRlciB0byB0aGUgYWN0dWFsIGRhdGE6XG4gICAgICAgICAgICBkYXRhT2Zmc2V0ID0gdGFnU2l6ZSA+IDQgPyB0aWZmT2Zmc2V0ICsgZGF0YVZpZXcuZ2V0VWludDMyKCBvZmZzZXQgKyA4LFxuICAgICAgICAgICAgICAgICAgICBsaXR0bGVFbmRpYW4gKSA6IChvZmZzZXQgKyA4KTtcbiAgICBcbiAgICAgICAgICAgIGlmICggZGF0YU9mZnNldCArIHRhZ1NpemUgPiBkYXRhVmlldy5ieXRlTGVuZ3RoICkge1xuICAgICAgICAgICAgICAgIEJhc2UubG9nKCdJbnZhbGlkIEV4aWYgZGF0YTogSW52YWxpZCBkYXRhIG9mZnNldC4nKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgXG4gICAgICAgICAgICBpZiAoIGxlbmd0aCA9PT0gMSApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGFnVHlwZS5nZXRWYWx1ZSggZGF0YVZpZXcsIGRhdGFPZmZzZXQsIGxpdHRsZUVuZGlhbiApO1xuICAgICAgICAgICAgfVxuICAgIFxuICAgICAgICAgICAgdmFsdWVzID0gW107XG4gICAgXG4gICAgICAgICAgICBmb3IgKCBpID0gMDsgaSA8IGxlbmd0aDsgaSArPSAxICkge1xuICAgICAgICAgICAgICAgIHZhbHVlc1sgaSBdID0gdGFnVHlwZS5nZXRWYWx1ZSggZGF0YVZpZXcsXG4gICAgICAgICAgICAgICAgICAgICAgICBkYXRhT2Zmc2V0ICsgaSAqIHRhZ1R5cGUuc2l6ZSwgbGl0dGxlRW5kaWFuICk7XG4gICAgICAgICAgICB9XG4gICAgXG4gICAgICAgICAgICBpZiAoIHRhZ1R5cGUuYXNjaWkgKSB7XG4gICAgICAgICAgICAgICAgc3RyID0gJyc7XG4gICAgXG4gICAgICAgICAgICAgICAgLy8gQ29uY2F0ZW5hdGUgdGhlIGNoYXJzOlxuICAgICAgICAgICAgICAgIGZvciAoIGkgPSAwOyBpIDwgdmFsdWVzLmxlbmd0aDsgaSArPSAxICkge1xuICAgICAgICAgICAgICAgICAgICBjID0gdmFsdWVzWyBpIF07XG4gICAgXG4gICAgICAgICAgICAgICAgICAgIC8vIElnbm9yZSB0aGUgdGVybWluYXRpbmcgTlVMTCBieXRlKHMpOlxuICAgICAgICAgICAgICAgICAgICBpZiAoIGMgPT09ICdcXHUwMDAwJyApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHN0ciArPSBjO1xuICAgICAgICAgICAgICAgIH1cbiAgICBcbiAgICAgICAgICAgICAgICByZXR1cm4gc3RyO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHZhbHVlcztcbiAgICAgICAgfTtcbiAgICBcbiAgICAgICAgRVhJRi5wYXJzZUV4aWZUYWcgPSBmdW5jdGlvbiggZGF0YVZpZXcsIHRpZmZPZmZzZXQsIG9mZnNldCwgbGl0dGxlRW5kaWFuLFxuICAgICAgICAgICAgICAgIGRhdGEgKSB7XG4gICAgXG4gICAgICAgICAgICB2YXIgdGFnID0gZGF0YVZpZXcuZ2V0VWludDE2KCBvZmZzZXQsIGxpdHRsZUVuZGlhbiApO1xuICAgICAgICAgICAgZGF0YS5leGlmWyB0YWcgXSA9IEVYSUYuZ2V0RXhpZlZhbHVlKCBkYXRhVmlldywgdGlmZk9mZnNldCwgb2Zmc2V0LFxuICAgICAgICAgICAgICAgICAgICBkYXRhVmlldy5nZXRVaW50MTYoIG9mZnNldCArIDIsIGxpdHRsZUVuZGlhbiApLCAgICAvLyB0YWcgdHlwZVxuICAgICAgICAgICAgICAgICAgICBkYXRhVmlldy5nZXRVaW50MzIoIG9mZnNldCArIDQsIGxpdHRsZUVuZGlhbiApLCAgICAvLyB0YWcgbGVuZ3RoXG4gICAgICAgICAgICAgICAgICAgIGxpdHRsZUVuZGlhbiApO1xuICAgICAgICB9O1xuICAgIFxuICAgICAgICBFWElGLnBhcnNlRXhpZlRhZ3MgPSBmdW5jdGlvbiggZGF0YVZpZXcsIHRpZmZPZmZzZXQsIGRpck9mZnNldCxcbiAgICAgICAgICAgICAgICBsaXR0bGVFbmRpYW4sIGRhdGEgKSB7XG4gICAgXG4gICAgICAgICAgICB2YXIgdGFnc051bWJlciwgZGlyRW5kT2Zmc2V0LCBpO1xuICAgIFxuICAgICAgICAgICAgaWYgKCBkaXJPZmZzZXQgKyA2ID4gZGF0YVZpZXcuYnl0ZUxlbmd0aCApIHtcbiAgICAgICAgICAgICAgICBCYXNlLmxvZygnSW52YWxpZCBFeGlmIGRhdGE6IEludmFsaWQgZGlyZWN0b3J5IG9mZnNldC4nKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgXG4gICAgICAgICAgICB0YWdzTnVtYmVyID0gZGF0YVZpZXcuZ2V0VWludDE2KCBkaXJPZmZzZXQsIGxpdHRsZUVuZGlhbiApO1xuICAgICAgICAgICAgZGlyRW5kT2Zmc2V0ID0gZGlyT2Zmc2V0ICsgMiArIDEyICogdGFnc051bWJlcjtcbiAgICBcbiAgICAgICAgICAgIGlmICggZGlyRW5kT2Zmc2V0ICsgNCA+IGRhdGFWaWV3LmJ5dGVMZW5ndGggKSB7XG4gICAgICAgICAgICAgICAgQmFzZS5sb2coJ0ludmFsaWQgRXhpZiBkYXRhOiBJbnZhbGlkIGRpcmVjdG9yeSBzaXplLicpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICBcbiAgICAgICAgICAgIGZvciAoIGkgPSAwOyBpIDwgdGFnc051bWJlcjsgaSArPSAxICkge1xuICAgICAgICAgICAgICAgIHRoaXMucGFyc2VFeGlmVGFnKCBkYXRhVmlldywgdGlmZk9mZnNldCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGRpck9mZnNldCArIDIgKyAxMiAqIGksICAgIC8vIHRhZyBvZmZzZXRcbiAgICAgICAgICAgICAgICAgICAgICAgIGxpdHRsZUVuZGlhbiwgZGF0YSApO1xuICAgICAgICAgICAgfVxuICAgIFxuICAgICAgICAgICAgLy8gUmV0dXJuIHRoZSBvZmZzZXQgdG8gdGhlIG5leHQgZGlyZWN0b3J5OlxuICAgICAgICAgICAgcmV0dXJuIGRhdGFWaWV3LmdldFVpbnQzMiggZGlyRW5kT2Zmc2V0LCBsaXR0bGVFbmRpYW4gKTtcbiAgICAgICAgfTtcbiAgICBcbiAgICAgICAgLy8gRVhJRi5nZXRFeGlmVGh1bWJuYWlsID0gZnVuY3Rpb24oZGF0YVZpZXcsIG9mZnNldCwgbGVuZ3RoKSB7XG4gICAgICAgIC8vICAgICB2YXIgaGV4RGF0YSxcbiAgICAgICAgLy8gICAgICAgICBpLFxuICAgICAgICAvLyAgICAgICAgIGI7XG4gICAgICAgIC8vICAgICBpZiAoIWxlbmd0aCB8fCBvZmZzZXQgKyBsZW5ndGggPiBkYXRhVmlldy5ieXRlTGVuZ3RoKSB7XG4gICAgICAgIC8vICAgICAgICAgQmFzZS5sb2coJ0ludmFsaWQgRXhpZiBkYXRhOiBJbnZhbGlkIHRodW1ibmFpbCBkYXRhLicpO1xuICAgICAgICAvLyAgICAgICAgIHJldHVybjtcbiAgICAgICAgLy8gICAgIH1cbiAgICAgICAgLy8gICAgIGhleERhdGEgPSBbXTtcbiAgICAgICAgLy8gICAgIGZvciAoaSA9IDA7IGkgPCBsZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICAvLyAgICAgICAgIGIgPSBkYXRhVmlldy5nZXRVaW50OChvZmZzZXQgKyBpKTtcbiAgICAgICAgLy8gICAgICAgICBoZXhEYXRhLnB1c2goKGIgPCAxNiA/ICcwJyA6ICcnKSArIGIudG9TdHJpbmcoMTYpKTtcbiAgICAgICAgLy8gICAgIH1cbiAgICAgICAgLy8gICAgIHJldHVybiAnZGF0YTppbWFnZS9qcGVnLCUnICsgaGV4RGF0YS5qb2luKCclJyk7XG4gICAgICAgIC8vIH07XG4gICAgXG4gICAgICAgIEVYSUYucGFyc2VFeGlmRGF0YSA9IGZ1bmN0aW9uKCBkYXRhVmlldywgb2Zmc2V0LCBsZW5ndGgsIGRhdGEgKSB7XG4gICAgXG4gICAgICAgICAgICB2YXIgdGlmZk9mZnNldCA9IG9mZnNldCArIDEwLFxuICAgICAgICAgICAgICAgIGxpdHRsZUVuZGlhbiwgZGlyT2Zmc2V0O1xuICAgIFxuICAgICAgICAgICAgLy8gQ2hlY2sgZm9yIHRoZSBBU0NJSSBjb2RlIGZvciBcIkV4aWZcIiAoMHg0NTc4Njk2Nik6XG4gICAgICAgICAgICBpZiAoIGRhdGFWaWV3LmdldFVpbnQzMiggb2Zmc2V0ICsgNCApICE9PSAweDQ1Nzg2OTY2ICkge1xuICAgICAgICAgICAgICAgIC8vIE5vIEV4aWYgZGF0YSwgbWlnaHQgYmUgWE1QIGRhdGEgaW5zdGVhZFxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICggdGlmZk9mZnNldCArIDggPiBkYXRhVmlldy5ieXRlTGVuZ3RoICkge1xuICAgICAgICAgICAgICAgIEJhc2UubG9nKCdJbnZhbGlkIEV4aWYgZGF0YTogSW52YWxpZCBzZWdtZW50IHNpemUuJyk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgIFxuICAgICAgICAgICAgLy8gQ2hlY2sgZm9yIHRoZSB0d28gbnVsbCBieXRlczpcbiAgICAgICAgICAgIGlmICggZGF0YVZpZXcuZ2V0VWludDE2KCBvZmZzZXQgKyA4ICkgIT09IDB4MDAwMCApIHtcbiAgICAgICAgICAgICAgICBCYXNlLmxvZygnSW52YWxpZCBFeGlmIGRhdGE6IE1pc3NpbmcgYnl0ZSBhbGlnbm1lbnQgb2Zmc2V0LicpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICBcbiAgICAgICAgICAgIC8vIENoZWNrIHRoZSBieXRlIGFsaWdubWVudDpcbiAgICAgICAgICAgIHN3aXRjaCAoIGRhdGFWaWV3LmdldFVpbnQxNiggdGlmZk9mZnNldCApICkge1xuICAgICAgICAgICAgICAgIGNhc2UgMHg0OTQ5OlxuICAgICAgICAgICAgICAgICAgICBsaXR0bGVFbmRpYW4gPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICBcbiAgICAgICAgICAgICAgICBjYXNlIDB4NEQ0RDpcbiAgICAgICAgICAgICAgICAgICAgbGl0dGxlRW5kaWFuID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgIFxuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIEJhc2UubG9nKCdJbnZhbGlkIEV4aWYgZGF0YTogSW52YWxpZCBieXRlIGFsaWdubWVudCBtYXJrZXIuJyk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICBcbiAgICAgICAgICAgIC8vIENoZWNrIGZvciB0aGUgVElGRiB0YWcgbWFya2VyICgweDAwMkEpOlxuICAgICAgICAgICAgaWYgKCBkYXRhVmlldy5nZXRVaW50MTYoIHRpZmZPZmZzZXQgKyAyLCBsaXR0bGVFbmRpYW4gKSAhPT0gMHgwMDJBICkge1xuICAgICAgICAgICAgICAgIEJhc2UubG9nKCdJbnZhbGlkIEV4aWYgZGF0YTogTWlzc2luZyBUSUZGIG1hcmtlci4nKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgXG4gICAgICAgICAgICAvLyBSZXRyaWV2ZSB0aGUgZGlyZWN0b3J5IG9mZnNldCBieXRlcywgdXN1YWxseSAweDAwMDAwMDA4IG9yIDggZGVjaW1hbDpcbiAgICAgICAgICAgIGRpck9mZnNldCA9IGRhdGFWaWV3LmdldFVpbnQzMiggdGlmZk9mZnNldCArIDQsIGxpdHRsZUVuZGlhbiApO1xuICAgICAgICAgICAgLy8gQ3JlYXRlIHRoZSBleGlmIG9iamVjdCB0byBzdG9yZSB0aGUgdGFnczpcbiAgICAgICAgICAgIGRhdGEuZXhpZiA9IG5ldyBFWElGLkV4aWZNYXAoKTtcbiAgICAgICAgICAgIC8vIFBhcnNlIHRoZSB0YWdzIG9mIHRoZSBtYWluIGltYWdlIGRpcmVjdG9yeSBhbmQgcmV0cmlldmUgdGhlXG4gICAgICAgICAgICAvLyBvZmZzZXQgdG8gdGhlIG5leHQgZGlyZWN0b3J5LCB1c3VhbGx5IHRoZSB0aHVtYm5haWwgZGlyZWN0b3J5OlxuICAgICAgICAgICAgZGlyT2Zmc2V0ID0gRVhJRi5wYXJzZUV4aWZUYWdzKCBkYXRhVmlldywgdGlmZk9mZnNldCxcbiAgICAgICAgICAgICAgICAgICAgdGlmZk9mZnNldCArIGRpck9mZnNldCwgbGl0dGxlRW5kaWFuLCBkYXRhICk7XG4gICAgXG4gICAgICAgICAgICAvLyDlsJ3or5Xor7vlj5bnvKnnlaXlm75cbiAgICAgICAgICAgIC8vIGlmICggZGlyT2Zmc2V0ICkge1xuICAgICAgICAgICAgLy8gICAgIHRodW1ibmFpbERhdGEgPSB7ZXhpZjoge319O1xuICAgICAgICAgICAgLy8gICAgIGRpck9mZnNldCA9IEVYSUYucGFyc2VFeGlmVGFncyhcbiAgICAgICAgICAgIC8vICAgICAgICAgZGF0YVZpZXcsXG4gICAgICAgICAgICAvLyAgICAgICAgIHRpZmZPZmZzZXQsXG4gICAgICAgICAgICAvLyAgICAgICAgIHRpZmZPZmZzZXQgKyBkaXJPZmZzZXQsXG4gICAgICAgICAgICAvLyAgICAgICAgIGxpdHRsZUVuZGlhbixcbiAgICAgICAgICAgIC8vICAgICAgICAgdGh1bWJuYWlsRGF0YVxuICAgICAgICAgICAgLy8gICAgICk7XG4gICAgXG4gICAgICAgICAgICAvLyAgICAgLy8gQ2hlY2sgZm9yIEpQRUcgVGh1bWJuYWlsIG9mZnNldDpcbiAgICAgICAgICAgIC8vICAgICBpZiAodGh1bWJuYWlsRGF0YS5leGlmWzB4MDIwMV0pIHtcbiAgICAgICAgICAgIC8vICAgICAgICAgZGF0YS5leGlmLlRodW1ibmFpbCA9IEVYSUYuZ2V0RXhpZlRodW1ibmFpbChcbiAgICAgICAgICAgIC8vICAgICAgICAgICAgIGRhdGFWaWV3LFxuICAgICAgICAgICAgLy8gICAgICAgICAgICAgdGlmZk9mZnNldCArIHRodW1ibmFpbERhdGEuZXhpZlsweDAyMDFdLFxuICAgICAgICAgICAgLy8gICAgICAgICAgICAgdGh1bWJuYWlsRGF0YS5leGlmWzB4MDIwMl0gLy8gVGh1bWJuYWlsIGRhdGEgbGVuZ3RoXG4gICAgICAgICAgICAvLyAgICAgICAgICk7XG4gICAgICAgICAgICAvLyAgICAgfVxuICAgICAgICAgICAgLy8gfVxuICAgICAgICB9O1xuICAgIFxuICAgICAgICBJbWFnZU1ldGEucGFyc2Vyc1sgMHhmZmUxIF0ucHVzaCggRVhJRi5wYXJzZUV4aWZEYXRhICk7XG4gICAgICAgIHJldHVybiBFWElGO1xuICAgIH0pO1xuICAgIC8qKlxuICAgICAqIOi/meS4quaWueW8j+aAp+iDveS4jeihjO+8jOS9huaYr+WPr+S7peino+WGs2FuZHJvaWTph4zpnaLnmoR0b0RhdGFVcmznmoRidWdcbiAgICAgKiBhbmRyb2lk6YeM6Z2idG9EYXRhVXJsKCdpbWFnZS9qcGVnZScp5b6X5Yiw55qE57uT5p6c5Y205pivcG5nLlxuICAgICAqXG4gICAgICog5omA5Lul6L+Z6YeM5rKh6L6Z77yM5Y+q6IO95YCf5Yqp6L+Z5Liq5bel5YW3XG4gICAgICogQGZpbGVPdmVydmlldyBqcGVnIGVuY29kZXJcbiAgICAgKi9cbiAgICBkZWZpbmUoJ3J1bnRpbWUvaHRtbDUvanBlZ2VuY29kZXInLFtdLCBmdW5jdGlvbiggcmVxdWlyZSwgZXhwb3J0cywgbW9kdWxlICkge1xuICAgIFxuICAgICAgICAvKlxuICAgICAgICAgIENvcHlyaWdodCAoYykgMjAwOCwgQWRvYmUgU3lzdGVtcyBJbmNvcnBvcmF0ZWRcbiAgICAgICAgICBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICAgIFxuICAgICAgICAgIFJlZGlzdHJpYnV0aW9uIGFuZCB1c2UgaW4gc291cmNlIGFuZCBiaW5hcnkgZm9ybXMsIHdpdGggb3Igd2l0aG91dFxuICAgICAgICAgIG1vZGlmaWNhdGlvbiwgYXJlIHBlcm1pdHRlZCBwcm92aWRlZCB0aGF0IHRoZSBmb2xsb3dpbmcgY29uZGl0aW9ucyBhcmVcbiAgICAgICAgICBtZXQ6XG4gICAgXG4gICAgICAgICAgKiBSZWRpc3RyaWJ1dGlvbnMgb2Ygc291cmNlIGNvZGUgbXVzdCByZXRhaW4gdGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UsXG4gICAgICAgICAgICB0aGlzIGxpc3Qgb2YgY29uZGl0aW9ucyBhbmQgdGhlIGZvbGxvd2luZyBkaXNjbGFpbWVyLlxuICAgIFxuICAgICAgICAgICogUmVkaXN0cmlidXRpb25zIGluIGJpbmFyeSBmb3JtIG11c3QgcmVwcm9kdWNlIHRoZSBhYm92ZSBjb3B5cmlnaHRcbiAgICAgICAgICAgIG5vdGljZSwgdGhpcyBsaXN0IG9mIGNvbmRpdGlvbnMgYW5kIHRoZSBmb2xsb3dpbmcgZGlzY2xhaW1lciBpbiB0aGVcbiAgICAgICAgICAgIGRvY3VtZW50YXRpb24gYW5kL29yIG90aGVyIG1hdGVyaWFscyBwcm92aWRlZCB3aXRoIHRoZSBkaXN0cmlidXRpb24uXG4gICAgXG4gICAgICAgICAgKiBOZWl0aGVyIHRoZSBuYW1lIG9mIEFkb2JlIFN5c3RlbXMgSW5jb3Jwb3JhdGVkIG5vciB0aGUgbmFtZXMgb2YgaXRzXG4gICAgICAgICAgICBjb250cmlidXRvcnMgbWF5IGJlIHVzZWQgdG8gZW5kb3JzZSBvciBwcm9tb3RlIHByb2R1Y3RzIGRlcml2ZWQgZnJvbVxuICAgICAgICAgICAgdGhpcyBzb2Z0d2FyZSB3aXRob3V0IHNwZWNpZmljIHByaW9yIHdyaXR0ZW4gcGVybWlzc2lvbi5cbiAgICBcbiAgICAgICAgICBUSElTIFNPRlRXQVJFIElTIFBST1ZJREVEIEJZIFRIRSBDT1BZUklHSFQgSE9MREVSUyBBTkQgQ09OVFJJQlVUT1JTIFwiQVNcbiAgICAgICAgICBJU1wiIEFORCBBTlkgRVhQUkVTUyBPUiBJTVBMSUVEIFdBUlJBTlRJRVMsIElOQ0xVRElORywgQlVUIE5PVCBMSU1JVEVEIFRPLFxuICAgICAgICAgIFRIRSBJTVBMSUVEIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZIEFORCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVJcbiAgICAgICAgICBQVVJQT1NFIEFSRSBESVNDTEFJTUVELiBJTiBOTyBFVkVOVCBTSEFMTCBUSEUgQ09QWVJJR0hUIE9XTkVSIE9SXG4gICAgICAgICAgQ09OVFJJQlVUT1JTIEJFIExJQUJMRSBGT1IgQU5ZIERJUkVDVCwgSU5ESVJFQ1QsIElOQ0lERU5UQUwsIFNQRUNJQUwsXG4gICAgICAgICAgRVhFTVBMQVJZLCBPUiBDT05TRVFVRU5USUFMIERBTUFHRVMgKElOQ0xVRElORywgQlVUIE5PVCBMSU1JVEVEIFRPLFxuICAgICAgICAgIFBST0NVUkVNRU5UIE9GIFNVQlNUSVRVVEUgR09PRFMgT1IgU0VSVklDRVM7IExPU1MgT0YgVVNFLCBEQVRBLCBPUlxuICAgICAgICAgIFBST0ZJVFM7IE9SIEJVU0lORVNTIElOVEVSUlVQVElPTikgSE9XRVZFUiBDQVVTRUQgQU5EIE9OIEFOWSBUSEVPUlkgT0ZcbiAgICAgICAgICBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQ09OVFJBQ1QsIFNUUklDVCBMSUFCSUxJVFksIE9SIFRPUlQgKElOQ0xVRElOR1xuICAgICAgICAgIE5FR0xJR0VOQ0UgT1IgT1RIRVJXSVNFKSBBUklTSU5HIElOIEFOWSBXQVkgT1VUIE9GIFRIRSBVU0UgT0YgVEhJU1xuICAgICAgICAgIFNPRlRXQVJFLCBFVkVOIElGIEFEVklTRUQgT0YgVEhFIFBPU1NJQklMSVRZIE9GIFNVQ0ggREFNQUdFLlxuICAgICAgICAqL1xuICAgICAgICAvKlxuICAgICAgICBKUEVHIGVuY29kZXIgcG9ydGVkIHRvIEphdmFTY3JpcHQgYW5kIG9wdGltaXplZCBieSBBbmRyZWFzIFJpdHRlciwgd3d3LmJ5dGVzdHJvbS5ldSwgMTEvMjAwOVxuICAgIFxuICAgICAgICBCYXNpYyBHVUkgYmxvY2tpbmcganBlZyBlbmNvZGVyXG4gICAgICAgICovXG4gICAgXG4gICAgICAgIGZ1bmN0aW9uIEpQRUdFbmNvZGVyKHF1YWxpdHkpIHtcbiAgICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICAgICAgICB2YXIgZnJvdW5kID0gTWF0aC5yb3VuZDtcbiAgICAgICAgICAgIHZhciBmZmxvb3IgPSBNYXRoLmZsb29yO1xuICAgICAgICAgICAgdmFyIFlUYWJsZSA9IG5ldyBBcnJheSg2NCk7XG4gICAgICAgICAgICB2YXIgVVZUYWJsZSA9IG5ldyBBcnJheSg2NCk7XG4gICAgICAgICAgICB2YXIgZmR0YmxfWSA9IG5ldyBBcnJheSg2NCk7XG4gICAgICAgICAgICB2YXIgZmR0YmxfVVYgPSBuZXcgQXJyYXkoNjQpO1xuICAgICAgICAgICAgdmFyIFlEQ19IVDtcbiAgICAgICAgICAgIHZhciBVVkRDX0hUO1xuICAgICAgICAgICAgdmFyIFlBQ19IVDtcbiAgICAgICAgICAgIHZhciBVVkFDX0hUO1xuICAgIFxuICAgICAgICAgICAgdmFyIGJpdGNvZGUgPSBuZXcgQXJyYXkoNjU1MzUpO1xuICAgICAgICAgICAgdmFyIGNhdGVnb3J5ID0gbmV3IEFycmF5KDY1NTM1KTtcbiAgICAgICAgICAgIHZhciBvdXRwdXRmRENUUXVhbnQgPSBuZXcgQXJyYXkoNjQpO1xuICAgICAgICAgICAgdmFyIERVID0gbmV3IEFycmF5KDY0KTtcbiAgICAgICAgICAgIHZhciBieXRlb3V0ID0gW107XG4gICAgICAgICAgICB2YXIgYnl0ZW5ldyA9IDA7XG4gICAgICAgICAgICB2YXIgYnl0ZXBvcyA9IDc7XG4gICAgXG4gICAgICAgICAgICB2YXIgWURVID0gbmV3IEFycmF5KDY0KTtcbiAgICAgICAgICAgIHZhciBVRFUgPSBuZXcgQXJyYXkoNjQpO1xuICAgICAgICAgICAgdmFyIFZEVSA9IG5ldyBBcnJheSg2NCk7XG4gICAgICAgICAgICB2YXIgY2x0ID0gbmV3IEFycmF5KDI1Nik7XG4gICAgICAgICAgICB2YXIgUkdCX1lVVl9UQUJMRSA9IG5ldyBBcnJheSgyMDQ4KTtcbiAgICAgICAgICAgIHZhciBjdXJyZW50UXVhbGl0eTtcbiAgICBcbiAgICAgICAgICAgIHZhciBaaWdaYWcgPSBbXG4gICAgICAgICAgICAgICAgICAgICAwLCAxLCA1LCA2LDE0LDE1LDI3LDI4LFxuICAgICAgICAgICAgICAgICAgICAgMiwgNCwgNywxMywxNiwyNiwyOSw0MixcbiAgICAgICAgICAgICAgICAgICAgIDMsIDgsMTIsMTcsMjUsMzAsNDEsNDMsXG4gICAgICAgICAgICAgICAgICAgICA5LDExLDE4LDI0LDMxLDQwLDQ0LDUzLFxuICAgICAgICAgICAgICAgICAgICAxMCwxOSwyMywzMiwzOSw0NSw1Miw1NCxcbiAgICAgICAgICAgICAgICAgICAgMjAsMjIsMzMsMzgsNDYsNTEsNTUsNjAsXG4gICAgICAgICAgICAgICAgICAgIDIxLDM0LDM3LDQ3LDUwLDU2LDU5LDYxLFxuICAgICAgICAgICAgICAgICAgICAzNSwzNiw0OCw0OSw1Nyw1OCw2Miw2M1xuICAgICAgICAgICAgICAgIF07XG4gICAgXG4gICAgICAgICAgICB2YXIgc3RkX2RjX2x1bWluYW5jZV9ucmNvZGVzID0gWzAsMCwxLDUsMSwxLDEsMSwxLDEsMCwwLDAsMCwwLDAsMF07XG4gICAgICAgICAgICB2YXIgc3RkX2RjX2x1bWluYW5jZV92YWx1ZXMgPSBbMCwxLDIsMyw0LDUsNiw3LDgsOSwxMCwxMV07XG4gICAgICAgICAgICB2YXIgc3RkX2FjX2x1bWluYW5jZV9ucmNvZGVzID0gWzAsMCwyLDEsMywzLDIsNCwzLDUsNSw0LDQsMCwwLDEsMHg3ZF07XG4gICAgICAgICAgICB2YXIgc3RkX2FjX2x1bWluYW5jZV92YWx1ZXMgPSBbXG4gICAgICAgICAgICAgICAgICAgIDB4MDEsMHgwMiwweDAzLDB4MDAsMHgwNCwweDExLDB4MDUsMHgxMixcbiAgICAgICAgICAgICAgICAgICAgMHgyMSwweDMxLDB4NDEsMHgwNiwweDEzLDB4NTEsMHg2MSwweDA3LFxuICAgICAgICAgICAgICAgICAgICAweDIyLDB4NzEsMHgxNCwweDMyLDB4ODEsMHg5MSwweGExLDB4MDgsXG4gICAgICAgICAgICAgICAgICAgIDB4MjMsMHg0MiwweGIxLDB4YzEsMHgxNSwweDUyLDB4ZDEsMHhmMCxcbiAgICAgICAgICAgICAgICAgICAgMHgyNCwweDMzLDB4NjIsMHg3MiwweDgyLDB4MDksMHgwYSwweDE2LFxuICAgICAgICAgICAgICAgICAgICAweDE3LDB4MTgsMHgxOSwweDFhLDB4MjUsMHgyNiwweDI3LDB4MjgsXG4gICAgICAgICAgICAgICAgICAgIDB4MjksMHgyYSwweDM0LDB4MzUsMHgzNiwweDM3LDB4MzgsMHgzOSxcbiAgICAgICAgICAgICAgICAgICAgMHgzYSwweDQzLDB4NDQsMHg0NSwweDQ2LDB4NDcsMHg0OCwweDQ5LFxuICAgICAgICAgICAgICAgICAgICAweDRhLDB4NTMsMHg1NCwweDU1LDB4NTYsMHg1NywweDU4LDB4NTksXG4gICAgICAgICAgICAgICAgICAgIDB4NWEsMHg2MywweDY0LDB4NjUsMHg2NiwweDY3LDB4NjgsMHg2OSxcbiAgICAgICAgICAgICAgICAgICAgMHg2YSwweDczLDB4NzQsMHg3NSwweDc2LDB4NzcsMHg3OCwweDc5LFxuICAgICAgICAgICAgICAgICAgICAweDdhLDB4ODMsMHg4NCwweDg1LDB4ODYsMHg4NywweDg4LDB4ODksXG4gICAgICAgICAgICAgICAgICAgIDB4OGEsMHg5MiwweDkzLDB4OTQsMHg5NSwweDk2LDB4OTcsMHg5OCxcbiAgICAgICAgICAgICAgICAgICAgMHg5OSwweDlhLDB4YTIsMHhhMywweGE0LDB4YTUsMHhhNiwweGE3LFxuICAgICAgICAgICAgICAgICAgICAweGE4LDB4YTksMHhhYSwweGIyLDB4YjMsMHhiNCwweGI1LDB4YjYsXG4gICAgICAgICAgICAgICAgICAgIDB4YjcsMHhiOCwweGI5LDB4YmEsMHhjMiwweGMzLDB4YzQsMHhjNSxcbiAgICAgICAgICAgICAgICAgICAgMHhjNiwweGM3LDB4YzgsMHhjOSwweGNhLDB4ZDIsMHhkMywweGQ0LFxuICAgICAgICAgICAgICAgICAgICAweGQ1LDB4ZDYsMHhkNywweGQ4LDB4ZDksMHhkYSwweGUxLDB4ZTIsXG4gICAgICAgICAgICAgICAgICAgIDB4ZTMsMHhlNCwweGU1LDB4ZTYsMHhlNywweGU4LDB4ZTksMHhlYSxcbiAgICAgICAgICAgICAgICAgICAgMHhmMSwweGYyLDB4ZjMsMHhmNCwweGY1LDB4ZjYsMHhmNywweGY4LFxuICAgICAgICAgICAgICAgICAgICAweGY5LDB4ZmFcbiAgICAgICAgICAgICAgICBdO1xuICAgIFxuICAgICAgICAgICAgdmFyIHN0ZF9kY19jaHJvbWluYW5jZV9ucmNvZGVzID0gWzAsMCwzLDEsMSwxLDEsMSwxLDEsMSwxLDAsMCwwLDAsMF07XG4gICAgICAgICAgICB2YXIgc3RkX2RjX2Nocm9taW5hbmNlX3ZhbHVlcyA9IFswLDEsMiwzLDQsNSw2LDcsOCw5LDEwLDExXTtcbiAgICAgICAgICAgIHZhciBzdGRfYWNfY2hyb21pbmFuY2VfbnJjb2RlcyA9IFswLDAsMiwxLDIsNCw0LDMsNCw3LDUsNCw0LDAsMSwyLDB4NzddO1xuICAgICAgICAgICAgdmFyIHN0ZF9hY19jaHJvbWluYW5jZV92YWx1ZXMgPSBbXG4gICAgICAgICAgICAgICAgICAgIDB4MDAsMHgwMSwweDAyLDB4MDMsMHgxMSwweDA0LDB4MDUsMHgyMSxcbiAgICAgICAgICAgICAgICAgICAgMHgzMSwweDA2LDB4MTIsMHg0MSwweDUxLDB4MDcsMHg2MSwweDcxLFxuICAgICAgICAgICAgICAgICAgICAweDEzLDB4MjIsMHgzMiwweDgxLDB4MDgsMHgxNCwweDQyLDB4OTEsXG4gICAgICAgICAgICAgICAgICAgIDB4YTEsMHhiMSwweGMxLDB4MDksMHgyMywweDMzLDB4NTIsMHhmMCxcbiAgICAgICAgICAgICAgICAgICAgMHgxNSwweDYyLDB4NzIsMHhkMSwweDBhLDB4MTYsMHgyNCwweDM0LFxuICAgICAgICAgICAgICAgICAgICAweGUxLDB4MjUsMHhmMSwweDE3LDB4MTgsMHgxOSwweDFhLDB4MjYsXG4gICAgICAgICAgICAgICAgICAgIDB4MjcsMHgyOCwweDI5LDB4MmEsMHgzNSwweDM2LDB4MzcsMHgzOCxcbiAgICAgICAgICAgICAgICAgICAgMHgzOSwweDNhLDB4NDMsMHg0NCwweDQ1LDB4NDYsMHg0NywweDQ4LFxuICAgICAgICAgICAgICAgICAgICAweDQ5LDB4NGEsMHg1MywweDU0LDB4NTUsMHg1NiwweDU3LDB4NTgsXG4gICAgICAgICAgICAgICAgICAgIDB4NTksMHg1YSwweDYzLDB4NjQsMHg2NSwweDY2LDB4NjcsMHg2OCxcbiAgICAgICAgICAgICAgICAgICAgMHg2OSwweDZhLDB4NzMsMHg3NCwweDc1LDB4NzYsMHg3NywweDc4LFxuICAgICAgICAgICAgICAgICAgICAweDc5LDB4N2EsMHg4MiwweDgzLDB4ODQsMHg4NSwweDg2LDB4ODcsXG4gICAgICAgICAgICAgICAgICAgIDB4ODgsMHg4OSwweDhhLDB4OTIsMHg5MywweDk0LDB4OTUsMHg5NixcbiAgICAgICAgICAgICAgICAgICAgMHg5NywweDk4LDB4OTksMHg5YSwweGEyLDB4YTMsMHhhNCwweGE1LFxuICAgICAgICAgICAgICAgICAgICAweGE2LDB4YTcsMHhhOCwweGE5LDB4YWEsMHhiMiwweGIzLDB4YjQsXG4gICAgICAgICAgICAgICAgICAgIDB4YjUsMHhiNiwweGI3LDB4YjgsMHhiOSwweGJhLDB4YzIsMHhjMyxcbiAgICAgICAgICAgICAgICAgICAgMHhjNCwweGM1LDB4YzYsMHhjNywweGM4LDB4YzksMHhjYSwweGQyLFxuICAgICAgICAgICAgICAgICAgICAweGQzLDB4ZDQsMHhkNSwweGQ2LDB4ZDcsMHhkOCwweGQ5LDB4ZGEsXG4gICAgICAgICAgICAgICAgICAgIDB4ZTIsMHhlMywweGU0LDB4ZTUsMHhlNiwweGU3LDB4ZTgsMHhlOSxcbiAgICAgICAgICAgICAgICAgICAgMHhlYSwweGYyLDB4ZjMsMHhmNCwweGY1LDB4ZjYsMHhmNywweGY4LFxuICAgICAgICAgICAgICAgICAgICAweGY5LDB4ZmFcbiAgICAgICAgICAgICAgICBdO1xuICAgIFxuICAgICAgICAgICAgZnVuY3Rpb24gaW5pdFF1YW50VGFibGVzKHNmKXtcbiAgICAgICAgICAgICAgICAgICAgdmFyIFlRVCA9IFtcbiAgICAgICAgICAgICAgICAgICAgICAgIDE2LCAxMSwgMTAsIDE2LCAyNCwgNDAsIDUxLCA2MSxcbiAgICAgICAgICAgICAgICAgICAgICAgIDEyLCAxMiwgMTQsIDE5LCAyNiwgNTgsIDYwLCA1NSxcbiAgICAgICAgICAgICAgICAgICAgICAgIDE0LCAxMywgMTYsIDI0LCA0MCwgNTcsIDY5LCA1NixcbiAgICAgICAgICAgICAgICAgICAgICAgIDE0LCAxNywgMjIsIDI5LCA1MSwgODcsIDgwLCA2MixcbiAgICAgICAgICAgICAgICAgICAgICAgIDE4LCAyMiwgMzcsIDU2LCA2OCwxMDksMTAzLCA3NyxcbiAgICAgICAgICAgICAgICAgICAgICAgIDI0LCAzNSwgNTUsIDY0LCA4MSwxMDQsMTEzLCA5MixcbiAgICAgICAgICAgICAgICAgICAgICAgIDQ5LCA2NCwgNzgsIDg3LDEwMywxMjEsMTIwLDEwMSxcbiAgICAgICAgICAgICAgICAgICAgICAgIDcyLCA5MiwgOTUsIDk4LDExMiwxMDAsMTAzLCA5OVxuICAgICAgICAgICAgICAgICAgICBdO1xuICAgIFxuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IDY0OyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciB0ID0gZmZsb29yKChZUVRbaV0qc2YrNTApLzEwMCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodCA8IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0ID0gMTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAodCA+IDI1NSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHQgPSAyNTU7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBZVGFibGVbWmlnWmFnW2ldXSA9IHQ7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdmFyIFVWUVQgPSBbXG4gICAgICAgICAgICAgICAgICAgICAgICAxNywgMTgsIDI0LCA0NywgOTksIDk5LCA5OSwgOTksXG4gICAgICAgICAgICAgICAgICAgICAgICAxOCwgMjEsIDI2LCA2NiwgOTksIDk5LCA5OSwgOTksXG4gICAgICAgICAgICAgICAgICAgICAgICAyNCwgMjYsIDU2LCA5OSwgOTksIDk5LCA5OSwgOTksXG4gICAgICAgICAgICAgICAgICAgICAgICA0NywgNjYsIDk5LCA5OSwgOTksIDk5LCA5OSwgOTksXG4gICAgICAgICAgICAgICAgICAgICAgICA5OSwgOTksIDk5LCA5OSwgOTksIDk5LCA5OSwgOTksXG4gICAgICAgICAgICAgICAgICAgICAgICA5OSwgOTksIDk5LCA5OSwgOTksIDk5LCA5OSwgOTksXG4gICAgICAgICAgICAgICAgICAgICAgICA5OSwgOTksIDk5LCA5OSwgOTksIDk5LCA5OSwgOTksXG4gICAgICAgICAgICAgICAgICAgICAgICA5OSwgOTksIDk5LCA5OSwgOTksIDk5LCA5OSwgOTlcbiAgICAgICAgICAgICAgICAgICAgXTtcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCA2NDsgaisrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgdSA9IGZmbG9vcigoVVZRVFtqXSpzZis1MCkvMTAwKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh1IDwgMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHUgPSAxO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmICh1ID4gMjU1KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdSA9IDI1NTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIFVWVGFibGVbWmlnWmFnW2pdXSA9IHU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdmFyIGFhc2YgPSBbXG4gICAgICAgICAgICAgICAgICAgICAgICAxLjAsIDEuMzg3MDM5ODQ1LCAxLjMwNjU2Mjk2NSwgMS4xNzU4NzU2MDIsXG4gICAgICAgICAgICAgICAgICAgICAgICAxLjAsIDAuNzg1Njk0OTU4LCAwLjU0MTE5NjEwMCwgMC4yNzU4OTkzNzlcbiAgICAgICAgICAgICAgICAgICAgXTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGsgPSAwO1xuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciByb3cgPSAwOyByb3cgPCA4OyByb3crKylcbiAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgY29sID0gMDsgY29sIDwgODsgY29sKyspXG4gICAgICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZmR0YmxfWVtrXSAgPSAoMS4wIC8gKFlUYWJsZSBbWmlnWmFnW2tdXSAqIGFhc2Zbcm93XSAqIGFhc2ZbY29sXSAqIDguMCkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZkdGJsX1VWW2tdID0gKDEuMCAvIChVVlRhYmxlW1ppZ1phZ1trXV0gKiBhYXNmW3Jvd10gKiBhYXNmW2NvbF0gKiA4LjApKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBrKys7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgXG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gY29tcHV0ZUh1ZmZtYW5UYmwobnJjb2Rlcywgc3RkX3RhYmxlKXtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGNvZGV2YWx1ZSA9IDA7XG4gICAgICAgICAgICAgICAgICAgIHZhciBwb3NfaW5fdGFibGUgPSAwO1xuICAgICAgICAgICAgICAgICAgICB2YXIgSFQgPSBuZXcgQXJyYXkoKTtcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgayA9IDE7IGsgPD0gMTY7IGsrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaiA9IDE7IGogPD0gbnJjb2Rlc1trXTsgaisrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgSFRbc3RkX3RhYmxlW3Bvc19pbl90YWJsZV1dID0gW107XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgSFRbc3RkX3RhYmxlW3Bvc19pbl90YWJsZV1dWzBdID0gY29kZXZhbHVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIEhUW3N0ZF90YWJsZVtwb3NfaW5fdGFibGVdXVsxXSA9IGs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcG9zX2luX3RhYmxlKys7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29kZXZhbHVlKys7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBjb2RldmFsdWUqPTI7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIEhUO1xuICAgICAgICAgICAgICAgIH1cbiAgICBcbiAgICAgICAgICAgICAgICBmdW5jdGlvbiBpbml0SHVmZm1hblRibCgpXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBZRENfSFQgPSBjb21wdXRlSHVmZm1hblRibChzdGRfZGNfbHVtaW5hbmNlX25yY29kZXMsc3RkX2RjX2x1bWluYW5jZV92YWx1ZXMpO1xuICAgICAgICAgICAgICAgICAgICBVVkRDX0hUID0gY29tcHV0ZUh1ZmZtYW5UYmwoc3RkX2RjX2Nocm9taW5hbmNlX25yY29kZXMsc3RkX2RjX2Nocm9taW5hbmNlX3ZhbHVlcyk7XG4gICAgICAgICAgICAgICAgICAgIFlBQ19IVCA9IGNvbXB1dGVIdWZmbWFuVGJsKHN0ZF9hY19sdW1pbmFuY2VfbnJjb2RlcyxzdGRfYWNfbHVtaW5hbmNlX3ZhbHVlcyk7XG4gICAgICAgICAgICAgICAgICAgIFVWQUNfSFQgPSBjb21wdXRlSHVmZm1hblRibChzdGRfYWNfY2hyb21pbmFuY2VfbnJjb2RlcyxzdGRfYWNfY2hyb21pbmFuY2VfdmFsdWVzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgXG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gaW5pdENhdGVnb3J5TnVtYmVyKClcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBucmxvd2VyID0gMTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIG5ydXBwZXIgPSAyO1xuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBjYXQgPSAxOyBjYXQgPD0gMTU7IGNhdCsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvL1Bvc2l0aXZlIG51bWJlcnNcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIG5yID0gbnJsb3dlcjsgbnI8bnJ1cHBlcjsgbnIrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhdGVnb3J5WzMyNzY3K25yXSA9IGNhdDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBiaXRjb2RlWzMyNzY3K25yXSA9IFtdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJpdGNvZGVbMzI3NjcrbnJdWzFdID0gY2F0O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJpdGNvZGVbMzI3NjcrbnJdWzBdID0gbnI7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAvL05lZ2F0aXZlIG51bWJlcnNcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIG5ybmVnID0tKG5ydXBwZXItMSk7IG5ybmVnPD0tbnJsb3dlcjsgbnJuZWcrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhdGVnb3J5WzMyNzY3K25ybmVnXSA9IGNhdDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBiaXRjb2RlWzMyNzY3K25ybmVnXSA9IFtdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJpdGNvZGVbMzI3NjcrbnJuZWddWzFdID0gY2F0O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJpdGNvZGVbMzI3NjcrbnJuZWddWzBdID0gbnJ1cHBlci0xK25ybmVnO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgbnJsb3dlciA8PD0gMTtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5ydXBwZXIgPDw9IDE7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgXG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gaW5pdFJHQllVVlRhYmxlKCkge1xuICAgICAgICAgICAgICAgICAgICBmb3IodmFyIGkgPSAwOyBpIDwgMjU2O2krKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgUkdCX1lVVl9UQUJMRVtpXSAgICAgICAgICAgID0gIDE5NTk1ICogaTtcbiAgICAgICAgICAgICAgICAgICAgICAgIFJHQl9ZVVZfVEFCTEVbKGkrIDI1Nik+PjBdICA9ICAzODQ3MCAqIGk7XG4gICAgICAgICAgICAgICAgICAgICAgICBSR0JfWVVWX1RBQkxFWyhpKyA1MTIpPj4wXSAgPSAgIDc0NzEgKiBpICsgMHg4MDAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgUkdCX1lVVl9UQUJMRVsoaSsgNzY4KT4+MF0gID0gLTExMDU5ICogaTtcbiAgICAgICAgICAgICAgICAgICAgICAgIFJHQl9ZVVZfVEFCTEVbKGkrMTAyNCk+PjBdICA9IC0yMTcwOSAqIGk7XG4gICAgICAgICAgICAgICAgICAgICAgICBSR0JfWVVWX1RBQkxFWyhpKzEyODApPj4wXSAgPSAgMzI3NjggKiBpICsgMHg4MDdGRkY7XG4gICAgICAgICAgICAgICAgICAgICAgICBSR0JfWVVWX1RBQkxFWyhpKzE1MzYpPj4wXSAgPSAtMjc0MzkgKiBpO1xuICAgICAgICAgICAgICAgICAgICAgICAgUkdCX1lVVl9UQUJMRVsoaSsxNzkyKT4+MF0gID0gLSA1MzI5ICogaTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICBcbiAgICAgICAgICAgICAgICAvLyBJTyBmdW5jdGlvbnNcbiAgICAgICAgICAgICAgICBmdW5jdGlvbiB3cml0ZUJpdHMoYnMpXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICB2YXIgdmFsdWUgPSBic1swXTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHBvc3ZhbCA9IGJzWzFdLTE7XG4gICAgICAgICAgICAgICAgICAgIHdoaWxlICggcG9zdmFsID49IDAgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodmFsdWUgJiAoMSA8PCBwb3N2YWwpICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJ5dGVuZXcgfD0gKDEgPDwgYnl0ZXBvcyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBwb3N2YWwtLTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJ5dGVwb3MtLTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChieXRlcG9zIDwgMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChieXRlbmV3ID09IDB4RkYpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgd3JpdGVCeXRlKDB4RkYpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB3cml0ZUJ5dGUoMCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB3cml0ZUJ5dGUoYnl0ZW5ldyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJ5dGVwb3M9NztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBieXRlbmV3PTA7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgXG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gd3JpdGVCeXRlKHZhbHVlKVxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgYnl0ZW91dC5wdXNoKGNsdFt2YWx1ZV0pOyAvLyB3cml0ZSBjaGFyIGRpcmVjdGx5IGluc3RlYWQgb2YgY29udmVydGluZyBsYXRlclxuICAgICAgICAgICAgICAgIH1cbiAgICBcbiAgICAgICAgICAgICAgICBmdW5jdGlvbiB3cml0ZVdvcmQodmFsdWUpXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICB3cml0ZUJ5dGUoKHZhbHVlPj44KSYweEZGKTtcbiAgICAgICAgICAgICAgICAgICAgd3JpdGVCeXRlKCh2YWx1ZSAgICkmMHhGRik7XG4gICAgICAgICAgICAgICAgfVxuICAgIFxuICAgICAgICAgICAgICAgIC8vIERDVCAmIHF1YW50aXphdGlvbiBjb3JlXG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gZkRDVFF1YW50KGRhdGEsIGZkdGJsKVxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGQwLCBkMSwgZDIsIGQzLCBkNCwgZDUsIGQ2LCBkNztcbiAgICAgICAgICAgICAgICAgICAgLyogUGFzcyAxOiBwcm9jZXNzIHJvd3MuICovXG4gICAgICAgICAgICAgICAgICAgIHZhciBkYXRhT2ZmPTA7XG4gICAgICAgICAgICAgICAgICAgIHZhciBpO1xuICAgICAgICAgICAgICAgICAgICB2YXIgSTggPSA4O1xuICAgICAgICAgICAgICAgICAgICB2YXIgSTY0ID0gNjQ7XG4gICAgICAgICAgICAgICAgICAgIGZvciAoaT0wOyBpPEk4OyArK2kpXG4gICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGQwID0gZGF0YVtkYXRhT2ZmXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGQxID0gZGF0YVtkYXRhT2ZmKzFdO1xuICAgICAgICAgICAgICAgICAgICAgICAgZDIgPSBkYXRhW2RhdGFPZmYrMl07XG4gICAgICAgICAgICAgICAgICAgICAgICBkMyA9IGRhdGFbZGF0YU9mZiszXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGQ0ID0gZGF0YVtkYXRhT2ZmKzRdO1xuICAgICAgICAgICAgICAgICAgICAgICAgZDUgPSBkYXRhW2RhdGFPZmYrNV07XG4gICAgICAgICAgICAgICAgICAgICAgICBkNiA9IGRhdGFbZGF0YU9mZis2XTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGQ3ID0gZGF0YVtkYXRhT2ZmKzddO1xuICAgIFxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHRtcDAgPSBkMCArIGQ3O1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHRtcDcgPSBkMCAtIGQ3O1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHRtcDEgPSBkMSArIGQ2O1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHRtcDYgPSBkMSAtIGQ2O1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHRtcDIgPSBkMiArIGQ1O1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHRtcDUgPSBkMiAtIGQ1O1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHRtcDMgPSBkMyArIGQ0O1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHRtcDQgPSBkMyAtIGQ0O1xuICAgIFxuICAgICAgICAgICAgICAgICAgICAgICAgLyogRXZlbiBwYXJ0ICovXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgdG1wMTAgPSB0bXAwICsgdG1wMzsgICAgLyogcGhhc2UgMiAqL1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHRtcDEzID0gdG1wMCAtIHRtcDM7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgdG1wMTEgPSB0bXAxICsgdG1wMjtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciB0bXAxMiA9IHRtcDEgLSB0bXAyO1xuICAgIFxuICAgICAgICAgICAgICAgICAgICAgICAgZGF0YVtkYXRhT2ZmXSA9IHRtcDEwICsgdG1wMTE7IC8qIHBoYXNlIDMgKi9cbiAgICAgICAgICAgICAgICAgICAgICAgIGRhdGFbZGF0YU9mZis0XSA9IHRtcDEwIC0gdG1wMTE7XG4gICAgXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgejEgPSAodG1wMTIgKyB0bXAxMykgKiAwLjcwNzEwNjc4MTsgLyogYzQgKi9cbiAgICAgICAgICAgICAgICAgICAgICAgIGRhdGFbZGF0YU9mZisyXSA9IHRtcDEzICsgejE7IC8qIHBoYXNlIDUgKi9cbiAgICAgICAgICAgICAgICAgICAgICAgIGRhdGFbZGF0YU9mZis2XSA9IHRtcDEzIC0gejE7XG4gICAgXG4gICAgICAgICAgICAgICAgICAgICAgICAvKiBPZGQgcGFydCAqL1xuICAgICAgICAgICAgICAgICAgICAgICAgdG1wMTAgPSB0bXA0ICsgdG1wNTsgLyogcGhhc2UgMiAqL1xuICAgICAgICAgICAgICAgICAgICAgICAgdG1wMTEgPSB0bXA1ICsgdG1wNjtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRtcDEyID0gdG1wNiArIHRtcDc7XG4gICAgXG4gICAgICAgICAgICAgICAgICAgICAgICAvKiBUaGUgcm90YXRvciBpcyBtb2RpZmllZCBmcm9tIGZpZyA0LTggdG8gYXZvaWQgZXh0cmEgbmVnYXRpb25zLiAqL1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHo1ID0gKHRtcDEwIC0gdG1wMTIpICogMC4zODI2ODM0MzM7IC8qIGM2ICovXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgejIgPSAwLjU0MTE5NjEwMCAqIHRtcDEwICsgejU7IC8qIGMyLWM2ICovXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgejQgPSAxLjMwNjU2Mjk2NSAqIHRtcDEyICsgejU7IC8qIGMyK2M2ICovXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgejMgPSB0bXAxMSAqIDAuNzA3MTA2NzgxOyAvKiBjNCAqL1xuICAgIFxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHoxMSA9IHRtcDcgKyB6MzsgICAgLyogcGhhc2UgNSAqL1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHoxMyA9IHRtcDcgLSB6MztcbiAgICBcbiAgICAgICAgICAgICAgICAgICAgICAgIGRhdGFbZGF0YU9mZis1XSA9IHoxMyArIHoyOyAvKiBwaGFzZSA2ICovXG4gICAgICAgICAgICAgICAgICAgICAgICBkYXRhW2RhdGFPZmYrM10gPSB6MTMgLSB6MjtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRhdGFbZGF0YU9mZisxXSA9IHoxMSArIHo0O1xuICAgICAgICAgICAgICAgICAgICAgICAgZGF0YVtkYXRhT2ZmKzddID0gejExIC0gejQ7XG4gICAgXG4gICAgICAgICAgICAgICAgICAgICAgICBkYXRhT2ZmICs9IDg7IC8qIGFkdmFuY2UgcG9pbnRlciB0byBuZXh0IHJvdyAqL1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgXG4gICAgICAgICAgICAgICAgICAgIC8qIFBhc3MgMjogcHJvY2VzcyBjb2x1bW5zLiAqL1xuICAgICAgICAgICAgICAgICAgICBkYXRhT2ZmID0gMDtcbiAgICAgICAgICAgICAgICAgICAgZm9yIChpPTA7IGk8STg7ICsraSlcbiAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgZDAgPSBkYXRhW2RhdGFPZmZdO1xuICAgICAgICAgICAgICAgICAgICAgICAgZDEgPSBkYXRhW2RhdGFPZmYgKyA4XTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGQyID0gZGF0YVtkYXRhT2ZmICsgMTZdO1xuICAgICAgICAgICAgICAgICAgICAgICAgZDMgPSBkYXRhW2RhdGFPZmYgKyAyNF07XG4gICAgICAgICAgICAgICAgICAgICAgICBkNCA9IGRhdGFbZGF0YU9mZiArIDMyXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGQ1ID0gZGF0YVtkYXRhT2ZmICsgNDBdO1xuICAgICAgICAgICAgICAgICAgICAgICAgZDYgPSBkYXRhW2RhdGFPZmYgKyA0OF07XG4gICAgICAgICAgICAgICAgICAgICAgICBkNyA9IGRhdGFbZGF0YU9mZiArIDU2XTtcbiAgICBcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciB0bXAwcDIgPSBkMCArIGQ3O1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHRtcDdwMiA9IGQwIC0gZDc7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgdG1wMXAyID0gZDEgKyBkNjtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciB0bXA2cDIgPSBkMSAtIGQ2O1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHRtcDJwMiA9IGQyICsgZDU7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgdG1wNXAyID0gZDIgLSBkNTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciB0bXAzcDIgPSBkMyArIGQ0O1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHRtcDRwMiA9IGQzIC0gZDQ7XG4gICAgXG4gICAgICAgICAgICAgICAgICAgICAgICAvKiBFdmVuIHBhcnQgKi9cbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciB0bXAxMHAyID0gdG1wMHAyICsgdG1wM3AyOyAgLyogcGhhc2UgMiAqL1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHRtcDEzcDIgPSB0bXAwcDIgLSB0bXAzcDI7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgdG1wMTFwMiA9IHRtcDFwMiArIHRtcDJwMjtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciB0bXAxMnAyID0gdG1wMXAyIC0gdG1wMnAyO1xuICAgIFxuICAgICAgICAgICAgICAgICAgICAgICAgZGF0YVtkYXRhT2ZmXSA9IHRtcDEwcDIgKyB0bXAxMXAyOyAvKiBwaGFzZSAzICovXG4gICAgICAgICAgICAgICAgICAgICAgICBkYXRhW2RhdGFPZmYrMzJdID0gdG1wMTBwMiAtIHRtcDExcDI7XG4gICAgXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgejFwMiA9ICh0bXAxMnAyICsgdG1wMTNwMikgKiAwLjcwNzEwNjc4MTsgLyogYzQgKi9cbiAgICAgICAgICAgICAgICAgICAgICAgIGRhdGFbZGF0YU9mZisxNl0gPSB0bXAxM3AyICsgejFwMjsgLyogcGhhc2UgNSAqL1xuICAgICAgICAgICAgICAgICAgICAgICAgZGF0YVtkYXRhT2ZmKzQ4XSA9IHRtcDEzcDIgLSB6MXAyO1xuICAgIFxuICAgICAgICAgICAgICAgICAgICAgICAgLyogT2RkIHBhcnQgKi9cbiAgICAgICAgICAgICAgICAgICAgICAgIHRtcDEwcDIgPSB0bXA0cDIgKyB0bXA1cDI7IC8qIHBoYXNlIDIgKi9cbiAgICAgICAgICAgICAgICAgICAgICAgIHRtcDExcDIgPSB0bXA1cDIgKyB0bXA2cDI7XG4gICAgICAgICAgICAgICAgICAgICAgICB0bXAxMnAyID0gdG1wNnAyICsgdG1wN3AyO1xuICAgIFxuICAgICAgICAgICAgICAgICAgICAgICAgLyogVGhlIHJvdGF0b3IgaXMgbW9kaWZpZWQgZnJvbSBmaWcgNC04IHRvIGF2b2lkIGV4dHJhIG5lZ2F0aW9ucy4gKi9cbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciB6NXAyID0gKHRtcDEwcDIgLSB0bXAxMnAyKSAqIDAuMzgyNjgzNDMzOyAvKiBjNiAqL1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHoycDIgPSAwLjU0MTE5NjEwMCAqIHRtcDEwcDIgKyB6NXAyOyAvKiBjMi1jNiAqL1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHo0cDIgPSAxLjMwNjU2Mjk2NSAqIHRtcDEycDIgKyB6NXAyOyAvKiBjMitjNiAqL1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHozcDIgPSB0bXAxMXAyICogMC43MDcxMDY3ODE7IC8qIGM0ICovXG4gICAgXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgejExcDIgPSB0bXA3cDIgKyB6M3AyOyAgLyogcGhhc2UgNSAqL1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHoxM3AyID0gdG1wN3AyIC0gejNwMjtcbiAgICBcbiAgICAgICAgICAgICAgICAgICAgICAgIGRhdGFbZGF0YU9mZis0MF0gPSB6MTNwMiArIHoycDI7IC8qIHBoYXNlIDYgKi9cbiAgICAgICAgICAgICAgICAgICAgICAgIGRhdGFbZGF0YU9mZisyNF0gPSB6MTNwMiAtIHoycDI7XG4gICAgICAgICAgICAgICAgICAgICAgICBkYXRhW2RhdGFPZmYrIDhdID0gejExcDIgKyB6NHAyO1xuICAgICAgICAgICAgICAgICAgICAgICAgZGF0YVtkYXRhT2ZmKzU2XSA9IHoxMXAyIC0gejRwMjtcbiAgICBcbiAgICAgICAgICAgICAgICAgICAgICAgIGRhdGFPZmYrKzsgLyogYWR2YW5jZSBwb2ludGVyIHRvIG5leHQgY29sdW1uICovXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICBcbiAgICAgICAgICAgICAgICAgICAgLy8gUXVhbnRpemUvZGVzY2FsZSB0aGUgY29lZmZpY2llbnRzXG4gICAgICAgICAgICAgICAgICAgIHZhciBmRENUUXVhbnQ7XG4gICAgICAgICAgICAgICAgICAgIGZvciAoaT0wOyBpPEk2NDsgKytpKVxuICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBBcHBseSB0aGUgcXVhbnRpemF0aW9uIGFuZCBzY2FsaW5nIGZhY3RvciAmIFJvdW5kIHRvIG5lYXJlc3QgaW50ZWdlclxuICAgICAgICAgICAgICAgICAgICAgICAgZkRDVFF1YW50ID0gZGF0YVtpXSpmZHRibFtpXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIG91dHB1dGZEQ1RRdWFudFtpXSA9IChmRENUUXVhbnQgPiAwLjApID8gKChmRENUUXVhbnQgKyAwLjUpfDApIDogKChmRENUUXVhbnQgLSAwLjUpfDApO1xuICAgICAgICAgICAgICAgICAgICAgICAgLy9vdXRwdXRmRENUUXVhbnRbaV0gPSBmcm91bmQoZkRDVFF1YW50KTtcbiAgICBcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gb3V0cHV0ZkRDVFF1YW50O1xuICAgICAgICAgICAgICAgIH1cbiAgICBcbiAgICAgICAgICAgICAgICBmdW5jdGlvbiB3cml0ZUFQUDAoKVxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgd3JpdGVXb3JkKDB4RkZFMCk7IC8vIG1hcmtlclxuICAgICAgICAgICAgICAgICAgICB3cml0ZVdvcmQoMTYpOyAvLyBsZW5ndGhcbiAgICAgICAgICAgICAgICAgICAgd3JpdGVCeXRlKDB4NEEpOyAvLyBKXG4gICAgICAgICAgICAgICAgICAgIHdyaXRlQnl0ZSgweDQ2KTsgLy8gRlxuICAgICAgICAgICAgICAgICAgICB3cml0ZUJ5dGUoMHg0OSk7IC8vIElcbiAgICAgICAgICAgICAgICAgICAgd3JpdGVCeXRlKDB4NDYpOyAvLyBGXG4gICAgICAgICAgICAgICAgICAgIHdyaXRlQnl0ZSgwKTsgLy8gPSBcIkpGSUZcIiwnXFwwJ1xuICAgICAgICAgICAgICAgICAgICB3cml0ZUJ5dGUoMSk7IC8vIHZlcnNpb25oaVxuICAgICAgICAgICAgICAgICAgICB3cml0ZUJ5dGUoMSk7IC8vIHZlcnNpb25sb1xuICAgICAgICAgICAgICAgICAgICB3cml0ZUJ5dGUoMCk7IC8vIHh5dW5pdHNcbiAgICAgICAgICAgICAgICAgICAgd3JpdGVXb3JkKDEpOyAvLyB4ZGVuc2l0eVxuICAgICAgICAgICAgICAgICAgICB3cml0ZVdvcmQoMSk7IC8vIHlkZW5zaXR5XG4gICAgICAgICAgICAgICAgICAgIHdyaXRlQnl0ZSgwKTsgLy8gdGh1bWJud2lkdGhcbiAgICAgICAgICAgICAgICAgICAgd3JpdGVCeXRlKDApOyAvLyB0aHVtYm5oZWlnaHRcbiAgICAgICAgICAgICAgICB9XG4gICAgXG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gd3JpdGVTT0YwKHdpZHRoLCBoZWlnaHQpXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICB3cml0ZVdvcmQoMHhGRkMwKTsgLy8gbWFya2VyXG4gICAgICAgICAgICAgICAgICAgIHdyaXRlV29yZCgxNyk7ICAgLy8gbGVuZ3RoLCB0cnVlY29sb3IgWVVWIEpQR1xuICAgICAgICAgICAgICAgICAgICB3cml0ZUJ5dGUoOCk7ICAgIC8vIHByZWNpc2lvblxuICAgICAgICAgICAgICAgICAgICB3cml0ZVdvcmQoaGVpZ2h0KTtcbiAgICAgICAgICAgICAgICAgICAgd3JpdGVXb3JkKHdpZHRoKTtcbiAgICAgICAgICAgICAgICAgICAgd3JpdGVCeXRlKDMpOyAgICAvLyBucm9mY29tcG9uZW50c1xuICAgICAgICAgICAgICAgICAgICB3cml0ZUJ5dGUoMSk7ICAgIC8vIElkWVxuICAgICAgICAgICAgICAgICAgICB3cml0ZUJ5dGUoMHgxMSk7IC8vIEhWWVxuICAgICAgICAgICAgICAgICAgICB3cml0ZUJ5dGUoMCk7ICAgIC8vIFFUWVxuICAgICAgICAgICAgICAgICAgICB3cml0ZUJ5dGUoMik7ICAgIC8vIElkVVxuICAgICAgICAgICAgICAgICAgICB3cml0ZUJ5dGUoMHgxMSk7IC8vIEhWVVxuICAgICAgICAgICAgICAgICAgICB3cml0ZUJ5dGUoMSk7ICAgIC8vIFFUVVxuICAgICAgICAgICAgICAgICAgICB3cml0ZUJ5dGUoMyk7ICAgIC8vIElkVlxuICAgICAgICAgICAgICAgICAgICB3cml0ZUJ5dGUoMHgxMSk7IC8vIEhWVlxuICAgICAgICAgICAgICAgICAgICB3cml0ZUJ5dGUoMSk7ICAgIC8vIFFUVlxuICAgICAgICAgICAgICAgIH1cbiAgICBcbiAgICAgICAgICAgICAgICBmdW5jdGlvbiB3cml0ZURRVCgpXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICB3cml0ZVdvcmQoMHhGRkRCKTsgLy8gbWFya2VyXG4gICAgICAgICAgICAgICAgICAgIHdyaXRlV29yZCgxMzIpOyAgICAvLyBsZW5ndGhcbiAgICAgICAgICAgICAgICAgICAgd3JpdGVCeXRlKDApO1xuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBpPTA7IGk8NjQ7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgd3JpdGVCeXRlKFlUYWJsZVtpXSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgd3JpdGVCeXRlKDEpO1xuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBqPTA7IGo8NjQ7IGorKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgd3JpdGVCeXRlKFVWVGFibGVbal0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgIFxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uIHdyaXRlREhUKClcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIHdyaXRlV29yZCgweEZGQzQpOyAvLyBtYXJrZXJcbiAgICAgICAgICAgICAgICAgICAgd3JpdGVXb3JkKDB4MDFBMik7IC8vIGxlbmd0aFxuICAgIFxuICAgICAgICAgICAgICAgICAgICB3cml0ZUJ5dGUoMCk7IC8vIEhUWURDaW5mb1xuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBpPTA7IGk8MTY7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgd3JpdGVCeXRlKHN0ZF9kY19sdW1pbmFuY2VfbnJjb2Rlc1tpKzFdKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBqPTA7IGo8PTExOyBqKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHdyaXRlQnl0ZShzdGRfZGNfbHVtaW5hbmNlX3ZhbHVlc1tqXSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICBcbiAgICAgICAgICAgICAgICAgICAgd3JpdGVCeXRlKDB4MTApOyAvLyBIVFlBQ2luZm9cbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaz0wOyBrPDE2OyBrKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHdyaXRlQnl0ZShzdGRfYWNfbHVtaW5hbmNlX25yY29kZXNbaysxXSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgbD0wOyBsPD0xNjE7IGwrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgd3JpdGVCeXRlKHN0ZF9hY19sdW1pbmFuY2VfdmFsdWVzW2xdKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgIFxuICAgICAgICAgICAgICAgICAgICB3cml0ZUJ5dGUoMSk7IC8vIEhUVURDaW5mb1xuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBtPTA7IG08MTY7IG0rKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgd3JpdGVCeXRlKHN0ZF9kY19jaHJvbWluYW5jZV9ucmNvZGVzW20rMV0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIG49MDsgbjw9MTE7IG4rKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgd3JpdGVCeXRlKHN0ZF9kY19jaHJvbWluYW5jZV92YWx1ZXNbbl0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgXG4gICAgICAgICAgICAgICAgICAgIHdyaXRlQnl0ZSgweDExKTsgLy8gSFRVQUNpbmZvXG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIG89MDsgbzwxNjsgbysrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB3cml0ZUJ5dGUoc3RkX2FjX2Nocm9taW5hbmNlX25yY29kZXNbbysxXSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgcD0wOyBwPD0xNjE7IHArKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgd3JpdGVCeXRlKHN0ZF9hY19jaHJvbWluYW5jZV92YWx1ZXNbcF0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgIFxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uIHdyaXRlU09TKClcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIHdyaXRlV29yZCgweEZGREEpOyAvLyBtYXJrZXJcbiAgICAgICAgICAgICAgICAgICAgd3JpdGVXb3JkKDEyKTsgLy8gbGVuZ3RoXG4gICAgICAgICAgICAgICAgICAgIHdyaXRlQnl0ZSgzKTsgLy8gbnJvZmNvbXBvbmVudHNcbiAgICAgICAgICAgICAgICAgICAgd3JpdGVCeXRlKDEpOyAvLyBJZFlcbiAgICAgICAgICAgICAgICAgICAgd3JpdGVCeXRlKDApOyAvLyBIVFlcbiAgICAgICAgICAgICAgICAgICAgd3JpdGVCeXRlKDIpOyAvLyBJZFVcbiAgICAgICAgICAgICAgICAgICAgd3JpdGVCeXRlKDB4MTEpOyAvLyBIVFVcbiAgICAgICAgICAgICAgICAgICAgd3JpdGVCeXRlKDMpOyAvLyBJZFZcbiAgICAgICAgICAgICAgICAgICAgd3JpdGVCeXRlKDB4MTEpOyAvLyBIVFZcbiAgICAgICAgICAgICAgICAgICAgd3JpdGVCeXRlKDApOyAvLyBTc1xuICAgICAgICAgICAgICAgICAgICB3cml0ZUJ5dGUoMHgzZik7IC8vIFNlXG4gICAgICAgICAgICAgICAgICAgIHdyaXRlQnl0ZSgwKTsgLy8gQmZcbiAgICAgICAgICAgICAgICB9XG4gICAgXG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gcHJvY2Vzc0RVKENEVSwgZmR0YmwsIERDLCBIVERDLCBIVEFDKXtcbiAgICAgICAgICAgICAgICAgICAgdmFyIEVPQiA9IEhUQUNbMHgwMF07XG4gICAgICAgICAgICAgICAgICAgIHZhciBNMTZ6ZXJvZXMgPSBIVEFDWzB4RjBdO1xuICAgICAgICAgICAgICAgICAgICB2YXIgcG9zO1xuICAgICAgICAgICAgICAgICAgICB2YXIgSTE2ID0gMTY7XG4gICAgICAgICAgICAgICAgICAgIHZhciBJNjMgPSA2MztcbiAgICAgICAgICAgICAgICAgICAgdmFyIEk2NCA9IDY0O1xuICAgICAgICAgICAgICAgICAgICB2YXIgRFVfRENUID0gZkRDVFF1YW50KENEVSwgZmR0YmwpO1xuICAgICAgICAgICAgICAgICAgICAvL1ppZ1phZyByZW9yZGVyXG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGo9MDtqPEk2NDsrK2opIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIERVW1ppZ1phZ1tqXV09RFVfRENUW2pdO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHZhciBEaWZmID0gRFVbMF0gLSBEQzsgREMgPSBEVVswXTtcbiAgICAgICAgICAgICAgICAgICAgLy9FbmNvZGUgRENcbiAgICAgICAgICAgICAgICAgICAgaWYgKERpZmY9PTApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHdyaXRlQml0cyhIVERDWzBdKTsgLy8gRGlmZiBtaWdodCBiZSAwXG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwb3MgPSAzMjc2NytEaWZmO1xuICAgICAgICAgICAgICAgICAgICAgICAgd3JpdGVCaXRzKEhURENbY2F0ZWdvcnlbcG9zXV0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgd3JpdGVCaXRzKGJpdGNvZGVbcG9zXSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgLy9FbmNvZGUgQUNzXG4gICAgICAgICAgICAgICAgICAgIHZhciBlbmQwcG9zID0gNjM7IC8vIHdhcyBjb25zdC4uLiB3aGljaCBpcyBjcmF6eVxuICAgICAgICAgICAgICAgICAgICBmb3IgKDsgKGVuZDBwb3M+MCkmJihEVVtlbmQwcG9zXT09MCk7IGVuZDBwb3MtLSkge307XG4gICAgICAgICAgICAgICAgICAgIC8vZW5kMHBvcyA9IGZpcnN0IGVsZW1lbnQgaW4gcmV2ZXJzZSBvcmRlciAhPTBcbiAgICAgICAgICAgICAgICAgICAgaWYgKCBlbmQwcG9zID09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHdyaXRlQml0cyhFT0IpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIERDO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHZhciBpID0gMTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGxuZztcbiAgICAgICAgICAgICAgICAgICAgd2hpbGUgKCBpIDw9IGVuZDBwb3MgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgc3RhcnRwb3MgPSBpO1xuICAgICAgICAgICAgICAgICAgICAgICAgZm9yICg7IChEVVtpXT09MCkgJiYgKGk8PWVuZDBwb3MpOyArK2kpIHt9XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgbnJ6ZXJvZXMgPSBpLXN0YXJ0cG9zO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCBucnplcm9lcyA+PSBJMTYgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbG5nID0gbnJ6ZXJvZXM+PjQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgbnJtYXJrZXI9MTsgbnJtYXJrZXIgPD0gbG5nOyArK25ybWFya2VyKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB3cml0ZUJpdHMoTTE2emVyb2VzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBucnplcm9lcyA9IG5yemVyb2VzJjB4RjtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHBvcyA9IDMyNzY3K0RVW2ldO1xuICAgICAgICAgICAgICAgICAgICAgICAgd3JpdGVCaXRzKEhUQUNbKG5yemVyb2VzPDw0KStjYXRlZ29yeVtwb3NdXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB3cml0ZUJpdHMoYml0Y29kZVtwb3NdKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGkrKztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoIGVuZDBwb3MgIT0gSTYzICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgd3JpdGVCaXRzKEVPQik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIERDO1xuICAgICAgICAgICAgICAgIH1cbiAgICBcbiAgICAgICAgICAgICAgICBmdW5jdGlvbiBpbml0Q2hhckxvb2t1cFRhYmxlKCl7XG4gICAgICAgICAgICAgICAgICAgIHZhciBzZmNjID0gU3RyaW5nLmZyb21DaGFyQ29kZTtcbiAgICAgICAgICAgICAgICAgICAgZm9yKHZhciBpPTA7IGkgPCAyNTY7IGkrKyl7IC8vLy8vIEFDSFRVTkcgLy8gMjU1XG4gICAgICAgICAgICAgICAgICAgICAgICBjbHRbaV0gPSBzZmNjKGkpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgIFxuICAgICAgICAgICAgICAgIHRoaXMuZW5jb2RlID0gZnVuY3Rpb24oaW1hZ2UscXVhbGl0eSkgLy8gaW1hZ2UgZGF0YSBvYmplY3RcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIC8vIHZhciB0aW1lX3N0YXJ0ID0gbmV3IERhdGUoKS5nZXRUaW1lKCk7XG4gICAgXG4gICAgICAgICAgICAgICAgICAgIGlmKHF1YWxpdHkpIHNldFF1YWxpdHkocXVhbGl0eSk7XG4gICAgXG4gICAgICAgICAgICAgICAgICAgIC8vIEluaXRpYWxpemUgYml0IHdyaXRlclxuICAgICAgICAgICAgICAgICAgICBieXRlb3V0ID0gbmV3IEFycmF5KCk7XG4gICAgICAgICAgICAgICAgICAgIGJ5dGVuZXc9MDtcbiAgICAgICAgICAgICAgICAgICAgYnl0ZXBvcz03O1xuICAgIFxuICAgICAgICAgICAgICAgICAgICAvLyBBZGQgSlBFRyBoZWFkZXJzXG4gICAgICAgICAgICAgICAgICAgIHdyaXRlV29yZCgweEZGRDgpOyAvLyBTT0lcbiAgICAgICAgICAgICAgICAgICAgd3JpdGVBUFAwKCk7XG4gICAgICAgICAgICAgICAgICAgIHdyaXRlRFFUKCk7XG4gICAgICAgICAgICAgICAgICAgIHdyaXRlU09GMChpbWFnZS53aWR0aCxpbWFnZS5oZWlnaHQpO1xuICAgICAgICAgICAgICAgICAgICB3cml0ZURIVCgpO1xuICAgICAgICAgICAgICAgICAgICB3cml0ZVNPUygpO1xuICAgIFxuICAgIFxuICAgICAgICAgICAgICAgICAgICAvLyBFbmNvZGUgOHg4IG1hY3JvYmxvY2tzXG4gICAgICAgICAgICAgICAgICAgIHZhciBEQ1k9MDtcbiAgICAgICAgICAgICAgICAgICAgdmFyIERDVT0wO1xuICAgICAgICAgICAgICAgICAgICB2YXIgRENWPTA7XG4gICAgXG4gICAgICAgICAgICAgICAgICAgIGJ5dGVuZXc9MDtcbiAgICAgICAgICAgICAgICAgICAgYnl0ZXBvcz03O1xuICAgIFxuICAgIFxuICAgICAgICAgICAgICAgICAgICB0aGlzLmVuY29kZS5kaXNwbGF5TmFtZSA9IFwiX2VuY29kZV9cIjtcbiAgICBcbiAgICAgICAgICAgICAgICAgICAgdmFyIGltYWdlRGF0YSA9IGltYWdlLmRhdGE7XG4gICAgICAgICAgICAgICAgICAgIHZhciB3aWR0aCA9IGltYWdlLndpZHRoO1xuICAgICAgICAgICAgICAgICAgICB2YXIgaGVpZ2h0ID0gaW1hZ2UuaGVpZ2h0O1xuICAgIFxuICAgICAgICAgICAgICAgICAgICB2YXIgcXVhZFdpZHRoID0gd2lkdGgqNDtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHRyaXBsZVdpZHRoID0gd2lkdGgqMztcbiAgICBcbiAgICAgICAgICAgICAgICAgICAgdmFyIHgsIHkgPSAwO1xuICAgICAgICAgICAgICAgICAgICB2YXIgciwgZywgYjtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHN0YXJ0LHAsIGNvbCxyb3cscG9zO1xuICAgICAgICAgICAgICAgICAgICB3aGlsZSh5IDwgaGVpZ2h0KXtcbiAgICAgICAgICAgICAgICAgICAgICAgIHggPSAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgd2hpbGUoeCA8IHF1YWRXaWR0aCl7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdGFydCA9IHF1YWRXaWR0aCAqIHkgKyB4O1xuICAgICAgICAgICAgICAgICAgICAgICAgcCA9IHN0YXJ0O1xuICAgICAgICAgICAgICAgICAgICAgICAgY29sID0gLTE7XG4gICAgICAgICAgICAgICAgICAgICAgICByb3cgPSAwO1xuICAgIFxuICAgICAgICAgICAgICAgICAgICAgICAgZm9yKHBvcz0wOyBwb3MgPCA2NDsgcG9zKyspe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJvdyA9IHBvcyA+PiAzOy8vIC84XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29sID0gKCBwb3MgJiA3ICkgKiA0OyAvLyAlOFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHAgPSBzdGFydCArICggcm93ICogcXVhZFdpZHRoICkgKyBjb2w7XG4gICAgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYoeStyb3cgPj0gaGVpZ2h0KXsgLy8gcGFkZGluZyBib3R0b21cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcC09IChxdWFkV2lkdGgqKHkrMStyb3ctaGVpZ2h0KSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmKHgrY29sID49IHF1YWRXaWR0aCl7IC8vIHBhZGRpbmcgcmlnaHRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcC09ICgoeCtjb2wpIC0gcXVhZFdpZHRoICs0KVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByID0gaW1hZ2VEYXRhWyBwKysgXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBnID0gaW1hZ2VEYXRhWyBwKysgXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBiID0gaW1hZ2VEYXRhWyBwKysgXTtcbiAgICBcbiAgICBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvKiAvLyBjYWxjdWxhdGUgWVVWIHZhbHVlcyBkeW5hbWljYWxseVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFlEVVtwb3NdPSgoKCAwLjI5OTAwKSpyKyggMC41ODcwMCkqZysoIDAuMTE0MDApKmIpKS0xMjg7IC8vLTB4ODBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBVRFVbcG9zXT0oKCgtMC4xNjg3NCkqcisoLTAuMzMxMjYpKmcrKCAwLjUwMDAwKSpiKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgVkRVW3Bvc109KCgoIDAuNTAwMDApKnIrKC0wLjQxODY5KSpnKygtMC4wODEzMSkqYikpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICovXG4gICAgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gdXNlIGxvb2t1cCB0YWJsZSAoc2xpZ2h0bHkgZmFzdGVyKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFlEVVtwb3NdID0gKChSR0JfWVVWX1RBQkxFW3JdICAgICAgICAgICAgICsgUkdCX1lVVl9UQUJMRVsoZyArICAyNTYpPj4wXSArIFJHQl9ZVVZfVEFCTEVbKGIgKyAgNTEyKT4+MF0pID4+IDE2KS0xMjg7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgVURVW3Bvc10gPSAoKFJHQl9ZVVZfVEFCTEVbKHIgKyAgNzY4KT4+MF0gKyBSR0JfWVVWX1RBQkxFWyhnICsgMTAyNCk+PjBdICsgUkdCX1lVVl9UQUJMRVsoYiArIDEyODApPj4wXSkgPj4gMTYpLTEyODtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBWRFVbcG9zXSA9ICgoUkdCX1lVVl9UQUJMRVsociArIDEyODApPj4wXSArIFJHQl9ZVVZfVEFCTEVbKGcgKyAxNTM2KT4+MF0gKyBSR0JfWVVWX1RBQkxFWyhiICsgMTc5Mik+PjBdKSA+PiAxNiktMTI4O1xuICAgIFxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgIFxuICAgICAgICAgICAgICAgICAgICAgICAgRENZID0gcHJvY2Vzc0RVKFlEVSwgZmR0YmxfWSwgRENZLCBZRENfSFQsIFlBQ19IVCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBEQ1UgPSBwcm9jZXNzRFUoVURVLCBmZHRibF9VViwgRENVLCBVVkRDX0hULCBVVkFDX0hUKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIERDViA9IHByb2Nlc3NEVShWRFUsIGZkdGJsX1VWLCBEQ1YsIFVWRENfSFQsIFVWQUNfSFQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgeCs9MzI7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB5Kz04O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgXG4gICAgXG4gICAgICAgICAgICAgICAgICAgIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cbiAgICBcbiAgICAgICAgICAgICAgICAgICAgLy8gRG8gdGhlIGJpdCBhbGlnbm1lbnQgb2YgdGhlIEVPSSBtYXJrZXJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCBieXRlcG9zID49IDAgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgZmlsbGJpdHMgPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZpbGxiaXRzWzFdID0gYnl0ZXBvcysxO1xuICAgICAgICAgICAgICAgICAgICAgICAgZmlsbGJpdHNbMF0gPSAoMTw8KGJ5dGVwb3MrMSkpLTE7XG4gICAgICAgICAgICAgICAgICAgICAgICB3cml0ZUJpdHMoZmlsbGJpdHMpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgXG4gICAgICAgICAgICAgICAgICAgIHdyaXRlV29yZCgweEZGRDkpOyAvL0VPSVxuICAgIFxuICAgICAgICAgICAgICAgICAgICB2YXIganBlZ0RhdGFVcmkgPSAnZGF0YTppbWFnZS9qcGVnO2Jhc2U2NCwnICsgYnRvYShieXRlb3V0LmpvaW4oJycpKTtcbiAgICBcbiAgICAgICAgICAgICAgICAgICAgYnl0ZW91dCA9IFtdO1xuICAgIFxuICAgICAgICAgICAgICAgICAgICAvLyBiZW5jaG1hcmtpbmdcbiAgICAgICAgICAgICAgICAgICAgLy8gdmFyIGR1cmF0aW9uID0gbmV3IERhdGUoKS5nZXRUaW1lKCkgLSB0aW1lX3N0YXJ0O1xuICAgICAgICAgICAgICAgICAgICAvLyBjb25zb2xlLmxvZygnRW5jb2RpbmcgdGltZTogJysgY3VycmVudFF1YWxpdHkgKyAnbXMnKTtcbiAgICAgICAgICAgICAgICAgICAgLy9cbiAgICBcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGpwZWdEYXRhVXJpXG4gICAgICAgICAgICB9XG4gICAgXG4gICAgICAgICAgICBmdW5jdGlvbiBzZXRRdWFsaXR5KHF1YWxpdHkpe1xuICAgICAgICAgICAgICAgIGlmIChxdWFsaXR5IDw9IDApIHtcbiAgICAgICAgICAgICAgICAgICAgcXVhbGl0eSA9IDE7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChxdWFsaXR5ID4gMTAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHF1YWxpdHkgPSAxMDA7XG4gICAgICAgICAgICAgICAgfVxuICAgIFxuICAgICAgICAgICAgICAgIGlmKGN1cnJlbnRRdWFsaXR5ID09IHF1YWxpdHkpIHJldHVybiAvLyBkb24ndCByZWNhbGMgaWYgdW5jaGFuZ2VkXG4gICAgXG4gICAgICAgICAgICAgICAgdmFyIHNmID0gMDtcbiAgICAgICAgICAgICAgICBpZiAocXVhbGl0eSA8IDUwKSB7XG4gICAgICAgICAgICAgICAgICAgIHNmID0gTWF0aC5mbG9vcig1MDAwIC8gcXVhbGl0eSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgc2YgPSBNYXRoLmZsb29yKDIwMCAtIHF1YWxpdHkqMik7XG4gICAgICAgICAgICAgICAgfVxuICAgIFxuICAgICAgICAgICAgICAgIGluaXRRdWFudFRhYmxlcyhzZik7XG4gICAgICAgICAgICAgICAgY3VycmVudFF1YWxpdHkgPSBxdWFsaXR5O1xuICAgICAgICAgICAgICAgIC8vIGNvbnNvbGUubG9nKCdRdWFsaXR5IHNldCB0bzogJytxdWFsaXR5ICsnJScpO1xuICAgICAgICAgICAgfVxuICAgIFxuICAgICAgICAgICAgZnVuY3Rpb24gaW5pdCgpe1xuICAgICAgICAgICAgICAgIC8vIHZhciB0aW1lX3N0YXJ0ID0gbmV3IERhdGUoKS5nZXRUaW1lKCk7XG4gICAgICAgICAgICAgICAgaWYoIXF1YWxpdHkpIHF1YWxpdHkgPSA1MDtcbiAgICAgICAgICAgICAgICAvLyBDcmVhdGUgdGFibGVzXG4gICAgICAgICAgICAgICAgaW5pdENoYXJMb29rdXBUYWJsZSgpXG4gICAgICAgICAgICAgICAgaW5pdEh1ZmZtYW5UYmwoKTtcbiAgICAgICAgICAgICAgICBpbml0Q2F0ZWdvcnlOdW1iZXIoKTtcbiAgICAgICAgICAgICAgICBpbml0UkdCWVVWVGFibGUoKTtcbiAgICBcbiAgICAgICAgICAgICAgICBzZXRRdWFsaXR5KHF1YWxpdHkpO1xuICAgICAgICAgICAgICAgIC8vIHZhciBkdXJhdGlvbiA9IG5ldyBEYXRlKCkuZ2V0VGltZSgpIC0gdGltZV9zdGFydDtcbiAgICAgICAgICAgICAgICAvLyBjb25zb2xlLmxvZygnSW5pdGlhbGl6YXRpb24gJysgZHVyYXRpb24gKyAnbXMnKTtcbiAgICAgICAgICAgIH1cbiAgICBcbiAgICAgICAgICAgIGluaXQoKTtcbiAgICBcbiAgICAgICAgfTtcbiAgICBcbiAgICAgICAgSlBFR0VuY29kZXIuZW5jb2RlID0gZnVuY3Rpb24oIGRhdGEsIHF1YWxpdHkgKSB7XG4gICAgICAgICAgICB2YXIgZW5jb2RlciA9IG5ldyBKUEVHRW5jb2RlciggcXVhbGl0eSApO1xuICAgIFxuICAgICAgICAgICAgcmV0dXJuIGVuY29kZXIuZW5jb2RlKCBkYXRhICk7XG4gICAgICAgIH1cbiAgICBcbiAgICAgICAgcmV0dXJuIEpQRUdFbmNvZGVyO1xuICAgIH0pO1xuICAgIC8qKlxuICAgICAqIEBmaWxlT3ZlcnZpZXcgRml4IGFuZHJvaWQgY2FudmFzLnRvRGF0YVVybCBidWcuXG4gICAgICovXG4gICAgZGVmaW5lKCdydW50aW1lL2h0bWw1L2FuZHJvaWRwYXRjaCcsW1xuICAgICAgICAncnVudGltZS9odG1sNS91dGlsJyxcbiAgICAgICAgJ3J1bnRpbWUvaHRtbDUvanBlZ2VuY29kZXInLFxuICAgICAgICAnYmFzZSdcbiAgICBdLCBmdW5jdGlvbiggVXRpbCwgZW5jb2RlciwgQmFzZSApIHtcbiAgICAgICAgdmFyIG9yaWdpbiA9IFV0aWwuY2FudmFzVG9EYXRhVXJsLFxuICAgICAgICAgICAgc3VwcG9ydEpwZWc7XG4gICAgXG4gICAgICAgIFV0aWwuY2FudmFzVG9EYXRhVXJsID0gZnVuY3Rpb24oIGNhbnZhcywgdHlwZSwgcXVhbGl0eSApIHtcbiAgICAgICAgICAgIHZhciBjdHgsIHcsIGgsIGZyYWdlbWVudCwgcGFydHM7XG4gICAgXG4gICAgICAgICAgICAvLyDpnZ5hbmRyb2lk5omL5py655u05o6l6Lez6L+H44CCXG4gICAgICAgICAgICBpZiAoICFCYXNlLm9zLmFuZHJvaWQgKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG9yaWdpbi5hcHBseSggbnVsbCwgYXJndW1lbnRzICk7XG4gICAgICAgICAgICB9XG4gICAgXG4gICAgICAgICAgICAvLyDmo4DmtYvmmK/lkKZjYW52YXPmlK/mjIFqcGVn5a+85Ye677yM5qC55o2u5pWw5o2u5qC85byP5p2l5Yik5pat44CCXG4gICAgICAgICAgICAvLyBKUEVHIOWJjeS4pOS9jeWIhuWIq+aYr++8mjI1NSwgMjE2XG4gICAgICAgICAgICBpZiAoIHR5cGUgPT09ICdpbWFnZS9qcGVnJyAmJiB0eXBlb2Ygc3VwcG9ydEpwZWcgPT09ICd1bmRlZmluZWQnICkge1xuICAgICAgICAgICAgICAgIGZyYWdlbWVudCA9IG9yaWdpbi5hcHBseSggbnVsbCwgYXJndW1lbnRzICk7XG4gICAgXG4gICAgICAgICAgICAgICAgcGFydHMgPSBmcmFnZW1lbnQuc3BsaXQoJywnKTtcbiAgICBcbiAgICAgICAgICAgICAgICBpZiAoIH5wYXJ0c1sgMCBdLmluZGV4T2YoJ2Jhc2U2NCcpICkge1xuICAgICAgICAgICAgICAgICAgICBmcmFnZW1lbnQgPSBhdG9iKCBwYXJ0c1sgMSBdICk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgZnJhZ2VtZW50ID0gZGVjb2RlVVJJQ29tcG9uZW50KCBwYXJ0c1sgMSBdICk7XG4gICAgICAgICAgICAgICAgfVxuICAgIFxuICAgICAgICAgICAgICAgIGZyYWdlbWVudCA9IGZyYWdlbWVudC5zdWJzdHJpbmcoIDAsIDIgKTtcbiAgICBcbiAgICAgICAgICAgICAgICBzdXBwb3J0SnBlZyA9IGZyYWdlbWVudC5jaGFyQ29kZUF0KCAwICkgPT09IDI1NSAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgZnJhZ2VtZW50LmNoYXJDb2RlQXQoIDEgKSA9PT0gMjE2O1xuICAgICAgICAgICAgfVxuICAgIFxuICAgICAgICAgICAgLy8g5Y+q5pyJ5ZyoYW5kcm9pZOeOr+Wig+S4i+aJjeS/ruWkjVxuICAgICAgICAgICAgaWYgKCB0eXBlID09PSAnaW1hZ2UvanBlZycgJiYgIXN1cHBvcnRKcGVnICkge1xuICAgICAgICAgICAgICAgIHcgPSBjYW52YXMud2lkdGg7XG4gICAgICAgICAgICAgICAgaCA9IGNhbnZhcy5oZWlnaHQ7XG4gICAgICAgICAgICAgICAgY3R4ID0gY2FudmFzLmdldENvbnRleHQoJzJkJyk7XG4gICAgXG4gICAgICAgICAgICAgICAgcmV0dXJuIGVuY29kZXIuZW5jb2RlKCBjdHguZ2V0SW1hZ2VEYXRhKCAwLCAwLCB3LCBoICksIHF1YWxpdHkgKTtcbiAgICAgICAgICAgIH1cbiAgICBcbiAgICAgICAgICAgIHJldHVybiBvcmlnaW4uYXBwbHkoIG51bGwsIGFyZ3VtZW50cyApO1xuICAgICAgICB9O1xuICAgIH0pO1xuICAgIC8qKlxuICAgICAqIEBmaWxlT3ZlcnZpZXcgSW1hZ2VcbiAgICAgKi9cbiAgICBkZWZpbmUoJ3J1bnRpbWUvaHRtbDUvaW1hZ2UnLFtcbiAgICAgICAgJ2Jhc2UnLFxuICAgICAgICAncnVudGltZS9odG1sNS9ydW50aW1lJyxcbiAgICAgICAgJ3J1bnRpbWUvaHRtbDUvdXRpbCdcbiAgICBdLCBmdW5jdGlvbiggQmFzZSwgSHRtbDVSdW50aW1lLCBVdGlsICkge1xuICAgIFxuICAgICAgICB2YXIgQkxBTksgPSAnZGF0YTppbWFnZS9naWY7YmFzZTY0LFIwbEdPRGxoQVFBQkFBRC9BQ3dBQUFBQUFRQUJBQUFDQURzJTNEJztcbiAgICBcbiAgICAgICAgcmV0dXJuIEh0bWw1UnVudGltZS5yZWdpc3RlciggJ0ltYWdlJywge1xuICAgIFxuICAgICAgICAgICAgLy8gZmxhZzog5qCH6K6w5piv5ZCm6KKr5L+u5pS56L+H44CCXG4gICAgICAgICAgICBtb2RpZmllZDogZmFsc2UsXG4gICAgXG4gICAgICAgICAgICBpbml0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICB2YXIgbWUgPSB0aGlzLFxuICAgICAgICAgICAgICAgICAgICBpbWcgPSBuZXcgSW1hZ2UoKTtcbiAgICBcbiAgICAgICAgICAgICAgICBpbWcub25sb2FkID0gZnVuY3Rpb24oKSB7XG4gICAgXG4gICAgICAgICAgICAgICAgICAgIG1lLl9pbmZvID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogbWUudHlwZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHdpZHRoOiB0aGlzLndpZHRoLFxuICAgICAgICAgICAgICAgICAgICAgICAgaGVpZ2h0OiB0aGlzLmhlaWdodFxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgIFxuICAgICAgICAgICAgICAgICAgICAvLyDor7vlj5ZtZXRh5L+h5oGv44CCXG4gICAgICAgICAgICAgICAgICAgIGlmICggIW1lLl9tZXRhcyAmJiAnaW1hZ2UvanBlZycgPT09IG1lLnR5cGUgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBVdGlsLnBhcnNlTWV0YSggbWUuX2Jsb2IsIGZ1bmN0aW9uKCBlcnJvciwgcmV0ICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1lLl9tZXRhcyA9IHJldDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtZS5vd25lci50cmlnZ2VyKCdsb2FkJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1lLm93bmVyLnRyaWdnZXIoJ2xvYWQnKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH07XG4gICAgXG4gICAgICAgICAgICAgICAgaW1nLm9uZXJyb3IgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgbWUub3duZXIudHJpZ2dlcignZXJyb3InKTtcbiAgICAgICAgICAgICAgICB9O1xuICAgIFxuICAgICAgICAgICAgICAgIG1lLl9pbWcgPSBpbWc7XG4gICAgICAgICAgICB9LFxuICAgIFxuICAgICAgICAgICAgbG9hZEZyb21CbG9iOiBmdW5jdGlvbiggYmxvYiApIHtcbiAgICAgICAgICAgICAgICB2YXIgbWUgPSB0aGlzLFxuICAgICAgICAgICAgICAgICAgICBpbWcgPSBtZS5faW1nO1xuICAgIFxuICAgICAgICAgICAgICAgIG1lLl9ibG9iID0gYmxvYjtcbiAgICAgICAgICAgICAgICBtZS50eXBlID0gYmxvYi50eXBlO1xuICAgICAgICAgICAgICAgIGltZy5zcmMgPSBVdGlsLmNyZWF0ZU9iamVjdFVSTCggYmxvYi5nZXRTb3VyY2UoKSApO1xuICAgICAgICAgICAgICAgIG1lLm93bmVyLm9uY2UoICdsb2FkJywgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIFV0aWwucmV2b2tlT2JqZWN0VVJMKCBpbWcuc3JjICk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9LFxuICAgIFxuICAgICAgICAgICAgcmVzaXplOiBmdW5jdGlvbiggd2lkdGgsIGhlaWdodCApIHtcbiAgICAgICAgICAgICAgICB2YXIgY2FudmFzID0gdGhpcy5fY2FudmFzIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAodGhpcy5fY2FudmFzID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnY2FudmFzJykpO1xuICAgIFxuICAgICAgICAgICAgICAgIHRoaXMuX3Jlc2l6ZSggdGhpcy5faW1nLCBjYW52YXMsIHdpZHRoLCBoZWlnaHQgKTtcbiAgICAgICAgICAgICAgICB0aGlzLl9ibG9iID0gbnVsbDsgICAgLy8g5rKh55So5LqG77yM5Y+v5Lul5Yig5o6J5LqG44CCXG4gICAgICAgICAgICAgICAgdGhpcy5tb2RpZmllZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgdGhpcy5vd25lci50cmlnZ2VyKCAnY29tcGxldGUnLCAncmVzaXplJyApO1xuICAgICAgICAgICAgfSxcbiAgICBcbiAgICAgICAgICAgIGNyb3A6IGZ1bmN0aW9uKCB4LCB5LCB3LCBoLCBzICkge1xuICAgICAgICAgICAgICAgIHZhciBjdnMgPSB0aGlzLl9jYW52YXMgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgICh0aGlzLl9jYW52YXMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjYW52YXMnKSksXG4gICAgICAgICAgICAgICAgICAgIG9wdHMgPSB0aGlzLm9wdGlvbnMsXG4gICAgICAgICAgICAgICAgICAgIGltZyA9IHRoaXMuX2ltZyxcbiAgICAgICAgICAgICAgICAgICAgaXcgPSBpbWcubmF0dXJhbFdpZHRoLFxuICAgICAgICAgICAgICAgICAgICBpaCA9IGltZy5uYXR1cmFsSGVpZ2h0LFxuICAgICAgICAgICAgICAgICAgICBvcmllbnRhdGlvbiA9IHRoaXMuZ2V0T3JpZW50YXRpb24oKTtcbiAgICBcbiAgICAgICAgICAgICAgICBzID0gcyB8fCAxO1xuICAgIFxuICAgICAgICAgICAgICAgIC8vIHRvZG8g6Kej5YazIG9yaWVudGF0aW9uIOeahOmXrumimOOAglxuICAgICAgICAgICAgICAgIC8vIHZhbHVlcyB0aGF0IHJlcXVpcmUgOTAgZGVncmVlIHJvdGF0aW9uXG4gICAgICAgICAgICAgICAgLy8gaWYgKCB+WyA1LCA2LCA3LCA4IF0uaW5kZXhPZiggb3JpZW50YXRpb24gKSApIHtcbiAgICBcbiAgICAgICAgICAgICAgICAvLyAgICAgc3dpdGNoICggb3JpZW50YXRpb24gKSB7XG4gICAgICAgICAgICAgICAgLy8gICAgICAgICBjYXNlIDY6XG4gICAgICAgICAgICAgICAgLy8gICAgICAgICAgICAgdG1wID0geDtcbiAgICAgICAgICAgICAgICAvLyAgICAgICAgICAgICB4ID0geTtcbiAgICAgICAgICAgICAgICAvLyAgICAgICAgICAgICB5ID0gaXcgKiBzIC0gdG1wIC0gdztcbiAgICAgICAgICAgICAgICAvLyAgICAgICAgICAgICBjb25zb2xlLmxvZyhpaCAqIHMsIHRtcCwgdylcbiAgICAgICAgICAgICAgICAvLyAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAvLyAgICAgfVxuICAgIFxuICAgICAgICAgICAgICAgIC8vICAgICAodyBePSBoLCBoIF49IHcsIHcgXj0gaCk7XG4gICAgICAgICAgICAgICAgLy8gfVxuICAgIFxuICAgICAgICAgICAgICAgIGN2cy53aWR0aCA9IHc7XG4gICAgICAgICAgICAgICAgY3ZzLmhlaWdodCA9IGg7XG4gICAgXG4gICAgICAgICAgICAgICAgb3B0cy5wcmVzZXJ2ZUhlYWRlcnMgfHwgdGhpcy5fcm90YXRlMk9yaWVudGFpb24oIGN2cywgb3JpZW50YXRpb24gKTtcbiAgICAgICAgICAgICAgICB0aGlzLl9yZW5kZXJJbWFnZVRvQ2FudmFzKCBjdnMsIGltZywgLXgsIC15LCBpdyAqIHMsIGloICogcyApO1xuICAgIFxuICAgICAgICAgICAgICAgIHRoaXMuX2Jsb2IgPSBudWxsOyAgICAvLyDmsqHnlKjkuobvvIzlj6/ku6XliKDmjonkuobjgIJcbiAgICAgICAgICAgICAgICB0aGlzLm1vZGlmaWVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB0aGlzLm93bmVyLnRyaWdnZXIoICdjb21wbGV0ZScsICdjcm9wJyApO1xuICAgICAgICAgICAgfSxcbiAgICBcbiAgICAgICAgICAgIGdldEFzQmxvYjogZnVuY3Rpb24oIHR5cGUgKSB7XG4gICAgICAgICAgICAgICAgdmFyIGJsb2IgPSB0aGlzLl9ibG9iLFxuICAgICAgICAgICAgICAgICAgICBvcHRzID0gdGhpcy5vcHRpb25zLFxuICAgICAgICAgICAgICAgICAgICBjYW52YXM7XG4gICAgXG4gICAgICAgICAgICAgICAgdHlwZSA9IHR5cGUgfHwgdGhpcy50eXBlO1xuICAgIFxuICAgICAgICAgICAgICAgIC8vIGJsb2LpnIDopoHph43mlrDnlJ/miJDjgIJcbiAgICAgICAgICAgICAgICBpZiAoIHRoaXMubW9kaWZpZWQgfHwgdGhpcy50eXBlICE9PSB0eXBlICkge1xuICAgICAgICAgICAgICAgICAgICBjYW52YXMgPSB0aGlzLl9jYW52YXM7XG4gICAgXG4gICAgICAgICAgICAgICAgICAgIGlmICggdHlwZSA9PT0gJ2ltYWdlL2pwZWcnICkge1xuICAgIFxuICAgICAgICAgICAgICAgICAgICAgICAgYmxvYiA9IFV0aWwuY2FudmFzVG9EYXRhVXJsKCBjYW52YXMsIHR5cGUsIG9wdHMucXVhbGl0eSApO1xuICAgIFxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCBvcHRzLnByZXNlcnZlSGVhZGVycyAmJiB0aGlzLl9tZXRhcyAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9tZXRhcy5pbWFnZUhlYWQgKSB7XG4gICAgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYmxvYiA9IFV0aWwuZGF0YVVSTDJBcnJheUJ1ZmZlciggYmxvYiApO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJsb2IgPSBVdGlsLnVwZGF0ZUltYWdlSGVhZCggYmxvYixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX21ldGFzLmltYWdlSGVhZCApO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJsb2IgPSBVdGlsLmFycmF5QnVmZmVyVG9CbG9iKCBibG9iLCB0eXBlICk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGJsb2I7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBibG9iID0gVXRpbC5jYW52YXNUb0RhdGFVcmwoIGNhbnZhcywgdHlwZSApO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgXG4gICAgICAgICAgICAgICAgICAgIGJsb2IgPSBVdGlsLmRhdGFVUkwyQmxvYiggYmxvYiApO1xuICAgICAgICAgICAgICAgIH1cbiAgICBcbiAgICAgICAgICAgICAgICByZXR1cm4gYmxvYjtcbiAgICAgICAgICAgIH0sXG4gICAgXG4gICAgICAgICAgICBnZXRBc0RhdGFVcmw6IGZ1bmN0aW9uKCB0eXBlICkge1xuICAgICAgICAgICAgICAgIHZhciBvcHRzID0gdGhpcy5vcHRpb25zO1xuICAgIFxuICAgICAgICAgICAgICAgIHR5cGUgPSB0eXBlIHx8IHRoaXMudHlwZTtcbiAgICBcbiAgICAgICAgICAgICAgICBpZiAoIHR5cGUgPT09ICdpbWFnZS9qcGVnJyApIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFV0aWwuY2FudmFzVG9EYXRhVXJsKCB0aGlzLl9jYW52YXMsIHR5cGUsIG9wdHMucXVhbGl0eSApO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9jYW52YXMudG9EYXRhVVJMKCB0eXBlICk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICBcbiAgICAgICAgICAgIGdldE9yaWVudGF0aW9uOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fbWV0YXMgJiYgdGhpcy5fbWV0YXMuZXhpZiAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fbWV0YXMuZXhpZi5nZXQoJ09yaWVudGF0aW9uJykgfHwgMTtcbiAgICAgICAgICAgIH0sXG4gICAgXG4gICAgICAgICAgICBpbmZvOiBmdW5jdGlvbiggdmFsICkge1xuICAgIFxuICAgICAgICAgICAgICAgIC8vIHNldHRlclxuICAgICAgICAgICAgICAgIGlmICggdmFsICkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9pbmZvID0gdmFsO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgICAgICAgICB9XG4gICAgXG4gICAgICAgICAgICAgICAgLy8gZ2V0dGVyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2luZm87XG4gICAgICAgICAgICB9LFxuICAgIFxuICAgICAgICAgICAgbWV0YTogZnVuY3Rpb24oIHZhbCApIHtcbiAgICBcbiAgICAgICAgICAgICAgICAvLyBzZXR0ZXJcbiAgICAgICAgICAgICAgICBpZiAoIHZhbCApIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fbWV0YSA9IHZhbDtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgICAgICAgICAgfVxuICAgIFxuICAgICAgICAgICAgICAgIC8vIGdldHRlclxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9tZXRhO1xuICAgICAgICAgICAgfSxcbiAgICBcbiAgICAgICAgICAgIGRlc3Ryb3k6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHZhciBjYW52YXMgPSB0aGlzLl9jYW52YXM7XG4gICAgICAgICAgICAgICAgdGhpcy5faW1nLm9ubG9hZCA9IG51bGw7XG4gICAgXG4gICAgICAgICAgICAgICAgaWYgKCBjYW52YXMgKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhbnZhcy5nZXRDb250ZXh0KCcyZCcpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLmNsZWFyUmVjdCggMCwgMCwgY2FudmFzLndpZHRoLCBjYW52YXMuaGVpZ2h0ICk7XG4gICAgICAgICAgICAgICAgICAgIGNhbnZhcy53aWR0aCA9IGNhbnZhcy5oZWlnaHQgPSAwO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9jYW52YXMgPSBudWxsO1xuICAgICAgICAgICAgICAgIH1cbiAgICBcbiAgICAgICAgICAgICAgICAvLyDph4rmlL7lhoXlrZjjgILpnZ7luLjph43opoHvvIzlkKbliJnph4rmlL7kuI3kuoZpbWFnZeeahOWGheWtmOOAglxuICAgICAgICAgICAgICAgIHRoaXMuX2ltZy5zcmMgPSBCTEFOSztcbiAgICAgICAgICAgICAgICB0aGlzLl9pbWcgPSB0aGlzLl9ibG9iID0gbnVsbDtcbiAgICAgICAgICAgIH0sXG4gICAgXG4gICAgICAgICAgICBfcmVzaXplOiBmdW5jdGlvbiggaW1nLCBjdnMsIHdpZHRoLCBoZWlnaHQgKSB7XG4gICAgICAgICAgICAgICAgdmFyIG9wdHMgPSB0aGlzLm9wdGlvbnMsXG4gICAgICAgICAgICAgICAgICAgIG5hdHVyYWxXaWR0aCA9IGltZy53aWR0aCxcbiAgICAgICAgICAgICAgICAgICAgbmF0dXJhbEhlaWdodCA9IGltZy5oZWlnaHQsXG4gICAgICAgICAgICAgICAgICAgIG9yaWVudGF0aW9uID0gdGhpcy5nZXRPcmllbnRhdGlvbigpLFxuICAgICAgICAgICAgICAgICAgICBzY2FsZSwgdywgaCwgeCwgeTtcbiAgICBcbiAgICAgICAgICAgICAgICAvLyB2YWx1ZXMgdGhhdCByZXF1aXJlIDkwIGRlZ3JlZSByb3RhdGlvblxuICAgICAgICAgICAgICAgIGlmICggflsgNSwgNiwgNywgOCBdLmluZGV4T2YoIG9yaWVudGF0aW9uICkgKSB7XG4gICAgXG4gICAgICAgICAgICAgICAgICAgIC8vIOS6pOaNondpZHRoLCBoZWlnaHTnmoTlgLzjgIJcbiAgICAgICAgICAgICAgICAgICAgd2lkdGggXj0gaGVpZ2h0O1xuICAgICAgICAgICAgICAgICAgICBoZWlnaHQgXj0gd2lkdGg7XG4gICAgICAgICAgICAgICAgICAgIHdpZHRoIF49IGhlaWdodDtcbiAgICAgICAgICAgICAgICB9XG4gICAgXG4gICAgICAgICAgICAgICAgc2NhbGUgPSBNYXRoWyBvcHRzLmNyb3AgPyAnbWF4JyA6ICdtaW4nIF0oIHdpZHRoIC8gbmF0dXJhbFdpZHRoLFxuICAgICAgICAgICAgICAgICAgICAgICAgaGVpZ2h0IC8gbmF0dXJhbEhlaWdodCApO1xuICAgIFxuICAgICAgICAgICAgICAgIC8vIOS4jeWFgeiuuOaUvuWkp+OAglxuICAgICAgICAgICAgICAgIG9wdHMuYWxsb3dNYWduaWZ5IHx8IChzY2FsZSA9IE1hdGgubWluKCAxLCBzY2FsZSApKTtcbiAgICBcbiAgICAgICAgICAgICAgICB3ID0gbmF0dXJhbFdpZHRoICogc2NhbGU7XG4gICAgICAgICAgICAgICAgaCA9IG5hdHVyYWxIZWlnaHQgKiBzY2FsZTtcbiAgICBcbiAgICAgICAgICAgICAgICBpZiAoIG9wdHMuY3JvcCApIHtcbiAgICAgICAgICAgICAgICAgICAgY3ZzLndpZHRoID0gd2lkdGg7XG4gICAgICAgICAgICAgICAgICAgIGN2cy5oZWlnaHQgPSBoZWlnaHQ7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgY3ZzLndpZHRoID0gdztcbiAgICAgICAgICAgICAgICAgICAgY3ZzLmhlaWdodCA9IGg7XG4gICAgICAgICAgICAgICAgfVxuICAgIFxuICAgICAgICAgICAgICAgIHggPSAoY3ZzLndpZHRoIC0gdykgLyAyO1xuICAgICAgICAgICAgICAgIHkgPSAoY3ZzLmhlaWdodCAtIGgpIC8gMjtcbiAgICBcbiAgICAgICAgICAgICAgICBvcHRzLnByZXNlcnZlSGVhZGVycyB8fCB0aGlzLl9yb3RhdGUyT3JpZW50YWlvbiggY3ZzLCBvcmllbnRhdGlvbiApO1xuICAgIFxuICAgICAgICAgICAgICAgIHRoaXMuX3JlbmRlckltYWdlVG9DYW52YXMoIGN2cywgaW1nLCB4LCB5LCB3LCBoICk7XG4gICAgICAgICAgICB9LFxuICAgIFxuICAgICAgICAgICAgX3JvdGF0ZTJPcmllbnRhaW9uOiBmdW5jdGlvbiggY2FudmFzLCBvcmllbnRhdGlvbiApIHtcbiAgICAgICAgICAgICAgICB2YXIgd2lkdGggPSBjYW52YXMud2lkdGgsXG4gICAgICAgICAgICAgICAgICAgIGhlaWdodCA9IGNhbnZhcy5oZWlnaHQsXG4gICAgICAgICAgICAgICAgICAgIGN0eCA9IGNhbnZhcy5nZXRDb250ZXh0KCcyZCcpO1xuICAgIFxuICAgICAgICAgICAgICAgIHN3aXRjaCAoIG9yaWVudGF0aW9uICkge1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDU6XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgNjpcbiAgICAgICAgICAgICAgICAgICAgY2FzZSA3OlxuICAgICAgICAgICAgICAgICAgICBjYXNlIDg6XG4gICAgICAgICAgICAgICAgICAgICAgICBjYW52YXMud2lkdGggPSBoZWlnaHQ7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYW52YXMuaGVpZ2h0ID0gd2lkdGg7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgXG4gICAgICAgICAgICAgICAgc3dpdGNoICggb3JpZW50YXRpb24gKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMjogICAgLy8gaG9yaXpvbnRhbCBmbGlwXG4gICAgICAgICAgICAgICAgICAgICAgICBjdHgudHJhbnNsYXRlKCB3aWR0aCwgMCApO1xuICAgICAgICAgICAgICAgICAgICAgICAgY3R4LnNjYWxlKCAtMSwgMSApO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMzogICAgLy8gMTgwIHJvdGF0ZSBsZWZ0XG4gICAgICAgICAgICAgICAgICAgICAgICBjdHgudHJhbnNsYXRlKCB3aWR0aCwgaGVpZ2h0ICk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjdHgucm90YXRlKCBNYXRoLlBJICk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICBcbiAgICAgICAgICAgICAgICAgICAgY2FzZSA0OiAgICAvLyB2ZXJ0aWNhbCBmbGlwXG4gICAgICAgICAgICAgICAgICAgICAgICBjdHgudHJhbnNsYXRlKCAwLCBoZWlnaHQgKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGN0eC5zY2FsZSggMSwgLTEgKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgIFxuICAgICAgICAgICAgICAgICAgICBjYXNlIDU6ICAgIC8vIHZlcnRpY2FsIGZsaXAgKyA5MCByb3RhdGUgcmlnaHRcbiAgICAgICAgICAgICAgICAgICAgICAgIGN0eC5yb3RhdGUoIDAuNSAqIE1hdGguUEkgKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGN0eC5zY2FsZSggMSwgLTEgKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgIFxuICAgICAgICAgICAgICAgICAgICBjYXNlIDY6ICAgIC8vIDkwIHJvdGF0ZSByaWdodFxuICAgICAgICAgICAgICAgICAgICAgICAgY3R4LnJvdGF0ZSggMC41ICogTWF0aC5QSSApO1xuICAgICAgICAgICAgICAgICAgICAgICAgY3R4LnRyYW5zbGF0ZSggMCwgLWhlaWdodCApO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgNzogICAgLy8gaG9yaXpvbnRhbCBmbGlwICsgOTAgcm90YXRlIHJpZ2h0XG4gICAgICAgICAgICAgICAgICAgICAgICBjdHgucm90YXRlKCAwLjUgKiBNYXRoLlBJICk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjdHgudHJhbnNsYXRlKCB3aWR0aCwgLWhlaWdodCApO1xuICAgICAgICAgICAgICAgICAgICAgICAgY3R4LnNjYWxlKCAtMSwgMSApO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgODogICAgLy8gOTAgcm90YXRlIGxlZnRcbiAgICAgICAgICAgICAgICAgICAgICAgIGN0eC5yb3RhdGUoIC0wLjUgKiBNYXRoLlBJICk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjdHgudHJhbnNsYXRlKCAtd2lkdGgsIDAgKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgXG4gICAgICAgICAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vc3RvbWl0YS9pb3MtaW1hZ2VmaWxlLW1lZ2FwaXhlbC9cbiAgICAgICAgICAgIC8vIGJsb2IvbWFzdGVyL3NyYy9tZWdhcGl4LWltYWdlLmpzXG4gICAgICAgICAgICBfcmVuZGVySW1hZ2VUb0NhbnZhczogKGZ1bmN0aW9uKCkge1xuICAgIFxuICAgICAgICAgICAgICAgIC8vIOWmguaenOS4jeaYr2lvcywg5LiN6ZyA6KaB6L+Z5LmI5aSN5p2C77yBXG4gICAgICAgICAgICAgICAgaWYgKCAhQmFzZS5vcy5pb3MgKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiggY2FudmFzICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGFyZ3MgPSBCYXNlLnNsaWNlKCBhcmd1bWVudHMsIDEgKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdHggPSBjYW52YXMuZ2V0Q29udGV4dCgnMmQnKTtcbiAgICBcbiAgICAgICAgICAgICAgICAgICAgICAgIGN0eC5kcmF3SW1hZ2UuYXBwbHkoIGN0eCwgYXJncyApO1xuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICBcbiAgICAgICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAgICAgKiBEZXRlY3RpbmcgdmVydGljYWwgc3F1YXNoIGluIGxvYWRlZCBpbWFnZS5cbiAgICAgICAgICAgICAgICAgKiBGaXhlcyBhIGJ1ZyB3aGljaCBzcXVhc2ggaW1hZ2UgdmVydGljYWxseSB3aGlsZSBkcmF3aW5nIGludG9cbiAgICAgICAgICAgICAgICAgKiBjYW52YXMgZm9yIHNvbWUgaW1hZ2VzLlxuICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgIGZ1bmN0aW9uIGRldGVjdFZlcnRpY2FsU3F1YXNoKCBpbWcsIGl3LCBpaCApIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGNhbnZhcyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2NhbnZhcycpLFxuICAgICAgICAgICAgICAgICAgICAgICAgY3R4ID0gY2FudmFzLmdldENvbnRleHQoJzJkJyksXG4gICAgICAgICAgICAgICAgICAgICAgICBzeSA9IDAsXG4gICAgICAgICAgICAgICAgICAgICAgICBleSA9IGloLFxuICAgICAgICAgICAgICAgICAgICAgICAgcHkgPSBpaCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGRhdGEsIGFscGhhLCByYXRpbztcbiAgICBcbiAgICBcbiAgICAgICAgICAgICAgICAgICAgY2FudmFzLndpZHRoID0gMTtcbiAgICAgICAgICAgICAgICAgICAgY2FudmFzLmhlaWdodCA9IGloO1xuICAgICAgICAgICAgICAgICAgICBjdHguZHJhd0ltYWdlKCBpbWcsIDAsIDAgKTtcbiAgICAgICAgICAgICAgICAgICAgZGF0YSA9IGN0eC5nZXRJbWFnZURhdGEoIDAsIDAsIDEsIGloICkuZGF0YTtcbiAgICBcbiAgICAgICAgICAgICAgICAgICAgLy8gc2VhcmNoIGltYWdlIGVkZ2UgcGl4ZWwgcG9zaXRpb24gaW4gY2FzZVxuICAgICAgICAgICAgICAgICAgICAvLyBpdCBpcyBzcXVhc2hlZCB2ZXJ0aWNhbGx5LlxuICAgICAgICAgICAgICAgICAgICB3aGlsZSAoIHB5ID4gc3kgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhbHBoYSA9IGRhdGFbIChweSAtIDEpICogNCArIDMgXTtcbiAgICBcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICggYWxwaGEgPT09IDAgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZXkgPSBweTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3kgPSBweTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICBcbiAgICAgICAgICAgICAgICAgICAgICAgIHB5ID0gKGV5ICsgc3kpID4+IDE7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICBcbiAgICAgICAgICAgICAgICAgICAgcmF0aW8gPSAocHkgLyBpaCk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAocmF0aW8gPT09IDApID8gMSA6IHJhdGlvO1xuICAgICAgICAgICAgICAgIH1cbiAgICBcbiAgICAgICAgICAgICAgICAvLyBmaXggaWU3IGJ1Z1xuICAgICAgICAgICAgICAgIC8vIGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvMTE5MjkwOTkvXG4gICAgICAgICAgICAgICAgLy8gaHRtbDUtY2FudmFzLWRyYXdpbWFnZS1yYXRpby1idWctaW9zXG4gICAgICAgICAgICAgICAgaWYgKCBCYXNlLm9zLmlvcyA+PSA3ICkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24oIGNhbnZhcywgaW1nLCB4LCB5LCB3LCBoICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGl3ID0gaW1nLm5hdHVyYWxXaWR0aCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpaCA9IGltZy5uYXR1cmFsSGVpZ2h0LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZlcnRTcXVhc2hSYXRpbyA9IGRldGVjdFZlcnRpY2FsU3F1YXNoKCBpbWcsIGl3LCBpaCApO1xuICAgIFxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNhbnZhcy5nZXRDb250ZXh0KCcyZCcpLmRyYXdJbWFnZSggaW1nLCAwLCAwLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpdyAqIHZlcnRTcXVhc2hSYXRpbywgaWggKiB2ZXJ0U3F1YXNoUmF0aW8sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHgsIHksIHcsIGggKTtcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB9XG4gICAgXG4gICAgICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgICAgICogRGV0ZWN0IHN1YnNhbXBsaW5nIGluIGxvYWRlZCBpbWFnZS5cbiAgICAgICAgICAgICAgICAgKiBJbiBpT1MsIGxhcmdlciBpbWFnZXMgdGhhbiAyTSBwaXhlbHMgbWF5IGJlXG4gICAgICAgICAgICAgICAgICogc3Vic2FtcGxlZCBpbiByZW5kZXJpbmcuXG4gICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gZGV0ZWN0U3Vic2FtcGxpbmcoIGltZyApIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGl3ID0gaW1nLm5hdHVyYWxXaWR0aCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGloID0gaW1nLm5hdHVyYWxIZWlnaHQsXG4gICAgICAgICAgICAgICAgICAgICAgICBjYW52YXMsIGN0eDtcbiAgICBcbiAgICAgICAgICAgICAgICAgICAgLy8gc3Vic2FtcGxpbmcgbWF5IGhhcHBlbiBvdmVybWVnYXBpeGVsIGltYWdlXG4gICAgICAgICAgICAgICAgICAgIGlmICggaXcgKiBpaCA+IDEwMjQgKiAxMDI0ICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FudmFzID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnY2FudmFzJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYW52YXMud2lkdGggPSBjYW52YXMuaGVpZ2h0ID0gMTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGN0eCA9IGNhbnZhcy5nZXRDb250ZXh0KCcyZCcpO1xuICAgICAgICAgICAgICAgICAgICAgICAgY3R4LmRyYXdJbWFnZSggaW1nLCAtaXcgKyAxLCAwICk7XG4gICAgXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBzdWJzYW1wbGVkIGltYWdlIGJlY29tZXMgaGFsZiBzbWFsbGVyIGluIHJlbmRlcmluZyBzaXplLlxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gY2hlY2sgYWxwaGEgY2hhbm5lbCB2YWx1ZSB0byBjb25maXJtIGltYWdlIGlzIGNvdmVyaW5nXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBlZGdlIHBpeGVsIG9yIG5vdC4gaWYgYWxwaGEgdmFsdWUgaXMgMFxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gaW1hZ2UgaXMgbm90IGNvdmVyaW5nLCBoZW5jZSBzdWJzYW1wbGVkLlxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGN0eC5nZXRJbWFnZURhdGEoIDAsIDAsIDEsIDEgKS5kYXRhWyAzIF0gPT09IDA7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgXG4gICAgXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKCBjYW52YXMsIGltZywgeCwgeSwgd2lkdGgsIGhlaWdodCApIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGl3ID0gaW1nLm5hdHVyYWxXaWR0aCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGloID0gaW1nLm5hdHVyYWxIZWlnaHQsXG4gICAgICAgICAgICAgICAgICAgICAgICBjdHggPSBjYW52YXMuZ2V0Q29udGV4dCgnMmQnKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHN1YnNhbXBsZWQgPSBkZXRlY3RTdWJzYW1wbGluZyggaW1nICksXG4gICAgICAgICAgICAgICAgICAgICAgICBkb1NxdWFzaCA9IHRoaXMudHlwZSA9PT0gJ2ltYWdlL2pwZWcnLFxuICAgICAgICAgICAgICAgICAgICAgICAgZCA9IDEwMjQsXG4gICAgICAgICAgICAgICAgICAgICAgICBzeSA9IDAsXG4gICAgICAgICAgICAgICAgICAgICAgICBkeSA9IDAsXG4gICAgICAgICAgICAgICAgICAgICAgICB0bXBDYW52YXMsIHRtcEN0eCwgdmVydFNxdWFzaFJhdGlvLCBkdywgZGgsIHN4LCBkeDtcbiAgICBcbiAgICAgICAgICAgICAgICAgICAgaWYgKCBzdWJzYW1wbGVkICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaXcgLz0gMjtcbiAgICAgICAgICAgICAgICAgICAgICAgIGloIC89IDI7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICBcbiAgICAgICAgICAgICAgICAgICAgY3R4LnNhdmUoKTtcbiAgICAgICAgICAgICAgICAgICAgdG1wQ2FudmFzID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnY2FudmFzJyk7XG4gICAgICAgICAgICAgICAgICAgIHRtcENhbnZhcy53aWR0aCA9IHRtcENhbnZhcy5oZWlnaHQgPSBkO1xuICAgIFxuICAgICAgICAgICAgICAgICAgICB0bXBDdHggPSB0bXBDYW52YXMuZ2V0Q29udGV4dCgnMmQnKTtcbiAgICAgICAgICAgICAgICAgICAgdmVydFNxdWFzaFJhdGlvID0gZG9TcXVhc2ggP1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRldGVjdFZlcnRpY2FsU3F1YXNoKCBpbWcsIGl3LCBpaCApIDogMTtcbiAgICBcbiAgICAgICAgICAgICAgICAgICAgZHcgPSBNYXRoLmNlaWwoIGQgKiB3aWR0aCAvIGl3ICk7XG4gICAgICAgICAgICAgICAgICAgIGRoID0gTWF0aC5jZWlsKCBkICogaGVpZ2h0IC8gaWggLyB2ZXJ0U3F1YXNoUmF0aW8gKTtcbiAgICBcbiAgICAgICAgICAgICAgICAgICAgd2hpbGUgKCBzeSA8IGloICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgc3ggPSAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgZHggPSAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgd2hpbGUgKCBzeCA8IGl3ICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRtcEN0eC5jbGVhclJlY3QoIDAsIDAsIGQsIGQgKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0bXBDdHguZHJhd0ltYWdlKCBpbWcsIC1zeCwgLXN5ICk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY3R4LmRyYXdJbWFnZSggdG1wQ2FudmFzLCAwLCAwLCBkLCBkLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgeCArIGR4LCB5ICsgZHksIGR3LCBkaCApO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN4ICs9IGQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZHggKz0gZHc7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBzeSArPSBkO1xuICAgICAgICAgICAgICAgICAgICAgICAgZHkgKz0gZGg7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY3R4LnJlc3RvcmUoKTtcbiAgICAgICAgICAgICAgICAgICAgdG1wQ2FudmFzID0gdG1wQ3R4ID0gbnVsbDtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfSkoKVxuICAgICAgICB9KTtcbiAgICB9KTtcbiAgICAvKipcbiAgICAgKiBAZmlsZU92ZXJ2aWV3IFRyYW5zcG9ydFxuICAgICAqIEB0b2RvIOaUr+aMgWNodW5rZWTkvKDovpPvvIzkvJjlir/vvJpcbiAgICAgKiDlj6/ku6XlsIblpKfmlofku7bliIbmiJDlsI/lnZfvvIzmjKjkuKrkvKDovpPvvIzlj6/ku6Xmj5Dpq5jlpKfmlofku7bmiJDlip/njofvvIzlvZPlpLHotKXnmoTml7blgJnvvIzkuZ/lj6rpnIDopoHph43kvKDpgqPlsI/pg6jliIbvvIxcbiAgICAgKiDogIzkuI3pnIDopoHph43lpLTlho3kvKDkuIDmrKHjgILlj6blpJbmlq3ngrnnu63kvKDkuZ/pnIDopoHnlKhjaHVua2Vk5pa55byP44CCXG4gICAgICovXG4gICAgZGVmaW5lKCdydW50aW1lL2h0bWw1L3RyYW5zcG9ydCcsW1xuICAgICAgICAnYmFzZScsXG4gICAgICAgICdydW50aW1lL2h0bWw1L3J1bnRpbWUnXG4gICAgXSwgZnVuY3Rpb24oIEJhc2UsIEh0bWw1UnVudGltZSApIHtcbiAgICBcbiAgICAgICAgdmFyIG5vb3AgPSBCYXNlLm5vb3AsXG4gICAgICAgICAgICAkID0gQmFzZS4kO1xuICAgIFxuICAgICAgICByZXR1cm4gSHRtbDVSdW50aW1lLnJlZ2lzdGVyKCAnVHJhbnNwb3J0Jywge1xuICAgICAgICAgICAgaW5pdDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fc3RhdHVzID0gMDtcbiAgICAgICAgICAgICAgICB0aGlzLl9yZXNwb25zZSA9IG51bGw7XG4gICAgICAgICAgICB9LFxuICAgIFxuICAgICAgICAgICAgc2VuZDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgdmFyIG93bmVyID0gdGhpcy5vd25lcixcbiAgICAgICAgICAgICAgICAgICAgb3B0cyA9IHRoaXMub3B0aW9ucyxcbiAgICAgICAgICAgICAgICAgICAgeGhyID0gdGhpcy5faW5pdEFqYXgoKSxcbiAgICAgICAgICAgICAgICAgICAgYmxvYiA9IG93bmVyLl9ibG9iLFxuICAgICAgICAgICAgICAgICAgICBzZXJ2ZXIgPSBvcHRzLnNlcnZlcixcbiAgICAgICAgICAgICAgICAgICAgZm9ybURhdGEsIGJpbmFyeSwgZnI7XG4gICAgXG4gICAgICAgICAgICAgICAgaWYgKCBvcHRzLnNlbmRBc0JpbmFyeSApIHtcbiAgICAgICAgICAgICAgICAgICAgc2VydmVyICs9ICgvXFw/Ly50ZXN0KCBzZXJ2ZXIgKSA/ICcmJyA6ICc/JykgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICQucGFyYW0oIG93bmVyLl9mb3JtRGF0YSApO1xuICAgIFxuICAgICAgICAgICAgICAgICAgICBiaW5hcnkgPSBibG9iLmdldFNvdXJjZSgpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGZvcm1EYXRhID0gbmV3IEZvcm1EYXRhKCk7XG4gICAgICAgICAgICAgICAgICAgICQuZWFjaCggb3duZXIuX2Zvcm1EYXRhLCBmdW5jdGlvbiggaywgdiApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvcm1EYXRhLmFwcGVuZCggaywgdiApO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICBcbiAgICAgICAgICAgICAgICAgICAgZm9ybURhdGEuYXBwZW5kKCBvcHRzLmZpbGVWYWwsIGJsb2IuZ2V0U291cmNlKCksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb3B0cy5maWxlbmFtZSB8fCBvd25lci5fZm9ybURhdGEubmFtZSB8fCAnJyApO1xuICAgICAgICAgICAgICAgIH1cbiAgICBcbiAgICAgICAgICAgICAgICBpZiAoIG9wdHMud2l0aENyZWRlbnRpYWxzICYmICd3aXRoQ3JlZGVudGlhbHMnIGluIHhociApIHtcbiAgICAgICAgICAgICAgICAgICAgeGhyLm9wZW4oIG9wdHMubWV0aG9kLCBzZXJ2ZXIsIHRydWUgKTtcbiAgICAgICAgICAgICAgICAgICAgeGhyLndpdGhDcmVkZW50aWFscyA9IHRydWU7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgeGhyLm9wZW4oIG9wdHMubWV0aG9kLCBzZXJ2ZXIgKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgXG4gICAgICAgICAgICAgICAgdGhpcy5fc2V0UmVxdWVzdEhlYWRlciggeGhyLCBvcHRzLmhlYWRlcnMgKTtcbiAgICBcbiAgICAgICAgICAgICAgICBpZiAoIGJpbmFyeSApIHtcbiAgICAgICAgICAgICAgICAgICAgLy8g5by65Yi26K6+572u5oiQIGNvbnRlbnQtdHlwZSDkuLrmlofku7bmtYHjgIJcbiAgICAgICAgICAgICAgICAgICAgeGhyLm92ZXJyaWRlTWltZVR5cGUgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB4aHIub3ZlcnJpZGVNaW1lVHlwZSgnYXBwbGljYXRpb24vb2N0ZXQtc3RyZWFtJyk7XG4gICAgXG4gICAgICAgICAgICAgICAgICAgIC8vIGFuZHJvaWTnm7TmjqXlj5HpgIFibG9i5Lya5a+86Ie05pyN5Yqh56uv5o6l5pS25Yiw55qE5piv56m65paH5Lu244CCXG4gICAgICAgICAgICAgICAgICAgIC8vIGJ1Z+ivpuaDheOAglxuICAgICAgICAgICAgICAgICAgICAvLyBodHRwczovL2NvZGUuZ29vZ2xlLmNvbS9wL2FuZHJvaWQvaXNzdWVzL2RldGFpbD9pZD0zOTg4MlxuICAgICAgICAgICAgICAgICAgICAvLyDmiYDku6XlhYjnlKhmaWxlUmVhZGVy6K+75Y+W5Ye65p2l5YaN6YCa6L+HYXJyYXlidWZmZXLnmoTmlrnlvI/lj5HpgIHjgIJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCBCYXNlLm9zLmFuZHJvaWQgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBmciA9IG5ldyBGaWxlUmVhZGVyKCk7XG4gICAgXG4gICAgICAgICAgICAgICAgICAgICAgICBmci5vbmxvYWQgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB4aHIuc2VuZCggdGhpcy5yZXN1bHQgKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmciA9IGZyLm9ubG9hZCA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgIFxuICAgICAgICAgICAgICAgICAgICAgICAgZnIucmVhZEFzQXJyYXlCdWZmZXIoIGJpbmFyeSApO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgeGhyLnNlbmQoIGJpbmFyeSApO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgeGhyLnNlbmQoIGZvcm1EYXRhICk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICBcbiAgICAgICAgICAgIGdldFJlc3BvbnNlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fcmVzcG9uc2U7XG4gICAgICAgICAgICB9LFxuICAgIFxuICAgICAgICAgICAgZ2V0UmVzcG9uc2VBc0pzb246IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9wYXJzZUpzb24oIHRoaXMuX3Jlc3BvbnNlICk7XG4gICAgICAgICAgICB9LFxuICAgIFxuICAgICAgICAgICAgZ2V0U3RhdHVzOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fc3RhdHVzO1xuICAgICAgICAgICAgfSxcbiAgICBcbiAgICAgICAgICAgIGFib3J0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICB2YXIgeGhyID0gdGhpcy5feGhyO1xuICAgIFxuICAgICAgICAgICAgICAgIGlmICggeGhyICkge1xuICAgICAgICAgICAgICAgICAgICB4aHIudXBsb2FkLm9ucHJvZ3Jlc3MgPSBub29wO1xuICAgICAgICAgICAgICAgICAgICB4aHIub25yZWFkeXN0YXRlY2hhbmdlID0gbm9vcDtcbiAgICAgICAgICAgICAgICAgICAgeGhyLmFib3J0KCk7XG4gICAgXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3hociA9IHhociA9IG51bGw7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICBcbiAgICAgICAgICAgIGRlc3Ryb3k6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHRoaXMuYWJvcnQoKTtcbiAgICAgICAgICAgIH0sXG4gICAgXG4gICAgICAgICAgICBfaW5pdEFqYXg6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHZhciBtZSA9IHRoaXMsXG4gICAgICAgICAgICAgICAgICAgIHhociA9IG5ldyBYTUxIdHRwUmVxdWVzdCgpLFxuICAgICAgICAgICAgICAgICAgICBvcHRzID0gdGhpcy5vcHRpb25zO1xuICAgIFxuICAgICAgICAgICAgICAgIGlmICggb3B0cy53aXRoQ3JlZGVudGlhbHMgJiYgISgnd2l0aENyZWRlbnRpYWxzJyBpbiB4aHIpICYmXG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlb2YgWERvbWFpblJlcXVlc3QgIT09ICd1bmRlZmluZWQnICkge1xuICAgICAgICAgICAgICAgICAgICB4aHIgPSBuZXcgWERvbWFpblJlcXVlc3QoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgXG4gICAgICAgICAgICAgICAgeGhyLnVwbG9hZC5vbnByb2dyZXNzID0gZnVuY3Rpb24oIGUgKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBwZXJjZW50YWdlID0gMDtcbiAgICBcbiAgICAgICAgICAgICAgICAgICAgaWYgKCBlLmxlbmd0aENvbXB1dGFibGUgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwZXJjZW50YWdlID0gZS5sb2FkZWQgLyBlLnRvdGFsO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBtZS50cmlnZ2VyKCAncHJvZ3Jlc3MnLCBwZXJjZW50YWdlICk7XG4gICAgICAgICAgICAgICAgfTtcbiAgICBcbiAgICAgICAgICAgICAgICB4aHIub25yZWFkeXN0YXRlY2hhbmdlID0gZnVuY3Rpb24oKSB7XG4gICAgXG4gICAgICAgICAgICAgICAgICAgIGlmICggeGhyLnJlYWR5U3RhdGUgIT09IDQgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICBcbiAgICAgICAgICAgICAgICAgICAgeGhyLnVwbG9hZC5vbnByb2dyZXNzID0gbm9vcDtcbiAgICAgICAgICAgICAgICAgICAgeGhyLm9ucmVhZHlzdGF0ZWNoYW5nZSA9IG5vb3A7XG4gICAgICAgICAgICAgICAgICAgIG1lLl94aHIgPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICBtZS5fc3RhdHVzID0geGhyLnN0YXR1cztcbiAgICBcbiAgICAgICAgICAgICAgICAgICAgaWYgKCB4aHIuc3RhdHVzID49IDIwMCAmJiB4aHIuc3RhdHVzIDwgMzAwICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbWUuX3Jlc3BvbnNlID0geGhyLnJlc3BvbnNlVGV4dDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBtZS50cmlnZ2VyKCdsb2FkJyk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoIHhoci5zdGF0dXMgPj0gNTAwICYmIHhoci5zdGF0dXMgPCA2MDAgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBtZS5fcmVzcG9uc2UgPSB4aHIucmVzcG9uc2VUZXh0O1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG1lLnRyaWdnZXIoICdlcnJvcicsICdzZXJ2ZXInICk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICBcbiAgICBcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG1lLnRyaWdnZXIoICdlcnJvcicsIG1lLl9zdGF0dXMgPyAnaHR0cCcgOiAnYWJvcnQnICk7XG4gICAgICAgICAgICAgICAgfTtcbiAgICBcbiAgICAgICAgICAgICAgICBtZS5feGhyID0geGhyO1xuICAgICAgICAgICAgICAgIHJldHVybiB4aHI7XG4gICAgICAgICAgICB9LFxuICAgIFxuICAgICAgICAgICAgX3NldFJlcXVlc3RIZWFkZXI6IGZ1bmN0aW9uKCB4aHIsIGhlYWRlcnMgKSB7XG4gICAgICAgICAgICAgICAgJC5lYWNoKCBoZWFkZXJzLCBmdW5jdGlvbigga2V5LCB2YWwgKSB7XG4gICAgICAgICAgICAgICAgICAgIHhoci5zZXRSZXF1ZXN0SGVhZGVyKCBrZXksIHZhbCApO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSxcbiAgICBcbiAgICAgICAgICAgIF9wYXJzZUpzb246IGZ1bmN0aW9uKCBzdHIgKSB7XG4gICAgICAgICAgICAgICAgdmFyIGpzb247XG4gICAgXG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAganNvbiA9IEpTT04ucGFyc2UoIHN0ciApO1xuICAgICAgICAgICAgICAgIH0gY2F0Y2ggKCBleCApIHtcbiAgICAgICAgICAgICAgICAgICAganNvbiA9IHt9O1xuICAgICAgICAgICAgICAgIH1cbiAgICBcbiAgICAgICAgICAgICAgICByZXR1cm4ganNvbjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfSk7XG4gICAgLyoqXG4gICAgICogQGZpbGVPdmVydmlldyAgVHJhbnNwb3J0IGZsYXNo5a6e546wXG4gICAgICovXG4gICAgZGVmaW5lKCdydW50aW1lL2h0bWw1L21kNScsW1xuICAgICAgICAncnVudGltZS9odG1sNS9ydW50aW1lJ1xuICAgIF0sIGZ1bmN0aW9uKCBGbGFzaFJ1bnRpbWUgKSB7XG4gICAgXG4gICAgICAgIC8qXG4gICAgICAgICAqIEZhc3Rlc3QgbWQ1IGltcGxlbWVudGF0aW9uIGFyb3VuZCAoSktNIG1kNSlcbiAgICAgICAgICogQ3JlZGl0czogSm9zZXBoIE15ZXJzXG4gICAgICAgICAqXG4gICAgICAgICAqIEBzZWUgaHR0cDovL3d3dy5teWVyc2RhaWx5Lm9yZy9qb3NlcGgvamF2YXNjcmlwdC9tZDUtdGV4dC5odG1sXG4gICAgICAgICAqIEBzZWUgaHR0cDovL2pzcGVyZi5jb20vbWQ1LXNob290b3V0LzdcbiAgICAgICAgICovXG4gICAgXG4gICAgICAgIC8qIHRoaXMgZnVuY3Rpb24gaXMgbXVjaCBmYXN0ZXIsXG4gICAgICAgICAgc28gaWYgcG9zc2libGUgd2UgdXNlIGl0LiBTb21lIElFc1xuICAgICAgICAgIGFyZSB0aGUgb25seSBvbmVzIEkga25vdyBvZiB0aGF0XG4gICAgICAgICAgbmVlZCB0aGUgaWRpb3RpYyBzZWNvbmQgZnVuY3Rpb24sXG4gICAgICAgICAgZ2VuZXJhdGVkIGJ5IGFuIGlmIGNsYXVzZS4gICovXG4gICAgICAgIHZhciBhZGQzMiA9IGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICAgICAgICByZXR1cm4gKGEgKyBiKSAmIDB4RkZGRkZGRkY7XG4gICAgICAgIH0sXG4gICAgXG4gICAgICAgIGNtbiA9IGZ1bmN0aW9uIChxLCBhLCBiLCB4LCBzLCB0KSB7XG4gICAgICAgICAgICBhID0gYWRkMzIoYWRkMzIoYSwgcSksIGFkZDMyKHgsIHQpKTtcbiAgICAgICAgICAgIHJldHVybiBhZGQzMigoYSA8PCBzKSB8IChhID4+PiAoMzIgLSBzKSksIGIpO1xuICAgICAgICB9LFxuICAgIFxuICAgICAgICBmZiA9IGZ1bmN0aW9uIChhLCBiLCBjLCBkLCB4LCBzLCB0KSB7XG4gICAgICAgICAgICByZXR1cm4gY21uKChiICYgYykgfCAoKH5iKSAmIGQpLCBhLCBiLCB4LCBzLCB0KTtcbiAgICAgICAgfSxcbiAgICBcbiAgICAgICAgZ2cgPSBmdW5jdGlvbiAoYSwgYiwgYywgZCwgeCwgcywgdCkge1xuICAgICAgICAgICAgcmV0dXJuIGNtbigoYiAmIGQpIHwgKGMgJiAofmQpKSwgYSwgYiwgeCwgcywgdCk7XG4gICAgICAgIH0sXG4gICAgXG4gICAgICAgIGhoID0gZnVuY3Rpb24gKGEsIGIsIGMsIGQsIHgsIHMsIHQpIHtcbiAgICAgICAgICAgIHJldHVybiBjbW4oYiBeIGMgXiBkLCBhLCBiLCB4LCBzLCB0KTtcbiAgICAgICAgfSxcbiAgICBcbiAgICAgICAgaWkgPSBmdW5jdGlvbiAoYSwgYiwgYywgZCwgeCwgcywgdCkge1xuICAgICAgICAgICAgcmV0dXJuIGNtbihjIF4gKGIgfCAofmQpKSwgYSwgYiwgeCwgcywgdCk7XG4gICAgICAgIH0sXG4gICAgXG4gICAgICAgIG1kNWN5Y2xlID0gZnVuY3Rpb24gKHgsIGspIHtcbiAgICAgICAgICAgIHZhciBhID0geFswXSxcbiAgICAgICAgICAgICAgICBiID0geFsxXSxcbiAgICAgICAgICAgICAgICBjID0geFsyXSxcbiAgICAgICAgICAgICAgICBkID0geFszXTtcbiAgICBcbiAgICAgICAgICAgIGEgPSBmZihhLCBiLCBjLCBkLCBrWzBdLCA3LCAtNjgwODc2OTM2KTtcbiAgICAgICAgICAgIGQgPSBmZihkLCBhLCBiLCBjLCBrWzFdLCAxMiwgLTM4OTU2NDU4Nik7XG4gICAgICAgICAgICBjID0gZmYoYywgZCwgYSwgYiwga1syXSwgMTcsIDYwNjEwNTgxOSk7XG4gICAgICAgICAgICBiID0gZmYoYiwgYywgZCwgYSwga1szXSwgMjIsIC0xMDQ0NTI1MzMwKTtcbiAgICAgICAgICAgIGEgPSBmZihhLCBiLCBjLCBkLCBrWzRdLCA3LCAtMTc2NDE4ODk3KTtcbiAgICAgICAgICAgIGQgPSBmZihkLCBhLCBiLCBjLCBrWzVdLCAxMiwgMTIwMDA4MDQyNik7XG4gICAgICAgICAgICBjID0gZmYoYywgZCwgYSwgYiwga1s2XSwgMTcsIC0xNDczMjMxMzQxKTtcbiAgICAgICAgICAgIGIgPSBmZihiLCBjLCBkLCBhLCBrWzddLCAyMiwgLTQ1NzA1OTgzKTtcbiAgICAgICAgICAgIGEgPSBmZihhLCBiLCBjLCBkLCBrWzhdLCA3LCAxNzcwMDM1NDE2KTtcbiAgICAgICAgICAgIGQgPSBmZihkLCBhLCBiLCBjLCBrWzldLCAxMiwgLTE5NTg0MTQ0MTcpO1xuICAgICAgICAgICAgYyA9IGZmKGMsIGQsIGEsIGIsIGtbMTBdLCAxNywgLTQyMDYzKTtcbiAgICAgICAgICAgIGIgPSBmZihiLCBjLCBkLCBhLCBrWzExXSwgMjIsIC0xOTkwNDA0MTYyKTtcbiAgICAgICAgICAgIGEgPSBmZihhLCBiLCBjLCBkLCBrWzEyXSwgNywgMTgwNDYwMzY4Mik7XG4gICAgICAgICAgICBkID0gZmYoZCwgYSwgYiwgYywga1sxM10sIDEyLCAtNDAzNDExMDEpO1xuICAgICAgICAgICAgYyA9IGZmKGMsIGQsIGEsIGIsIGtbMTRdLCAxNywgLTE1MDIwMDIyOTApO1xuICAgICAgICAgICAgYiA9IGZmKGIsIGMsIGQsIGEsIGtbMTVdLCAyMiwgMTIzNjUzNTMyOSk7XG4gICAgXG4gICAgICAgICAgICBhID0gZ2coYSwgYiwgYywgZCwga1sxXSwgNSwgLTE2NTc5NjUxMCk7XG4gICAgICAgICAgICBkID0gZ2coZCwgYSwgYiwgYywga1s2XSwgOSwgLTEwNjk1MDE2MzIpO1xuICAgICAgICAgICAgYyA9IGdnKGMsIGQsIGEsIGIsIGtbMTFdLCAxNCwgNjQzNzE3NzEzKTtcbiAgICAgICAgICAgIGIgPSBnZyhiLCBjLCBkLCBhLCBrWzBdLCAyMCwgLTM3Mzg5NzMwMik7XG4gICAgICAgICAgICBhID0gZ2coYSwgYiwgYywgZCwga1s1XSwgNSwgLTcwMTU1ODY5MSk7XG4gICAgICAgICAgICBkID0gZ2coZCwgYSwgYiwgYywga1sxMF0sIDksIDM4MDE2MDgzKTtcbiAgICAgICAgICAgIGMgPSBnZyhjLCBkLCBhLCBiLCBrWzE1XSwgMTQsIC02NjA0NzgzMzUpO1xuICAgICAgICAgICAgYiA9IGdnKGIsIGMsIGQsIGEsIGtbNF0sIDIwLCAtNDA1NTM3ODQ4KTtcbiAgICAgICAgICAgIGEgPSBnZyhhLCBiLCBjLCBkLCBrWzldLCA1LCA1Njg0NDY0MzgpO1xuICAgICAgICAgICAgZCA9IGdnKGQsIGEsIGIsIGMsIGtbMTRdLCA5LCAtMTAxOTgwMzY5MCk7XG4gICAgICAgICAgICBjID0gZ2coYywgZCwgYSwgYiwga1szXSwgMTQsIC0xODczNjM5NjEpO1xuICAgICAgICAgICAgYiA9IGdnKGIsIGMsIGQsIGEsIGtbOF0sIDIwLCAxMTYzNTMxNTAxKTtcbiAgICAgICAgICAgIGEgPSBnZyhhLCBiLCBjLCBkLCBrWzEzXSwgNSwgLTE0NDQ2ODE0NjcpO1xuICAgICAgICAgICAgZCA9IGdnKGQsIGEsIGIsIGMsIGtbMl0sIDksIC01MTQwMzc4NCk7XG4gICAgICAgICAgICBjID0gZ2coYywgZCwgYSwgYiwga1s3XSwgMTQsIDE3MzUzMjg0NzMpO1xuICAgICAgICAgICAgYiA9IGdnKGIsIGMsIGQsIGEsIGtbMTJdLCAyMCwgLTE5MjY2MDc3MzQpO1xuICAgIFxuICAgICAgICAgICAgYSA9IGhoKGEsIGIsIGMsIGQsIGtbNV0sIDQsIC0zNzg1NTgpO1xuICAgICAgICAgICAgZCA9IGhoKGQsIGEsIGIsIGMsIGtbOF0sIDExLCAtMjAyMjU3NDQ2Myk7XG4gICAgICAgICAgICBjID0gaGgoYywgZCwgYSwgYiwga1sxMV0sIDE2LCAxODM5MDMwNTYyKTtcbiAgICAgICAgICAgIGIgPSBoaChiLCBjLCBkLCBhLCBrWzE0XSwgMjMsIC0zNTMwOTU1Nik7XG4gICAgICAgICAgICBhID0gaGgoYSwgYiwgYywgZCwga1sxXSwgNCwgLTE1MzA5OTIwNjApO1xuICAgICAgICAgICAgZCA9IGhoKGQsIGEsIGIsIGMsIGtbNF0sIDExLCAxMjcyODkzMzUzKTtcbiAgICAgICAgICAgIGMgPSBoaChjLCBkLCBhLCBiLCBrWzddLCAxNiwgLTE1NTQ5NzYzMik7XG4gICAgICAgICAgICBiID0gaGgoYiwgYywgZCwgYSwga1sxMF0sIDIzLCAtMTA5NDczMDY0MCk7XG4gICAgICAgICAgICBhID0gaGgoYSwgYiwgYywgZCwga1sxM10sIDQsIDY4MTI3OTE3NCk7XG4gICAgICAgICAgICBkID0gaGgoZCwgYSwgYiwgYywga1swXSwgMTEsIC0zNTg1MzcyMjIpO1xuICAgICAgICAgICAgYyA9IGhoKGMsIGQsIGEsIGIsIGtbM10sIDE2LCAtNzIyNTIxOTc5KTtcbiAgICAgICAgICAgIGIgPSBoaChiLCBjLCBkLCBhLCBrWzZdLCAyMywgNzYwMjkxODkpO1xuICAgICAgICAgICAgYSA9IGhoKGEsIGIsIGMsIGQsIGtbOV0sIDQsIC02NDAzNjQ0ODcpO1xuICAgICAgICAgICAgZCA9IGhoKGQsIGEsIGIsIGMsIGtbMTJdLCAxMSwgLTQyMTgxNTgzNSk7XG4gICAgICAgICAgICBjID0gaGgoYywgZCwgYSwgYiwga1sxNV0sIDE2LCA1MzA3NDI1MjApO1xuICAgICAgICAgICAgYiA9IGhoKGIsIGMsIGQsIGEsIGtbMl0sIDIzLCAtOTk1MzM4NjUxKTtcbiAgICBcbiAgICAgICAgICAgIGEgPSBpaShhLCBiLCBjLCBkLCBrWzBdLCA2LCAtMTk4NjMwODQ0KTtcbiAgICAgICAgICAgIGQgPSBpaShkLCBhLCBiLCBjLCBrWzddLCAxMCwgMTEyNjg5MTQxNSk7XG4gICAgICAgICAgICBjID0gaWkoYywgZCwgYSwgYiwga1sxNF0sIDE1LCAtMTQxNjM1NDkwNSk7XG4gICAgICAgICAgICBiID0gaWkoYiwgYywgZCwgYSwga1s1XSwgMjEsIC01NzQzNDA1NSk7XG4gICAgICAgICAgICBhID0gaWkoYSwgYiwgYywgZCwga1sxMl0sIDYsIDE3MDA0ODU1NzEpO1xuICAgICAgICAgICAgZCA9IGlpKGQsIGEsIGIsIGMsIGtbM10sIDEwLCAtMTg5NDk4NjYwNik7XG4gICAgICAgICAgICBjID0gaWkoYywgZCwgYSwgYiwga1sxMF0sIDE1LCAtMTA1MTUyMyk7XG4gICAgICAgICAgICBiID0gaWkoYiwgYywgZCwgYSwga1sxXSwgMjEsIC0yMDU0OTIyNzk5KTtcbiAgICAgICAgICAgIGEgPSBpaShhLCBiLCBjLCBkLCBrWzhdLCA2LCAxODczMzEzMzU5KTtcbiAgICAgICAgICAgIGQgPSBpaShkLCBhLCBiLCBjLCBrWzE1XSwgMTAsIC0zMDYxMTc0NCk7XG4gICAgICAgICAgICBjID0gaWkoYywgZCwgYSwgYiwga1s2XSwgMTUsIC0xNTYwMTk4MzgwKTtcbiAgICAgICAgICAgIGIgPSBpaShiLCBjLCBkLCBhLCBrWzEzXSwgMjEsIDEzMDkxNTE2NDkpO1xuICAgICAgICAgICAgYSA9IGlpKGEsIGIsIGMsIGQsIGtbNF0sIDYsIC0xNDU1MjMwNzApO1xuICAgICAgICAgICAgZCA9IGlpKGQsIGEsIGIsIGMsIGtbMTFdLCAxMCwgLTExMjAyMTAzNzkpO1xuICAgICAgICAgICAgYyA9IGlpKGMsIGQsIGEsIGIsIGtbMl0sIDE1LCA3MTg3ODcyNTkpO1xuICAgICAgICAgICAgYiA9IGlpKGIsIGMsIGQsIGEsIGtbOV0sIDIxLCAtMzQzNDg1NTUxKTtcbiAgICBcbiAgICAgICAgICAgIHhbMF0gPSBhZGQzMihhLCB4WzBdKTtcbiAgICAgICAgICAgIHhbMV0gPSBhZGQzMihiLCB4WzFdKTtcbiAgICAgICAgICAgIHhbMl0gPSBhZGQzMihjLCB4WzJdKTtcbiAgICAgICAgICAgIHhbM10gPSBhZGQzMihkLCB4WzNdKTtcbiAgICAgICAgfSxcbiAgICBcbiAgICAgICAgLyogdGhlcmUgbmVlZHMgdG8gYmUgc3VwcG9ydCBmb3IgVW5pY29kZSBoZXJlLFxuICAgICAgICAgICAqIHVubGVzcyB3ZSBwcmV0ZW5kIHRoYXQgd2UgY2FuIHJlZGVmaW5lIHRoZSBNRC01XG4gICAgICAgICAgICogYWxnb3JpdGhtIGZvciBtdWx0aS1ieXRlIGNoYXJhY3RlcnMgKHBlcmhhcHNcbiAgICAgICAgICAgKiBieSBhZGRpbmcgZXZlcnkgZm91ciAxNi1iaXQgY2hhcmFjdGVycyBhbmRcbiAgICAgICAgICAgKiBzaG9ydGVuaW5nIHRoZSBzdW0gdG8gMzIgYml0cykuIE90aGVyd2lzZVxuICAgICAgICAgICAqIEkgc3VnZ2VzdCBwZXJmb3JtaW5nIE1ELTUgYXMgaWYgZXZlcnkgY2hhcmFjdGVyXG4gICAgICAgICAgICogd2FzIHR3byBieXRlcy0tZS5nLiwgMDA0MCAwMDI1ID0gQCUtLWJ1dCB0aGVuXG4gICAgICAgICAgICogaG93IHdpbGwgYW4gb3JkaW5hcnkgTUQtNSBzdW0gYmUgbWF0Y2hlZD9cbiAgICAgICAgICAgKiBUaGVyZSBpcyBubyB3YXkgdG8gc3RhbmRhcmRpemUgdGV4dCB0byBzb21ldGhpbmdcbiAgICAgICAgICAgKiBsaWtlIFVURi04IGJlZm9yZSB0cmFuc2Zvcm1hdGlvbjsgc3BlZWQgY29zdCBpc1xuICAgICAgICAgICAqIHV0dGVybHkgcHJvaGliaXRpdmUuIFRoZSBKYXZhU2NyaXB0IHN0YW5kYXJkXG4gICAgICAgICAgICogaXRzZWxmIG5lZWRzIHRvIGxvb2sgYXQgdGhpczogaXQgc2hvdWxkIHN0YXJ0XG4gICAgICAgICAgICogcHJvdmlkaW5nIGFjY2VzcyB0byBzdHJpbmdzIGFzIHByZWZvcm1lZCBVVEYtOFxuICAgICAgICAgICAqIDgtYml0IHVuc2lnbmVkIHZhbHVlIGFycmF5cy5cbiAgICAgICAgICAgKi9cbiAgICAgICAgbWQ1YmxrID0gZnVuY3Rpb24gKHMpIHtcbiAgICAgICAgICAgIHZhciBtZDVibGtzID0gW10sXG4gICAgICAgICAgICAgICAgaTsgLyogQW5keSBLaW5nIHNhaWQgZG8gaXQgdGhpcyB3YXkuICovXG4gICAgXG4gICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgNjQ7IGkgKz0gNCkge1xuICAgICAgICAgICAgICAgIG1kNWJsa3NbaSA+PiAyXSA9IHMuY2hhckNvZGVBdChpKSArIChzLmNoYXJDb2RlQXQoaSArIDEpIDw8IDgpICsgKHMuY2hhckNvZGVBdChpICsgMikgPDwgMTYpICsgKHMuY2hhckNvZGVBdChpICsgMykgPDwgMjQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG1kNWJsa3M7XG4gICAgICAgIH0sXG4gICAgXG4gICAgICAgIG1kNWJsa19hcnJheSA9IGZ1bmN0aW9uIChhKSB7XG4gICAgICAgICAgICB2YXIgbWQ1YmxrcyA9IFtdLFxuICAgICAgICAgICAgICAgIGk7IC8qIEFuZHkgS2luZyBzYWlkIGRvIGl0IHRoaXMgd2F5LiAqL1xuICAgIFxuICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IDY0OyBpICs9IDQpIHtcbiAgICAgICAgICAgICAgICBtZDVibGtzW2kgPj4gMl0gPSBhW2ldICsgKGFbaSArIDFdIDw8IDgpICsgKGFbaSArIDJdIDw8IDE2KSArIChhW2kgKyAzXSA8PCAyNCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbWQ1YmxrcztcbiAgICAgICAgfSxcbiAgICBcbiAgICAgICAgbWQ1MSA9IGZ1bmN0aW9uIChzKSB7XG4gICAgICAgICAgICB2YXIgbiA9IHMubGVuZ3RoLFxuICAgICAgICAgICAgICAgIHN0YXRlID0gWzE3MzI1ODQxOTMsIC0yNzE3MzM4NzksIC0xNzMyNTg0MTk0LCAyNzE3MzM4NzhdLFxuICAgICAgICAgICAgICAgIGksXG4gICAgICAgICAgICAgICAgbGVuZ3RoLFxuICAgICAgICAgICAgICAgIHRhaWwsXG4gICAgICAgICAgICAgICAgdG1wLFxuICAgICAgICAgICAgICAgIGxvLFxuICAgICAgICAgICAgICAgIGhpO1xuICAgIFxuICAgICAgICAgICAgZm9yIChpID0gNjQ7IGkgPD0gbjsgaSArPSA2NCkge1xuICAgICAgICAgICAgICAgIG1kNWN5Y2xlKHN0YXRlLCBtZDVibGsocy5zdWJzdHJpbmcoaSAtIDY0LCBpKSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcyA9IHMuc3Vic3RyaW5nKGkgLSA2NCk7XG4gICAgICAgICAgICBsZW5ndGggPSBzLmxlbmd0aDtcbiAgICAgICAgICAgIHRhaWwgPSBbMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMF07XG4gICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgICAgICAgICB0YWlsW2kgPj4gMl0gfD0gcy5jaGFyQ29kZUF0KGkpIDw8ICgoaSAlIDQpIDw8IDMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGFpbFtpID4+IDJdIHw9IDB4ODAgPDwgKChpICUgNCkgPDwgMyk7XG4gICAgICAgICAgICBpZiAoaSA+IDU1KSB7XG4gICAgICAgICAgICAgICAgbWQ1Y3ljbGUoc3RhdGUsIHRhaWwpO1xuICAgICAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCAxNjsgaSArPSAxKSB7XG4gICAgICAgICAgICAgICAgICAgIHRhaWxbaV0gPSAwO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICBcbiAgICAgICAgICAgIC8vIEJld2FyZSB0aGF0IHRoZSBmaW5hbCBsZW5ndGggbWlnaHQgbm90IGZpdCBpbiAzMiBiaXRzIHNvIHdlIHRha2UgY2FyZSBvZiB0aGF0XG4gICAgICAgICAgICB0bXAgPSBuICogODtcbiAgICAgICAgICAgIHRtcCA9IHRtcC50b1N0cmluZygxNikubWF0Y2goLyguKj8pKC57MCw4fSkkLyk7XG4gICAgICAgICAgICBsbyA9IHBhcnNlSW50KHRtcFsyXSwgMTYpO1xuICAgICAgICAgICAgaGkgPSBwYXJzZUludCh0bXBbMV0sIDE2KSB8fCAwO1xuICAgIFxuICAgICAgICAgICAgdGFpbFsxNF0gPSBsbztcbiAgICAgICAgICAgIHRhaWxbMTVdID0gaGk7XG4gICAgXG4gICAgICAgICAgICBtZDVjeWNsZShzdGF0ZSwgdGFpbCk7XG4gICAgICAgICAgICByZXR1cm4gc3RhdGU7XG4gICAgICAgIH0sXG4gICAgXG4gICAgICAgIG1kNTFfYXJyYXkgPSBmdW5jdGlvbiAoYSkge1xuICAgICAgICAgICAgdmFyIG4gPSBhLmxlbmd0aCxcbiAgICAgICAgICAgICAgICBzdGF0ZSA9IFsxNzMyNTg0MTkzLCAtMjcxNzMzODc5LCAtMTczMjU4NDE5NCwgMjcxNzMzODc4XSxcbiAgICAgICAgICAgICAgICBpLFxuICAgICAgICAgICAgICAgIGxlbmd0aCxcbiAgICAgICAgICAgICAgICB0YWlsLFxuICAgICAgICAgICAgICAgIHRtcCxcbiAgICAgICAgICAgICAgICBsbyxcbiAgICAgICAgICAgICAgICBoaTtcbiAgICBcbiAgICAgICAgICAgIGZvciAoaSA9IDY0OyBpIDw9IG47IGkgKz0gNjQpIHtcbiAgICAgICAgICAgICAgICBtZDVjeWNsZShzdGF0ZSwgbWQ1YmxrX2FycmF5KGEuc3ViYXJyYXkoaSAtIDY0LCBpKSkpO1xuICAgICAgICAgICAgfVxuICAgIFxuICAgICAgICAgICAgLy8gTm90IHN1cmUgaWYgaXQgaXMgYSBidWcsIGhvd2V2ZXIgSUUxMCB3aWxsIGFsd2F5cyBwcm9kdWNlIGEgc3ViIGFycmF5IG9mIGxlbmd0aCAxXG4gICAgICAgICAgICAvLyBjb250YWluaW5nIHRoZSBsYXN0IGVsZW1lbnQgb2YgdGhlIHBhcmVudCBhcnJheSBpZiB0aGUgc3ViIGFycmF5IHNwZWNpZmllZCBzdGFydHNcbiAgICAgICAgICAgIC8vIGJleW9uZCB0aGUgbGVuZ3RoIG9mIHRoZSBwYXJlbnQgYXJyYXkgLSB3ZWlyZC5cbiAgICAgICAgICAgIC8vIGh0dHBzOi8vY29ubmVjdC5taWNyb3NvZnQuY29tL0lFL2ZlZWRiYWNrL2RldGFpbHMvNzcxNDUyL3R5cGVkLWFycmF5LXN1YmFycmF5LWlzc3VlXG4gICAgICAgICAgICBhID0gKGkgLSA2NCkgPCBuID8gYS5zdWJhcnJheShpIC0gNjQpIDogbmV3IFVpbnQ4QXJyYXkoMCk7XG4gICAgXG4gICAgICAgICAgICBsZW5ndGggPSBhLmxlbmd0aDtcbiAgICAgICAgICAgIHRhaWwgPSBbMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMF07XG4gICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgICAgICAgICB0YWlsW2kgPj4gMl0gfD0gYVtpXSA8PCAoKGkgJSA0KSA8PCAzKTtcbiAgICAgICAgICAgIH1cbiAgICBcbiAgICAgICAgICAgIHRhaWxbaSA+PiAyXSB8PSAweDgwIDw8ICgoaSAlIDQpIDw8IDMpO1xuICAgICAgICAgICAgaWYgKGkgPiA1NSkge1xuICAgICAgICAgICAgICAgIG1kNWN5Y2xlKHN0YXRlLCB0YWlsKTtcbiAgICAgICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgMTY7IGkgKz0gMSkge1xuICAgICAgICAgICAgICAgICAgICB0YWlsW2ldID0gMDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgXG4gICAgICAgICAgICAvLyBCZXdhcmUgdGhhdCB0aGUgZmluYWwgbGVuZ3RoIG1pZ2h0IG5vdCBmaXQgaW4gMzIgYml0cyBzbyB3ZSB0YWtlIGNhcmUgb2YgdGhhdFxuICAgICAgICAgICAgdG1wID0gbiAqIDg7XG4gICAgICAgICAgICB0bXAgPSB0bXAudG9TdHJpbmcoMTYpLm1hdGNoKC8oLio/KSguezAsOH0pJC8pO1xuICAgICAgICAgICAgbG8gPSBwYXJzZUludCh0bXBbMl0sIDE2KTtcbiAgICAgICAgICAgIGhpID0gcGFyc2VJbnQodG1wWzFdLCAxNikgfHwgMDtcbiAgICBcbiAgICAgICAgICAgIHRhaWxbMTRdID0gbG87XG4gICAgICAgICAgICB0YWlsWzE1XSA9IGhpO1xuICAgIFxuICAgICAgICAgICAgbWQ1Y3ljbGUoc3RhdGUsIHRhaWwpO1xuICAgIFxuICAgICAgICAgICAgcmV0dXJuIHN0YXRlO1xuICAgICAgICB9LFxuICAgIFxuICAgICAgICBoZXhfY2hyID0gWycwJywgJzEnLCAnMicsICczJywgJzQnLCAnNScsICc2JywgJzcnLCAnOCcsICc5JywgJ2EnLCAnYicsICdjJywgJ2QnLCAnZScsICdmJ10sXG4gICAgXG4gICAgICAgIHJoZXggPSBmdW5jdGlvbiAobikge1xuICAgICAgICAgICAgdmFyIHMgPSAnJyxcbiAgICAgICAgICAgICAgICBqO1xuICAgICAgICAgICAgZm9yIChqID0gMDsgaiA8IDQ7IGogKz0gMSkge1xuICAgICAgICAgICAgICAgIHMgKz0gaGV4X2NoclsobiA+PiAoaiAqIDggKyA0KSkgJiAweDBGXSArIGhleF9jaHJbKG4gPj4gKGogKiA4KSkgJiAweDBGXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBzO1xuICAgICAgICB9LFxuICAgIFxuICAgICAgICBoZXggPSBmdW5jdGlvbiAoeCkge1xuICAgICAgICAgICAgdmFyIGk7XG4gICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgeC5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICAgICAgICAgIHhbaV0gPSByaGV4KHhbaV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHguam9pbignJyk7XG4gICAgICAgIH0sXG4gICAgXG4gICAgICAgIG1kNSA9IGZ1bmN0aW9uIChzKSB7XG4gICAgICAgICAgICByZXR1cm4gaGV4KG1kNTEocykpO1xuICAgICAgICB9LFxuICAgIFxuICAgIFxuICAgIFxuICAgICAgICAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG4gICAgXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTcGFya01ENSBPT1AgaW1wbGVtZW50YXRpb24uXG4gICAgICAgICAqXG4gICAgICAgICAqIFVzZSB0aGlzIGNsYXNzIHRvIHBlcmZvcm0gYW4gaW5jcmVtZW50YWwgbWQ1LCBvdGhlcndpc2UgdXNlIHRoZVxuICAgICAgICAgKiBzdGF0aWMgbWV0aG9kcyBpbnN0ZWFkLlxuICAgICAgICAgKi9cbiAgICAgICAgU3BhcmtNRDUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAvLyBjYWxsIHJlc2V0IHRvIGluaXQgdGhlIGluc3RhbmNlXG4gICAgICAgICAgICB0aGlzLnJlc2V0KCk7XG4gICAgICAgIH07XG4gICAgXG4gICAgXG4gICAgICAgIC8vIEluIHNvbWUgY2FzZXMgdGhlIGZhc3QgYWRkMzIgZnVuY3Rpb24gY2Fubm90IGJlIHVzZWQuLlxuICAgICAgICBpZiAobWQ1KCdoZWxsbycpICE9PSAnNWQ0MTQwMmFiYzRiMmE3NmI5NzE5ZDkxMTAxN2M1OTInKSB7XG4gICAgICAgICAgICBhZGQzMiA9IGZ1bmN0aW9uICh4LCB5KSB7XG4gICAgICAgICAgICAgICAgdmFyIGxzdyA9ICh4ICYgMHhGRkZGKSArICh5ICYgMHhGRkZGKSxcbiAgICAgICAgICAgICAgICAgICAgbXN3ID0gKHggPj4gMTYpICsgKHkgPj4gMTYpICsgKGxzdyA+PiAxNik7XG4gICAgICAgICAgICAgICAgcmV0dXJuIChtc3cgPDwgMTYpIHwgKGxzdyAmIDB4RkZGRik7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgXG4gICAgXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBcHBlbmRzIGEgc3RyaW5nLlxuICAgICAgICAgKiBBIGNvbnZlcnNpb24gd2lsbCBiZSBhcHBsaWVkIGlmIGFuIHV0Zjggc3RyaW5nIGlzIGRldGVjdGVkLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0ge1N0cmluZ30gc3RyIFRoZSBzdHJpbmcgdG8gYmUgYXBwZW5kZWRcbiAgICAgICAgICpcbiAgICAgICAgICogQHJldHVybiB7U3BhcmtNRDV9IFRoZSBpbnN0YW5jZSBpdHNlbGZcbiAgICAgICAgICovXG4gICAgICAgIFNwYXJrTUQ1LnByb3RvdHlwZS5hcHBlbmQgPSBmdW5jdGlvbiAoc3RyKSB7XG4gICAgICAgICAgICAvLyBjb252ZXJ0cyB0aGUgc3RyaW5nIHRvIHV0ZjggYnl0ZXMgaWYgbmVjZXNzYXJ5XG4gICAgICAgICAgICBpZiAoL1tcXHUwMDgwLVxcdUZGRkZdLy50ZXN0KHN0cikpIHtcbiAgICAgICAgICAgICAgICBzdHIgPSB1bmVzY2FwZShlbmNvZGVVUklDb21wb25lbnQoc3RyKSk7XG4gICAgICAgICAgICB9XG4gICAgXG4gICAgICAgICAgICAvLyB0aGVuIGFwcGVuZCBhcyBiaW5hcnlcbiAgICAgICAgICAgIHRoaXMuYXBwZW5kQmluYXJ5KHN0cik7XG4gICAgXG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfTtcbiAgICBcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEFwcGVuZHMgYSBiaW5hcnkgc3RyaW5nLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0ge1N0cmluZ30gY29udGVudHMgVGhlIGJpbmFyeSBzdHJpbmcgdG8gYmUgYXBwZW5kZWRcbiAgICAgICAgICpcbiAgICAgICAgICogQHJldHVybiB7U3BhcmtNRDV9IFRoZSBpbnN0YW5jZSBpdHNlbGZcbiAgICAgICAgICovXG4gICAgICAgIFNwYXJrTUQ1LnByb3RvdHlwZS5hcHBlbmRCaW5hcnkgPSBmdW5jdGlvbiAoY29udGVudHMpIHtcbiAgICAgICAgICAgIHRoaXMuX2J1ZmYgKz0gY29udGVudHM7XG4gICAgICAgICAgICB0aGlzLl9sZW5ndGggKz0gY29udGVudHMubGVuZ3RoO1xuICAgIFxuICAgICAgICAgICAgdmFyIGxlbmd0aCA9IHRoaXMuX2J1ZmYubGVuZ3RoLFxuICAgICAgICAgICAgICAgIGk7XG4gICAgXG4gICAgICAgICAgICBmb3IgKGkgPSA2NDsgaSA8PSBsZW5ndGg7IGkgKz0gNjQpIHtcbiAgICAgICAgICAgICAgICBtZDVjeWNsZSh0aGlzLl9zdGF0ZSwgbWQ1YmxrKHRoaXMuX2J1ZmYuc3Vic3RyaW5nKGkgLSA2NCwgaSkpKTtcbiAgICAgICAgICAgIH1cbiAgICBcbiAgICAgICAgICAgIHRoaXMuX2J1ZmYgPSB0aGlzLl9idWZmLnN1YnN0cihpIC0gNjQpO1xuICAgIFxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH07XG4gICAgXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBGaW5pc2hlcyB0aGUgaW5jcmVtZW50YWwgY29tcHV0YXRpb24sIHJlc2V0aW5nIHRoZSBpbnRlcm5hbCBzdGF0ZSBhbmRcbiAgICAgICAgICogcmV0dXJuaW5nIHRoZSByZXN1bHQuXG4gICAgICAgICAqIFVzZSB0aGUgcmF3IHBhcmFtZXRlciB0byBvYnRhaW4gdGhlIHJhdyByZXN1bHQgaW5zdGVhZCBvZiB0aGUgaGV4IG9uZS5cbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIHtCb29sZWFufSByYXcgVHJ1ZSB0byBnZXQgdGhlIHJhdyByZXN1bHQsIGZhbHNlIHRvIGdldCB0aGUgaGV4IHJlc3VsdFxuICAgICAgICAgKlxuICAgICAgICAgKiBAcmV0dXJuIHtTdHJpbmd8QXJyYXl9IFRoZSByZXN1bHRcbiAgICAgICAgICovXG4gICAgICAgIFNwYXJrTUQ1LnByb3RvdHlwZS5lbmQgPSBmdW5jdGlvbiAocmF3KSB7XG4gICAgICAgICAgICB2YXIgYnVmZiA9IHRoaXMuX2J1ZmYsXG4gICAgICAgICAgICAgICAgbGVuZ3RoID0gYnVmZi5sZW5ndGgsXG4gICAgICAgICAgICAgICAgaSxcbiAgICAgICAgICAgICAgICB0YWlsID0gWzAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDBdLFxuICAgICAgICAgICAgICAgIHJldDtcbiAgICBcbiAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBsZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICAgICAgICAgIHRhaWxbaSA+PiAyXSB8PSBidWZmLmNoYXJDb2RlQXQoaSkgPDwgKChpICUgNCkgPDwgMyk7XG4gICAgICAgICAgICB9XG4gICAgXG4gICAgICAgICAgICB0aGlzLl9maW5pc2godGFpbCwgbGVuZ3RoKTtcbiAgICAgICAgICAgIHJldCA9ICEhcmF3ID8gdGhpcy5fc3RhdGUgOiBoZXgodGhpcy5fc3RhdGUpO1xuICAgIFxuICAgICAgICAgICAgdGhpcy5yZXNldCgpO1xuICAgIFxuICAgICAgICAgICAgcmV0dXJuIHJldDtcbiAgICAgICAgfTtcbiAgICBcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEZpbmlzaCB0aGUgZmluYWwgY2FsY3VsYXRpb24gYmFzZWQgb24gdGhlIHRhaWwuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSB7QXJyYXl9ICB0YWlsICAgVGhlIHRhaWwgKHdpbGwgYmUgbW9kaWZpZWQpXG4gICAgICAgICAqIEBwYXJhbSB7TnVtYmVyfSBsZW5ndGggVGhlIGxlbmd0aCBvZiB0aGUgcmVtYWluaW5nIGJ1ZmZlclxuICAgICAgICAgKi9cbiAgICAgICAgU3BhcmtNRDUucHJvdG90eXBlLl9maW5pc2ggPSBmdW5jdGlvbiAodGFpbCwgbGVuZ3RoKSB7XG4gICAgICAgICAgICB2YXIgaSA9IGxlbmd0aCxcbiAgICAgICAgICAgICAgICB0bXAsXG4gICAgICAgICAgICAgICAgbG8sXG4gICAgICAgICAgICAgICAgaGk7XG4gICAgXG4gICAgICAgICAgICB0YWlsW2kgPj4gMl0gfD0gMHg4MCA8PCAoKGkgJSA0KSA8PCAzKTtcbiAgICAgICAgICAgIGlmIChpID4gNTUpIHtcbiAgICAgICAgICAgICAgICBtZDVjeWNsZSh0aGlzLl9zdGF0ZSwgdGFpbCk7XG4gICAgICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IDE2OyBpICs9IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgdGFpbFtpXSA9IDA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgIFxuICAgICAgICAgICAgLy8gRG8gdGhlIGZpbmFsIGNvbXB1dGF0aW9uIGJhc2VkIG9uIHRoZSB0YWlsIGFuZCBsZW5ndGhcbiAgICAgICAgICAgIC8vIEJld2FyZSB0aGF0IHRoZSBmaW5hbCBsZW5ndGggbWF5IG5vdCBmaXQgaW4gMzIgYml0cyBzbyB3ZSB0YWtlIGNhcmUgb2YgdGhhdFxuICAgICAgICAgICAgdG1wID0gdGhpcy5fbGVuZ3RoICogODtcbiAgICAgICAgICAgIHRtcCA9IHRtcC50b1N0cmluZygxNikubWF0Y2goLyguKj8pKC57MCw4fSkkLyk7XG4gICAgICAgICAgICBsbyA9IHBhcnNlSW50KHRtcFsyXSwgMTYpO1xuICAgICAgICAgICAgaGkgPSBwYXJzZUludCh0bXBbMV0sIDE2KSB8fCAwO1xuICAgIFxuICAgICAgICAgICAgdGFpbFsxNF0gPSBsbztcbiAgICAgICAgICAgIHRhaWxbMTVdID0gaGk7XG4gICAgICAgICAgICBtZDVjeWNsZSh0aGlzLl9zdGF0ZSwgdGFpbCk7XG4gICAgICAgIH07XG4gICAgXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZXNldHMgdGhlIGludGVybmFsIHN0YXRlIG9mIHRoZSBjb21wdXRhdGlvbi5cbiAgICAgICAgICpcbiAgICAgICAgICogQHJldHVybiB7U3BhcmtNRDV9IFRoZSBpbnN0YW5jZSBpdHNlbGZcbiAgICAgICAgICovXG4gICAgICAgIFNwYXJrTUQ1LnByb3RvdHlwZS5yZXNldCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHRoaXMuX2J1ZmYgPSBcIlwiO1xuICAgICAgICAgICAgdGhpcy5fbGVuZ3RoID0gMDtcbiAgICAgICAgICAgIHRoaXMuX3N0YXRlID0gWzE3MzI1ODQxOTMsIC0yNzE3MzM4NzksIC0xNzMyNTg0MTk0LCAyNzE3MzM4NzhdO1xuICAgIFxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH07XG4gICAgXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZWxlYXNlcyBtZW1vcnkgdXNlZCBieSB0aGUgaW5jcmVtZW50YWwgYnVmZmVyIGFuZCBvdGhlciBhZGl0aW9uYWxcbiAgICAgICAgICogcmVzb3VyY2VzLiBJZiB5b3UgcGxhbiB0byB1c2UgdGhlIGluc3RhbmNlIGFnYWluLCB1c2UgcmVzZXQgaW5zdGVhZC5cbiAgICAgICAgICovXG4gICAgICAgIFNwYXJrTUQ1LnByb3RvdHlwZS5kZXN0cm95ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgZGVsZXRlIHRoaXMuX3N0YXRlO1xuICAgICAgICAgICAgZGVsZXRlIHRoaXMuX2J1ZmY7XG4gICAgICAgICAgICBkZWxldGUgdGhpcy5fbGVuZ3RoO1xuICAgICAgICB9O1xuICAgIFxuICAgIFxuICAgICAgICAvKipcbiAgICAgICAgICogUGVyZm9ybXMgdGhlIG1kNSBoYXNoIG9uIGEgc3RyaW5nLlxuICAgICAgICAgKiBBIGNvbnZlcnNpb24gd2lsbCBiZSBhcHBsaWVkIGlmIHV0Zjggc3RyaW5nIGlzIGRldGVjdGVkLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0ge1N0cmluZ30gIHN0ciBUaGUgc3RyaW5nXG4gICAgICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gcmF3IFRydWUgdG8gZ2V0IHRoZSByYXcgcmVzdWx0LCBmYWxzZSB0byBnZXQgdGhlIGhleCByZXN1bHRcbiAgICAgICAgICpcbiAgICAgICAgICogQHJldHVybiB7U3RyaW5nfEFycmF5fSBUaGUgcmVzdWx0XG4gICAgICAgICAqL1xuICAgICAgICBTcGFya01ENS5oYXNoID0gZnVuY3Rpb24gKHN0ciwgcmF3KSB7XG4gICAgICAgICAgICAvLyBjb252ZXJ0cyB0aGUgc3RyaW5nIHRvIHV0ZjggYnl0ZXMgaWYgbmVjZXNzYXJ5XG4gICAgICAgICAgICBpZiAoL1tcXHUwMDgwLVxcdUZGRkZdLy50ZXN0KHN0cikpIHtcbiAgICAgICAgICAgICAgICBzdHIgPSB1bmVzY2FwZShlbmNvZGVVUklDb21wb25lbnQoc3RyKSk7XG4gICAgICAgICAgICB9XG4gICAgXG4gICAgICAgICAgICB2YXIgaGFzaCA9IG1kNTEoc3RyKTtcbiAgICBcbiAgICAgICAgICAgIHJldHVybiAhIXJhdyA/IGhhc2ggOiBoZXgoaGFzaCk7XG4gICAgICAgIH07XG4gICAgXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBQZXJmb3JtcyB0aGUgbWQ1IGhhc2ggb24gYSBiaW5hcnkgc3RyaW5nLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0ge1N0cmluZ30gIGNvbnRlbnQgVGhlIGJpbmFyeSBzdHJpbmdcbiAgICAgICAgICogQHBhcmFtIHtCb29sZWFufSByYXcgICAgIFRydWUgdG8gZ2V0IHRoZSByYXcgcmVzdWx0LCBmYWxzZSB0byBnZXQgdGhlIGhleCByZXN1bHRcbiAgICAgICAgICpcbiAgICAgICAgICogQHJldHVybiB7U3RyaW5nfEFycmF5fSBUaGUgcmVzdWx0XG4gICAgICAgICAqL1xuICAgICAgICBTcGFya01ENS5oYXNoQmluYXJ5ID0gZnVuY3Rpb24gKGNvbnRlbnQsIHJhdykge1xuICAgICAgICAgICAgdmFyIGhhc2ggPSBtZDUxKGNvbnRlbnQpO1xuICAgIFxuICAgICAgICAgICAgcmV0dXJuICEhcmF3ID8gaGFzaCA6IGhleChoYXNoKTtcbiAgICAgICAgfTtcbiAgICBcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFNwYXJrTUQ1IE9PUCBpbXBsZW1lbnRhdGlvbiBmb3IgYXJyYXkgYnVmZmVycy5cbiAgICAgICAgICpcbiAgICAgICAgICogVXNlIHRoaXMgY2xhc3MgdG8gcGVyZm9ybSBhbiBpbmNyZW1lbnRhbCBtZDUgT05MWSBmb3IgYXJyYXkgYnVmZmVycy5cbiAgICAgICAgICovXG4gICAgICAgIFNwYXJrTUQ1LkFycmF5QnVmZmVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgLy8gY2FsbCByZXNldCB0byBpbml0IHRoZSBpbnN0YW5jZVxuICAgICAgICAgICAgdGhpcy5yZXNldCgpO1xuICAgICAgICB9O1xuICAgIFxuICAgICAgICAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG4gICAgXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBcHBlbmRzIGFuIGFycmF5IGJ1ZmZlci5cbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIHtBcnJheUJ1ZmZlcn0gYXJyIFRoZSBhcnJheSB0byBiZSBhcHBlbmRlZFxuICAgICAgICAgKlxuICAgICAgICAgKiBAcmV0dXJuIHtTcGFya01ENS5BcnJheUJ1ZmZlcn0gVGhlIGluc3RhbmNlIGl0c2VsZlxuICAgICAgICAgKi9cbiAgICAgICAgU3BhcmtNRDUuQXJyYXlCdWZmZXIucHJvdG90eXBlLmFwcGVuZCA9IGZ1bmN0aW9uIChhcnIpIHtcbiAgICAgICAgICAgIC8vIFRPRE86IHdlIGNvdWxkIGF2b2lkIHRoZSBjb25jYXRlbmF0aW9uIGhlcmUgYnV0IHRoZSBhbGdvcml0aG0gd291bGQgYmUgbW9yZSBjb21wbGV4XG4gICAgICAgICAgICAvLyAgICAgICBpZiB5b3UgZmluZCB5b3Vyc2VsZiBuZWVkaW5nIGV4dHJhIHBlcmZvcm1hbmNlLCBwbGVhc2UgbWFrZSBhIFBSLlxuICAgICAgICAgICAgdmFyIGJ1ZmYgPSB0aGlzLl9jb25jYXRBcnJheUJ1ZmZlcih0aGlzLl9idWZmLCBhcnIpLFxuICAgICAgICAgICAgICAgIGxlbmd0aCA9IGJ1ZmYubGVuZ3RoLFxuICAgICAgICAgICAgICAgIGk7XG4gICAgXG4gICAgICAgICAgICB0aGlzLl9sZW5ndGggKz0gYXJyLmJ5dGVMZW5ndGg7XG4gICAgXG4gICAgICAgICAgICBmb3IgKGkgPSA2NDsgaSA8PSBsZW5ndGg7IGkgKz0gNjQpIHtcbiAgICAgICAgICAgICAgICBtZDVjeWNsZSh0aGlzLl9zdGF0ZSwgbWQ1YmxrX2FycmF5KGJ1ZmYuc3ViYXJyYXkoaSAtIDY0LCBpKSkpO1xuICAgICAgICAgICAgfVxuICAgIFxuICAgICAgICAgICAgLy8gQXZvaWRzIElFMTAgd2VpcmRuZXNzIChkb2N1bWVudGVkIGFib3ZlKVxuICAgICAgICAgICAgdGhpcy5fYnVmZiA9IChpIC0gNjQpIDwgbGVuZ3RoID8gYnVmZi5zdWJhcnJheShpIC0gNjQpIDogbmV3IFVpbnQ4QXJyYXkoMCk7XG4gICAgXG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfTtcbiAgICBcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEZpbmlzaGVzIHRoZSBpbmNyZW1lbnRhbCBjb21wdXRhdGlvbiwgcmVzZXRpbmcgdGhlIGludGVybmFsIHN0YXRlIGFuZFxuICAgICAgICAgKiByZXR1cm5pbmcgdGhlIHJlc3VsdC5cbiAgICAgICAgICogVXNlIHRoZSByYXcgcGFyYW1ldGVyIHRvIG9idGFpbiB0aGUgcmF3IHJlc3VsdCBpbnN0ZWFkIG9mIHRoZSBoZXggb25lLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IHJhdyBUcnVlIHRvIGdldCB0aGUgcmF3IHJlc3VsdCwgZmFsc2UgdG8gZ2V0IHRoZSBoZXggcmVzdWx0XG4gICAgICAgICAqXG4gICAgICAgICAqIEByZXR1cm4ge1N0cmluZ3xBcnJheX0gVGhlIHJlc3VsdFxuICAgICAgICAgKi9cbiAgICAgICAgU3BhcmtNRDUuQXJyYXlCdWZmZXIucHJvdG90eXBlLmVuZCA9IGZ1bmN0aW9uIChyYXcpIHtcbiAgICAgICAgICAgIHZhciBidWZmID0gdGhpcy5fYnVmZixcbiAgICAgICAgICAgICAgICBsZW5ndGggPSBidWZmLmxlbmd0aCxcbiAgICAgICAgICAgICAgICB0YWlsID0gWzAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDBdLFxuICAgICAgICAgICAgICAgIGksXG4gICAgICAgICAgICAgICAgcmV0O1xuICAgIFxuICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IGxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgICAgICAgICAgdGFpbFtpID4+IDJdIHw9IGJ1ZmZbaV0gPDwgKChpICUgNCkgPDwgMyk7XG4gICAgICAgICAgICB9XG4gICAgXG4gICAgICAgICAgICB0aGlzLl9maW5pc2godGFpbCwgbGVuZ3RoKTtcbiAgICAgICAgICAgIHJldCA9ICEhcmF3ID8gdGhpcy5fc3RhdGUgOiBoZXgodGhpcy5fc3RhdGUpO1xuICAgIFxuICAgICAgICAgICAgdGhpcy5yZXNldCgpO1xuICAgIFxuICAgICAgICAgICAgcmV0dXJuIHJldDtcbiAgICAgICAgfTtcbiAgICBcbiAgICAgICAgU3BhcmtNRDUuQXJyYXlCdWZmZXIucHJvdG90eXBlLl9maW5pc2ggPSBTcGFya01ENS5wcm90b3R5cGUuX2ZpbmlzaDtcbiAgICBcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJlc2V0cyB0aGUgaW50ZXJuYWwgc3RhdGUgb2YgdGhlIGNvbXB1dGF0aW9uLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcmV0dXJuIHtTcGFya01ENS5BcnJheUJ1ZmZlcn0gVGhlIGluc3RhbmNlIGl0c2VsZlxuICAgICAgICAgKi9cbiAgICAgICAgU3BhcmtNRDUuQXJyYXlCdWZmZXIucHJvdG90eXBlLnJlc2V0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdGhpcy5fYnVmZiA9IG5ldyBVaW50OEFycmF5KDApO1xuICAgICAgICAgICAgdGhpcy5fbGVuZ3RoID0gMDtcbiAgICAgICAgICAgIHRoaXMuX3N0YXRlID0gWzE3MzI1ODQxOTMsIC0yNzE3MzM4NzksIC0xNzMyNTg0MTk0LCAyNzE3MzM4NzhdO1xuICAgIFxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH07XG4gICAgXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZWxlYXNlcyBtZW1vcnkgdXNlZCBieSB0aGUgaW5jcmVtZW50YWwgYnVmZmVyIGFuZCBvdGhlciBhZGl0aW9uYWxcbiAgICAgICAgICogcmVzb3VyY2VzLiBJZiB5b3UgcGxhbiB0byB1c2UgdGhlIGluc3RhbmNlIGFnYWluLCB1c2UgcmVzZXQgaW5zdGVhZC5cbiAgICAgICAgICovXG4gICAgICAgIFNwYXJrTUQ1LkFycmF5QnVmZmVyLnByb3RvdHlwZS5kZXN0cm95ID0gU3BhcmtNRDUucHJvdG90eXBlLmRlc3Ryb3k7XG4gICAgXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDb25jYXRzIHR3byBhcnJheSBidWZmZXJzLCByZXR1cm5pbmcgYSBuZXcgb25lLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0gIHtBcnJheUJ1ZmZlcn0gZmlyc3QgIFRoZSBmaXJzdCBhcnJheSBidWZmZXJcbiAgICAgICAgICogQHBhcmFtICB7QXJyYXlCdWZmZXJ9IHNlY29uZCBUaGUgc2Vjb25kIGFycmF5IGJ1ZmZlclxuICAgICAgICAgKlxuICAgICAgICAgKiBAcmV0dXJuIHtBcnJheUJ1ZmZlcn0gVGhlIG5ldyBhcnJheSBidWZmZXJcbiAgICAgICAgICovXG4gICAgICAgIFNwYXJrTUQ1LkFycmF5QnVmZmVyLnByb3RvdHlwZS5fY29uY2F0QXJyYXlCdWZmZXIgPSBmdW5jdGlvbiAoZmlyc3QsIHNlY29uZCkge1xuICAgICAgICAgICAgdmFyIGZpcnN0TGVuZ3RoID0gZmlyc3QubGVuZ3RoLFxuICAgICAgICAgICAgICAgIHJlc3VsdCA9IG5ldyBVaW50OEFycmF5KGZpcnN0TGVuZ3RoICsgc2Vjb25kLmJ5dGVMZW5ndGgpO1xuICAgIFxuICAgICAgICAgICAgcmVzdWx0LnNldChmaXJzdCk7XG4gICAgICAgICAgICByZXN1bHQuc2V0KG5ldyBVaW50OEFycmF5KHNlY29uZCksIGZpcnN0TGVuZ3RoKTtcbiAgICBcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH07XG4gICAgXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBQZXJmb3JtcyB0aGUgbWQ1IGhhc2ggb24gYW4gYXJyYXkgYnVmZmVyLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0ge0FycmF5QnVmZmVyfSBhcnIgVGhlIGFycmF5IGJ1ZmZlclxuICAgICAgICAgKiBAcGFyYW0ge0Jvb2xlYW59ICAgICByYXcgVHJ1ZSB0byBnZXQgdGhlIHJhdyByZXN1bHQsIGZhbHNlIHRvIGdldCB0aGUgaGV4IHJlc3VsdFxuICAgICAgICAgKlxuICAgICAgICAgKiBAcmV0dXJuIHtTdHJpbmd8QXJyYXl9IFRoZSByZXN1bHRcbiAgICAgICAgICovXG4gICAgICAgIFNwYXJrTUQ1LkFycmF5QnVmZmVyLmhhc2ggPSBmdW5jdGlvbiAoYXJyLCByYXcpIHtcbiAgICAgICAgICAgIHZhciBoYXNoID0gbWQ1MV9hcnJheShuZXcgVWludDhBcnJheShhcnIpKTtcbiAgICBcbiAgICAgICAgICAgIHJldHVybiAhIXJhdyA/IGhhc2ggOiBoZXgoaGFzaCk7XG4gICAgICAgIH07XG4gICAgICAgIFxuICAgICAgICByZXR1cm4gRmxhc2hSdW50aW1lLnJlZ2lzdGVyKCAnTWQ1Jywge1xuICAgICAgICAgICAgaW5pdDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgLy8gZG8gbm90aGluZy5cbiAgICAgICAgICAgIH0sXG4gICAgXG4gICAgICAgICAgICBsb2FkRnJvbUJsb2I6IGZ1bmN0aW9uKCBmaWxlICkge1xuICAgICAgICAgICAgICAgIHZhciBibG9iID0gZmlsZS5nZXRTb3VyY2UoKSxcbiAgICAgICAgICAgICAgICAgICAgY2h1bmtTaXplID0gMiAqIDEwMjQgKiAxMDI0LFxuICAgICAgICAgICAgICAgICAgICBjaHVua3MgPSBNYXRoLmNlaWwoIGJsb2Iuc2l6ZSAvIGNodW5rU2l6ZSApLFxuICAgICAgICAgICAgICAgICAgICBjaHVuayA9IDAsXG4gICAgICAgICAgICAgICAgICAgIG93bmVyID0gdGhpcy5vd25lcixcbiAgICAgICAgICAgICAgICAgICAgc3BhcmsgPSBuZXcgU3BhcmtNRDUuQXJyYXlCdWZmZXIoKSxcbiAgICAgICAgICAgICAgICAgICAgbWUgPSB0aGlzLFxuICAgICAgICAgICAgICAgICAgICBibG9iU2xpY2UgPSBibG9iLm1velNsaWNlIHx8IGJsb2Iud2Via2l0U2xpY2UgfHwgYmxvYi5zbGljZSxcbiAgICAgICAgICAgICAgICAgICAgbG9hZE5leHQsIGZyO1xuICAgIFxuICAgICAgICAgICAgICAgIGZyID0gbmV3IEZpbGVSZWFkZXIoKTtcbiAgICBcbiAgICAgICAgICAgICAgICBsb2FkTmV4dCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgc3RhcnQsIGVuZDtcbiAgICBcbiAgICAgICAgICAgICAgICAgICAgc3RhcnQgPSBjaHVuayAqIGNodW5rU2l6ZTtcbiAgICAgICAgICAgICAgICAgICAgZW5kID0gTWF0aC5taW4oIHN0YXJ0ICsgY2h1bmtTaXplLCBibG9iLnNpemUgKTtcbiAgICBcbiAgICAgICAgICAgICAgICAgICAgZnIub25sb2FkID0gZnVuY3Rpb24oIGUgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzcGFyay5hcHBlbmQoIGUudGFyZ2V0LnJlc3VsdCApO1xuICAgICAgICAgICAgICAgICAgICAgICAgb3duZXIudHJpZ2dlciggJ3Byb2dyZXNzJywge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRvdGFsOiBmaWxlLnNpemUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbG9hZGVkOiBlbmRcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9O1xuICAgIFxuICAgICAgICAgICAgICAgICAgICBmci5vbmxvYWRlbmQgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZyLm9ubG9hZGVuZCA9IGZyLm9ubG9hZCA9IG51bGw7XG4gICAgXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoICsrY2h1bmsgPCBjaHVua3MgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2V0VGltZW91dCggbG9hZE5leHQsIDEgKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbigpe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvd25lci50cmlnZ2VyKCdsb2FkJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1lLnJlc3VsdCA9IHNwYXJrLmVuZCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsb2FkTmV4dCA9IGZpbGUgPSBibG9iID0gc3BhcmsgPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvd25lci50cmlnZ2VyKCdjb21wbGV0ZScpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sIDUwICk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgXG4gICAgICAgICAgICAgICAgICAgIGZyLnJlYWRBc0FycmF5QnVmZmVyKCBibG9iU2xpY2UuY2FsbCggYmxvYiwgc3RhcnQsIGVuZCApICk7XG4gICAgICAgICAgICAgICAgfTtcbiAgICBcbiAgICAgICAgICAgICAgICBsb2FkTmV4dCgpO1xuICAgICAgICAgICAgfSxcbiAgICBcbiAgICAgICAgICAgIGdldFJlc3VsdDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMucmVzdWx0O1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9KTtcbiAgICAvKipcbiAgICAgKiBAZmlsZU92ZXJ2aWV3IEZsYXNoUnVudGltZVxuICAgICAqL1xuICAgIGRlZmluZSgncnVudGltZS9mbGFzaC9ydW50aW1lJyxbXG4gICAgICAgICdiYXNlJyxcbiAgICAgICAgJ3J1bnRpbWUvcnVudGltZScsXG4gICAgICAgICdydW50aW1lL2NvbXBiYXNlJ1xuICAgIF0sIGZ1bmN0aW9uKCBCYXNlLCBSdW50aW1lLCBDb21wQmFzZSApIHtcbiAgICBcbiAgICAgICAgdmFyICQgPSBCYXNlLiQsXG4gICAgICAgICAgICB0eXBlID0gJ2ZsYXNoJyxcbiAgICAgICAgICAgIGNvbXBvbmVudHMgPSB7fTtcbiAgICBcbiAgICBcbiAgICAgICAgZnVuY3Rpb24gZ2V0Rmxhc2hWZXJzaW9uKCkge1xuICAgICAgICAgICAgdmFyIHZlcnNpb247XG4gICAgXG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHZlcnNpb24gPSBuYXZpZ2F0b3IucGx1Z2luc1sgJ1Nob2Nrd2F2ZSBGbGFzaCcgXTtcbiAgICAgICAgICAgICAgICB2ZXJzaW9uID0gdmVyc2lvbi5kZXNjcmlwdGlvbjtcbiAgICAgICAgICAgIH0gY2F0Y2ggKCBleCApIHtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICB2ZXJzaW9uID0gbmV3IEFjdGl2ZVhPYmplY3QoJ1Nob2Nrd2F2ZUZsYXNoLlNob2Nrd2F2ZUZsYXNoJylcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAuR2V0VmFyaWFibGUoJyR2ZXJzaW9uJyk7XG4gICAgICAgICAgICAgICAgfSBjYXRjaCAoIGV4MiApIHtcbiAgICAgICAgICAgICAgICAgICAgdmVyc2lvbiA9ICcwLjAnO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZlcnNpb24gPSB2ZXJzaW9uLm1hdGNoKCAvXFxkKy9nICk7XG4gICAgICAgICAgICByZXR1cm4gcGFyc2VGbG9hdCggdmVyc2lvblsgMCBdICsgJy4nICsgdmVyc2lvblsgMSBdLCAxMCApO1xuICAgICAgICB9XG4gICAgXG4gICAgICAgIGZ1bmN0aW9uIEZsYXNoUnVudGltZSgpIHtcbiAgICAgICAgICAgIHZhciBwb29sID0ge30sXG4gICAgICAgICAgICAgICAgY2xpZW50cyA9IHt9LFxuICAgICAgICAgICAgICAgIGRlc3Ryb3kgPSB0aGlzLmRlc3Ryb3ksXG4gICAgICAgICAgICAgICAgbWUgPSB0aGlzLFxuICAgICAgICAgICAgICAgIGpzcmVjaXZlciA9IEJhc2UuZ3VpZCgnd2VidXBsb2FkZXJfJyk7XG4gICAgXG4gICAgICAgICAgICBSdW50aW1lLmFwcGx5KCBtZSwgYXJndW1lbnRzICk7XG4gICAgICAgICAgICBtZS50eXBlID0gdHlwZTtcbiAgICBcbiAgICBcbiAgICAgICAgICAgIC8vIOi/meS4quaWueazleeahOiwg+eUqOiAhe+8jOWunumZheS4iuaYr1J1bnRpbWVDbGllbnRcbiAgICAgICAgICAgIG1lLmV4ZWMgPSBmdW5jdGlvbiggY29tcCwgZm4vKiwgYXJncy4uLiovICkge1xuICAgICAgICAgICAgICAgIHZhciBjbGllbnQgPSB0aGlzLFxuICAgICAgICAgICAgICAgICAgICB1aWQgPSBjbGllbnQudWlkLFxuICAgICAgICAgICAgICAgICAgICBhcmdzID0gQmFzZS5zbGljZSggYXJndW1lbnRzLCAyICksXG4gICAgICAgICAgICAgICAgICAgIGluc3RhbmNlO1xuICAgIFxuICAgICAgICAgICAgICAgIGNsaWVudHNbIHVpZCBdID0gY2xpZW50O1xuICAgIFxuICAgICAgICAgICAgICAgIGlmICggY29tcG9uZW50c1sgY29tcCBdICkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoICFwb29sWyB1aWQgXSApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBvb2xbIHVpZCBdID0gbmV3IGNvbXBvbmVudHNbIGNvbXAgXSggY2xpZW50LCBtZSApO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgXG4gICAgICAgICAgICAgICAgICAgIGluc3RhbmNlID0gcG9vbFsgdWlkIF07XG4gICAgXG4gICAgICAgICAgICAgICAgICAgIGlmICggaW5zdGFuY2VbIGZuIF0gKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gaW5zdGFuY2VbIGZuIF0uYXBwbHkoIGluc3RhbmNlLCBhcmdzICk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgXG4gICAgICAgICAgICAgICAgcmV0dXJuIG1lLmZsYXNoRXhlYy5hcHBseSggY2xpZW50LCBhcmd1bWVudHMgKTtcbiAgICAgICAgICAgIH07XG4gICAgXG4gICAgICAgICAgICBmdW5jdGlvbiBoYW5kbGVyKCBldnQsIG9iaiApIHtcbiAgICAgICAgICAgICAgICB2YXIgdHlwZSA9IGV2dC50eXBlIHx8IGV2dCxcbiAgICAgICAgICAgICAgICAgICAgcGFydHMsIHVpZDtcbiAgICBcbiAgICAgICAgICAgICAgICBwYXJ0cyA9IHR5cGUuc3BsaXQoJzo6Jyk7XG4gICAgICAgICAgICAgICAgdWlkID0gcGFydHNbIDAgXTtcbiAgICAgICAgICAgICAgICB0eXBlID0gcGFydHNbIDEgXTtcbiAgICBcbiAgICAgICAgICAgICAgICAvLyBjb25zb2xlLmxvZy5hcHBseSggY29uc29sZSwgYXJndW1lbnRzICk7XG4gICAgXG4gICAgICAgICAgICAgICAgaWYgKCB0eXBlID09PSAnUmVhZHknICYmIHVpZCA9PT0gbWUudWlkICkge1xuICAgICAgICAgICAgICAgICAgICBtZS50cmlnZ2VyKCdyZWFkeScpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoIGNsaWVudHNbIHVpZCBdICkge1xuICAgICAgICAgICAgICAgICAgICBjbGllbnRzWyB1aWQgXS50cmlnZ2VyKCB0eXBlLnRvTG93ZXJDYXNlKCksIGV2dCwgb2JqICk7XG4gICAgICAgICAgICAgICAgfVxuICAgIFxuICAgICAgICAgICAgICAgIC8vIEJhc2UubG9nKCBldnQsIG9iaiApO1xuICAgICAgICAgICAgfVxuICAgIFxuICAgICAgICAgICAgLy8gZmxhc2jnmoTmjqXlj5flmajjgIJcbiAgICAgICAgICAgIHdpbmRvd1sganNyZWNpdmVyIF0gPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICB2YXIgYXJncyA9IGFyZ3VtZW50cztcbiAgICBcbiAgICAgICAgICAgICAgICAvLyDkuLrkuobog73mjZXojrflvpfliLDjgIJcbiAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICBoYW5kbGVyLmFwcGx5KCBudWxsLCBhcmdzICk7XG4gICAgICAgICAgICAgICAgfSwgMSApO1xuICAgICAgICAgICAgfTtcbiAgICBcbiAgICAgICAgICAgIHRoaXMuanNyZWNpdmVyID0ganNyZWNpdmVyO1xuICAgIFxuICAgICAgICAgICAgdGhpcy5kZXN0cm95ID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgLy8gQHRvZG8g5Yig6Zmk5rGg5a2Q5Lit55qE5omA5pyJ5a6e5L6LXG4gICAgICAgICAgICAgICAgcmV0dXJuIGRlc3Ryb3kgJiYgZGVzdHJveS5hcHBseSggdGhpcywgYXJndW1lbnRzICk7XG4gICAgICAgICAgICB9O1xuICAgIFxuICAgICAgICAgICAgdGhpcy5mbGFzaEV4ZWMgPSBmdW5jdGlvbiggY29tcCwgZm4gKSB7XG4gICAgICAgICAgICAgICAgdmFyIGZsYXNoID0gbWUuZ2V0Rmxhc2goKSxcbiAgICAgICAgICAgICAgICAgICAgYXJncyA9IEJhc2Uuc2xpY2UoIGFyZ3VtZW50cywgMiApO1xuICAgIFxuICAgICAgICAgICAgICAgIHJldHVybiBmbGFzaC5leGVjKCB0aGlzLnVpZCwgY29tcCwgZm4sIGFyZ3MgKTtcbiAgICAgICAgICAgIH07XG4gICAgXG4gICAgICAgICAgICAvLyBAdG9kb1xuICAgICAgICB9XG4gICAgXG4gICAgICAgIEJhc2UuaW5oZXJpdHMoIFJ1bnRpbWUsIHtcbiAgICAgICAgICAgIGNvbnN0cnVjdG9yOiBGbGFzaFJ1bnRpbWUsXG4gICAgXG4gICAgICAgICAgICBpbml0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICB2YXIgY29udGFpbmVyID0gdGhpcy5nZXRDb250YWluZXIoKSxcbiAgICAgICAgICAgICAgICAgICAgb3B0cyA9IHRoaXMub3B0aW9ucyxcbiAgICAgICAgICAgICAgICAgICAgaHRtbDtcbiAgICBcbiAgICAgICAgICAgICAgICAvLyBpZiBub3QgdGhlIG1pbmltYWwgaGVpZ2h0LCBzaGltcyBhcmUgbm90IGluaXRpYWxpemVkXG4gICAgICAgICAgICAgICAgLy8gaW4gb2xkZXIgYnJvd3NlcnMgKGUuZyBGRjMuNiwgSUU2LDcsOCwgU2FmYXJpIDQuMCw1LjAsIGV0YylcbiAgICAgICAgICAgICAgICBjb250YWluZXIuY3NzKHtcbiAgICAgICAgICAgICAgICAgICAgcG9zaXRpb246ICdhYnNvbHV0ZScsXG4gICAgICAgICAgICAgICAgICAgIHRvcDogJy04cHgnLFxuICAgICAgICAgICAgICAgICAgICBsZWZ0OiAnLThweCcsXG4gICAgICAgICAgICAgICAgICAgIHdpZHRoOiAnOXB4JyxcbiAgICAgICAgICAgICAgICAgICAgaGVpZ2h0OiAnOXB4JyxcbiAgICAgICAgICAgICAgICAgICAgb3ZlcmZsb3c6ICdoaWRkZW4nXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgXG4gICAgICAgICAgICAgICAgLy8gaW5zZXJ0IGZsYXNoIG9iamVjdFxuICAgICAgICAgICAgICAgIGh0bWwgPSAnPG9iamVjdCBpZD1cIicgKyB0aGlzLnVpZCArICdcIiB0eXBlPVwiYXBwbGljYXRpb24vJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAneC1zaG9ja3dhdmUtZmxhc2hcIiBkYXRhPVwiJyArICBvcHRzLnN3ZiArICdcIiAnO1xuICAgIFxuICAgICAgICAgICAgICAgIGlmICggQmFzZS5icm93c2VyLmllICkge1xuICAgICAgICAgICAgICAgICAgICBodG1sICs9ICdjbGFzc2lkPVwiY2xzaWQ6ZDI3Y2RiNmUtYWU2ZC0xMWNmLTk2YjgtNDQ0NTUzNTQwMDAwXCIgJztcbiAgICAgICAgICAgICAgICB9XG4gICAgXG4gICAgICAgICAgICAgICAgaHRtbCArPSAnd2lkdGg9XCIxMDAlXCIgaGVpZ2h0PVwiMTAwJVwiIHN0eWxlPVwib3V0bGluZTowXCI+JyAgK1xuICAgICAgICAgICAgICAgICAgICAnPHBhcmFtIG5hbWU9XCJtb3ZpZVwiIHZhbHVlPVwiJyArIG9wdHMuc3dmICsgJ1wiIC8+JyArXG4gICAgICAgICAgICAgICAgICAgICc8cGFyYW0gbmFtZT1cImZsYXNodmFyc1wiIHZhbHVlPVwidWlkPScgKyB0aGlzLnVpZCArXG4gICAgICAgICAgICAgICAgICAgICcmanNyZWNpdmVyPScgKyB0aGlzLmpzcmVjaXZlciArICdcIiAvPicgK1xuICAgICAgICAgICAgICAgICAgICAnPHBhcmFtIG5hbWU9XCJ3bW9kZVwiIHZhbHVlPVwidHJhbnNwYXJlbnRcIiAvPicgK1xuICAgICAgICAgICAgICAgICAgICAnPHBhcmFtIG5hbWU9XCJhbGxvd3NjcmlwdGFjY2Vzc1wiIHZhbHVlPVwiYWx3YXlzXCIgLz4nICtcbiAgICAgICAgICAgICAgICAnPC9vYmplY3Q+JztcbiAgICBcbiAgICAgICAgICAgICAgICBjb250YWluZXIuaHRtbCggaHRtbCApO1xuICAgICAgICAgICAgfSxcbiAgICBcbiAgICAgICAgICAgIGdldEZsYXNoOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICBpZiAoIHRoaXMuX2ZsYXNoICkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fZmxhc2g7XG4gICAgICAgICAgICAgICAgfVxuICAgIFxuICAgICAgICAgICAgICAgIHRoaXMuX2ZsYXNoID0gJCggJyMnICsgdGhpcy51aWQgKS5nZXQoIDAgKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fZmxhc2g7XG4gICAgICAgICAgICB9XG4gICAgXG4gICAgICAgIH0pO1xuICAgIFxuICAgICAgICBGbGFzaFJ1bnRpbWUucmVnaXN0ZXIgPSBmdW5jdGlvbiggbmFtZSwgY29tcG9uZW50ICkge1xuICAgICAgICAgICAgY29tcG9uZW50ID0gY29tcG9uZW50c1sgbmFtZSBdID0gQmFzZS5pbmhlcml0cyggQ29tcEJhc2UsICQuZXh0ZW5kKHtcbiAgICBcbiAgICAgICAgICAgICAgICAvLyBAdG9kbyBmaXggdGhpcyBsYXRlclxuICAgICAgICAgICAgICAgIGZsYXNoRXhlYzogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBvd25lciA9IHRoaXMub3duZXIsXG4gICAgICAgICAgICAgICAgICAgICAgICBydW50aW1lID0gdGhpcy5nZXRSdW50aW1lKCk7XG4gICAgXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBydW50aW1lLmZsYXNoRXhlYy5hcHBseSggb3duZXIsIGFyZ3VtZW50cyApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIGNvbXBvbmVudCApICk7XG4gICAgXG4gICAgICAgICAgICByZXR1cm4gY29tcG9uZW50O1xuICAgICAgICB9O1xuICAgIFxuICAgICAgICBpZiAoIGdldEZsYXNoVmVyc2lvbigpID49IDExLjQgKSB7XG4gICAgICAgICAgICBSdW50aW1lLmFkZFJ1bnRpbWUoIHR5cGUsIEZsYXNoUnVudGltZSApO1xuICAgICAgICB9XG4gICAgXG4gICAgICAgIHJldHVybiBGbGFzaFJ1bnRpbWU7XG4gICAgfSk7XG4gICAgLyoqXG4gICAgICogQGZpbGVPdmVydmlldyBGaWxlUGlja2VyXG4gICAgICovXG4gICAgZGVmaW5lKCdydW50aW1lL2ZsYXNoL2ZpbGVwaWNrZXInLFtcbiAgICAgICAgJ2Jhc2UnLFxuICAgICAgICAncnVudGltZS9mbGFzaC9ydW50aW1lJ1xuICAgIF0sIGZ1bmN0aW9uKCBCYXNlLCBGbGFzaFJ1bnRpbWUgKSB7XG4gICAgICAgIHZhciAkID0gQmFzZS4kO1xuICAgIFxuICAgICAgICByZXR1cm4gRmxhc2hSdW50aW1lLnJlZ2lzdGVyKCAnRmlsZVBpY2tlcicsIHtcbiAgICAgICAgICAgIGluaXQ6IGZ1bmN0aW9uKCBvcHRzICkge1xuICAgICAgICAgICAgICAgIHZhciBjb3B5ID0gJC5leHRlbmQoe30sIG9wdHMgKSxcbiAgICAgICAgICAgICAgICAgICAgbGVuLCBpO1xuICAgIFxuICAgICAgICAgICAgICAgIC8vIOS/ruWkjUZsYXNo5YaN5rKh5pyJ6K6+572udGl0bGXnmoTmg4XlhrXkuIvml6Dms5XlvLnlh7pmbGFzaOaWh+S7tumAieaLqeahhueahGJ1Zy5cbiAgICAgICAgICAgICAgICBsZW4gPSBjb3B5LmFjY2VwdCAmJiBjb3B5LmFjY2VwdC5sZW5ndGg7XG4gICAgICAgICAgICAgICAgZm9yICggIGkgPSAwOyBpIDwgbGVuOyBpKysgKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICggIWNvcHkuYWNjZXB0WyBpIF0udGl0bGUgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb3B5LmFjY2VwdFsgaSBdLnRpdGxlID0gJ0ZpbGVzJztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICBcbiAgICAgICAgICAgICAgICBkZWxldGUgY29weS5idXR0b247XG4gICAgICAgICAgICAgICAgZGVsZXRlIGNvcHkuaWQ7XG4gICAgICAgICAgICAgICAgZGVsZXRlIGNvcHkuY29udGFpbmVyO1xuICAgIFxuICAgICAgICAgICAgICAgIHRoaXMuZmxhc2hFeGVjKCAnRmlsZVBpY2tlcicsICdpbml0JywgY29weSApO1xuICAgICAgICAgICAgfSxcbiAgICBcbiAgICAgICAgICAgIGRlc3Ryb3k6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHRoaXMuZmxhc2hFeGVjKCAnRmlsZVBpY2tlcicsICdkZXN0cm95JyApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9KTtcbiAgICAvKipcbiAgICAgKiBAZmlsZU92ZXJ2aWV3IOWbvueJh+WOi+e8qVxuICAgICAqL1xuICAgIGRlZmluZSgncnVudGltZS9mbGFzaC9pbWFnZScsW1xuICAgICAgICAncnVudGltZS9mbGFzaC9ydW50aW1lJ1xuICAgIF0sIGZ1bmN0aW9uKCBGbGFzaFJ1bnRpbWUgKSB7XG4gICAgXG4gICAgICAgIHJldHVybiBGbGFzaFJ1bnRpbWUucmVnaXN0ZXIoICdJbWFnZScsIHtcbiAgICAgICAgICAgIC8vIGluaXQ6IGZ1bmN0aW9uKCBvcHRpb25zICkge1xuICAgICAgICAgICAgLy8gICAgIHZhciBvd25lciA9IHRoaXMub3duZXI7XG4gICAgXG4gICAgICAgICAgICAvLyAgICAgdGhpcy5mbGFzaEV4ZWMoICdJbWFnZScsICdpbml0Jywgb3B0aW9ucyApO1xuICAgICAgICAgICAgLy8gICAgIG93bmVyLm9uKCAnbG9hZCcsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgLy8gICAgICAgICBkZWJ1Z2dlcjtcbiAgICAgICAgICAgIC8vICAgICB9KTtcbiAgICAgICAgICAgIC8vIH0sXG4gICAgXG4gICAgICAgICAgICBsb2FkRnJvbUJsb2I6IGZ1bmN0aW9uKCBibG9iICkge1xuICAgICAgICAgICAgICAgIHZhciBvd25lciA9IHRoaXMub3duZXI7XG4gICAgXG4gICAgICAgICAgICAgICAgb3duZXIuaW5mbygpICYmIHRoaXMuZmxhc2hFeGVjKCAnSW1hZ2UnLCAnaW5mbycsIG93bmVyLmluZm8oKSApO1xuICAgICAgICAgICAgICAgIG93bmVyLm1ldGEoKSAmJiB0aGlzLmZsYXNoRXhlYyggJ0ltYWdlJywgJ21ldGEnLCBvd25lci5tZXRhKCkgKTtcbiAgICBcbiAgICAgICAgICAgICAgICB0aGlzLmZsYXNoRXhlYyggJ0ltYWdlJywgJ2xvYWRGcm9tQmxvYicsIGJsb2IudWlkICk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH0pO1xuICAgIC8qKlxuICAgICAqIEBmaWxlT3ZlcnZpZXcgIFRyYW5zcG9ydCBmbGFzaOWunueOsFxuICAgICAqL1xuICAgIGRlZmluZSgncnVudGltZS9mbGFzaC90cmFuc3BvcnQnLFtcbiAgICAgICAgJ2Jhc2UnLFxuICAgICAgICAncnVudGltZS9mbGFzaC9ydW50aW1lJyxcbiAgICAgICAgJ3J1bnRpbWUvY2xpZW50J1xuICAgIF0sIGZ1bmN0aW9uKCBCYXNlLCBGbGFzaFJ1bnRpbWUsIFJ1bnRpbWVDbGllbnQgKSB7XG4gICAgICAgIHZhciAkID0gQmFzZS4kO1xuICAgIFxuICAgICAgICByZXR1cm4gRmxhc2hSdW50aW1lLnJlZ2lzdGVyKCAnVHJhbnNwb3J0Jywge1xuICAgICAgICAgICAgaW5pdDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fc3RhdHVzID0gMDtcbiAgICAgICAgICAgICAgICB0aGlzLl9yZXNwb25zZSA9IG51bGw7XG4gICAgICAgICAgICAgICAgdGhpcy5fcmVzcG9uc2VKc29uID0gbnVsbDtcbiAgICAgICAgICAgIH0sXG4gICAgXG4gICAgICAgICAgICBzZW5kOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICB2YXIgb3duZXIgPSB0aGlzLm93bmVyLFxuICAgICAgICAgICAgICAgICAgICBvcHRzID0gdGhpcy5vcHRpb25zLFxuICAgICAgICAgICAgICAgICAgICB4aHIgPSB0aGlzLl9pbml0QWpheCgpLFxuICAgICAgICAgICAgICAgICAgICBibG9iID0gb3duZXIuX2Jsb2IsXG4gICAgICAgICAgICAgICAgICAgIHNlcnZlciA9IG9wdHMuc2VydmVyLFxuICAgICAgICAgICAgICAgICAgICBiaW5hcnk7XG4gICAgXG4gICAgICAgICAgICAgICAgeGhyLmNvbm5lY3RSdW50aW1lKCBibG9iLnJ1aWQgKTtcbiAgICBcbiAgICAgICAgICAgICAgICBpZiAoIG9wdHMuc2VuZEFzQmluYXJ5ICkge1xuICAgICAgICAgICAgICAgICAgICBzZXJ2ZXIgKz0gKC9cXD8vLnRlc3QoIHNlcnZlciApID8gJyYnIDogJz8nKSArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJC5wYXJhbSggb3duZXIuX2Zvcm1EYXRhICk7XG4gICAgXG4gICAgICAgICAgICAgICAgICAgIGJpbmFyeSA9IGJsb2IudWlkO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICQuZWFjaCggb3duZXIuX2Zvcm1EYXRhLCBmdW5jdGlvbiggaywgdiApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHhoci5leGVjKCAnYXBwZW5kJywgaywgdiApO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICBcbiAgICAgICAgICAgICAgICAgICAgeGhyLmV4ZWMoICdhcHBlbmRCbG9iJywgb3B0cy5maWxlVmFsLCBibG9iLnVpZCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcHRzLmZpbGVuYW1lIHx8IG93bmVyLl9mb3JtRGF0YS5uYW1lIHx8ICcnICk7XG4gICAgICAgICAgICAgICAgfVxuICAgIFxuICAgICAgICAgICAgICAgIHRoaXMuX3NldFJlcXVlc3RIZWFkZXIoIHhociwgb3B0cy5oZWFkZXJzICk7XG4gICAgICAgICAgICAgICAgeGhyLmV4ZWMoICdzZW5kJywge1xuICAgICAgICAgICAgICAgICAgICBtZXRob2Q6IG9wdHMubWV0aG9kLFxuICAgICAgICAgICAgICAgICAgICB1cmw6IHNlcnZlcixcbiAgICAgICAgICAgICAgICAgICAgZm9yY2VVUkxTdHJlYW06IG9wdHMuZm9yY2VVUkxTdHJlYW0sXG4gICAgICAgICAgICAgICAgICAgIG1pbWVUeXBlOiAnYXBwbGljYXRpb24vb2N0ZXQtc3RyZWFtJ1xuICAgICAgICAgICAgICAgIH0sIGJpbmFyeSApO1xuICAgICAgICAgICAgfSxcbiAgICBcbiAgICAgICAgICAgIGdldFN0YXR1czogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3N0YXR1cztcbiAgICAgICAgICAgIH0sXG4gICAgXG4gICAgICAgICAgICBnZXRSZXNwb25zZTogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3Jlc3BvbnNlIHx8ICcnO1xuICAgICAgICAgICAgfSxcbiAgICBcbiAgICAgICAgICAgIGdldFJlc3BvbnNlQXNKc29uOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fcmVzcG9uc2VKc29uO1xuICAgICAgICAgICAgfSxcbiAgICBcbiAgICAgICAgICAgIGFib3J0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICB2YXIgeGhyID0gdGhpcy5feGhyO1xuICAgIFxuICAgICAgICAgICAgICAgIGlmICggeGhyICkge1xuICAgICAgICAgICAgICAgICAgICB4aHIuZXhlYygnYWJvcnQnKTtcbiAgICAgICAgICAgICAgICAgICAgeGhyLmRlc3Ryb3koKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5feGhyID0geGhyID0gbnVsbDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgIFxuICAgICAgICAgICAgZGVzdHJveTogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5hYm9ydCgpO1xuICAgICAgICAgICAgfSxcbiAgICBcbiAgICAgICAgICAgIF9pbml0QWpheDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgdmFyIG1lID0gdGhpcyxcbiAgICAgICAgICAgICAgICAgICAgeGhyID0gbmV3IFJ1bnRpbWVDbGllbnQoJ1hNTEh0dHBSZXF1ZXN0Jyk7XG4gICAgXG4gICAgICAgICAgICAgICAgeGhyLm9uKCAndXBsb2FkcHJvZ3Jlc3MgcHJvZ3Jlc3MnLCBmdW5jdGlvbiggZSApIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHBlcmNlbnQgPSBlLmxvYWRlZCAvIGUudG90YWw7XG4gICAgICAgICAgICAgICAgICAgIHBlcmNlbnQgPSBNYXRoLm1pbiggMSwgTWF0aC5tYXgoIDAsIHBlcmNlbnQgKSApO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbWUudHJpZ2dlciggJ3Byb2dyZXNzJywgcGVyY2VudCApO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgIFxuICAgICAgICAgICAgICAgIHhoci5vbiggJ2xvYWQnLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHN0YXR1cyA9IHhoci5leGVjKCdnZXRTdGF0dXMnKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlYWRCb2R5ID0gZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgICAgICBlcnIgPSAnJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHA7XG4gICAgXG4gICAgICAgICAgICAgICAgICAgIHhoci5vZmYoKTtcbiAgICAgICAgICAgICAgICAgICAgbWUuX3hociA9IG51bGw7XG4gICAgXG4gICAgICAgICAgICAgICAgICAgIGlmICggc3RhdHVzID49IDIwMCAmJiBzdGF0dXMgPCAzMDAgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZWFkQm9keSA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoIHN0YXR1cyA+PSA1MDAgJiYgc3RhdHVzIDwgNjAwICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVhZEJvZHkgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgZXJyID0gJ3NlcnZlcic7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBlcnIgPSAnaHR0cCc7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICBcbiAgICAgICAgICAgICAgICAgICAgaWYgKCByZWFkQm9keSApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1lLl9yZXNwb25zZSA9IHhoci5leGVjKCdnZXRSZXNwb25zZScpO1xuICAgICAgICAgICAgICAgICAgICAgICAgbWUuX3Jlc3BvbnNlID0gZGVjb2RlVVJJQ29tcG9uZW50KCBtZS5fcmVzcG9uc2UgKTtcbiAgICBcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGZsYXNoIOWkhOeQhuWPr+iDveWtmOWcqCBidWcsIOayoei+meWPquiDvemdoCBqcyDkuoZcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyAgICAgbWUuX3Jlc3BvbnNlSnNvbiA9IHhoci5leGVjKCdnZXRSZXNwb25zZUFzSnNvbicpO1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gfSBjYXRjaCAoIGVycm9yICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICAgICAgcCA9IHdpbmRvdy5KU09OICYmIHdpbmRvdy5KU09OLnBhcnNlIHx8IGZ1bmN0aW9uKCBzICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgRnVuY3Rpb24oJ3JldHVybiAnICsgcykuY2FsbCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gY2F0Y2ggKCBlcnIgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB7fTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgbWUuX3Jlc3BvbnNlSnNvbiAgPSBtZS5fcmVzcG9uc2UgPyBwKG1lLl9yZXNwb25zZSkgOiB7fTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgeGhyLmRlc3Ryb3koKTtcbiAgICAgICAgICAgICAgICAgICAgeGhyID0gbnVsbDtcbiAgICBcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGVyciA/IG1lLnRyaWdnZXIoICdlcnJvcicsIGVyciApIDogbWUudHJpZ2dlcignbG9hZCcpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgIFxuICAgICAgICAgICAgICAgIHhoci5vbiggJ2Vycm9yJywgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIHhoci5vZmYoKTtcbiAgICAgICAgICAgICAgICAgICAgbWUuX3hociA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgIG1lLnRyaWdnZXIoICdlcnJvcicsICdodHRwJyApO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgIFxuICAgICAgICAgICAgICAgIG1lLl94aHIgPSB4aHI7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHhocjtcbiAgICAgICAgICAgIH0sXG4gICAgXG4gICAgICAgICAgICBfc2V0UmVxdWVzdEhlYWRlcjogZnVuY3Rpb24oIHhociwgaGVhZGVycyApIHtcbiAgICAgICAgICAgICAgICAkLmVhY2goIGhlYWRlcnMsIGZ1bmN0aW9uKCBrZXksIHZhbCApIHtcbiAgICAgICAgICAgICAgICAgICAgeGhyLmV4ZWMoICdzZXRSZXF1ZXN0SGVhZGVyJywga2V5LCB2YWwgKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfSk7XG4gICAgLyoqXG4gICAgICogQGZpbGVPdmVydmlldyBCbG9iIEh0bWzlrp7njrBcbiAgICAgKi9cbiAgICBkZWZpbmUoJ3J1bnRpbWUvZmxhc2gvYmxvYicsW1xuICAgICAgICAncnVudGltZS9mbGFzaC9ydW50aW1lJyxcbiAgICAgICAgJ2xpYi9ibG9iJ1xuICAgIF0sIGZ1bmN0aW9uKCBGbGFzaFJ1bnRpbWUsIEJsb2IgKSB7XG4gICAgXG4gICAgICAgIHJldHVybiBGbGFzaFJ1bnRpbWUucmVnaXN0ZXIoICdCbG9iJywge1xuICAgICAgICAgICAgc2xpY2U6IGZ1bmN0aW9uKCBzdGFydCwgZW5kICkge1xuICAgICAgICAgICAgICAgIHZhciBibG9iID0gdGhpcy5mbGFzaEV4ZWMoICdCbG9iJywgJ3NsaWNlJywgc3RhcnQsIGVuZCApO1xuICAgIFxuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgQmxvYiggYmxvYi51aWQsIGJsb2IgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfSk7XG4gICAgLyoqXG4gICAgICogQGZpbGVPdmVydmlldyAgTWQ1IGZsYXNo5a6e546wXG4gICAgICovXG4gICAgZGVmaW5lKCdydW50aW1lL2ZsYXNoL21kNScsW1xuICAgICAgICAncnVudGltZS9mbGFzaC9ydW50aW1lJ1xuICAgIF0sIGZ1bmN0aW9uKCBGbGFzaFJ1bnRpbWUgKSB7XG4gICAgICAgIFxuICAgICAgICByZXR1cm4gRmxhc2hSdW50aW1lLnJlZ2lzdGVyKCAnTWQ1Jywge1xuICAgICAgICAgICAgaW5pdDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgLy8gZG8gbm90aGluZy5cbiAgICAgICAgICAgIH0sXG4gICAgXG4gICAgICAgICAgICBsb2FkRnJvbUJsb2I6IGZ1bmN0aW9uKCBibG9iICkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmZsYXNoRXhlYyggJ01kNScsICdsb2FkRnJvbUJsb2InLCBibG9iLnVpZCApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9KTtcbiAgICAvKipcbiAgICAgKiBAZmlsZU92ZXJ2aWV3IOWujOWFqOeJiOacrOOAglxuICAgICAqL1xuICAgIGRlZmluZSgncHJlc2V0L2FsbCcsW1xuICAgICAgICAnYmFzZScsXG4gICAgXG4gICAgICAgIC8vIHdpZGdldHNcbiAgICAgICAgJ3dpZGdldHMvZmlsZWRuZCcsXG4gICAgICAgICd3aWRnZXRzL2ZpbGVwYXN0ZScsXG4gICAgICAgICd3aWRnZXRzL2ZpbGVwaWNrZXInLFxuICAgICAgICAnd2lkZ2V0cy9pbWFnZScsXG4gICAgICAgICd3aWRnZXRzL3F1ZXVlJyxcbiAgICAgICAgJ3dpZGdldHMvcnVudGltZScsXG4gICAgICAgICd3aWRnZXRzL3VwbG9hZCcsXG4gICAgICAgICd3aWRnZXRzL3ZhbGlkYXRvcicsXG4gICAgICAgICd3aWRnZXRzL21kNScsXG4gICAgXG4gICAgICAgIC8vIHJ1bnRpbWVzXG4gICAgICAgIC8vIGh0bWw1XG4gICAgICAgICdydW50aW1lL2h0bWw1L2Jsb2InLFxuICAgICAgICAncnVudGltZS9odG1sNS9kbmQnLFxuICAgICAgICAncnVudGltZS9odG1sNS9maWxlcGFzdGUnLFxuICAgICAgICAncnVudGltZS9odG1sNS9maWxlcGlja2VyJyxcbiAgICAgICAgJ3J1bnRpbWUvaHRtbDUvaW1hZ2VtZXRhL2V4aWYnLFxuICAgICAgICAncnVudGltZS9odG1sNS9hbmRyb2lkcGF0Y2gnLFxuICAgICAgICAncnVudGltZS9odG1sNS9pbWFnZScsXG4gICAgICAgICdydW50aW1lL2h0bWw1L3RyYW5zcG9ydCcsXG4gICAgICAgICdydW50aW1lL2h0bWw1L21kNScsXG4gICAgXG4gICAgICAgIC8vIGZsYXNoXG4gICAgICAgICdydW50aW1lL2ZsYXNoL2ZpbGVwaWNrZXInLFxuICAgICAgICAncnVudGltZS9mbGFzaC9pbWFnZScsXG4gICAgICAgICdydW50aW1lL2ZsYXNoL3RyYW5zcG9ydCcsXG4gICAgICAgICdydW50aW1lL2ZsYXNoL2Jsb2InLFxuICAgICAgICAncnVudGltZS9mbGFzaC9tZDUnXG4gICAgXSwgZnVuY3Rpb24oIEJhc2UgKSB7XG4gICAgICAgIHJldHVybiBCYXNlO1xuICAgIH0pO1xuICAgIC8qKlxuICAgICAqIEBmaWxlT3ZlcnZpZXcg5pel5b+X57uE5Lu277yM5Li76KaB55So5p2l5pS26ZuG6ZSZ6K+v5L+h5oGv77yM5Y+v5Lul5biu5YqpIHdlYnVwbG9hZGVyIOabtOWlveeahOWumuS9jemXrumimOWSjOWPkeWxleOAglxuICAgICAqXG4gICAgICog5aaC5p6c5oKo5LiN5oOz6KaB5ZCv55So5q2k5Yqf6IO977yM6K+35Zyo5omT5YyF55qE5pe25YCZ5Y675o6JIGxvZyDmqKHlnZfjgIJcbiAgICAgKlxuICAgICAqIOaIluiAheWPr+S7peWcqOWIneWni+WMlueahOaXtuWAmemAmui/hyBvcHRpb25zLmRpc2FibGVXaWRnZXRzIOWxnuaAp+emgeeUqOOAglxuICAgICAqXG4gICAgICog5aaC77yaXG4gICAgICogV2ViVXBsb2FkZXIuY3JlYXRlKHtcbiAgICAgKiAgICAgLi4uXG4gICAgICpcbiAgICAgKiAgICAgZGlzYWJsZVdpZGdldHM6ICdsb2cnLFxuICAgICAqXG4gICAgICogICAgIC4uLlxuICAgICAqIH0pXG4gICAgICovXG4gICAgZGVmaW5lKCd3aWRnZXRzL2xvZycsW1xuICAgICAgICAnYmFzZScsXG4gICAgICAgICd1cGxvYWRlcicsXG4gICAgICAgICd3aWRnZXRzL3dpZGdldCdcbiAgICBdLCBmdW5jdGlvbiggQmFzZSwgVXBsb2FkZXIgKSB7XG4gICAgICAgIHZhciAkID0gQmFzZS4kLFxuICAgICAgICAgICAgbG9nVXJsID0gJyBodHRwOi8vc3RhdGljLnRpZWJhLmJhaWR1LmNvbS90Yi9wbXMvaW1nL3N0LmdpZj8/JyxcbiAgICAgICAgICAgIHByb2R1Y3QgPSAobG9jYXRpb24uaG9zdG5hbWUgfHwgbG9jYXRpb24uaG9zdCB8fCAncHJvdGVjdGVkJykudG9Mb3dlckNhc2UoKSxcbiAgICBcbiAgICAgICAgICAgIC8vIOWPqumSiOWvuSBiYWlkdSDlhoXpg6jkuqflk4HnlKjmiLflgZrnu5/orqHlip/og73jgIJcbiAgICAgICAgICAgIGVuYWJsZSA9IHByb2R1Y3QgJiYgL2JhaWR1L2kuZXhlYyhwcm9kdWN0KSxcbiAgICAgICAgICAgIGJhc2U7XG4gICAgXG4gICAgICAgIGlmICghZW5hYmxlKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICBcbiAgICAgICAgYmFzZSA9IHtcbiAgICAgICAgICAgIGR2OiAzLFxuICAgICAgICAgICAgbWFzdGVyOiAnd2VidXBsb2FkZXInLFxuICAgICAgICAgICAgb25saW5lOiAvdGVzdC8uZXhlYyhwcm9kdWN0KSA/IDAgOiAxLFxuICAgICAgICAgICAgbW9kdWxlOiAnJyxcbiAgICAgICAgICAgIHByb2R1Y3Q6IHByb2R1Y3QsXG4gICAgICAgICAgICB0eXBlOiAwXG4gICAgICAgIH07XG4gICAgXG4gICAgICAgIGZ1bmN0aW9uIHNlbmQoZGF0YSkge1xuICAgICAgICAgICAgdmFyIG9iaiA9ICQuZXh0ZW5kKHt9LCBiYXNlLCBkYXRhKSxcbiAgICAgICAgICAgICAgICB1cmwgPSBsb2dVcmwucmVwbGFjZSgvXiguKilcXD8vLCAnJDEnICsgJC5wYXJhbSggb2JqICkpLFxuICAgICAgICAgICAgICAgIGltYWdlID0gbmV3IEltYWdlKCk7XG4gICAgXG4gICAgICAgICAgICBpbWFnZS5zcmMgPSB1cmw7XG4gICAgICAgIH1cbiAgICBcbiAgICAgICAgcmV0dXJuIFVwbG9hZGVyLnJlZ2lzdGVyKHtcbiAgICAgICAgICAgIG5hbWU6ICdsb2cnLFxuICAgIFxuICAgICAgICAgICAgaW5pdDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgdmFyIG93bmVyID0gdGhpcy5vd25lcixcbiAgICAgICAgICAgICAgICAgICAgY291bnQgPSAwLFxuICAgICAgICAgICAgICAgICAgICBzaXplID0gMDtcbiAgICBcbiAgICAgICAgICAgICAgICBvd25lclxuICAgICAgICAgICAgICAgICAgICAub24oJ2Vycm9yJywgZnVuY3Rpb24oY29kZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgc2VuZCh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogMixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjX2Vycm9yX2NvZGU6IGNvZGVcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgICAgICAub24oJ3VwbG9hZEVycm9yJywgZnVuY3Rpb24oZmlsZSwgcmVhc29uKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZW5kKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiAyLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNfZXJyb3JfY29kZTogJ1VQTE9BRF9FUlJPUicsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY19yZWFzb246ICcnICsgcmVhc29uXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAgICAgLm9uKCd1cGxvYWRDb21wbGV0ZScsIGZ1bmN0aW9uKGZpbGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvdW50Kys7XG4gICAgICAgICAgICAgICAgICAgICAgICBzaXplICs9IGZpbGUuc2l6ZTtcbiAgICAgICAgICAgICAgICAgICAgfSkuXG4gICAgICAgICAgICAgICAgICAgIG9uKCd1cGxvYWRGaW5pc2hlZCcsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgc2VuZCh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY19jb3VudDogY291bnQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY19zaXplOiBzaXplXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvdW50ID0gc2l6ZSA9IDA7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgIFxuICAgICAgICAgICAgICAgIHNlbmQoe1xuICAgICAgICAgICAgICAgICAgICBjX3VzYWdlOiAxXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH0pO1xuICAgIC8qKlxuICAgICAqIEBmaWxlT3ZlcnZpZXcgVXBsb2FkZXLkuIrkvKDnsbtcbiAgICAgKi9cbiAgICBkZWZpbmUoJ3dlYnVwbG9hZGVyJyxbXG4gICAgICAgICdwcmVzZXQvYWxsJyxcbiAgICAgICAgJ3dpZGdldHMvbG9nJ1xuICAgIF0sIGZ1bmN0aW9uKCBwcmVzZXQgKSB7XG4gICAgICAgIHJldHVybiBwcmVzZXQ7XG4gICAgfSk7XG4gICAgcmV0dXJuIHJlcXVpcmUoJ3dlYnVwbG9hZGVyJyk7XG59KTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy9jb21wb25lbnRzL3dlYnVwbG9hZGVyL3dlYnVwbG9hZGVyLTAuMS41L3dlYnVwbG9hZGVyLmpzIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///66\n");

/***/ }),
/* 67 */
/***/ (function(module, exports) {

eval("module.exports = function(originalModule) {\r\n\tif(!originalModule.webpackPolyfill) {\r\n\t\tvar module = Object.create(originalModule);\r\n\t\t// module.parent = undefined by default\r\n\t\tif(!module.children) module.children = [];\r\n\t\tObject.defineProperty(module, \"loaded\", {\r\n\t\t\tenumerable: true,\r\n\t\t\tget: function() {\r\n\t\t\t\treturn module.l;\r\n\t\t\t}\r\n\t\t});\r\n\t\tObject.defineProperty(module, \"id\", {\r\n\t\t\tenumerable: true,\r\n\t\t\tget: function() {\r\n\t\t\t\treturn module.i;\r\n\t\t\t}\r\n\t\t});\r\n\t\tObject.defineProperty(module, \"exports\", {\r\n\t\t\tenumerable: true,\r\n\t\t});\r\n\t\tmodule.webpackPolyfill = 1;\r\n\t}\r\n\treturn module;\r\n};\r\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vKHdlYnBhY2spL2J1aWxkaW4vaGFybW9ueS1tb2R1bGUuanM/Y2M5NiJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EiLCJmaWxlIjoiNjcuanMiLCJzb3VyY2VzQ29udGVudCI6WyJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKG9yaWdpbmFsTW9kdWxlKSB7XHJcblx0aWYoIW9yaWdpbmFsTW9kdWxlLndlYnBhY2tQb2x5ZmlsbCkge1xyXG5cdFx0dmFyIG1vZHVsZSA9IE9iamVjdC5jcmVhdGUob3JpZ2luYWxNb2R1bGUpO1xyXG5cdFx0Ly8gbW9kdWxlLnBhcmVudCA9IHVuZGVmaW5lZCBieSBkZWZhdWx0XHJcblx0XHRpZighbW9kdWxlLmNoaWxkcmVuKSBtb2R1bGUuY2hpbGRyZW4gPSBbXTtcclxuXHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShtb2R1bGUsIFwibG9hZGVkXCIsIHtcclxuXHRcdFx0ZW51bWVyYWJsZTogdHJ1ZSxcclxuXHRcdFx0Z2V0OiBmdW5jdGlvbigpIHtcclxuXHRcdFx0XHRyZXR1cm4gbW9kdWxlLmw7XHJcblx0XHRcdH1cclxuXHRcdH0pO1xyXG5cdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KG1vZHVsZSwgXCJpZFwiLCB7XHJcblx0XHRcdGVudW1lcmFibGU6IHRydWUsXHJcblx0XHRcdGdldDogZnVuY3Rpb24oKSB7XHJcblx0XHRcdFx0cmV0dXJuIG1vZHVsZS5pO1xyXG5cdFx0XHR9XHJcblx0XHR9KTtcclxuXHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShtb2R1bGUsIFwiZXhwb3J0c1wiLCB7XHJcblx0XHRcdGVudW1lcmFibGU6IHRydWUsXHJcblx0XHR9KTtcclxuXHRcdG1vZHVsZS53ZWJwYWNrUG9seWZpbGwgPSAxO1xyXG5cdH1cclxuXHRyZXR1cm4gbW9kdWxlO1xyXG59O1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAod2VicGFjaykvYnVpbGRpbi9oYXJtb255LW1vZHVsZS5qc1xuLy8gbW9kdWxlIGlkID0gNjdcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///67\n");

/***/ }),
/* 68 */
/***/ (function(module, exports, __webpack_require__) {

eval("module.exports = { \"default\": __webpack_require__(69), __esModule: true };\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvYmFiZWwtcnVudGltZS9jb3JlLWpzL29iamVjdC9jcmVhdGUuanM/M2FmNCJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSxrQkFBa0IsWUFBWSxtQkFBTyxDQUFDLEVBQWtDIiwiZmlsZSI6IjY4LmpzIiwic291cmNlc0NvbnRlbnQiOlsibW9kdWxlLmV4cG9ydHMgPSB7IFwiZGVmYXVsdFwiOiByZXF1aXJlKFwiY29yZS1qcy9saWJyYXJ5L2ZuL29iamVjdC9jcmVhdGVcIiksIF9fZXNNb2R1bGU6IHRydWUgfTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9iYWJlbC1ydW50aW1lL2NvcmUtanMvb2JqZWN0L2NyZWF0ZS5qc1xuLy8gbW9kdWxlIGlkID0gNjhcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///68\n");

/***/ }),
/* 69 */
/***/ (function(module, exports, __webpack_require__) {

eval("__webpack_require__(70);\nvar $Object = __webpack_require__(2).Object;\nmodule.exports = function create(P, D) {\n  return $Object.create(P, D);\n};\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L2ZuL29iamVjdC9jcmVhdGUuanM/YTBjZSJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSxtQkFBTyxDQUFDLEVBQWlDO0FBQ3pDLGNBQWMsbUJBQU8sQ0FBQyxDQUFxQjtBQUMzQztBQUNBO0FBQ0EiLCJmaWxlIjoiNjkuanMiLCJzb3VyY2VzQ29udGVudCI6WyJyZXF1aXJlKCcuLi8uLi9tb2R1bGVzL2VzNi5vYmplY3QuY3JlYXRlJyk7XG52YXIgJE9iamVjdCA9IHJlcXVpcmUoJy4uLy4uL21vZHVsZXMvX2NvcmUnKS5PYmplY3Q7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGNyZWF0ZShQLCBEKSB7XG4gIHJldHVybiAkT2JqZWN0LmNyZWF0ZShQLCBEKTtcbn07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvZm4vb2JqZWN0L2NyZWF0ZS5qc1xuLy8gbW9kdWxlIGlkID0gNjlcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///69\n");

/***/ }),
/* 70 */
/***/ (function(module, exports, __webpack_require__) {

eval("var $export = __webpack_require__(17);\n// 19.1.2.2 / 15.2.3.5 Object.create(O [, Properties])\n$export($export.S, 'Object', { create: __webpack_require__(19) });\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvZXM2Lm9iamVjdC5jcmVhdGUuanM/YjA1ZiJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSxjQUFjLG1CQUFPLENBQUMsRUFBVztBQUNqQztBQUNBLDhCQUE4QixTQUFTLG1CQUFPLENBQUMsRUFBa0IsR0FBRyIsImZpbGUiOiI3MC5qcyIsInNvdXJjZXNDb250ZW50IjpbInZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG4vLyAxOS4xLjIuMiAvIDE1LjIuMy41IE9iamVjdC5jcmVhdGUoTyBbLCBQcm9wZXJ0aWVzXSlcbiRleHBvcnQoJGV4cG9ydC5TLCAnT2JqZWN0JywgeyBjcmVhdGU6IHJlcXVpcmUoJy4vX29iamVjdC1jcmVhdGUnKSB9KTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL2VzNi5vYmplY3QuY3JlYXRlLmpzXG4vLyBtb2R1bGUgaWQgPSA3MFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///70\n");

/***/ }),
/* 71 */
/***/ (function(module, exports, __webpack_require__) {

eval("// optional / simple context binding\nvar aFunction = __webpack_require__(72);\nmodule.exports = function (fn, that, length) {\n  aFunction(fn);\n  if (that === undefined) return fn;\n  switch (length) {\n    case 1: return function (a) {\n      return fn.call(that, a);\n    };\n    case 2: return function (a, b) {\n      return fn.call(that, a, b);\n    };\n    case 3: return function (a, b, c) {\n      return fn.call(that, a, b, c);\n    };\n  }\n  return function (/* ...args */) {\n    return fn.apply(that, arguments);\n  };\n};\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2N0eC5qcz9mOTkzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0EsZ0JBQWdCLG1CQUFPLENBQUMsRUFBZTtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJmaWxlIjoiNzEuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvLyBvcHRpb25hbCAvIHNpbXBsZSBjb250ZXh0IGJpbmRpbmdcbnZhciBhRnVuY3Rpb24gPSByZXF1aXJlKCcuL19hLWZ1bmN0aW9uJyk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChmbiwgdGhhdCwgbGVuZ3RoKSB7XG4gIGFGdW5jdGlvbihmbik7XG4gIGlmICh0aGF0ID09PSB1bmRlZmluZWQpIHJldHVybiBmbjtcbiAgc3dpdGNoIChsZW5ndGgpIHtcbiAgICBjYXNlIDE6IHJldHVybiBmdW5jdGlvbiAoYSkge1xuICAgICAgcmV0dXJuIGZuLmNhbGwodGhhdCwgYSk7XG4gICAgfTtcbiAgICBjYXNlIDI6IHJldHVybiBmdW5jdGlvbiAoYSwgYikge1xuICAgICAgcmV0dXJuIGZuLmNhbGwodGhhdCwgYSwgYik7XG4gICAgfTtcbiAgICBjYXNlIDM6IHJldHVybiBmdW5jdGlvbiAoYSwgYiwgYykge1xuICAgICAgcmV0dXJuIGZuLmNhbGwodGhhdCwgYSwgYiwgYyk7XG4gICAgfTtcbiAgfVxuICByZXR1cm4gZnVuY3Rpb24gKC8qIC4uLmFyZ3MgKi8pIHtcbiAgICByZXR1cm4gZm4uYXBwbHkodGhhdCwgYXJndW1lbnRzKTtcbiAgfTtcbn07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fY3R4LmpzXG4vLyBtb2R1bGUgaWQgPSA3MVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///71\n");

/***/ }),
/* 72 */
/***/ (function(module, exports) {

eval("module.exports = function (it) {\n  if (typeof it != 'function') throw TypeError(it + ' is not a function!');\n  return it;\n};\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2EtZnVuY3Rpb24uanM/OTRlOSJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQSIsImZpbGUiOiI3Mi5qcyIsInNvdXJjZXNDb250ZW50IjpbIm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGl0KSB7XG4gIGlmICh0eXBlb2YgaXQgIT0gJ2Z1bmN0aW9uJykgdGhyb3cgVHlwZUVycm9yKGl0ICsgJyBpcyBub3QgYSBmdW5jdGlvbiEnKTtcbiAgcmV0dXJuIGl0O1xufTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19hLWZ1bmN0aW9uLmpzXG4vLyBtb2R1bGUgaWQgPSA3MlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///72\n");

/***/ }),
/* 73 */
/***/ (function(module, exports, __webpack_require__) {

eval("var dP = __webpack_require__(4);\nvar anObject = __webpack_require__(12);\nvar getKeys = __webpack_require__(20);\n\nmodule.exports = __webpack_require__(5) ? Object.defineProperties : function defineProperties(O, Properties) {\n  anObject(O);\n  var keys = getKeys(Properties);\n  var length = keys.length;\n  var i = 0;\n  var P;\n  while (length > i) dP.f(O, P = keys[i++], Properties[P]);\n  return O;\n};\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX29iamVjdC1kcHMuanM/YWEyYSJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSxTQUFTLG1CQUFPLENBQUMsQ0FBYztBQUMvQixlQUFlLG1CQUFPLENBQUMsRUFBYztBQUNyQyxjQUFjLG1CQUFPLENBQUMsRUFBZ0I7O0FBRXRDLGlCQUFpQixtQkFBTyxDQUFDLENBQWdCO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJmaWxlIjoiNzMuanMiLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgZFAgPSByZXF1aXJlKCcuL19vYmplY3QtZHAnKTtcbnZhciBhbk9iamVjdCA9IHJlcXVpcmUoJy4vX2FuLW9iamVjdCcpO1xudmFyIGdldEtleXMgPSByZXF1aXJlKCcuL19vYmplY3Qta2V5cycpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vX2Rlc2NyaXB0b3JzJykgPyBPYmplY3QuZGVmaW5lUHJvcGVydGllcyA6IGZ1bmN0aW9uIGRlZmluZVByb3BlcnRpZXMoTywgUHJvcGVydGllcykge1xuICBhbk9iamVjdChPKTtcbiAgdmFyIGtleXMgPSBnZXRLZXlzKFByb3BlcnRpZXMpO1xuICB2YXIgbGVuZ3RoID0ga2V5cy5sZW5ndGg7XG4gIHZhciBpID0gMDtcbiAgdmFyIFA7XG4gIHdoaWxlIChsZW5ndGggPiBpKSBkUC5mKE8sIFAgPSBrZXlzW2krK10sIFByb3BlcnRpZXNbUF0pO1xuICByZXR1cm4gTztcbn07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fb2JqZWN0LWRwcy5qc1xuLy8gbW9kdWxlIGlkID0gNzNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///73\n");

/***/ }),
/* 74 */
/***/ (function(module, exports, __webpack_require__) {

eval("// fallback for non-array-like ES3 and non-enumerable old V8 strings\nvar cof = __webpack_require__(39);\n// eslint-disable-next-line no-prototype-builtins\nmodule.exports = Object('z').propertyIsEnumerable(0) ? Object : function (it) {\n  return cof(it) == 'String' ? it.split('') : Object(it);\n};\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2lvYmplY3QuanM/MzE0ZSJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUNBLFVBQVUsbUJBQU8sQ0FBQyxFQUFRO0FBQzFCO0FBQ0E7QUFDQTtBQUNBIiwiZmlsZSI6Ijc0LmpzIiwic291cmNlc0NvbnRlbnQiOlsiLy8gZmFsbGJhY2sgZm9yIG5vbi1hcnJheS1saWtlIEVTMyBhbmQgbm9uLWVudW1lcmFibGUgb2xkIFY4IHN0cmluZ3NcbnZhciBjb2YgPSByZXF1aXJlKCcuL19jb2YnKTtcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1wcm90b3R5cGUtYnVpbHRpbnNcbm1vZHVsZS5leHBvcnRzID0gT2JqZWN0KCd6JykucHJvcGVydHlJc0VudW1lcmFibGUoMCkgPyBPYmplY3QgOiBmdW5jdGlvbiAoaXQpIHtcbiAgcmV0dXJuIGNvZihpdCkgPT0gJ1N0cmluZycgPyBpdC5zcGxpdCgnJykgOiBPYmplY3QoaXQpO1xufTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19pb2JqZWN0LmpzXG4vLyBtb2R1bGUgaWQgPSA3NFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///74\n");

/***/ }),
/* 75 */
/***/ (function(module, exports, __webpack_require__) {

eval("// false -> Array#indexOf\n// true  -> Array#includes\nvar toIObject = __webpack_require__(6);\nvar toLength = __webpack_require__(76);\nvar toAbsoluteIndex = __webpack_require__(77);\nmodule.exports = function (IS_INCLUDES) {\n  return function ($this, el, fromIndex) {\n    var O = toIObject($this);\n    var length = toLength(O.length);\n    var index = toAbsoluteIndex(fromIndex, length);\n    var value;\n    // Array#includes uses SameValueZero equality algorithm\n    // eslint-disable-next-line no-self-compare\n    if (IS_INCLUDES && el != el) while (length > index) {\n      value = O[index++];\n      // eslint-disable-next-line no-self-compare\n      if (value != value) return true;\n    // Array#indexOf ignores holes, Array#includes - not\n    } else for (;length > index; index++) if (IS_INCLUDES || index in O) {\n      if (O[index] === el) return IS_INCLUDES || index || 0;\n    } return !IS_INCLUDES && -1;\n  };\n};\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2FycmF5LWluY2x1ZGVzLmpzP2JjNTciXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBLGdCQUFnQixtQkFBTyxDQUFDLENBQWU7QUFDdkMsZUFBZSxtQkFBTyxDQUFDLEVBQWM7QUFDckMsc0JBQXNCLG1CQUFPLENBQUMsRUFBc0I7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLLFlBQVksZUFBZTtBQUNoQztBQUNBLEtBQUs7QUFDTDtBQUNBIiwiZmlsZSI6Ijc1LmpzIiwic291cmNlc0NvbnRlbnQiOlsiLy8gZmFsc2UgLT4gQXJyYXkjaW5kZXhPZlxuLy8gdHJ1ZSAgLT4gQXJyYXkjaW5jbHVkZXNcbnZhciB0b0lPYmplY3QgPSByZXF1aXJlKCcuL190by1pb2JqZWN0Jyk7XG52YXIgdG9MZW5ndGggPSByZXF1aXJlKCcuL190by1sZW5ndGgnKTtcbnZhciB0b0Fic29sdXRlSW5kZXggPSByZXF1aXJlKCcuL190by1hYnNvbHV0ZS1pbmRleCcpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoSVNfSU5DTFVERVMpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uICgkdGhpcywgZWwsIGZyb21JbmRleCkge1xuICAgIHZhciBPID0gdG9JT2JqZWN0KCR0aGlzKTtcbiAgICB2YXIgbGVuZ3RoID0gdG9MZW5ndGgoTy5sZW5ndGgpO1xuICAgIHZhciBpbmRleCA9IHRvQWJzb2x1dGVJbmRleChmcm9tSW5kZXgsIGxlbmd0aCk7XG4gICAgdmFyIHZhbHVlO1xuICAgIC8vIEFycmF5I2luY2x1ZGVzIHVzZXMgU2FtZVZhbHVlWmVybyBlcXVhbGl0eSBhbGdvcml0aG1cbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tc2VsZi1jb21wYXJlXG4gICAgaWYgKElTX0lOQ0xVREVTICYmIGVsICE9IGVsKSB3aGlsZSAobGVuZ3RoID4gaW5kZXgpIHtcbiAgICAgIHZhbHVlID0gT1tpbmRleCsrXTtcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1zZWxmLWNvbXBhcmVcbiAgICAgIGlmICh2YWx1ZSAhPSB2YWx1ZSkgcmV0dXJuIHRydWU7XG4gICAgLy8gQXJyYXkjaW5kZXhPZiBpZ25vcmVzIGhvbGVzLCBBcnJheSNpbmNsdWRlcyAtIG5vdFxuICAgIH0gZWxzZSBmb3IgKDtsZW5ndGggPiBpbmRleDsgaW5kZXgrKykgaWYgKElTX0lOQ0xVREVTIHx8IGluZGV4IGluIE8pIHtcbiAgICAgIGlmIChPW2luZGV4XSA9PT0gZWwpIHJldHVybiBJU19JTkNMVURFUyB8fCBpbmRleCB8fCAwO1xuICAgIH0gcmV0dXJuICFJU19JTkNMVURFUyAmJiAtMTtcbiAgfTtcbn07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fYXJyYXktaW5jbHVkZXMuanNcbi8vIG1vZHVsZSBpZCA9IDc1XG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///75\n");

/***/ }),
/* 76 */
/***/ (function(module, exports, __webpack_require__) {

eval("// 7.1.15 ToLength\nvar toInteger = __webpack_require__(22);\nvar min = Math.min;\nmodule.exports = function (it) {\n  return it > 0 ? min(toInteger(it), 0x1fffffffffffff) : 0; // pow(2, 53) - 1 == 9007199254740991\n};\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX3RvLWxlbmd0aC5qcz80MTExIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0EsZ0JBQWdCLG1CQUFPLENBQUMsRUFBZTtBQUN2QztBQUNBO0FBQ0EsMkRBQTJEO0FBQzNEIiwiZmlsZSI6Ijc2LmpzIiwic291cmNlc0NvbnRlbnQiOlsiLy8gNy4xLjE1IFRvTGVuZ3RoXG52YXIgdG9JbnRlZ2VyID0gcmVxdWlyZSgnLi9fdG8taW50ZWdlcicpO1xudmFyIG1pbiA9IE1hdGgubWluO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaXQpIHtcbiAgcmV0dXJuIGl0ID4gMCA/IG1pbih0b0ludGVnZXIoaXQpLCAweDFmZmZmZmZmZmZmZmZmKSA6IDA7IC8vIHBvdygyLCA1MykgLSAxID09IDkwMDcxOTkyNTQ3NDA5OTFcbn07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fdG8tbGVuZ3RoLmpzXG4vLyBtb2R1bGUgaWQgPSA3NlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///76\n");

/***/ }),
/* 77 */
/***/ (function(module, exports, __webpack_require__) {

eval("var toInteger = __webpack_require__(22);\nvar max = Math.max;\nvar min = Math.min;\nmodule.exports = function (index, length) {\n  index = toInteger(index);\n  return index < 0 ? max(index + length, 0) : min(index, length);\n};\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX3RvLWFic29sdXRlLWluZGV4LmpzPzdlNDAiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEsZ0JBQWdCLG1CQUFPLENBQUMsRUFBZTtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJmaWxlIjoiNzcuanMiLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgdG9JbnRlZ2VyID0gcmVxdWlyZSgnLi9fdG8taW50ZWdlcicpO1xudmFyIG1heCA9IE1hdGgubWF4O1xudmFyIG1pbiA9IE1hdGgubWluO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaW5kZXgsIGxlbmd0aCkge1xuICBpbmRleCA9IHRvSW50ZWdlcihpbmRleCk7XG4gIHJldHVybiBpbmRleCA8IDAgPyBtYXgoaW5kZXggKyBsZW5ndGgsIDApIDogbWluKGluZGV4LCBsZW5ndGgpO1xufTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL190by1hYnNvbHV0ZS1pbmRleC5qc1xuLy8gbW9kdWxlIGlkID0gNzdcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///77\n");

/***/ }),
/* 78 */
/***/ (function(module, exports, __webpack_require__) {

eval("var document = __webpack_require__(0).document;\nmodule.exports = document && document.documentElement;\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2h0bWwuanM/NDRmMiJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSxlQUFlLG1CQUFPLENBQUMsQ0FBVztBQUNsQyIsImZpbGUiOiI3OC5qcyIsInNvdXJjZXNDb250ZW50IjpbInZhciBkb2N1bWVudCA9IHJlcXVpcmUoJy4vX2dsb2JhbCcpLmRvY3VtZW50O1xubW9kdWxlLmV4cG9ydHMgPSBkb2N1bWVudCAmJiBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQ7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9faHRtbC5qc1xuLy8gbW9kdWxlIGlkID0gNzhcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///78\n");

/***/ }),
/* 79 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nexports.__esModule = true;\n\nvar _iterator = __webpack_require__(80);\n\nvar _iterator2 = _interopRequireDefault(_iterator);\n\nvar _symbol = __webpack_require__(90);\n\nvar _symbol2 = _interopRequireDefault(_symbol);\n\nvar _typeof = typeof _symbol2.default === \"function\" && typeof _iterator2.default === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof _symbol2.default === \"function\" && obj.constructor === _symbol2.default && obj !== _symbol2.default.prototype ? \"symbol\" : typeof obj; };\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nexports.default = typeof _symbol2.default === \"function\" && _typeof(_iterator2.default) === \"symbol\" ? function (obj) {\n  return typeof obj === \"undefined\" ? \"undefined\" : _typeof(obj);\n} : function (obj) {\n  return obj && typeof _symbol2.default === \"function\" && obj.constructor === _symbol2.default && obj !== _symbol2.default.prototype ? \"symbol\" : typeof obj === \"undefined\" ? \"undefined\" : _typeof(obj);\n};\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvYmFiZWwtcnVudGltZS9oZWxwZXJzL3R5cGVvZi5qcz9hNDU2Il0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFhOztBQUViOztBQUVBLGdCQUFnQixtQkFBTyxDQUFDLEVBQTRCOztBQUVwRDs7QUFFQSxjQUFjLG1CQUFPLENBQUMsRUFBbUI7O0FBRXpDOztBQUVBLGlIQUFpSCxtQkFBbUIsRUFBRSxtQkFBbUIsNEpBQTRKOztBQUVyVCxzQ0FBc0MsdUNBQXVDLGdCQUFnQjs7QUFFN0Y7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBIiwiZmlsZSI6Ijc5LmpzIiwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5cbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5cbnZhciBfaXRlcmF0b3IgPSByZXF1aXJlKFwiLi4vY29yZS1qcy9zeW1ib2wvaXRlcmF0b3JcIik7XG5cbnZhciBfaXRlcmF0b3IyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfaXRlcmF0b3IpO1xuXG52YXIgX3N5bWJvbCA9IHJlcXVpcmUoXCIuLi9jb3JlLWpzL3N5bWJvbFwiKTtcblxudmFyIF9zeW1ib2wyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfc3ltYm9sKTtcblxudmFyIF90eXBlb2YgPSB0eXBlb2YgX3N5bWJvbDIuZGVmYXVsdCA9PT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiBfaXRlcmF0b3IyLmRlZmF1bHQgPT09IFwic3ltYm9sXCIgPyBmdW5jdGlvbiAob2JqKSB7IHJldHVybiB0eXBlb2Ygb2JqOyB9IDogZnVuY3Rpb24gKG9iaikgeyByZXR1cm4gb2JqICYmIHR5cGVvZiBfc3ltYm9sMi5kZWZhdWx0ID09PSBcImZ1bmN0aW9uXCIgJiYgb2JqLmNvbnN0cnVjdG9yID09PSBfc3ltYm9sMi5kZWZhdWx0ICYmIG9iaiAhPT0gX3N5bWJvbDIuZGVmYXVsdC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIG9iajsgfTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuZXhwb3J0cy5kZWZhdWx0ID0gdHlwZW9mIF9zeW1ib2wyLmRlZmF1bHQgPT09IFwiZnVuY3Rpb25cIiAmJiBfdHlwZW9mKF9pdGVyYXRvcjIuZGVmYXVsdCkgPT09IFwic3ltYm9sXCIgPyBmdW5jdGlvbiAob2JqKSB7XG4gIHJldHVybiB0eXBlb2Ygb2JqID09PSBcInVuZGVmaW5lZFwiID8gXCJ1bmRlZmluZWRcIiA6IF90eXBlb2Yob2JqKTtcbn0gOiBmdW5jdGlvbiAob2JqKSB7XG4gIHJldHVybiBvYmogJiYgdHlwZW9mIF9zeW1ib2wyLmRlZmF1bHQgPT09IFwiZnVuY3Rpb25cIiAmJiBvYmouY29uc3RydWN0b3IgPT09IF9zeW1ib2wyLmRlZmF1bHQgJiYgb2JqICE9PSBfc3ltYm9sMi5kZWZhdWx0LnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2Ygb2JqID09PSBcInVuZGVmaW5lZFwiID8gXCJ1bmRlZmluZWRcIiA6IF90eXBlb2Yob2JqKTtcbn07XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvYmFiZWwtcnVudGltZS9oZWxwZXJzL3R5cGVvZi5qc1xuLy8gbW9kdWxlIGlkID0gNzlcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///79\n");

/***/ }),
/* 80 */
/***/ (function(module, exports, __webpack_require__) {

eval("module.exports = { \"default\": __webpack_require__(81), __esModule: true };\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvYmFiZWwtcnVudGltZS9jb3JlLWpzL3N5bWJvbC9pdGVyYXRvci5qcz82NzM4Il0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBLGtCQUFrQixZQUFZLG1CQUFPLENBQUMsRUFBb0MiLCJmaWxlIjoiODAuanMiLCJzb3VyY2VzQ29udGVudCI6WyJtb2R1bGUuZXhwb3J0cyA9IHsgXCJkZWZhdWx0XCI6IHJlcXVpcmUoXCJjb3JlLWpzL2xpYnJhcnkvZm4vc3ltYm9sL2l0ZXJhdG9yXCIpLCBfX2VzTW9kdWxlOiB0cnVlIH07XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvYmFiZWwtcnVudGltZS9jb3JlLWpzL3N5bWJvbC9pdGVyYXRvci5qc1xuLy8gbW9kdWxlIGlkID0gODBcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///80\n");

/***/ }),
/* 81 */
/***/ (function(module, exports, __webpack_require__) {

eval("__webpack_require__(82);\n__webpack_require__(86);\nmodule.exports = __webpack_require__(28).f('iterator');\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L2ZuL3N5bWJvbC9pdGVyYXRvci5qcz9mZTdlIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBLG1CQUFPLENBQUMsRUFBbUM7QUFDM0MsbUJBQU8sQ0FBQyxFQUFnQztBQUN4QyxpQkFBaUIsbUJBQU8sQ0FBQyxFQUF3QiIsImZpbGUiOiI4MS5qcyIsInNvdXJjZXNDb250ZW50IjpbInJlcXVpcmUoJy4uLy4uL21vZHVsZXMvZXM2LnN0cmluZy5pdGVyYXRvcicpO1xucmVxdWlyZSgnLi4vLi4vbW9kdWxlcy93ZWIuZG9tLml0ZXJhYmxlJyk7XG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4uLy4uL21vZHVsZXMvX3drcy1leHQnKS5mKCdpdGVyYXRvcicpO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L2ZuL3N5bWJvbC9pdGVyYXRvci5qc1xuLy8gbW9kdWxlIGlkID0gODFcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///81\n");

/***/ }),
/* 82 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar $at = __webpack_require__(83)(true);\n\n// 21.1.3.27 String.prototype[@@iterator]()\n__webpack_require__(40)(String, 'String', function (iterated) {\n  this._t = String(iterated); // target\n  this._i = 0;                // next index\n// 21.1.5.2.1 %StringIteratorPrototype%.next()\n}, function () {\n  var O = this._t;\n  var index = this._i;\n  var point;\n  if (index >= O.length) return { value: undefined, done: true };\n  point = $at(O, index);\n  this._i += point.length;\n  return { value: point, done: false };\n});\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvZXM2LnN0cmluZy5pdGVyYXRvci5qcz9jZDA0Il0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsVUFBVSxtQkFBTyxDQUFDLEVBQWM7O0FBRWhDO0FBQ0EsbUJBQU8sQ0FBQyxFQUFnQjtBQUN4Qiw2QkFBNkI7QUFDN0IsY0FBYztBQUNkO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQztBQUNqQztBQUNBO0FBQ0EsVUFBVTtBQUNWLENBQUMiLCJmaWxlIjoiODIuanMiLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG52YXIgJGF0ID0gcmVxdWlyZSgnLi9fc3RyaW5nLWF0JykodHJ1ZSk7XG5cbi8vIDIxLjEuMy4yNyBTdHJpbmcucHJvdG90eXBlW0BAaXRlcmF0b3JdKClcbnJlcXVpcmUoJy4vX2l0ZXItZGVmaW5lJykoU3RyaW5nLCAnU3RyaW5nJywgZnVuY3Rpb24gKGl0ZXJhdGVkKSB7XG4gIHRoaXMuX3QgPSBTdHJpbmcoaXRlcmF0ZWQpOyAvLyB0YXJnZXRcbiAgdGhpcy5faSA9IDA7ICAgICAgICAgICAgICAgIC8vIG5leHQgaW5kZXhcbi8vIDIxLjEuNS4yLjEgJVN0cmluZ0l0ZXJhdG9yUHJvdG90eXBlJS5uZXh0KClcbn0sIGZ1bmN0aW9uICgpIHtcbiAgdmFyIE8gPSB0aGlzLl90O1xuICB2YXIgaW5kZXggPSB0aGlzLl9pO1xuICB2YXIgcG9pbnQ7XG4gIGlmIChpbmRleCA+PSBPLmxlbmd0aCkgcmV0dXJuIHsgdmFsdWU6IHVuZGVmaW5lZCwgZG9uZTogdHJ1ZSB9O1xuICBwb2ludCA9ICRhdChPLCBpbmRleCk7XG4gIHRoaXMuX2kgKz0gcG9pbnQubGVuZ3RoO1xuICByZXR1cm4geyB2YWx1ZTogcG9pbnQsIGRvbmU6IGZhbHNlIH07XG59KTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL2VzNi5zdHJpbmcuaXRlcmF0b3IuanNcbi8vIG1vZHVsZSBpZCA9IDgyXG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///82\n");

/***/ }),
/* 83 */
/***/ (function(module, exports, __webpack_require__) {

eval("var toInteger = __webpack_require__(22);\nvar defined = __webpack_require__(21);\n// true  -> String#at\n// false -> String#codePointAt\nmodule.exports = function (TO_STRING) {\n  return function (that, pos) {\n    var s = String(defined(that));\n    var i = toInteger(pos);\n    var l = s.length;\n    var a, b;\n    if (i < 0 || i >= l) return TO_STRING ? '' : undefined;\n    a = s.charCodeAt(i);\n    return a < 0xd800 || a > 0xdbff || i + 1 === l || (b = s.charCodeAt(i + 1)) < 0xdc00 || b > 0xdfff\n      ? TO_STRING ? s.charAt(i) : a\n      : TO_STRING ? s.slice(i, i + 2) : (a - 0xd800 << 10) + (b - 0xdc00) + 0x10000;\n  };\n};\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX3N0cmluZy1hdC5qcz84N2FlIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBLGdCQUFnQixtQkFBTyxDQUFDLEVBQWU7QUFDdkMsY0FBYyxtQkFBTyxDQUFDLEVBQVk7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwiZmlsZSI6IjgzLmpzIiwic291cmNlc0NvbnRlbnQiOlsidmFyIHRvSW50ZWdlciA9IHJlcXVpcmUoJy4vX3RvLWludGVnZXInKTtcbnZhciBkZWZpbmVkID0gcmVxdWlyZSgnLi9fZGVmaW5lZCcpO1xuLy8gdHJ1ZSAgLT4gU3RyaW5nI2F0XG4vLyBmYWxzZSAtPiBTdHJpbmcjY29kZVBvaW50QXRcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKFRPX1NUUklORykge1xuICByZXR1cm4gZnVuY3Rpb24gKHRoYXQsIHBvcykge1xuICAgIHZhciBzID0gU3RyaW5nKGRlZmluZWQodGhhdCkpO1xuICAgIHZhciBpID0gdG9JbnRlZ2VyKHBvcyk7XG4gICAgdmFyIGwgPSBzLmxlbmd0aDtcbiAgICB2YXIgYSwgYjtcbiAgICBpZiAoaSA8IDAgfHwgaSA+PSBsKSByZXR1cm4gVE9fU1RSSU5HID8gJycgOiB1bmRlZmluZWQ7XG4gICAgYSA9IHMuY2hhckNvZGVBdChpKTtcbiAgICByZXR1cm4gYSA8IDB4ZDgwMCB8fCBhID4gMHhkYmZmIHx8IGkgKyAxID09PSBsIHx8IChiID0gcy5jaGFyQ29kZUF0KGkgKyAxKSkgPCAweGRjMDAgfHwgYiA+IDB4ZGZmZlxuICAgICAgPyBUT19TVFJJTkcgPyBzLmNoYXJBdChpKSA6IGFcbiAgICAgIDogVE9fU1RSSU5HID8gcy5zbGljZShpLCBpICsgMikgOiAoYSAtIDB4ZDgwMCA8PCAxMCkgKyAoYiAtIDB4ZGMwMCkgKyAweDEwMDAwO1xuICB9O1xufTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19zdHJpbmctYXQuanNcbi8vIG1vZHVsZSBpZCA9IDgzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///83\n");

/***/ }),
/* 84 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar create = __webpack_require__(19);\nvar descriptor = __webpack_require__(14);\nvar setToStringTag = __webpack_require__(27);\nvar IteratorPrototype = {};\n\n// 25.1.2.1.1 %IteratorPrototype%[@@iterator]()\n__webpack_require__(3)(IteratorPrototype, __webpack_require__(7)('iterator'), function () { return this; });\n\nmodule.exports = function (Constructor, NAME, next) {\n  Constructor.prototype = create(IteratorPrototype, { next: descriptor(1, next) });\n  setToStringTag(Constructor, NAME + ' Iterator');\n};\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2l0ZXItY3JlYXRlLmpzP2Y3ODUiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQWE7QUFDYixhQUFhLG1CQUFPLENBQUMsRUFBa0I7QUFDdkMsaUJBQWlCLG1CQUFPLENBQUMsRUFBa0I7QUFDM0MscUJBQXFCLG1CQUFPLENBQUMsRUFBc0I7QUFDbkQ7O0FBRUE7QUFDQSxtQkFBTyxDQUFDLENBQVMscUJBQXFCLG1CQUFPLENBQUMsQ0FBUSw0QkFBNEIsYUFBYSxFQUFFOztBQUVqRztBQUNBLHFEQUFxRCw0QkFBNEI7QUFDakY7QUFDQSIsImZpbGUiOiI4NC5qcyIsInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcbnZhciBjcmVhdGUgPSByZXF1aXJlKCcuL19vYmplY3QtY3JlYXRlJyk7XG52YXIgZGVzY3JpcHRvciA9IHJlcXVpcmUoJy4vX3Byb3BlcnR5LWRlc2MnKTtcbnZhciBzZXRUb1N0cmluZ1RhZyA9IHJlcXVpcmUoJy4vX3NldC10by1zdHJpbmctdGFnJyk7XG52YXIgSXRlcmF0b3JQcm90b3R5cGUgPSB7fTtcblxuLy8gMjUuMS4yLjEuMSAlSXRlcmF0b3JQcm90b3R5cGUlW0BAaXRlcmF0b3JdKClcbnJlcXVpcmUoJy4vX2hpZGUnKShJdGVyYXRvclByb3RvdHlwZSwgcmVxdWlyZSgnLi9fd2tzJykoJ2l0ZXJhdG9yJyksIGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXM7IH0pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChDb25zdHJ1Y3RvciwgTkFNRSwgbmV4dCkge1xuICBDb25zdHJ1Y3Rvci5wcm90b3R5cGUgPSBjcmVhdGUoSXRlcmF0b3JQcm90b3R5cGUsIHsgbmV4dDogZGVzY3JpcHRvcigxLCBuZXh0KSB9KTtcbiAgc2V0VG9TdHJpbmdUYWcoQ29uc3RydWN0b3IsIE5BTUUgKyAnIEl0ZXJhdG9yJyk7XG59O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2l0ZXItY3JlYXRlLmpzXG4vLyBtb2R1bGUgaWQgPSA4NFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///84\n");

/***/ }),
/* 85 */
/***/ (function(module, exports, __webpack_require__) {

eval("// 19.1.2.9 / 15.2.3.2 Object.getPrototypeOf(O)\nvar has = __webpack_require__(1);\nvar toObject = __webpack_require__(42);\nvar IE_PROTO = __webpack_require__(23)('IE_PROTO');\nvar ObjectProto = Object.prototype;\n\nmodule.exports = Object.getPrototypeOf || function (O) {\n  O = toObject(O);\n  if (has(O, IE_PROTO)) return O[IE_PROTO];\n  if (typeof O.constructor == 'function' && O instanceof O.constructor) {\n    return O.constructor.prototype;\n  } return O instanceof Object ? ObjectProto : null;\n};\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX29iamVjdC1ncG8uanM/M2YzYyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUNBLFVBQVUsbUJBQU8sQ0FBQyxDQUFRO0FBQzFCLGVBQWUsbUJBQU8sQ0FBQyxFQUFjO0FBQ3JDLGVBQWUsbUJBQU8sQ0FBQyxFQUFlO0FBQ3RDOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0giLCJmaWxlIjoiODUuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvLyAxOS4xLjIuOSAvIDE1LjIuMy4yIE9iamVjdC5nZXRQcm90b3R5cGVPZihPKVxudmFyIGhhcyA9IHJlcXVpcmUoJy4vX2hhcycpO1xudmFyIHRvT2JqZWN0ID0gcmVxdWlyZSgnLi9fdG8tb2JqZWN0Jyk7XG52YXIgSUVfUFJPVE8gPSByZXF1aXJlKCcuL19zaGFyZWQta2V5JykoJ0lFX1BST1RPJyk7XG52YXIgT2JqZWN0UHJvdG8gPSBPYmplY3QucHJvdG90eXBlO1xuXG5tb2R1bGUuZXhwb3J0cyA9IE9iamVjdC5nZXRQcm90b3R5cGVPZiB8fCBmdW5jdGlvbiAoTykge1xuICBPID0gdG9PYmplY3QoTyk7XG4gIGlmIChoYXMoTywgSUVfUFJPVE8pKSByZXR1cm4gT1tJRV9QUk9UT107XG4gIGlmICh0eXBlb2YgTy5jb25zdHJ1Y3RvciA9PSAnZnVuY3Rpb24nICYmIE8gaW5zdGFuY2VvZiBPLmNvbnN0cnVjdG9yKSB7XG4gICAgcmV0dXJuIE8uY29uc3RydWN0b3IucHJvdG90eXBlO1xuICB9IHJldHVybiBPIGluc3RhbmNlb2YgT2JqZWN0ID8gT2JqZWN0UHJvdG8gOiBudWxsO1xufTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19vYmplY3QtZ3BvLmpzXG4vLyBtb2R1bGUgaWQgPSA4NVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///85\n");

/***/ }),
/* 86 */
/***/ (function(module, exports, __webpack_require__) {

eval("__webpack_require__(87);\nvar global = __webpack_require__(0);\nvar hide = __webpack_require__(3);\nvar Iterators = __webpack_require__(26);\nvar TO_STRING_TAG = __webpack_require__(7)('toStringTag');\n\nvar DOMIterables = ('CSSRuleList,CSSStyleDeclaration,CSSValueList,ClientRectList,DOMRectList,DOMStringList,' +\n  'DOMTokenList,DataTransferItemList,FileList,HTMLAllCollection,HTMLCollection,HTMLFormElement,HTMLSelectElement,' +\n  'MediaList,MimeTypeArray,NamedNodeMap,NodeList,PaintRequestList,Plugin,PluginArray,SVGLengthList,SVGNumberList,' +\n  'SVGPathSegList,SVGPointList,SVGStringList,SVGTransformList,SourceBufferList,StyleSheetList,TextTrackCueList,' +\n  'TextTrackList,TouchList').split(',');\n\nfor (var i = 0; i < DOMIterables.length; i++) {\n  var NAME = DOMIterables[i];\n  var Collection = global[NAME];\n  var proto = Collection && Collection.prototype;\n  if (proto && !proto[TO_STRING_TAG]) hide(proto, TO_STRING_TAG, NAME);\n  Iterators[NAME] = Iterators.Array;\n}\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvd2ViLmRvbS5pdGVyYWJsZS5qcz9mYWQzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBLG1CQUFPLENBQUMsRUFBc0I7QUFDOUIsYUFBYSxtQkFBTyxDQUFDLENBQVc7QUFDaEMsV0FBVyxtQkFBTyxDQUFDLENBQVM7QUFDNUIsZ0JBQWdCLG1CQUFPLENBQUMsRUFBYztBQUN0QyxvQkFBb0IsbUJBQU8sQ0FBQyxDQUFROztBQUVwQztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGVBQWUseUJBQXlCO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsImZpbGUiOiI4Ni5qcyIsInNvdXJjZXNDb250ZW50IjpbInJlcXVpcmUoJy4vZXM2LmFycmF5Lml0ZXJhdG9yJyk7XG52YXIgZ2xvYmFsID0gcmVxdWlyZSgnLi9fZ2xvYmFsJyk7XG52YXIgaGlkZSA9IHJlcXVpcmUoJy4vX2hpZGUnKTtcbnZhciBJdGVyYXRvcnMgPSByZXF1aXJlKCcuL19pdGVyYXRvcnMnKTtcbnZhciBUT19TVFJJTkdfVEFHID0gcmVxdWlyZSgnLi9fd2tzJykoJ3RvU3RyaW5nVGFnJyk7XG5cbnZhciBET01JdGVyYWJsZXMgPSAoJ0NTU1J1bGVMaXN0LENTU1N0eWxlRGVjbGFyYXRpb24sQ1NTVmFsdWVMaXN0LENsaWVudFJlY3RMaXN0LERPTVJlY3RMaXN0LERPTVN0cmluZ0xpc3QsJyArXG4gICdET01Ub2tlbkxpc3QsRGF0YVRyYW5zZmVySXRlbUxpc3QsRmlsZUxpc3QsSFRNTEFsbENvbGxlY3Rpb24sSFRNTENvbGxlY3Rpb24sSFRNTEZvcm1FbGVtZW50LEhUTUxTZWxlY3RFbGVtZW50LCcgK1xuICAnTWVkaWFMaXN0LE1pbWVUeXBlQXJyYXksTmFtZWROb2RlTWFwLE5vZGVMaXN0LFBhaW50UmVxdWVzdExpc3QsUGx1Z2luLFBsdWdpbkFycmF5LFNWR0xlbmd0aExpc3QsU1ZHTnVtYmVyTGlzdCwnICtcbiAgJ1NWR1BhdGhTZWdMaXN0LFNWR1BvaW50TGlzdCxTVkdTdHJpbmdMaXN0LFNWR1RyYW5zZm9ybUxpc3QsU291cmNlQnVmZmVyTGlzdCxTdHlsZVNoZWV0TGlzdCxUZXh0VHJhY2tDdWVMaXN0LCcgK1xuICAnVGV4dFRyYWNrTGlzdCxUb3VjaExpc3QnKS5zcGxpdCgnLCcpO1xuXG5mb3IgKHZhciBpID0gMDsgaSA8IERPTUl0ZXJhYmxlcy5sZW5ndGg7IGkrKykge1xuICB2YXIgTkFNRSA9IERPTUl0ZXJhYmxlc1tpXTtcbiAgdmFyIENvbGxlY3Rpb24gPSBnbG9iYWxbTkFNRV07XG4gIHZhciBwcm90byA9IENvbGxlY3Rpb24gJiYgQ29sbGVjdGlvbi5wcm90b3R5cGU7XG4gIGlmIChwcm90byAmJiAhcHJvdG9bVE9fU1RSSU5HX1RBR10pIGhpZGUocHJvdG8sIFRPX1NUUklOR19UQUcsIE5BTUUpO1xuICBJdGVyYXRvcnNbTkFNRV0gPSBJdGVyYXRvcnMuQXJyYXk7XG59XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy93ZWIuZG9tLml0ZXJhYmxlLmpzXG4vLyBtb2R1bGUgaWQgPSA4NlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///86\n");

/***/ }),
/* 87 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar addToUnscopables = __webpack_require__(88);\nvar step = __webpack_require__(89);\nvar Iterators = __webpack_require__(26);\nvar toIObject = __webpack_require__(6);\n\n// 22.1.3.4 Array.prototype.entries()\n// 22.1.3.13 Array.prototype.keys()\n// 22.1.3.29 Array.prototype.values()\n// 22.1.3.30 Array.prototype[@@iterator]()\nmodule.exports = __webpack_require__(40)(Array, 'Array', function (iterated, kind) {\n  this._t = toIObject(iterated); // target\n  this._i = 0;                   // next index\n  this._k = kind;                // kind\n// 22.1.5.2.1 %ArrayIteratorPrototype%.next()\n}, function () {\n  var O = this._t;\n  var kind = this._k;\n  var index = this._i++;\n  if (!O || index >= O.length) {\n    this._t = undefined;\n    return step(1);\n  }\n  if (kind == 'keys') return step(0, index);\n  if (kind == 'values') return step(0, O[index]);\n  return step(0, [index, O[index]]);\n}, 'values');\n\n// argumentsList[@@iterator] is %ArrayProto_values% (9.4.4.6, 9.4.4.7)\nIterators.Arguments = Iterators.Array;\n\naddToUnscopables('keys');\naddToUnscopables('values');\naddToUnscopables('entries');\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvZXM2LmFycmF5Lml0ZXJhdG9yLmpzP2M0NjkiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQWE7QUFDYix1QkFBdUIsbUJBQU8sQ0FBQyxFQUF1QjtBQUN0RCxXQUFXLG1CQUFPLENBQUMsRUFBYztBQUNqQyxnQkFBZ0IsbUJBQU8sQ0FBQyxFQUFjO0FBQ3RDLGdCQUFnQixtQkFBTyxDQUFDLENBQWU7O0FBRXZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLG1CQUFPLENBQUMsRUFBZ0I7QUFDekMsZ0NBQWdDO0FBQ2hDLGNBQWM7QUFDZCxpQkFBaUI7QUFDakI7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBIiwiZmlsZSI6Ijg3LmpzIiwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xudmFyIGFkZFRvVW5zY29wYWJsZXMgPSByZXF1aXJlKCcuL19hZGQtdG8tdW5zY29wYWJsZXMnKTtcbnZhciBzdGVwID0gcmVxdWlyZSgnLi9faXRlci1zdGVwJyk7XG52YXIgSXRlcmF0b3JzID0gcmVxdWlyZSgnLi9faXRlcmF0b3JzJyk7XG52YXIgdG9JT2JqZWN0ID0gcmVxdWlyZSgnLi9fdG8taW9iamVjdCcpO1xuXG4vLyAyMi4xLjMuNCBBcnJheS5wcm90b3R5cGUuZW50cmllcygpXG4vLyAyMi4xLjMuMTMgQXJyYXkucHJvdG90eXBlLmtleXMoKVxuLy8gMjIuMS4zLjI5IEFycmF5LnByb3RvdHlwZS52YWx1ZXMoKVxuLy8gMjIuMS4zLjMwIEFycmF5LnByb3RvdHlwZVtAQGl0ZXJhdG9yXSgpXG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vX2l0ZXItZGVmaW5lJykoQXJyYXksICdBcnJheScsIGZ1bmN0aW9uIChpdGVyYXRlZCwga2luZCkge1xuICB0aGlzLl90ID0gdG9JT2JqZWN0KGl0ZXJhdGVkKTsgLy8gdGFyZ2V0XG4gIHRoaXMuX2kgPSAwOyAgICAgICAgICAgICAgICAgICAvLyBuZXh0IGluZGV4XG4gIHRoaXMuX2sgPSBraW5kOyAgICAgICAgICAgICAgICAvLyBraW5kXG4vLyAyMi4xLjUuMi4xICVBcnJheUl0ZXJhdG9yUHJvdG90eXBlJS5uZXh0KClcbn0sIGZ1bmN0aW9uICgpIHtcbiAgdmFyIE8gPSB0aGlzLl90O1xuICB2YXIga2luZCA9IHRoaXMuX2s7XG4gIHZhciBpbmRleCA9IHRoaXMuX2krKztcbiAgaWYgKCFPIHx8IGluZGV4ID49IE8ubGVuZ3RoKSB7XG4gICAgdGhpcy5fdCA9IHVuZGVmaW5lZDtcbiAgICByZXR1cm4gc3RlcCgxKTtcbiAgfVxuICBpZiAoa2luZCA9PSAna2V5cycpIHJldHVybiBzdGVwKDAsIGluZGV4KTtcbiAgaWYgKGtpbmQgPT0gJ3ZhbHVlcycpIHJldHVybiBzdGVwKDAsIE9baW5kZXhdKTtcbiAgcmV0dXJuIHN0ZXAoMCwgW2luZGV4LCBPW2luZGV4XV0pO1xufSwgJ3ZhbHVlcycpO1xuXG4vLyBhcmd1bWVudHNMaXN0W0BAaXRlcmF0b3JdIGlzICVBcnJheVByb3RvX3ZhbHVlcyUgKDkuNC40LjYsIDkuNC40LjcpXG5JdGVyYXRvcnMuQXJndW1lbnRzID0gSXRlcmF0b3JzLkFycmF5O1xuXG5hZGRUb1Vuc2NvcGFibGVzKCdrZXlzJyk7XG5hZGRUb1Vuc2NvcGFibGVzKCd2YWx1ZXMnKTtcbmFkZFRvVW5zY29wYWJsZXMoJ2VudHJpZXMnKTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL2VzNi5hcnJheS5pdGVyYXRvci5qc1xuLy8gbW9kdWxlIGlkID0gODdcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///87\n");

/***/ }),
/* 88 */
/***/ (function(module, exports) {

eval("module.exports = function () { /* empty */ };\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2FkZC10by11bnNjb3BhYmxlcy5qcz9lMjY3Il0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBLDhCQUE4QiIsImZpbGUiOiI4OC5qcyIsInNvdXJjZXNDb250ZW50IjpbIm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKCkgeyAvKiBlbXB0eSAqLyB9O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2FkZC10by11bnNjb3BhYmxlcy5qc1xuLy8gbW9kdWxlIGlkID0gODhcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///88\n");

/***/ }),
/* 89 */
/***/ (function(module, exports) {

eval("module.exports = function (done, value) {\n  return { value: value, done: !!done };\n};\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2l0ZXItc3RlcC5qcz8xMDY2Il0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0EsVUFBVTtBQUNWIiwiZmlsZSI6Ijg5LmpzIiwic291cmNlc0NvbnRlbnQiOlsibW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoZG9uZSwgdmFsdWUpIHtcbiAgcmV0dXJuIHsgdmFsdWU6IHZhbHVlLCBkb25lOiAhIWRvbmUgfTtcbn07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9faXRlci1zdGVwLmpzXG4vLyBtb2R1bGUgaWQgPSA4OVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///89\n");

/***/ }),
/* 90 */
/***/ (function(module, exports, __webpack_require__) {

eval("module.exports = { \"default\": __webpack_require__(91), __esModule: true };\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvYmFiZWwtcnVudGltZS9jb3JlLWpzL3N5bWJvbC5qcz9lNTA1Il0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBLGtCQUFrQixZQUFZLG1CQUFPLENBQUMsRUFBMkIiLCJmaWxlIjoiOTAuanMiLCJzb3VyY2VzQ29udGVudCI6WyJtb2R1bGUuZXhwb3J0cyA9IHsgXCJkZWZhdWx0XCI6IHJlcXVpcmUoXCJjb3JlLWpzL2xpYnJhcnkvZm4vc3ltYm9sXCIpLCBfX2VzTW9kdWxlOiB0cnVlIH07XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvYmFiZWwtcnVudGltZS9jb3JlLWpzL3N5bWJvbC5qc1xuLy8gbW9kdWxlIGlkID0gOTBcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///90\n");

/***/ }),
/* 91 */
/***/ (function(module, exports, __webpack_require__) {

eval("__webpack_require__(92);\n__webpack_require__(98);\n__webpack_require__(99);\n__webpack_require__(100);\nmodule.exports = __webpack_require__(2).Symbol;\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L2ZuL3N5bWJvbC9pbmRleC5qcz8wNzA3Il0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBLG1CQUFPLENBQUMsRUFBMEI7QUFDbEMsbUJBQU8sQ0FBQyxFQUFvQztBQUM1QyxtQkFBTyxDQUFDLEVBQXlDO0FBQ2pELG1CQUFPLENBQUMsR0FBcUM7QUFDN0MsaUJBQWlCLG1CQUFPLENBQUMsQ0FBcUIiLCJmaWxlIjoiOTEuanMiLCJzb3VyY2VzQ29udGVudCI6WyJyZXF1aXJlKCcuLi8uLi9tb2R1bGVzL2VzNi5zeW1ib2wnKTtcbnJlcXVpcmUoJy4uLy4uL21vZHVsZXMvZXM2Lm9iamVjdC50by1zdHJpbmcnKTtcbnJlcXVpcmUoJy4uLy4uL21vZHVsZXMvZXM3LnN5bWJvbC5hc3luYy1pdGVyYXRvcicpO1xucmVxdWlyZSgnLi4vLi4vbW9kdWxlcy9lczcuc3ltYm9sLm9ic2VydmFibGUnKTtcbm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi4vLi4vbW9kdWxlcy9fY29yZScpLlN5bWJvbDtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9mbi9zeW1ib2wvaW5kZXguanNcbi8vIG1vZHVsZSBpZCA9IDkxXG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///91\n");

/***/ }),
/* 92 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n// ECMAScript 6 symbols shim\nvar global = __webpack_require__(0);\nvar has = __webpack_require__(1);\nvar DESCRIPTORS = __webpack_require__(5);\nvar $export = __webpack_require__(17);\nvar redefine = __webpack_require__(41);\nvar META = __webpack_require__(93).KEY;\nvar $fails = __webpack_require__(13);\nvar shared = __webpack_require__(24);\nvar setToStringTag = __webpack_require__(27);\nvar uid = __webpack_require__(16);\nvar wks = __webpack_require__(7);\nvar wksExt = __webpack_require__(28);\nvar wksDefine = __webpack_require__(29);\nvar enumKeys = __webpack_require__(94);\nvar isArray = __webpack_require__(95);\nvar anObject = __webpack_require__(12);\nvar isObject = __webpack_require__(8);\nvar toObject = __webpack_require__(42);\nvar toIObject = __webpack_require__(6);\nvar toPrimitive = __webpack_require__(18);\nvar createDesc = __webpack_require__(14);\nvar _create = __webpack_require__(19);\nvar gOPNExt = __webpack_require__(96);\nvar $GOPD = __webpack_require__(97);\nvar $GOPS = __webpack_require__(43);\nvar $DP = __webpack_require__(4);\nvar $keys = __webpack_require__(20);\nvar gOPD = $GOPD.f;\nvar dP = $DP.f;\nvar gOPN = gOPNExt.f;\nvar $Symbol = global.Symbol;\nvar $JSON = global.JSON;\nvar _stringify = $JSON && $JSON.stringify;\nvar PROTOTYPE = 'prototype';\nvar HIDDEN = wks('_hidden');\nvar TO_PRIMITIVE = wks('toPrimitive');\nvar isEnum = {}.propertyIsEnumerable;\nvar SymbolRegistry = shared('symbol-registry');\nvar AllSymbols = shared('symbols');\nvar OPSymbols = shared('op-symbols');\nvar ObjectProto = Object[PROTOTYPE];\nvar USE_NATIVE = typeof $Symbol == 'function' && !!$GOPS.f;\nvar QObject = global.QObject;\n// Don't use setters in Qt Script, https://github.com/zloirock/core-js/issues/173\nvar setter = !QObject || !QObject[PROTOTYPE] || !QObject[PROTOTYPE].findChild;\n\n// fallback for old Android, https://code.google.com/p/v8/issues/detail?id=687\nvar setSymbolDesc = DESCRIPTORS && $fails(function () {\n  return _create(dP({}, 'a', {\n    get: function () { return dP(this, 'a', { value: 7 }).a; }\n  })).a != 7;\n}) ? function (it, key, D) {\n  var protoDesc = gOPD(ObjectProto, key);\n  if (protoDesc) delete ObjectProto[key];\n  dP(it, key, D);\n  if (protoDesc && it !== ObjectProto) dP(ObjectProto, key, protoDesc);\n} : dP;\n\nvar wrap = function (tag) {\n  var sym = AllSymbols[tag] = _create($Symbol[PROTOTYPE]);\n  sym._k = tag;\n  return sym;\n};\n\nvar isSymbol = USE_NATIVE && typeof $Symbol.iterator == 'symbol' ? function (it) {\n  return typeof it == 'symbol';\n} : function (it) {\n  return it instanceof $Symbol;\n};\n\nvar $defineProperty = function defineProperty(it, key, D) {\n  if (it === ObjectProto) $defineProperty(OPSymbols, key, D);\n  anObject(it);\n  key = toPrimitive(key, true);\n  anObject(D);\n  if (has(AllSymbols, key)) {\n    if (!D.enumerable) {\n      if (!has(it, HIDDEN)) dP(it, HIDDEN, createDesc(1, {}));\n      it[HIDDEN][key] = true;\n    } else {\n      if (has(it, HIDDEN) && it[HIDDEN][key]) it[HIDDEN][key] = false;\n      D = _create(D, { enumerable: createDesc(0, false) });\n    } return setSymbolDesc(it, key, D);\n  } return dP(it, key, D);\n};\nvar $defineProperties = function defineProperties(it, P) {\n  anObject(it);\n  var keys = enumKeys(P = toIObject(P));\n  var i = 0;\n  var l = keys.length;\n  var key;\n  while (l > i) $defineProperty(it, key = keys[i++], P[key]);\n  return it;\n};\nvar $create = function create(it, P) {\n  return P === undefined ? _create(it) : $defineProperties(_create(it), P);\n};\nvar $propertyIsEnumerable = function propertyIsEnumerable(key) {\n  var E = isEnum.call(this, key = toPrimitive(key, true));\n  if (this === ObjectProto && has(AllSymbols, key) && !has(OPSymbols, key)) return false;\n  return E || !has(this, key) || !has(AllSymbols, key) || has(this, HIDDEN) && this[HIDDEN][key] ? E : true;\n};\nvar $getOwnPropertyDescriptor = function getOwnPropertyDescriptor(it, key) {\n  it = toIObject(it);\n  key = toPrimitive(key, true);\n  if (it === ObjectProto && has(AllSymbols, key) && !has(OPSymbols, key)) return;\n  var D = gOPD(it, key);\n  if (D && has(AllSymbols, key) && !(has(it, HIDDEN) && it[HIDDEN][key])) D.enumerable = true;\n  return D;\n};\nvar $getOwnPropertyNames = function getOwnPropertyNames(it) {\n  var names = gOPN(toIObject(it));\n  var result = [];\n  var i = 0;\n  var key;\n  while (names.length > i) {\n    if (!has(AllSymbols, key = names[i++]) && key != HIDDEN && key != META) result.push(key);\n  } return result;\n};\nvar $getOwnPropertySymbols = function getOwnPropertySymbols(it) {\n  var IS_OP = it === ObjectProto;\n  var names = gOPN(IS_OP ? OPSymbols : toIObject(it));\n  var result = [];\n  var i = 0;\n  var key;\n  while (names.length > i) {\n    if (has(AllSymbols, key = names[i++]) && (IS_OP ? has(ObjectProto, key) : true)) result.push(AllSymbols[key]);\n  } return result;\n};\n\n// 19.4.1.1 Symbol([description])\nif (!USE_NATIVE) {\n  $Symbol = function Symbol() {\n    if (this instanceof $Symbol) throw TypeError('Symbol is not a constructor!');\n    var tag = uid(arguments.length > 0 ? arguments[0] : undefined);\n    var $set = function (value) {\n      if (this === ObjectProto) $set.call(OPSymbols, value);\n      if (has(this, HIDDEN) && has(this[HIDDEN], tag)) this[HIDDEN][tag] = false;\n      setSymbolDesc(this, tag, createDesc(1, value));\n    };\n    if (DESCRIPTORS && setter) setSymbolDesc(ObjectProto, tag, { configurable: true, set: $set });\n    return wrap(tag);\n  };\n  redefine($Symbol[PROTOTYPE], 'toString', function toString() {\n    return this._k;\n  });\n\n  $GOPD.f = $getOwnPropertyDescriptor;\n  $DP.f = $defineProperty;\n  __webpack_require__(44).f = gOPNExt.f = $getOwnPropertyNames;\n  __webpack_require__(30).f = $propertyIsEnumerable;\n  $GOPS.f = $getOwnPropertySymbols;\n\n  if (DESCRIPTORS && !__webpack_require__(15)) {\n    redefine(ObjectProto, 'propertyIsEnumerable', $propertyIsEnumerable, true);\n  }\n\n  wksExt.f = function (name) {\n    return wrap(wks(name));\n  };\n}\n\n$export($export.G + $export.W + $export.F * !USE_NATIVE, { Symbol: $Symbol });\n\nfor (var es6Symbols = (\n  // 19.4.2.2, 19.4.2.3, 19.4.2.4, 19.4.2.6, 19.4.2.8, 19.4.2.9, 19.4.2.10, 19.4.2.11, 19.4.2.12, 19.4.2.13, 19.4.2.14\n  'hasInstance,isConcatSpreadable,iterator,match,replace,search,species,split,toPrimitive,toStringTag,unscopables'\n).split(','), j = 0; es6Symbols.length > j;)wks(es6Symbols[j++]);\n\nfor (var wellKnownSymbols = $keys(wks.store), k = 0; wellKnownSymbols.length > k;) wksDefine(wellKnownSymbols[k++]);\n\n$export($export.S + $export.F * !USE_NATIVE, 'Symbol', {\n  // 19.4.2.1 Symbol.for(key)\n  'for': function (key) {\n    return has(SymbolRegistry, key += '')\n      ? SymbolRegistry[key]\n      : SymbolRegistry[key] = $Symbol(key);\n  },\n  // 19.4.2.5 Symbol.keyFor(sym)\n  keyFor: function keyFor(sym) {\n    if (!isSymbol(sym)) throw TypeError(sym + ' is not a symbol!');\n    for (var key in SymbolRegistry) if (SymbolRegistry[key] === sym) return key;\n  },\n  useSetter: function () { setter = true; },\n  useSimple: function () { setter = false; }\n});\n\n$export($export.S + $export.F * !USE_NATIVE, 'Object', {\n  // 19.1.2.2 Object.create(O [, Properties])\n  create: $create,\n  // 19.1.2.4 Object.defineProperty(O, P, Attributes)\n  defineProperty: $defineProperty,\n  // 19.1.2.3 Object.defineProperties(O, Properties)\n  defineProperties: $defineProperties,\n  // 19.1.2.6 Object.getOwnPropertyDescriptor(O, P)\n  getOwnPropertyDescriptor: $getOwnPropertyDescriptor,\n  // 19.1.2.7 Object.getOwnPropertyNames(O)\n  getOwnPropertyNames: $getOwnPropertyNames,\n  // 19.1.2.8 Object.getOwnPropertySymbols(O)\n  getOwnPropertySymbols: $getOwnPropertySymbols\n});\n\n// Chrome 38 and 39 `Object.getOwnPropertySymbols` fails on primitives\n// https://bugs.chromium.org/p/v8/issues/detail?id=3443\nvar FAILS_ON_PRIMITIVES = $fails(function () { $GOPS.f(1); });\n\n$export($export.S + $export.F * FAILS_ON_PRIMITIVES, 'Object', {\n  getOwnPropertySymbols: function getOwnPropertySymbols(it) {\n    return $GOPS.f(toObject(it));\n  }\n});\n\n// 24.3.2 JSON.stringify(value [, replacer [, space]])\n$JSON && $export($export.S + $export.F * (!USE_NATIVE || $fails(function () {\n  var S = $Symbol();\n  // MS Edge converts symbol values to JSON as {}\n  // WebKit converts symbol values to JSON as null\n  // V8 throws on boxed symbols\n  return _stringify([S]) != '[null]' || _stringify({ a: S }) != '{}' || _stringify(Object(S)) != '{}';\n})), 'JSON', {\n  stringify: function stringify(it) {\n    var args = [it];\n    var i = 1;\n    var replacer, $replacer;\n    while (arguments.length > i) args.push(arguments[i++]);\n    $replacer = replacer = args[1];\n    if (!isObject(replacer) && it === undefined || isSymbol(it)) return; // IE8 returns string on undefined\n    if (!isArray(replacer)) replacer = function (key, value) {\n      if (typeof $replacer == 'function') value = $replacer.call(this, key, value);\n      if (!isSymbol(value)) return value;\n    };\n    args[1] = replacer;\n    return _stringify.apply($JSON, args);\n  }\n});\n\n// 19.4.3.4 Symbol.prototype[@@toPrimitive](hint)\n$Symbol[PROTOTYPE][TO_PRIMITIVE] || __webpack_require__(3)($Symbol[PROTOTYPE], TO_PRIMITIVE, $Symbol[PROTOTYPE].valueOf);\n// 19.4.3.5 Symbol.prototype[@@toStringTag]\nsetToStringTag($Symbol, 'Symbol');\n// 20.2.1.9 Math[@@toStringTag]\nsetToStringTag(Math, 'Math', true);\n// 24.3.3 JSON[@@toStringTag]\nsetToStringTag(global.JSON, 'JSON', true);\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvZXM2LnN5bWJvbC5qcz83ZDY3Il0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQSxhQUFhLG1CQUFPLENBQUMsQ0FBVztBQUNoQyxVQUFVLG1CQUFPLENBQUMsQ0FBUTtBQUMxQixrQkFBa0IsbUJBQU8sQ0FBQyxDQUFnQjtBQUMxQyxjQUFjLG1CQUFPLENBQUMsRUFBVztBQUNqQyxlQUFlLG1CQUFPLENBQUMsRUFBYTtBQUNwQyxXQUFXLG1CQUFPLENBQUMsRUFBUztBQUM1QixhQUFhLG1CQUFPLENBQUMsRUFBVTtBQUMvQixhQUFhLG1CQUFPLENBQUMsRUFBVztBQUNoQyxxQkFBcUIsbUJBQU8sQ0FBQyxFQUFzQjtBQUNuRCxVQUFVLG1CQUFPLENBQUMsRUFBUTtBQUMxQixVQUFVLG1CQUFPLENBQUMsQ0FBUTtBQUMxQixhQUFhLG1CQUFPLENBQUMsRUFBWTtBQUNqQyxnQkFBZ0IsbUJBQU8sQ0FBQyxFQUFlO0FBQ3ZDLGVBQWUsbUJBQU8sQ0FBQyxFQUFjO0FBQ3JDLGNBQWMsbUJBQU8sQ0FBQyxFQUFhO0FBQ25DLGVBQWUsbUJBQU8sQ0FBQyxFQUFjO0FBQ3JDLGVBQWUsbUJBQU8sQ0FBQyxDQUFjO0FBQ3JDLGVBQWUsbUJBQU8sQ0FBQyxFQUFjO0FBQ3JDLGdCQUFnQixtQkFBTyxDQUFDLENBQWU7QUFDdkMsa0JBQWtCLG1CQUFPLENBQUMsRUFBaUI7QUFDM0MsaUJBQWlCLG1CQUFPLENBQUMsRUFBa0I7QUFDM0MsY0FBYyxtQkFBTyxDQUFDLEVBQWtCO0FBQ3hDLGNBQWMsbUJBQU8sQ0FBQyxFQUFvQjtBQUMxQyxZQUFZLG1CQUFPLENBQUMsRUFBZ0I7QUFDcEMsWUFBWSxtQkFBTyxDQUFDLEVBQWdCO0FBQ3BDLFVBQVUsbUJBQU8sQ0FBQyxDQUFjO0FBQ2hDLFlBQVksbUJBQU8sQ0FBQyxFQUFnQjtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCLHNCQUFzQix1QkFBdUIsV0FBVyxJQUFJO0FBQzVELEdBQUc7QUFDSCxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkRBQTJEO0FBQzNEO0FBQ0EsS0FBSztBQUNMO0FBQ0Esc0JBQXNCLG1DQUFtQztBQUN6RCxLQUFLO0FBQ0wsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnRUFBZ0UsZ0NBQWdDO0FBQ2hHO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0EsRUFBRSxtQkFBTyxDQUFDLEVBQWdCO0FBQzFCLEVBQUUsbUJBQU8sQ0FBQyxFQUFlO0FBQ3pCOztBQUVBLHNCQUFzQixtQkFBTyxDQUFDLEVBQVk7QUFDMUM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSwwREFBMEQsa0JBQWtCOztBQUU1RTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsdUJBQXVCOztBQUUzQyxvREFBb0QsNkJBQTZCOztBQUVqRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsMEJBQTBCLGVBQWUsRUFBRTtBQUMzQywwQkFBMEIsZ0JBQWdCO0FBQzFDLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQSw4Q0FBOEMsWUFBWSxFQUFFOztBQUU1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0RBQW9ELE9BQU8sUUFBUSxpQ0FBaUM7QUFDcEcsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdFQUF3RTtBQUN4RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQSxvQ0FBb0MsbUJBQU8sQ0FBQyxDQUFTO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsImZpbGUiOiI5Mi5qcyIsInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0Jztcbi8vIEVDTUFTY3JpcHQgNiBzeW1ib2xzIHNoaW1cbnZhciBnbG9iYWwgPSByZXF1aXJlKCcuL19nbG9iYWwnKTtcbnZhciBoYXMgPSByZXF1aXJlKCcuL19oYXMnKTtcbnZhciBERVNDUklQVE9SUyA9IHJlcXVpcmUoJy4vX2Rlc2NyaXB0b3JzJyk7XG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xudmFyIHJlZGVmaW5lID0gcmVxdWlyZSgnLi9fcmVkZWZpbmUnKTtcbnZhciBNRVRBID0gcmVxdWlyZSgnLi9fbWV0YScpLktFWTtcbnZhciAkZmFpbHMgPSByZXF1aXJlKCcuL19mYWlscycpO1xudmFyIHNoYXJlZCA9IHJlcXVpcmUoJy4vX3NoYXJlZCcpO1xudmFyIHNldFRvU3RyaW5nVGFnID0gcmVxdWlyZSgnLi9fc2V0LXRvLXN0cmluZy10YWcnKTtcbnZhciB1aWQgPSByZXF1aXJlKCcuL191aWQnKTtcbnZhciB3a3MgPSByZXF1aXJlKCcuL193a3MnKTtcbnZhciB3a3NFeHQgPSByZXF1aXJlKCcuL193a3MtZXh0Jyk7XG52YXIgd2tzRGVmaW5lID0gcmVxdWlyZSgnLi9fd2tzLWRlZmluZScpO1xudmFyIGVudW1LZXlzID0gcmVxdWlyZSgnLi9fZW51bS1rZXlzJyk7XG52YXIgaXNBcnJheSA9IHJlcXVpcmUoJy4vX2lzLWFycmF5Jyk7XG52YXIgYW5PYmplY3QgPSByZXF1aXJlKCcuL19hbi1vYmplY3QnKTtcbnZhciBpc09iamVjdCA9IHJlcXVpcmUoJy4vX2lzLW9iamVjdCcpO1xudmFyIHRvT2JqZWN0ID0gcmVxdWlyZSgnLi9fdG8tb2JqZWN0Jyk7XG52YXIgdG9JT2JqZWN0ID0gcmVxdWlyZSgnLi9fdG8taW9iamVjdCcpO1xudmFyIHRvUHJpbWl0aXZlID0gcmVxdWlyZSgnLi9fdG8tcHJpbWl0aXZlJyk7XG52YXIgY3JlYXRlRGVzYyA9IHJlcXVpcmUoJy4vX3Byb3BlcnR5LWRlc2MnKTtcbnZhciBfY3JlYXRlID0gcmVxdWlyZSgnLi9fb2JqZWN0LWNyZWF0ZScpO1xudmFyIGdPUE5FeHQgPSByZXF1aXJlKCcuL19vYmplY3QtZ29wbi1leHQnKTtcbnZhciAkR09QRCA9IHJlcXVpcmUoJy4vX29iamVjdC1nb3BkJyk7XG52YXIgJEdPUFMgPSByZXF1aXJlKCcuL19vYmplY3QtZ29wcycpO1xudmFyICREUCA9IHJlcXVpcmUoJy4vX29iamVjdC1kcCcpO1xudmFyICRrZXlzID0gcmVxdWlyZSgnLi9fb2JqZWN0LWtleXMnKTtcbnZhciBnT1BEID0gJEdPUEQuZjtcbnZhciBkUCA9ICREUC5mO1xudmFyIGdPUE4gPSBnT1BORXh0LmY7XG52YXIgJFN5bWJvbCA9IGdsb2JhbC5TeW1ib2w7XG52YXIgJEpTT04gPSBnbG9iYWwuSlNPTjtcbnZhciBfc3RyaW5naWZ5ID0gJEpTT04gJiYgJEpTT04uc3RyaW5naWZ5O1xudmFyIFBST1RPVFlQRSA9ICdwcm90b3R5cGUnO1xudmFyIEhJRERFTiA9IHdrcygnX2hpZGRlbicpO1xudmFyIFRPX1BSSU1JVElWRSA9IHdrcygndG9QcmltaXRpdmUnKTtcbnZhciBpc0VudW0gPSB7fS5wcm9wZXJ0eUlzRW51bWVyYWJsZTtcbnZhciBTeW1ib2xSZWdpc3RyeSA9IHNoYXJlZCgnc3ltYm9sLXJlZ2lzdHJ5Jyk7XG52YXIgQWxsU3ltYm9scyA9IHNoYXJlZCgnc3ltYm9scycpO1xudmFyIE9QU3ltYm9scyA9IHNoYXJlZCgnb3Atc3ltYm9scycpO1xudmFyIE9iamVjdFByb3RvID0gT2JqZWN0W1BST1RPVFlQRV07XG52YXIgVVNFX05BVElWRSA9IHR5cGVvZiAkU3ltYm9sID09ICdmdW5jdGlvbicgJiYgISEkR09QUy5mO1xudmFyIFFPYmplY3QgPSBnbG9iYWwuUU9iamVjdDtcbi8vIERvbid0IHVzZSBzZXR0ZXJzIGluIFF0IFNjcmlwdCwgaHR0cHM6Ly9naXRodWIuY29tL3psb2lyb2NrL2NvcmUtanMvaXNzdWVzLzE3M1xudmFyIHNldHRlciA9ICFRT2JqZWN0IHx8ICFRT2JqZWN0W1BST1RPVFlQRV0gfHwgIVFPYmplY3RbUFJPVE9UWVBFXS5maW5kQ2hpbGQ7XG5cbi8vIGZhbGxiYWNrIGZvciBvbGQgQW5kcm9pZCwgaHR0cHM6Ly9jb2RlLmdvb2dsZS5jb20vcC92OC9pc3N1ZXMvZGV0YWlsP2lkPTY4N1xudmFyIHNldFN5bWJvbERlc2MgPSBERVNDUklQVE9SUyAmJiAkZmFpbHMoZnVuY3Rpb24gKCkge1xuICByZXR1cm4gX2NyZWF0ZShkUCh7fSwgJ2EnLCB7XG4gICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBkUCh0aGlzLCAnYScsIHsgdmFsdWU6IDcgfSkuYTsgfVxuICB9KSkuYSAhPSA3O1xufSkgPyBmdW5jdGlvbiAoaXQsIGtleSwgRCkge1xuICB2YXIgcHJvdG9EZXNjID0gZ09QRChPYmplY3RQcm90bywga2V5KTtcbiAgaWYgKHByb3RvRGVzYykgZGVsZXRlIE9iamVjdFByb3RvW2tleV07XG4gIGRQKGl0LCBrZXksIEQpO1xuICBpZiAocHJvdG9EZXNjICYmIGl0ICE9PSBPYmplY3RQcm90bykgZFAoT2JqZWN0UHJvdG8sIGtleSwgcHJvdG9EZXNjKTtcbn0gOiBkUDtcblxudmFyIHdyYXAgPSBmdW5jdGlvbiAodGFnKSB7XG4gIHZhciBzeW0gPSBBbGxTeW1ib2xzW3RhZ10gPSBfY3JlYXRlKCRTeW1ib2xbUFJPVE9UWVBFXSk7XG4gIHN5bS5fayA9IHRhZztcbiAgcmV0dXJuIHN5bTtcbn07XG5cbnZhciBpc1N5bWJvbCA9IFVTRV9OQVRJVkUgJiYgdHlwZW9mICRTeW1ib2wuaXRlcmF0b3IgPT0gJ3N5bWJvbCcgPyBmdW5jdGlvbiAoaXQpIHtcbiAgcmV0dXJuIHR5cGVvZiBpdCA9PSAnc3ltYm9sJztcbn0gOiBmdW5jdGlvbiAoaXQpIHtcbiAgcmV0dXJuIGl0IGluc3RhbmNlb2YgJFN5bWJvbDtcbn07XG5cbnZhciAkZGVmaW5lUHJvcGVydHkgPSBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0eShpdCwga2V5LCBEKSB7XG4gIGlmIChpdCA9PT0gT2JqZWN0UHJvdG8pICRkZWZpbmVQcm9wZXJ0eShPUFN5bWJvbHMsIGtleSwgRCk7XG4gIGFuT2JqZWN0KGl0KTtcbiAga2V5ID0gdG9QcmltaXRpdmUoa2V5LCB0cnVlKTtcbiAgYW5PYmplY3QoRCk7XG4gIGlmIChoYXMoQWxsU3ltYm9scywga2V5KSkge1xuICAgIGlmICghRC5lbnVtZXJhYmxlKSB7XG4gICAgICBpZiAoIWhhcyhpdCwgSElEREVOKSkgZFAoaXQsIEhJRERFTiwgY3JlYXRlRGVzYygxLCB7fSkpO1xuICAgICAgaXRbSElEREVOXVtrZXldID0gdHJ1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKGhhcyhpdCwgSElEREVOKSAmJiBpdFtISURERU5dW2tleV0pIGl0W0hJRERFTl1ba2V5XSA9IGZhbHNlO1xuICAgICAgRCA9IF9jcmVhdGUoRCwgeyBlbnVtZXJhYmxlOiBjcmVhdGVEZXNjKDAsIGZhbHNlKSB9KTtcbiAgICB9IHJldHVybiBzZXRTeW1ib2xEZXNjKGl0LCBrZXksIEQpO1xuICB9IHJldHVybiBkUChpdCwga2V5LCBEKTtcbn07XG52YXIgJGRlZmluZVByb3BlcnRpZXMgPSBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0aWVzKGl0LCBQKSB7XG4gIGFuT2JqZWN0KGl0KTtcbiAgdmFyIGtleXMgPSBlbnVtS2V5cyhQID0gdG9JT2JqZWN0KFApKTtcbiAgdmFyIGkgPSAwO1xuICB2YXIgbCA9IGtleXMubGVuZ3RoO1xuICB2YXIga2V5O1xuICB3aGlsZSAobCA+IGkpICRkZWZpbmVQcm9wZXJ0eShpdCwga2V5ID0ga2V5c1tpKytdLCBQW2tleV0pO1xuICByZXR1cm4gaXQ7XG59O1xudmFyICRjcmVhdGUgPSBmdW5jdGlvbiBjcmVhdGUoaXQsIFApIHtcbiAgcmV0dXJuIFAgPT09IHVuZGVmaW5lZCA/IF9jcmVhdGUoaXQpIDogJGRlZmluZVByb3BlcnRpZXMoX2NyZWF0ZShpdCksIFApO1xufTtcbnZhciAkcHJvcGVydHlJc0VudW1lcmFibGUgPSBmdW5jdGlvbiBwcm9wZXJ0eUlzRW51bWVyYWJsZShrZXkpIHtcbiAgdmFyIEUgPSBpc0VudW0uY2FsbCh0aGlzLCBrZXkgPSB0b1ByaW1pdGl2ZShrZXksIHRydWUpKTtcbiAgaWYgKHRoaXMgPT09IE9iamVjdFByb3RvICYmIGhhcyhBbGxTeW1ib2xzLCBrZXkpICYmICFoYXMoT1BTeW1ib2xzLCBrZXkpKSByZXR1cm4gZmFsc2U7XG4gIHJldHVybiBFIHx8ICFoYXModGhpcywga2V5KSB8fCAhaGFzKEFsbFN5bWJvbHMsIGtleSkgfHwgaGFzKHRoaXMsIEhJRERFTikgJiYgdGhpc1tISURERU5dW2tleV0gPyBFIDogdHJ1ZTtcbn07XG52YXIgJGdldE93blByb3BlcnR5RGVzY3JpcHRvciA9IGZ1bmN0aW9uIGdldE93blByb3BlcnR5RGVzY3JpcHRvcihpdCwga2V5KSB7XG4gIGl0ID0gdG9JT2JqZWN0KGl0KTtcbiAga2V5ID0gdG9QcmltaXRpdmUoa2V5LCB0cnVlKTtcbiAgaWYgKGl0ID09PSBPYmplY3RQcm90byAmJiBoYXMoQWxsU3ltYm9scywga2V5KSAmJiAhaGFzKE9QU3ltYm9scywga2V5KSkgcmV0dXJuO1xuICB2YXIgRCA9IGdPUEQoaXQsIGtleSk7XG4gIGlmIChEICYmIGhhcyhBbGxTeW1ib2xzLCBrZXkpICYmICEoaGFzKGl0LCBISURERU4pICYmIGl0W0hJRERFTl1ba2V5XSkpIEQuZW51bWVyYWJsZSA9IHRydWU7XG4gIHJldHVybiBEO1xufTtcbnZhciAkZ2V0T3duUHJvcGVydHlOYW1lcyA9IGZ1bmN0aW9uIGdldE93blByb3BlcnR5TmFtZXMoaXQpIHtcbiAgdmFyIG5hbWVzID0gZ09QTih0b0lPYmplY3QoaXQpKTtcbiAgdmFyIHJlc3VsdCA9IFtdO1xuICB2YXIgaSA9IDA7XG4gIHZhciBrZXk7XG4gIHdoaWxlIChuYW1lcy5sZW5ndGggPiBpKSB7XG4gICAgaWYgKCFoYXMoQWxsU3ltYm9scywga2V5ID0gbmFtZXNbaSsrXSkgJiYga2V5ICE9IEhJRERFTiAmJiBrZXkgIT0gTUVUQSkgcmVzdWx0LnB1c2goa2V5KTtcbiAgfSByZXR1cm4gcmVzdWx0O1xufTtcbnZhciAkZ2V0T3duUHJvcGVydHlTeW1ib2xzID0gZnVuY3Rpb24gZ2V0T3duUHJvcGVydHlTeW1ib2xzKGl0KSB7XG4gIHZhciBJU19PUCA9IGl0ID09PSBPYmplY3RQcm90bztcbiAgdmFyIG5hbWVzID0gZ09QTihJU19PUCA/IE9QU3ltYm9scyA6IHRvSU9iamVjdChpdCkpO1xuICB2YXIgcmVzdWx0ID0gW107XG4gIHZhciBpID0gMDtcbiAgdmFyIGtleTtcbiAgd2hpbGUgKG5hbWVzLmxlbmd0aCA+IGkpIHtcbiAgICBpZiAoaGFzKEFsbFN5bWJvbHMsIGtleSA9IG5hbWVzW2krK10pICYmIChJU19PUCA/IGhhcyhPYmplY3RQcm90bywga2V5KSA6IHRydWUpKSByZXN1bHQucHVzaChBbGxTeW1ib2xzW2tleV0pO1xuICB9IHJldHVybiByZXN1bHQ7XG59O1xuXG4vLyAxOS40LjEuMSBTeW1ib2woW2Rlc2NyaXB0aW9uXSlcbmlmICghVVNFX05BVElWRSkge1xuICAkU3ltYm9sID0gZnVuY3Rpb24gU3ltYm9sKCkge1xuICAgIGlmICh0aGlzIGluc3RhbmNlb2YgJFN5bWJvbCkgdGhyb3cgVHlwZUVycm9yKCdTeW1ib2wgaXMgbm90IGEgY29uc3RydWN0b3IhJyk7XG4gICAgdmFyIHRhZyA9IHVpZChhcmd1bWVudHMubGVuZ3RoID4gMCA/IGFyZ3VtZW50c1swXSA6IHVuZGVmaW5lZCk7XG4gICAgdmFyICRzZXQgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgIGlmICh0aGlzID09PSBPYmplY3RQcm90bykgJHNldC5jYWxsKE9QU3ltYm9scywgdmFsdWUpO1xuICAgICAgaWYgKGhhcyh0aGlzLCBISURERU4pICYmIGhhcyh0aGlzW0hJRERFTl0sIHRhZykpIHRoaXNbSElEREVOXVt0YWddID0gZmFsc2U7XG4gICAgICBzZXRTeW1ib2xEZXNjKHRoaXMsIHRhZywgY3JlYXRlRGVzYygxLCB2YWx1ZSkpO1xuICAgIH07XG4gICAgaWYgKERFU0NSSVBUT1JTICYmIHNldHRlcikgc2V0U3ltYm9sRGVzYyhPYmplY3RQcm90bywgdGFnLCB7IGNvbmZpZ3VyYWJsZTogdHJ1ZSwgc2V0OiAkc2V0IH0pO1xuICAgIHJldHVybiB3cmFwKHRhZyk7XG4gIH07XG4gIHJlZGVmaW5lKCRTeW1ib2xbUFJPVE9UWVBFXSwgJ3RvU3RyaW5nJywgZnVuY3Rpb24gdG9TdHJpbmcoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2s7XG4gIH0pO1xuXG4gICRHT1BELmYgPSAkZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yO1xuICAkRFAuZiA9ICRkZWZpbmVQcm9wZXJ0eTtcbiAgcmVxdWlyZSgnLi9fb2JqZWN0LWdvcG4nKS5mID0gZ09QTkV4dC5mID0gJGdldE93blByb3BlcnR5TmFtZXM7XG4gIHJlcXVpcmUoJy4vX29iamVjdC1waWUnKS5mID0gJHByb3BlcnR5SXNFbnVtZXJhYmxlO1xuICAkR09QUy5mID0gJGdldE93blByb3BlcnR5U3ltYm9scztcblxuICBpZiAoREVTQ1JJUFRPUlMgJiYgIXJlcXVpcmUoJy4vX2xpYnJhcnknKSkge1xuICAgIHJlZGVmaW5lKE9iamVjdFByb3RvLCAncHJvcGVydHlJc0VudW1lcmFibGUnLCAkcHJvcGVydHlJc0VudW1lcmFibGUsIHRydWUpO1xuICB9XG5cbiAgd2tzRXh0LmYgPSBmdW5jdGlvbiAobmFtZSkge1xuICAgIHJldHVybiB3cmFwKHdrcyhuYW1lKSk7XG4gIH07XG59XG5cbiRleHBvcnQoJGV4cG9ydC5HICsgJGV4cG9ydC5XICsgJGV4cG9ydC5GICogIVVTRV9OQVRJVkUsIHsgU3ltYm9sOiAkU3ltYm9sIH0pO1xuXG5mb3IgKHZhciBlczZTeW1ib2xzID0gKFxuICAvLyAxOS40LjIuMiwgMTkuNC4yLjMsIDE5LjQuMi40LCAxOS40LjIuNiwgMTkuNC4yLjgsIDE5LjQuMi45LCAxOS40LjIuMTAsIDE5LjQuMi4xMSwgMTkuNC4yLjEyLCAxOS40LjIuMTMsIDE5LjQuMi4xNFxuICAnaGFzSW5zdGFuY2UsaXNDb25jYXRTcHJlYWRhYmxlLGl0ZXJhdG9yLG1hdGNoLHJlcGxhY2Usc2VhcmNoLHNwZWNpZXMsc3BsaXQsdG9QcmltaXRpdmUsdG9TdHJpbmdUYWcsdW5zY29wYWJsZXMnXG4pLnNwbGl0KCcsJyksIGogPSAwOyBlczZTeW1ib2xzLmxlbmd0aCA+IGo7KXdrcyhlczZTeW1ib2xzW2orK10pO1xuXG5mb3IgKHZhciB3ZWxsS25vd25TeW1ib2xzID0gJGtleXMod2tzLnN0b3JlKSwgayA9IDA7IHdlbGxLbm93blN5bWJvbHMubGVuZ3RoID4gazspIHdrc0RlZmluZSh3ZWxsS25vd25TeW1ib2xzW2srK10pO1xuXG4kZXhwb3J0KCRleHBvcnQuUyArICRleHBvcnQuRiAqICFVU0VfTkFUSVZFLCAnU3ltYm9sJywge1xuICAvLyAxOS40LjIuMSBTeW1ib2wuZm9yKGtleSlcbiAgJ2Zvcic6IGZ1bmN0aW9uIChrZXkpIHtcbiAgICByZXR1cm4gaGFzKFN5bWJvbFJlZ2lzdHJ5LCBrZXkgKz0gJycpXG4gICAgICA/IFN5bWJvbFJlZ2lzdHJ5W2tleV1cbiAgICAgIDogU3ltYm9sUmVnaXN0cnlba2V5XSA9ICRTeW1ib2woa2V5KTtcbiAgfSxcbiAgLy8gMTkuNC4yLjUgU3ltYm9sLmtleUZvcihzeW0pXG4gIGtleUZvcjogZnVuY3Rpb24ga2V5Rm9yKHN5bSkge1xuICAgIGlmICghaXNTeW1ib2woc3ltKSkgdGhyb3cgVHlwZUVycm9yKHN5bSArICcgaXMgbm90IGEgc3ltYm9sIScpO1xuICAgIGZvciAodmFyIGtleSBpbiBTeW1ib2xSZWdpc3RyeSkgaWYgKFN5bWJvbFJlZ2lzdHJ5W2tleV0gPT09IHN5bSkgcmV0dXJuIGtleTtcbiAgfSxcbiAgdXNlU2V0dGVyOiBmdW5jdGlvbiAoKSB7IHNldHRlciA9IHRydWU7IH0sXG4gIHVzZVNpbXBsZTogZnVuY3Rpb24gKCkgeyBzZXR0ZXIgPSBmYWxzZTsgfVxufSk7XG5cbiRleHBvcnQoJGV4cG9ydC5TICsgJGV4cG9ydC5GICogIVVTRV9OQVRJVkUsICdPYmplY3QnLCB7XG4gIC8vIDE5LjEuMi4yIE9iamVjdC5jcmVhdGUoTyBbLCBQcm9wZXJ0aWVzXSlcbiAgY3JlYXRlOiAkY3JlYXRlLFxuICAvLyAxOS4xLjIuNCBPYmplY3QuZGVmaW5lUHJvcGVydHkoTywgUCwgQXR0cmlidXRlcylcbiAgZGVmaW5lUHJvcGVydHk6ICRkZWZpbmVQcm9wZXJ0eSxcbiAgLy8gMTkuMS4yLjMgT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoTywgUHJvcGVydGllcylcbiAgZGVmaW5lUHJvcGVydGllczogJGRlZmluZVByb3BlcnRpZXMsXG4gIC8vIDE5LjEuMi42IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoTywgUClcbiAgZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yOiAkZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yLFxuICAvLyAxOS4xLjIuNyBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhPKVxuICBnZXRPd25Qcm9wZXJ0eU5hbWVzOiAkZ2V0T3duUHJvcGVydHlOYW1lcyxcbiAgLy8gMTkuMS4yLjggT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhPKVxuICBnZXRPd25Qcm9wZXJ0eVN5bWJvbHM6ICRnZXRPd25Qcm9wZXJ0eVN5bWJvbHNcbn0pO1xuXG4vLyBDaHJvbWUgMzggYW5kIDM5IGBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzYCBmYWlscyBvbiBwcmltaXRpdmVzXG4vLyBodHRwczovL2J1Z3MuY2hyb21pdW0ub3JnL3AvdjgvaXNzdWVzL2RldGFpbD9pZD0zNDQzXG52YXIgRkFJTFNfT05fUFJJTUlUSVZFUyA9ICRmYWlscyhmdW5jdGlvbiAoKSB7ICRHT1BTLmYoMSk7IH0pO1xuXG4kZXhwb3J0KCRleHBvcnQuUyArICRleHBvcnQuRiAqIEZBSUxTX09OX1BSSU1JVElWRVMsICdPYmplY3QnLCB7XG4gIGdldE93blByb3BlcnR5U3ltYm9sczogZnVuY3Rpb24gZ2V0T3duUHJvcGVydHlTeW1ib2xzKGl0KSB7XG4gICAgcmV0dXJuICRHT1BTLmYodG9PYmplY3QoaXQpKTtcbiAgfVxufSk7XG5cbi8vIDI0LjMuMiBKU09OLnN0cmluZ2lmeSh2YWx1ZSBbLCByZXBsYWNlciBbLCBzcGFjZV1dKVxuJEpTT04gJiYgJGV4cG9ydCgkZXhwb3J0LlMgKyAkZXhwb3J0LkYgKiAoIVVTRV9OQVRJVkUgfHwgJGZhaWxzKGZ1bmN0aW9uICgpIHtcbiAgdmFyIFMgPSAkU3ltYm9sKCk7XG4gIC8vIE1TIEVkZ2UgY29udmVydHMgc3ltYm9sIHZhbHVlcyB0byBKU09OIGFzIHt9XG4gIC8vIFdlYktpdCBjb252ZXJ0cyBzeW1ib2wgdmFsdWVzIHRvIEpTT04gYXMgbnVsbFxuICAvLyBWOCB0aHJvd3Mgb24gYm94ZWQgc3ltYm9sc1xuICByZXR1cm4gX3N0cmluZ2lmeShbU10pICE9ICdbbnVsbF0nIHx8IF9zdHJpbmdpZnkoeyBhOiBTIH0pICE9ICd7fScgfHwgX3N0cmluZ2lmeShPYmplY3QoUykpICE9ICd7fSc7XG59KSksICdKU09OJywge1xuICBzdHJpbmdpZnk6IGZ1bmN0aW9uIHN0cmluZ2lmeShpdCkge1xuICAgIHZhciBhcmdzID0gW2l0XTtcbiAgICB2YXIgaSA9IDE7XG4gICAgdmFyIHJlcGxhY2VyLCAkcmVwbGFjZXI7XG4gICAgd2hpbGUgKGFyZ3VtZW50cy5sZW5ndGggPiBpKSBhcmdzLnB1c2goYXJndW1lbnRzW2krK10pO1xuICAgICRyZXBsYWNlciA9IHJlcGxhY2VyID0gYXJnc1sxXTtcbiAgICBpZiAoIWlzT2JqZWN0KHJlcGxhY2VyKSAmJiBpdCA9PT0gdW5kZWZpbmVkIHx8IGlzU3ltYm9sKGl0KSkgcmV0dXJuOyAvLyBJRTggcmV0dXJucyBzdHJpbmcgb24gdW5kZWZpbmVkXG4gICAgaWYgKCFpc0FycmF5KHJlcGxhY2VyKSkgcmVwbGFjZXIgPSBmdW5jdGlvbiAoa2V5LCB2YWx1ZSkge1xuICAgICAgaWYgKHR5cGVvZiAkcmVwbGFjZXIgPT0gJ2Z1bmN0aW9uJykgdmFsdWUgPSAkcmVwbGFjZXIuY2FsbCh0aGlzLCBrZXksIHZhbHVlKTtcbiAgICAgIGlmICghaXNTeW1ib2wodmFsdWUpKSByZXR1cm4gdmFsdWU7XG4gICAgfTtcbiAgICBhcmdzWzFdID0gcmVwbGFjZXI7XG4gICAgcmV0dXJuIF9zdHJpbmdpZnkuYXBwbHkoJEpTT04sIGFyZ3MpO1xuICB9XG59KTtcblxuLy8gMTkuNC4zLjQgU3ltYm9sLnByb3RvdHlwZVtAQHRvUHJpbWl0aXZlXShoaW50KVxuJFN5bWJvbFtQUk9UT1RZUEVdW1RPX1BSSU1JVElWRV0gfHwgcmVxdWlyZSgnLi9faGlkZScpKCRTeW1ib2xbUFJPVE9UWVBFXSwgVE9fUFJJTUlUSVZFLCAkU3ltYm9sW1BST1RPVFlQRV0udmFsdWVPZik7XG4vLyAxOS40LjMuNSBTeW1ib2wucHJvdG90eXBlW0BAdG9TdHJpbmdUYWddXG5zZXRUb1N0cmluZ1RhZygkU3ltYm9sLCAnU3ltYm9sJyk7XG4vLyAyMC4yLjEuOSBNYXRoW0BAdG9TdHJpbmdUYWddXG5zZXRUb1N0cmluZ1RhZyhNYXRoLCAnTWF0aCcsIHRydWUpO1xuLy8gMjQuMy4zIEpTT05bQEB0b1N0cmluZ1RhZ11cbnNldFRvU3RyaW5nVGFnKGdsb2JhbC5KU09OLCAnSlNPTicsIHRydWUpO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvZXM2LnN5bWJvbC5qc1xuLy8gbW9kdWxlIGlkID0gOTJcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///92\n");

/***/ }),
/* 93 */
/***/ (function(module, exports, __webpack_require__) {

eval("var META = __webpack_require__(16)('meta');\nvar isObject = __webpack_require__(8);\nvar has = __webpack_require__(1);\nvar setDesc = __webpack_require__(4).f;\nvar id = 0;\nvar isExtensible = Object.isExtensible || function () {\n  return true;\n};\nvar FREEZE = !__webpack_require__(13)(function () {\n  return isExtensible(Object.preventExtensions({}));\n});\nvar setMeta = function (it) {\n  setDesc(it, META, { value: {\n    i: 'O' + ++id, // object ID\n    w: {}          // weak collections IDs\n  } });\n};\nvar fastKey = function (it, create) {\n  // return primitive with prefix\n  if (!isObject(it)) return typeof it == 'symbol' ? it : (typeof it == 'string' ? 'S' : 'P') + it;\n  if (!has(it, META)) {\n    // can't set metadata to uncaught frozen object\n    if (!isExtensible(it)) return 'F';\n    // not necessary to add metadata\n    if (!create) return 'E';\n    // add missing metadata\n    setMeta(it);\n  // return object ID\n  } return it[META].i;\n};\nvar getWeak = function (it, create) {\n  if (!has(it, META)) {\n    // can't set metadata to uncaught frozen object\n    if (!isExtensible(it)) return true;\n    // not necessary to add metadata\n    if (!create) return false;\n    // add missing metadata\n    setMeta(it);\n  // return hash weak collections IDs\n  } return it[META].w;\n};\n// add metadata on freeze-family methods calling\nvar onFreeze = function (it) {\n  if (FREEZE && meta.NEED && isExtensible(it) && !has(it, META)) setMeta(it);\n  return it;\n};\nvar meta = module.exports = {\n  KEY: META,\n  NEED: false,\n  fastKey: fastKey,\n  getWeak: getWeak,\n  onFreeze: onFreeze\n};\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX21ldGEuanM/ZDNhMyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSxXQUFXLG1CQUFPLENBQUMsRUFBUTtBQUMzQixlQUFlLG1CQUFPLENBQUMsQ0FBYztBQUNyQyxVQUFVLG1CQUFPLENBQUMsQ0FBUTtBQUMxQixjQUFjLG1CQUFPLENBQUMsQ0FBYztBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsbUJBQU8sQ0FBQyxFQUFVO0FBQ2hDLGlEQUFpRDtBQUNqRCxDQUFDO0FBQ0Q7QUFDQSxxQkFBcUI7QUFDckI7QUFDQSxTQUFTO0FBQ1QsR0FBRyxFQUFFO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwiZmlsZSI6IjkzLmpzIiwic291cmNlc0NvbnRlbnQiOlsidmFyIE1FVEEgPSByZXF1aXJlKCcuL191aWQnKSgnbWV0YScpO1xudmFyIGlzT2JqZWN0ID0gcmVxdWlyZSgnLi9faXMtb2JqZWN0Jyk7XG52YXIgaGFzID0gcmVxdWlyZSgnLi9faGFzJyk7XG52YXIgc2V0RGVzYyA9IHJlcXVpcmUoJy4vX29iamVjdC1kcCcpLmY7XG52YXIgaWQgPSAwO1xudmFyIGlzRXh0ZW5zaWJsZSA9IE9iamVjdC5pc0V4dGVuc2libGUgfHwgZnVuY3Rpb24gKCkge1xuICByZXR1cm4gdHJ1ZTtcbn07XG52YXIgRlJFRVpFID0gIXJlcXVpcmUoJy4vX2ZhaWxzJykoZnVuY3Rpb24gKCkge1xuICByZXR1cm4gaXNFeHRlbnNpYmxlKE9iamVjdC5wcmV2ZW50RXh0ZW5zaW9ucyh7fSkpO1xufSk7XG52YXIgc2V0TWV0YSA9IGZ1bmN0aW9uIChpdCkge1xuICBzZXREZXNjKGl0LCBNRVRBLCB7IHZhbHVlOiB7XG4gICAgaTogJ08nICsgKytpZCwgLy8gb2JqZWN0IElEXG4gICAgdzoge30gICAgICAgICAgLy8gd2VhayBjb2xsZWN0aW9ucyBJRHNcbiAgfSB9KTtcbn07XG52YXIgZmFzdEtleSA9IGZ1bmN0aW9uIChpdCwgY3JlYXRlKSB7XG4gIC8vIHJldHVybiBwcmltaXRpdmUgd2l0aCBwcmVmaXhcbiAgaWYgKCFpc09iamVjdChpdCkpIHJldHVybiB0eXBlb2YgaXQgPT0gJ3N5bWJvbCcgPyBpdCA6ICh0eXBlb2YgaXQgPT0gJ3N0cmluZycgPyAnUycgOiAnUCcpICsgaXQ7XG4gIGlmICghaGFzKGl0LCBNRVRBKSkge1xuICAgIC8vIGNhbid0IHNldCBtZXRhZGF0YSB0byB1bmNhdWdodCBmcm96ZW4gb2JqZWN0XG4gICAgaWYgKCFpc0V4dGVuc2libGUoaXQpKSByZXR1cm4gJ0YnO1xuICAgIC8vIG5vdCBuZWNlc3NhcnkgdG8gYWRkIG1ldGFkYXRhXG4gICAgaWYgKCFjcmVhdGUpIHJldHVybiAnRSc7XG4gICAgLy8gYWRkIG1pc3NpbmcgbWV0YWRhdGFcbiAgICBzZXRNZXRhKGl0KTtcbiAgLy8gcmV0dXJuIG9iamVjdCBJRFxuICB9IHJldHVybiBpdFtNRVRBXS5pO1xufTtcbnZhciBnZXRXZWFrID0gZnVuY3Rpb24gKGl0LCBjcmVhdGUpIHtcbiAgaWYgKCFoYXMoaXQsIE1FVEEpKSB7XG4gICAgLy8gY2FuJ3Qgc2V0IG1ldGFkYXRhIHRvIHVuY2F1Z2h0IGZyb3plbiBvYmplY3RcbiAgICBpZiAoIWlzRXh0ZW5zaWJsZShpdCkpIHJldHVybiB0cnVlO1xuICAgIC8vIG5vdCBuZWNlc3NhcnkgdG8gYWRkIG1ldGFkYXRhXG4gICAgaWYgKCFjcmVhdGUpIHJldHVybiBmYWxzZTtcbiAgICAvLyBhZGQgbWlzc2luZyBtZXRhZGF0YVxuICAgIHNldE1ldGEoaXQpO1xuICAvLyByZXR1cm4gaGFzaCB3ZWFrIGNvbGxlY3Rpb25zIElEc1xuICB9IHJldHVybiBpdFtNRVRBXS53O1xufTtcbi8vIGFkZCBtZXRhZGF0YSBvbiBmcmVlemUtZmFtaWx5IG1ldGhvZHMgY2FsbGluZ1xudmFyIG9uRnJlZXplID0gZnVuY3Rpb24gKGl0KSB7XG4gIGlmIChGUkVFWkUgJiYgbWV0YS5ORUVEICYmIGlzRXh0ZW5zaWJsZShpdCkgJiYgIWhhcyhpdCwgTUVUQSkpIHNldE1ldGEoaXQpO1xuICByZXR1cm4gaXQ7XG59O1xudmFyIG1ldGEgPSBtb2R1bGUuZXhwb3J0cyA9IHtcbiAgS0VZOiBNRVRBLFxuICBORUVEOiBmYWxzZSxcbiAgZmFzdEtleTogZmFzdEtleSxcbiAgZ2V0V2VhazogZ2V0V2VhayxcbiAgb25GcmVlemU6IG9uRnJlZXplXG59O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX21ldGEuanNcbi8vIG1vZHVsZSBpZCA9IDkzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///93\n");

/***/ }),
/* 94 */
/***/ (function(module, exports, __webpack_require__) {

eval("// all enumerable object keys, includes symbols\nvar getKeys = __webpack_require__(20);\nvar gOPS = __webpack_require__(43);\nvar pIE = __webpack_require__(30);\nmodule.exports = function (it) {\n  var result = getKeys(it);\n  var getSymbols = gOPS.f;\n  if (getSymbols) {\n    var symbols = getSymbols(it);\n    var isEnum = pIE.f;\n    var i = 0;\n    var key;\n    while (symbols.length > i) if (isEnum.call(it, key = symbols[i++])) result.push(key);\n  } return result;\n};\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2VudW0ta2V5cy5qcz81ZGNlIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0EsY0FBYyxtQkFBTyxDQUFDLEVBQWdCO0FBQ3RDLFdBQVcsbUJBQU8sQ0FBQyxFQUFnQjtBQUNuQyxVQUFVLG1CQUFPLENBQUMsRUFBZTtBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0giLCJmaWxlIjoiOTQuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvLyBhbGwgZW51bWVyYWJsZSBvYmplY3Qga2V5cywgaW5jbHVkZXMgc3ltYm9sc1xudmFyIGdldEtleXMgPSByZXF1aXJlKCcuL19vYmplY3Qta2V5cycpO1xudmFyIGdPUFMgPSByZXF1aXJlKCcuL19vYmplY3QtZ29wcycpO1xudmFyIHBJRSA9IHJlcXVpcmUoJy4vX29iamVjdC1waWUnKTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGl0KSB7XG4gIHZhciByZXN1bHQgPSBnZXRLZXlzKGl0KTtcbiAgdmFyIGdldFN5bWJvbHMgPSBnT1BTLmY7XG4gIGlmIChnZXRTeW1ib2xzKSB7XG4gICAgdmFyIHN5bWJvbHMgPSBnZXRTeW1ib2xzKGl0KTtcbiAgICB2YXIgaXNFbnVtID0gcElFLmY7XG4gICAgdmFyIGkgPSAwO1xuICAgIHZhciBrZXk7XG4gICAgd2hpbGUgKHN5bWJvbHMubGVuZ3RoID4gaSkgaWYgKGlzRW51bS5jYWxsKGl0LCBrZXkgPSBzeW1ib2xzW2krK10pKSByZXN1bHQucHVzaChrZXkpO1xuICB9IHJldHVybiByZXN1bHQ7XG59O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2VudW0ta2V5cy5qc1xuLy8gbW9kdWxlIGlkID0gOTRcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///94\n");

/***/ }),
/* 95 */
/***/ (function(module, exports, __webpack_require__) {

eval("// 7.2.2 IsArray(argument)\nvar cof = __webpack_require__(39);\nmodule.exports = Array.isArray || function isArray(arg) {\n  return cof(arg) == 'Array';\n};\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2lzLWFycmF5LmpzP2VkNDMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQSxVQUFVLG1CQUFPLENBQUMsRUFBUTtBQUMxQjtBQUNBO0FBQ0EiLCJmaWxlIjoiOTUuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvLyA3LjIuMiBJc0FycmF5KGFyZ3VtZW50KVxudmFyIGNvZiA9IHJlcXVpcmUoJy4vX2NvZicpO1xubW9kdWxlLmV4cG9ydHMgPSBBcnJheS5pc0FycmF5IHx8IGZ1bmN0aW9uIGlzQXJyYXkoYXJnKSB7XG4gIHJldHVybiBjb2YoYXJnKSA9PSAnQXJyYXknO1xufTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19pcy1hcnJheS5qc1xuLy8gbW9kdWxlIGlkID0gOTVcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///95\n");

/***/ }),
/* 96 */
/***/ (function(module, exports, __webpack_require__) {

eval("// fallback for IE11 buggy Object.getOwnPropertyNames with iframe and window\nvar toIObject = __webpack_require__(6);\nvar gOPN = __webpack_require__(44).f;\nvar toString = {}.toString;\n\nvar windowNames = typeof window == 'object' && window && Object.getOwnPropertyNames\n  ? Object.getOwnPropertyNames(window) : [];\n\nvar getWindowNames = function (it) {\n  try {\n    return gOPN(it);\n  } catch (e) {\n    return windowNames.slice();\n  }\n};\n\nmodule.exports.f = function getOwnPropertyNames(it) {\n  return windowNames && toString.call(it) == '[object Window]' ? getWindowNames(it) : gOPN(toIObject(it));\n};\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX29iamVjdC1nb3BuLWV4dC5qcz80NmI3Il0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0EsZ0JBQWdCLG1CQUFPLENBQUMsQ0FBZTtBQUN2QyxXQUFXLG1CQUFPLENBQUMsRUFBZ0I7QUFDbkMsaUJBQWlCOztBQUVqQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBIiwiZmlsZSI6Ijk2LmpzIiwic291cmNlc0NvbnRlbnQiOlsiLy8gZmFsbGJhY2sgZm9yIElFMTEgYnVnZ3kgT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMgd2l0aCBpZnJhbWUgYW5kIHdpbmRvd1xudmFyIHRvSU9iamVjdCA9IHJlcXVpcmUoJy4vX3RvLWlvYmplY3QnKTtcbnZhciBnT1BOID0gcmVxdWlyZSgnLi9fb2JqZWN0LWdvcG4nKS5mO1xudmFyIHRvU3RyaW5nID0ge30udG9TdHJpbmc7XG5cbnZhciB3aW5kb3dOYW1lcyA9IHR5cGVvZiB3aW5kb3cgPT0gJ29iamVjdCcgJiYgd2luZG93ICYmIE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzXG4gID8gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMod2luZG93KSA6IFtdO1xuXG52YXIgZ2V0V2luZG93TmFtZXMgPSBmdW5jdGlvbiAoaXQpIHtcbiAgdHJ5IHtcbiAgICByZXR1cm4gZ09QTihpdCk7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICByZXR1cm4gd2luZG93TmFtZXMuc2xpY2UoKTtcbiAgfVxufTtcblxubW9kdWxlLmV4cG9ydHMuZiA9IGZ1bmN0aW9uIGdldE93blByb3BlcnR5TmFtZXMoaXQpIHtcbiAgcmV0dXJuIHdpbmRvd05hbWVzICYmIHRvU3RyaW5nLmNhbGwoaXQpID09ICdbb2JqZWN0IFdpbmRvd10nID8gZ2V0V2luZG93TmFtZXMoaXQpIDogZ09QTih0b0lPYmplY3QoaXQpKTtcbn07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fb2JqZWN0LWdvcG4tZXh0LmpzXG4vLyBtb2R1bGUgaWQgPSA5NlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///96\n");

/***/ }),
/* 97 */
/***/ (function(module, exports, __webpack_require__) {

eval("var pIE = __webpack_require__(30);\nvar createDesc = __webpack_require__(14);\nvar toIObject = __webpack_require__(6);\nvar toPrimitive = __webpack_require__(18);\nvar has = __webpack_require__(1);\nvar IE8_DOM_DEFINE = __webpack_require__(36);\nvar gOPD = Object.getOwnPropertyDescriptor;\n\nexports.f = __webpack_require__(5) ? gOPD : function getOwnPropertyDescriptor(O, P) {\n  O = toIObject(O);\n  P = toPrimitive(P, true);\n  if (IE8_DOM_DEFINE) try {\n    return gOPD(O, P);\n  } catch (e) { /* empty */ }\n  if (has(O, P)) return createDesc(!pIE.f.call(O, P), O[P]);\n};\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX29iamVjdC1nb3BkLmpzPzJjYTYiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEsVUFBVSxtQkFBTyxDQUFDLEVBQWU7QUFDakMsaUJBQWlCLG1CQUFPLENBQUMsRUFBa0I7QUFDM0MsZ0JBQWdCLG1CQUFPLENBQUMsQ0FBZTtBQUN2QyxrQkFBa0IsbUJBQU8sQ0FBQyxFQUFpQjtBQUMzQyxVQUFVLG1CQUFPLENBQUMsQ0FBUTtBQUMxQixxQkFBcUIsbUJBQU8sQ0FBQyxFQUFtQjtBQUNoRDs7QUFFQSxZQUFZLG1CQUFPLENBQUMsQ0FBZ0I7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHLFlBQVk7QUFDZjtBQUNBIiwiZmlsZSI6Ijk3LmpzIiwic291cmNlc0NvbnRlbnQiOlsidmFyIHBJRSA9IHJlcXVpcmUoJy4vX29iamVjdC1waWUnKTtcbnZhciBjcmVhdGVEZXNjID0gcmVxdWlyZSgnLi9fcHJvcGVydHktZGVzYycpO1xudmFyIHRvSU9iamVjdCA9IHJlcXVpcmUoJy4vX3RvLWlvYmplY3QnKTtcbnZhciB0b1ByaW1pdGl2ZSA9IHJlcXVpcmUoJy4vX3RvLXByaW1pdGl2ZScpO1xudmFyIGhhcyA9IHJlcXVpcmUoJy4vX2hhcycpO1xudmFyIElFOF9ET01fREVGSU5FID0gcmVxdWlyZSgnLi9faWU4LWRvbS1kZWZpbmUnKTtcbnZhciBnT1BEID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcjtcblxuZXhwb3J0cy5mID0gcmVxdWlyZSgnLi9fZGVzY3JpcHRvcnMnKSA/IGdPUEQgOiBmdW5jdGlvbiBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoTywgUCkge1xuICBPID0gdG9JT2JqZWN0KE8pO1xuICBQID0gdG9QcmltaXRpdmUoUCwgdHJ1ZSk7XG4gIGlmIChJRThfRE9NX0RFRklORSkgdHJ5IHtcbiAgICByZXR1cm4gZ09QRChPLCBQKTtcbiAgfSBjYXRjaCAoZSkgeyAvKiBlbXB0eSAqLyB9XG4gIGlmIChoYXMoTywgUCkpIHJldHVybiBjcmVhdGVEZXNjKCFwSUUuZi5jYWxsKE8sIFApLCBPW1BdKTtcbn07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fb2JqZWN0LWdvcGQuanNcbi8vIG1vZHVsZSBpZCA9IDk3XG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///97\n");

/***/ }),
/* 98 */
/***/ (function(module, exports) {

eval("\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IiIsImZpbGUiOiI5OC5qcyIsInNvdXJjZXNDb250ZW50IjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///98\n");

/***/ }),
/* 99 */
/***/ (function(module, exports, __webpack_require__) {

eval("__webpack_require__(29)('asyncIterator');\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvZXM3LnN5bWJvbC5hc3luYy1pdGVyYXRvci5qcz8zOTg5Il0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBLG1CQUFPLENBQUMsRUFBZSIsImZpbGUiOiI5OS5qcyIsInNvdXJjZXNDb250ZW50IjpbInJlcXVpcmUoJy4vX3drcy1kZWZpbmUnKSgnYXN5bmNJdGVyYXRvcicpO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvZXM3LnN5bWJvbC5hc3luYy1pdGVyYXRvci5qc1xuLy8gbW9kdWxlIGlkID0gOTlcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///99\n");

/***/ }),
/* 100 */
/***/ (function(module, exports, __webpack_require__) {

eval("__webpack_require__(29)('observable');\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvZXM3LnN5bWJvbC5vYnNlcnZhYmxlLmpzPzQxNjciXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEsbUJBQU8sQ0FBQyxFQUFlIiwiZmlsZSI6IjEwMC5qcyIsInNvdXJjZXNDb250ZW50IjpbInJlcXVpcmUoJy4vX3drcy1kZWZpbmUnKSgnb2JzZXJ2YWJsZScpO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvZXM3LnN5bWJvbC5vYnNlcnZhYmxlLmpzXG4vLyBtb2R1bGUgaWQgPSAxMDBcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///100\n");

/***/ }),
/* 101 */
/***/ (function(module, exports) {

eval("/* WEBPACK VAR INJECTION */(function(__webpack_amd_options__) {/* globals __webpack_amd_options__ */\r\nmodule.exports = __webpack_amd_options__;\r\n\n/* WEBPACK VAR INJECTION */}.call(exports, {}))\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vKHdlYnBhY2spL2J1aWxkaW4vYW1kLW9wdGlvbnMuanM/NWY3MSJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUNBIiwiZmlsZSI6IjEwMS5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8qIGdsb2JhbHMgX193ZWJwYWNrX2FtZF9vcHRpb25zX18gKi9cclxubW9kdWxlLmV4cG9ydHMgPSBfX3dlYnBhY2tfYW1kX29wdGlvbnNfXztcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gKHdlYnBhY2spL2J1aWxkaW4vYW1kLW9wdGlvbnMuanNcbi8vIG1vZHVsZSBpZCA9IDEwMVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///101\n");

/***/ }),
/* 102 */
/***/ (function(module, exports) {

eval("module.exports = \"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAJYAAACWCAYAAAA8AXHiAAATBElEQVR42u2da5AcVRXHV1GrpPSTpVVaZalFlQ8+6AfLEkotY1mC0c3udM8uxI2E7HT3TJJNUrEgQQ0kKgREEmISFBISiUB4GwwJjxiK8EiIIghBBBV5hgQlQHanu6fnfb3nPvrenulNstme3Z3dc6pOzWxvb89k+pf/Offcc+90dKChoaGhoaGhoaGhoaGhoaGhoaGhoaGdiE2btud9nRnvSz22O+1Y3t0/9FX8tNBi7Xt9734q1T/UmbK8n6Rsb6vp5J81sn4lnS2Q47nheC/hJzjFzTDyH5nR734z7bgLUpZ/nWF7+0zbc08EIAQLrePMMw9+8PvnD345lfHmUAVaZdjuLsP2D40GIARrStkdp6RmD302lXHTZtb9mWF5d1EV+heFqN4KiBCsSWjfmXnkE2nHO7vb8i6k8GwxHPcpw/GLYwUQgtXm9rWuIx/uzOS/3u3kc1R5rqEQPWw67uB4A4RgtYmdfvpzH+ia7X2RKlAfzYGuoL6TQvTqRAUIwZp49p4Z5w1+piuT76I3YRnNg2417fxzpu1X2w0iBGucbHqv+9GujPutbttdZFjuRhrK9tMP3p8MACFYY2CdnYdOnTFn8CuG5WdM27s6Zbu7aR705mQGCMFKeDj/fcv9Qpfl9lJ4fkEVaFva9l4cy+E8gjUZKtOZ/Jk0gV6SstwbqRI9TfOgEsJzHLBs/9Dx5hMnusNsxPTzB09rGVhUlR5AWKauwxzpjDlDZyBY6MnDRaNUKuOdhWChtyBvdA93rFjxXgQLPXl3vLMRrHF0Z2lAnvtXre29/4KgcbS7DMEaRx9YFpDJYLmLGsCy3J8jWAhW4mBBGxKChWChYiFYCBb6FAYLpvAQLAQLwUKw2gQsy70UwUKwECwEq02S94x7GYI1jj57cUBu31GekP74k1UECz15X7WhNJrkfSWChY5gobcJWJZ7OYKFnjhYsNYTwUJHsHBU2B6jQtPyfolgYR0r+bYZBAvBas1coXclgoVgIVgIVptM6djerxAsBAvBii4x4m5Geq1H8dxR10SwRp28X9WWYCkgfPrc147L5wF/nms8Xmg6bsK5ThBe19SANR0Ea/KDpd1s0/Gbn9viuaM/95uOMxjlObYv4BTXtgP1OmMA1uSdK/RWtQdYjoBIKA88NygsRvionpuOxx5T7GcvhC+d9UgPVaqeHD+HqZWET5xjAGjidXrncggjKukgWJMHLJlH0RvfAzc/K1WoIGDy+M/0eMrmcMDv6D+OwuWxcxhIOY/0UrDOnefxv8lyuAz6CNdOOy7/Gc63fHqeBpfDX38qwTWqKR3LWz2xwQrzHV/cfHHjpcpYnlAplytUxmdQwPEUPM94XIkAyrkULArLzHlK1RgoNr9mWoRHQ7xe36ICmTlAQZxPVS5ULj+S8CNYw+RYtnf12ILlxPjxoHJUyApDnw0qJZxC1Q3nUYgMClUKwMqwTc2Ygpl8gzOasFMFmlcgvaBKEiBHPgZcCWXYpI/nLSyQvoU+g6tHGzmaqFgTCyxzuBszzAiMH4sm3xysgIWxlMXzJx76BEQUKlAtBo4l1MuWuZLPAOmdq5J9I+sLxZMhTygiHSn2DQRk1iKfzFpQYCE0zPOcqaFao8yx1rQWLB0ax2/YAU5TppjcBX7fw/5OA8jmoYsBBGFQqJYhcisGhTwmQpoEB5J2BleOQ2SIUoU6Rx2DRL+Xhs4+qlazFgSsPGGG5Yn494vlhrECS0u60/qITt6gMBz6IWSmDh8okwhZHCb5vCBAcvlxSNRZQi/LCCq5T+vhDa6Zk4/q9UyhZhJ8IyvCZg4S+AL5wXyR/Dt+/H8IBCsuef91y8BS4UULg2KIL0dYpnZzjTDUydzHYyO7MAzKkSADKM9HdZCEi5CWYuGwwI4b4prsfPEeQLF6cqqwyiBrKDeAs5JElp8PcJ0zT0Gk3nsy4RDBOlmwQkXyI+phsiG+GvHxQqUMeyp8sdzJ0eFyRciSMOnJvIBKliPkdaUDLHM5LBKadM6PDA5kHibD5jk5GYY9kZf5TVNBCFYzWGnbW5s4WGZWhUA1mlPh0AhHXryeJEdjRkOtyJAKxHInnqyzupQMf0K9GISWSy5dG5Arr6VJ93yXgWDYef76lqhb2aKWBXDN8xhYDLK5Qr1kgg/H6OPSywOyemOROEv4lI+p1c8QrHEAS42eCuT+hyqkQD878KDIXf485BLy6hs11gK79nclls/05AJRQpBTNlwx0ranKuwCLHtJgdz7YIUcHayTel39I+G56xPy6J+rZNHyQKmXUB6A7ByAiibnUNvqEcoFMK3bXCIvvlIjpXL0g4P3/dSzNXLRFUWei0G4nDt6sOZPErCyzcn7upaEQgnWg4+dWN80wHDk3TrZeneJlwNkSIQ8ylYjNxkiL1tbJG+8GQUqzgaH6uSaG4pMtUyR8BtU3fhUj8eq7aCcUFbY99cqqR7n7boeIZtuLbE8rDeHYI0ZWPqQ3GBgVUb0Bms1Qp58tsputOkomAxtXu+ydUXy9rv1JjCLJa4sjbB5VL2uu6kE20QzTzGYxCjS5sn4nscr7LV1K5W4spYrzdfbcHM5EbBmLy6Q23dUJqTvG8FiimxTd4O/Plmw9CIidV2xKvQG3bmzHOYvG7aWyBPPVIlfaIYLbnQ6G02swWct8MmzL0QJeOdonWyk1+JAe+QXawpMzXR75WCNLLg4YKUKNQLl6nfnfeVI6IMwuvWPJT4KpefO/UmB7H2iyt6/tMP/q5PFPwuwQDpmYGWjLS2NYN2xsxIO9WVxctHyAtvSWVcaUJ7Nt5XU8F44AAS/kwbKdSkNi/ogAR4XrvDJ4f8qAAGcm7aVeelBKxv8mAL+vyP1ZnXLylEmz6VmzudwyfdYof+sbfdXEKxhwIJvt00OrIy7i1W4w3DoR0IhB6scjr50JeqLUaLn/11ThUuhLqBw4fXo0+1/qsSUMvjzm7dFlQiuZwio5FTOAw/TEFhX4XQvzbOMsN4WsKIsnH8uTfJXbywxNZP2z//UEKzhcizL/01yYFkAVhCOCuEFmhWrLGpFWg4lnq+5vhi5cZAowz9Owrfg4gILQWFinifk8vXFECQdKrju0pVUjd6uR9Rt2ZVBWN+C6ZqXXqtFQuCa63lINWzVn8WnjuBvXPLqQXU9uPbSlUUEa0zAYm2+avpmd4xi9WiKJavYUpVABaRVQ0XiJYw1m4qRfOzVN+qqwKoXW0U9DIB9QbsehNBrtvAwB+BddV2RwRtej+ZhqubmizlIj08d0ZFkiqrXgedrTeAjWDE5lu3/NjGwuhhY0aLo7pjkvTkUKiDue0iFJjAIfVKNbrunHBmhwU3WVSo6NcTBeuyJBsXcUQnbb27dXopcD15LNRGqqj4rsFKwuilgD+1T14MR49rNJRwVthosUKy03nt+jBxLnzM0QtUqkBvviuZFEKokgPfviUIH1w6nYhwVAtMCDsPxm8odux+rhOfpagrXBahNrRArlRSOddt5plzrNhfJnv0V8vD+Ktn1SIUm/0WsY8Un79cmD1ZWzdPFgdWT07tBNcWivpbeuIL2Wb9+uK6VLqKQMLCy0dEghK6UhIP+DhRSLxM8tK/CpoXAn/5Ho5qV+XVsXjyF67B8weGF1RQUVzP0MeNF/jMgWLE51nUJ51hKOQCs3cMk73rxU7YJgy9fFZC3j2oJN32+fHXAzgco9Pzrj7sq4esYthfCBWCkRa87wFJpCJ+GeD09X4JiKKgl6/MS/fJpSzQMikJqN+uhd1mvFs/jglHPGaJijWBKx7CDsAYUOyrU1Iq7F44MY8GixxpBgGvdzhTGEz1ZroDMDTsR4L3EgSWniyD5j+ZLxRgF9FX5gV63S5sET6IfCxVrJGBlVVEzLhTKAqretXlMxVrFR5oHno9JxG3ZRcoBTUsYbF6Fv31nI1jVEOrXDzWAtamoDQa0pkE5amWlBzFaTKgfC8EaQeVdXwPYFAp3lMPFCo1QxYL1rgyFUPmuNIPFKuRuGK7MsDeLJ/F37IxTLB7emsDaXIwMBMJ6nJwlEC06EAp5j9foF1YgWCcIVk8ErOFDoaxzNU4yr1xfYoVPvQi5ZCWEKDc+ebf9SE+9XCsoi7B33hsFi5UvxGvpxVGoca3fUmoYZVLPqWIuKNXSlQXyawrg2k0lVtBdvCJAsGLLDe6G5Bv9cqITNK7csKOiLazwG5Z2xYwKD9Vip4ckWPym85ypR3Slhj3sw/yNBLsxZ5Nqqiuq3gYESqiXKKAGdtv2MhZIxwIsUy6CGKa7QeVYzZ0LcMNjk23IaSyaL91TifwOygVmtqAthGj2xpHk9l2VUI32asVTOcqMFm0LkZobHPvL08kWSCftJLTlbmxNo19WhsJKkyqk9ZXMDT1X+s1WRUue36y/oRjpbIBQxm58ToW+Hg0quPbf/xkNd9ffogq0jVV+yOHU+9Lbf9T6xgMv4JTOuIOVHk6xsr7WDKhKD/MvjvZRAQgbt5b5QlR6cy++Mog0+IWTyo5K3E0tiZ8fM2l9xTWqxWb9liior9FkHrosDF1Rs6okAqui9feHk9DHWqWTMFhqzaDfNKWi51iGXBomygRwDMJUpRpVpHMHeHcBq3pb0Ull2WOllE9TGRo+N2yNUTi2HIznZAMMvIbuho3FSAt0uOiVvs9V10YnreG9mNg2Ew+W7V6frGI52tIvO2ZUKEOhrVfoA9ZH7mktM7wAWmIwGXLlM338w33lCHyvvF4nA8t8sYgVKuYBA7FvwKVhKxpWdz1cCVcHmUKFHv1LJdJgCD1hfQOiXBEufuXnxjb6OQjW2IJ13FDIJ6sXreCdmfrEM9y8A/+okR8M+AIspUgLlweR8CbPhSVaquvTa+phZ/UwKLTaWr87hQWOHXmnHmmLfmR/hYW9cPk9Vb+7H4hOjr9Fw+CP2YodXP41NmDpq5sbwALVePOtOnnlYJ0c+m+d9VY1LmAAUP79co0suoSvG0wLZZEdC/AzhL9SKfo3UFTd/7cqeeTPVXLwcHT1DgBx1718MQUrTVhcsdiyfPr8zp2VkV/vvjKuhD4GWJSFTS1b/pUewfIvecPgRoJSMeWx/MjuNPr+oHc/UGla+zfcqh9QL77USyz50uYS5fWg16twAvcYyhJ7Hq8mtpURgnUyo8Ksf1yw2OJSmhDvf6pKLrkq4GWDcK/Q5s03dJXYQEeMMDIbbm0hJOOgRvq8pFqqr436bL7vwxW/KbLW4+GuB6PKm/5QTnTzNQRrpHs3iAIj9J1DEREq6vxR+KYSW5zgLNU33Di5petr6LWgsxNC6Euv1WlCXmXr/voWyusG2kYefrj7TUrkZHJ1tRwtwmJYaCp8/sUaeZkODmClNixV61ug7eiHinW8csPmlm9jZGpbFYWhzWneMyuR8KJXzENlaih0akv3ee+WCruyjyvcCskWgwdbq8YnOBJEsEa5o5++m1/EW7xtdzrcjE1tv807RCU00RXRRlbsHRGCpbZVwn3eRzIq9H43dnuQjmT/0aS+aEDsqyVdhj5T378rq9YlhotZbR3G1r1X2N90+erShHSYm20PsMbJpXKlRdEzbat9u5pd37pSbRCHXyCAYA0Pl9OYhzXA1fglAQ5+M8VJjwot94apAZaW0Ec3p9XabBrrZdmpq1YI1kmOFk3Hj7T3qIKpH4UKFQvBGtFosanvquH4FIcqgRxry5T8IswxLX8cw52lAdvCaSL6wcM1BGs039OTHocvwJwCdawpDBZ+dW8rwfo9goVgIVgIVpt0N1jujQgWgoVgIVgIFvrULjfchGCht6JAimChI1jo7fMt9jcjWOgIFjqChT6FW5NTtrcVwcI6VgvWFSJYCFZr5gpvQbAQLAQLwUKw0Kf0SmjvVgQLwUKwEKy2AQvrWAgW9rwjWG0DVgu+/QsdwTJt72oEC8FqAVj+JQgWdpCO2vsvaJjSybjnIFjoiXvXbO+LCBZ6stsX2P5fO5I0BAudQlVN9Q91IljoCeyB4ddMx3/NsP1tnXPyn+9I2oxM/sxU1lsKjfSG7T5DX7CMH/yxnd6MQz22O60tfU7+G9PPHzyt48tPvr9jLG3atD3vm97vnt6dc881Mu5lKcvbTqXyZQRKA8vxXupASwi43rc+NGPO0BlGxndStreOKtweqnBHESy0lpj5wyMfT2W8syhsF8Bck+G4TxmOX0Sw0Fpgd5zy3Vn5z3X3uz2G5f4cEsS07b1IH+sIFlri1tl56NQZcwa/Ylh+hircGqpwD5q2+w6ChdYSO+s892Mpy/12t+0uoqBtoMq213TcIQQLrSX2nZlHPgH5W7fj/gi+8owCt9+0PRfBQmuNws1855MzMt70bsu7EPYmp8A9QW+2j2ChtcLek5p79NMwNdGd8S6CTcRghEoVLkCw0JK3FSveC5Xmrky+y7T9n8JqX5hhGE1JBMFCO2ZJJDV76LPd/XkDGtwocLdRhfv7iUxpIVhoaGhoaGhoaGhoaGhoaGhoaGhoaGhoaGhoaGhT0f4P8KUhaCnNRQcAAAAASUVORK5CYII=\"\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvYXNzZXRzL2ltYWdldmlldy9zdWZmaXgvZG9jLnBuZz85Yjc1Il0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBLGlDQUFpQyIsImZpbGUiOiIxMDIuanMiLCJzb3VyY2VzQ29udGVudCI6WyJtb2R1bGUuZXhwb3J0cyA9IFwiZGF0YTppbWFnZS9wbmc7YmFzZTY0LGlWQk9SdzBLR2dvQUFBQU5TVWhFVWdBQUFKWUFBQUNXQ0FZQUFBQThBWEhpQUFBVEJFbEVRVlI0MnUyZGE1QWNWUlhIVjFHcnBQU1RwVlZhWmFsRmxROCs2QWZMRWtvdFkxbUMwYzN1ZE04dXhJMkU3SFQzVEpKTlVyRWdRUTBrS2dSRUVtSVNGQklTaVVCNEd3d0pqeGlLOEVpSUlnaEJCQlY1aGdRbFFIYW51NmZuZmIzblB2cmVudWxOc3RtZTNaM2RjNnBPeld4dmI4OWsrcGYvT2ZmY2MrOTBkS0Nob2FHaG9hR2hvYUdob2FHaG9hR2hvYUdob2FHZGlFMmJ0dWQ5blJudlN6MjJPKzFZM3QwLzlGWDh0TkJpN1h0OTczNHExVC9VbWJLOG42UnNiNnZwNUo4MXNuNGxuUzJRNDduaGVDL2hKempGelREeUg1blI3MzR6N2JnTFVwWi9uV0Y3KzB6YmMwOEVJQVFMcmVQTU13OSs4UHZuRDM0NWxmSG1VQVZhWmRqdUxzUDJENDBHSUFSclN0a2RwNlJtRDMwMmxYSFRadGI5bVdGNWQxRVYraGVGcU40S2lCQ3NTV2pmbVhua0UybkhPN3ZiOGk2azhHd3hIUGNwdy9HTFl3VVFndFhtOXJXdUl4L3V6T1MvM3Uza2MxUjVycUVRUFd3Njd1QjRBNFJndFltZGZ2cHpIK2lhN1gyUktsQWZ6WUd1b0w2VFF2VHFSQVVJd1pwNDlwNFo1dzErcGl1VDc2STNZUm5OZzI0MTdmeHpwdTFYMncwaUJHdWNiSHF2KzlHdWpQdXRidHRkWkZqdVJocks5dE1QM3A4TUFDRllZMkNkbllkT25URm44Q3VHNVdkTTI3czZaYnU3YVI3MDVtUUdDTUZLZURqL2ZjdjlRcGZsOWxKNGZrRVZhRnZhOWw0Y3krRThnalVaS3RPWi9KazBnVjZTc3R3YnFSSTlUZk9nRXNKekhMQnMvOUR4NWhNbnVzTnN4UFR6QjA5ckdWaFVsUjVBV0thdXd4enBqRGxEWnlCWTZNbkRSYU5VS3VPZGhXQ2h0eUJ2ZEE5M3JGanhYZ1FMUFhsM3ZMTVJySEYwWjJsQW52dFhyZTI5LzRLZ2NiUzdETUVhUng5WUZwREpZTG1MR3NDeTNKOGpXQWhXNG1CQkd4S0NoV0NoWWlGWUNCYjZGQVlMcHZBUUxBUUx3VUt3MmdRc3k3MFV3VUt3RUN3RXEwMlM5NHg3R1lJMWpqNTdjVUJ1MzFHZWtQNzRrMVVFQ3oxNVg3V2hOSnJrZlNXQ2hZNWdvYmNKV0paN09ZS0ZuamhZc05ZVHdVSkhzSEJVMkI2alF0UHlmb2xnWVIwcitiWVpCQXZCYXMxY29YY2xnb1ZnSVZnSVZwdE02ZGplcnhBc0JBdkJpaTR4NG01R2VxMUg4ZHhSMTBTd1JwMjhYOVdXWUNrZ2ZQcmMxNDdMNXdGL25tczhYbWc2YnNLNVRoQmUxOVNBTlIwRWEvS0RwZDFzMC9HYm45dml1YU0vOTV1T014amxPYll2NEJUWHRnUDFPbU1BMXVTZEsvUld0UWRZam9CSUtBODhOeWdzUnZpb25wdU94eDVUN0djdmhDK2Q5VWdQVmFxZUhEK0hxWldFVDV4akFHamlkWHJuY2dnakt1a2dXSk1ITEpsSDBSdmZBemMvSzFXb0lHRHkrTS8wZU1ybWNNRHY2RCtPd3VXeGN4aElPWS8wVXJET25lZnh2OGx5dUF6NkNOZE9PeTcvR2M2M2ZIcWVCcGZEWDM4cXdUV3FLUjNMV3oyeHdRcnpIVi9jZkhIanBjcFlubEFwbHl0VXhtZFF3UEVVUE05NFhJa0F5cmtVTEFyTHpIbEsxUmdvTnI5bVdvUkhRN3hlMzZJQ21UbEFRWnhQVlM1VUxqK1M4Q05ZdytSWXRuZjEySUxseFBqeG9ISlV5QXBEbncwcUpaeEMxUTNuVVlnTUNsVUt3TXF3VGMyWWdwbDhnek9hc0ZNRm1sY2d2YUJLRWlCSFBnWmNDV1hZcEkvbkxTeVF2b1UrZzZ0SEd6bWFxRmdUQ3l4enVCc3p6QWlNSDRzbTN4eXNnSVd4bE1Yekp4NzZCRVFVS2xBdEJvNGwxTXVXdVpMUEFPbWRxNUo5SStzTHhaTWhUeWdpSFNuMkRRUmsxaUtmekZwUVlDRTB6UE9jcWFGYW84eXgxclFXTEIwYXgyL1lBVTVUcHBqY0JYN2Z3LzVPQThqbW9Zc0JCR0ZRcUpZaGNpc0doVHdtUXBvRUI1SjJCbGVPUTJTSVVvVTZSeDJEUkwrWGhzNCtxbGF6RmdTc1BHR0c1WW40OTR2bGhyRUNTMHU2MC9xSVR0NmdNQno2SVdTbURoOG9rd2haSENiNXZDQkFjdmx4U05SWlFpL0xDQ3E1VCt2aERhNlprNC9xOVV5aFpoSjhJeXZDWmc0UytBTDV3WHlSL0R0Ky9IOElCQ3N1ZWY5MXk4QlM0VVVMZzJLSUwwZFlwblp6alREVXlkekhZeU83TUF6S2tTQURLTTlIZFpDRWk1Q1dZdUd3d0k0YjRwcnNmUEVlUUxGNmNxcXd5aUJyS0RlQXM1SkVscDhQY0owelQwR2szbnN5NFJEQk9sbXdRa1h5SStwaHNpRytHdkh4UXFVTWV5cDhzZHpKMGVGeVJjaVNNT25KdklCS2xpUGtkYVVETEhNNUxCS2FkTTZQREE1a0hpYkQ1ams1R1lZOWtaZjVUVk5CQ0ZZeldHbmJXNXM0V0daV2hVQTFtbFBoMEFoSFhyeWVKRWRqUmtPdHlKQUt4SElubnF5enVwUU1mMEs5R0lTV1N5NWRHNUFycjZWSjkzeVhnV0RZZWY3NmxxaGIyYUtXQlhETjh4aFlETEs1UXIxa2dnL0g2T1BTeXdPeWVtT1JPRXY0bEkrcDFjOFFySEVBUzQyZUN1VCtoeXFrUUQ4NzhLRElYZjQ4NUJMeTZoczExZ0s3OW5jbGxzLzA1QUpSUXBCVE5sd3gwcmFuS3V3Q0xIdEpnZHo3WUlVY0hheVRlbDM5SStHNTZ4UHk2SityWk5IeVFLbVhVQjZBN0J5QWlpYm5VTnZxRWNvRk1LM2JYQ0l2dmxJanBYTDBnNFAzL2RTek5YTFJGVVdlaTBHNG5EdDZzT1pQRXJDeXpjbjd1cGFFUWduV2c0K2RXTjgwd0hEazNUclplbmVKbHdOa1NJUTh5bFlqTnhraUwxdGJKRys4R1FVcXpnYUg2dVNhRzRwTXRVeVI4QnRVM2ZoVWo4ZXE3YUNjVUZiWTk5Y3FxUjduN2JvZUladHVMYkU4ckRlSFlJMFpXUHFRM0dCZ1ZVYjBCbXMxUXA1OHRzcHV0T2tvbUF4dFh1K3lkVVh5OXJ2MUpqQ0xKYTRzamJCNVZMMnV1NmtFMjBRelR6R1l4Q2pTNXNuNG5zY3I3TFYxSzVXNHNwWXJ6ZGZiY0hNNUViQm1MeTZRMjNkVUpxVHZHOEZpaW14VGQ0Ty9QbG13OUNJaWRWMnhLdlFHM2JtekhPWXZHN2FXeUJQUFZJbGZhSVlMYm5RNkcwMnN3V2N0OE1tekwwUUplT2Rvbld5azErSkFlK1FYYXdwTXpYUjc1V0NOTExnNFlLVUtOUUxsNm5mbmZlVkk2SU13dXZXUEpUNEtwZWZPL1VtQjdIMml5dDYvdE1QL3E1UEZQd3V3UURwbVlHV2pMUzJOWU4yeHN4SU85V1Z4Y3RIeUF0dlNXVmNhVUo3TnQ1WFU4RjQ0QUFTL2t3YktkU2tOaS9vZ0FSNFhydkRKNGY4cUFBR2NtN2FWZWVsQkt4djhtQUwrdnlQMVpuWEx5bEVtejZWbXp1ZHd5ZmRZb2Yrc2JmZFhFS3hod0lKdnQwME9ySXk3aTFXNHczRG9SMEloQjZzY2pyNTBKZXFMVWFMbi8xMVRoVXVoTHFCdzRmWG8wKzEvcXNTVU12anptN2RGbFFpdVp3aW81RlRPQXcvVEVGaFg0WFF2emJPTXNONFdzS0lzbkg4dVRmSlhieXd4TlpQMnovL1VFS3poY2l6TC8wMXlZRmtBVmhDT0N1RUZtaFdyTEdwRldnNGxucSs1dmhpNWNaQW93ejlPd3JmZzRnSUxRV0Zpbmlmazh2WEZFQ1FkS3JqdTBwVlVqZDZ1UjlSdDJaVkJXTitDNlpxWFhxdEZRdUNhNjNsSU5XelZuOFduanVCdlhQTHFRWFU5dVBiU2xVVUVhMHpBWW0yK2F2cG1kNHhpOVdpS0phdllVcFZBQmFSVlEwWGlKWXcxbTRxUmZPelZOK3Fxd0tvWFcwVTlESUI5UWJzZWhOQnJ0dkF3QitCZGRWMlJ3UnRlaitaaHF1Ym1pemxJajA4ZDBaRmtpcXJYZ2VkclRlQWpXREU1bHUzL05qR3d1aGhZMGFMbzdwamt2VGtVS2lEdWUwaUZKakFJZlZLTmJydW5IQm1od1UzV1ZTbzZOY1RCZXV5SkJzWGNVUW5iYjI3ZFhvcGNEMTVMTlJHcXFqNHJzRkt3dWlsZ0QrMVQxNE1SNDlyTkpSd1Z0aG9zVUt5MDNudCtqQnhMbnpNMFF0VXFrQnZ2aXVaRkVLb2tnUGZ2aVVJSDF3Nm5ZaHdWQXRNQ0RzUHhtOG9kdXgrcmhPZnBhZ3JYQmFoTnJSQXJsUlNPZGR0NXBsenJOaGZKbnYwVjh2RCtLdG4xU0lVbS8wV3NZOFVuNzljbUQxWld6ZFBGZ2RXVDA3dEJOY1dpdnBiZXVJTDJXYjkrdUs2VkxxS1FNTEN5MGRFZ2hLNlVoSVArRGhSU0x4TTh0Sy9DcG9YQW4vNUhvNXFWK1hWc1hqeUY2N0I4d2VHRjFSUVVWelAwTWVORi9qTWdXTEU1MW5VSjUxaEtPUUNzM2NNazczcnhVN1lKZ3k5ZkZaQzNqMm9KTjMyK2ZIWEF6Z2NvOVB6cmo3c3E0ZXNZdGhmQ0JXQ2tSYTg3d0ZKcENKK0dlRDA5WDRKaUtLZ2w2L01TL2ZKcFN6UU1pa0pxTit1aGQxbXZGcy9qZ2xIUEdhSmlqV0JLeDdDRHNBWVVPeXJVMUlxN0Y0NE1ZOEdpeHhwQmdHdmR6aFRHRXoxWnJvRE1EVHNSNEwzRWdTV25peUQ1aitaTHhSZ0Y5Rlg1Z1Y2M1M1c0VUNklmQ3hWckpHQmxWVkV6TGhUS0FxcmV0WGxNeFZyRlI1b0hubzlKeEczWlJjb0JUVXNZYkY2RnYzMW5JMWpWRU9yWER6V0F0YW1vRFFhMHBrRTVhbVdsQnpGYVRLZ2ZDOEVhUWVWZFh3UFlGQXAzbE1QRkNvMVF4WUwxcmd5RlVQbXVOSVBGS3VSdUdLN01zRGVMSi9GMzdJeFRMQjdlbXNEYVhJd01CTUo2bkp3bEVDMDZFQXA1ajlmb0YxWWdXQ2NJVms4RXJPRkRvYXh6TlU0eXIxeGZZb1ZQdlFpNVpDV0VLRGMrZWJmOVNFKzlYQ3NvaTdCMzNoc0ZpNVV2eEd2cHhWR29jYTNmVW1vWVpWTFBxV0l1S05YU2xRWHlhd3JnMmswbFZ0QmR2Q0pBc0dMTERlNkc1QnY5Y3FJVE5LN2NzS09pTGF6d0c1WjJ4WXdLRDlWaXA0Y2tXUHltODV5cFIzU2xoajNzdy95TkJMc3haNU5xcWl1cTNnWUVTcWlYS0tBR2R0djJNaFpJeHdJc1V5NkNHS2E3UWVWWXpaMExjTU5qazIzSWFTeWFMOTFUaWZ3T3lnVm10cUF0aEdqMnhwSGs5bDJWVUkzMmFzVlRPY3FNRm0wTGtab2JIUHZMMDhrV1NDZnRKTFRsYm14Tm8xOVdoc0pLa3lxazlaWE1EVDFYK3MxV1JVdWUzNnkvb1JqcGJJQlF4bTU4VG9XK0hnMHF1UGJmL3hrTmQ5ZmZvZ3EwalZWK3lPSFUrOUxiZjlUNnhnTXY0SlRPdUlPVkhrNnhzcjdXREtoS0QvTXZqdlpSQVFnYnQ1YjVRbFI2Y3krK01vZzArSVdUeW81SzNFMHRpWjhmTTJsOXhUV3F4V2I5bGlpb3I5RmtIcm9zREYxUnM2b2tBcXVpOWZlSGs5REhXcVdUTUZocXphRGZOS1dpNTFpR1hCb215Z1J3RE1KVXBScFZwSE1IZUhjQnEzcGIwVWxsMldPbGxFOVRHUm8rTjJ5TlVUaTJISXpuWkFNTXZJYnVobzNGU0F0MHVPaVZ2czlWMTBZbnJlRzltTmcyRXcrVzdWNmZyR0k1MnRJdk8yWlVLRU9oclZmb0E5Wkg3bWt0TTd3QVdtSXdHWExsTTMzOHczM2xDSHl2dkY0bkE4dDhzWWdWS3VZQkE3RnZ3S1ZoS3hwV2R6MWNDVmNIbVVLRkh2MUxKZEpnQ0QxaGZRT2lYQkV1ZnVYbnhqYjZPUWpXMklKMTNGRElKNnNYcmVDZG1mckVNOXk4QS8rb2tSOE0rQUlzcFVnTGx3ZVI4Q2JQaFNWYXF1dlRhK3BoWi9Vd0tMVGFXcjg3aFFXT0hYbW5IbW1MZm1SL2hZVzljUGs5VmIrN0g0aE9qcjlGdytDUDJZb2RYUDQxTm1EcHE1c2J3QUxWZVBPdE9ubmxZSjBjK20rZDlWWTFMbUFBVVA3OWNvMHN1b1N2RzB3TFpaRWRDL0F6aEw5U0tmbzNVRlRkLzdjcWVlVFBWWEx3Y0hUMURnQngxNzE4TVFVclRWaGNzZGl5ZlByOHpwMlZrVi92dmpLdWhENEdXSlNGVFMxYi9wVWV3Zkl2ZWNQZ1JvSlNNZVd4L01qdU5QcitvSGMvVUdsYSt6ZmNxaDlRTDc3VVN5ejUwdVlTNWZXZzE2dHdBdmNZeWhKN0hxOG10cFVSZ25VeW84S3NmMXl3Mk9KU21oRHZmNnBLTHJrcTRHV0RjSy9RNXMwM2RKWFlRRWVNTURJYmJtMGhKT09nUnZxOHBGcXFyNDM2Ykw3dnd4Vy9LYkxXNCtHdUI2UEttLzVRVG5Uek5RUnJwSHMzaUFJajlKMURFUkVxNnZ4UitLWVNXNXpnTE5VMzNEaTVwZXRyNkxXZ3N4TkM2RXV2MVdsQ1htWHIvdm9XeXVzRzJrWWVmcmo3VFVya1pISjF0Und0d21KWWFDcDgvc1VhZVprT0RtQ2xOaXhWNjF1ZzdlaUhpblc4Y3NQbWxtOWpaR3BiRllXaHpXbmVNeXVSOEtKWHpFTmxhaWgwYWt2M2VlK1dDcnV5anl2Y0Nza1dnd2RicThZbk9CSkVzRWE1bzUrK20xL0VXN3h0ZHpyY2pFMXR2ODA3UkNVMDBSWFJSbGJzSFJHQ3BiWlZ3bjNlUnpJcTlINDNkbnVRam1ULzBhUythRURzcXlWZGhqNVQzNzhycTlZbGhvdFpiUjNHMXIxWDJOOTArZXJTaEhTWW0yMFBzTWJKcFhLbFJkRXpiYXQ5dTVwZDM3cFNiUkNIWHlDQVlBMFBsOU9ZaHpYQTFmZ2xBUTUrTThWSmp3b3Q5NGFwQVphVzBFYzNwOVhhYkJyclpkbXBxMVlJMWttT0ZrM0hqN1QzcUlLcEg0VUtGUXZCR3RGb3NhbnZxdUg0RkljcWdSeHJ5NVQ4SXN3eExYOGN3NTJsQWR2Q2FTTDZ3Y00xQkdzMDM5T1RIb2N2d0p3Q2Rhd3BEQlorZFc4cndmbzlnb1ZnSVZnSVZwdDBOMWp1alFnV2dvVmdJVmdJRnZyVUxqZmNoR0NodDZKQWltQ2hJMWpvN2ZNdDlqY2pXT2dJRmpxQ2hUNkZXNU5UdHJjVndjSTZWZ3ZXRlNKWUNGWnI1Z3B2UWJBUUxBUUx3VUt3MEtmMFNtanZWZ1FMd1VLd0VLeTJBUXZyV0FnVzlyd2pXRzBEVmd1Ky9Rc2R3VEp0NzJvRUM4RnFBVmorSlFnV2RwQ08ydnN2YUpqU3liam5JRmpvaVh2WGJPK0xDQlo2c3RzWDJQNWZPNUkwQkF1ZFFsVk45UTkxSWxqb0NleUI0ZGRNeDMvTnNQMXRuWFB5bis5STJveE0vc3hVMWxzS2pmU0c3VDVEWDdDTUgveXhuZDZNUXoyMk82MHRmVTcrRzlQUEh6eXQ0OHRQdnI5akxHM2F0RDN2bTk3dm50NmRjODgxTXU1bEtjdmJUcVh5WlFSS0E4dnhYdXBBU3dpNDNyYytOR1BPMEJsR3huZFN0cmVPS3R3ZXFuQkhFU3kwbHBqNXd5TWZUMlc4c3loc0Y4QmNrK0c0VHhtT1gwU3cwRnBnZDV6eTNWbjV6M1gzdXoyRzVmNGNFc1MwN2IxSUgrc0lGbHJpMXRsNTZOUVpjd2EvWWxoK2hpcmNHcXB3RDVxMit3NkNoZFlTTytzODkyTXB5LzEydCswdW9xQnRvTXEyMTNUY0lRUUxyU1gyblpsSFBnSDVXN2ZqL2dpKzhvd0N0OSswUFJmQlFtdU53czE4NTVNek10NzBic3U3RVBZbXA4QTlRVysyajJDaHRjTGVrNXA3OU5Nd05kR2Q4UzZDVGNSZ2hFb1ZMa0N3MEpLM0ZTdmVDNVhtcmt5K3k3VDluOEpxWDVoaEdFMUpCTUZDTzJaSkpEVjc2TFBkL1hrREd0d29jTGRSaGZ2N2lVeHBJVmhvYUdob2FHaG9hR2hvYUdob2FHaG9hR2hvYUdob2FHaG9hR2hUMGY0UDhLVWhhQ25OUlFjQUFBQUFTVVZPUks1Q1lJST1cIlxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vc3JjL2Fzc2V0cy9pbWFnZXZpZXcvc3VmZml4L2RvYy5wbmdcbi8vIG1vZHVsZSBpZCA9IDEwMlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///102\n");

/***/ }),
/* 103 */
/***/ (function(module, exports) {

eval("module.exports = \"data:image/png;base64,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\"\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvYXNzZXRzL2ltYWdldmlldy9zdWZmaXgvZG9jeC5wbmc/MGUzZiJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSxpQ0FBaUMiLCJmaWxlIjoiMTAzLmpzIiwic291cmNlc0NvbnRlbnQiOlsibW9kdWxlLmV4cG9ydHMgPSBcImRhdGE6aW1hZ2UvcG5nO2Jhc2U2NCxpVkJPUncwS0dnb0FBQUFOU1VoRVVnQUFBSllBQUFDV0NBWUFBQUE4QVhIaUFBQVRCRWxFUVZSNDJ1MmRhNUFjVlJYSFYxR3JwUFNUcFZWYVphbEZsUTgrNkFmTEVrb3RZMW1DMGMzdWRNOHV4STJFN0hUM1RKSk5VckVnUVEwa0tnUkVFbUlTRkJJU2lVQjRHd3dKanhpSzhFaUlJZ2hCQkJWNWhnUWxRSGFudTZmbmZiM25QdnJlbnVsTnN0bWUzWjNkYzZwT3pXeHZiODlrK3BmL09mZmNjKzkwZEtDaG9hR2hvYUdob2FHaG9hR2hvYUdob2FHaG9hR2RpRTJidHVkOW5SbnZTejIyTysxWTN0MC85Rlg4dE5CaTdYdDk3MzRxMVQvVW1iSzhuNlJzYjZ2cDVKODFzbjRsblMyUTQ3bmhlQy9oSnpqRnpURHlINW5SNzM0ejdiZ0xVcFovbldGNyswemJjMDhFSUFRTHJlUE1NdzkrOFB2bkQzNDVsZkhtVUFWYVpkanVMc1AyRDQwR0lBUnJTdGtkcDZSbUQzMDJsWEhUWnRiOW1XRjVkMUVWK2hlRnFONEtpQkNzU1dqZm1YbmtFMm5ITzd2YjhpNms4R3d4SFBjcHcvR0xZd1VRZ3RYbTlyV3VJeC91ek9TLzN1M2tjMVI1cnFFUVBXdzY3dUI0QTRSZ3RZbWRmdnB6SCtpYTdYMlJLbEFmellHdW9MNlRRdlRxUkFVSXdacDQ5cDRaNXcxK3BpdVQ3NkkzWVJuTmcyNDE3Znh6cHUxWDJ3MGlCR3VjYkhxdis5R3VqUHV0YnR0ZFpGanVSaHJLOXRNUDNwOE1BQ0ZZWTJDZG5ZZE9uVEZuOEN1RzVXZE0yN3M2WmJ1N2FSNzA1bVFHQ01GS2VEai9mY3Y5UXBmbDlsSjRma0VWYUZ2YTlsNGN5K0U4Z2pVWkt0T1ovSmswZ1Y2U3N0d2JxUkk5VGZPZ0VzSnpITEJzLzlEeDVoTW51c05zeFBUekIwOXJHVmhVbFI1QVdLYXV3eHpwakRsRFp5Qlk2TW5EUmFOVUt1T2RoV0NodHlCdmRBOTNyRmp4WGdRTFBYbDN2TE1SckhGMFoybEFudnRYcmUyOS80S2djYlM3RE1FYVJ4OVlGcERKWUxtTEdzQ3kzSjhqV0FoVzRtQkJHeEtDaFdDaFlpRllDQmI2RkFZTHB2QVFMQVFMd1VLdzJnUXN5NzBVd1VLd0VDd0VxMDJTOTR4N0dZSTFqajU3Y1VCdTMxR2VrUDc0azFVRUN6MTVYN1doTkpya2ZTV0NoWTVnb2JjSldKWjdPWUtGbmpoWXNOWVR3VUpIc0hCVTJCNmpRdFB5Zm9sZ1lSMHIrYllaQkF2QmFzMWNvWGNsZ29WZ0lWZ0lWcHRNNmRqZXJ4QXNCQXZCaWk0eDRtNUdlcTFIOGR4UjEwU3dScDI4WDlXV1lDa2dmUHJjMTQ3TDV3Ri9ubXM4WG1nNmJzSzVUaEJlMTlTQU5SMEVhL0tEcGQxczAvR2JuOXZpdWFNLzk1dU9NeGpsT2JZdjRCVFh0Z1AxT21NQTF1U2RLL1JXdFFkWWpvQklLQTg4Tnlnc1J2aW9ucHVPeHg1VDdHY3ZoQytkOVVnUFZhcWVIRCtIcVpXRVQ1eGpBR2ppZFhybmNnZ2pLdWtnV0pNSExKbEgwUnZmQXpjL0sxV29JR0R5K00vMGVNcm1jTUR2NkQrT3d1V3hjeGhJT1kvMFVyRE9uZWZ4djhseXVBejZDTmRPT3k3L0djNjNmSHFlQnBmRFgzOHF3VFdxS1IzTFd6Mnh3UXJ6SFYvY2ZISGpwY3BZbmxBcGx5dFV4bWRRd1BFVVBNOTRYSWtBeXJrVUxBckx6SGxLMVJnb05yOW1Xb1JIUTd4ZTM2SUNtVGxBUVp4UFZTNVVMaitTOENOWXcrUll0bmYxMklMbHhQanhvSEpVeUFwRG53MHFKWnhDMVEzblVZZ01DbFVLd01xd1RjMllncGw4Z3pPYXNGTUZtbGNndmFCS0VpQkhQZ1pjQ1dYWXBJL25MU3lRdm9VK2c2dEhHem1hcUZnVEN5eHp1QnN6ekFpTUg0c20zeHlzZ0lXeGxNWHpKeDc2QkVRVUtsQXRCbzRsMU11V3VaTFBBT21kcTVKOUkrc0x4Wk1oVHlnaUhTbjJEUVJrMWlLZnpGcFFZQ0UwelBPY3FhRmFvOHl4MXJRV0xCMGF4Mi9ZQVU1VHBwamNCWDdmdy81T0E4am1vWXNCQkdGUXFKWWhjaXNHaFR3bVFwb0VCNUoyQmxlT1EyU0lVb1U2UngyRFJMK1hoczQrcWxhekZnU3NQR0dHNVluNDk0dmxockVDUzB1NjAvcUlUdDZnTUJ6NklXU21EaDhva3doWkhDYjV2Q0JBY3ZseFNOUlpRaS9MQ0NxNVQrdmhEYTZaazQvcTlVeWhaaEo4SXl2Q1pnNFMrQUw1d1h5Ui9EdCsvSDhJQkNzdWVmOTF5OEJTNFVVTGcyS0lMMGRZcG5aempURFV5ZHpIWXlPN01BektrU0FES005SGRaQ0VpNUNXWXVHd3dJNGI0cHJzZlBFZVFMRjZjcXF3eWlCcktEZUFzNUpFbHA4UGNKMHpUMEdrM25zeTRSREJPbG13UWtYeUkrcGhzaUcrR3ZIeFFxVU1leXA4c2R6SjBlRnlSY2lTTU9uSnZJQktsaVBrZGFVRExITTVMQkthZE02UERBNWtIaWJENWprNUdZWTlrWmY1VFZOQkNGWXpXR25iVzVzNFdHWldoVUExbWxQaDBBaEhYcnllSkVkalJrT3R5SkFLeEhJbm5xeXp1cFFNZjBLOUdJU1dTeTVkRzVBcnI2Vko5M3lYZ1dEWWVmNzZscWhiMmFLV0JYRE44eGhZRExLNVFyMWtnZy9INk9QU3l3T3llbU9ST0V2NGxJK3AxYzhRckhFQVM0MmVDdVQraHlxa1FEODc4S0RJWGY0ODVCTHk2aHMxMWdLNzluY2xscy8wNUFKUlFwQlRObHd4MHJhbkt1d0NMSHRKZ2R6N1lJVWNIYXlUZWwzOUkrRzU2eFB5NkorclpOSHlRS21YVUI2QTdCeUFpaWJuVU52cUVjb0ZNSzNiWENJdnZsSWpwWEwwZzRQMy9kU3pOWExSRlVXZWkwRzRuRHQ2c09aUEVyQ3l6Y243dXBhRVFnbldnNCtkV044MHdIRGszVHJaZW5lSmx3TmtTSVE4eWxZak54a2lMMXRiSkcrOEdRVXF6Z2FINnVTYUc0cE10VXlSOEJ0VTNmaFVqOGVxN2FDY1VGYlk5OWNxcVI3bjdib2VJWnR1TGJFOHJEZUhZSTBaV1BxUTNHQmdWVWIwQm1zMVFwNTh0c3B1dE9rb21BeHRYdSt5ZFVYeTlydjFKakNMSmE0c2piQjVWTDJ1dTZrRTIwUXpUekdZeENqUzVzbjRuc2NyN0xWMUs1VzRzcFlyemRmYmNITTVFYkJtTHk2UTIzZFVKcVR2RzhGaWlteFRkNE8vUGxtdzlDSWlkVjJ4S3ZRRzNibXpIT1l2RzdhV3lCUFBWSWxmYUlZTGJuUTZHMDJzd1djdDhNbXpMMFFKZU9kb25XeWsxK0pBZStRWGF3cE16WFI3NVdDTkxMZzRZS1VLTlFMbDZuZm5mZVZJNklNd3V2V1BKVDRLcGVmTy9VbUI3SDJpeXQ2L3RNUC9xNVBGUHd1d1FEcG1ZR1dqTFMyTllOMnhzeElPOVdWeGN0SHlBdHZTV1ZjYVVKN050NVhVOEY0NEFBUy9rd2JLZFNrTmkvb2dBUjRYcnZESjRmOHFBQUdjbTdhVmVlbEJLeHY4bUFMK3Z5UDFablhMeWxFbXo2Vm16dWR3eWZkWW9mK3NiZmRYRUt4aHdJSnZ0MDBPckl5N2kxVzR3M0RvUjBJaEI2c2NqcjUwSmVxTFVhTG4vMTFUaFV1aExxQnc0ZlhvMCsxL3FzU1VNdmp6bTdkRmxRaXVad2lvNUZUT0F3L1RFRmhYNFhRdnpiT01zTjRXc0tJc25IOHVUZkpYYnl3eE5aUDJ6Ly9VRUt6aGNpekwvMDF5WUZrQVZoQ09DdUVGbWhXckxHcEZXZzRsbnErNXZoaTVjWkFvd3o5T3dyZmc0Z0lMUVdGaW5pZms4dlhGRUNRZEtyanUwcFZVamQ2dVI5UnQyWlZCV04rQzZacVhYcXRGUXVDYTYzbElOV3pWbjhXbmp1QnZYUExxUVhVOXVQYlNsVVVFYTB6QVltMithdnBtZDR4aTlXaUtKYXZZVXBWQUJhUlZRMFhpSll3MW00cVJmT3pWTitxcXdLb1hXMFU5RElCOVFic2VoTkJydHZBd0IrQmRkVjJSd1J0ZWorWmhxdWJtaXpsSWowOGQwWkZraXFyWGdlZHJUZUFqV0RFNWx1My9Oakd3dWhoWTBhTG83cGprdlRrVUtpRHVlMGlGSmpBSWZWS05icnVuSEJtaHdVM1dWU282TmNUQmV1eUpCc1hjVVFuYmIyN2RYb3BjRDE1TE5SR3FxajRyc0ZLd3VpbGdEKzFUMTRNUjQ5ck5KUndWdGhvc1VLeTAzbnQrakJ4TG56TTBRdFVxa0J2dml1WkZFS29rZ1BmdmlVSUgxdzZuWWh3VkF0TUNEc1B4bThvZHV4K3JoT2ZwYWdyWEJhaE5yUkFybFJTT2RkdDVwbHpyTmhmSm52MFY4dkQrS3RuMVNJVW0vMFdzWThVbjc5Y21EMVpXemRQRmdkV1QwN3RCTmNXaXZwYmV1SUwyV2I5K3VLNlZMcUtRTUxDeTBkRWdoSzZVaElQK0RoUlNMeE04dEsvQ3BvWEFuLzVIbzVxVitYVnNYanlGNjdCOHdlR0YxUlFVVnpQME1lTkYvak1nV0xFNTFuVUo1MWhLT1FDczNjTWs3M3J4VTdZSmd5OWZGWkMzajJvSk4zMitmSFhBemdjbzlQenJqN3NxNGVzWXRoZkNCV0NrUmE4N3dGSnBDSitHZUQwOVg0SmlLS2dsNi9NUy9mSnBTelFNaWtKcU4rdWhkMW12RnMvamdsSFBHYUppaldCS3g3Q0RzQVlVT3lyVTFJcTdGNDRNWThHaXh4cEJnR3ZkemhUR0V6MVpyb0RNRFRzUjRMM0VnU1duaXlENWorWkx4UmdGOUZYNWdWNjNTNXNFVDZJZkN4VnJKR0JsVlZFekxoVEtBcXJldFhsTXhWckZSNW9Ibm85SnhHM1pSY29CVFVzWWJGNkZ2MzFuSTFqVkVPclhEeldBdGFtb0RRYTBwa0U1YW1XbEJ6RmFUS2dmQzhFYVFlVmRYd1BZRkFwM2xNUEZDbzFReFlMMXJneUZVUG11TklQRkt1UnVHSzdNc0RlTEovRjM3SXhUTEI3ZW1zRGFYSXdNQk1KNm5Kd2xFQzA2RUFwNWo5Zm9GMVlnV0NjSVZrOEVyT0ZEb2F4ek5VNHlyMXhmWW9WUHZRaTVaQ1dFS0RjK2ViZjlTRSs5WENzb2k3QjMzaHNGaTVVdnhHdnB4VkdvY2EzZlVtb1laVkxQcVdJdUtOWFNsUVh5YXdyZzJrMGxWdEJkdkNKQXNHTExEZTZHNUJ2OWNxSVROSzdjc0tPaUxhendHNVoyeFl3S0Q5VmlwNGNrV1B5bTg1eXBSM1NsaGozc3cveU5CTHN4WjVOcXFpdXEzZ1lFU3FpWEtLQUdkdHYyTWhaSXh3SXNVeTZDR0thN1FlVll6WjBMY01OamsyM0lhU3lhTDkxVGlmd095Z1ZtdHFBdGhHajJ4cEhrOWwyVlVJMzJhc1ZUT2NxTUZtMExrWm9iSFB2TDA4a1dTQ2Z0SkxUbGJteE5vMTlXaHNKS2t5cWs5WlhNRFQxWCtzMVdSVXVlMzZ5L29SanBiSUJReG01OFRvVytIZzBxdVBiZi94a05kOWZmb2dxMGpWVit5T0hVKzlMYmY5VDZ4Z012NEpUT3VJT1ZIazZ4c3I3V0RLaEtEL012anZaUkFRZ2J0NWI1UWxSNmN5KytNb2cwK0lXVHlvNUszRTB0aVo4Zk0ybDl4VFdxeFdiOWxpaW9yOUZrSHJvc0RGMVJzNm9rQXF1aTlmZUhrOURIV3FXVE1GaHF6YURmTktXaTUxaUdYQm9teWdSd0RNSlVwUnBWcEhNSGVIY0JxM3BiMFVsbDJXT2xsRTlUR1JvK04yeU5VVGkySEl6blpBTU12SWJ1aG8zRlNBdDB1T2lWdnM5VjEwWW5yZUc5bU5nMkV3K1c3VjZmckdJNTJ0SXZPMlpVS0VPaHJWZm9BOVpIN21rdE03d0FXbUl3R1hMbE0zMzh3MzNsQ0h5dnZGNG5BOHQ4c1lnVkt1WUJBN0Z2d0tWaEt4cFdkejFjQ1ZjSG1VS0ZIdjFMSmRKZ0NEMWhmUU9pWEJFdWZ1WG54amI2T1FqVzJJSjEzRkRJSjZzWHJlQ2RtZnJFTTl5OEEvK29rUjhNK0FJc3BVZ0xsd2VSOENiUGhTVmFxdXZUYStwaFovVXdLTFRhV3I4N2hRV09IWG1uSG1tTGZtUi9oWVc5Y1BrOVZiKzdINGhPanI5RncrQ1AyWW9kWFA0MU5tRHBxNXNid0FMVmVQT3RPbm5sWUowYyttK2Q5VlkxTG1BQVVQNzljbzBzdW9Tdkcwd0xaWkVkQy9BemhMOVNLZm8zVUZUZC83Y3FlZVRQVlhMd2NIVDFEZ0J4MTcxOE1RVXJUVmhjc2RpeWZQcjh6cDJWa1YvdnZqS3VoRDRHV0pTRlRTMWIvcFVld2ZJdmVjUGdSb0pTTWVXeC9NanVOUHIrb0hjL1VHbGEremZjcWg5UUw3N1VTeXo1MHVZUzVmV2cxNnR3QXZjWXloSjdIcThtdHBVUmduVXlvOEtzZjF5dzJPSlNtaER2ZjZwS0xya3E0R1dEY0svUTVzMDNkSlhZUUVlTU1ESWJibTBoSk9PZ1J2cThwRnFxcjQzNmJMN3Z3eFcvS2JMVzQrR3VCNlBLbS81UVRuVHpOUVJycEhzM2lBSWo5SjFERVJFcTZ2eFIrS1lTVzV6Z0xOVTMzRGk1cGV0cjZMV2dzeE5DNkV1djFXbENYbVhyL3ZvV3l1c0cya1llZnJqN1RVcmtaSEoxdFJ3dHdtSllhQ3A4L3NVYWVaa09EbUNsTml4VjYxdWc3ZWlIaW5XOGNzUG1sbTlqWkdwYkZZV2h6V25lTXl1UjhLSlh6RU5sYWloMGFrdjNlZStXQ3J1eWp5dmNDc2tXZ3dkYnE4WW5PQkpFc0VhNW81KyttMS9FVzd4dGR6cmNqRTF0djgwN1JDVTAwUlhSUmxic0hSR0NwYlpWd24zZVJ6SXE5SDQzZG51UWptVC8wYVMrYUVEc3F5VmRoajVUMzc4cnE5WWxob3RaYlIzRzFyMVgyTjkwK2VyU2hIU1ltMjBQc01iSnBYS2xSZEV6YmF0OXU1cGQzN3BTYlJDSFh5Q0FZQTBQbDlPWWh6WEExZmdsQVE1K004Vkpqd290OTRhcEFaYVcwRWMzcDlYYWJCcnJaZG1wcTFZSTFrbU9GazNIajdUM3FJS3BINFVLRlF2Qkd0Rm9zYW52cXVINEZJY3FnUnhyeTVUOElzd3hMWDhjdzUybEFkdkNhU0w2d2NNMUJHczAzOU9USG9jdndKd0NkYXdwREJaK2RXOHJ3Zm85Z29WZ0lWZ0lWcHQwTjFqdWpRZ1dnb1ZnSVZnSUZ2clVMamZjaEdDaHQ2SkFpbUNoSTFqbzdmTXQ5amNqV09nSUZqcUNoVDZGVzVOVHRyY1Z3Y0k2Vmd2V0ZTSllDRlpyNWdwdlFiQVFMQVFMd1VLdzBLZjBTbWp2VmdRTHdVS3dFS3kyQVF2cldBZ1c5cndqV0cwRFZndSsvUXNkd1RKdDcyb0VDOEZxQVZqK0pRZ1dkcENPMnZzdmFKalN5YmpuSUZqb2lYdlhiTytMQ0JaNnN0c1gyUDVmTzVJMEJBdWRRbFZOOVE5MUlsam9DZXlCNGRkTXgzL05zUDF0blhQeW4rOUkyb3hNL3N4VTFsc0tqZlNHN1Q1RFg3Q01IL3l4bmQ2TVF6MjJPNjB0ZlU3K0c5UFBIenl0NDh0UHZyOWpMRzNhdEQzdm05N3ZudDZkYzg4MU11NWxLY3ZiVHFYeVpRUktBOHZ4WHVwQVN3aTQzcmMrTkdQTzBCbEd4bmRTdHJlT0t0d2VxbkJIRVN5MGxwajV3eU1mVDJXOHN5aHNGOEJjaytHNFR4bU9YMFN3MEZwZ2Q1enkzVm41ejNYM3V6Mkc1ZjRjRXNTMDdiMUlIK3NJRmxyaTF0bDU2TlFaY3dhL1lsaCtoaXJjR3Fwd0Q1cTIrdzZDaGRZU08rczg5Mk1weS8xMnQrMHVvcUJ0b01xMjEzVGNJUVFMclNYMm5abEhQZ0g1Vzdmai9naSs4b3dDdDkrMFBSZkJRbXVOd3MxODU1TXpNdDcwYnN1N0VQWW1wOEE5UVcrMmoyQ2h0Y0xlazVwNzlOTXdOZEdkOFM2Q1RjUmdoRW9WTGtDdzBKSzNGU3ZlQzVYbXJreSt5N1Q5bjhKcVg1aGhHRTFKQk1GQ08yWkpKRFY3NkxQZC9Ya0RHdHdvY0xkUmhmdjdpVXhwSVZob2FHaG9hR2hvYUdob2FHaG9hR2hvYUdob2FHaG9hR2hvYUdoVDBmNFA4S1VoYUNuTlJRY0FBQUFBU1VWT1JLNUNZSUk9XCJcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL3NyYy9hc3NldHMvaW1hZ2V2aWV3L3N1ZmZpeC9kb2N4LnBuZ1xuLy8gbW9kdWxlIGlkID0gMTAzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///103\n");

/***/ }),
/* 104 */
/***/ (function(module, exports) {

eval("module.exports = \"data:image/png;base64,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\"\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvYXNzZXRzL2ltYWdldmlldy9zdWZmaXgvcGRmLnBuZz8xYjk0Il0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBLGlDQUFpQyIsImZpbGUiOiIxMDQuanMiLCJzb3VyY2VzQ29udGVudCI6WyJtb2R1bGUuZXhwb3J0cyA9IFwiZGF0YTppbWFnZS9wbmc7YmFzZTY0LGlWQk9SdzBLR2dvQUFBQU5TVWhFVWdBQUFKWUFBQUNXQ0FZQUFBQThBWEhpQUFBUmYwbEVRVlI0WHUyZGVaQWMxWDNIdjYvbjNITm1oSTZWTEdtRlRyVGJqVWs1UlFLR0NqZzIyS21VN2RoeEhDY3BZbU53Q0VjTXNZT0pMUTZCQkhZY2JEREVOd1RLSmtXY2xMRWhrR0RIRlZ3NEpKWlRKTTdxUktEb1FrTDM3dXd4TTkwei9WS3ZaM1puWjVuUmUvMTJlbVozNXRmL3FGYnYvZDd4N2MvOGZ1L3FiZ2E2U0lFQUZHQUJsRWxGa2dJZ3NBaUNRQlFnc0FLUmxRb2xzSWlCUUJRZ3NBS1JsUW9sc0lpQlFCUWdzQUtSbFFvbHNJaUJRQlFnc0FLUmxRb2xzSWlCUUJRZ3NDU3ljdkRRYUhSb25RdkQ1SURGQUJPQUJXQXQyRmtXbURsK2tiVE5Dd081YS9PZ1VBSnIyazJhd05BS0p4YXlPSGRORG00eU1BSFFBQmlpdnU4bGdlVmJzbmx2TUlJZEM0d3dNMTNtV3R6Z0poY0FjWnpQR0hycTFqa0NxMjVTenJtQ09JNTBqa1JPRFhBWXBnRnVjUU1pbkprTVdCWjRZd21zd0NVT3ZBSU9IaDZMYmw5WDhNWkIzR0xnSnBqbmhkYWNkUndVWk1zSXJDRFZyWC9aR2V4WWFjZGNpM1BtallNQUprQWFBR09SK3RjMml4SUpyRm1JRjZCcEdydk9LWVR6bHNHWTZZMkR1SmlKTVRFTzZnNncydm9WVFdEVlQwdWRrc1E0S0IwNVBlaUNsY1pCM21CYWpJT1c2cFEzWjJ3SXJNYmNpdUk0YU9mNkFzUUFlbW9jWkRaMUhCUmsxd21zK3F1YndjNStPMVl3T1Rjc0R0ZGJVR1RBeGprM0RxcC8xOHNsRWxqNjZxYXhaMkVoYkp0R1NBQWt4a0hlWUhyK2pJUDB1eTYzSkxCVU5QcGxWem9TR25EQkxRUEZ3YlNZalFIb2sxdTNhUTRDUzM3amgyUGIvd1hBbGZLY2xHTktBUUpMRGdPQkpkZG9aZzdPTVFyR1gvWnZxVzdCd0Z5QUZ3QldBT0J5RHZGdmdZRzd4ZjhycHZIUzMwejh6Y28ySEhEaG9tQUFCYzdLTnJ4VXJnR0RBM3l2YTNjOWw4SzV3K290Zzlyalh3U1dIMGxiTDYvNGtSakFkUW5iL0R2VjNpbWRiaUN3Vk9WczRYd2NIR0MvbjdRSHY2ZlNTd0pMUlNYSzR5bkFnU1BKM09CeUJzWmxraEJZTW9VMDAwTm1IR3hCU05ONmJwaTUrMjI0QjUyS3hoZ0ZkbWx2ZnZCbnNoWVNXREtGTk5NN2Y3QVNrWGZYNzNpWFpqTm1aWmJiY2dMWkxjY3J5bUF1dnlyaFdOK1JGVXhneVJUU1RHOVZzTGpMUHBaeUJoK1R5VUpneVJUU1RDZXdGSVNqV2FHQ1NET3l0REJZVjZlY3diK1ZLVUllUzZhUVpqcUJwU0FjZVN3RmtkckdZL0dQcHh6clVaa2k1TEZrQ21tbXQ2N0hxaTlZendPNFFsUGp0alFqc0JSdSszQnNPNEdsb05QMExLMEtGbHgrVGRLeEhwSEpvUm9LQ1N5WmttMHl4aUt3ZklKUTcreXQ2N0Z3YmRJeHZ5M1RpenlXVENITmRBSkxRVGdhWXltSTFEYWhFSjlJT3VhM1pJcVF4NUlwcEpuZXdoNkx3Tkprb2k1bXJRc1crNU9rTS9oTm1VamtzV1FLYWFZVFdBckMwUmhMUWFTMkdXT3g2NUxPNERka2lwREhraW1rbWQ3Q0hvdkEwbVNpTG1hdEN4Yi8wNlJqZlYwbUVua3NtVUthNlFTV2duQTB4bElRcVczR1dQejZwR045VGFhSW9zY2EraEhBM2lVcmpOTExDclN3eHlLd21nbDZxNExGWE55UWNNeXZ5clFsanlWVFNET2R3RklRYmpoR29WQkJwb29zc3dHTER4ZVErK3VUNEljY1JLNUpJWHhwbDkvcTY1Sy8rbk9GdURIaG1IOGpxNEE4bGt3aHpYUnRzSEljWTIvZmg4TDI3RlROOFZzWElYYjNZczJXNkpzUldQcmFCV2FwQzFidWE2ZVF2ZVdOeW5ZWlFNK2U5VEJXTlBhTjR6WEF1aW5obUEvTGhDT1BKVk5JTTEwWHJGRnpMOXhYYmEvV3lQdDdrWDl4SFB4VUFSM2ZYSWJvVlNuTjF1aVpFVmg2dWdWcXBRTlc0Yjh6R0x0bzMxUzd1cDVhaWV4ZHgxSDRaUmF4ellzUi84eWlRTnM4czNBQ3E2RnlxMVdtQTFidUs2ZVF2YlVVQmtOQTR0UUFSdCs2Ris0QkIvSDcreEM3NFJ5MXl1dVVxeXBZWUgrV3lBMCtKS3VDUXFGTUljMTBIYkF5Tnh5Ri9jaHByMGJqdkJoNlhseU5rY1c3dkJkVGRUNjV3Z3VOamJ3SXJFYXFyVmlYRGxnVDd6MEE1MGRqWGczaDkvUWdkblVLNHg4NjZQM2QrL3A1WU9jMDluMWIxY0hpbjB6a3JLL0laQ0NQSlZOSU0xMEhyTEczdlliQ2p1SXlRL1NqS2ZDc0MrZkpFUmdySStoNVpiMW1TL1RObWdwVzlOb1VqQ1dWMDJET09URHFncWRkaU1VKzkzZ2VoWmNtM3R6RGJnUHhteGRXN1RrZkthRHdTZzd1bmh6Yy9aVnZsYXN3aURCZmcxb3h5OHIvZEZ4ZmJVVkxIYkJHKy9mQVBaYjNhb2o4YmkrY1owYUJIRWYwNmhRNnZocjhKeGFWQnUvZ055ZHkxb015R1ZROTFvOEI5czVxaGZWc1d3UGovTGlzSGhSZXptTGlJd2U5Z2Vqa3haYUYwYnR2ZzlSV3JFQm5OaDJEOC9jalZlRk1uTndvTFdNeVErNitFOGh1cm54TG5iS3hqNHc2WUtVWDdnSWZjNHUxaEFFVUdVUG45MWNpOGx1TmZ6dGdEWS9WR0xDNnQ2MUJTQUVzSVpEN21vMnhpMTd6UEptNGpHVVI5T3hUZC9INW40eGgvQU1IdlYveEZKdzlCbnBQcUlPVnZlOEVjbk1VckpIZW5ZQmQrZDVZOFI3VDNnTWJnSWlTRC9DQnZqeHJOYkE0Y0VzcVp6NGdzMVpxN1hCc3FLYkhtZzZXKzBZZTd0NWN1YzRRUS9odEhVQ3NYSTI0cWVMbVZnTkxqQy80YWZFTy9OSVZZUWovU3FWOWR1dHg1TzRwMm91THpRQ3JzRHNIZnFMMFU2L1NlK2U3STdBZlB5UFRaZGJwT2g1cnBHY240RlNDRmJ0bEllTDNMWmwxZTNRS2FDcFkwME9oL2EwenlOeDBwS0lQYkhrWVBTK3VBVnNxZkR2QUR6aEliM2lsQ01XTVVDaThVZjY1MFFwN1kxVUUzVDlkRGJha2FDKzhWWHJWSHZBekpRQzdEVXdQaFJOL2ZMaDZ5TlJSZGhZMk9tQ2xrenZCczlQQWlySGlWazVmcWUremFJK09hUTJ3L2p5Vk03OHNLMi9XSGtzR2xtaEEvUGJGaUgydXRHck1nWkh1SFJBZjUxQUJTOWlIcit4RzF3LzdwL3FTdmUwTjVCNDRWZnk3bGNCYXNodGkwako1TmROYmViL2hLbTlONXNEY0FTdDIwem1JZjdIOG9iRDAwdDJleDFFRlMzU3laK2M2R0t1am51YjVaMGFuMW5mbUtsaGRQK2hIK04zK3ZqS2NYcmtiL0hnSnJFNkczbGMyZ0MxczdOclZkRStVdmVjNGNsdkx3dzR2NGdDZlN1WE1MODBKajFVaHNzUGhqU1VVUStGa0J6cWZXSUhJQjRzcno5UEQ2VndGeTI4b3pEMXdFdG5ianBYdmx3RWtUZzhBY2FXZ0lydlBXdWsxUEZiandjby9PNHJjZzZVUUpjQlpFRUxrOXhLSWZLQzhGWkgvNTFHTS8wNXhOZG1QeDRwL3ZnK3htMHQ3WlJNY0l3dUtjTTRFNjJ3S1pxNC9BdnZSNEFmdW9nMSt3Q3BzbThEWTVmdkZON2dxbXQvMXI2c1F2cVE1aC94cWgwTDI2VlJ1OEg0WnFVby9oN1BOQ2xYWHNTWWJNbmJaUGhUK00rTWZyRTJMRWR0VTN0MGY2U3FPMCtZN1dHSVdQUHJXVjZ2T1pHT2ZYb2o0bHViTUNPY1BXQTVINXBOSEt6eUdMNCsxZVRGaWs4ZEd4QVNnWThmODkxZ3VNSDdGZnVSL1ZuMG5RQnpzRTdOQ0dETC9FRXg2dFZBSWp0dVN0dmtGV1kyQmV5eCtPTzhkVmhNRFFYZGY4UURiNU9VSHJJNzcreEF0SFJ2aEp3dElMOTlkRmF6NXROeVF1L000c2w4b0Q0Nk53WmkzbkRKNTBNOExxZDliZ2NoN0czdXFZZkwrTkJXczZRdWs5cmRQSTNQalVSbk1VK2t6Vjk0blBuZ1F6ck9WNjFpVG1idWU2MGY0SGNWWlZ1RVhHWXhkV2p3UU4zT0JOUFBSdzdDZnJMTDFvOXlxK21TVWpiR2NwOU9ZK1BBaGI1cmxYYjBHZXY5ckxaeG4wc2g4cW53ME9menJuZWg2NGR6Nk5NcG5LZFhCWW4rWnRBYy9MeXRLMVdQVmZHQlZaUjJyVmlPVVBWYVBnY1RoODZaVzhITVBuVUwyTDByaXo4TjFMTytrNkcvOFg4WDJUZGV6cXhEK3pTNGc3V0trZnplUUtRL2tteldJYjNtd09oNVlpdWgxQzZiNEhQM1ZWK0Z1TDIwZHpUT3d4UGYvdlAzU1U5TVdRait6Q1BITjVhZHdaczVleGVOZlhUOWVKWE1TZFU5dkdiQ3l0eDlENGVmRkdhTzR4SFpPNUNOSmhDOHZUN256ejQ5aC9IMEh5aUxPSTdERW92RFlKZnU4emZqSnk5dFZlS3EvWW9EdXJkTlpleXM4V3NjamIwSDBENU4xaCtkc0JkWUE2N05KZS9BK1dVTm1IUXJyT2NhU05WYWNpaGc3ZnkvRVp2ZmtOVy9HV0RiSCtEdjNJNyt0ZkM0dGRFRWMzUytzcnJvSW1yM2pHSEovZGJMY3oyUUlQVU5yd1JZMWJ0K3dMY0FxN013aDh3ZUhJRTR2VEwvbUJWZ094OFJWaCtFOGxTNkRJazZGdnJTbTlwYk5CRWQ2L1I2SUdmQ1VkN3U4RzJJU0F5VjNJUHVaeXRPYkNsYkgxNWZCV0ZQYXcvdW5NZVFlTFAvS1pFMFhaN2pGUXdKbnUvalJQUEl2ak1OK2ZQaE5LOVBDam5VWTZIeDY1VlFSdVh0UEl2OXZ4WFBqemJ5bVpvVXVrUG5FNjdDL096ek4reGpvL3ZjMVU3clZhcWZ6bldGTVhQdDZSWElqSHdOcktsak52SGx6dVc2eGF1NGRyLzU1Qm9YL0xUOHU3LzBZK3NKZ01RYjNrQU9VRG93cTk0VUJrZC91OGFBMDFzUmdySXNpdENFMmRTeEp1UnlGak5VMm9jSDU1NUsyZGEvTVhNbXAwa3RCWkRJMlA1MGxRd2haY1lRdjZrVG9zazZFTCsrZWRjaXM3ckVJck9iZjdXa3RZSEdHMElXZC90cmtjTzk0a1h1NlVEeFptNi9jcEQ1YlljS2p4Yi9VaDhpVittZmxDU3gvdDZ2eHVhTU1YVS8zSTN6WkxFNHE1RGd5dDFUdXRVNTJoQ1VNOEpFcU1kVUFPaDVhaXVqSHkydUFmanBmQTZ4TlNkdmFLaXVIUXFGTW9kbW1oeG5FT3hqQzcvSjM2SzlXdGZZVHc4amVlQlE4TXcya1RvYU9MWDFBbHdHeFZaUi9mblRxQ1I4eGcrejZ5YmtJWCt6VFc5WTRRUXJPQ2F6Wk1qRnIrekJENXhQTEVYbGZmVGVSeFNOMEUzOTB5TnN6blg2SnhkYjQ1aVV3Rm9XUnVlME5PUDlRM0RQVmZlOERlYXhaRXhCQUFSRldQSm53SHYweHpsbGI1UUs1TDU5RTd0NFQ0T09WWVZBYzRUYVdSNUQvbjR5Mzl5amJFSzlWRDRFVkFCZXpMYkxqNGFXSVhxTTN0dkZUdDNqVUxYdm5jZGlQbmFtNmRHR3NpcUpuKzFvZ3JEVHFxYWk2NmdPckhMY25iSE9MckkxS3RkRnlnMHpHTjZkN2cvVXI2ak91VXFsZGhFZm4wVFBJUFhwbTZqU3FzU1NNemgvMlEyd2Q2VndFbG81cUFkczBHcXlwN3JpQXU5OEduM0FSR29qUDZ2UXBnUlV3SkRyRk53MHNuY2JXc0trQjFoMEoyN3hIVmcyRlFwbENtdWtFbG9Kd05NWlNFR2xHRmdKTFFUTUNTMEVrQXF0Q0FRcUYvcGxSc21oZGo4WHVUTmlEZDh0RUlMQmtDbW1tRTFnS3dsRW9WQkNwYlVJaGVTei9OTlRSb29VOTFsMEplM0N6VENvS2hUS0ZOTk1KTEFYaEtCUXFpTlErb1pBOGxuOGM2bWRCSGt0QlMvSllDaUsxaWNmaW5HOU8yZFpkTWtWb2pDVlRTRE85VlQwV2dhVUpSTDNNQ0N3RkpTa1VLb2pVTnFFUWQ2ZHM4MDZaSWhRS1pRcHBwcmV1eHlLd05KR29qeG1CcGFBamhVSUZrU2dVVmloQW9kQS9NMG9XTGV5eDdrblo1aDB5RVFnc21VS2E2UVNXZ25BVUNoVkVhcDlRU0I3TFB3NzFzMmhoajdVbFpadTN5NVNpVUNoVFNETzlWY0VDWjF1VDl1QW1tU3dFbGt3aHpmUldCWXR6VUNqVVpLSXVacTBLRnFOSDdPdkNoM1loclFvV3dHOU41cXd2eW9TaFVDaFRTRE85VmNGaUxtNUtPT2JETWxrSUxKbENtdW10Q2haMzJjZFN6dUJqTWxrSUxKbENtdW54clVzUXVyQkQwM3B1bURtUEQxZThSbHkweWlpRUx1N05iL3dQV1FzSkxKbENsRjVXZ01OTjJMRVV3N3J5bHhCcTZFTmdFVGpxQ25EOFk5STJQNlJpUUdDcHFFUjV4SGNWcytERzI1UE93TXNxY2hCWUtpcTFheDdPODJEc0FPZjhwWmdkLzJ3bjFoMVdsWUxBVWxYS2J6Nk9YZHpsMS9zMW13djVRMkJPSkc4Y2ptUGpZUVpXL2txVWo4WVJXRDdFOHBXVlkxdlNObi9ObDAwTFpTYXdncnFaQkpaYzJYUjQ2R0xYWUpkd2NBdGdGZ01mQUdNUnVXVWI1eUN3L045OERoNGVpKzVjWDRCckFZWWxnR1BNZzY0NW4xdjMzNFhnTFFpcyttbk1zYnNuSFhFSE9WeUxHOXhpWUJZNHZ3Q01OZlpqeHZYcmtuNUpCSmErZHFxVzQ5aTlMQi9PV3p6RUxjNUZLSVVGWUFBTU1kVXk1bDArQXFzNXQ0eURoMGFqUSt0Y2hJcWhWSXpmbVBCd1dBM1dxSzhlQjloM0FpdEFjVFdLNWpqU21ZNmNOZ1ZzWEV3VURBallMZ0JEOEIrbTBXaHZUUk1DcTU1cUJsZldHSWFXNU1NaGk0ZGNpM0V4VVJEaGxKbGcwUHRRVEhCTkxaWk1ZQVd0Y0hEbGMzQWpIZHUxeHVVRnl5ak5Ub3ZBWVMwWWpPQnFWaWlad0ZJUWFaNWw0VGpVTVJJWkd4Q3pVME9FVktPNC9nYWdyMkZkSWJBYUpuWFRLMHBqejhKQzJMRU1NVHYxbGtKUVdvTmovcjlySytzTmdTVlRxTFhUT1RnYndkQzVSclE0TzUzY1hRRDRlakFXMHU0OWdhVXRYVXNiY3V5TkRVZnNqWVpZN0JYTElLemszY0Rlb3RSeEFrdEpKc3BVVW9EanRjUm9PR01Xd00rNlY4cFlLSzE2S0s0VnhWVTYzZENLSGFjK0Jhc0FnUldzdm0xYk9vSFZ0cmMrMkk0VFdNSHEyN2FsRTFodGUrdUQ3VGlCRmF5K2JWczZnZFcydHo3WWpoTll3ZXJidHFVVFdHMTc2NFB0T0lFVnJMNXRXL3IvQXcyNXRCNEJTbXljQUFBQUFFbEZUa1N1UW1DQ1wiXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9zcmMvYXNzZXRzL2ltYWdldmlldy9zdWZmaXgvcGRmLnBuZ1xuLy8gbW9kdWxlIGlkID0gMTA0XG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///104\n");

/***/ }),
/* 105 */
/***/ (function(module, exports) {

eval("module.exports = \"data:image/png;base64,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\"\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvYXNzZXRzL2ltYWdldmlldy9zdWZmaXgvcHB0LnBuZz9kZDc0Il0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBLGlDQUFpQyIsImZpbGUiOiIxMDUuanMiLCJzb3VyY2VzQ29udGVudCI6WyJtb2R1bGUuZXhwb3J0cyA9IFwiZGF0YTppbWFnZS9wbmc7YmFzZTY0LGlWQk9SdzBLR2dvQUFBQU5TVWhFVWdBQUFKWUFBQUNXQ0FZQUFBQThBWEhpQUFBUU4wbEVRVlI0WHUyZGU1UWNWWjNIdjdlcXVudGVQWlBwbmlFTU1lUkpTRExkRTFnVGtBMjdRZGJ3RG04MWlPR3hpTElyd1ptT252WHdoeWZ1NmpuckVzV0YzVDBteWdZaFBCWVdGVkFDUG81eVJJMWkzUFhzWnZGeGtJMUlUQ0R6ekV3bS9hcWZwN3FIbnVsT3o5emIxVlU5TmRXLytpZEozL3Y3M2QvOTNrOSs5L2J0VzFVQ2ZMRUNMaWdnWFBESkxsa0JNRmdNZ1NzS01GaXV5TXBPR1N4bXdCVUZHQ3hYWkdXbkRCWXo0SW9DREpZcnNySlRCb3NaY0VVQkJzc1ZXZGtwZzZYSUFOMkQ1bjQ5MEMyQXVDa1FFOUM2aVJDY3psd0F5WTVFOG1KRjk3NnJ4bUNWRENsdGh6RVFDYTZBaVRpWmlBR0lreEF4QVZvS0NHVzlpT2hFWnlMVjZEdGlGRHVrTEpTaXZ6bFZiZUNmY1RveW9aaXBVeHlFT0JGaVFtQTFJQUxWZG9UQnFsYkJPV0EvOUc5b3A1UVJ6NW9pQm1oeHNxWXlvalVRSXV4VytBeVdXOHJPZ2wvYWpZYWhnY0Nxckk2NElCRTN5WnJDRUlmQWdscUh3MkRWV25FSDJxUHQwRWJhUTh2U0pzVXRjQWo1dFJBSVowQUl6WUVtcW5iQllGVXRvYnNPM3JvWFhSb1pjUk42WEFpS2dSQWpnYmlBQ0xuYmNuWGVHYXpxOUhQTXV2OCt0Q0pyZEpzUWNVR2FOWDNGQURvTEVQTWNhNlNHamhpc0dvcHROVVhiRVJ4c0RaNlp6ZTBGNWI2SnhZV3dGdFZZWE9OUVhHMk93WEpKWGlLSTRSMVluTlpEMWg2UXRRNktDeXNMRVZaQ0NNT2xaajNqbHNGeVlDaEdkcUFqcVJzeEFYMGlBMUdNQ0QxQ2lHWUgzTTlKRnd4V0JjTkdPOUYwZEN5d1dwdjhXV01DSkp4YWdadTZxTXBnS1F6ejZCY3hmOXdNdlNRRUxhdmtadzBGMTc2dHdtQXBETzNnRGl6SzZxSC9WNmpLVmQ1V2dDaEZ3cHpUUDBJYkFxYWhaVjRKMzRXM0toMVlwZDhLR2F4S1pmVlpmYUtuaFpHNk0zb1gvcURhTXdaTFZhbDZyMGQ0UTlPVGZ4NzVHSDZ2SWdXRHBhSVMxOGtyUVBoK1J5SjVvWW9jREphS1NseW5vRUNEU0o3YTBvc2pNa2tZTEpsQ2RzdjFJRnF2K1paZGEwL1kwWWtCSFB2bSs0dGkwU2w3UVhzaTg2SXNRQVpMcHBETmNtRTBJbkxub0UxcmI1aVp4OS9FNEs3VGk0TXhzKy9wMkpiNW5peENCa3Vta00xeTM0S0Y3TWFPdnN4M1piSXdXREtGYkpZeldBckM4VDZXZ2tnbFZmd0tsaERaaTZLOW1lL0lGT0dNSlZQSVpqbURwU0FjWnl3Rmtlb2xZMUgyNG1naTgyMlpJcHl4WkFyWkxQZHR4bklVckh1eE9JdlFhelkxcmtzejM0SWxzcGRFZXpNdnlBWlZMV014V0RJZFR5cG5zQlFrRzJTd0ZGUXFybElKV09QN3Y0anMwRytodHk2RzNyWUV4cW5yb0xVdXFyaE5wdzNLYlpBS3lsNGFUV1NlbDdYRkdVdW1rTTN5U3NBYWZmNVdKSC8xV0ZGTHhtbm5JYlJ5TTBJcjNndlJFTEVaUlhWbURGWjErcmxpWFMxWWhhRDBJSnJXL1IwYTEzMEMwS2Q5dUkwcmZTZ0hsZ1pjRnVsTDdwVTF5QmxMcHBETjh1bkF5ZzY5aXN5Ui9RaWNkaDYwOE1LYzk5SG5iMEh5VjQvUDJKTFd0aFRoaTNiQ1dQQVhOaU9xM0l6QnFsd3oxeTJFMFlCNXR4eklRWlE5c2gvcHd5L24vazdKNFZ6YnJkZnVSZUQwZHl1RDlYYkFqV3NUYUZyL0dhQUdUeElvQzVhSnl5UGJrcy9KQk9TTUpWUElwZkx3TmM4aXVHaGpIcXk5TnlQNTYvOVFiaW13OEFLRUwzOEVvaUdxYkdPbklvTmxSN1ZadGdsZjlYVUVsMXhxQ3l6THlQcldPRy96RHlHYVRuR3RKOU5NaFZkRStwTFNnMmFjc1Z3Ymxwa2RoemM5aWVDeVRiYkJzZ3lOQmVlajdmb1hBS0c3MGdzR3l4VlozWFVhdnVKeEJKZGZuV3ZrMk42YmtQcjFFN1lhYkRqcmI5Rjh3UmRzMmNxTXlvRkZBcHM2ZTVQZmxObHl4cElwNUZKNXkyVjdFRnB4ZmRWZ1dRNm1aajhudzJXd25GU3pScjVhTG5rd3R3R2F5MWpQYlVIcU4wL2FibGtMbjQ3Mld3OEFXdFdQVGkyS29TeFloQ3M3RThsblpjRXFaYXloZTdBa1k0UitKM1BHNWVvS3RGejhBRUtyYm5RRUxNdEowL21mUWVQYWo2c0hvRkNUd1ZJUXlXdFZtamZ1UkVQM3pZNU1oVGtuMXMwYnQvOE9JdFR1V0Zlbm1RcXY2dXhOUGlOcmhET1dUQ0dYeXB2Zjh5VTB4RzV4RGl3QXpYOTFQeHJpdHpzV01ZUGxtSlMxYytRR1dNWnA2OUgyUHVtZFdjcWRMSHY3RjlIVkhZblUweklubkxGa0NybFVQaFdzU25mZVp3cXAvYmJmRm42RHJEWjBCcXRhQldmQjNpMndXamJ1UkdoaTdWWnR0OHFDQmJxbW95LzFEWmx2emxneWhWd3FMd0pMNFhTRGFoaldOMFByRzZJVEY0UGxoSW8xOXVFV1dNRmxWeUs4eWQ0dWZxa0VkUUlXNWZzOThVZnU3MWErdGY2ZHk3dEt5YmZHK0V6ZjNGU3d4bi8yajBnZGRHYlJyYzliaHBhTlgzS2tuOU9zc2E3dFNLUytMbXRBYVRTOHNFRksxdk85cDN1ckcxbFBSaVhRSElKcktsaXlRWnF0OHJvQWEwcHFLcXN6RWFDSjRvUTJXd09pMHU2Y0JRdDBYVWRmNm11eVBzNlpqQ1VEYTNLZVZPcVNUQmZYeTYyVG9JSEYrZk5ZMVY1Q0Q4SG9PcWRhTnlmWlQ3UEdxZzFZSWpRUFJtZlB5WjB5MHpDVHc2RGtVTzQ0THFYSHluWmNiMThCcmJuME1mRUVTbzlQMkE3QlBERUFtTm1pSjRHTFFBdU0rWDlXNUxPdzNKcEI0c3pobDBHWmNjY0hZVFlkR3AxcjBIYmpUeDBQb2V4ZE9pWmRIOTJXZWtyV21OSi83NW5XV0lGM2JFQ3JkZGhNY21YNy93K2ozOXVLektFZkZkVnN1V2dYUXF0dmtsZ1RrZ2NleHRoTGQ0UEdqK2JxNnAxck1NK0dtSU83dTJFT3Z5b0xkMDZWV3djR3JhTXpUbC91ZzNVdmxtWVFLanNhZ1lVYjBIcWRIS3hjcDgwTVJwKy9HY25mVEFMZmN0R1hFVnE5UlVrVGMrUWdocCs0RU9ib0d6Qk9PUXR0SDlpblpEZTEwdENEM2JEdWxQSFQxYmgyRzVyTy82empYU29MRnVpOTBiN1VmOG9hVTh0WUZZQ1ZuMnBPRk5yVldycWd6MXRlK0xjMU5RNCtjQVlvZFN6MzJWU3dLRFdDekp1L0xJclpPR1VOUkxDMThObUpBdzloN0RzZmh2VzEybG9BVDcxRXNBWEdLV2NYUHNyZEZaTStYbFRIQXRzY1BTVFRaVTZWaDY5OENzR2xsenNlOCt5Q1ZUSVZEdTVlQlhPNCtQa2g0Y3YySURoeFd0THEvZWdMSDBMeWxUMFRZRTFPaFpsRFA4NWxwQ0pZR2p2UnZ1WG5FRTN6OHgrYkdmVGYzd1pROWlRaGpmbHIwWGJEUzRYUGgvYXNSZmJvL3pvdXVLY2NDaDJSTzk2QXRkWjEraW9MbHFEM1JYdFQwbm0zK295bEFKWjFpM2prSTY4WER2MlA3L3NzanUvN0J5V3dyRXFsNTdvSGQ2K0dPWHp5dVVOai9qdlJkc1BrR3E0ZXdMSnVJYk51SlhQajhqeFlWcWNqZi9QSHdpRzBFLy85cnhqN3dUWmxzQUpMTGtYclZaT2J2VU9Qbm9mc20vL0ZHYXRrS2VFMFhPV2YzVUR2anlaUzB0K01hcEt4OU9ocXpOdnlpMEsvai8vb1V4aC8rWitVd1dyZWNBOGF6dDVhc0IvOHlyTGNBcjcwcXJlTUpScmFFYm45b0d2UGRQQWtXTmIwcDBkV0lyQmdQUnJXM0FHdFpVR0JnK0hIMXVkdU43ZXVxZHNOazJzc2tic2hVNCt1ekMxS0cySzNGVzRwTjRkZXhlQ0QzU2RCWmUyOEI3cldvbTF6L2F5eG1zNjlHNDNuZmNycFJGWHdOODFVdURuYW01TGV0bDE5eHFwa3V3RkErdlVYTWZMVTVOdldLdGx1eUMvOGIwUHlsVWZLaW1rOVY2cHQ4dzhuQWQ2ekRwbWovK09hOExQcFdHdWVuM3MyaExWUjdOWTF1MkFwYnBCYW5jOGMrVGxHdnJZSmxKeDhZNFBhQnFsbFRSai8yZWR3L01mYjh6cGFLVXFJd2dFSDY2TjYrbFk0OWI3RVdvSkZSRGQySmxLUHl0cXNQbVBKd01vbWtlay9nQk8vM0lua2dZZEt6cjBVVDRYbGdyWGU1NUwrNHo2TS8rVFRFM3RjZWFDS2pzOU1HTllMV05hTnJoWllibDlsYjZZQWZiQ3pMMVYreXBnU1VQVmdsVXlGUTd0WElWdXlqeldUQUZPbnd2U2huMkRraWZ5amZleGM5VEFWV2h2RGJSOThHY0pvc2lOUlJUYnVnelhERGF1bFAra3dXQldOWFVXVjllZ3F0Rjc3SExUbXJvcnM3Rlptc042ZUNuMjhlTGUrSGJkYytsVlhGK3VsQURKWWZnWkxDNkJwL2QrajhaMTlkaE9QYmJ1eTU3Rk0ydEt4TFNWZDRLbXRzWGdxdEQwNDFSaGFhOGFXamJ0Z1RZR3pjVEZZWHN4WVFvTWVYb2pzeU1IS21OQ0RDQzYrSlBmQWtPRHlLMmYxSnBGWkJjczZ2ZGkwWVVkQnZORzlXMkNPSFZZV3MzSGR4eEZZbE44d3RVNGlqUDNBZnNyWEkyZWkrY0ovS2JSdEhhK3A1QnVxY3RBcUZRUE5pSDYwSDNUOFRWamZkak9IZjRyTTRmM0lIbnNkNXJIWEFUT2Q4eUlhT3hIb09nZEcxN3NRNkRvM2Y4UlliMUJwd2ZVNmRQd0lCbmFWdnNqQXZLbWpMLzJ3clBHcXAwSlpBL1ZhTGdMTmlIeTBmMDUzdi95WmR3WnJWZ2ZWMm1lSzNEa3dxekZVMnppRFZhMkNMdGhYOG1ZS0Y1cDN4Q1dENVlpTXpqcXhYaUFRdVhQSVdhYzE5bFlXTEdIZTNOR2J0bjZibS9IaU5aWk1JWnZsMXIxK2thMzV0MURNMVl2Qjh1TEk2VUZFdDQ1NE1UTGxtQmdzWmFscVdGRUxJSHBYL2s2a3VYcVZmM2FEZVV0SEl2MVZXWjk0S3BRcFpMZGNhR2c4OTI2NzFvN2JHVjNuRnQ3ZG8rcWN3VkpWcW83ck5aNjlGVTBiN3FsSUFRYXJJcm5xc3pLRFZaL2o3bnF2SFFNTDVxMGRmZWtIWlFIekdrdW1rRS9LR1N5ZkRLVFh1c0ZnZVcxRTdNYWpHV2c4NTVOMnJSMjNjK3Bib1NEenI2T0o5RzVaZ0R3VnloU3lXZTdYM3dvWkxKdEFPR1hHWUNrbzZZV25KaXVFNmFrcURKYkNjREJZQ2lLVlZQRXRXREJ2aS9hbC8xMm1DSyt4WkFyWkxHZXdGSVRqaktVZ0VtZXNJZ1U0WTFYT2pKcUZIa1RyTmQ5U3ExdURXbHA0QWZTMnBSVzFWUDc1V09hSG9vbjBBekpIREpaTUlaK1VPN1ZCS29qQjhna1N6blNEd1hKR1IvWlNvZ0NEeFVpNG9vQmpZTUc4UGRxWC9vb3NTRjVqeVJUeVNUbUQ1Wk9CaE5BUVdIQytaM29UUE9QYTNFT0dLN25LdjVtQ00xWWxHanBlMTdjYnBLYjU0ZWkyOUpkbGd2RlVLRlBJWmptRHBTQWM3N3dyaUZRdk8rK2NzU3FId1VrTHpsZ0thbkxHVWhDcFRqSVd3ZnhJWjE5Nmwwd1JYbVBKRkxKWjd0ZU1SY0s4bzdNM3ZWTW1DNE1sVThobXVWL0JFcnpHc2ttRVEyWitCUXZFejI1d0NCRjdidndLbGtaMFF5U1JlbHltQ2srRk1vVnNsdnNWTEJLNHFyTTMrWXhNRmdaTHBwRE5jcitDcFZIMkx5T0p6T1M3KzZiUmg4R3lDWTdVekdNM3JFcmpMVmNoUFlieC9mY1dsUVFvR1cxTFFQclVYZ2JMbHVKMWFrUTQySkZJTGxicFBZT2xvaExYeVNrZ0NJbG9JbG1jd25ncVpEcXFVb0JvWHhTcEMwVUM0eXArT0dPcHFGUjNkU2hORUw4WHdHdEVlQTJDWGxSNXErcFVtUmdzbDZBaG9oT2RpVlNqUys0OTc1YkJjbW1JR0N3RllmbDBnNEpJSlZVWUxFWE4zcm9mcDJscEl3Ym8zU1FvQnFDYkNERWhSTE9paTdxcXhtQlZPZHlETzdDSVJLamIxQ1pnQTdwQjZCWkNlT09sZTFYMno2NDVnMlZYdVJuc2FEdTA0UWlXcE0xUXR6QW5nQk9JQ2NKS0NCRjBvVW5QdVdTd2FqZ2s5QVQwbzRkQ3l3VlJ0eURFVEtCYkFOYTB1Z0pDR0RVTXhmV21HQ3pYSlpZM1FEc1JHQmdMcm9DR21HbE5vNFFZNWFGYkRpRTB1UWZ2MVdDd3ZEY21oWWpvUG9TRzBvR1ZHVTNFUlA3TFFod1EzVUpnaVlmRHpvWEdZSGw5aE1yRTk5Ym5FTmFDUnN5RWlBdG9QUVRFQmRFYUNOSG1sZTR3V0Y0WkNRZmlPUG9GTE5CRXFNY0V4UUhrZ1FOV0FTTGdnUHVLWERCWUZjazE5eXJUZGhnRHJjRXpCUkEzQlhxczZWUkF4Q0d3eU0zZU1GaHVxdXRoMy8zM29WVmtqWGlXY3ROcG5BUjZKcWJUc0JOaE0xaE9xT2dqSC8yZngwS2hoWHBNeWsyblZtYnJRWDcvcmFMdEVBYkxSMUM0MVJWck8yUndMTGd5bTErenhRbm9BV2IrS1VzQXlZNUU4bUszWXZLNlg2WFREVjd2Qk1mblBRVVlMTytOaVM4aVlyQjhNWXplNndTRDViMHg4VVZFREpZdmh0RjduV0N3dkRjbXZvaUl3ZkxGTUhxdkV3eVc5OGJFRnhFeFdMNFlSdTkxZ3NIeTNwajRJaUlHeXhmRDZMMU9NRmplR3hOZlJQUW5WWDhISGdPdmFYUUFBQUFBU1VWT1JLNUNZSUk9XCJcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL3NyYy9hc3NldHMvaW1hZ2V2aWV3L3N1ZmZpeC9wcHQucG5nXG4vLyBtb2R1bGUgaWQgPSAxMDVcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///105\n");

/***/ }),
/* 106 */
/***/ (function(module, exports) {

eval("module.exports = \"data:image/png;base64,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\"\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvYXNzZXRzL2ltYWdldmlldy9zdWZmaXgvcHB0eC5wbmc/ZTRkYiJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSxpQ0FBaUMiLCJmaWxlIjoiMTA2LmpzIiwic291cmNlc0NvbnRlbnQiOlsibW9kdWxlLmV4cG9ydHMgPSBcImRhdGE6aW1hZ2UvcG5nO2Jhc2U2NCxpVkJPUncwS0dnb0FBQUFOU1VoRVVnQUFBSllBQUFDV0NBWUFBQUE4QVhIaUFBQVFOMGxFUVZSNFh1MmRlNVFjVlozSHY3ZXF1bnRlUFpQcG5pRU1NZVJKU0RMZEUxZ1RrQTI3UWRid0RtODFpT0d4aUxJcndabU9udlh3aHlmdTZqbnJFc1dGM1QwbXlnWWhQQllXRlZBQ1BvNXlSSTFpM1BYc1p2RnhrSTFJVENEenpFd20vYXFmcDdxSG51bE96OXpiMVZVOU5kVy8raWRKMy92NzNkLzkzazkrOS9idFcxVUNmTEVDTGlnZ1hQREpMbGtCTUZnTWdTc0tNRml1eU1wT0dTeG13QlVGR0N4WFpHV25EQll6NElvQ0RKWXJzckpUQm9zWmNFVUJCc3NWV2RrcGc2WElBTjJENW40OTBDMkF1Q2tRRTlDNmlSQ2N6bHdBeVk1RThtSkY5NzZyeG1DVkRDbHRoekVRQ2E2QWlUaVppQUdJa3hBeEFWb0tDR1c5aU9oRVp5TFY2RHRpRkR1a0xKU2l2emxWYmVDZmNUb3lvWmlwVXh5RU9CRmlRbUExSUFMVmRvVEJxbGJCT1dBLzlHOW9wNVFSejVvaUJtaHhzcVl5b2pVUUl1eFcrQXlXVzhyT2dsL2FqWWFoZ2NDcXJJNjRJQkUzeVpyQ0VJZkFnbHFIdzJEVlduRUgycVB0MEViYVE4dlNKc1V0Y0FqNXRSQUlaMEFJellFbXFuYkJZRlV0b2JzTzNyb1hYUm9aY1JONlhBaUtnUkFqZ2JpQUNMbmJjblhlR2F6cTlIUE11djgrdENKcmRKc1FjVUdhTlgzRkFEb0xFUE1jYTZTR2poaXNHb3B0TlVYYkVSeHNEWjZaemUwRjViNkp4WVd3RnRWWVhPTlFYRzJPd1hKSlhpS0k0UjFZbk5aRDFoNlF0UTZLQ3lzTEVWWkNDTU9sWmozamxzRnlZQ2hHZHFBanFSc3hBWDBpQTFHTUNEMUNpR1lIM005SkZ3eFdCY05HTzlGMGRDeXdXcHY4V1dNQ0pKeGFnWnU2cU1wZ0tReno2QmN4Zjl3TXZTUUVMYXZrWncwRjE3NnR3bUFwRE8zZ0Rpeks2cUgvVjZqS1ZkNVdnQ2hGd3B6VFAwSWJBcWFoWlY0SjM0VzNLaDFZcGQ4S0dheEtaZlZaZmFLbmhaRzZNM29YL3FEYU13WkxWYWw2cjBkNFE5T1RmeDc1R0g2dklnV0RwYUlTMThrclFQaCtSeUo1b1lvY0RKYUtTbHlub0VDRFNKN2Ewb3NqTWtrWUxKbENkc3YxSUZxditaWmRhMC9ZMFlrQkhQdm0rNHRpMFNsN1FYc2k4NklzUUFaTHBwRE5jbUUwSW5Mbm9FMXJiNWlaeDkvRTRLN1RpNE14cysvcDJKYjVuaXhDQmt1bWtNMXkzNEtGN01hT3ZzeDNaYkl3V0RLRmJKWXpXQXJDOFQ2V2drZ2xWZndLbGhEWmk2SzltZS9JRk9HTUpWUElaam1EcFNBY1p5d0ZrZW9sWTFIMjRtZ2k4MjJaSXB5eFpBclpMUGR0eG5JVXJIdXhPSXZRYXpZMXJrc3ozNElsc3BkRWV6TXZ5QVpWTFdNeFdESWRUeXBuc0JRa0cyU3dGRlFxcmxJSldPUDd2NGpzMEcraHR5NkczcllFeHFucm9MVXVxcmhOcHczS2JaQUt5bDRhVFdTZWw3WEZHVXVta00zeVNzQWFmZjVXSkgvMVdGRkx4bW5uSWJSeU0wSXIzZ3ZSRUxFWlJYVm1ERloxK3JsaVhTMVloYUQwSUpyVy9SMGExMzBDMEtkOXVJMHJmU2dIbGdaY0Z1bEw3cFUxeUJsTHBwRE44dW5BeWc2OWlzeVIvUWljZGg2MDhNS2M5OUhuYjBIeVY0L1AySkxXdGhUaGkzYkNXUEFYTmlPcTNJekJxbHd6MXkyRTBZQjV0eHpJUVpROXNoL3B3eS9uL2s3SjRWemJyZGZ1UmVEMGR5dUQ5WGJBaldzVGFGci9HYUFHVHhJb0M1YUp5eVBia3MvSkJPU01KVlBJcGZMd05jOGl1R2hqSHF5OU55UDU2LzlRYmltdzhBS0VMMzhFb2lHcWJHT25Jb05sUjdWWnRnbGY5WFVFbDF4cUN5ekx5UHJXT0cvekR5R2FUbkd0SjlOTWhWZEUrcExTZzJhY3NWd2JscGtkaHpjOWllQ3lUYmJCc2d5TkJlZWo3Zm9YQUtHNzBnc0d5eFZaM1hVYXZ1SnhCSmRmbld2azJONmJrUHIxRTdZYWJEanJiOUY4d1JkczJjcU15b0ZGQXBzNmU1UGZsTmx5eHBJcDVGSjV5MlY3RUZweGZkVmdXUTZtWmo4bncyV3duRlN6UnI1YUxua3d0d0dheTFqUGJVSHFOMC9hYmxrTG40NzJXdzhBV3RXUFRpMktvU3hZaENzN0U4bG5aY0VxWmF5aGU3QWtZNFIrSjNQRzVlb0t0Rno4QUVLcmJuUUVMTXRKMC9tZlFlUGFqNnNIb0ZDVHdWSVF5V3RWbWpmdVJFUDN6WTVNaFRrbjFzMGJ0LzhPSXRUdVdGZW5tUXF2NnV4TlBpTnJoRE9XVENHWHlwdmY4eVUweEc1eERpd0F6WDkxUHhyaXR6c1dNWVBsbUpTMWMrUUdXTVpwNjlIMlB1bWRXY3FkTEh2N0Y5SFZIWW5VMHpJbm5MRmtDcmxVUGhXc1NuZmVad3FwL2JiZkZuNkRyRFowQnF0YUJXZkIzaTJ3V2pidVJHaGk3Vlp0dDhxQ0JicW1veS8xRFpsdnpsZ3loVndxTHdKTDRYU0RhaGpXTjBQckc2SVRGNFBsaElvMTl1RVdXTUZsVnlLOHlkNHVmcWtFZFFJVzVmczk4VWZ1NzFhK3RmNmR5N3RLeWJmRytFemYzRlN3eG4vMmowZ2RkR2JScmM5YmhwYU5YM0trbjlPc3NhN3RTS1MrTG10QWFUUzhzRUZLMXZPOXAzdXJHMWxQUmlYUUhJSnJLbGl5UVpxdDhyb0FhMHBxS3FzekVhQ0o0b1EyV3dPaTB1NmNCUXQwWFVkZjZtdXlQczZaakNVRGEzS2VWT3FTVEJmWHk2MlRvSUhGK2ZOWTFWNUNEOEhvT3FkYU55ZlpUN1BHcWcxWUlqUVBSbWZQeVoweTB6Q1R3NkRrVU80NExxWEh5blpjYjE4QnJibjBNZkVFU285UDJBN0JQREVBbU5taUo0R0xRQXVNK1g5VzVMT3czSnBCNHN6aGwwR1pjY2NIWVRZZEdwMXIwSGJqVHgwUG9leGRPaVpkSDkyV2VrcldtTkovNzVuV1dJRjNiRUNyZGRoTWNtWDcvdytqMzl1S3pLRWZGZFZzdVdnWFFxdHZrbGdUa2djZXh0aExkNFBHaiticTZwMXJNTStHbUlPN3UyRU92eW9MZDA2Vld3Y0dyYU16VGwvdWczVXZsbVlRS2pzYWdZVWIwSHFkSEt4Y3A4ME1ScCsvR2NuZlRBTGZjdEdYRVZxOVJVa1RjK1FnaHArNEVPYm9HekJPT1F0dEg5aW5aRGUxMHRDRDNiRHVsUEhUMWJoMkc1ck8vNnpqWFNvTEZ1aTkwYjdVZjhvYVU4dFlGWUNWbjJwT0ZOclZXcnFnejF0ZStMYzFOUTQrY0FZb2RTejMyVlN3S0RXQ3pKdS9MSXJaT0dVTlJMQzE4Tm1KQXc5aDdEc2ZodlcxMmxvQVQ3MUVzQVhHS1djWFBzcmRGWk0rWGxUSEF0c2NQU1RUWlU2Vmg2OThDc0dsbHpzZTgreUNWVElWRHU1ZUJYTzQrUGtoNGN2MklEaHhXdExxL2VnTEgwTHlsVDBUWUUxT2habERQODVscENKWUdqdlJ2dVhuRUUzejh4K2JHZlRmM3daUTlpUWhqZmxyMFhiRFM0WFBoL2FzUmZiby96b3V1S2NjQ2gyUk85NkF0ZFoxK2lvTGxxRDNSWHRUMG5tMytveWxBSloxaTNqa0k2OFhEdjJQNy9zc2p1LzdCeVd3ckVxbDU3b0hkNitHT1h6eXVVTmovanZSZHNQa0dxNGV3TEp1SWJOdUpYUGo4anhZVnFjamYvUEh3aUcwRS8vOXJ4ajd3VFpsc0FKTExrWHJWWk9idlVPUG5vZnNtLy9GR2F0a0tlRTBYT1dmM1VEdmp5WlMwdCtNYXBLeDlPaHF6TnZ5aTBLL2ovL29VeGgvK1orVXdXcmVjQThhenQ1YXNCLzh5ckxjQXI3MHFyZU1KUnJhRWJuOW9HdlBkUEFrV05iMHAwZFdJckJnUFJyVzNBR3RaVUdCZytISDF1ZHVON2V1cWRzTmsyc3NrYnNoVTQrdXpDMUtHMkszRlc0cE40ZGV4ZUNEM1NkQlplMjhCN3JXb20xei9heXhtczY5RzQzbmZjcnBSRlh3TjgxVXVEbmFtNUxldGwxOXhxcGt1d0ZBK3ZVWE1mTFU1TnZXS3RsdXlDLzhiMFB5bFVmS2ltazlWNnB0OHc4bkFkNnpEcG1qLytPYThMUHBXR3VlbjNzMmhMVlI3TlkxdTJBcGJwQmFuYzhjK1RsR3ZyWUpsSng4WTRQYUJxbGxUUmovMmVkdy9NZmI4enBhS1VxSXdnRUg2Nk42K2xZNDliN0VXb0pGUkRkMkpsS1B5dHFzUG1QSndNb21rZWsvZ0JPLzNJbmtnWWRLenIwVVQ0WGxnclhlNTVMKzR6Nk0vK1RURTN0Y2VhQ0tqczlNR05ZTFdOYU5yaFpZYmw5bGI2WUFmYkN6TDFWK3lwZ1NVUFZnbFV5RlE3dFhJVnV5anpXVEFGT253dlNobjJEa2lmeWpmZXhjOVRBVldodkRiUjk4R2NKb3NpTlJSVGJ1Z3pYRERhdWxQK2t3V0JXTlhVV1Y5ZWdxdEY3N0hMVG1yb3JzN0ZabXNONmVDbjI4ZUxlK0hiZGMrbFZYRit1bEFESllmZ1pMQzZCcC9kK2o4WjE5ZGhPUGJidXk1N0ZNMnRLeExTVmQ0S210c1hncXREMDQxUmhhYThhV2pidGdUWUd6Y1RGWVhzeFlRb01lWG9qc3lNSEttTkNEQ0M2K0pQZkFrT0R5SzJmMUpwRlpCY3M2dmRpMFlVZEJ2Tkc5VzJDT0hWWVdzM0hkeHhGWWxOOHd0VTRpalAzQWZzclhJMmVpK2NKL0tiUnRIYStwNUJ1cWN0QXFGUVBOaUg2MEgzVDhUVmpmZGpPSGY0ck00ZjNJSG5zZDVySFhBVE9kOHlJYU94SG9PZ2RHMTdzUTZEbzNmOFJZYjFCcHdmVTZkUHdJQm5hVnZzakF2S21qTC8yd3JQR3FwMEpaQS9WYUxnTE5pSHkwZjA1M3YveVpkd1pyVmdmVjJtZUszRGt3cXpGVTJ6aURWYTJDTHRoWDhtWUtGNXAzeENXRDVZaU16anF4WGlBUXVYUElXYWMxOWxZV0xHSGUzTkdidG42Ym0vSGlOWlpNSVp2bDFyMStrYTM1dDFETTFZdkI4dUxJNlVGRXQ0NTRNVExsbUJnc1phbHFXRkVMSUhwWC9rNmt1WHFWZjNhRGVVdEhJdjFWV1o5NEtwUXBaTGRjYUdnODkyNjcxbzdiR1YzbkZ0N2RvK3Fjd1ZKVnFvN3JOWjY5RlUwYjdxbElBUWFySXJucXN6S0RWWi9qN25xdkhRTUw1cTBkZmVrSFpRSHpHa3Vta0UvS0dTeWZES1RYdXNGZ2VXMUU3TWFqR1dnODU1TjJyUjIzYytwYm9TRHpyNk9KOUc1WmdEd1Z5aFN5V2U3WDN3b1pMSnRBT0dYR1lDa282WVduSml1RTZha3FESmJDY0RCWUNpS1ZWUEV0V0RCdmkvYWwvMTJtQ0sreFpBclpMR2V3RklUampLVWdFbWVzSWdVNFkxWE9qSnFGSGtUck5kOVNxMXVEV2xwNEFmUzJwUlcxVlA3NVdPYUhvb24wQXpKSERKWk1JWitVTzdWQktvakI4Z2tTem5TRHdYSkdSL1pTb2dDRHhVaTRvb0JqWU1HOFBkcVgvb29zU0Y1anlSVHlTVG1ENVpPQmhOQVFXSEMrWjNvVFBPUGEzRU9HSzduS3Y1bUNNMVlsR2pwZTE3Y2JwS2I1NGVpMjlKZGxndkZVS0ZQSVpqbURwU0FjNzd3cmlGUXZPKytjc1NxSHdVa0x6bGdLYW5MR1VoQ3BUaklXd2Z4SVoxOTZsMHdSWG1QSkZMSlo3dGVNUmNLOG83TTN2Vk1tQzRNbFU4aG11Vi9CRXJ6R3NrbUVRMlorQlF2RXoyNXdDQkY3YnZ3S2xrWjBReVNSZWx5bUNrK0ZNb1ZzbHZzVkxCSzRxck0zK1l4TUZnWkxwcEROY3IrQ3BWSDJMeU9Kek9TNys2YlJoOEd5Q1k3VXpHTTNyRXJqTFZjaFBZYngvZmNXbFFRb0dXMUxRUHJVWGdiTGx1SjFha1E0MkpGSUxsYnBQWU9sb2hMWHlTa2dDSWxvSWxtY3duZ3FaRHFxVW9Cb1h4U3BDMFVDNHlwK09HT3BxRlIzZFNoTkVMOFh3R3RFZUEyQ1hsUjVxK3BVbVJnc2w2QWhvaE9kaVZTalMrNDk3NWJCY21tSUdDd0ZZZmwwZzRKSUpWVVlMRVhOM3JvZnAybHBJd2JvM1NRb0JxQ2JDREVoUkxPaWk3cXF4bUJWT2R5RE83Q0lSS2piMUNaZ0E3cEI2QlpDZU9PbGUxWDJ6NjQ1ZzJWWHVSbnNhRHUwNFFpV3BNMVF0ekFuZ0JPSUNjSktDQkYwb1VuUHVXU3dhamdrOUFUMG80ZEN5d1ZSdHlERVRLQmJBTmEwdWdKQ0dEVU14ZldtR0N6WEpaWTNRRHNSR0JnTHJvQ0dtR2xObzRRWTVhRmJEaUUwdVFmdjFXQ3d2RGNtaFlqb1BvU0cwb0dWR1UzRVJQN0xRaHdRM1VKZ2lZZkR6b1hHWUhsOWhNckU5OWJuRU5hQ1JzeUVpQXRvUFFURUJkRWFDTkhtbGU0d1dGNFpDUWZpT1BvRkxOQkVxTWNFeFFIa2dRTldBU0xnZ1B1S1hEQllGY2sxOXlyVGRoZ0RyY0V6QlJBM0JYcXM2VlJBeENHd3lNM2VNRmh1cXV0aDMvMzNvVlZralhpV2N0TnBuQVI2SnFiVHNCTmhNMWhPcU9nakgvMmZ4MEtoaFhwTXlrMm5WbWJyUVg3L3JhTHRFQWJMUjFDNDFSVnJPMlJ3TExneW0xK3p4UW5vQVdiK0tVc0F5WTVFOG1LM1l2SzZYNlhURFY3dkJNZm5QUVVZTE8rTmlTOGlZckI4TVl6ZTZ3U0Q1YjB4OFVWRURKWXZodEY3bldDd3ZEY212b2lJd2ZMRk1IcXZFd3lXOThiRUZ4RXhXTDRZUnU5MWdzSHkzcGo0SWlJR3l4ZkQ2TDFPTUZqZUd4TmZSUFFuVlg4SEhnT3ZhWFFBQUFBQVNVVk9SSzVDWUlJPVwiXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9zcmMvYXNzZXRzL2ltYWdldmlldy9zdWZmaXgvcHB0eC5wbmdcbi8vIG1vZHVsZSBpZCA9IDEwNlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///106\n");

/***/ }),
/* 107 */
/***/ (function(module, exports) {

eval("module.exports = \"data:image/png;base64,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\"\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvYXNzZXRzL2ltYWdldmlldy9zdWZmaXgvcmFyLnBuZz9lNTg1Il0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBLGlDQUFpQyIsImZpbGUiOiIxMDcuanMiLCJzb3VyY2VzQ29udGVudCI6WyJtb2R1bGUuZXhwb3J0cyA9IFwiZGF0YTppbWFnZS9wbmc7YmFzZTY0LGlWQk9SdzBLR2dvQUFBQU5TVWhFVWdBQUFKWUFBQUNXQ0FZQUFBQThBWEhpQUFBbFZFbEVRVlI0MnUxZENYUmNWM2tlbk1qU3ZFVnk3Qmc3ZTFnQ0JGSkMyUXVrRFJ3SWhLUnRvQ0ZzcFVBSW9XbWFIRW81NllFR0RLZTBnUklLdFBTY3Boc0pYVGlFcFNYUWtNU1c1cjE1SXpsMjdCQTdUdXdzWHFWNTk3MlJ0ZG1TSld2eDY5M3ZmOTg4eVpKbVJwTGxlODk1UjVJOUdrbnp2dm4vNy8vK0xaY3p4eHh6ekRISEhIUE1NY2NjYzh3eHh4eHp6REhISEhQTU1jY2NjOHd4eDV6bGMrN1A3VnJwcit6K2pZSVRmY2kzd2p0OUIzMWx1c3V6d2x2TUsyYU9kdTdKYldzcU9JY3V3d0M1b2VpZ3Izb08rb252aExzOU81b00zRGlaemVYYjZFbnpTcDdHQU9wdzBLdThQUG9BdHpRL3hnQjZlaTRBTXNBNmpjK0dYT0hNalN2RFN3dDVkTDF2b1EzNHVyOW9vNmQ4TzVxb0ZVQUdXS2NKZ0FwdStSVWQrZkFQUEF0OUdkL2NINUViM0VnQUdXQXRLeEo5L3hrZHplV1grL253L1pna2Y4bXp3eC9pRzdrVFc2SHhoUWFRQWRhcGVWNVFhRUVYRjVyUnRaNGJmY0czdy8vR04rd0ovUEg0VWdHUUFkWVNQNXR5UFdzS0Ryb1NFK2cveGRjOXZvdTZQRGNjWHVvQU1zQmFNbTZzTzkvUkZMNnVZS05QWVBEYzdkbm9ZWHlGcHlxQURMQVdpUWZSU0l5RjhqL0ZRSHEyYUVjbmxodUlETEFhZE5wejNlZDEyT0c3L1R6NlBBYlBmZmhGM1k0SjlkanBBQ0FEckRxY0IzUFB0YmJueTIveHJmQXp2b1crVjNTUWgwbjE0T2tNSUFPc0dvNW5vVGQ0ZHZtUUFZd0JWbjJCMVZ4K2x3SExISUhsb24wa3ltM2toYVBtS3pyeTViY1dtbnJlVE43OExDanFlUTFKbEpOVUZSR0xIMm51dm1Sajg4RVhFOW5tNFh6NWdrZXNRK2NXN1Azckg4eWh0US9sdWxmL1QyNy9xcC9uOXJnUDVNclc5M1A3VzBpYWEwTnV3d29ETEhNMTdDSTVVMHgzdHBFSTNnRExYSTJ5d1BjU3dkb0F5MXdOc0dEb2p1VUZMR2NPbHdGQUl3T1M3bE1mV0FBc3hUbGNTd1ZrKys4Y1RnYUQ0NmYwdGZQcWdhcS82d0czZlBhcEJ5d0NCcHRkUlg2eHJ5UDhlY2JsNkZkQXI2VUJzdWdIeDVKVC9leisyRkRWMzBVaXkxTUhXQUJRdmdSVmhEOW5BUElkY3Mxc25Zb3V1Umk0MGlCYkRIQXRWMkMxNThLTGxqYXdIQVdvSWdjVSt4d1JYMDdCVkhRRXFNam5pRjQrdndMNnRmcC9CaWdPSkE0eVpja1dIbUFHV0lzQkxHRmxKSmdpQ2lnS0tnSUlsMW1nd0UwQlJuSXVEaGpOTlhKd0NwQzVPc0RFOHl3VXVKWXJzSWpRdXZTQUJjZzRjM3ZNM1RFTHhNRGdVekRvRm9sOFRnQkhMUmNCRy9sY2dpOVcvNGVCS1N4Z0dtQ0I1R0lBcEFaWXl3QllHcWc0ZnhMdWpvTkZnRWx3TEVqS3lkZUJIVWxTbnlid0FRZWRKUFA4c1JSZzlQbWg5V284dUpZdGVXODU4S0tsQXl4SXVqa2d5TC81SEZTU0svRUkwSGQxNjZKQUVDbnJSQzZMazMxSEIxMUEzU29IcjhXQktGM3N3b0RMQUdzV3g3ZkxWOVVLcXNDQlZpam1aSnhGZTc2d1ZOeTYrSTZJQm1NZURiTHY4VzNBcXpoSFk0RGtvSkpFbnozV0U5ekw0Z0FUUHhzQXQxR2NhN2tDaXlTMEZ3OVlxWWd2QUs3THA5d0tTVEQ0TGxLV2pMdEpDQUpwZGZMQ0lpSDZkV0RwN2xKd0xNSFpCT0I4eXJ2SWM2VEE1U2lBR21BdFpXQ2xsWElnSXdpUzdnbFFXWUswYzNkbUtWNFYyQUJRNURHV3Nqand1WVMrVlpUV0twWmNURml5b2lEMjNEVVdMVVFCSmlORThQUHFEYTdsS3pjY2VrbmpnWldSZGduQURSWVdRMWdvOHRHem1LeEFYU0g1UE04Zlo3R0xXS0lnSDBrSnd1ZldSZ0tLZkord1hNSWFDbmRvUlFwQU5uUzM0bnZGOTdIbkNhUjc1UUt0WTRDMStNQnk0cFR3Q1BVaXhvOENvSUJMMThRdENYTnB3aXJobTV3dnM2L3pJWE43VnFTcDc1SVQyVHB3QStIaWdKWkZQODl6YXllaVEvSXpxUEFxd0FoRVdQRVkyd0RycEhKRHJ2dWxqUUZXQ2xBeXZCY2h2UVBjRXJFWUx2K0lBZUJaSVFkRUtLMlF4OTJUaHgvakVUQzBjRmNwd0pYWDB6bUJIV3R1TEVqbERIMFlFWXJQdVFXakZoRUlxa0tBOVcya0lrckhBR3ZoZ2FXQktnVW9GOTRvb0RNUmF5SmNIbmQzWHA2NVFYTERmYTY0ZXpad2lYbmxKcWtWc1VRa3gzK0gxbGlwODYzaTU2b29VVmc0bjFzdVJlb1p5SHorTzFIZGpQT3dZcDNCdFZ5QlJVcWQ2d3NzTFFITVhaeWJUdjdHUEdKVG5Nam5CSnhZSnMvbVlJSlhubjBzOHNzVGxpWWZnVWlRUFgvSlZVQU9XdG5YSlF5c0V2NmNmRTMvWFhJcHdNdGtCSW1VUlpOUklnZVhneVRmcWdlWk44Q2FEYkNheTFkcHJrL2NYQzJYcCtRRVNib2xTQkIxZi9EL1pBUm5DY3NpWEJnQ0JEM1MzWis4MlJWMnRWYVNZaXNER1FWYVc4U3NHUkJpQlpsWEJCNUVpWGtRWFVMRnZnNzYxbklGMXFibW5wZlZCVlJKTG5sQm9UbDhEd1NWVXJBVjJGaUV4ZDJSaGJpVlFWd3V3SmFJdXFFUVJIYUNvSE5ySmExSXBOeWlFMHNneUtqTlRtbGtUb1ZiTFB6NUtuSlZkQ0x2TUlsRFJveU8wTFFBQjdQamxCNVd1d1JoZ0hVU1VPRnJSZEJjZVU4V3FHQnFSSytoUXVxR0NwbEJXQTRZNldsRW02dnNVTXlrTjdqQ3JZMlNGOGpQTEVtM1hHRmZ0K0hQMndpd3VEVzBJcW4yVXdYZlFrclM0S0twK0Qxb3RDZ2tEQkVZT0xXQmE3a0NpNHhOcUFld1ZoUnl5WmtkelQzWFZGc3FjT05zM2ZYSUdpa3JBbnhLa0dlb09TRnBwUVRSVjZHL2l0d0V3UTVFZ3RvaVZxbFNMUThRVjlqR0NiMnQrS0JLKzZBVW1QalBkb0RGdENQTkNzL1hKUnBnemVRQ01haDI1WGF0TERiM1hCdGtXU29RN3Z1QXp3aUZXNmptSXZLalFtbGVpWlUrai93RXp4SWFsVW9vY3d2Q296NENocEtWaXQ1QUlFRTRWNmtOWDZ1Z2VNdWUxM2NBbUcwU1RJQ29WUWlwRmxEeTAvbEVBeXdtTjdqbFY5VHNBcmZsa3FaQ2JuOUx3U3BmRjJTQlN2QXVLV1lDQ3lRMEtNcXJrRks4TFNSVE13SjhNcW5zUUI3Rm8wN2graWk0S3JMU05KQkFKSjlYT0xDSTFTTEFxbFFCaTJscEFxejg5OGh6Z1pYekt4YTE4dWQyVTFiTEFLcyt3Q0xXNnNIY2M4MFByNHZzam56OC9nQyt5RkFOQitJajFhaUV4UkpBU2wzS0dvbEtBeFZSYWk0SVA2WmtNekFwWmI4Q3hGQUJuQW9uOE5NQksxYVZEd0pnSXJVa2hGZ0h5WFNQQ0R4RUZjUjh1WllCMWpUY1NsaXIwdG05THBseHBaV2JpR1N3cGZpVkFKWXZMSklUeTl3Zis2Z3VjWE5WNGxoRW5PazBFUU9Oem5lcXY2NEdsdTRLcXdvRCtlOUpOVGNPdHNDSlZLbU5CVGlrQVpaZTNiQXl2TFJtYmtXc1ZXSFZ3S3FPZk04TnlnV21icEtzVmtCYXprNXdtY0NLVmRtS0VDRGxSNUFhZ3E3V2hjL1BkQ3RWYmd4U085Z0ZsbXlnYldHT1JZSFZsZ0VzQjBTaURsUDN2VHdweDFIMVlOU05VNUVYV3NYNXVVTURyR2tpUVdHdHVscTdWN2ZueXgrV0w3UUZ5bGFnYk1CNVZXQ3Bmd3ZnUjBmbDloanZRU3I2UzZuNlJXbUoyQjlUa201SkVQa0tCeStYR3ZnZlRhMVdHLy9vVkxRVWxNOEJJenFBcUxiR2VhREtHb2drTlZKUjVUemQ0YkxWc1ZhaVY5YmtCcnR5M2ZtTlovVzNZVGV4MW0rSlBpS3RsUVVVYkVjSFVjRExnQU1MMUVaSmpsT3BMayttSkxrQ0hoUHBFWjhOQ0x5cmw3YVVTSW9IRW5jSnJvcmVxd2d5QTRFRk5EWVNWSWczQStkWU5LMWpRUVUrU29IZEFHdGV3Q0p1OFA1Y2NnWjBnNC9hOFRyUERqOUczOEVXRURERlRiQ1F5c2Rac2VZT1pZdVhFMm5WcE1vOUFTc2wycmZjT0pPY1V4N2xBa0ZXV3BJS0E1aDBoM3B0bUJSdVFVTUdsUnNjcEJMU0lrb0ZSWWdDV0lFQmxxNWpPZWhWTlVXRGhiVVZoN2pCb3RWN2p0Y1UvaEVzdlBOY2tlQk5FM053azRUcmM2b2JLZ0lJSU1DMzRFM1VnTVV0bE9SY1hIR0gxcTBrK3dncm1yNEZyU1FFRE0wRzVGVkpUU0JrQ0R2UzN4RExCRmpqdlZQSjBTY201RnlHeVpFVEN3b3NqVjl0Y1h2V2RPVVBuMWRvUXArUTFhQkNBN0pBZEFWYnNsSWR5WUprVnlubEdhNHZxNFcrbUNvZ0xIRTF2a1FCRk9sbExsbURSS0RNa1NMeUlvb043SFRaREg1K0M4b1E4d0hXNk9LQktKcEtLdmVQSnM5Ly9raXk0MTM5U2VmNlN0WHYxL25DT0RuOHk3R1pnZldIZzlWeWczUG9zcm9CSzJpS2JsUmNDdGFqUjFwcUIwb0lnaU9WN0tpcTBsVGw0aXFLTnptd3NWUVhKNHVPU2pnTHNiU1VGakMxNXRSWVZTenduNlc0RTdkT1BOWGtWV2x0M1BMWnFiOXRLVnNzYkh5R3Rvd24rLy95YUxMOTlYMnovaDMzZnY3bzNIV3NlZ0hyMFh6ZitZV202Q1lKS3BoSXJ1SkR3SVc0MWFYTENsaVY2bktZS21zRHduMFhTQk9pOHRPRm9tbXFBREgxZTFFcHcxSnF2YzlWZUZvTEp0NGdGcEJDWk9GZ0xSYXI4Y0FhM2pWQndiSGxwYjN6U3BRZit0YnduSUZGNXB2V0JWaEJTLytGWGxOME0yeEc4RUVyVjhDYkVnS2djdzBVanAvOFRZYXQ4TWpUazhuZUx4ek5IS0NtMWJrTEM0SS85djJLUC9kVWtwVC9hU1RWb1pPdXhXSldibVQzeEVsL255bk1PWTVzbTBqMjNEVElhL0lqSFZqMjBnRFdpY2trUWQ4L2x2ejZpdjZhcTF5SEhoMWZIR0J0Yzh0bmIyNFp1SmdBcTJncnhWendMZnBpcjhMK2VnMTJUMmV4MGhYeXcyY0RMSG53QzlYN3YyTkoxL3BVR3NiaGVoV3dYanV1NlUrT2w2Zmt0eEl5V2xySDY2L1NWZ3FraUVaMlQ4NzYxNW5DMUtoOHo0aXEyWWZBc2hjUldOamRWWDQ4bWp4MjJlRzYxT1EvZWxFdmZjNjV5dzNkcjY0WldKMU85TUl0TGRHTENrM3hIM3RnSWt4Z3h4SllYZWRYa3EwdjcwMDJYMUJKdXRaV0tNQWdzTWE2cDVMaEp5ZTBhK1NwaVdSeVVQMVZKL0RERDMxenBNcGlwZk45aDc0MWtwd0FiN0xKb1JQSm5wdUhlSVdDenRWOEVKR09QRDBocmR6bzNrbjk5OWs1UWY5L0NrUko1SGQ3N3JOSHRFcFdmeEdCTlZnNm5qeis1cjY2OWozdXZlUG9QSFdzR29IMTZPcStWZ0tzenViNEpUZ3F2RlV2OFZVVkNsM25ZZlJmMG9zL1ZwTE9zMk9hcHhzRXdJcnVHOVcwS0hHenQ3LytNTDJ4NGh4N1pqSjU3RFdIcTZKQ0gzUklEMjBlcjM0WC8yaFV5aHJGVk5lUVNDTUpWMGdBZlBCdmhtVjlsc2RGVWlLVFBQbStnV1NzUjFuRG9kSTRmWnpucWxLYnVmUWUxZ05ZeDNGMDk4eE5RL1dmTGRFYUo2UDdKK2NGckE2NzUvS2FkQ3hoc1lMbTZNWHRUZWcyV2UwSmE5WHhpOXgxYmlWNTlNVVlXT2RVbUV0Y1ZkRXNWblR2S05PaFpNU21YTjd6bnp1U1RBMmZrRlppenllSGRPMEpSSWk3UHptWVRQU3p4NUlYWmJ6Q1FERDYvR1N5OWRXOWV1V0ZxOHNVRUZnSDdocVdGYTJzR2tPa2RlS2srenZZSW5Lc0g4Y2dlK0txUHMwTnpvWEExd29zd2gvSmE5dUlnU1U3cnhtWXYwQTZYMkFKNWYzbkdGZ2tuYk1WQTZ1aktib2RsaG5MVmlyOHNmT2NPTmw4Y1cvU3VZN3hMUExDWndFclNBbWU1UE1uZjNjZ09ZNm1KSmsvOExWaHFXOXBVU2EyS09HL0hLT3VqRmdwY3RNR1M4eDZUZUYvM29mRGJQWTRNSERFVmgrRks2UVc2eHZEb05XTVJZY2xMaTA4Yzh0UU1ubFVBWjJBV1pRMkIwQittQTI0NWdzc0ltVHVldDlBUTJkMzlmNTBkTjdBSXBzdmFpeVpxVGdQWW1BVm1pc3Y3VmhSdmwxMk1kdEk4aXZ5ZGVkNmJMVXd2eUtDVytkWmxTcGdJUXdzbGI2cGFCSkVGYkQrNnFocVRoWFJKLzY4RXhOMHdzc2dyenAwOTdEa1czMi9HZ1BhbU9pNjRibEFEQzRkV0VmWlBJYzhVbmxQTHZKV0FldkdRYTdJNjVVWWpRSlcveU5qbEZRM0VsVGJNTjFJcHBMRkE5YkR1Y2dXRnF1NEF0Mm1Tb3lWdFNMdmVBSW93ck5LbkY4Uml6UFFrYkpZVlhKQ2xPa0toWVdBdll2a2hqNzNaK3FHRTRCMVlldjQ1SFg5VkdHbWJndEhpanZlMncveW1BSmdESnhFMXBEQSt2cFIyblFoYXZBRFN6VlNkSDgzNVFyZjFhZHE4RjFkd0QwWnVPWUtyQmh6UmZyNk5YaUVKZms1dGVRSy9hYnliODY3SGt0VU4yeHllOVlRdWFHNG9ud2JmWWR6WUhtT1N1bVVpS1Vpd0ZyTDVRYjgvMVd1ME5IZENMa3gyMS9YbTBIZWV6T3FUbU1jWm8vSnFJNjRSRkhXVEtJbENoaHN1WWpZSjRhTkJLMjgzWXdubGFIRk92QjEvTGhWa2V5K0x2SzIreWV2MDhuN0lDZnZLajAxdC9LWnVRQ0x1T2VGR0xpNzlaV3p0MVoxQnhZSDF4bVl4TGY4TW5md3JNNlc4S0ppVStVMjFwYWVxcjhpS1p1MUhGaHJJbDY1R2MxTGJqajR6V0hlL29Xa0FrNUE4Y1NWL2NuWVFmWnFFUEpPckJxcFRTZVdoa1I0Si9pUEloR2o1Nmp4a0xKeHcwTFR5dzA3K2UrVEpUZmNQcVRxOGUyS21vZnFwdEpITlFLTHBHR1c2b2p3ekdrelRlWFgxbFNhL0dBdWFTYkFhdWZBb2k0akR3YlN1dXpHVTI2Rkk4TFNtbGkyWGcwVXhtZXYrK0Y3SHY5d2xKSi9PRkZHV0t6OUc0NVMwVklLb3V1RkpVTEpqcXVWWURyUmR5SjU2cU1EdE9NNmNCR1RDVGlIa3NDYWpVQ0tYL3R1WXYwczBMV2ppYmI4YTFFS1hjTk5SUDkrYk1GQXRlM3l1Vm1yaGdGclZ5NVp1VEhYMzFiSW9ZdUxSRzZ3UWhxYXkyWUREckRTMlJHVkdrcXJJem1zWTdiS083RWUrMGhLQnlTMjA2M3VrcThKTnlocjYyTnFrZlQvSDJHL1Z5dXNyMEt6QXhiKy9xTTdKcExkSktXRHdlbUI2bFl4bVJsMmYxUHIzRHIvNm9iK2g0N1ArUDFVb3NHOGRjK05RL1JqelpIZ3o4Ym1YbytWVWQzUTNvVGVXSE16QlFGV2tDdGYySTQ1Rm5OL1BOSVM3VnlFbjZ5dFVNbUJBQ3NycFlQdVBhYVZ2VVQvT1NyZk9jVGE3SHh2djFUSzlYcDZJbG9xZ3M3YzRBQW8yV0VmOTM5WldUVGlZanZQaVdqaktoejBvUW1rbUx6N2JiellELzhOTU5BZ2JuSHJhMkx1VW5sUm9CdHJVYUhQWjFhVVZuTUxQUTlnRFdQTDI3bDIrdS9kL3FZK211YWkxdlB2Um1ZUG9GV0VSL1VtTzY3cVQvWjhhb2hhKy9CZmp5VUQ3Y2ZuSlgwMERGaWxYSy9yNS9vdTJFaWlRcHZYaU50cS9CQ3hHcFJqWVlzVmNGZFlUSkYzeE1sN2tWY2lQUEgyZnFYNkV1WDhKNlBLemRpcUpaNUdhVUN3SkRJRDVVUTdNL2dSdjRja2Nud2VSNUJCRzZMdVVFeVhnVkVoSmUrdDRtZkV5ZTZQOTFNM0tvS0FudThPODZtRFlMNlhxNUxpb2tDeHhQT2pjd1hXMUVpU2JMMXNHa2tCdjM3ZDN4NlJienp5UmdsbUVTbVN0TnBUSHh4TWV2RHJSV3FzeVBkTjFhRWNyQkhBb3BIaC9ibUtVOGoxbkY5WWdXNGwzTVd6eENUaWtJZjJJUVdXZElWdDJRS3ByS2ZpNVM3aFBTTTArU3k0MGU2UEQ0TE9abllUQ2VjaW5Hck9pVm9jVGxQZ1dHTENqUjRWSHJ5TGk2bDhoUW9CZmQvL2pjbUVMQUg5cjY4OHpLbzJoTWpLWGJ5Y1JramRGT2VWclhNRDFyTzNaS2RvdHJ5c054bnFHdGNDbW0ydnJTM2h2T1dTM3JrVkJDd0VzRWhxaDFxc2ZQbUM5dWJ3RnVvRzh5Z3A4RWpMNS9NT09za0xmRzdNM3NGdHZHd21wV09WWEwxeGROdnJlNU5qejZsY0ZmbmpaWEVlVDUvc0FTbWN1Wnl4QTFNWUdIMXljakp4YTFYQTRseUpEVnlMazEwZjdFdkc0eW5KdFlpN0RsS2wwSUlIaW9WUXBiVWdZSmtsZVNmdUxldXhUOTB3bUV3ZTBmL1dmWDlSZTdUNDFQV0Q5YTk1YitwK1U2MnpHODdFa1dHcm4zditnazNONkZiNkRzNkRBUnVpRWZXRm1MeWZqMzhvNFF4dHFFcHVrTXA3YWxWY3ozZFZwY0xFd0luazJWdUhRTlVtU3FMN2pra3JjdlR4Q2ExMVgweU1ZWW53bnVSeEtrbE15cktYZlY4NVFxMk14OHQ4cW5Rc25xVDJuWkMzb1NIc2twWFZndHhQSnJURldoWkhsUFpXR0tsdW01M0ZJa0x3NWd1cmMzLzd2bmkwcW54bE1CaXZ2U3ptSmIzemVtT2V6R0xWQTFoTlA4OGw3c2JjM2dzOUsvNlR3Q2t6TU1HSnlCWkw2V3krc0RjcFlZQUZaN0ZvRFZvc1F0NzFxb0FLZmNjVE1YUmtsM0oxeEExMHJXZFdZZXZsdlZRd0ZYSUU0VnErcldabHNjclBIajVPc2t3anVNTy9HTlVzSUFHQ2g0RkRaQWVOdkZOWHFFWVplVHgxQktVTGNxTjdNZEJrRWh5MGtZa0lrZFNQVVFLK2FuWVdpMmh1NmNmMC9PTklkWGthdGx6RWhkVmF2U0RFNDZWb3NjNGdGcXM5OTh4NUc1dDdieEVEYW9YY0lPUUJvaXQxdmFnaWdVVnVSbFpLUnhUTXdVbUFCKzlTQWllSmdFaUVSNEQ3M09lR1pLcUh1S2hkSCtobi9FNk9sd3o1QUkrSWZ1NjdZYkwzaTBmb2M0anZlZks2UHFhK08zRXFwVE1zVzhkRTlhdm82SVlScStCK2NoZFBhanhtMXprZzhYNFNpMFdlaXp4V0E5VjNScWE1bVlPekJnK3hTcisrb284UzkyYy9PNVFjK3R2aEpQcVAwZVRJbHZHa0hpZXptYUtwNTgwMWN5eVNpRzdQZForM3FTbjZqSGp4MVN3cmJyRklQUllHVnVjNi9HK3JxNk5DUWQ2elpzT1RhUExvOWdrdDNIL3M4b3JXUFVJVWRUaWFtK1g0eXJLdmtWZ3JNaXozOGJmMUpxTUhKbFdLNSs1aFBob3BsWVMrYTFpTkMzZjFpdE1uM3RHdjFTbVJONGhhU2hESitSSUVtSjNuOWRLeUZncXMxcG1CdGZlT0kvcGEzeTlsRjluUjJyS1RBSXE0VXdJa0VqMlNvS05lRWVDQ0FVc2tvaC9KOVo3YjBSVGU3UEdrYnRIV0o4bDRjRkdBQThZRXlTYUg2Q1FMdytFWWI5VlZJOHVDZWN1N25PbHVjeGVYSno4N3BLRHk4dGd0dHVESHQwVDY3QWk1S0pOOUhvQXBNcXBtQzdFV2Z1SWFSZldGRzRFOFlTUkxjQVJ4Sjc5ZjEva2NXS3RuQmhheHZGRGdKQllwczZnUFRkVlVmN1gxMHQ3a3lLUGpTeDVZc25RR1grczdWb1EzaXgwMXF2T1p5UTUrWG9HcldMWHRWSTBxeWlvM3FaN1hrRTZkS0xHVXpvYlhCcmhoNG0wUjNvYzVWa3RJNThON0xUR3ZWb0NkekpGc1JnMjBBU1JpM1Z5cWhzc1dJcWdDa2Rab3k5OE1YUmV3cXRucExSYnp5K2crbGJaNS9LMTl5ZFRZaVV5WkpHdXg5MXc0RmFtSFg0aE82TG9BaTFpc1RibDRuZDhVM1NoS1pnSTVqRmJOR0tYLzVvSlJqS0RWUzJzY2RkSlhYTjI2SlIvSG4wdnN3ckhBODJNZ0VUQjVZQ0t6bDJlVGwyWC9vQnluaENTUWZGdnRMZFFBN01aYU02dXYxWFhCbGpKRjVFa05HZ1hXNnBtQnRmUGRMTHJzV2xkSnhycXp5NEY3L21GazNxQWlQLy93QTJPTmNZVVp3TUxlNGJkcW5qMUtnTFV0Vno2N2NBYjZCQ1h0anByWndLeFhoWUVNam5kMGticUpEdWpSbThZVkZ2bHdEOTlPV1NsUlVPZ3d4WjlOaUNFTmszeFNESFdCSWExYlorWEZnUDl4ZWNCMzFmUmxEU1JnVTZzYW4wVGtDVENuUzR3RmQxUEpaeTZ1YmhZV2E4MzB3RG9lVHNtdmFRVnN4am4yN0FSK2p2bTVRSkw2RVFXUXB4U3dNS2lzcnR6UWFxOHAvRmhSM0Z4YmJVSDFiRjFYVXZNVW91ejFiU0FpREJ4bzJaQlV0TldBWEVTclFJVktMdHdidFZSNUJqWUNyQUlGRm5PTkFvd2UzTVRxQ3MyS1AwZXIzckl2WExKUFJ5SWh0VHZSaWpKYi9FV3JQZ1hXK2RPTHBJUmpIYnFiV1NLaWlXVW1DbkF3UWNCeE1qZEhYT2pPcS91VFBUY05KUWYvZWpqcCtmdVJaTEE0TGlQcWhnRXJnMlBWQlZpazJDL0lEWjdscnd3L0d0aXh2bmxMY0JrSFZWa2JiWW1TbzFjRmFBTkN3QUJaSHd6eXB4T1N4ZEFSbDFzc081SmJMTmpub1p3ajZnc1h5RWNwcWR3a2tudW01Zk8zUmxWZzhlVU1MU1VwcUQzVkVkOVJyY1lHa005SmRDWXQxalRBSXNXRFJHWVlPNVJkcjdMdnpwblZkYUtUa1FpUWFHQ0hmekVtNVpRRm16YVRsZExKbDk5U0YyQ1JVVWJleXZLSDRUQ045QWhHejFLdFlYS3RpTmljQ3ExWHhreFNRWmJWNU9VeW53bUJ1SlZoUUNyUXhVNnNJb0YrVDU2dFVDSFdpeTUyc2hWSkY2bWFvclllV0czN0NzQm9jUjhFRm5MaEFCVnhJMWtxSXdlWU9HcW13MllSRlU3akNnbHBKemxVMHJXY2RZNXNIVDlwMlV6Nm9qMEMwZFRDQVN1ckhxc2V3S0lUa3pHd2l2bm9RNEVjOEsrNEN3T1JFaGpWckhUbWpqd3h5Y1ZSR3lEVU9sNVZsU25jRkl2ODFNbzUxY3JQbzA4ZWxSWmM0aExMU1pCbnlyc29nV0dTQVZoYkp5UUhzVHdLV2trWitUSEFsQndFbWozNDN5VXJHOVRjZWNIVHVzN3I1Y24zYkdDUk9qUFNaSnJaL0gza1JMTDEwdGtubUVuNktQem5rU1V4SDZ0V1lHbjloZGc2M0ZBRWU1cVZkYWxJbHlWdWFxQnBVWkVjUmlzak1vMjNoS3BWMzBGeXNsNlJSM01NTEtFcTd1UDE5Z1hLcjNTNW93amEwd0lYNm1CSVcyZ3VPSmNBalEvSGl3dkxLVWc2R1BzdGhvV0lMV2ZFV3BIeFFOUEpEVHZlMlovMGI4d21RYzk4ZXZaTnFFOS9aREE1dG5jeVdZelRFR0Jway8zeWxldTFRZjJXMnUzc3dhMm5WcVJaTTFYV3EvaFQxVUEwa1JDMjFPTEt3QkVyZm5uVktwaHg2dkdDUStsK2hXV3k0QmhMSkpjQ3lPZTNWYzI2RUVBRGFURmpLZXA2a05UTDBVMUk2bDhCZDVPMFFYY0dZRzEvVHpaaDczdHdiSFpOcFZjUEpFY2ZIMDhXODJUbUN2UGx0OWE4N2tSMDY1QTU3Mm9ra0Y0M0pXOFFkMGVCb3lZVHF3azBTTG9pejliSFJNS0J0MkwvanVCVlFoK1RKVEFXYjlmS0s4bERESGFUYmZhUWJIT3VSb3IreEFSQ1F0NERLRGNJdm1oeGQ4aVhTMGtMTERNSmVndlk1dlV4RzJnMlRZbnlnUXh1UmRSMUVrMU9XN0NIbisrNVc0OGtSeDViWEVBMUhGaVNaNUhORkk0KzRCL09XSkJseFE0Y3ZLYjRGbk12b2JZWVhMZ2VYMWdQTjdVb1hKQnRvR2w1bG1yWm9xN1FpWUZGUTZvN0I2NjVBNnErN3loZUZRZ0EwbEhmU003N29ta2R1UFl1clgzeDU1NXJkUU1WU3pQVWRXTHhkdjMrQUcwb21jMzR4dVVBTERudnZkMktmay95SXpqSFU2WkN4THM4TlFQZUFadTFOQXNHUmppNmlGc2VaU2s4aC8xN1VZSXBWRlVWZWJXMnpxTWpLRU10bjhpSU9wSmFXRWxtQitEdkhVbEJWR3B6YnNweUFzM0tCOHE4Y0o5RVNaOUxvUitaeFNBdEUvN2Vwejg4bUVUL2RTeVpHSmhLbHVxWlpqUEYyK3F5L1l2bURKdlJ0Yktmems2Sm5rNzFYbWJaeVd5blVpZU9jaXZNVWtITkNSVHdPYXFSVks0bjRXVXl6UFdST3F0WVc2SGl1Mm9xamR5VjZLaFIyL0wvUUk1UWlxT2kwc0hTcFFWUldpTnloZ0dZTjkrNWR2cUlNQTJzcWRFVFZIa25RMlZKV3VmRVpISktuRVlDaTFxdFRjMDkxOExRVzBWeHVocXRqVmVFMDRvQjcxTFZEMGlCelk1a3M2a2N3dUhHMml3R1J0SXJqTHpUU0k4QXJTemJ0SHdvZHRyTXpSWHBESG1Va2FOay8rZHova2FuUU12SElqQTBOOUl5QWlKRlJlVUowVXpSR2llbjB6anV1Z0dMV0szMlp2VGVJdWdDRG1EYVJpd1B5R2pxRkhxUm5QWGdxSlZ5MVNrZnNGWFZGVnhKVlNXSTZjWkNGL000NFJZTHlYMnczRW02V2pEbHorTy9Zd2x3SmFodGVZQ2IrV0w4cFYyOTZFbFlMMkt0WnU3U1daN0E4dHp3aXJxdDd2V2FLMWZEK1FzU0RDNGJBY1NJTXlpY3F4cUVCbFJ2alc5QmxUeEtWVGRVQU9pUTNGZkkzR2NvdVpodkllQ21VbFVVZGd4K0x0SmNzRmJlWTZkQUpJRGt4dnJTQWtmTnA1L0pXaGxnemZLUW5kQlEySlNrSFk3QzVnVGNsN20yR09UYTBwWk1BVTd4R1pRQ2xuQTlZZzJ3c2o1TWZxaWsvaTBDYlYxNlZCaHdRdTg1cXVaZVgwVWNxN294V0M4R1FjM2Rwd0R4eVNiREdHRE40blRZNGJ1REZHZVNOOHdHcXJVTnJCWG9IS1kzeDJVZ0NWeDRzM21DR0U2anNjRnNkakRrellOcEgwdTVZYzhHbzcvaHFHNXEwUkNZWnlvc1ZVVUpveTdZb1dOSDJscGlGYlhxVW9YOFBWMERyUG9BQzJ5VUVLbzc0eHRJMjc4czNGMWd4eUJhUkhvTEdBZUI1NGhGbDZDa1dDdFZyc2plUURYNExhYWFtSzlwVEVoSkJLNVM0RXZTN1lHbFRUS0ZGTWxlUm4xbllxUlZpaFlkM2FwcHRXV25JYkRhVzhMZmJneXdnQ3RURWdRbjhkdzYrU2xpSHRncVdwUHVVb3owQnAweXhIcXgydm9LbnlXS3BPck9DdjBxZkg5UExOdmZpZFVKUUoyOWFKMm4xczZ0U0xJZkNEM0xVZnNKQTlBdnFPMlhUamRhdURvdkRBeXdHZ3Nza1pEVkJwUHhKVW42VWlRMUcxNHVEbmRqa0tQVHk1bDlIdmJMYUZKb1ZTSkg2WWFzMnRPT3RRMWRQbS8vRit2b0dNaEM2aTVMdGtqaklKWUZBRzhDVWYyZzc2YUdtekdpcXJyODA5VVZOaHhZa0poRDRSQk93Q3RxMW8yUlptWnRRbFV0QU1oeEFBVlVCeWF6MmJvNnRSMmpVdFY4b1dsVW9BcERyS3NyQWRuQmQwVVhqeWdCMG9GVWxHbWZXQlVlT25QYmFyOXMxOHExb045cERMRGN1SG94a3VaS3B1bkFjU0hnSXNCWjJNSWwzNjdlb2NPMmh1bTdEQU1nd1BxdUl1eHdTQm9Ga0ZZU1UxSExsMXkxNjlCM1FaTkVLaXJVQk5Lc21uMERyTVlBUytOWkxzait5eGMrMGdpdkR3ZHNPUG9BVzIwRG1MYVZJdEp2dWhCQzNVaGIrUnZZU3NYMzRhNUNHNlp5d0J2QlZzOEhGemtGYmx3OXZjL1Y4NXdMdVVEZ3RBV1c3ZzdUOVZhUlJudzFJQWtOekVWQWU0cXlselM1c0JVKzFsMmVySUFRaXpHUlZtZ1lhRk9VVTVxWEZHdFZ3d1VFZnRvYW13MnJDd0VzTjlWY0tydHZVczJwd1BYcDdyRTZkQyttcWp2aDBINllqL1JGSHBDcjZWS3VjTUVlYWFEMCs1cnNFWUVKTW1BYXNndHErVjIrUjlIVmxmakFBSXZ2SzBSWE5oeFlSVWRYc0FPTlQwV0EwOFNnZjA4SG1Yb2VXUFdwT21RMGNLV3JKK1JIRGpCWm9vTlVXNzRkZ2YyR01IcU5xdnNjM1ZoejZiSmplbzZnTXNDcWc4WEt0Rm93WVEzYjFWMTRBOU0xOE5OLzFGTkJjTjREQWkxa2dIZkJ2c0xVUm9taXBsZEZWUlkxMENTRytWa3JBNnhhZ09WbTNDaEE1TFgwaUFzM3o2Y0E1c2JheklmMG9vSDAxbFd0VDlFVk05MUJqeURZN3l5Q2dxSUwxSGRYVHlocjIyRGROS2ptdmxsMTJhZDBIUFQyeGdOck9wY0lSVk5YVDQvQTJRa1FXTlhrSE9idVFJNVJzMmhJZFFTNW9CclUxZ2Q0UUUxS2FXNlJWc091UmFGdWJhQXl3S29Ic0U0R3J2UVlJemMxdXNpTk1wNHpxbEwyaTRDZ3kwa3l0b3JzZkZjZjlwKzJqRmxYT3BvdHVuSG1ubXNEck1VQzFnenBucXFiazdFVVBNMmh0RG9xVUZ6SXZnZWxpZzFWWVdCZ1IzckRCaUQ1R3NoU0tTUXBpNlNzNTN4QnRaeUI1VHM5NzFoNFlHVlpoU295bnliSzAwK2hTZmNoK29DY3N4SWNsZm9SVlJkVlltdnFlWUowNmdtNDUzcUJ5cEQzQlFEV2pHRFRPRlcxbXlwbXBKRGdncVFpV0hydTIrbXBOdG5Qa3dZVXRHREZPb0ZxV1NlaGErbUVialN3Wm1YZDRFQlpCN2EzUSt1U3pZWHE5VHdHV0ZsVGs4UFhuWExBbWdsd1dwTGJpZWFsaU5mcmVVNW5ZRzFjR1Y2NmJJQjFLbDdMbG1QWis5Y2JZQzNpdGYvT1lkcWdlaXBmNlpFQW5oc081K3A1RExETXhWYi9oZTBHV09hcVA3QmF5aDh4d0RKWGZVSGxvZ01iY29VekRiRE1WWHMwYm9mSGlqWjZ5cmZSTng3TzdiQno5VDRHV1BPNEtXNjBsNmpVcCtKRk5ueHR5dTFibDJ2ME1jQ2FEOUZGTzNQbUdHQVpZQzNDMlpUcldlTlo2Sk9Zd04zdDJlZ2gvS0oxRy9BWVlEWGtiTXp0YlNQckx6dzMvTFJ2aDkveDdHZ1RmakdSQVpVQlZrUE9RN251MWFRTjI3UENXM3dMZmEvb0lLL29vbjRETEhNYTVFNzNyU05GWXA0VDNlNDc2QjdzVmp2eE5XU0FaVTVERGxrTjdOdmxxN3g4K0Ruc1V2OE51OVl0SkNkbGdHVk9JODRMMm5QaFJSM042Qm9jTE55Qkxkc1A4STNham9FM2FvQmxUdDNQaHR5R0ZZODBkMS9pNThQM1kzZjZGWHo5RklQdTJhSWRuVERBTXFmdTU0RmMyZklzOUFiZmltN0UwZW0zYVlUcWhuMEdXT1kwTEdBb05KZmZTZmliNTZMdjR3aDFtMmVIWXdaWTVqVEVuVzVxN25sWklZK3V4MEQ3S25hblA4UHU5UGw2dTFNRExIT2tPMjF2UW0vMDNlaFRSUERGVjBjdCtwc0Jsamt6SGxMalRlUVFIREQ4T2Jaczk1TG9kRGJ1MUFETEhIUE1NY2NjYzh3eHh4eHp6REhISEhQTU1jY2NjOHd4eHh4enpESEhuQ1YrL2g4V0VIeEtPZmVZa0FBQUFBQkpSVTVFcmtKZ2dnPT1cIlxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vc3JjL2Fzc2V0cy9pbWFnZXZpZXcvc3VmZml4L3Jhci5wbmdcbi8vIG1vZHVsZSBpZCA9IDEwN1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///107\n");

/***/ }),
/* 108 */
/***/ (function(module, exports) {

eval("module.exports = \"data:image/png;base64,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\"\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvYXNzZXRzL2ltYWdldmlldy9zdWZmaXgvdHh0LnBuZz82NTA3Il0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBLGlDQUFpQyIsImZpbGUiOiIxMDguanMiLCJzb3VyY2VzQ29udGVudCI6WyJtb2R1bGUuZXhwb3J0cyA9IFwiZGF0YTppbWFnZS9wbmc7YmFzZTY0LGlWQk9SdzBLR2dvQUFBQU5TVWhFVWdBQUFKWUFBQUNXQ0FZQUFBQThBWEhpQUFBUHVVbEVRVlI0WHUyZGUzUVUxUjNIdjNjM0lXQWd2SlNBRUlpQUpDRTdRUWtFaEZhVVhZcTF0cmJzbG5Qb3NWcTFldFNpb3EySVR5d3FEOTlXNjdNdmovYm95VEZGclhKRWhDaFdDYnVMaUJBUjVha2dBZ0lDSXNRa2MzdnVKRmxDMk9UZW5jek1ibVovOTU4OGZ2ZjV2Wi85L2U3Y096dkRRSWtVc0VFQlprT2RWQ1VwQUFLTElMQkZBUUxMRmxtcFVnS0xHTEJGQVFMTEZsbXBVZ0tMR0xCRkFRTExGbG1wVWdLTEdMQkZBUUxMRmxtcFVnSXJFUVk0OTVRdFhUaVVlK0JqWEM4Q1dHWnJ4VG40MFlnL05EK1I2dDJVbDhCcVpUWkhMQzN2bjhVOFBzNDlHcmp1QTJNYU9Jb1pRNVlTQUp3ZkRBZEMzWlh5dWpCVDJvTlZ1cVM4Ty9ONmZSN09OYzdnQXhjQThSR01zZlpCUVdDNThPTVNaMGhERnkzSzZ0bWxwZ2oxOVQ0R3BvRnhIK2RNWXd4NXRpaEFZTmtpYS9JcTVkd3pabm5GRUY3SGZKeHpqVEhtNCtBYTR6Z2RqSGtkNnhpQjVaalVsamRVdXJ5aUgycDF6Y3VaanpPbU1jNTlFT0VNckxQbGpTVmFJWUdWcUdMTzV4OVR0U2hIUDN6WUIrYnhNUTZOQXhxQUVRem80WHh2RkZza3NCU0ZjaUJiY1hWNXA2eWRua0l2UEJxWTdtTmlJVzE0SUF4eW9IbHJteUN3ck5WVHFUYk9XZW15VndZenhuMk1jM0VaNzJQZ3dnc1ZPTG9PVXVxc3lVd0Vsa25oRkl1TmVmdlZYQjExeHFWOHd5VTlhNFNJZFZHc29tTm1JN0NzbWJmaXl2S3VYZUgxY1IyeHF6RUFad0xvYVUwTEhhd1dBaXV4Q1N1TlJqUFpvUzhLb091YXg3Z2FNeTdseGM3MGFZblY1UExjQkpaOGdzc3FYeDRGSFRkeU1JMEJoUUF5NUtYU1BBZUJKUWVnN08yS3k4SHdOM2xPeWhGVGdNQ1N3MEJneVRWeWJRN090M0NHaW9OWm1YTTIvT2pDUTZyalZEcUVKckJVNVhSMXZqWGd6QjhPVE5tck1rb0NTMFVseXRPa1FHWFlINXlvSWdlQnBhSVM1WWtwd0xpM2VHWGdsNS9JSkNHd1pBcVp0SWNHRElhL3p3Q1RwVk9qMkZ1N3ZzVENIVnVPNjR3T1hCejFCNStYOVpEQWtpbGswajVqcUlacEEwODNXVG8xaXIydzdUTTh0bW5kY1ozaDRGZEcvS0ZuWlQwa3NHUUttYlM3RlN5ZDQ2cG9JUGkwVEJZQ1M2YVFTVHVCcFNBY2JUY29pTlFpaTF2QkF2alZZWC9vS1praTVMRmtDcG0wRTFnS3dwSEhVaEFwVFR3V0I3OG00Zzg5S1ZPRVBKWk1JWk4ydDNvc2E4RmFXdkY3QU5KTFRKTno0TXBpcmdXTDR3K1JRUEFKMmFTcGVTd0NTNmJqQ1hZQ1MwR3lNZ0pMUWFYanM3Z1ZMSjN6NmRGQTZLOHlRY2hqeVJReWFTZXdGSVFqajZVZ1VwcGNGZXJnMTBiOW9jZGxpcERIa2lsazB1NWFqMFZnbVNUQ29tSnVCUXZBZFdGLzhER1pUT1N4WkFxWnRCTllDc0xSR2t0QnBEUlpZM0hPcm84RXB2eEZwZ2g1TEpsQ0p1MXU5VmdFbGtrZ3JDcEdZQ2tvU2FGUVFhUzBDWVY4UmlRUWVsU21DSVZDbVVJbTdlNzFXQmFDTlhycHkxY3dzR2RNYXB5V3haSUYxb1pEMytMWkxldlJ1MU5uaUM5MG5ON1YvRE42NDkzenJnTTNSUDNCUjJTVHF1U3hDQ3laakNmYWt3SFd3ZG9mTUhYbEV1ei9vY2JvVUFiejRKTDhBbHlXWDJEOG5tZ2lzQkpWeklIOHlRRHI5dW9JbHV6NjhvVFJEYzdPd2V6aHBTanNsdGdUcGVLQkJjWnVERStjOHJCTVF2SllNb1ZNMnAwRzY5MDlYMkhtMnFwV2UrdGhESE9HajhLa1hQV25qeE5ZSmlmZnptSk9naVZDWUxEcUxZaWZiYVV1M2d3c08vdm5FSkNwcExoZ2NmN0hjQ0Qwa0t5OFVndTB4cExKbU53MWx2QlV3bVBKa2xqSXYxRG1sMldMMlFrc1phbWN5K2lVeC9yNHdGNWNzZXBkcFlIZFV6eTYzYUdRYy93cEVnZytLR3VRUEpaTUlaTjJwOEQ2NTlaUDhkUm02VE02TU9HVVUzR2ZOamFoMGNUOWlqMkJsWkNHbG1lZWNYb0pwdVVOdGJ6ZXBncnZxQTVqZUU0dkJQb013TFNWUzNDb3JyYlZ0bkl5TWxFeGJqSnlNam9sMUovbnYvZ01qMjlzK2V3R2RsUEVQK1VCV1VYa3NXUUttYlRiNmJIcXVJNEo3N3dHOGJNb3B5Y3V6eS9FODlzK3c1b0Q4WitKSmp5VjhGaUpwdmdQQlNHd0V0WFIwdngyZXl3QjBiejFIMkxMOTRmZ1pRd1hEeXFBOEV4UGJhNUdqYTdIeGlJODJyMitNbE5qaStleGRNWm5SaWVHN3BkVlNCNUxwcEJKdTUxZ2hmZnR4dXM3dDJGcTNoQ3NQYkFQVDIrdXhwSDZldVIxeWNiVlEzejQ3ODZ0V0xGM0YvSzZkTVUvUnA5ckFHY21FVmhtVkxPNWpGMWd2ZmpsUmp6eStjZEc3NFdudW1SUUFTNDhOUjlQYktyRzRzWmQ5NmtEaHVDcUljWEk5cmJ2cWVueHdBTEh6ZUZBOEQ2WmZPM3lXQStOR0lmeHZmdksyampPdm5UM0RpellzQm9WWjAxR3Q4WlAwdjdhR2x6NC9wdW8wZXVQeTV2bDhlTFY4ZWVoWjJiRDIzSy9yZjBCdi9yZ1RkeFdOTkpZdENhU3hDZDR4cHIzRXluU3JyeFdneVhDMndNYlBzSnJPN2VlMEsvVHNydGhybThNdnF1cnhkekc4RGl6NEF3RSt3OXUxeGpzQjJ0WnhaV000NFNIYlprRjY5WjFLNDJUOTV1R25SRWJ1Rmg4UHQ3aTZYSFhEQ2syUHBGTmFjNzZWWGhqNXpaanpaQk9ZSW5RSno2TTI0OGNiaFVVNGIzdUxCSkhOZ01nOXJaS3V2YzJQRnA3VWx5d3dHYUYvVk1XeU9wVmFubTBEV0NKam9sZDRLYmJPdW80eDlTcXQ3Q2pVYnpjckM3NHo3anprTkVvenZwRCsvRzdTS1V4bm5RQ2ErRlhXekQvMDlXeGVSU3dDQSsxNmJ1RDRDMW05eGVuNXVPMndwR3lPVmUySncyc2VEMThlTVI0ak91ZGE1amUvV1luWm42OG90V0JGSFhyaVgrTlBqZG1mMy92MTdoeHpRZkczd3Uwc1RpbjhSSlpDSGhSK0cxcy9PNWdxM1dKVU9EdjA5K3dSL2J2eHZUVi8xTVcwSTZNVm9YQ1c5YXV4TEk5TzR3dUR1MmFneWRIVGpBVzQrS0RkdDNxOTNHd3J1RjhNSk41VUg3V0pKemFPZHV5NGNUZngrSzNSUHloK2JKRzJ1V3gyZ3VXS0gvWDhGSDRhZCtCc2FvRUVMVmN4OU1qejQ3OXIzejdKano0MlpvMngrSldzRzVlVzRWM0dzOEJyeCtxNFRmTkhwZ3JGdXpQYmR0ZzZISkJ2MEc0bzZoVU50OEoyVHMwV04wek8ySGh1UE5pVnpCaUhYR2t2aTRXSXBzVzdOL1gxNlVsV0xQV1ZxR3lFYXpmRGhxRzZVUEVDMmNiMHUzVllTelp0ZDM0L2RuU0NjYTZ5c3JVb2NFU1FvaWpEeEU2NHFXbUJidE1NTGQ2ck9haDhMTDhRcHg5U2o5OGZmUUlJdnQybzJMSFprTVdjZFg4NW85L0pwTW9ZWHRjc0JodWpVd016cE5WbHZSUUtEb29icHA5Y2V3azVKL1U3YmorTmwrd3l3YmlkckNFTm8rZU1SNlhSaXV4ci9IVzR5Wk54SlhnUGNYbWR0ZmIwclhEZ3lVR0p4YjhZdUhmUEYwZWZRZnJEdTZUTVdYWTNRcVcySnI1WU8vWGVMN01iMXdkUnZmdmllbVI1ZkhnM0Q3OWNmM1FFdlRxMUxEWFoyV0t1L1BPY1ZzMEVKd3JheWNsUEpib1pNdUZxZmpmTTVzL3dkKzNmaW9iZzZ2QkVyZkVGT2YweEtiREIvSGtwbXBqYjJwc3IxeE03cHRuSEN4MzluaVY5REdUcVJXUGRXZGtZdkJ1V1gwcEFkYkFrN3JpcFRHVFR0alErMEhYRVZ5eEdMdHJqc2pHa1hJZVMweSsxcjJYdE44cUdjU3JVK1o5K2lGRzlqZ1pnZHc4MDJkL0ttMDF6eE1YTE01blJ3S2hPYks2YkFCckhNWTFIdk1zMy9NVmJtcmpCdittenJWMVJTUEN3QTJOZTF0dERXYXVyeXoyVWlTeHNKMytVWEwzc1dUQ0oySmZmczZGRU1kYlRxZTR0eVlEZDRYOXdUL0wrbUlEV09vYnBLSno1L2NkaU5uRFI4WDZLVFlEeFJuaTZKNTlZdis3NmVNVldQN056amJIa21wckxDczkxcVg1aGUwK25wR0JFTThlZitjOWFXQ3BleXdCME10blRVYVB6SVk3RzQvVzF5Tll0ZGo0ZEphUG5SVDdrdVd1bzBjUXFsb01FUnBiUzZubXNleTgwYzhNSkdiS3BKakhVZ2VyNVFuOEU1dXI4ZHpXaHAza2E0ZjRjTkdnWVRFOVpQZDJFMWhtMEdtN1RJY0VhMmpqVjVHYVlyRTRmSjVhdGNTNDNWYWt6bDR2S3NaT3hzbFpuWTIveGYrRnZlbVF1cVVrQkpaallQMDU3QS9lSld2TmhqV1czR09KUnNYaGMvT3ZmSXZGdGxoME4wOC95YzNEM2NXalkvOWF0WDhQcmxuOVh0d3hFVml5cVU3YzNvckhTbDJ3cHZRZmpKc0xqdDJMVmJsN0IyYXRXeGwzNU0rVVRzQ0labWRndDY0TFkrbnVodk94NW9uQVNod2NXWW1VQWt1RU9IR3dMTkszdFRYR2ZVTXRVMEczSHVqYTdEN3NqZDhkd0lGV3ZoNHVIc2VUbjMzc3FFZmtFL2xicHRPeWMySzd6K0tyNXAvSHlTTVQwa3E3V3hmdm5QTTVrVUJvdGt3cnkwT2hyTUYwc1JOWUNqUGQyaDJrQ2tYVE5ndUJwVEQxQkphQ1NDMnlFRmdLbWhGWUNpS2xEVmk0T3hJSTNpbFRoTlpZTW9WTTJ0M3JzUWdzazBoWVU0ekFVdENSUXFHQ1NDMnlqTzJkQ3kzSG10dG1FbSs5N1JMaVBpNlZweW5IZnlnSTdvbjRnM2ZJK2tTaFVLYVFDKzJ6aTBiaC9IN0h2aG5WMmhBSkxCZE92cDFESXJEc1ZEZU42eWF3MG5qeTdSeDZlOEFDK0wxaGYraDJXZjlvalNWVHlJVjJBcXNEVDZwYnR4dklZeVVaU3RlQ3hURTNIQWplSnBPWFFxRk1JWk4yQWt0Qk9Ob2dWUkFwVGM0S1FSNHJjUmlzTE9GV2o4VTU1a1VDd1Z0bFdsRW9sQ2xrMGs1Z0tRaEhvVkJCcERRSmhlU3hFbWZCMGhJRHVtUWp0L05KbHRacFZXVVhEeHdHY1VndVM2MjhTNGRDb1V5NGRMVzNaNE9VZzgrUCtFTzN5TFNqTlpaTUlSZmFDU3dYVG1vcURJbkFTb1ZaY0dFZjJnY1dGa1Q4d1ZreVdTZ1V5aFF5YVhmdDRoMEVsa2trckNubTJuMHNBc3NhUU16V1FtQXBLRWNicEFvaXBja0dLVGp1Q3dlQ044c1VvVFdXVENHVGRyZDZMQUxMSkJCV0ZTT3dGSlNrVUtnZ1V0cUVRbjUvT0JDYUtWT0VRcUZNSVpOMjkzb3NBc3NrRXRZVUk3QVVkS1JRcUNCUzJvUkN1dWM5Y1Jvc0xPRmFqNVdzTjFOWU9EY2R1aXEzZ3FVelBqTTZNWFMvYkhKbzhTNVR5S1RkdFdDQlh4djFoeDZYeVVKZ3lSUXlhWGNyV0dDNElEd3grSVpNRmdKTHBoRFpqMU9nRnNoZjdROXVrOGxDWU1rVUludE1BUTZzaS9pRG1vb2tCSmFLU3BUSFVFRG5iRm8wTU9VbEZUa0lMQldWS005Mnp0bXNTR0RLdjFXbElMQlVsVW93SCtlb1lRenpFeXlXRXRrNVVBZGdPeGpib3RmWGJWa1YrTFg0dmZXWFJjYnBOWUZsMDFSeXpnOUVBcUVlTmxXZjh0VVNXRFpORVlHbElPeW9wUXZMR1BRYkdPY2xBQXJBbVBOdnZsYm9aeXBsSWJBU25JM2k2dkpPMmJzeWlyaXVhd3hNNDR3YlB3RU1TTEFxVjJjbnNDeWFYdTI5MTN0MnFUbmkwOEZLUERIZ1VBS3dyaFkxMGFHcUliQnNucTR6bDFZTXl1Uk00eDZ1TWM0MURwUXdzQUlBR1RZM25kVHFDYXdreUMvQ2FkWk9UNkVYSGcxR0tPVWE1MHhqREhsSjZJNHRUUkpZdHNocXJ0SXpLaGYyOElMN1BQVzhoREhoM1pqR0lNSXBqcjI3MTF6VmpwY2lzQnlYUFBFR1M1ZVVEL1I2dlExaDFBaW5CbkNGcVJ4T0NhekU1emtsU3BSR281bll2NzNRNjYzWE9CZnJONlp4Y0kweEpuLzdrQU1qSUxBY0VObkpKa3FYbEhkSFJvYm0wWFVOd3JOeGFHQVk0WFE0SmJDY25QVWt0alg2M1ZmeWVIMmQ1dUVldzhNQlloM0hpdXdLcHdSV0VpYzcyVTJMY01vT2ZWRUFzZG5MeFNhdkVVckZadStnOXZhTndHcXZnaTRzUDZacVVZNSsrTENQZ1pVWTJ5QVFIZzRqd0ZpTzZuQUpMRldsS0IvR1ZGWU1xTmM5bW9mcll0M1c1aU9ST2ZqUmlEL1VJVytic1dLcWxlNXVzS0locWlPOUZDQ3cwbXUrSFJzdGdlV1kxT25WRUlHVlh2UHQyR2dKTE1la1RxK0dDS3owbW0vSFJrdGdPU1oxZWpWRVlLWFhmRHMyV2dMTE1hblRxeUVDSzczbTI3SFJFbGlPU1oxZURmMGZCdm9XSG95WnF4d0FBQUFBU1VWT1JLNUNZSUk9XCJcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL3NyYy9hc3NldHMvaW1hZ2V2aWV3L3N1ZmZpeC90eHQucG5nXG4vLyBtb2R1bGUgaWQgPSAxMDhcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///108\n");

/***/ }),
/* 109 */
/***/ (function(module, exports) {

eval("module.exports = \"data:image/png;base64,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\"\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvYXNzZXRzL2ltYWdldmlldy9zdWZmaXgveGxzLnBuZz9hODM1Il0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBLGlDQUFpQyIsImZpbGUiOiIxMDkuanMiLCJzb3VyY2VzQ29udGVudCI6WyJtb2R1bGUuZXhwb3J0cyA9IFwiZGF0YTppbWFnZS9wbmc7YmFzZTY0LGlWQk9SdzBLR2dvQUFBQU5TVWhFVWdBQUFKWUFBQUNXQ0FZQUFBQThBWEhpQUFBTzVVbEVRVlI0WHUyZGVYZ1VSUnJHMytwT1FrSk1ZQUVGUXhhQ0JPU0JUSVROK3NpaEVrUlFRTmoxaUFkeUk0Z3JpQkVWWllVTklDQ0tNd0s2eUNVM0NuaXNzRzRnTXloZWk0c2JZUkVWVjJSbk9CUVFrVU1Ja0dScW4rNGhrNXZxbVo2ZW1XNisvb3RNVlgxVi9YNC82dTRxQm5wSUFRTVVZQWJZSkpPa0FBZ3Nnc0FRQlFnc1EyUWxvd1FXTVdDSUFnU1dJYktTVVFLTEdEQkVBUUxMRUZuSktJRkZEQmlpQUlGbGlLeGtsTUFpQmd4UmdNQVN5WnJYTGk3MWx5WnRaQVliazVpTmMyUXd3QWJHbW9tU3V2ZlhqOEc2ZGFXaWVGWU1KN0RLdmNxYVA5NHp6ZXZsTmduY3BzRERPY3NBMElZeHlNRTRuOEFLUmpVVHAwa1psOTBvbHNzMjdtVVpURUlaUkptTW9XNG9YNHZBQ3FXYVVXUXJaV1JXWFRteFFWc1ozTVlaOHpWaDREYUFOUWxITVFtc2NLaHNaQjQ1T1hLTGxLUHBwVXl5U1V5eWNhaTFVQVlIVDJlTVJheTVKN0NNZEhxSWJhZm0zdFEwUnBJeU9ML1FoQ2tRY2RZV0RIVkNuSlZ1Y3dTV2JnbERiNkRCbUY3SlNiSG5NaGhrRytjOGc0SFp3SGg3Z05VTGZXN0dXQ1N3ak5GVm0xVmxPSC9peXF0bFgvTmw0K3pDY0I2c3VUWUQwUnVMd0FxUGIxamFvOW5OdlN6T3hzcUc4d3daQUcvRHdHTENVNFR3NWtKZ2hWanZwZzkzYnhnYnkveTFqOUtaQm1PWkRFZ01jVlpSYlk3QUN0STlxYm1kRWlRcHFhM0V1WDlHV2gyUk1Wd1pwRWxMSlNPd1JPN01nOVQwWlBmMEdEQmZQd2krZmhEbmFCWEo0YnlvMkpFT054U3NQRWo0SVV0T1MwbVNpMzZOazR2UHlYS3lYQ1FWRjh0eVNZSXN4NWN3dWFUMG5Cd1hKOG1sWGtuMm9rU0s5VEs1TkVhU3ZWNG14M0FtZTJVbWU3MGxzc3laekNGSkVuaXNvbG1wN1BWQ3dzSDlKMDdzdzRMQzRtQjAxRFRIMHp5MyszREdwRVhCWkVCcHpLc0FCN3dNZkQvbjdBc21zUW51Rnd0MmEzMGJBa3VyVXBkNFBNNVJDbDdhMS9QUysvbGFwQ0N3dEtoRWNWUUZPT2RmZUJ5dUxDMXlFRmhhVktJNGZnVktTdEQ2d0J6bmR5SkpDQ3lSUWpyQ1Y0MTZIcklrNmJBUSthU1Bybm9PaDA0Y3JWQVE3NzF1KytZMW9wSVJXQ0tGZElSL1Ayc1RwTWl0Z2Vzb2VYblNiak9Hd0gzMEIvOFBITjVKSHZ2bXFTTGpCSlpJSVIzaFZnUUxITFBkRHVlaklsa0lMSkZDT3NLdENCYm5XT3h4T0I4UXlVSmdpUlRTRVc1SnNJQ1ZIcnR6b0VnV0FrdWtrSTV3aTRMMXVzZnU3QytTaGNBU0thUWpuTUFTaUVkTE9zSFJaVW13T0YvdGNianVGeWxDTlpaSUlSM2hCQmJWV0Ryd3FUM3BkUzB6b2ZWYmpxVDRSQ3dZbWxmTjJFK25qbUhNOHVraExWK0h0RFlZMzBjNHNGUHpyRGFQUlRWV1NIMWh1TEVHaWZWUU9HVmR0WHoySHp1RUc2Y05DbW4rWGR0Y2k2VWpwbW15V1gyQ2xLL3kyRjBEUkltcEtSUXBGS1p3QWl0TVFsOXEyWmdITEpySE1oV2JCSmFwM0dXZXdoSlk1dkdWcVVwcUdyQTRYK0Z4dUlTakNlcThSd2wrQkZhVU9NSnF4VEFMV0FCZjdyYTdCb3YwcHhwTHBGQ1l3Z21zTUFsdGhXeXNPUE1Pam1WdWgzT0l5RDlVWTRrVTBoRnV4YlZDQWtzSEVLRktTbUFKbEtSdE04R2haa213Z0tWdXUzT29TQkZxQ2tVSzZRZ25zS2pHMG9GUDdVbXRDQmJuZkluSDRSb21Fb3hxTEpGQ09zSUQrV0ExUm81QlZscmJhcm1kS3ptUDdlNXZkSlNpZXRMNmljbG9jMlVMVFRacjJJOUZZR2xTTGtvaW1XVWVpMnFzS0FGR2F6Rk1BeGI0YXg2N2E3am92YWdwRkNrVXBuQUNLMHhDWDJyWm1BWXMraExhWEdnU1dPYnlsMmxLUzJDWnhsWG1LcWhwd0FJV2Vlek9FU0oxcWZNdVVpaE00UVJXbUlTKzFMSXhEMWg4b2NmdUdpbnlqNjRhYTNqWE81RVU3N3M3a25PTytSK3N3OW5pYzlYeTdOZ3lFeDNUci9IL3Z1V2J6N0ZqMzI3RVNESiszNktkLy9kdkQ3bnh5K21Ub2pKWENtOVNyeEU2dDJxUDlDdWFvVm1qRk1oTXd1NGY5MkxYZ1QzNCtOdENuQzhONnBqeWdNb1Fpc2dFVmdVVmg5MTRPeWIrNFNIL0w3TUxWdUNsVFNzcTZWd25KaFlmL25rNUdpYzNWSDgvVVhRS04wNGJqSk5GditJM2ljbjRZc3FiL3ZnUExadUNqVHMvMGV5bnZ1MnpNZk9leDVBUUYxOWpHdVh6OURrRnE3RHlueHMwMnd4bFJDdXVGWUx6Qlc2SDYwR1JUcnBxTElsSktIaHlJVnBlOFZzMW4vTWx4YmhoMmtBY09YbXNISmJ1OStMSjN1VnJscys4T1J1cnRyNm5odXNCUzhuenZYSHpVQ2NtVHZTT0dML0dqclhiTmdyamhUb0NnU1ZROUdMN3NiTFMydUhOTVE2L2hiYytMOERqYjh4Uy82NlhrSVN0azFiNWE1UTloL2VoeC9QbGgxSG9BV3ZPZ0tmUnQwTTNOWjlTcnhmdkZMclVwcS9FVzRvYldtZmg3dXR1Z1FLKzhwdzVmeGFkcDl5djFwYmhmQWdzSFdBcFNlY09uSURiMm1mN3JmU3hQNFN2RDM2UEtYZU14c0F1L2Z5LzU3eWNpMy8vN3l2LzMzckEyalg5WFNUV1NWQnRQYlhXZ1RYL3FueGh3djJkK3VEWnU4YjY4eHE2NkJscytXWmJPTG1DSmNFQzVydnR6bEVpSVhVMWhXWEdMMDlxZ0E4bkxQWFhURHM4dTVHN2VpWmM0eGY3enpuLys0NHRHTE9pOG5FOHdZS2xIQTIwNTRWOGY0MDBkdVVNck4vK1FhVjNqWk5qVVRoMUhZck9uMVVIQlBQZVg0Ty9GVzRXNlJIU2NBSkxaNDJsSkI5MTA5MlZ6bHphOS9PUGFOYlFkN3VjMHZlNi90bUJVRHJURlo5Z3dWSnM1RDgrMzcrblNEbmcvc1g4cGRpd2ZRdVUvVXZSOGxnU0xNNWZkVHRjNVNPMldzUU9TWTJsMkZZMnFtMGV2OWdQVThYODdCdVhZYTV6VmJVaVZCMWkvMm5aVk9Udi9GZ1RGNE82OU1Qa08wWlhpbHQwL2h6V2IzOWZCV3pybmgzd2NxN0pWalJFTXN0MEE4SU5sdUljWlQ1SjJUVlo4VG40eXhIY05HTm9qZk5KZW1xc3FyVldWVGlVMmpGLzV5ZFl0MjBUZGgwUVh2MFNjYllJckl1NFFPbE1iOHRiZzdvVjVwVm01Uy9CSzY3WGEweWxGeXdsL1pRN3h1QzI5bDFyTFpVeWNUc3JmeW4rdXJubU1rU2NxQXNGSUxBdTRnbWxhVkthcUlxUFVuTmtUeCtpRHZtclBuckJLck4zMWVXcDZIWE5EZWlaMFFXMjFGWTFudnY1d09KSjJQejFaOUhDa2JCYlVCWWgybzZLREh0VGVIV1ROTFZEWGROaHJzcy9YWSsvdlAyeVlXQlZOS3o4ejcrKzllL1FJNk56cFpyc3N6My93WDN6bmlDd0FPZzVnelRzWUszUGZVV3RMY3FldlVmMjQ2b0xNL0pLYzlUdnBkSFYranJCMWxpdEdqZEg2eWJOb1h4dGNyTG9ORFpVbVdvb0s4T01uRnpjMjdHWCt1ZnhNNmZRWWVLZEJKYVp3THF2WTI5TXp5bS9FRXFaczFMV0REYzlzZEEvajZVc01QZWVOUXBlN3ZVN04xaXdLazV0bkRwN0dwbC92cjFHWVBwMzZvTnBGU1pKVzR6clNXQ1pCYXprK0VSOC9Nd0tKQ2RjcGpwTm1aRHNPbjJJT21jMW9lOUlqTWkreSsvTXFlKytpdGMrZWxzM1dPMmJ0Y0U3WStmNDdiendqeVUxZHM0ckx2c2NQdmt6T2s2K2o4RFNDMWE0WnQ2ZnV6c1g5MXpuYTI2VVo4YUdoVml3eFhkZWVYeHNIWHc0WVJtdVNHNmcvcTFzcWVrMlk2ai94czZxTlpaajQzSnMyN3V6VnVlZk9uc0dYeDNjbzRhLzk5Zzh0RzNhVXYyM2I4dk9XbldoK2NmalI5V0owd0dkYjhPZDE1YlhVTW9PaDRsdnpTV3d6QUNXMHFkUytsWmx6L2RIOXVQV0YwYXFDOEZsVDc4TzNUQjd3TlArdnd0MmZZb0hsMHhXLzY0S2xzanJ5bExSN1hNZVVhTlZyYlV1bGxicFgvVjhma1MxbVg5UmZ1RU1OODEwZzlFMWxySnpRTm0yVXZGVDdidm01cUxRWGI3SVhPYVlkYU1kbFRiMERWN3dORDc2dGxBWFdJcnQwVGYzUis2dGcveHJoaldCOE91NU14aSthQ0syN2YweW5KeW9lVDNTYzREbXEzc1RZdU14c2x0T3RUSXErOVlxZGg5QzhSSnBqWnJpajFuZE5abXErb2s5akFhclM2c09HTk9qL0JLb0x3LzhGOVBXTDZpeHNLMmJwS2s3SGNxZUg0Ny9oTWRXejFSM255NGNOa1hUQ3lxUnZqdnNxZGFjS1dBLzBYc1ltamRLUWNQTDZxTiszU1RWbnJKRnhybHJLMllYck1TQlk0YzA1eEhLaUJaZEt6UitvMThvbldCRld3U1d3S3QwOEZwdzJCTllCRlp3NUFoU0VWZ0VGb0ZWaXdMVk91L2grSmpDRUc5WXlLZ1ZSNFVjWWZpdTBFSU1SUHhWekRLUFJXQkZISlhBQ2tCZ0JhWVh4ZGFvQUlHbFVTaUtGcGdDQkZaZ2VsRnNqUXFZQnl3NnhraWpTNk1qR29FVkhYNndYQ2tJTE11NU5EcGVpTUNLRGo5WXJoUUVsdVZjYXR3TFdmRWlURTdIY1JzSGpGYkxWbHlFSnJDMGV0L0FlQVFXN1c0d0JDOENpOEFpc0dwUm9QcTFjbGpzY1RqTGoyV3NKVjNJampFeXhETW1OMnJKR290dS80bzhsWmE4Q0pQQWlqeFlnWlRBUFBOWWRGOWhJSDZOZUZ3Q0srSXVzR1lCQ0N4citqWGliMlVhc09nVys0aXpFbEFCQ0t5QTVLTElXaFVnc0xRcVJmRUNVb0RBQ2tndWlxeFZBYk9BQlk1bGJvZHppT2k5YU9aZHBGQ1l3azBERnZoeXQ5MDFXQ1FMZ1NWU0tFemhaZ0dMYzc3QzQzQU5Fc2xDWUlrVTBoRnV5U1VkemxkN0hLN3lnOUZvRVZvSElVRW10ZVlpTkY3MzJKMzlSWkpRalNWU1NFZTRGY0VDNTJ2ZER0YzlJbGtJTEpGQ09zS3RDQllIZjh0amQ1V2ZzVTVOb1E1Q2dreHFSYkRBOFliYjRSUWVtRTgxVnBEUWFFbG1SYkE0clJWcWNiMnhjU3dKRnZDS3grNnNmQU5wRFRKU2pXVWdXMVlFQytDVDNYWlhua2cyQWt1a2tJNXdLNExsQlFidXN6dFhpbVFoc0VRSzZRZ1A1RXRvSGRrWW1sUzVaa2E1QTZuODRaM2NkcGZ3UmxFQ3kxQzNXTTA0UDFza1NZME96eW80TFhvekFrdWtFSVZYcksxbXV1MnVwN1JJUW1CcFVlbFNqOFB4RTRCSmJvZHp2bktMbnhZNUNDd3RLZ1VkaC92dXp6UHB3ems3QlZhNjFaUHMzWWE4TFNXQnZBYUJGWWhhQWNaMTI1MmE5QTNRckNtaWEzdnhuQnk1UmNyUjlGSTVKcE1CTmdadTQ0QU5IRmV4bXE2dE44V3JHMTlJQWl0SWpWTkdadFdWRXV0bHlHQTJCc2tIRzlDZU1manU2cjNFSHdJcnhBQzBHTnU5Y2FuRWJCSlFCcHVOTVdRQUxEN0VXVVcxT1FJckhPN0pnNVI2ckVkTFdlSTJKaUdUYzZWSlpUWU9ubTdWNXBUQUNnZFl0ZVNSbXRzcGdlR3lkbkpadjAzdHc4RUd4aHBIc0ZnaHlackFDb21Nb1RXU01pNjdVV3hwWENaanZvR0NBaHNIdHpIR0VrS2JrM0hXQ0N6anRBMjFaWmFhbTkxU1Jxd2ZObldFeWxnckJraWh6a3l2UFFKTHI0SVJUcCtXbHgzUGowdHRHVlA2YkpJeVVNZ0V1QTFnVFNKWk5BSXJrdW9ibUhmVGg3czNqS21EVEY5VEt0a1k5NDFTR1VOZEE3UDFteWF3d3FGeTlPVEJtdVhlM0tKc0tvUXhsZ25mdEVqclVEZW5CRmIwT0QxaUpVa2YwNnRPY1d4eDI3S0JnbSt3b0U2SnBBUmJLQUlyV09VdWdYU3B1YmMwaUlIWDV1VThrMGxsbzFObHBRR0pvdGNuc0VRS1VUZ3BFS0FDMmhhaEF6UkswVWtCQW9zWU1FUUJBc3NRV2Nrb2dVVU1HS0lBZ1dXSXJHU1V3Q0lHREZHQXdESkVWakpLWUJFRGhpaEFZQmtpS3hrbHNJZ0JReFQ0UDlsWGdSNnJuT003QUFBQUFFbEZUa1N1UW1DQ1wiXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9zcmMvYXNzZXRzL2ltYWdldmlldy9zdWZmaXgveGxzLnBuZ1xuLy8gbW9kdWxlIGlkID0gMTA5XG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///109\n");

/***/ }),
/* 110 */
/***/ (function(module, exports) {

eval("module.exports = \"data:image/png;base64,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\"\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvYXNzZXRzL2ltYWdldmlldy9zdWZmaXgveGxzeC5wbmc/MTYwNSJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSxpQ0FBaUMiLCJmaWxlIjoiMTEwLmpzIiwic291cmNlc0NvbnRlbnQiOlsibW9kdWxlLmV4cG9ydHMgPSBcImRhdGE6aW1hZ2UvcG5nO2Jhc2U2NCxpVkJPUncwS0dnb0FBQUFOU1VoRVVnQUFBSllBQUFDV0NBWUFBQUE4QVhIaUFBQU81VWxFUVZSNFh1MmRlWGdVUlJyRzMrcE9Ra0pNWUFFRlF4YUNCT1NCVElUTitzaWhFa1JRUU5qMWlBZHlJNGdyaUJFVlpZVU5JQ0NLTXdLNnlDVTNDbmlzc0c0Z015aGVpNHNiWVJFVlYyUm5PQlFRa1VNSWtHUnFuKzRoazV2cW1aNmVtVzYrL290TVZYMVYvWDQvNnU0cUJucElBUU1VWUFiWUpKT2tBQWdzZ3NBUUJRZ3NRMlFsb3dRV01XQ0lBZ1NXSWJLU1VRS0xHREJFQVFMTEVGbkpLSUZGREJpaUFJRmxpS3hrbE1BaUJneFJnTUFTeVpyWExpNzFseVp0WkFZYms1aU5jMlF3d0FiR21vbVN1dmZYajhHNmRhV2llRllNSjdES3ZjcWFQOTR6emV2bE5nbmNwc0RET2NzQTBJWXh5TUU0bjhBS1JqVVRwMGtabDkwb2xzczI3bVVaVEVJWlJKbU1vVzRvWDR2QUNxV2FVV1FyWldSV1hUbXhRVnNaM01ZWjh6Vmg0RGFBTlFsSE1RbXNjS2hzWkI0NU9YS0xsS1BwcFV5eVNVeXljYWkxVUFZSFQyZU1SYXk1SjdDTWRIcUliYWZtM3RRMFJwSXlPTC9RaENrUWNkWVdESFZDbkpWdWN3U1diZ2xEYjZEQm1GN0pTYkhuTWhoa0crYzhnNEhad0hoN2dOVUxmVzdHV0NTd2pORlZtMVZsT0gvaXlxdGxYL05sNCt6Q2NCNnN1VFlEMFJ1THdBcVBiMWphbzluTnZTek94c3FHOHd3WkFHL0R3R0xDVTRUdzVrSmdoVmp2cGc5M2J4Z2J5L3kxajlLWkJtT1pERWdNY1ZaUmJZN0FDdEk5cWJtZEVpUXBxYTNFdVg5R1doMlJNVndacEVsTEpTT3dSTzdNZzlUMFpQZjBHREJmUHdpK2ZoRG5hQlhKNGJ5bzJKRU9OeFNzUEVqNElVdE9TMG1TaTM2Tms0dlB5WEt5WENRVkY4dHlTWUlzeDVjd3VhVDBuQndYSjhtbFhrbjJva1NLOVRLNU5FYVN2VjRteDNBbWUyVW1lNzBsc3N5WnpDRkpFbmlzb2xtcDdQVkN3c0g5SjA3c3c0TEM0bUIwMURUSDB6eTMrM0RHcEVYQlpFQnB6S3NBQjd3TWZEL243QXNtc1FudUZ3dDJhMzBiQWt1clVwZDRQTTVSQ2w3YTEvUFMrL2xhcENDd3RLaEVjVlFGT09kZmVCeXVMQzF5RUZoYVZLSTRmZ1ZLU3RENndCem5keUpKQ0N5UlFqckNWNDE2SHJJazZiQVErYVNQcm5vT2gwNGNyVkFRNzcxdSsrWTFvcElSV0NLRmRJUi9QMnNUcE1pdGdlc29lWG5TYmpPR3dIMzBCLzhQSE41Skh2dm1xU0xqQkpaSUlSM2hWZ1FMSExQZER1ZWpJbGtJTEpGQ09zS3RDQmJuV094eE9COFF5VUpnaVJUU0VXNUpzSUNWSHJ0em9FZ1dBa3Vra0k1d2k0TDF1c2Z1N0MrU2hjQVNLYVFqbk1BU2lFZExPc0hSWlVtd09GL3RjYmp1RnlsQ05aWklJUjNoQkJiVldEcndxVDNwZFMwem9mVmJqcVQ0UkN3WW1sZk4yRStuam1ITTh1a2hMVitIdERZWTMwYzRzRlB6ckRhUFJUVldTSDFodUxFR2lmVlFPR1ZkdFh6Mkh6dUVHNmNOQ21uK1hkdGNpNlVqcG1teVdYMkNsSy95MkYwRFJJbXBLUlFwRktad0FpdE1RbDlxMlpnSExKckhNaFdiQkphcDNHV2V3aEpZNXZHVnFVcHFHckE0WCtGeHVJU2pDZXE4UndsK0JGYVVPTUpxeFRBTFdBQmY3cmE3Qm92MHB4cExwRkNZd2dtc01BbHRoV3lzT1BNT2ptVnVoM09JeUQ5VVk0a1UwaEZ1eGJWQ0Frc0hFS0ZLU21BSmxLUnRNOEdoWmttd2dLVnV1M09vU0JGcUNrVUs2UWduc0tqRzBvRlA3VW10Q0JibmZJbkg0Um9tRW94cUxKRkNPc0lEK1dBMVJvNUJWbHJiYXJtZEt6bVA3ZTV2ZEpTaWV0TDZpY2xvYzJVTFRUWnIySTlGWUdsU0xrb2ltV1VlaTJxc0tBRkdhekZNQXhiNGF4NjdhN2pvdmFncEZDa1VwbkFDSzB4Q1gyclptQVlzK2hMYVhHZ1NXT2J5bDJsS1MyQ1p4bFhtS3FocHdBSVdlZXpPRVNKMXFmTXVVaWhNNFFSV21JUysxTEl4RDFoOG9jZnVHaW55ajY0YWEzalhPNUVVNzdzN2tuT08rUitzdzluaWM5WHk3Tmd5RXgzVHIvSC92dVdiejdGajMyN0VTREorMzZLZC8vZHZEN254eSttVG9qSlhDbTlTcnhFNnQycVA5Q3Vhb1ZtakZNaE13dTRmOTJMWGdUMzQrTnRDbkM4TjZwanlnTW9RaXNnRVZnVVZoOTE0T3liKzRTSC9MN01MVnVDbFRTc3E2VnduSmhZZi9uazVHaWMzVkg4L1VYUUtOMDRiakpORnYrSTNpY240WXNxYi92Z1BMWnVDalRzLzBleW52dTJ6TWZPZXg1QVFGMTlqR3VYejlEa0ZxN0R5bnhzMDJ3eGxSQ3V1RllMekJXNkg2MEdSVHJwcUxJbEpLSGh5SVZwZThWczFuL01seGJoaDJrQWNPWG1zSEpidTkrTEozdVZybHMrOE9SdXJ0cjZuaHVzQlM4bnp2WEh6VUNjbVR2U09HTC9HanJYYk5ncmpoVG9DZ1NWUTlHTDdzYkxTMnVITk1RNi9oYmMrTDhEamI4eFMvNjZYa0lTdGsxYjVhNVE5aC9laHgvUGxoMUhvQVd2T2dLZlJ0ME0zTlo5U3J4ZnZGTHJVcHEvRVc0b2JXbWZoN3V0dWdRSys4cHc1ZnhhZHA5eXYxcGJoZkFnc0hXQXBTZWNPbklEYjJtZjdyZlN4UDRTdkQzNlBLWGVNeHNBdS9meS81N3ljaTMvLzd5di8zM3JBMmpYOVhTVFdTVkJ0UGJYV2dUWC9xbnhod3YyZCt1RFp1OGI2OHhxNjZCbHMrV1piT0xtQ0pjRUM1cnZ0emxFaUlYVTFoV1hHTDA5cWdBOG5MUFhYVERzOHU1RzdlaVpjNHhmN3p6bi8rNDR0R0xPaThuRTh3WUtsSEEyMDU0VjhmNDAwZHVVTXJOLytRYVYzalpOalVUaDFIWXJPbjFVSEJQUGVYNE8vRlc0VzZSSFNjQUpMWjQybEpCOTEwOTJWemx6YTkvT1BhTmJRZDd1YzB2ZTYvdG1CVURyVEZaOWd3VkpzNUQ4KzM3K25TRG5nL3NYOHBkaXdmUXVVL1V2UjhsZ1NMTTVmZFR0YzVTTzJXc1FPU1kybDJGWTJxbTBldjlnUFU4WDg3QnVYWWE1elZiVWlWQjFpLzJuWlZPVHYvRmdURjRPNjlNUGtPMFpYaWx0MC9oeldiMzlmQld6cm5oM3djcTdKVmpSRU1zdDBBOElObHVJY1pUNUoyVFZaOFRuNHl4SGNOR05vamZOSmVtcXNxclZXVlRpVTJqRi81eWRZdDIwVGRoMFFYdjBTY2JZSXJJdTRRT2xNYjh0Ymc3b1Y1cFZtNVMvQks2N1hhMHlsRnl3bC9aUTd4dUMyOWwxckxaVXljVHNyZnluK3Vybm1Na1NjcUFzRklMQXU0Z21sYVZLYXFJcVBVbk5rVHgraUR2bXJQbnJCS3JOMzFlV3A2SFhORGVpWjBRVzIxRlkxbnZ2NXdPSkoyUHoxWjlIQ2tiQmJVQlloMm82S0RIdFRlSFdUTkxWRFhkTmhyc3MvWFkrL3ZQMnlZV0JWTkt6OHo3Kys5ZS9RSTZOenBacnNzejMvd1gzem5pQ3dBT2c1Z3pUc1lLM1BmVVd0TGNxZXZVZjI0Nm9MTS9KS2M5VHZwZEhWK2pyQjFsaXRHamRINnliTm9YeHRjckxvTkRaVW1Xb29LOE9NbkZ6YzI3R1grdWZ4TTZmUVllS2RCSmFad0xxdlkyOU16eW0vRUVxWnMxTFdERGM5c2RBL2o2VXNNUGVlTlFwZTd2VTdOMWl3S2s1dG5EcDdHcGwvdnIxR1lQcDM2b05wRlNaSlc0enJTV0NaQmF6aytFUjgvTXdLSkNkY3BqcE5tWkRzT24ySU9tYzFvZTlJak1pK3krL01xZSsraXRjK2VsczNXTzJidGNFN1krZjQ3Ynp3anlVMWRzNHJMdnNjUHZrek9rNitqOERTQzFhNFp0NmZ1enNYOTF6bmEyNlVaOGFHaFZpd3hYZGVlWHhzSFh3NFlSbXVTRzZnL3Exc3FlazJZNmoveHM2cU5aWmo0M0pzMjd1elZ1ZWZPbnNHWHgzY280YS85OWc4dEczYVV2MjNiOHZPV25XaCtjZmpSOVdKMHdHZGI4T2QxNWJYVU1vT2g0bHZ6U1d3ekFDVzBxZFMrbFpsei9kSDl1UFdGMGFxQzhGbFQ3OE8zVEI3d05QK3Z3dDJmWW9IbDB4Vy82NEtsc2pyeWxMUjdYTWVVYU5WcmJVdWxsYnBYL1Y4ZmtTMW1YOVJmdUVNTjgxMGc5RTFsckp6UU5tMlV2RlQ3YnZtNXFMUVhiN0lYT2FZZGFNZGxUYjBEVjd3TkQ3NnRsQVhXSXJ0MFRmM1IrNnRnL3hyaGpXQjhPdTVNeGkrYUNLMjdmMHluSnlvZVQzU2M0RG1xM3NUWXVNeHNsdE90VElxKzlZcWRoOUM4UkpwalpyaWoxbmROWm1xK29rOWpBYXJTNnNPR05Pai9CS29Mdy84RjlQV0w2aXhzSzJicEtrN0hjcWVINDcvaE1kV3oxUjNueTRjTmtYVEN5cVJ2anZzcWRhY0tXQS8wWHNZbWpkS1FjUEw2cU4rM1NUVm5ySkZ4cmxySzJZWHJNU0JZNGMwNXhIS2lCWmRLelIrbzE4b25XQkZXd1NXd0t0MDhGcHcyQk5ZQkZadzVBaFNFVmdFRm9GVml3TFZPdS9oK0pqQ0VHOVl5S2dWUjRVY1lmaXUwRUlNUlB4VnpES1BSV0JGSEpYQUNrQmdCYVlYeGRhb0FJR2xVU2lLRnBnQ0JGWmdlbEZzalFxWUJ5dzZ4a2lqUzZNakdvRVZIWDZ3WENrSUxNdTVORHBlaU1DS0RqOVlyaFFFbHVWY2F0d0xXZkVpVEU3SGNSc0hqRmJMVmx5RUpyQzBldC9BZUFRVzdXNHdCQzhDaThBaXNHcFJvUHExY2xqc2NUakxqMldzSlYzSWpqRXl4RE1tTjJySkdvdHUvNG84bFphOENKUEFpanhZZ1pUQVBQTllkRjloSUg2TmVGd0NLK0l1c0dZQkNDeHIralhpYjJVYXNPZ1crNGl6RWxBQkNLeUE1S0xJV2hVZ3NMUXFSZkVDVW9EQUNrZ3VpcXhWQWJPQUJZNWxib2R6aU9pOWFPWmRwRkNZd2swREZ2aHl0OTAxV0NRTGdTVlNLRXpoWmdHTGM3N0M0M0FORXNsQ1lJa1UwaEZ1eVNVZHpsZDdISzd5ZzlGb0VWb0hJVUVtdGVZaU5GNzMySjM5UlpKUWpTVlNTRWU0RmNFQzUydmREdGM5SWxrSUxKRkNPc0t0Q0JZSGY4dGpkNVdmc1U1Tm9RNUNna3hxUmJEQThZYmI0UlFlbUU4MVZwRFFhRWxtUmJBNHJSVnFjYjJ4Y1N3SkZ2Q0t4KzZzZkFOcERUSlNqV1VnVzFZRUMrQ1QzWFpYbmtnMkFrdWtrSTV3SzRMbEJRYnVzenRYaW1RaHNFUUs2UWdQNUV0b0hka1ltbFM1WmthNUE2bjg0WjNjZHBmd1JsRUN5MUMzV00wNFAxc2tTWTBPenlvNExYb3pBa3VrRUlWWHJLMW11dTJ1cDdSSVFtQnBVZWxTajhQeEU0Qkpib2R6dm5LTG54WTVDQ3d0S2dVZGgvdnV6elBwd3prN0JWYTYxWlBzM1lhOExTV0J2QWFCRlloYUFjWjEyNTJhOUEzUXJDbWlhM3Z4bkJ5NVJjclI5Rkk1SnBNQk5nWnU0NEFOSEZleG1xNnROOFdyRzE5SUFpdElqVk5HWnRXVkV1dGx5R0EyQnNrSEc5Q2VNZmp1NnIzRUh3SXJ4QUMwR051OWNhbkViQkpRQnB1Tk1XUUFMRDdFV1VXMU9RSXJITzdKZzVSNnJFZExXZUkySmlHVGM2VkpaVFlPbm03VjVwVEFDZ2RZdGVTUm10c3BnZUd5ZG5KWnYwM3R3OEVHeGhwSHNGZ2h5WnJBQ29tTW9UV1NNaTY3VVd4cFhDWmp2b0dDQWhzSHR6SEdFa0tiazNIV0NDemp0QTIxWlphYW05MVNScXdmTm5XRXlsZ3JCa2loemt5dlBRSkxyNElSVHArV2x4M1BqMHR0R1ZQNmJKSXlVTWdFdUExZ1RTSlpOQUlya3VvYm1IZlRoN3MzakttRFRGOVRLdGtZOTQxU0dVTmRBN1AxbXlhd3dxRnk5T1RCbXVYZTNLSnNLb1F4bGduZnRFanJVRGVuQkZiME9EMWlKVWtmMDZ0T2NXeHgyN0tCZ20rd29FNkpwQVJiS0FJcldPVXVnWFNwdWJjMGlJSFg1dVU4azBsbG8xTmxwUUdKb3RjbnNFUUtVVGdwRUtBQzJoYWhBelJLMFVrQkFvc1lNRVFCQXNzUVdja29nVVVNR0tJQWdXV0lyR1NVd0NJR0RGR0F3REpFVmpKS1lCRURoaWhBWUJraUt4a2xzSWdCUXhUNFA5bFhnUjZybk9NN0FBQUFBRWxGVGtTdVFtQ0NcIlxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vc3JjL2Fzc2V0cy9pbWFnZXZpZXcvc3VmZml4L3hsc3gucG5nXG4vLyBtb2R1bGUgaWQgPSAxMTBcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///110\n");

/***/ }),
/* 111 */
/***/ (function(module, exports, __webpack_require__) {

eval("module.exports = __webpack_require__.p + \"static/img/zip.ef7f82b.png\";\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvYXNzZXRzL2ltYWdldmlldy9zdWZmaXgvemlwLnBuZz82NzJhIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBLGlCQUFpQixxQkFBdUIiLCJmaWxlIjoiMTExLmpzIiwic291cmNlc0NvbnRlbnQiOlsibW9kdWxlLmV4cG9ydHMgPSBfX3dlYnBhY2tfcHVibGljX3BhdGhfXyArIFwic3RhdGljL2ltZy96aXAuZWY3ZjgyYi5wbmdcIjtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL3NyYy9hc3NldHMvaW1hZ2V2aWV3L3N1ZmZpeC96aXAucG5nXG4vLyBtb2R1bGUgaWQgPSAxMTFcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///111\n");

/***/ }),
/* 112 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("var render = function() {\n  var _vm = this\n  var _h = _vm.$createElement\n  var _c = _vm._self._c || _h\n  return _c(\"div\", [\n    _c(\"div\", { staticClass: \"page-container\" }, [\n      _c(\"div\", { attrs: { id: \"uploader\" } }, [\n        _c(\n          \"div\",\n          { staticClass: \"statusBar\", staticStyle: { display: \"none\" } },\n          [\n            _c(\"div\", { staticClass: \"tab-view\" }, [\n              _c(\n                \"div\",\n                {\n                  ref: \"detailView\",\n                  staticClass: \"tab-active\",\n                  staticStyle: { float: \"left\" },\n                  on: {\n                    click: function($event) {\n                      return _vm.tabChange(\"detailView\")\n                    }\n                  }\n                },\n                [\n                  _vm._v(\n                    \"分类展示\\n            \" +\n                      _vm._s(_vm.CNodeImgeCount) +\n                      \"\\n          \"\n                  )\n                ]\n              ),\n              _vm._v(\" \"),\n              _vm.uploadprops.config.shwoAlllist\n                ? _c(\n                    \"div\",\n                    {\n                      ref: \"allView\",\n                      staticStyle: { float: \"left\" },\n                      on: {\n                        click: function($event) {\n                          return _vm.tabChange(\"allView\")\n                        }\n                      }\n                    },\n                    [_vm._v(\"全部展示\" + _vm._s(_vm.AllImgeCount))]\n                  )\n                : _vm._e(),\n              _vm._v(\" \"),\n              _c(\"div\", { staticStyle: { clear: \"both\" } })\n            ]),\n            _vm._v(\" \"),\n            _vm._m(0)\n          ]\n        ),\n        _vm._v(\" \"),\n        _c(\"div\", { staticClass: \"queueList\" }, [\n          _c(\"div\", { staticClass: \"placeholder\", attrs: { id: \"dndArea\" } }, [\n            _c(\"div\", { attrs: { id: \"filePicker\" } }),\n            _vm._v(\" \"),\n            _c(\"p\", [_vm._v(\"或将照片拖到这里\" + _vm._s(_vm.currentNode))])\n          ]),\n          _vm._v(\" \"),\n          _c(\"ul\", {\n            staticClass: \"filelist\",\n            staticStyle: { height: \"135px\" }\n          })\n        ]),\n        _vm._v(\" \"),\n        _c(\"div\", { staticClass: \"queueAllList\" })\n      ])\n    ])\n  ])\n}\nvar staticRenderFns = [\n  function() {\n    var _vm = this\n    var _h = _vm.$createElement\n    var _c = _vm._self._c || _h\n    return _c(\"div\", { staticClass: \"btns\" }, [\n      _c(\"div\", { staticClass: \"progress\" }, [\n        _c(\"span\", { staticClass: \"text\" }, [_vm._v(\"0%\")]),\n        _vm._v(\" \"),\n        _c(\"span\", { staticClass: \"percentage\" })\n      ]),\n      _vm._v(\" \"),\n      _c(\"div\", { staticClass: \"info\" }, [_vm._v(\"共 5 张\")]),\n      _vm._v(\" \"),\n      _c(\"div\", { attrs: { id: \"filePicker2\" } }),\n      _vm._v(\" \"),\n      _c(\"div\", { staticClass: \"uploadBtn\" }, [_vm._v(\"开始上传\")])\n    ])\n  }\n]\nrender._withStripped = true\nvar esExports = { render: render, staticRenderFns: staticRenderFns }\n/* harmony default export */ __webpack_exports__[\"a\"] = (esExports);\nif (false) {\n  module.hot.accept()\n  if (module.hot.data) {\n    require(\"vue-hot-reload-api\")      .rerender(\"data-v-3151a9fe\", esExports)\n  }\n}\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvY29tcG9uZW50cy93ZWJ1cGxvYWRlci91cGxvYWQudnVlP2I5MWYiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsZ0NBQWdDO0FBQy9DLGlCQUFpQixTQUFTLGlCQUFpQixFQUFFO0FBQzdDO0FBQ0E7QUFDQSxXQUFXLHlDQUF5QyxrQkFBa0IsRUFBRTtBQUN4RTtBQUNBLHVCQUF1QiwwQkFBMEI7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQyxnQkFBZ0I7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DLGdCQUFnQjtBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLGVBQWUsZ0JBQWdCLEVBQUU7QUFDMUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLDJCQUEyQjtBQUM5QyxxQkFBcUIscUNBQXFDLGdCQUFnQixFQUFFO0FBQzVFLHVCQUF1QixTQUFTLG1CQUFtQixFQUFFO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQjtBQUMxQixXQUFXO0FBQ1g7QUFDQTtBQUNBLG1CQUFtQiw4QkFBOEI7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLHNCQUFzQjtBQUM1QyxpQkFBaUIsMEJBQTBCO0FBQzNDLG9CQUFvQixzQkFBc0I7QUFDMUM7QUFDQSxvQkFBb0IsNEJBQTRCO0FBQ2hEO0FBQ0E7QUFDQSxpQkFBaUIsc0JBQXNCO0FBQ3ZDO0FBQ0EsaUJBQWlCLFNBQVMsb0JBQW9CLEVBQUU7QUFDaEQ7QUFDQSxpQkFBaUIsMkJBQTJCO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ0Ysa0VBQVM7QUFDeEIsSUFBSSxLQUFVO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsImZpbGUiOiIxMTIuanMiLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgcmVuZGVyID0gZnVuY3Rpb24oKSB7XG4gIHZhciBfdm0gPSB0aGlzXG4gIHZhciBfaCA9IF92bS4kY3JlYXRlRWxlbWVudFxuICB2YXIgX2MgPSBfdm0uX3NlbGYuX2MgfHwgX2hcbiAgcmV0dXJuIF9jKFwiZGl2XCIsIFtcbiAgICBfYyhcImRpdlwiLCB7IHN0YXRpY0NsYXNzOiBcInBhZ2UtY29udGFpbmVyXCIgfSwgW1xuICAgICAgX2MoXCJkaXZcIiwgeyBhdHRyczogeyBpZDogXCJ1cGxvYWRlclwiIH0gfSwgW1xuICAgICAgICBfYyhcbiAgICAgICAgICBcImRpdlwiLFxuICAgICAgICAgIHsgc3RhdGljQ2xhc3M6IFwic3RhdHVzQmFyXCIsIHN0YXRpY1N0eWxlOiB7IGRpc3BsYXk6IFwibm9uZVwiIH0gfSxcbiAgICAgICAgICBbXG4gICAgICAgICAgICBfYyhcImRpdlwiLCB7IHN0YXRpY0NsYXNzOiBcInRhYi12aWV3XCIgfSwgW1xuICAgICAgICAgICAgICBfYyhcbiAgICAgICAgICAgICAgICBcImRpdlwiLFxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgIHJlZjogXCJkZXRhaWxWaWV3XCIsXG4gICAgICAgICAgICAgICAgICBzdGF0aWNDbGFzczogXCJ0YWItYWN0aXZlXCIsXG4gICAgICAgICAgICAgICAgICBzdGF0aWNTdHlsZTogeyBmbG9hdDogXCJsZWZ0XCIgfSxcbiAgICAgICAgICAgICAgICAgIG9uOiB7XG4gICAgICAgICAgICAgICAgICAgIGNsaWNrOiBmdW5jdGlvbigkZXZlbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gX3ZtLnRhYkNoYW5nZShcImRldGFpbFZpZXdcIilcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgW1xuICAgICAgICAgICAgICAgICAgX3ZtLl92KFxuICAgICAgICAgICAgICAgICAgICBcIuWIhuexu+WxleekulxcbiAgICAgICAgICAgIFwiICtcbiAgICAgICAgICAgICAgICAgICAgICBfdm0uX3MoX3ZtLkNOb2RlSW1nZUNvdW50KSArXG4gICAgICAgICAgICAgICAgICAgICAgXCJcXG4gICAgICAgICAgXCJcbiAgICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgICBdXG4gICAgICAgICAgICAgICksXG4gICAgICAgICAgICAgIF92bS5fdihcIiBcIiksXG4gICAgICAgICAgICAgIF92bS51cGxvYWRwcm9wcy5jb25maWcuc2h3b0FsbGxpc3RcbiAgICAgICAgICAgICAgICA/IF9jKFxuICAgICAgICAgICAgICAgICAgICBcImRpdlwiLFxuICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgcmVmOiBcImFsbFZpZXdcIixcbiAgICAgICAgICAgICAgICAgICAgICBzdGF0aWNTdHlsZTogeyBmbG9hdDogXCJsZWZ0XCIgfSxcbiAgICAgICAgICAgICAgICAgICAgICBvbjoge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2xpY2s6IGZ1bmN0aW9uKCRldmVudCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gX3ZtLnRhYkNoYW5nZShcImFsbFZpZXdcIilcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIFtfdm0uX3YoXCLlhajpg6jlsZXnpLpcIiArIF92bS5fcyhfdm0uQWxsSW1nZUNvdW50KSldXG4gICAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgOiBfdm0uX2UoKSxcbiAgICAgICAgICAgICAgX3ZtLl92KFwiIFwiKSxcbiAgICAgICAgICAgICAgX2MoXCJkaXZcIiwgeyBzdGF0aWNTdHlsZTogeyBjbGVhcjogXCJib3RoXCIgfSB9KVxuICAgICAgICAgICAgXSksXG4gICAgICAgICAgICBfdm0uX3YoXCIgXCIpLFxuICAgICAgICAgICAgX3ZtLl9tKDApXG4gICAgICAgICAgXVxuICAgICAgICApLFxuICAgICAgICBfdm0uX3YoXCIgXCIpLFxuICAgICAgICBfYyhcImRpdlwiLCB7IHN0YXRpY0NsYXNzOiBcInF1ZXVlTGlzdFwiIH0sIFtcbiAgICAgICAgICBfYyhcImRpdlwiLCB7IHN0YXRpY0NsYXNzOiBcInBsYWNlaG9sZGVyXCIsIGF0dHJzOiB7IGlkOiBcImRuZEFyZWFcIiB9IH0sIFtcbiAgICAgICAgICAgIF9jKFwiZGl2XCIsIHsgYXR0cnM6IHsgaWQ6IFwiZmlsZVBpY2tlclwiIH0gfSksXG4gICAgICAgICAgICBfdm0uX3YoXCIgXCIpLFxuICAgICAgICAgICAgX2MoXCJwXCIsIFtfdm0uX3YoXCLmiJblsIbnhafniYfmi5bliLDov5nph4xcIiArIF92bS5fcyhfdm0uY3VycmVudE5vZGUpKV0pXG4gICAgICAgICAgXSksXG4gICAgICAgICAgX3ZtLl92KFwiIFwiKSxcbiAgICAgICAgICBfYyhcInVsXCIsIHtcbiAgICAgICAgICAgIHN0YXRpY0NsYXNzOiBcImZpbGVsaXN0XCIsXG4gICAgICAgICAgICBzdGF0aWNTdHlsZTogeyBoZWlnaHQ6IFwiMTM1cHhcIiB9XG4gICAgICAgICAgfSlcbiAgICAgICAgXSksXG4gICAgICAgIF92bS5fdihcIiBcIiksXG4gICAgICAgIF9jKFwiZGl2XCIsIHsgc3RhdGljQ2xhc3M6IFwicXVldWVBbGxMaXN0XCIgfSlcbiAgICAgIF0pXG4gICAgXSlcbiAgXSlcbn1cbnZhciBzdGF0aWNSZW5kZXJGbnMgPSBbXG4gIGZ1bmN0aW9uKCkge1xuICAgIHZhciBfdm0gPSB0aGlzXG4gICAgdmFyIF9oID0gX3ZtLiRjcmVhdGVFbGVtZW50XG4gICAgdmFyIF9jID0gX3ZtLl9zZWxmLl9jIHx8IF9oXG4gICAgcmV0dXJuIF9jKFwiZGl2XCIsIHsgc3RhdGljQ2xhc3M6IFwiYnRuc1wiIH0sIFtcbiAgICAgIF9jKFwiZGl2XCIsIHsgc3RhdGljQ2xhc3M6IFwicHJvZ3Jlc3NcIiB9LCBbXG4gICAgICAgIF9jKFwic3BhblwiLCB7IHN0YXRpY0NsYXNzOiBcInRleHRcIiB9LCBbX3ZtLl92KFwiMCVcIildKSxcbiAgICAgICAgX3ZtLl92KFwiIFwiKSxcbiAgICAgICAgX2MoXCJzcGFuXCIsIHsgc3RhdGljQ2xhc3M6IFwicGVyY2VudGFnZVwiIH0pXG4gICAgICBdKSxcbiAgICAgIF92bS5fdihcIiBcIiksXG4gICAgICBfYyhcImRpdlwiLCB7IHN0YXRpY0NsYXNzOiBcImluZm9cIiB9LCBbX3ZtLl92KFwi5YWxIDUg5bygXCIpXSksXG4gICAgICBfdm0uX3YoXCIgXCIpLFxuICAgICAgX2MoXCJkaXZcIiwgeyBhdHRyczogeyBpZDogXCJmaWxlUGlja2VyMlwiIH0gfSksXG4gICAgICBfdm0uX3YoXCIgXCIpLFxuICAgICAgX2MoXCJkaXZcIiwgeyBzdGF0aWNDbGFzczogXCJ1cGxvYWRCdG5cIiB9LCBbX3ZtLl92KFwi5byA5aeL5LiK5LygXCIpXSlcbiAgICBdKVxuICB9XG5dXG5yZW5kZXIuX3dpdGhTdHJpcHBlZCA9IHRydWVcbnZhciBlc0V4cG9ydHMgPSB7IHJlbmRlcjogcmVuZGVyLCBzdGF0aWNSZW5kZXJGbnM6IHN0YXRpY1JlbmRlckZucyB9XG5leHBvcnQgZGVmYXVsdCBlc0V4cG9ydHNcbmlmIChtb2R1bGUuaG90KSB7XG4gIG1vZHVsZS5ob3QuYWNjZXB0KClcbiAgaWYgKG1vZHVsZS5ob3QuZGF0YSkge1xuICAgIHJlcXVpcmUoXCJ2dWUtaG90LXJlbG9hZC1hcGlcIikgICAgICAucmVyZW5kZXIoXCJkYXRhLXYtMzE1MWE5ZmVcIiwgZXNFeHBvcnRzKVxuICB9XG59XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvdGVtcGxhdGUtY29tcGlsZXI/e1wiaWRcIjpcImRhdGEtdi0zMTUxYTlmZVwiLFwiaGFzU2NvcGVkXCI6dHJ1ZSxcImJ1YmxlXCI6e1widHJhbnNmb3Jtc1wiOnt9fX0hLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvc2VsZWN0b3IuanM/dHlwZT10ZW1wbGF0ZSZpbmRleD0wIS4vc3JjL2NvbXBvbmVudHMvd2VidXBsb2FkZXIvdXBsb2FkLnZ1ZVxuLy8gbW9kdWxlIGlkID0gMTEyXG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///112\n");

/***/ }),
/* 113 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("/* WEBPACK VAR INJECTION */(function(process, global, setImmediate) {/*!\n * Vue.js v2.6.10\n * (c) 2014-2019 Evan You\n * Released under the MIT License.\n */\n/*  */\n\nvar emptyObject = Object.freeze({});\n\n// These helpers produce better VM code in JS engines due to their\n// explicitness and function inlining.\nfunction isUndef (v) {\n  return v === undefined || v === null\n}\n\nfunction isDef (v) {\n  return v !== undefined && v !== null\n}\n\nfunction isTrue (v) {\n  return v === true\n}\n\nfunction isFalse (v) {\n  return v === false\n}\n\n/**\n * Check if value is primitive.\n */\nfunction isPrimitive (value) {\n  return (\n    typeof value === 'string' ||\n    typeof value === 'number' ||\n    // $flow-disable-line\n    typeof value === 'symbol' ||\n    typeof value === 'boolean'\n  )\n}\n\n/**\n * Quick object check - this is primarily used to tell\n * Objects from primitive values when we know the value\n * is a JSON-compliant type.\n */\nfunction isObject (obj) {\n  return obj !== null && typeof obj === 'object'\n}\n\n/**\n * Get the raw type string of a value, e.g., [object Object].\n */\nvar _toString = Object.prototype.toString;\n\nfunction toRawType (value) {\n  return _toString.call(value).slice(8, -1)\n}\n\n/**\n * Strict object type check. Only returns true\n * for plain JavaScript objects.\n */\nfunction isPlainObject (obj) {\n  return _toString.call(obj) === '[object Object]'\n}\n\nfunction isRegExp (v) {\n  return _toString.call(v) === '[object RegExp]'\n}\n\n/**\n * Check if val is a valid array index.\n */\nfunction isValidArrayIndex (val) {\n  var n = parseFloat(String(val));\n  return n >= 0 && Math.floor(n) === n && isFinite(val)\n}\n\nfunction isPromise (val) {\n  return (\n    isDef(val) &&\n    typeof val.then === 'function' &&\n    typeof val.catch === 'function'\n  )\n}\n\n/**\n * Convert a value to a string that is actually rendered.\n */\nfunction toString (val) {\n  return val == null\n    ? ''\n    : Array.isArray(val) || (isPlainObject(val) && val.toString === _toString)\n      ? JSON.stringify(val, null, 2)\n      : String(val)\n}\n\n/**\n * Convert an input value to a number for persistence.\n * If the conversion fails, return original string.\n */\nfunction toNumber (val) {\n  var n = parseFloat(val);\n  return isNaN(n) ? val : n\n}\n\n/**\n * Make a map and return a function for checking if a key\n * is in that map.\n */\nfunction makeMap (\n  str,\n  expectsLowerCase\n) {\n  var map = Object.create(null);\n  var list = str.split(',');\n  for (var i = 0; i < list.length; i++) {\n    map[list[i]] = true;\n  }\n  return expectsLowerCase\n    ? function (val) { return map[val.toLowerCase()]; }\n    : function (val) { return map[val]; }\n}\n\n/**\n * Check if a tag is a built-in tag.\n */\nvar isBuiltInTag = makeMap('slot,component', true);\n\n/**\n * Check if an attribute is a reserved attribute.\n */\nvar isReservedAttribute = makeMap('key,ref,slot,slot-scope,is');\n\n/**\n * Remove an item from an array.\n */\nfunction remove (arr, item) {\n  if (arr.length) {\n    var index = arr.indexOf(item);\n    if (index > -1) {\n      return arr.splice(index, 1)\n    }\n  }\n}\n\n/**\n * Check whether an object has the property.\n */\nvar hasOwnProperty = Object.prototype.hasOwnProperty;\nfunction hasOwn (obj, key) {\n  return hasOwnProperty.call(obj, key)\n}\n\n/**\n * Create a cached version of a pure function.\n */\nfunction cached (fn) {\n  var cache = Object.create(null);\n  return (function cachedFn (str) {\n    var hit = cache[str];\n    return hit || (cache[str] = fn(str))\n  })\n}\n\n/**\n * Camelize a hyphen-delimited string.\n */\nvar camelizeRE = /-(\\w)/g;\nvar camelize = cached(function (str) {\n  return str.replace(camelizeRE, function (_, c) { return c ? c.toUpperCase() : ''; })\n});\n\n/**\n * Capitalize a string.\n */\nvar capitalize = cached(function (str) {\n  return str.charAt(0).toUpperCase() + str.slice(1)\n});\n\n/**\n * Hyphenate a camelCase string.\n */\nvar hyphenateRE = /\\B([A-Z])/g;\nvar hyphenate = cached(function (str) {\n  return str.replace(hyphenateRE, '-$1').toLowerCase()\n});\n\n/**\n * Simple bind polyfill for environments that do not support it,\n * e.g., PhantomJS 1.x. Technically, we don't need this anymore\n * since native bind is now performant enough in most browsers.\n * But removing it would mean breaking code that was able to run in\n * PhantomJS 1.x, so this must be kept for backward compatibility.\n */\n\n/* istanbul ignore next */\nfunction polyfillBind (fn, ctx) {\n  function boundFn (a) {\n    var l = arguments.length;\n    return l\n      ? l > 1\n        ? fn.apply(ctx, arguments)\n        : fn.call(ctx, a)\n      : fn.call(ctx)\n  }\n\n  boundFn._length = fn.length;\n  return boundFn\n}\n\nfunction nativeBind (fn, ctx) {\n  return fn.bind(ctx)\n}\n\nvar bind = Function.prototype.bind\n  ? nativeBind\n  : polyfillBind;\n\n/**\n * Convert an Array-like object to a real Array.\n */\nfunction toArray (list, start) {\n  start = start || 0;\n  var i = list.length - start;\n  var ret = new Array(i);\n  while (i--) {\n    ret[i] = list[i + start];\n  }\n  return ret\n}\n\n/**\n * Mix properties into target object.\n */\nfunction extend (to, _from) {\n  for (var key in _from) {\n    to[key] = _from[key];\n  }\n  return to\n}\n\n/**\n * Merge an Array of Objects into a single Object.\n */\nfunction toObject (arr) {\n  var res = {};\n  for (var i = 0; i < arr.length; i++) {\n    if (arr[i]) {\n      extend(res, arr[i]);\n    }\n  }\n  return res\n}\n\n/* eslint-disable no-unused-vars */\n\n/**\n * Perform no operation.\n * Stubbing args to make Flow happy without leaving useless transpiled code\n * with ...rest (https://flow.org/blog/2017/05/07/Strict-Function-Call-Arity/).\n */\nfunction noop (a, b, c) {}\n\n/**\n * Always return false.\n */\nvar no = function (a, b, c) { return false; };\n\n/* eslint-enable no-unused-vars */\n\n/**\n * Return the same value.\n */\nvar identity = function (_) { return _; };\n\n/**\n * Generate a string containing static keys from compiler modules.\n */\nfunction genStaticKeys (modules) {\n  return modules.reduce(function (keys, m) {\n    return keys.concat(m.staticKeys || [])\n  }, []).join(',')\n}\n\n/**\n * Check if two values are loosely equal - that is,\n * if they are plain objects, do they have the same shape?\n */\nfunction looseEqual (a, b) {\n  if (a === b) { return true }\n  var isObjectA = isObject(a);\n  var isObjectB = isObject(b);\n  if (isObjectA && isObjectB) {\n    try {\n      var isArrayA = Array.isArray(a);\n      var isArrayB = Array.isArray(b);\n      if (isArrayA && isArrayB) {\n        return a.length === b.length && a.every(function (e, i) {\n          return looseEqual(e, b[i])\n        })\n      } else if (a instanceof Date && b instanceof Date) {\n        return a.getTime() === b.getTime()\n      } else if (!isArrayA && !isArrayB) {\n        var keysA = Object.keys(a);\n        var keysB = Object.keys(b);\n        return keysA.length === keysB.length && keysA.every(function (key) {\n          return looseEqual(a[key], b[key])\n        })\n      } else {\n        /* istanbul ignore next */\n        return false\n      }\n    } catch (e) {\n      /* istanbul ignore next */\n      return false\n    }\n  } else if (!isObjectA && !isObjectB) {\n    return String(a) === String(b)\n  } else {\n    return false\n  }\n}\n\n/**\n * Return the first index at which a loosely equal value can be\n * found in the array (if value is a plain object, the array must\n * contain an object of the same shape), or -1 if it is not present.\n */\nfunction looseIndexOf (arr, val) {\n  for (var i = 0; i < arr.length; i++) {\n    if (looseEqual(arr[i], val)) { return i }\n  }\n  return -1\n}\n\n/**\n * Ensure a function is called only once.\n */\nfunction once (fn) {\n  var called = false;\n  return function () {\n    if (!called) {\n      called = true;\n      fn.apply(this, arguments);\n    }\n  }\n}\n\nvar SSR_ATTR = 'data-server-rendered';\n\nvar ASSET_TYPES = [\n  'component',\n  'directive',\n  'filter'\n];\n\nvar LIFECYCLE_HOOKS = [\n  'beforeCreate',\n  'created',\n  'beforeMount',\n  'mounted',\n  'beforeUpdate',\n  'updated',\n  'beforeDestroy',\n  'destroyed',\n  'activated',\n  'deactivated',\n  'errorCaptured',\n  'serverPrefetch'\n];\n\n/*  */\n\n\n\nvar config = ({\n  /**\n   * Option merge strategies (used in core/util/options)\n   */\n  // $flow-disable-line\n  optionMergeStrategies: Object.create(null),\n\n  /**\n   * Whether to suppress warnings.\n   */\n  silent: false,\n\n  /**\n   * Show production mode tip message on boot?\n   */\n  productionTip: process.env.NODE_ENV !== 'production',\n\n  /**\n   * Whether to enable devtools\n   */\n  devtools: process.env.NODE_ENV !== 'production',\n\n  /**\n   * Whether to record perf\n   */\n  performance: false,\n\n  /**\n   * Error handler for watcher errors\n   */\n  errorHandler: null,\n\n  /**\n   * Warn handler for watcher warns\n   */\n  warnHandler: null,\n\n  /**\n   * Ignore certain custom elements\n   */\n  ignoredElements: [],\n\n  /**\n   * Custom user key aliases for v-on\n   */\n  // $flow-disable-line\n  keyCodes: Object.create(null),\n\n  /**\n   * Check if a tag is reserved so that it cannot be registered as a\n   * component. This is platform-dependent and may be overwritten.\n   */\n  isReservedTag: no,\n\n  /**\n   * Check if an attribute is reserved so that it cannot be used as a component\n   * prop. This is platform-dependent and may be overwritten.\n   */\n  isReservedAttr: no,\n\n  /**\n   * Check if a tag is an unknown element.\n   * Platform-dependent.\n   */\n  isUnknownElement: no,\n\n  /**\n   * Get the namespace of an element\n   */\n  getTagNamespace: noop,\n\n  /**\n   * Parse the real tag name for the specific platform.\n   */\n  parsePlatformTagName: identity,\n\n  /**\n   * Check if an attribute must be bound using property, e.g. value\n   * Platform-dependent.\n   */\n  mustUseProp: no,\n\n  /**\n   * Perform updates asynchronously. Intended to be used by Vue Test Utils\n   * This will significantly reduce performance if set to false.\n   */\n  async: true,\n\n  /**\n   * Exposed for legacy reasons\n   */\n  _lifecycleHooks: LIFECYCLE_HOOKS\n});\n\n/*  */\n\n/**\n * unicode letters used for parsing html tags, component names and property paths.\n * using https://www.w3.org/TR/html53/semantics-scripting.html#potentialcustomelementname\n * skipping \\u10000-\\uEFFFF due to it freezing up PhantomJS\n */\nvar unicodeRegExp = /a-zA-Z\\u00B7\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u203F-\\u2040\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD/;\n\n/**\n * Check if a string starts with $ or _\n */\nfunction isReserved (str) {\n  var c = (str + '').charCodeAt(0);\n  return c === 0x24 || c === 0x5F\n}\n\n/**\n * Define a property.\n */\nfunction def (obj, key, val, enumerable) {\n  Object.defineProperty(obj, key, {\n    value: val,\n    enumerable: !!enumerable,\n    writable: true,\n    configurable: true\n  });\n}\n\n/**\n * Parse simple path.\n */\nvar bailRE = new RegExp((\"[^\" + (unicodeRegExp.source) + \".$_\\\\d]\"));\nfunction parsePath (path) {\n  if (bailRE.test(path)) {\n    return\n  }\n  var segments = path.split('.');\n  return function (obj) {\n    for (var i = 0; i < segments.length; i++) {\n      if (!obj) { return }\n      obj = obj[segments[i]];\n    }\n    return obj\n  }\n}\n\n/*  */\n\n// can we use __proto__?\nvar hasProto = '__proto__' in {};\n\n// Browser environment sniffing\nvar inBrowser = typeof window !== 'undefined';\nvar inWeex = typeof WXEnvironment !== 'undefined' && !!WXEnvironment.platform;\nvar weexPlatform = inWeex && WXEnvironment.platform.toLowerCase();\nvar UA = inBrowser && window.navigator.userAgent.toLowerCase();\nvar isIE = UA && /msie|trident/.test(UA);\nvar isIE9 = UA && UA.indexOf('msie 9.0') > 0;\nvar isEdge = UA && UA.indexOf('edge/') > 0;\nvar isAndroid = (UA && UA.indexOf('android') > 0) || (weexPlatform === 'android');\nvar isIOS = (UA && /iphone|ipad|ipod|ios/.test(UA)) || (weexPlatform === 'ios');\nvar isChrome = UA && /chrome\\/\\d+/.test(UA) && !isEdge;\nvar isPhantomJS = UA && /phantomjs/.test(UA);\nvar isFF = UA && UA.match(/firefox\\/(\\d+)/);\n\n// Firefox has a \"watch\" function on Object.prototype...\nvar nativeWatch = ({}).watch;\n\nvar supportsPassive = false;\nif (inBrowser) {\n  try {\n    var opts = {};\n    Object.defineProperty(opts, 'passive', ({\n      get: function get () {\n        /* istanbul ignore next */\n        supportsPassive = true;\n      }\n    })); // https://github.com/facebook/flow/issues/285\n    window.addEventListener('test-passive', null, opts);\n  } catch (e) {}\n}\n\n// this needs to be lazy-evaled because vue may be required before\n// vue-server-renderer can set VUE_ENV\nvar _isServer;\nvar isServerRendering = function () {\n  if (_isServer === undefined) {\n    /* istanbul ignore if */\n    if (!inBrowser && !inWeex && typeof global !== 'undefined') {\n      // detect presence of vue-server-renderer and avoid\n      // Webpack shimming the process\n      _isServer = global['process'] && global['process'].env.VUE_ENV === 'server';\n    } else {\n      _isServer = false;\n    }\n  }\n  return _isServer\n};\n\n// detect devtools\nvar devtools = inBrowser && window.__VUE_DEVTOOLS_GLOBAL_HOOK__;\n\n/* istanbul ignore next */\nfunction isNative (Ctor) {\n  return typeof Ctor === 'function' && /native code/.test(Ctor.toString())\n}\n\nvar hasSymbol =\n  typeof Symbol !== 'undefined' && isNative(Symbol) &&\n  typeof Reflect !== 'undefined' && isNative(Reflect.ownKeys);\n\nvar _Set;\n/* istanbul ignore if */ // $flow-disable-line\nif (typeof Set !== 'undefined' && isNative(Set)) {\n  // use native Set when available.\n  _Set = Set;\n} else {\n  // a non-standard Set polyfill that only works with primitive keys.\n  _Set = /*@__PURE__*/(function () {\n    function Set () {\n      this.set = Object.create(null);\n    }\n    Set.prototype.has = function has (key) {\n      return this.set[key] === true\n    };\n    Set.prototype.add = function add (key) {\n      this.set[key] = true;\n    };\n    Set.prototype.clear = function clear () {\n      this.set = Object.create(null);\n    };\n\n    return Set;\n  }());\n}\n\n/*  */\n\nvar warn = noop;\nvar tip = noop;\nvar generateComponentTrace = (noop); // work around flow check\nvar formatComponentName = (noop);\n\nif (process.env.NODE_ENV !== 'production') {\n  var hasConsole = typeof console !== 'undefined';\n  var classifyRE = /(?:^|[-_])(\\w)/g;\n  var classify = function (str) { return str\n    .replace(classifyRE, function (c) { return c.toUpperCase(); })\n    .replace(/[-_]/g, ''); };\n\n  warn = function (msg, vm) {\n    var trace = vm ? generateComponentTrace(vm) : '';\n\n    if (config.warnHandler) {\n      config.warnHandler.call(null, msg, vm, trace);\n    } else if (hasConsole && (!config.silent)) {\n      console.error((\"[Vue warn]: \" + msg + trace));\n    }\n  };\n\n  tip = function (msg, vm) {\n    if (hasConsole && (!config.silent)) {\n      console.warn(\"[Vue tip]: \" + msg + (\n        vm ? generateComponentTrace(vm) : ''\n      ));\n    }\n  };\n\n  formatComponentName = function (vm, includeFile) {\n    if (vm.$root === vm) {\n      return '<Root>'\n    }\n    var options = typeof vm === 'function' && vm.cid != null\n      ? vm.options\n      : vm._isVue\n        ? vm.$options || vm.constructor.options\n        : vm;\n    var name = options.name || options._componentTag;\n    var file = options.__file;\n    if (!name && file) {\n      var match = file.match(/([^/\\\\]+)\\.vue$/);\n      name = match && match[1];\n    }\n\n    return (\n      (name ? (\"<\" + (classify(name)) + \">\") : \"<Anonymous>\") +\n      (file && includeFile !== false ? (\" at \" + file) : '')\n    )\n  };\n\n  var repeat = function (str, n) {\n    var res = '';\n    while (n) {\n      if (n % 2 === 1) { res += str; }\n      if (n > 1) { str += str; }\n      n >>= 1;\n    }\n    return res\n  };\n\n  generateComponentTrace = function (vm) {\n    if (vm._isVue && vm.$parent) {\n      var tree = [];\n      var currentRecursiveSequence = 0;\n      while (vm) {\n        if (tree.length > 0) {\n          var last = tree[tree.length - 1];\n          if (last.constructor === vm.constructor) {\n            currentRecursiveSequence++;\n            vm = vm.$parent;\n            continue\n          } else if (currentRecursiveSequence > 0) {\n            tree[tree.length - 1] = [last, currentRecursiveSequence];\n            currentRecursiveSequence = 0;\n          }\n        }\n        tree.push(vm);\n        vm = vm.$parent;\n      }\n      return '\\n\\nfound in\\n\\n' + tree\n        .map(function (vm, i) { return (\"\" + (i === 0 ? '---> ' : repeat(' ', 5 + i * 2)) + (Array.isArray(vm)\n            ? ((formatComponentName(vm[0])) + \"... (\" + (vm[1]) + \" recursive calls)\")\n            : formatComponentName(vm))); })\n        .join('\\n')\n    } else {\n      return (\"\\n\\n(found in \" + (formatComponentName(vm)) + \")\")\n    }\n  };\n}\n\n/*  */\n\nvar uid = 0;\n\n/**\n * A dep is an observable that can have multiple\n * directives subscribing to it.\n */\nvar Dep = function Dep () {\n  this.id = uid++;\n  this.subs = [];\n};\n\nDep.prototype.addSub = function addSub (sub) {\n  this.subs.push(sub);\n};\n\nDep.prototype.removeSub = function removeSub (sub) {\n  remove(this.subs, sub);\n};\n\nDep.prototype.depend = function depend () {\n  if (Dep.target) {\n    Dep.target.addDep(this);\n  }\n};\n\nDep.prototype.notify = function notify () {\n  // stabilize the subscriber list first\n  var subs = this.subs.slice();\n  if (process.env.NODE_ENV !== 'production' && !config.async) {\n    // subs aren't sorted in scheduler if not running async\n    // we need to sort them now to make sure they fire in correct\n    // order\n    subs.sort(function (a, b) { return a.id - b.id; });\n  }\n  for (var i = 0, l = subs.length; i < l; i++) {\n    subs[i].update();\n  }\n};\n\n// The current target watcher being evaluated.\n// This is globally unique because only one watcher\n// can be evaluated at a time.\nDep.target = null;\nvar targetStack = [];\n\nfunction pushTarget (target) {\n  targetStack.push(target);\n  Dep.target = target;\n}\n\nfunction popTarget () {\n  targetStack.pop();\n  Dep.target = targetStack[targetStack.length - 1];\n}\n\n/*  */\n\nvar VNode = function VNode (\n  tag,\n  data,\n  children,\n  text,\n  elm,\n  context,\n  componentOptions,\n  asyncFactory\n) {\n  this.tag = tag;\n  this.data = data;\n  this.children = children;\n  this.text = text;\n  this.elm = elm;\n  this.ns = undefined;\n  this.context = context;\n  this.fnContext = undefined;\n  this.fnOptions = undefined;\n  this.fnScopeId = undefined;\n  this.key = data && data.key;\n  this.componentOptions = componentOptions;\n  this.componentInstance = undefined;\n  this.parent = undefined;\n  this.raw = false;\n  this.isStatic = false;\n  this.isRootInsert = true;\n  this.isComment = false;\n  this.isCloned = false;\n  this.isOnce = false;\n  this.asyncFactory = asyncFactory;\n  this.asyncMeta = undefined;\n  this.isAsyncPlaceholder = false;\n};\n\nvar prototypeAccessors = { child: { configurable: true } };\n\n// DEPRECATED: alias for componentInstance for backwards compat.\n/* istanbul ignore next */\nprototypeAccessors.child.get = function () {\n  return this.componentInstance\n};\n\nObject.defineProperties( VNode.prototype, prototypeAccessors );\n\nvar createEmptyVNode = function (text) {\n  if ( text === void 0 ) text = '';\n\n  var node = new VNode();\n  node.text = text;\n  node.isComment = true;\n  return node\n};\n\nfunction createTextVNode (val) {\n  return new VNode(undefined, undefined, undefined, String(val))\n}\n\n// optimized shallow clone\n// used for static nodes and slot nodes because they may be reused across\n// multiple renders, cloning them avoids errors when DOM manipulations rely\n// on their elm reference.\nfunction cloneVNode (vnode) {\n  var cloned = new VNode(\n    vnode.tag,\n    vnode.data,\n    // #7975\n    // clone children array to avoid mutating original in case of cloning\n    // a child.\n    vnode.children && vnode.children.slice(),\n    vnode.text,\n    vnode.elm,\n    vnode.context,\n    vnode.componentOptions,\n    vnode.asyncFactory\n  );\n  cloned.ns = vnode.ns;\n  cloned.isStatic = vnode.isStatic;\n  cloned.key = vnode.key;\n  cloned.isComment = vnode.isComment;\n  cloned.fnContext = vnode.fnContext;\n  cloned.fnOptions = vnode.fnOptions;\n  cloned.fnScopeId = vnode.fnScopeId;\n  cloned.asyncMeta = vnode.asyncMeta;\n  cloned.isCloned = true;\n  return cloned\n}\n\n/*\n * not type checking this file because flow doesn't play well with\n * dynamically accessing methods on Array prototype\n */\n\nvar arrayProto = Array.prototype;\nvar arrayMethods = Object.create(arrayProto);\n\nvar methodsToPatch = [\n  'push',\n  'pop',\n  'shift',\n  'unshift',\n  'splice',\n  'sort',\n  'reverse'\n];\n\n/**\n * Intercept mutating methods and emit events\n */\nmethodsToPatch.forEach(function (method) {\n  // cache original method\n  var original = arrayProto[method];\n  def(arrayMethods, method, function mutator () {\n    var args = [], len = arguments.length;\n    while ( len-- ) args[ len ] = arguments[ len ];\n\n    var result = original.apply(this, args);\n    var ob = this.__ob__;\n    var inserted;\n    switch (method) {\n      case 'push':\n      case 'unshift':\n        inserted = args;\n        break\n      case 'splice':\n        inserted = args.slice(2);\n        break\n    }\n    if (inserted) { ob.observeArray(inserted); }\n    // notify change\n    ob.dep.notify();\n    return result\n  });\n});\n\n/*  */\n\nvar arrayKeys = Object.getOwnPropertyNames(arrayMethods);\n\n/**\n * In some cases we may want to disable observation inside a component's\n * update computation.\n */\nvar shouldObserve = true;\n\nfunction toggleObserving (value) {\n  shouldObserve = value;\n}\n\n/**\n * Observer class that is attached to each observed\n * object. Once attached, the observer converts the target\n * object's property keys into getter/setters that\n * collect dependencies and dispatch updates.\n */\nvar Observer = function Observer (value) {\n  this.value = value;\n  this.dep = new Dep();\n  this.vmCount = 0;\n  def(value, '__ob__', this);\n  if (Array.isArray(value)) {\n    if (hasProto) {\n      protoAugment(value, arrayMethods);\n    } else {\n      copyAugment(value, arrayMethods, arrayKeys);\n    }\n    this.observeArray(value);\n  } else {\n    this.walk(value);\n  }\n};\n\n/**\n * Walk through all properties and convert them into\n * getter/setters. This method should only be called when\n * value type is Object.\n */\nObserver.prototype.walk = function walk (obj) {\n  var keys = Object.keys(obj);\n  for (var i = 0; i < keys.length; i++) {\n    defineReactive$$1(obj, keys[i]);\n  }\n};\n\n/**\n * Observe a list of Array items.\n */\nObserver.prototype.observeArray = function observeArray (items) {\n  for (var i = 0, l = items.length; i < l; i++) {\n    observe(items[i]);\n  }\n};\n\n// helpers\n\n/**\n * Augment a target Object or Array by intercepting\n * the prototype chain using __proto__\n */\nfunction protoAugment (target, src) {\n  /* eslint-disable no-proto */\n  target.__proto__ = src;\n  /* eslint-enable no-proto */\n}\n\n/**\n * Augment a target Object or Array by defining\n * hidden properties.\n */\n/* istanbul ignore next */\nfunction copyAugment (target, src, keys) {\n  for (var i = 0, l = keys.length; i < l; i++) {\n    var key = keys[i];\n    def(target, key, src[key]);\n  }\n}\n\n/**\n * Attempt to create an observer instance for a value,\n * returns the new observer if successfully observed,\n * or the existing observer if the value already has one.\n */\nfunction observe (value, asRootData) {\n  if (!isObject(value) || value instanceof VNode) {\n    return\n  }\n  var ob;\n  if (hasOwn(value, '__ob__') && value.__ob__ instanceof Observer) {\n    ob = value.__ob__;\n  } else if (\n    shouldObserve &&\n    !isServerRendering() &&\n    (Array.isArray(value) || isPlainObject(value)) &&\n    Object.isExtensible(value) &&\n    !value._isVue\n  ) {\n    ob = new Observer(value);\n  }\n  if (asRootData && ob) {\n    ob.vmCount++;\n  }\n  return ob\n}\n\n/**\n * Define a reactive property on an Object.\n */\nfunction defineReactive$$1 (\n  obj,\n  key,\n  val,\n  customSetter,\n  shallow\n) {\n  var dep = new Dep();\n\n  var property = Object.getOwnPropertyDescriptor(obj, key);\n  if (property && property.configurable === false) {\n    return\n  }\n\n  // cater for pre-defined getter/setters\n  var getter = property && property.get;\n  var setter = property && property.set;\n  if ((!getter || setter) && arguments.length === 2) {\n    val = obj[key];\n  }\n\n  var childOb = !shallow && observe(val);\n  Object.defineProperty(obj, key, {\n    enumerable: true,\n    configurable: true,\n    get: function reactiveGetter () {\n      var value = getter ? getter.call(obj) : val;\n      if (Dep.target) {\n        dep.depend();\n        if (childOb) {\n          childOb.dep.depend();\n          if (Array.isArray(value)) {\n            dependArray(value);\n          }\n        }\n      }\n      return value\n    },\n    set: function reactiveSetter (newVal) {\n      var value = getter ? getter.call(obj) : val;\n      /* eslint-disable no-self-compare */\n      if (newVal === value || (newVal !== newVal && value !== value)) {\n        return\n      }\n      /* eslint-enable no-self-compare */\n      if (process.env.NODE_ENV !== 'production' && customSetter) {\n        customSetter();\n      }\n      // #7981: for accessor properties without setter\n      if (getter && !setter) { return }\n      if (setter) {\n        setter.call(obj, newVal);\n      } else {\n        val = newVal;\n      }\n      childOb = !shallow && observe(newVal);\n      dep.notify();\n    }\n  });\n}\n\n/**\n * Set a property on an object. Adds the new property and\n * triggers change notification if the property doesn't\n * already exist.\n */\nfunction set (target, key, val) {\n  if (process.env.NODE_ENV !== 'production' &&\n    (isUndef(target) || isPrimitive(target))\n  ) {\n    warn((\"Cannot set reactive property on undefined, null, or primitive value: \" + ((target))));\n  }\n  if (Array.isArray(target) && isValidArrayIndex(key)) {\n    target.length = Math.max(target.length, key);\n    target.splice(key, 1, val);\n    return val\n  }\n  if (key in target && !(key in Object.prototype)) {\n    target[key] = val;\n    return val\n  }\n  var ob = (target).__ob__;\n  if (target._isVue || (ob && ob.vmCount)) {\n    process.env.NODE_ENV !== 'production' && warn(\n      'Avoid adding reactive properties to a Vue instance or its root $data ' +\n      'at runtime - declare it upfront in the data option.'\n    );\n    return val\n  }\n  if (!ob) {\n    target[key] = val;\n    return val\n  }\n  defineReactive$$1(ob.value, key, val);\n  ob.dep.notify();\n  return val\n}\n\n/**\n * Delete a property and trigger change if necessary.\n */\nfunction del (target, key) {\n  if (process.env.NODE_ENV !== 'production' &&\n    (isUndef(target) || isPrimitive(target))\n  ) {\n    warn((\"Cannot delete reactive property on undefined, null, or primitive value: \" + ((target))));\n  }\n  if (Array.isArray(target) && isValidArrayIndex(key)) {\n    target.splice(key, 1);\n    return\n  }\n  var ob = (target).__ob__;\n  if (target._isVue || (ob && ob.vmCount)) {\n    process.env.NODE_ENV !== 'production' && warn(\n      'Avoid deleting properties on a Vue instance or its root $data ' +\n      '- just set it to null.'\n    );\n    return\n  }\n  if (!hasOwn(target, key)) {\n    return\n  }\n  delete target[key];\n  if (!ob) {\n    return\n  }\n  ob.dep.notify();\n}\n\n/**\n * Collect dependencies on array elements when the array is touched, since\n * we cannot intercept array element access like property getters.\n */\nfunction dependArray (value) {\n  for (var e = (void 0), i = 0, l = value.length; i < l; i++) {\n    e = value[i];\n    e && e.__ob__ && e.__ob__.dep.depend();\n    if (Array.isArray(e)) {\n      dependArray(e);\n    }\n  }\n}\n\n/*  */\n\n/**\n * Option overwriting strategies are functions that handle\n * how to merge a parent option value and a child option\n * value into the final value.\n */\nvar strats = config.optionMergeStrategies;\n\n/**\n * Options with restrictions\n */\nif (process.env.NODE_ENV !== 'production') {\n  strats.el = strats.propsData = function (parent, child, vm, key) {\n    if (!vm) {\n      warn(\n        \"option \\\"\" + key + \"\\\" can only be used during instance \" +\n        'creation with the `new` keyword.'\n      );\n    }\n    return defaultStrat(parent, child)\n  };\n}\n\n/**\n * Helper that recursively merges two data objects together.\n */\nfunction mergeData (to, from) {\n  if (!from) { return to }\n  var key, toVal, fromVal;\n\n  var keys = hasSymbol\n    ? Reflect.ownKeys(from)\n    : Object.keys(from);\n\n  for (var i = 0; i < keys.length; i++) {\n    key = keys[i];\n    // in case the object is already observed...\n    if (key === '__ob__') { continue }\n    toVal = to[key];\n    fromVal = from[key];\n    if (!hasOwn(to, key)) {\n      set(to, key, fromVal);\n    } else if (\n      toVal !== fromVal &&\n      isPlainObject(toVal) &&\n      isPlainObject(fromVal)\n    ) {\n      mergeData(toVal, fromVal);\n    }\n  }\n  return to\n}\n\n/**\n * Data\n */\nfunction mergeDataOrFn (\n  parentVal,\n  childVal,\n  vm\n) {\n  if (!vm) {\n    // in a Vue.extend merge, both should be functions\n    if (!childVal) {\n      return parentVal\n    }\n    if (!parentVal) {\n      return childVal\n    }\n    // when parentVal & childVal are both present,\n    // we need to return a function that returns the\n    // merged result of both functions... no need to\n    // check if parentVal is a function here because\n    // it has to be a function to pass previous merges.\n    return function mergedDataFn () {\n      return mergeData(\n        typeof childVal === 'function' ? childVal.call(this, this) : childVal,\n        typeof parentVal === 'function' ? parentVal.call(this, this) : parentVal\n      )\n    }\n  } else {\n    return function mergedInstanceDataFn () {\n      // instance merge\n      var instanceData = typeof childVal === 'function'\n        ? childVal.call(vm, vm)\n        : childVal;\n      var defaultData = typeof parentVal === 'function'\n        ? parentVal.call(vm, vm)\n        : parentVal;\n      if (instanceData) {\n        return mergeData(instanceData, defaultData)\n      } else {\n        return defaultData\n      }\n    }\n  }\n}\n\nstrats.data = function (\n  parentVal,\n  childVal,\n  vm\n) {\n  if (!vm) {\n    if (childVal && typeof childVal !== 'function') {\n      process.env.NODE_ENV !== 'production' && warn(\n        'The \"data\" option should be a function ' +\n        'that returns a per-instance value in component ' +\n        'definitions.',\n        vm\n      );\n\n      return parentVal\n    }\n    return mergeDataOrFn(parentVal, childVal)\n  }\n\n  return mergeDataOrFn(parentVal, childVal, vm)\n};\n\n/**\n * Hooks and props are merged as arrays.\n */\nfunction mergeHook (\n  parentVal,\n  childVal\n) {\n  var res = childVal\n    ? parentVal\n      ? parentVal.concat(childVal)\n      : Array.isArray(childVal)\n        ? childVal\n        : [childVal]\n    : parentVal;\n  return res\n    ? dedupeHooks(res)\n    : res\n}\n\nfunction dedupeHooks (hooks) {\n  var res = [];\n  for (var i = 0; i < hooks.length; i++) {\n    if (res.indexOf(hooks[i]) === -1) {\n      res.push(hooks[i]);\n    }\n  }\n  return res\n}\n\nLIFECYCLE_HOOKS.forEach(function (hook) {\n  strats[hook] = mergeHook;\n});\n\n/**\n * Assets\n *\n * When a vm is present (instance creation), we need to do\n * a three-way merge between constructor options, instance\n * options and parent options.\n */\nfunction mergeAssets (\n  parentVal,\n  childVal,\n  vm,\n  key\n) {\n  var res = Object.create(parentVal || null);\n  if (childVal) {\n    process.env.NODE_ENV !== 'production' && assertObjectType(key, childVal, vm);\n    return extend(res, childVal)\n  } else {\n    return res\n  }\n}\n\nASSET_TYPES.forEach(function (type) {\n  strats[type + 's'] = mergeAssets;\n});\n\n/**\n * Watchers.\n *\n * Watchers hashes should not overwrite one\n * another, so we merge them as arrays.\n */\nstrats.watch = function (\n  parentVal,\n  childVal,\n  vm,\n  key\n) {\n  // work around Firefox's Object.prototype.watch...\n  if (parentVal === nativeWatch) { parentVal = undefined; }\n  if (childVal === nativeWatch) { childVal = undefined; }\n  /* istanbul ignore if */\n  if (!childVal) { return Object.create(parentVal || null) }\n  if (process.env.NODE_ENV !== 'production') {\n    assertObjectType(key, childVal, vm);\n  }\n  if (!parentVal) { return childVal }\n  var ret = {};\n  extend(ret, parentVal);\n  for (var key$1 in childVal) {\n    var parent = ret[key$1];\n    var child = childVal[key$1];\n    if (parent && !Array.isArray(parent)) {\n      parent = [parent];\n    }\n    ret[key$1] = parent\n      ? parent.concat(child)\n      : Array.isArray(child) ? child : [child];\n  }\n  return ret\n};\n\n/**\n * Other object hashes.\n */\nstrats.props =\nstrats.methods =\nstrats.inject =\nstrats.computed = function (\n  parentVal,\n  childVal,\n  vm,\n  key\n) {\n  if (childVal && process.env.NODE_ENV !== 'production') {\n    assertObjectType(key, childVal, vm);\n  }\n  if (!parentVal) { return childVal }\n  var ret = Object.create(null);\n  extend(ret, parentVal);\n  if (childVal) { extend(ret, childVal); }\n  return ret\n};\nstrats.provide = mergeDataOrFn;\n\n/**\n * Default strategy.\n */\nvar defaultStrat = function (parentVal, childVal) {\n  return childVal === undefined\n    ? parentVal\n    : childVal\n};\n\n/**\n * Validate component names\n */\nfunction checkComponents (options) {\n  for (var key in options.components) {\n    validateComponentName(key);\n  }\n}\n\nfunction validateComponentName (name) {\n  if (!new RegExp((\"^[a-zA-Z][\\\\-\\\\.0-9_\" + (unicodeRegExp.source) + \"]*$\")).test(name)) {\n    warn(\n      'Invalid component name: \"' + name + '\". Component names ' +\n      'should conform to valid custom element name in html5 specification.'\n    );\n  }\n  if (isBuiltInTag(name) || config.isReservedTag(name)) {\n    warn(\n      'Do not use built-in or reserved HTML elements as component ' +\n      'id: ' + name\n    );\n  }\n}\n\n/**\n * Ensure all props option syntax are normalized into the\n * Object-based format.\n */\nfunction normalizeProps (options, vm) {\n  var props = options.props;\n  if (!props) { return }\n  var res = {};\n  var i, val, name;\n  if (Array.isArray(props)) {\n    i = props.length;\n    while (i--) {\n      val = props[i];\n      if (typeof val === 'string') {\n        name = camelize(val);\n        res[name] = { type: null };\n      } else if (process.env.NODE_ENV !== 'production') {\n        warn('props must be strings when using array syntax.');\n      }\n    }\n  } else if (isPlainObject(props)) {\n    for (var key in props) {\n      val = props[key];\n      name = camelize(key);\n      res[name] = isPlainObject(val)\n        ? val\n        : { type: val };\n    }\n  } else if (process.env.NODE_ENV !== 'production') {\n    warn(\n      \"Invalid value for option \\\"props\\\": expected an Array or an Object, \" +\n      \"but got \" + (toRawType(props)) + \".\",\n      vm\n    );\n  }\n  options.props = res;\n}\n\n/**\n * Normalize all injections into Object-based format\n */\nfunction normalizeInject (options, vm) {\n  var inject = options.inject;\n  if (!inject) { return }\n  var normalized = options.inject = {};\n  if (Array.isArray(inject)) {\n    for (var i = 0; i < inject.length; i++) {\n      normalized[inject[i]] = { from: inject[i] };\n    }\n  } else if (isPlainObject(inject)) {\n    for (var key in inject) {\n      var val = inject[key];\n      normalized[key] = isPlainObject(val)\n        ? extend({ from: key }, val)\n        : { from: val };\n    }\n  } else if (process.env.NODE_ENV !== 'production') {\n    warn(\n      \"Invalid value for option \\\"inject\\\": expected an Array or an Object, \" +\n      \"but got \" + (toRawType(inject)) + \".\",\n      vm\n    );\n  }\n}\n\n/**\n * Normalize raw function directives into object format.\n */\nfunction normalizeDirectives (options) {\n  var dirs = options.directives;\n  if (dirs) {\n    for (var key in dirs) {\n      var def$$1 = dirs[key];\n      if (typeof def$$1 === 'function') {\n        dirs[key] = { bind: def$$1, update: def$$1 };\n      }\n    }\n  }\n}\n\nfunction assertObjectType (name, value, vm) {\n  if (!isPlainObject(value)) {\n    warn(\n      \"Invalid value for option \\\"\" + name + \"\\\": expected an Object, \" +\n      \"but got \" + (toRawType(value)) + \".\",\n      vm\n    );\n  }\n}\n\n/**\n * Merge two option objects into a new one.\n * Core utility used in both instantiation and inheritance.\n */\nfunction mergeOptions (\n  parent,\n  child,\n  vm\n) {\n  if (process.env.NODE_ENV !== 'production') {\n    checkComponents(child);\n  }\n\n  if (typeof child === 'function') {\n    child = child.options;\n  }\n\n  normalizeProps(child, vm);\n  normalizeInject(child, vm);\n  normalizeDirectives(child);\n\n  // Apply extends and mixins on the child options,\n  // but only if it is a raw options object that isn't\n  // the result of another mergeOptions call.\n  // Only merged options has the _base property.\n  if (!child._base) {\n    if (child.extends) {\n      parent = mergeOptions(parent, child.extends, vm);\n    }\n    if (child.mixins) {\n      for (var i = 0, l = child.mixins.length; i < l; i++) {\n        parent = mergeOptions(parent, child.mixins[i], vm);\n      }\n    }\n  }\n\n  var options = {};\n  var key;\n  for (key in parent) {\n    mergeField(key);\n  }\n  for (key in child) {\n    if (!hasOwn(parent, key)) {\n      mergeField(key);\n    }\n  }\n  function mergeField (key) {\n    var strat = strats[key] || defaultStrat;\n    options[key] = strat(parent[key], child[key], vm, key);\n  }\n  return options\n}\n\n/**\n * Resolve an asset.\n * This function is used because child instances need access\n * to assets defined in its ancestor chain.\n */\nfunction resolveAsset (\n  options,\n  type,\n  id,\n  warnMissing\n) {\n  /* istanbul ignore if */\n  if (typeof id !== 'string') {\n    return\n  }\n  var assets = options[type];\n  // check local registration variations first\n  if (hasOwn(assets, id)) { return assets[id] }\n  var camelizedId = camelize(id);\n  if (hasOwn(assets, camelizedId)) { return assets[camelizedId] }\n  var PascalCaseId = capitalize(camelizedId);\n  if (hasOwn(assets, PascalCaseId)) { return assets[PascalCaseId] }\n  // fallback to prototype chain\n  var res = assets[id] || assets[camelizedId] || assets[PascalCaseId];\n  if (process.env.NODE_ENV !== 'production' && warnMissing && !res) {\n    warn(\n      'Failed to resolve ' + type.slice(0, -1) + ': ' + id,\n      options\n    );\n  }\n  return res\n}\n\n/*  */\n\n\n\nfunction validateProp (\n  key,\n  propOptions,\n  propsData,\n  vm\n) {\n  var prop = propOptions[key];\n  var absent = !hasOwn(propsData, key);\n  var value = propsData[key];\n  // boolean casting\n  var booleanIndex = getTypeIndex(Boolean, prop.type);\n  if (booleanIndex > -1) {\n    if (absent && !hasOwn(prop, 'default')) {\n      value = false;\n    } else if (value === '' || value === hyphenate(key)) {\n      // only cast empty string / same name to boolean if\n      // boolean has higher priority\n      var stringIndex = getTypeIndex(String, prop.type);\n      if (stringIndex < 0 || booleanIndex < stringIndex) {\n        value = true;\n      }\n    }\n  }\n  // check default value\n  if (value === undefined) {\n    value = getPropDefaultValue(vm, prop, key);\n    // since the default value is a fresh copy,\n    // make sure to observe it.\n    var prevShouldObserve = shouldObserve;\n    toggleObserving(true);\n    observe(value);\n    toggleObserving(prevShouldObserve);\n  }\n  if (\n    process.env.NODE_ENV !== 'production' &&\n    // skip validation for weex recycle-list child component props\n    !(false)\n  ) {\n    assertProp(prop, key, value, vm, absent);\n  }\n  return value\n}\n\n/**\n * Get the default value of a prop.\n */\nfunction getPropDefaultValue (vm, prop, key) {\n  // no default, return undefined\n  if (!hasOwn(prop, 'default')) {\n    return undefined\n  }\n  var def = prop.default;\n  // warn against non-factory defaults for Object & Array\n  if (process.env.NODE_ENV !== 'production' && isObject(def)) {\n    warn(\n      'Invalid default value for prop \"' + key + '\": ' +\n      'Props with type Object/Array must use a factory function ' +\n      'to return the default value.',\n      vm\n    );\n  }\n  // the raw prop value was also undefined from previous render,\n  // return previous default value to avoid unnecessary watcher trigger\n  if (vm && vm.$options.propsData &&\n    vm.$options.propsData[key] === undefined &&\n    vm._props[key] !== undefined\n  ) {\n    return vm._props[key]\n  }\n  // call factory function for non-Function types\n  // a value is Function if its prototype is function even across different execution context\n  return typeof def === 'function' && getType(prop.type) !== 'Function'\n    ? def.call(vm)\n    : def\n}\n\n/**\n * Assert whether a prop is valid.\n */\nfunction assertProp (\n  prop,\n  name,\n  value,\n  vm,\n  absent\n) {\n  if (prop.required && absent) {\n    warn(\n      'Missing required prop: \"' + name + '\"',\n      vm\n    );\n    return\n  }\n  if (value == null && !prop.required) {\n    return\n  }\n  var type = prop.type;\n  var valid = !type || type === true;\n  var expectedTypes = [];\n  if (type) {\n    if (!Array.isArray(type)) {\n      type = [type];\n    }\n    for (var i = 0; i < type.length && !valid; i++) {\n      var assertedType = assertType(value, type[i]);\n      expectedTypes.push(assertedType.expectedType || '');\n      valid = assertedType.valid;\n    }\n  }\n\n  if (!valid) {\n    warn(\n      getInvalidTypeMessage(name, value, expectedTypes),\n      vm\n    );\n    return\n  }\n  var validator = prop.validator;\n  if (validator) {\n    if (!validator(value)) {\n      warn(\n        'Invalid prop: custom validator check failed for prop \"' + name + '\".',\n        vm\n      );\n    }\n  }\n}\n\nvar simpleCheckRE = /^(String|Number|Boolean|Function|Symbol)$/;\n\nfunction assertType (value, type) {\n  var valid;\n  var expectedType = getType(type);\n  if (simpleCheckRE.test(expectedType)) {\n    var t = typeof value;\n    valid = t === expectedType.toLowerCase();\n    // for primitive wrapper objects\n    if (!valid && t === 'object') {\n      valid = value instanceof type;\n    }\n  } else if (expectedType === 'Object') {\n    valid = isPlainObject(value);\n  } else if (expectedType === 'Array') {\n    valid = Array.isArray(value);\n  } else {\n    valid = value instanceof type;\n  }\n  return {\n    valid: valid,\n    expectedType: expectedType\n  }\n}\n\n/**\n * Use function string name to check built-in types,\n * because a simple equality check will fail when running\n * across different vms / iframes.\n */\nfunction getType (fn) {\n  var match = fn && fn.toString().match(/^\\s*function (\\w+)/);\n  return match ? match[1] : ''\n}\n\nfunction isSameType (a, b) {\n  return getType(a) === getType(b)\n}\n\nfunction getTypeIndex (type, expectedTypes) {\n  if (!Array.isArray(expectedTypes)) {\n    return isSameType(expectedTypes, type) ? 0 : -1\n  }\n  for (var i = 0, len = expectedTypes.length; i < len; i++) {\n    if (isSameType(expectedTypes[i], type)) {\n      return i\n    }\n  }\n  return -1\n}\n\nfunction getInvalidTypeMessage (name, value, expectedTypes) {\n  var message = \"Invalid prop: type check failed for prop \\\"\" + name + \"\\\".\" +\n    \" Expected \" + (expectedTypes.map(capitalize).join(', '));\n  var expectedType = expectedTypes[0];\n  var receivedType = toRawType(value);\n  var expectedValue = styleValue(value, expectedType);\n  var receivedValue = styleValue(value, receivedType);\n  // check if we need to specify expected value\n  if (expectedTypes.length === 1 &&\n      isExplicable(expectedType) &&\n      !isBoolean(expectedType, receivedType)) {\n    message += \" with value \" + expectedValue;\n  }\n  message += \", got \" + receivedType + \" \";\n  // check if we need to specify received value\n  if (isExplicable(receivedType)) {\n    message += \"with value \" + receivedValue + \".\";\n  }\n  return message\n}\n\nfunction styleValue (value, type) {\n  if (type === 'String') {\n    return (\"\\\"\" + value + \"\\\"\")\n  } else if (type === 'Number') {\n    return (\"\" + (Number(value)))\n  } else {\n    return (\"\" + value)\n  }\n}\n\nfunction isExplicable (value) {\n  var explicitTypes = ['string', 'number', 'boolean'];\n  return explicitTypes.some(function (elem) { return value.toLowerCase() === elem; })\n}\n\nfunction isBoolean () {\n  var args = [], len = arguments.length;\n  while ( len-- ) args[ len ] = arguments[ len ];\n\n  return args.some(function (elem) { return elem.toLowerCase() === 'boolean'; })\n}\n\n/*  */\n\nfunction handleError (err, vm, info) {\n  // Deactivate deps tracking while processing error handler to avoid possible infinite rendering.\n  // See: https://github.com/vuejs/vuex/issues/1505\n  pushTarget();\n  try {\n    if (vm) {\n      var cur = vm;\n      while ((cur = cur.$parent)) {\n        var hooks = cur.$options.errorCaptured;\n        if (hooks) {\n          for (var i = 0; i < hooks.length; i++) {\n            try {\n              var capture = hooks[i].call(cur, err, vm, info) === false;\n              if (capture) { return }\n            } catch (e) {\n              globalHandleError(e, cur, 'errorCaptured hook');\n            }\n          }\n        }\n      }\n    }\n    globalHandleError(err, vm, info);\n  } finally {\n    popTarget();\n  }\n}\n\nfunction invokeWithErrorHandling (\n  handler,\n  context,\n  args,\n  vm,\n  info\n) {\n  var res;\n  try {\n    res = args ? handler.apply(context, args) : handler.call(context);\n    if (res && !res._isVue && isPromise(res) && !res._handled) {\n      res.catch(function (e) { return handleError(e, vm, info + \" (Promise/async)\"); });\n      // issue #9511\n      // avoid catch triggering multiple times when nested calls\n      res._handled = true;\n    }\n  } catch (e) {\n    handleError(e, vm, info);\n  }\n  return res\n}\n\nfunction globalHandleError (err, vm, info) {\n  if (config.errorHandler) {\n    try {\n      return config.errorHandler.call(null, err, vm, info)\n    } catch (e) {\n      // if the user intentionally throws the original error in the handler,\n      // do not log it twice\n      if (e !== err) {\n        logError(e, null, 'config.errorHandler');\n      }\n    }\n  }\n  logError(err, vm, info);\n}\n\nfunction logError (err, vm, info) {\n  if (process.env.NODE_ENV !== 'production') {\n    warn((\"Error in \" + info + \": \\\"\" + (err.toString()) + \"\\\"\"), vm);\n  }\n  /* istanbul ignore else */\n  if ((inBrowser || inWeex) && typeof console !== 'undefined') {\n    console.error(err);\n  } else {\n    throw err\n  }\n}\n\n/*  */\n\nvar isUsingMicroTask = false;\n\nvar callbacks = [];\nvar pending = false;\n\nfunction flushCallbacks () {\n  pending = false;\n  var copies = callbacks.slice(0);\n  callbacks.length = 0;\n  for (var i = 0; i < copies.length; i++) {\n    copies[i]();\n  }\n}\n\n// Here we have async deferring wrappers using microtasks.\n// In 2.5 we used (macro) tasks (in combination with microtasks).\n// However, it has subtle problems when state is changed right before repaint\n// (e.g. #6813, out-in transitions).\n// Also, using (macro) tasks in event handler would cause some weird behaviors\n// that cannot be circumvented (e.g. #7109, #7153, #7546, #7834, #8109).\n// So we now use microtasks everywhere, again.\n// A major drawback of this tradeoff is that there are some scenarios\n// where microtasks have too high a priority and fire in between supposedly\n// sequential events (e.g. #4521, #6690, which have workarounds)\n// or even between bubbling of the same event (#6566).\nvar timerFunc;\n\n// The nextTick behavior leverages the microtask queue, which can be accessed\n// via either native Promise.then or MutationObserver.\n// MutationObserver has wider support, however it is seriously bugged in\n// UIWebView in iOS >= 9.3.3 when triggered in touch event handlers. It\n// completely stops working after triggering a few times... so, if native\n// Promise is available, we will use it:\n/* istanbul ignore next, $flow-disable-line */\nif (typeof Promise !== 'undefined' && isNative(Promise)) {\n  var p = Promise.resolve();\n  timerFunc = function () {\n    p.then(flushCallbacks);\n    // In problematic UIWebViews, Promise.then doesn't completely break, but\n    // it can get stuck in a weird state where callbacks are pushed into the\n    // microtask queue but the queue isn't being flushed, until the browser\n    // needs to do some other work, e.g. handle a timer. Therefore we can\n    // \"force\" the microtask queue to be flushed by adding an empty timer.\n    if (isIOS) { setTimeout(noop); }\n  };\n  isUsingMicroTask = true;\n} else if (!isIE && typeof MutationObserver !== 'undefined' && (\n  isNative(MutationObserver) ||\n  // PhantomJS and iOS 7.x\n  MutationObserver.toString() === '[object MutationObserverConstructor]'\n)) {\n  // Use MutationObserver where native Promise is not available,\n  // e.g. PhantomJS, iOS7, Android 4.4\n  // (#6466 MutationObserver is unreliable in IE11)\n  var counter = 1;\n  var observer = new MutationObserver(flushCallbacks);\n  var textNode = document.createTextNode(String(counter));\n  observer.observe(textNode, {\n    characterData: true\n  });\n  timerFunc = function () {\n    counter = (counter + 1) % 2;\n    textNode.data = String(counter);\n  };\n  isUsingMicroTask = true;\n} else if (typeof setImmediate !== 'undefined' && isNative(setImmediate)) {\n  // Fallback to setImmediate.\n  // Techinically it leverages the (macro) task queue,\n  // but it is still a better choice than setTimeout.\n  timerFunc = function () {\n    setImmediate(flushCallbacks);\n  };\n} else {\n  // Fallback to setTimeout.\n  timerFunc = function () {\n    setTimeout(flushCallbacks, 0);\n  };\n}\n\nfunction nextTick (cb, ctx) {\n  var _resolve;\n  callbacks.push(function () {\n    if (cb) {\n      try {\n        cb.call(ctx);\n      } catch (e) {\n        handleError(e, ctx, 'nextTick');\n      }\n    } else if (_resolve) {\n      _resolve(ctx);\n    }\n  });\n  if (!pending) {\n    pending = true;\n    timerFunc();\n  }\n  // $flow-disable-line\n  if (!cb && typeof Promise !== 'undefined') {\n    return new Promise(function (resolve) {\n      _resolve = resolve;\n    })\n  }\n}\n\n/*  */\n\nvar mark;\nvar measure;\n\nif (process.env.NODE_ENV !== 'production') {\n  var perf = inBrowser && window.performance;\n  /* istanbul ignore if */\n  if (\n    perf &&\n    perf.mark &&\n    perf.measure &&\n    perf.clearMarks &&\n    perf.clearMeasures\n  ) {\n    mark = function (tag) { return perf.mark(tag); };\n    measure = function (name, startTag, endTag) {\n      perf.measure(name, startTag, endTag);\n      perf.clearMarks(startTag);\n      perf.clearMarks(endTag);\n      // perf.clearMeasures(name)\n    };\n  }\n}\n\n/* not type checking this file because flow doesn't play well with Proxy */\n\nvar initProxy;\n\nif (process.env.NODE_ENV !== 'production') {\n  var allowedGlobals = makeMap(\n    'Infinity,undefined,NaN,isFinite,isNaN,' +\n    'parseFloat,parseInt,decodeURI,decodeURIComponent,encodeURI,encodeURIComponent,' +\n    'Math,Number,Date,Array,Object,Boolean,String,RegExp,Map,Set,JSON,Intl,' +\n    'require' // for Webpack/Browserify\n  );\n\n  var warnNonPresent = function (target, key) {\n    warn(\n      \"Property or method \\\"\" + key + \"\\\" is not defined on the instance but \" +\n      'referenced during render. Make sure that this property is reactive, ' +\n      'either in the data option, or for class-based components, by ' +\n      'initializing the property. ' +\n      'See: https://vuejs.org/v2/guide/reactivity.html#Declaring-Reactive-Properties.',\n      target\n    );\n  };\n\n  var warnReservedPrefix = function (target, key) {\n    warn(\n      \"Property \\\"\" + key + \"\\\" must be accessed with \\\"$data.\" + key + \"\\\" because \" +\n      'properties starting with \"$\" or \"_\" are not proxied in the Vue instance to ' +\n      'prevent conflicts with Vue internals' +\n      'See: https://vuejs.org/v2/api/#data',\n      target\n    );\n  };\n\n  var hasProxy =\n    typeof Proxy !== 'undefined' && isNative(Proxy);\n\n  if (hasProxy) {\n    var isBuiltInModifier = makeMap('stop,prevent,self,ctrl,shift,alt,meta,exact');\n    config.keyCodes = new Proxy(config.keyCodes, {\n      set: function set (target, key, value) {\n        if (isBuiltInModifier(key)) {\n          warn((\"Avoid overwriting built-in modifier in config.keyCodes: .\" + key));\n          return false\n        } else {\n          target[key] = value;\n          return true\n        }\n      }\n    });\n  }\n\n  var hasHandler = {\n    has: function has (target, key) {\n      var has = key in target;\n      var isAllowed = allowedGlobals(key) ||\n        (typeof key === 'string' && key.charAt(0) === '_' && !(key in target.$data));\n      if (!has && !isAllowed) {\n        if (key in target.$data) { warnReservedPrefix(target, key); }\n        else { warnNonPresent(target, key); }\n      }\n      return has || !isAllowed\n    }\n  };\n\n  var getHandler = {\n    get: function get (target, key) {\n      if (typeof key === 'string' && !(key in target)) {\n        if (key in target.$data) { warnReservedPrefix(target, key); }\n        else { warnNonPresent(target, key); }\n      }\n      return target[key]\n    }\n  };\n\n  initProxy = function initProxy (vm) {\n    if (hasProxy) {\n      // determine which proxy handler to use\n      var options = vm.$options;\n      var handlers = options.render && options.render._withStripped\n        ? getHandler\n        : hasHandler;\n      vm._renderProxy = new Proxy(vm, handlers);\n    } else {\n      vm._renderProxy = vm;\n    }\n  };\n}\n\n/*  */\n\nvar seenObjects = new _Set();\n\n/**\n * Recursively traverse an object to evoke all converted\n * getters, so that every nested property inside the object\n * is collected as a \"deep\" dependency.\n */\nfunction traverse (val) {\n  _traverse(val, seenObjects);\n  seenObjects.clear();\n}\n\nfunction _traverse (val, seen) {\n  var i, keys;\n  var isA = Array.isArray(val);\n  if ((!isA && !isObject(val)) || Object.isFrozen(val) || val instanceof VNode) {\n    return\n  }\n  if (val.__ob__) {\n    var depId = val.__ob__.dep.id;\n    if (seen.has(depId)) {\n      return\n    }\n    seen.add(depId);\n  }\n  if (isA) {\n    i = val.length;\n    while (i--) { _traverse(val[i], seen); }\n  } else {\n    keys = Object.keys(val);\n    i = keys.length;\n    while (i--) { _traverse(val[keys[i]], seen); }\n  }\n}\n\n/*  */\n\nvar normalizeEvent = cached(function (name) {\n  var passive = name.charAt(0) === '&';\n  name = passive ? name.slice(1) : name;\n  var once$$1 = name.charAt(0) === '~'; // Prefixed last, checked first\n  name = once$$1 ? name.slice(1) : name;\n  var capture = name.charAt(0) === '!';\n  name = capture ? name.slice(1) : name;\n  return {\n    name: name,\n    once: once$$1,\n    capture: capture,\n    passive: passive\n  }\n});\n\nfunction createFnInvoker (fns, vm) {\n  function invoker () {\n    var arguments$1 = arguments;\n\n    var fns = invoker.fns;\n    if (Array.isArray(fns)) {\n      var cloned = fns.slice();\n      for (var i = 0; i < cloned.length; i++) {\n        invokeWithErrorHandling(cloned[i], null, arguments$1, vm, \"v-on handler\");\n      }\n    } else {\n      // return handler return value for single handlers\n      return invokeWithErrorHandling(fns, null, arguments, vm, \"v-on handler\")\n    }\n  }\n  invoker.fns = fns;\n  return invoker\n}\n\nfunction updateListeners (\n  on,\n  oldOn,\n  add,\n  remove$$1,\n  createOnceHandler,\n  vm\n) {\n  var name, def$$1, cur, old, event;\n  for (name in on) {\n    def$$1 = cur = on[name];\n    old = oldOn[name];\n    event = normalizeEvent(name);\n    if (isUndef(cur)) {\n      process.env.NODE_ENV !== 'production' && warn(\n        \"Invalid handler for event \\\"\" + (event.name) + \"\\\": got \" + String(cur),\n        vm\n      );\n    } else if (isUndef(old)) {\n      if (isUndef(cur.fns)) {\n        cur = on[name] = createFnInvoker(cur, vm);\n      }\n      if (isTrue(event.once)) {\n        cur = on[name] = createOnceHandler(event.name, cur, event.capture);\n      }\n      add(event.name, cur, event.capture, event.passive, event.params);\n    } else if (cur !== old) {\n      old.fns = cur;\n      on[name] = old;\n    }\n  }\n  for (name in oldOn) {\n    if (isUndef(on[name])) {\n      event = normalizeEvent(name);\n      remove$$1(event.name, oldOn[name], event.capture);\n    }\n  }\n}\n\n/*  */\n\nfunction mergeVNodeHook (def, hookKey, hook) {\n  if (def instanceof VNode) {\n    def = def.data.hook || (def.data.hook = {});\n  }\n  var invoker;\n  var oldHook = def[hookKey];\n\n  function wrappedHook () {\n    hook.apply(this, arguments);\n    // important: remove merged hook to ensure it's called only once\n    // and prevent memory leak\n    remove(invoker.fns, wrappedHook);\n  }\n\n  if (isUndef(oldHook)) {\n    // no existing hook\n    invoker = createFnInvoker([wrappedHook]);\n  } else {\n    /* istanbul ignore if */\n    if (isDef(oldHook.fns) && isTrue(oldHook.merged)) {\n      // already a merged invoker\n      invoker = oldHook;\n      invoker.fns.push(wrappedHook);\n    } else {\n      // existing plain hook\n      invoker = createFnInvoker([oldHook, wrappedHook]);\n    }\n  }\n\n  invoker.merged = true;\n  def[hookKey] = invoker;\n}\n\n/*  */\n\nfunction extractPropsFromVNodeData (\n  data,\n  Ctor,\n  tag\n) {\n  // we are only extracting raw values here.\n  // validation and default values are handled in the child\n  // component itself.\n  var propOptions = Ctor.options.props;\n  if (isUndef(propOptions)) {\n    return\n  }\n  var res = {};\n  var attrs = data.attrs;\n  var props = data.props;\n  if (isDef(attrs) || isDef(props)) {\n    for (var key in propOptions) {\n      var altKey = hyphenate(key);\n      if (process.env.NODE_ENV !== 'production') {\n        var keyInLowerCase = key.toLowerCase();\n        if (\n          key !== keyInLowerCase &&\n          attrs && hasOwn(attrs, keyInLowerCase)\n        ) {\n          tip(\n            \"Prop \\\"\" + keyInLowerCase + \"\\\" is passed to component \" +\n            (formatComponentName(tag || Ctor)) + \", but the declared prop name is\" +\n            \" \\\"\" + key + \"\\\". \" +\n            \"Note that HTML attributes are case-insensitive and camelCased \" +\n            \"props need to use their kebab-case equivalents when using in-DOM \" +\n            \"templates. You should probably use \\\"\" + altKey + \"\\\" instead of \\\"\" + key + \"\\\".\"\n          );\n        }\n      }\n      checkProp(res, props, key, altKey, true) ||\n      checkProp(res, attrs, key, altKey, false);\n    }\n  }\n  return res\n}\n\nfunction checkProp (\n  res,\n  hash,\n  key,\n  altKey,\n  preserve\n) {\n  if (isDef(hash)) {\n    if (hasOwn(hash, key)) {\n      res[key] = hash[key];\n      if (!preserve) {\n        delete hash[key];\n      }\n      return true\n    } else if (hasOwn(hash, altKey)) {\n      res[key] = hash[altKey];\n      if (!preserve) {\n        delete hash[altKey];\n      }\n      return true\n    }\n  }\n  return false\n}\n\n/*  */\n\n// The template compiler attempts to minimize the need for normalization by\n// statically analyzing the template at compile time.\n//\n// For plain HTML markup, normalization can be completely skipped because the\n// generated render function is guaranteed to return Array<VNode>. There are\n// two cases where extra normalization is needed:\n\n// 1. When the children contains components - because a functional component\n// may return an Array instead of a single root. In this case, just a simple\n// normalization is needed - if any child is an Array, we flatten the whole\n// thing with Array.prototype.concat. It is guaranteed to be only 1-level deep\n// because functional components already normalize their own children.\nfunction simpleNormalizeChildren (children) {\n  for (var i = 0; i < children.length; i++) {\n    if (Array.isArray(children[i])) {\n      return Array.prototype.concat.apply([], children)\n    }\n  }\n  return children\n}\n\n// 2. When the children contains constructs that always generated nested Arrays,\n// e.g. <template>, <slot>, v-for, or when the children is provided by user\n// with hand-written render functions / JSX. In such cases a full normalization\n// is needed to cater to all possible types of children values.\nfunction normalizeChildren (children) {\n  return isPrimitive(children)\n    ? [createTextVNode(children)]\n    : Array.isArray(children)\n      ? normalizeArrayChildren(children)\n      : undefined\n}\n\nfunction isTextNode (node) {\n  return isDef(node) && isDef(node.text) && isFalse(node.isComment)\n}\n\nfunction normalizeArrayChildren (children, nestedIndex) {\n  var res = [];\n  var i, c, lastIndex, last;\n  for (i = 0; i < children.length; i++) {\n    c = children[i];\n    if (isUndef(c) || typeof c === 'boolean') { continue }\n    lastIndex = res.length - 1;\n    last = res[lastIndex];\n    //  nested\n    if (Array.isArray(c)) {\n      if (c.length > 0) {\n        c = normalizeArrayChildren(c, ((nestedIndex || '') + \"_\" + i));\n        // merge adjacent text nodes\n        if (isTextNode(c[0]) && isTextNode(last)) {\n          res[lastIndex] = createTextVNode(last.text + (c[0]).text);\n          c.shift();\n        }\n        res.push.apply(res, c);\n      }\n    } else if (isPrimitive(c)) {\n      if (isTextNode(last)) {\n        // merge adjacent text nodes\n        // this is necessary for SSR hydration because text nodes are\n        // essentially merged when rendered to HTML strings\n        res[lastIndex] = createTextVNode(last.text + c);\n      } else if (c !== '') {\n        // convert primitive to vnode\n        res.push(createTextVNode(c));\n      }\n    } else {\n      if (isTextNode(c) && isTextNode(last)) {\n        // merge adjacent text nodes\n        res[lastIndex] = createTextVNode(last.text + c.text);\n      } else {\n        // default key for nested array children (likely generated by v-for)\n        if (isTrue(children._isVList) &&\n          isDef(c.tag) &&\n          isUndef(c.key) &&\n          isDef(nestedIndex)) {\n          c.key = \"__vlist\" + nestedIndex + \"_\" + i + \"__\";\n        }\n        res.push(c);\n      }\n    }\n  }\n  return res\n}\n\n/*  */\n\nfunction initProvide (vm) {\n  var provide = vm.$options.provide;\n  if (provide) {\n    vm._provided = typeof provide === 'function'\n      ? provide.call(vm)\n      : provide;\n  }\n}\n\nfunction initInjections (vm) {\n  var result = resolveInject(vm.$options.inject, vm);\n  if (result) {\n    toggleObserving(false);\n    Object.keys(result).forEach(function (key) {\n      /* istanbul ignore else */\n      if (process.env.NODE_ENV !== 'production') {\n        defineReactive$$1(vm, key, result[key], function () {\n          warn(\n            \"Avoid mutating an injected value directly since the changes will be \" +\n            \"overwritten whenever the provided component re-renders. \" +\n            \"injection being mutated: \\\"\" + key + \"\\\"\",\n            vm\n          );\n        });\n      } else {\n        defineReactive$$1(vm, key, result[key]);\n      }\n    });\n    toggleObserving(true);\n  }\n}\n\nfunction resolveInject (inject, vm) {\n  if (inject) {\n    // inject is :any because flow is not smart enough to figure out cached\n    var result = Object.create(null);\n    var keys = hasSymbol\n      ? Reflect.ownKeys(inject)\n      : Object.keys(inject);\n\n    for (var i = 0; i < keys.length; i++) {\n      var key = keys[i];\n      // #6574 in case the inject object is observed...\n      if (key === '__ob__') { continue }\n      var provideKey = inject[key].from;\n      var source = vm;\n      while (source) {\n        if (source._provided && hasOwn(source._provided, provideKey)) {\n          result[key] = source._provided[provideKey];\n          break\n        }\n        source = source.$parent;\n      }\n      if (!source) {\n        if ('default' in inject[key]) {\n          var provideDefault = inject[key].default;\n          result[key] = typeof provideDefault === 'function'\n            ? provideDefault.call(vm)\n            : provideDefault;\n        } else if (process.env.NODE_ENV !== 'production') {\n          warn((\"Injection \\\"\" + key + \"\\\" not found\"), vm);\n        }\n      }\n    }\n    return result\n  }\n}\n\n/*  */\n\n\n\n/**\n * Runtime helper for resolving raw children VNodes into a slot object.\n */\nfunction resolveSlots (\n  children,\n  context\n) {\n  if (!children || !children.length) {\n    return {}\n  }\n  var slots = {};\n  for (var i = 0, l = children.length; i < l; i++) {\n    var child = children[i];\n    var data = child.data;\n    // remove slot attribute if the node is resolved as a Vue slot node\n    if (data && data.attrs && data.attrs.slot) {\n      delete data.attrs.slot;\n    }\n    // named slots should only be respected if the vnode was rendered in the\n    // same context.\n    if ((child.context === context || child.fnContext === context) &&\n      data && data.slot != null\n    ) {\n      var name = data.slot;\n      var slot = (slots[name] || (slots[name] = []));\n      if (child.tag === 'template') {\n        slot.push.apply(slot, child.children || []);\n      } else {\n        slot.push(child);\n      }\n    } else {\n      (slots.default || (slots.default = [])).push(child);\n    }\n  }\n  // ignore slots that contains only whitespace\n  for (var name$1 in slots) {\n    if (slots[name$1].every(isWhitespace)) {\n      delete slots[name$1];\n    }\n  }\n  return slots\n}\n\nfunction isWhitespace (node) {\n  return (node.isComment && !node.asyncFactory) || node.text === ' '\n}\n\n/*  */\n\nfunction normalizeScopedSlots (\n  slots,\n  normalSlots,\n  prevSlots\n) {\n  var res;\n  var hasNormalSlots = Object.keys(normalSlots).length > 0;\n  var isStable = slots ? !!slots.$stable : !hasNormalSlots;\n  var key = slots && slots.$key;\n  if (!slots) {\n    res = {};\n  } else if (slots._normalized) {\n    // fast path 1: child component re-render only, parent did not change\n    return slots._normalized\n  } else if (\n    isStable &&\n    prevSlots &&\n    prevSlots !== emptyObject &&\n    key === prevSlots.$key &&\n    !hasNormalSlots &&\n    !prevSlots.$hasNormal\n  ) {\n    // fast path 2: stable scoped slots w/ no normal slots to proxy,\n    // only need to normalize once\n    return prevSlots\n  } else {\n    res = {};\n    for (var key$1 in slots) {\n      if (slots[key$1] && key$1[0] !== '$') {\n        res[key$1] = normalizeScopedSlot(normalSlots, key$1, slots[key$1]);\n      }\n    }\n  }\n  // expose normal slots on scopedSlots\n  for (var key$2 in normalSlots) {\n    if (!(key$2 in res)) {\n      res[key$2] = proxyNormalSlot(normalSlots, key$2);\n    }\n  }\n  // avoriaz seems to mock a non-extensible $scopedSlots object\n  // and when that is passed down this would cause an error\n  if (slots && Object.isExtensible(slots)) {\n    (slots)._normalized = res;\n  }\n  def(res, '$stable', isStable);\n  def(res, '$key', key);\n  def(res, '$hasNormal', hasNormalSlots);\n  return res\n}\n\nfunction normalizeScopedSlot(normalSlots, key, fn) {\n  var normalized = function () {\n    var res = arguments.length ? fn.apply(null, arguments) : fn({});\n    res = res && typeof res === 'object' && !Array.isArray(res)\n      ? [res] // single vnode\n      : normalizeChildren(res);\n    return res && (\n      res.length === 0 ||\n      (res.length === 1 && res[0].isComment) // #9658\n    ) ? undefined\n      : res\n  };\n  // this is a slot using the new v-slot syntax without scope. although it is\n  // compiled as a scoped slot, render fn users would expect it to be present\n  // on this.$slots because the usage is semantically a normal slot.\n  if (fn.proxy) {\n    Object.defineProperty(normalSlots, key, {\n      get: normalized,\n      enumerable: true,\n      configurable: true\n    });\n  }\n  return normalized\n}\n\nfunction proxyNormalSlot(slots, key) {\n  return function () { return slots[key]; }\n}\n\n/*  */\n\n/**\n * Runtime helper for rendering v-for lists.\n */\nfunction renderList (\n  val,\n  render\n) {\n  var ret, i, l, keys, key;\n  if (Array.isArray(val) || typeof val === 'string') {\n    ret = new Array(val.length);\n    for (i = 0, l = val.length; i < l; i++) {\n      ret[i] = render(val[i], i);\n    }\n  } else if (typeof val === 'number') {\n    ret = new Array(val);\n    for (i = 0; i < val; i++) {\n      ret[i] = render(i + 1, i);\n    }\n  } else if (isObject(val)) {\n    if (hasSymbol && val[Symbol.iterator]) {\n      ret = [];\n      var iterator = val[Symbol.iterator]();\n      var result = iterator.next();\n      while (!result.done) {\n        ret.push(render(result.value, ret.length));\n        result = iterator.next();\n      }\n    } else {\n      keys = Object.keys(val);\n      ret = new Array(keys.length);\n      for (i = 0, l = keys.length; i < l; i++) {\n        key = keys[i];\n        ret[i] = render(val[key], key, i);\n      }\n    }\n  }\n  if (!isDef(ret)) {\n    ret = [];\n  }\n  (ret)._isVList = true;\n  return ret\n}\n\n/*  */\n\n/**\n * Runtime helper for rendering <slot>\n */\nfunction renderSlot (\n  name,\n  fallback,\n  props,\n  bindObject\n) {\n  var scopedSlotFn = this.$scopedSlots[name];\n  var nodes;\n  if (scopedSlotFn) { // scoped slot\n    props = props || {};\n    if (bindObject) {\n      if (process.env.NODE_ENV !== 'production' && !isObject(bindObject)) {\n        warn(\n          'slot v-bind without argument expects an Object',\n          this\n        );\n      }\n      props = extend(extend({}, bindObject), props);\n    }\n    nodes = scopedSlotFn(props) || fallback;\n  } else {\n    nodes = this.$slots[name] || fallback;\n  }\n\n  var target = props && props.slot;\n  if (target) {\n    return this.$createElement('template', { slot: target }, nodes)\n  } else {\n    return nodes\n  }\n}\n\n/*  */\n\n/**\n * Runtime helper for resolving filters\n */\nfunction resolveFilter (id) {\n  return resolveAsset(this.$options, 'filters', id, true) || identity\n}\n\n/*  */\n\nfunction isKeyNotMatch (expect, actual) {\n  if (Array.isArray(expect)) {\n    return expect.indexOf(actual) === -1\n  } else {\n    return expect !== actual\n  }\n}\n\n/**\n * Runtime helper for checking keyCodes from config.\n * exposed as Vue.prototype._k\n * passing in eventKeyName as last argument separately for backwards compat\n */\nfunction checkKeyCodes (\n  eventKeyCode,\n  key,\n  builtInKeyCode,\n  eventKeyName,\n  builtInKeyName\n) {\n  var mappedKeyCode = config.keyCodes[key] || builtInKeyCode;\n  if (builtInKeyName && eventKeyName && !config.keyCodes[key]) {\n    return isKeyNotMatch(builtInKeyName, eventKeyName)\n  } else if (mappedKeyCode) {\n    return isKeyNotMatch(mappedKeyCode, eventKeyCode)\n  } else if (eventKeyName) {\n    return hyphenate(eventKeyName) !== key\n  }\n}\n\n/*  */\n\n/**\n * Runtime helper for merging v-bind=\"object\" into a VNode's data.\n */\nfunction bindObjectProps (\n  data,\n  tag,\n  value,\n  asProp,\n  isSync\n) {\n  if (value) {\n    if (!isObject(value)) {\n      process.env.NODE_ENV !== 'production' && warn(\n        'v-bind without argument expects an Object or Array value',\n        this\n      );\n    } else {\n      if (Array.isArray(value)) {\n        value = toObject(value);\n      }\n      var hash;\n      var loop = function ( key ) {\n        if (\n          key === 'class' ||\n          key === 'style' ||\n          isReservedAttribute(key)\n        ) {\n          hash = data;\n        } else {\n          var type = data.attrs && data.attrs.type;\n          hash = asProp || config.mustUseProp(tag, type, key)\n            ? data.domProps || (data.domProps = {})\n            : data.attrs || (data.attrs = {});\n        }\n        var camelizedKey = camelize(key);\n        var hyphenatedKey = hyphenate(key);\n        if (!(camelizedKey in hash) && !(hyphenatedKey in hash)) {\n          hash[key] = value[key];\n\n          if (isSync) {\n            var on = data.on || (data.on = {});\n            on[(\"update:\" + key)] = function ($event) {\n              value[key] = $event;\n            };\n          }\n        }\n      };\n\n      for (var key in value) loop( key );\n    }\n  }\n  return data\n}\n\n/*  */\n\n/**\n * Runtime helper for rendering static trees.\n */\nfunction renderStatic (\n  index,\n  isInFor\n) {\n  var cached = this._staticTrees || (this._staticTrees = []);\n  var tree = cached[index];\n  // if has already-rendered static tree and not inside v-for,\n  // we can reuse the same tree.\n  if (tree && !isInFor) {\n    return tree\n  }\n  // otherwise, render a fresh tree.\n  tree = cached[index] = this.$options.staticRenderFns[index].call(\n    this._renderProxy,\n    null,\n    this // for render fns generated for functional component templates\n  );\n  markStatic(tree, (\"__static__\" + index), false);\n  return tree\n}\n\n/**\n * Runtime helper for v-once.\n * Effectively it means marking the node as static with a unique key.\n */\nfunction markOnce (\n  tree,\n  index,\n  key\n) {\n  markStatic(tree, (\"__once__\" + index + (key ? (\"_\" + key) : \"\")), true);\n  return tree\n}\n\nfunction markStatic (\n  tree,\n  key,\n  isOnce\n) {\n  if (Array.isArray(tree)) {\n    for (var i = 0; i < tree.length; i++) {\n      if (tree[i] && typeof tree[i] !== 'string') {\n        markStaticNode(tree[i], (key + \"_\" + i), isOnce);\n      }\n    }\n  } else {\n    markStaticNode(tree, key, isOnce);\n  }\n}\n\nfunction markStaticNode (node, key, isOnce) {\n  node.isStatic = true;\n  node.key = key;\n  node.isOnce = isOnce;\n}\n\n/*  */\n\nfunction bindObjectListeners (data, value) {\n  if (value) {\n    if (!isPlainObject(value)) {\n      process.env.NODE_ENV !== 'production' && warn(\n        'v-on without argument expects an Object value',\n        this\n      );\n    } else {\n      var on = data.on = data.on ? extend({}, data.on) : {};\n      for (var key in value) {\n        var existing = on[key];\n        var ours = value[key];\n        on[key] = existing ? [].concat(existing, ours) : ours;\n      }\n    }\n  }\n  return data\n}\n\n/*  */\n\nfunction resolveScopedSlots (\n  fns, // see flow/vnode\n  res,\n  // the following are added in 2.6\n  hasDynamicKeys,\n  contentHashKey\n) {\n  res = res || { $stable: !hasDynamicKeys };\n  for (var i = 0; i < fns.length; i++) {\n    var slot = fns[i];\n    if (Array.isArray(slot)) {\n      resolveScopedSlots(slot, res, hasDynamicKeys);\n    } else if (slot) {\n      // marker for reverse proxying v-slot without scope on this.$slots\n      if (slot.proxy) {\n        slot.fn.proxy = true;\n      }\n      res[slot.key] = slot.fn;\n    }\n  }\n  if (contentHashKey) {\n    (res).$key = contentHashKey;\n  }\n  return res\n}\n\n/*  */\n\nfunction bindDynamicKeys (baseObj, values) {\n  for (var i = 0; i < values.length; i += 2) {\n    var key = values[i];\n    if (typeof key === 'string' && key) {\n      baseObj[values[i]] = values[i + 1];\n    } else if (process.env.NODE_ENV !== 'production' && key !== '' && key !== null) {\n      // null is a speical value for explicitly removing a binding\n      warn(\n        (\"Invalid value for dynamic directive argument (expected string or null): \" + key),\n        this\n      );\n    }\n  }\n  return baseObj\n}\n\n// helper to dynamically append modifier runtime markers to event names.\n// ensure only append when value is already string, otherwise it will be cast\n// to string and cause the type check to miss.\nfunction prependModifier (value, symbol) {\n  return typeof value === 'string' ? symbol + value : value\n}\n\n/*  */\n\nfunction installRenderHelpers (target) {\n  target._o = markOnce;\n  target._n = toNumber;\n  target._s = toString;\n  target._l = renderList;\n  target._t = renderSlot;\n  target._q = looseEqual;\n  target._i = looseIndexOf;\n  target._m = renderStatic;\n  target._f = resolveFilter;\n  target._k = checkKeyCodes;\n  target._b = bindObjectProps;\n  target._v = createTextVNode;\n  target._e = createEmptyVNode;\n  target._u = resolveScopedSlots;\n  target._g = bindObjectListeners;\n  target._d = bindDynamicKeys;\n  target._p = prependModifier;\n}\n\n/*  */\n\nfunction FunctionalRenderContext (\n  data,\n  props,\n  children,\n  parent,\n  Ctor\n) {\n  var this$1 = this;\n\n  var options = Ctor.options;\n  // ensure the createElement function in functional components\n  // gets a unique context - this is necessary for correct named slot check\n  var contextVm;\n  if (hasOwn(parent, '_uid')) {\n    contextVm = Object.create(parent);\n    // $flow-disable-line\n    contextVm._original = parent;\n  } else {\n    // the context vm passed in is a functional context as well.\n    // in this case we want to make sure we are able to get a hold to the\n    // real context instance.\n    contextVm = parent;\n    // $flow-disable-line\n    parent = parent._original;\n  }\n  var isCompiled = isTrue(options._compiled);\n  var needNormalization = !isCompiled;\n\n  this.data = data;\n  this.props = props;\n  this.children = children;\n  this.parent = parent;\n  this.listeners = data.on || emptyObject;\n  this.injections = resolveInject(options.inject, parent);\n  this.slots = function () {\n    if (!this$1.$slots) {\n      normalizeScopedSlots(\n        data.scopedSlots,\n        this$1.$slots = resolveSlots(children, parent)\n      );\n    }\n    return this$1.$slots\n  };\n\n  Object.defineProperty(this, 'scopedSlots', ({\n    enumerable: true,\n    get: function get () {\n      return normalizeScopedSlots(data.scopedSlots, this.slots())\n    }\n  }));\n\n  // support for compiled functional template\n  if (isCompiled) {\n    // exposing $options for renderStatic()\n    this.$options = options;\n    // pre-resolve slots for renderSlot()\n    this.$slots = this.slots();\n    this.$scopedSlots = normalizeScopedSlots(data.scopedSlots, this.$slots);\n  }\n\n  if (options._scopeId) {\n    this._c = function (a, b, c, d) {\n      var vnode = createElement(contextVm, a, b, c, d, needNormalization);\n      if (vnode && !Array.isArray(vnode)) {\n        vnode.fnScopeId = options._scopeId;\n        vnode.fnContext = parent;\n      }\n      return vnode\n    };\n  } else {\n    this._c = function (a, b, c, d) { return createElement(contextVm, a, b, c, d, needNormalization); };\n  }\n}\n\ninstallRenderHelpers(FunctionalRenderContext.prototype);\n\nfunction createFunctionalComponent (\n  Ctor,\n  propsData,\n  data,\n  contextVm,\n  children\n) {\n  var options = Ctor.options;\n  var props = {};\n  var propOptions = options.props;\n  if (isDef(propOptions)) {\n    for (var key in propOptions) {\n      props[key] = validateProp(key, propOptions, propsData || emptyObject);\n    }\n  } else {\n    if (isDef(data.attrs)) { mergeProps(props, data.attrs); }\n    if (isDef(data.props)) { mergeProps(props, data.props); }\n  }\n\n  var renderContext = new FunctionalRenderContext(\n    data,\n    props,\n    children,\n    contextVm,\n    Ctor\n  );\n\n  var vnode = options.render.call(null, renderContext._c, renderContext);\n\n  if (vnode instanceof VNode) {\n    return cloneAndMarkFunctionalResult(vnode, data, renderContext.parent, options, renderContext)\n  } else if (Array.isArray(vnode)) {\n    var vnodes = normalizeChildren(vnode) || [];\n    var res = new Array(vnodes.length);\n    for (var i = 0; i < vnodes.length; i++) {\n      res[i] = cloneAndMarkFunctionalResult(vnodes[i], data, renderContext.parent, options, renderContext);\n    }\n    return res\n  }\n}\n\nfunction cloneAndMarkFunctionalResult (vnode, data, contextVm, options, renderContext) {\n  // #7817 clone node before setting fnContext, otherwise if the node is reused\n  // (e.g. it was from a cached normal slot) the fnContext causes named slots\n  // that should not be matched to match.\n  var clone = cloneVNode(vnode);\n  clone.fnContext = contextVm;\n  clone.fnOptions = options;\n  if (process.env.NODE_ENV !== 'production') {\n    (clone.devtoolsMeta = clone.devtoolsMeta || {}).renderContext = renderContext;\n  }\n  if (data.slot) {\n    (clone.data || (clone.data = {})).slot = data.slot;\n  }\n  return clone\n}\n\nfunction mergeProps (to, from) {\n  for (var key in from) {\n    to[camelize(key)] = from[key];\n  }\n}\n\n/*  */\n\n/*  */\n\n/*  */\n\n/*  */\n\n// inline hooks to be invoked on component VNodes during patch\nvar componentVNodeHooks = {\n  init: function init (vnode, hydrating) {\n    if (\n      vnode.componentInstance &&\n      !vnode.componentInstance._isDestroyed &&\n      vnode.data.keepAlive\n    ) {\n      // kept-alive components, treat as a patch\n      var mountedNode = vnode; // work around flow\n      componentVNodeHooks.prepatch(mountedNode, mountedNode);\n    } else {\n      var child = vnode.componentInstance = createComponentInstanceForVnode(\n        vnode,\n        activeInstance\n      );\n      child.$mount(hydrating ? vnode.elm : undefined, hydrating);\n    }\n  },\n\n  prepatch: function prepatch (oldVnode, vnode) {\n    var options = vnode.componentOptions;\n    var child = vnode.componentInstance = oldVnode.componentInstance;\n    updateChildComponent(\n      child,\n      options.propsData, // updated props\n      options.listeners, // updated listeners\n      vnode, // new parent vnode\n      options.children // new children\n    );\n  },\n\n  insert: function insert (vnode) {\n    var context = vnode.context;\n    var componentInstance = vnode.componentInstance;\n    if (!componentInstance._isMounted) {\n      componentInstance._isMounted = true;\n      callHook(componentInstance, 'mounted');\n    }\n    if (vnode.data.keepAlive) {\n      if (context._isMounted) {\n        // vue-router#1212\n        // During updates, a kept-alive component's child components may\n        // change, so directly walking the tree here may call activated hooks\n        // on incorrect children. Instead we push them into a queue which will\n        // be processed after the whole patch process ended.\n        queueActivatedComponent(componentInstance);\n      } else {\n        activateChildComponent(componentInstance, true /* direct */);\n      }\n    }\n  },\n\n  destroy: function destroy (vnode) {\n    var componentInstance = vnode.componentInstance;\n    if (!componentInstance._isDestroyed) {\n      if (!vnode.data.keepAlive) {\n        componentInstance.$destroy();\n      } else {\n        deactivateChildComponent(componentInstance, true /* direct */);\n      }\n    }\n  }\n};\n\nvar hooksToMerge = Object.keys(componentVNodeHooks);\n\nfunction createComponent (\n  Ctor,\n  data,\n  context,\n  children,\n  tag\n) {\n  if (isUndef(Ctor)) {\n    return\n  }\n\n  var baseCtor = context.$options._base;\n\n  // plain options object: turn it into a constructor\n  if (isObject(Ctor)) {\n    Ctor = baseCtor.extend(Ctor);\n  }\n\n  // if at this stage it's not a constructor or an async component factory,\n  // reject.\n  if (typeof Ctor !== 'function') {\n    if (process.env.NODE_ENV !== 'production') {\n      warn((\"Invalid Component definition: \" + (String(Ctor))), context);\n    }\n    return\n  }\n\n  // async component\n  var asyncFactory;\n  if (isUndef(Ctor.cid)) {\n    asyncFactory = Ctor;\n    Ctor = resolveAsyncComponent(asyncFactory, baseCtor);\n    if (Ctor === undefined) {\n      // return a placeholder node for async component, which is rendered\n      // as a comment node but preserves all the raw information for the node.\n      // the information will be used for async server-rendering and hydration.\n      return createAsyncPlaceholder(\n        asyncFactory,\n        data,\n        context,\n        children,\n        tag\n      )\n    }\n  }\n\n  data = data || {};\n\n  // resolve constructor options in case global mixins are applied after\n  // component constructor creation\n  resolveConstructorOptions(Ctor);\n\n  // transform component v-model data into props & events\n  if (isDef(data.model)) {\n    transformModel(Ctor.options, data);\n  }\n\n  // extract props\n  var propsData = extractPropsFromVNodeData(data, Ctor, tag);\n\n  // functional component\n  if (isTrue(Ctor.options.functional)) {\n    return createFunctionalComponent(Ctor, propsData, data, context, children)\n  }\n\n  // extract listeners, since these needs to be treated as\n  // child component listeners instead of DOM listeners\n  var listeners = data.on;\n  // replace with listeners with .native modifier\n  // so it gets processed during parent component patch.\n  data.on = data.nativeOn;\n\n  if (isTrue(Ctor.options.abstract)) {\n    // abstract components do not keep anything\n    // other than props & listeners & slot\n\n    // work around flow\n    var slot = data.slot;\n    data = {};\n    if (slot) {\n      data.slot = slot;\n    }\n  }\n\n  // install component management hooks onto the placeholder node\n  installComponentHooks(data);\n\n  // return a placeholder vnode\n  var name = Ctor.options.name || tag;\n  var vnode = new VNode(\n    (\"vue-component-\" + (Ctor.cid) + (name ? (\"-\" + name) : '')),\n    data, undefined, undefined, undefined, context,\n    { Ctor: Ctor, propsData: propsData, listeners: listeners, tag: tag, children: children },\n    asyncFactory\n  );\n\n  return vnode\n}\n\nfunction createComponentInstanceForVnode (\n  vnode, // we know it's MountedComponentVNode but flow doesn't\n  parent // activeInstance in lifecycle state\n) {\n  var options = {\n    _isComponent: true,\n    _parentVnode: vnode,\n    parent: parent\n  };\n  // check inline-template render functions\n  var inlineTemplate = vnode.data.inlineTemplate;\n  if (isDef(inlineTemplate)) {\n    options.render = inlineTemplate.render;\n    options.staticRenderFns = inlineTemplate.staticRenderFns;\n  }\n  return new vnode.componentOptions.Ctor(options)\n}\n\nfunction installComponentHooks (data) {\n  var hooks = data.hook || (data.hook = {});\n  for (var i = 0; i < hooksToMerge.length; i++) {\n    var key = hooksToMerge[i];\n    var existing = hooks[key];\n    var toMerge = componentVNodeHooks[key];\n    if (existing !== toMerge && !(existing && existing._merged)) {\n      hooks[key] = existing ? mergeHook$1(toMerge, existing) : toMerge;\n    }\n  }\n}\n\nfunction mergeHook$1 (f1, f2) {\n  var merged = function (a, b) {\n    // flow complains about extra args which is why we use any\n    f1(a, b);\n    f2(a, b);\n  };\n  merged._merged = true;\n  return merged\n}\n\n// transform component v-model info (value and callback) into\n// prop and event handler respectively.\nfunction transformModel (options, data) {\n  var prop = (options.model && options.model.prop) || 'value';\n  var event = (options.model && options.model.event) || 'input'\n  ;(data.attrs || (data.attrs = {}))[prop] = data.model.value;\n  var on = data.on || (data.on = {});\n  var existing = on[event];\n  var callback = data.model.callback;\n  if (isDef(existing)) {\n    if (\n      Array.isArray(existing)\n        ? existing.indexOf(callback) === -1\n        : existing !== callback\n    ) {\n      on[event] = [callback].concat(existing);\n    }\n  } else {\n    on[event] = callback;\n  }\n}\n\n/*  */\n\nvar SIMPLE_NORMALIZE = 1;\nvar ALWAYS_NORMALIZE = 2;\n\n// wrapper function for providing a more flexible interface\n// without getting yelled at by flow\nfunction createElement (\n  context,\n  tag,\n  data,\n  children,\n  normalizationType,\n  alwaysNormalize\n) {\n  if (Array.isArray(data) || isPrimitive(data)) {\n    normalizationType = children;\n    children = data;\n    data = undefined;\n  }\n  if (isTrue(alwaysNormalize)) {\n    normalizationType = ALWAYS_NORMALIZE;\n  }\n  return _createElement(context, tag, data, children, normalizationType)\n}\n\nfunction _createElement (\n  context,\n  tag,\n  data,\n  children,\n  normalizationType\n) {\n  if (isDef(data) && isDef((data).__ob__)) {\n    process.env.NODE_ENV !== 'production' && warn(\n      \"Avoid using observed data object as vnode data: \" + (JSON.stringify(data)) + \"\\n\" +\n      'Always create fresh vnode data objects in each render!',\n      context\n    );\n    return createEmptyVNode()\n  }\n  // object syntax in v-bind\n  if (isDef(data) && isDef(data.is)) {\n    tag = data.is;\n  }\n  if (!tag) {\n    // in case of component :is set to falsy value\n    return createEmptyVNode()\n  }\n  // warn against non-primitive key\n  if (process.env.NODE_ENV !== 'production' &&\n    isDef(data) && isDef(data.key) && !isPrimitive(data.key)\n  ) {\n    {\n      warn(\n        'Avoid using non-primitive value as key, ' +\n        'use string/number value instead.',\n        context\n      );\n    }\n  }\n  // support single function children as default scoped slot\n  if (Array.isArray(children) &&\n    typeof children[0] === 'function'\n  ) {\n    data = data || {};\n    data.scopedSlots = { default: children[0] };\n    children.length = 0;\n  }\n  if (normalizationType === ALWAYS_NORMALIZE) {\n    children = normalizeChildren(children);\n  } else if (normalizationType === SIMPLE_NORMALIZE) {\n    children = simpleNormalizeChildren(children);\n  }\n  var vnode, ns;\n  if (typeof tag === 'string') {\n    var Ctor;\n    ns = (context.$vnode && context.$vnode.ns) || config.getTagNamespace(tag);\n    if (config.isReservedTag(tag)) {\n      // platform built-in elements\n      vnode = new VNode(\n        config.parsePlatformTagName(tag), data, children,\n        undefined, undefined, context\n      );\n    } else if ((!data || !data.pre) && isDef(Ctor = resolveAsset(context.$options, 'components', tag))) {\n      // component\n      vnode = createComponent(Ctor, data, context, children, tag);\n    } else {\n      // unknown or unlisted namespaced elements\n      // check at runtime because it may get assigned a namespace when its\n      // parent normalizes children\n      vnode = new VNode(\n        tag, data, children,\n        undefined, undefined, context\n      );\n    }\n  } else {\n    // direct component options / constructor\n    vnode = createComponent(tag, data, context, children);\n  }\n  if (Array.isArray(vnode)) {\n    return vnode\n  } else if (isDef(vnode)) {\n    if (isDef(ns)) { applyNS(vnode, ns); }\n    if (isDef(data)) { registerDeepBindings(data); }\n    return vnode\n  } else {\n    return createEmptyVNode()\n  }\n}\n\nfunction applyNS (vnode, ns, force) {\n  vnode.ns = ns;\n  if (vnode.tag === 'foreignObject') {\n    // use default namespace inside foreignObject\n    ns = undefined;\n    force = true;\n  }\n  if (isDef(vnode.children)) {\n    for (var i = 0, l = vnode.children.length; i < l; i++) {\n      var child = vnode.children[i];\n      if (isDef(child.tag) && (\n        isUndef(child.ns) || (isTrue(force) && child.tag !== 'svg'))) {\n        applyNS(child, ns, force);\n      }\n    }\n  }\n}\n\n// ref #5318\n// necessary to ensure parent re-render when deep bindings like :style and\n// :class are used on slot nodes\nfunction registerDeepBindings (data) {\n  if (isObject(data.style)) {\n    traverse(data.style);\n  }\n  if (isObject(data.class)) {\n    traverse(data.class);\n  }\n}\n\n/*  */\n\nfunction initRender (vm) {\n  vm._vnode = null; // the root of the child tree\n  vm._staticTrees = null; // v-once cached trees\n  var options = vm.$options;\n  var parentVnode = vm.$vnode = options._parentVnode; // the placeholder node in parent tree\n  var renderContext = parentVnode && parentVnode.context;\n  vm.$slots = resolveSlots(options._renderChildren, renderContext);\n  vm.$scopedSlots = emptyObject;\n  // bind the createElement fn to this instance\n  // so that we get proper render context inside it.\n  // args order: tag, data, children, normalizationType, alwaysNormalize\n  // internal version is used by render functions compiled from templates\n  vm._c = function (a, b, c, d) { return createElement(vm, a, b, c, d, false); };\n  // normalization is always applied for the public version, used in\n  // user-written render functions.\n  vm.$createElement = function (a, b, c, d) { return createElement(vm, a, b, c, d, true); };\n\n  // $attrs & $listeners are exposed for easier HOC creation.\n  // they need to be reactive so that HOCs using them are always updated\n  var parentData = parentVnode && parentVnode.data;\n\n  /* istanbul ignore else */\n  if (process.env.NODE_ENV !== 'production') {\n    defineReactive$$1(vm, '$attrs', parentData && parentData.attrs || emptyObject, function () {\n      !isUpdatingChildComponent && warn(\"$attrs is readonly.\", vm);\n    }, true);\n    defineReactive$$1(vm, '$listeners', options._parentListeners || emptyObject, function () {\n      !isUpdatingChildComponent && warn(\"$listeners is readonly.\", vm);\n    }, true);\n  } else {\n    defineReactive$$1(vm, '$attrs', parentData && parentData.attrs || emptyObject, null, true);\n    defineReactive$$1(vm, '$listeners', options._parentListeners || emptyObject, null, true);\n  }\n}\n\nvar currentRenderingInstance = null;\n\nfunction renderMixin (Vue) {\n  // install runtime convenience helpers\n  installRenderHelpers(Vue.prototype);\n\n  Vue.prototype.$nextTick = function (fn) {\n    return nextTick(fn, this)\n  };\n\n  Vue.prototype._render = function () {\n    var vm = this;\n    var ref = vm.$options;\n    var render = ref.render;\n    var _parentVnode = ref._parentVnode;\n\n    if (_parentVnode) {\n      vm.$scopedSlots = normalizeScopedSlots(\n        _parentVnode.data.scopedSlots,\n        vm.$slots,\n        vm.$scopedSlots\n      );\n    }\n\n    // set parent vnode. this allows render functions to have access\n    // to the data on the placeholder node.\n    vm.$vnode = _parentVnode;\n    // render self\n    var vnode;\n    try {\n      // There's no need to maintain a stack becaues all render fns are called\n      // separately from one another. Nested component's render fns are called\n      // when parent component is patched.\n      currentRenderingInstance = vm;\n      vnode = render.call(vm._renderProxy, vm.$createElement);\n    } catch (e) {\n      handleError(e, vm, \"render\");\n      // return error render result,\n      // or previous vnode to prevent render error causing blank component\n      /* istanbul ignore else */\n      if (process.env.NODE_ENV !== 'production' && vm.$options.renderError) {\n        try {\n          vnode = vm.$options.renderError.call(vm._renderProxy, vm.$createElement, e);\n        } catch (e) {\n          handleError(e, vm, \"renderError\");\n          vnode = vm._vnode;\n        }\n      } else {\n        vnode = vm._vnode;\n      }\n    } finally {\n      currentRenderingInstance = null;\n    }\n    // if the returned array contains only a single node, allow it\n    if (Array.isArray(vnode) && vnode.length === 1) {\n      vnode = vnode[0];\n    }\n    // return empty vnode in case the render function errored out\n    if (!(vnode instanceof VNode)) {\n      if (process.env.NODE_ENV !== 'production' && Array.isArray(vnode)) {\n        warn(\n          'Multiple root nodes returned from render function. Render function ' +\n          'should return a single root node.',\n          vm\n        );\n      }\n      vnode = createEmptyVNode();\n    }\n    // set parent\n    vnode.parent = _parentVnode;\n    return vnode\n  };\n}\n\n/*  */\n\nfunction ensureCtor (comp, base) {\n  if (\n    comp.__esModule ||\n    (hasSymbol && comp[Symbol.toStringTag] === 'Module')\n  ) {\n    comp = comp.default;\n  }\n  return isObject(comp)\n    ? base.extend(comp)\n    : comp\n}\n\nfunction createAsyncPlaceholder (\n  factory,\n  data,\n  context,\n  children,\n  tag\n) {\n  var node = createEmptyVNode();\n  node.asyncFactory = factory;\n  node.asyncMeta = { data: data, context: context, children: children, tag: tag };\n  return node\n}\n\nfunction resolveAsyncComponent (\n  factory,\n  baseCtor\n) {\n  if (isTrue(factory.error) && isDef(factory.errorComp)) {\n    return factory.errorComp\n  }\n\n  if (isDef(factory.resolved)) {\n    return factory.resolved\n  }\n\n  var owner = currentRenderingInstance;\n  if (owner && isDef(factory.owners) && factory.owners.indexOf(owner) === -1) {\n    // already pending\n    factory.owners.push(owner);\n  }\n\n  if (isTrue(factory.loading) && isDef(factory.loadingComp)) {\n    return factory.loadingComp\n  }\n\n  if (owner && !isDef(factory.owners)) {\n    var owners = factory.owners = [owner];\n    var sync = true;\n    var timerLoading = null;\n    var timerTimeout = null\n\n    ;(owner).$on('hook:destroyed', function () { return remove(owners, owner); });\n\n    var forceRender = function (renderCompleted) {\n      for (var i = 0, l = owners.length; i < l; i++) {\n        (owners[i]).$forceUpdate();\n      }\n\n      if (renderCompleted) {\n        owners.length = 0;\n        if (timerLoading !== null) {\n          clearTimeout(timerLoading);\n          timerLoading = null;\n        }\n        if (timerTimeout !== null) {\n          clearTimeout(timerTimeout);\n          timerTimeout = null;\n        }\n      }\n    };\n\n    var resolve = once(function (res) {\n      // cache resolved\n      factory.resolved = ensureCtor(res, baseCtor);\n      // invoke callbacks only if this is not a synchronous resolve\n      // (async resolves are shimmed as synchronous during SSR)\n      if (!sync) {\n        forceRender(true);\n      } else {\n        owners.length = 0;\n      }\n    });\n\n    var reject = once(function (reason) {\n      process.env.NODE_ENV !== 'production' && warn(\n        \"Failed to resolve async component: \" + (String(factory)) +\n        (reason ? (\"\\nReason: \" + reason) : '')\n      );\n      if (isDef(factory.errorComp)) {\n        factory.error = true;\n        forceRender(true);\n      }\n    });\n\n    var res = factory(resolve, reject);\n\n    if (isObject(res)) {\n      if (isPromise(res)) {\n        // () => Promise\n        if (isUndef(factory.resolved)) {\n          res.then(resolve, reject);\n        }\n      } else if (isPromise(res.component)) {\n        res.component.then(resolve, reject);\n\n        if (isDef(res.error)) {\n          factory.errorComp = ensureCtor(res.error, baseCtor);\n        }\n\n        if (isDef(res.loading)) {\n          factory.loadingComp = ensureCtor(res.loading, baseCtor);\n          if (res.delay === 0) {\n            factory.loading = true;\n          } else {\n            timerLoading = setTimeout(function () {\n              timerLoading = null;\n              if (isUndef(factory.resolved) && isUndef(factory.error)) {\n                factory.loading = true;\n                forceRender(false);\n              }\n            }, res.delay || 200);\n          }\n        }\n\n        if (isDef(res.timeout)) {\n          timerTimeout = setTimeout(function () {\n            timerTimeout = null;\n            if (isUndef(factory.resolved)) {\n              reject(\n                process.env.NODE_ENV !== 'production'\n                  ? (\"timeout (\" + (res.timeout) + \"ms)\")\n                  : null\n              );\n            }\n          }, res.timeout);\n        }\n      }\n    }\n\n    sync = false;\n    // return in case resolved synchronously\n    return factory.loading\n      ? factory.loadingComp\n      : factory.resolved\n  }\n}\n\n/*  */\n\nfunction isAsyncPlaceholder (node) {\n  return node.isComment && node.asyncFactory\n}\n\n/*  */\n\nfunction getFirstComponentChild (children) {\n  if (Array.isArray(children)) {\n    for (var i = 0; i < children.length; i++) {\n      var c = children[i];\n      if (isDef(c) && (isDef(c.componentOptions) || isAsyncPlaceholder(c))) {\n        return c\n      }\n    }\n  }\n}\n\n/*  */\n\n/*  */\n\nfunction initEvents (vm) {\n  vm._events = Object.create(null);\n  vm._hasHookEvent = false;\n  // init parent attached events\n  var listeners = vm.$options._parentListeners;\n  if (listeners) {\n    updateComponentListeners(vm, listeners);\n  }\n}\n\nvar target;\n\nfunction add (event, fn) {\n  target.$on(event, fn);\n}\n\nfunction remove$1 (event, fn) {\n  target.$off(event, fn);\n}\n\nfunction createOnceHandler (event, fn) {\n  var _target = target;\n  return function onceHandler () {\n    var res = fn.apply(null, arguments);\n    if (res !== null) {\n      _target.$off(event, onceHandler);\n    }\n  }\n}\n\nfunction updateComponentListeners (\n  vm,\n  listeners,\n  oldListeners\n) {\n  target = vm;\n  updateListeners(listeners, oldListeners || {}, add, remove$1, createOnceHandler, vm);\n  target = undefined;\n}\n\nfunction eventsMixin (Vue) {\n  var hookRE = /^hook:/;\n  Vue.prototype.$on = function (event, fn) {\n    var vm = this;\n    if (Array.isArray(event)) {\n      for (var i = 0, l = event.length; i < l; i++) {\n        vm.$on(event[i], fn);\n      }\n    } else {\n      (vm._events[event] || (vm._events[event] = [])).push(fn);\n      // optimize hook:event cost by using a boolean flag marked at registration\n      // instead of a hash lookup\n      if (hookRE.test(event)) {\n        vm._hasHookEvent = true;\n      }\n    }\n    return vm\n  };\n\n  Vue.prototype.$once = function (event, fn) {\n    var vm = this;\n    function on () {\n      vm.$off(event, on);\n      fn.apply(vm, arguments);\n    }\n    on.fn = fn;\n    vm.$on(event, on);\n    return vm\n  };\n\n  Vue.prototype.$off = function (event, fn) {\n    var vm = this;\n    // all\n    if (!arguments.length) {\n      vm._events = Object.create(null);\n      return vm\n    }\n    // array of events\n    if (Array.isArray(event)) {\n      for (var i$1 = 0, l = event.length; i$1 < l; i$1++) {\n        vm.$off(event[i$1], fn);\n      }\n      return vm\n    }\n    // specific event\n    var cbs = vm._events[event];\n    if (!cbs) {\n      return vm\n    }\n    if (!fn) {\n      vm._events[event] = null;\n      return vm\n    }\n    // specific handler\n    var cb;\n    var i = cbs.length;\n    while (i--) {\n      cb = cbs[i];\n      if (cb === fn || cb.fn === fn) {\n        cbs.splice(i, 1);\n        break\n      }\n    }\n    return vm\n  };\n\n  Vue.prototype.$emit = function (event) {\n    var vm = this;\n    if (process.env.NODE_ENV !== 'production') {\n      var lowerCaseEvent = event.toLowerCase();\n      if (lowerCaseEvent !== event && vm._events[lowerCaseEvent]) {\n        tip(\n          \"Event \\\"\" + lowerCaseEvent + \"\\\" is emitted in component \" +\n          (formatComponentName(vm)) + \" but the handler is registered for \\\"\" + event + \"\\\". \" +\n          \"Note that HTML attributes are case-insensitive and you cannot use \" +\n          \"v-on to listen to camelCase events when using in-DOM templates. \" +\n          \"You should probably use \\\"\" + (hyphenate(event)) + \"\\\" instead of \\\"\" + event + \"\\\".\"\n        );\n      }\n    }\n    var cbs = vm._events[event];\n    if (cbs) {\n      cbs = cbs.length > 1 ? toArray(cbs) : cbs;\n      var args = toArray(arguments, 1);\n      var info = \"event handler for \\\"\" + event + \"\\\"\";\n      for (var i = 0, l = cbs.length; i < l; i++) {\n        invokeWithErrorHandling(cbs[i], vm, args, vm, info);\n      }\n    }\n    return vm\n  };\n}\n\n/*  */\n\nvar activeInstance = null;\nvar isUpdatingChildComponent = false;\n\nfunction setActiveInstance(vm) {\n  var prevActiveInstance = activeInstance;\n  activeInstance = vm;\n  return function () {\n    activeInstance = prevActiveInstance;\n  }\n}\n\nfunction initLifecycle (vm) {\n  var options = vm.$options;\n\n  // locate first non-abstract parent\n  var parent = options.parent;\n  if (parent && !options.abstract) {\n    while (parent.$options.abstract && parent.$parent) {\n      parent = parent.$parent;\n    }\n    parent.$children.push(vm);\n  }\n\n  vm.$parent = parent;\n  vm.$root = parent ? parent.$root : vm;\n\n  vm.$children = [];\n  vm.$refs = {};\n\n  vm._watcher = null;\n  vm._inactive = null;\n  vm._directInactive = false;\n  vm._isMounted = false;\n  vm._isDestroyed = false;\n  vm._isBeingDestroyed = false;\n}\n\nfunction lifecycleMixin (Vue) {\n  Vue.prototype._update = function (vnode, hydrating) {\n    var vm = this;\n    var prevEl = vm.$el;\n    var prevVnode = vm._vnode;\n    var restoreActiveInstance = setActiveInstance(vm);\n    vm._vnode = vnode;\n    // Vue.prototype.__patch__ is injected in entry points\n    // based on the rendering backend used.\n    if (!prevVnode) {\n      // initial render\n      vm.$el = vm.__patch__(vm.$el, vnode, hydrating, false /* removeOnly */);\n    } else {\n      // updates\n      vm.$el = vm.__patch__(prevVnode, vnode);\n    }\n    restoreActiveInstance();\n    // update __vue__ reference\n    if (prevEl) {\n      prevEl.__vue__ = null;\n    }\n    if (vm.$el) {\n      vm.$el.__vue__ = vm;\n    }\n    // if parent is an HOC, update its $el as well\n    if (vm.$vnode && vm.$parent && vm.$vnode === vm.$parent._vnode) {\n      vm.$parent.$el = vm.$el;\n    }\n    // updated hook is called by the scheduler to ensure that children are\n    // updated in a parent's updated hook.\n  };\n\n  Vue.prototype.$forceUpdate = function () {\n    var vm = this;\n    if (vm._watcher) {\n      vm._watcher.update();\n    }\n  };\n\n  Vue.prototype.$destroy = function () {\n    var vm = this;\n    if (vm._isBeingDestroyed) {\n      return\n    }\n    callHook(vm, 'beforeDestroy');\n    vm._isBeingDestroyed = true;\n    // remove self from parent\n    var parent = vm.$parent;\n    if (parent && !parent._isBeingDestroyed && !vm.$options.abstract) {\n      remove(parent.$children, vm);\n    }\n    // teardown watchers\n    if (vm._watcher) {\n      vm._watcher.teardown();\n    }\n    var i = vm._watchers.length;\n    while (i--) {\n      vm._watchers[i].teardown();\n    }\n    // remove reference from data ob\n    // frozen object may not have observer.\n    if (vm._data.__ob__) {\n      vm._data.__ob__.vmCount--;\n    }\n    // call the last hook...\n    vm._isDestroyed = true;\n    // invoke destroy hooks on current rendered tree\n    vm.__patch__(vm._vnode, null);\n    // fire destroyed hook\n    callHook(vm, 'destroyed');\n    // turn off all instance listeners.\n    vm.$off();\n    // remove __vue__ reference\n    if (vm.$el) {\n      vm.$el.__vue__ = null;\n    }\n    // release circular reference (#6759)\n    if (vm.$vnode) {\n      vm.$vnode.parent = null;\n    }\n  };\n}\n\nfunction mountComponent (\n  vm,\n  el,\n  hydrating\n) {\n  vm.$el = el;\n  if (!vm.$options.render) {\n    vm.$options.render = createEmptyVNode;\n    if (process.env.NODE_ENV !== 'production') {\n      /* istanbul ignore if */\n      if ((vm.$options.template && vm.$options.template.charAt(0) !== '#') ||\n        vm.$options.el || el) {\n        warn(\n          'You are using the runtime-only build of Vue where the template ' +\n          'compiler is not available. Either pre-compile the templates into ' +\n          'render functions, or use the compiler-included build.',\n          vm\n        );\n      } else {\n        warn(\n          'Failed to mount component: template or render function not defined.',\n          vm\n        );\n      }\n    }\n  }\n  callHook(vm, 'beforeMount');\n\n  var updateComponent;\n  /* istanbul ignore if */\n  if (process.env.NODE_ENV !== 'production' && config.performance && mark) {\n    updateComponent = function () {\n      var name = vm._name;\n      var id = vm._uid;\n      var startTag = \"vue-perf-start:\" + id;\n      var endTag = \"vue-perf-end:\" + id;\n\n      mark(startTag);\n      var vnode = vm._render();\n      mark(endTag);\n      measure((\"vue \" + name + \" render\"), startTag, endTag);\n\n      mark(startTag);\n      vm._update(vnode, hydrating);\n      mark(endTag);\n      measure((\"vue \" + name + \" patch\"), startTag, endTag);\n    };\n  } else {\n    updateComponent = function () {\n      vm._update(vm._render(), hydrating);\n    };\n  }\n\n  // we set this to vm._watcher inside the watcher's constructor\n  // since the watcher's initial patch may call $forceUpdate (e.g. inside child\n  // component's mounted hook), which relies on vm._watcher being already defined\n  new Watcher(vm, updateComponent, noop, {\n    before: function before () {\n      if (vm._isMounted && !vm._isDestroyed) {\n        callHook(vm, 'beforeUpdate');\n      }\n    }\n  }, true /* isRenderWatcher */);\n  hydrating = false;\n\n  // manually mounted instance, call mounted on self\n  // mounted is called for render-created child components in its inserted hook\n  if (vm.$vnode == null) {\n    vm._isMounted = true;\n    callHook(vm, 'mounted');\n  }\n  return vm\n}\n\nfunction updateChildComponent (\n  vm,\n  propsData,\n  listeners,\n  parentVnode,\n  renderChildren\n) {\n  if (process.env.NODE_ENV !== 'production') {\n    isUpdatingChildComponent = true;\n  }\n\n  // determine whether component has slot children\n  // we need to do this before overwriting $options._renderChildren.\n\n  // check if there are dynamic scopedSlots (hand-written or compiled but with\n  // dynamic slot names). Static scoped slots compiled from template has the\n  // \"$stable\" marker.\n  var newScopedSlots = parentVnode.data.scopedSlots;\n  var oldScopedSlots = vm.$scopedSlots;\n  var hasDynamicScopedSlot = !!(\n    (newScopedSlots && !newScopedSlots.$stable) ||\n    (oldScopedSlots !== emptyObject && !oldScopedSlots.$stable) ||\n    (newScopedSlots && vm.$scopedSlots.$key !== newScopedSlots.$key)\n  );\n\n  // Any static slot children from the parent may have changed during parent's\n  // update. Dynamic scoped slots may also have changed. In such cases, a forced\n  // update is necessary to ensure correctness.\n  var needsForceUpdate = !!(\n    renderChildren ||               // has new static slots\n    vm.$options._renderChildren ||  // has old static slots\n    hasDynamicScopedSlot\n  );\n\n  vm.$options._parentVnode = parentVnode;\n  vm.$vnode = parentVnode; // update vm's placeholder node without re-render\n\n  if (vm._vnode) { // update child tree's parent\n    vm._vnode.parent = parentVnode;\n  }\n  vm.$options._renderChildren = renderChildren;\n\n  // update $attrs and $listeners hash\n  // these are also reactive so they may trigger child update if the child\n  // used them during render\n  vm.$attrs = parentVnode.data.attrs || emptyObject;\n  vm.$listeners = listeners || emptyObject;\n\n  // update props\n  if (propsData && vm.$options.props) {\n    toggleObserving(false);\n    var props = vm._props;\n    var propKeys = vm.$options._propKeys || [];\n    for (var i = 0; i < propKeys.length; i++) {\n      var key = propKeys[i];\n      var propOptions = vm.$options.props; // wtf flow?\n      props[key] = validateProp(key, propOptions, propsData, vm);\n    }\n    toggleObserving(true);\n    // keep a copy of raw propsData\n    vm.$options.propsData = propsData;\n  }\n\n  // update listeners\n  listeners = listeners || emptyObject;\n  var oldListeners = vm.$options._parentListeners;\n  vm.$options._parentListeners = listeners;\n  updateComponentListeners(vm, listeners, oldListeners);\n\n  // resolve slots + force update if has children\n  if (needsForceUpdate) {\n    vm.$slots = resolveSlots(renderChildren, parentVnode.context);\n    vm.$forceUpdate();\n  }\n\n  if (process.env.NODE_ENV !== 'production') {\n    isUpdatingChildComponent = false;\n  }\n}\n\nfunction isInInactiveTree (vm) {\n  while (vm && (vm = vm.$parent)) {\n    if (vm._inactive) { return true }\n  }\n  return false\n}\n\nfunction activateChildComponent (vm, direct) {\n  if (direct) {\n    vm._directInactive = false;\n    if (isInInactiveTree(vm)) {\n      return\n    }\n  } else if (vm._directInactive) {\n    return\n  }\n  if (vm._inactive || vm._inactive === null) {\n    vm._inactive = false;\n    for (var i = 0; i < vm.$children.length; i++) {\n      activateChildComponent(vm.$children[i]);\n    }\n    callHook(vm, 'activated');\n  }\n}\n\nfunction deactivateChildComponent (vm, direct) {\n  if (direct) {\n    vm._directInactive = true;\n    if (isInInactiveTree(vm)) {\n      return\n    }\n  }\n  if (!vm._inactive) {\n    vm._inactive = true;\n    for (var i = 0; i < vm.$children.length; i++) {\n      deactivateChildComponent(vm.$children[i]);\n    }\n    callHook(vm, 'deactivated');\n  }\n}\n\nfunction callHook (vm, hook) {\n  // #7573 disable dep collection when invoking lifecycle hooks\n  pushTarget();\n  var handlers = vm.$options[hook];\n  var info = hook + \" hook\";\n  if (handlers) {\n    for (var i = 0, j = handlers.length; i < j; i++) {\n      invokeWithErrorHandling(handlers[i], vm, null, vm, info);\n    }\n  }\n  if (vm._hasHookEvent) {\n    vm.$emit('hook:' + hook);\n  }\n  popTarget();\n}\n\n/*  */\n\nvar MAX_UPDATE_COUNT = 100;\n\nvar queue = [];\nvar activatedChildren = [];\nvar has = {};\nvar circular = {};\nvar waiting = false;\nvar flushing = false;\nvar index = 0;\n\n/**\n * Reset the scheduler's state.\n */\nfunction resetSchedulerState () {\n  index = queue.length = activatedChildren.length = 0;\n  has = {};\n  if (process.env.NODE_ENV !== 'production') {\n    circular = {};\n  }\n  waiting = flushing = false;\n}\n\n// Async edge case #6566 requires saving the timestamp when event listeners are\n// attached. However, calling performance.now() has a perf overhead especially\n// if the page has thousands of event listeners. Instead, we take a timestamp\n// every time the scheduler flushes and use that for all event listeners\n// attached during that flush.\nvar currentFlushTimestamp = 0;\n\n// Async edge case fix requires storing an event listener's attach timestamp.\nvar getNow = Date.now;\n\n// Determine what event timestamp the browser is using. Annoyingly, the\n// timestamp can either be hi-res (relative to page load) or low-res\n// (relative to UNIX epoch), so in order to compare time we have to use the\n// same timestamp type when saving the flush timestamp.\n// All IE versions use low-res event timestamps, and have problematic clock\n// implementations (#9632)\nif (inBrowser && !isIE) {\n  var performance = window.performance;\n  if (\n    performance &&\n    typeof performance.now === 'function' &&\n    getNow() > document.createEvent('Event').timeStamp\n  ) {\n    // if the event timestamp, although evaluated AFTER the Date.now(), is\n    // smaller than it, it means the event is using a hi-res timestamp,\n    // and we need to use the hi-res version for event listener timestamps as\n    // well.\n    getNow = function () { return performance.now(); };\n  }\n}\n\n/**\n * Flush both queues and run the watchers.\n */\nfunction flushSchedulerQueue () {\n  currentFlushTimestamp = getNow();\n  flushing = true;\n  var watcher, id;\n\n  // Sort queue before flush.\n  // This ensures that:\n  // 1. Components are updated from parent to child. (because parent is always\n  //    created before the child)\n  // 2. A component's user watchers are run before its render watcher (because\n  //    user watchers are created before the render watcher)\n  // 3. If a component is destroyed during a parent component's watcher run,\n  //    its watchers can be skipped.\n  queue.sort(function (a, b) { return a.id - b.id; });\n\n  // do not cache length because more watchers might be pushed\n  // as we run existing watchers\n  for (index = 0; index < queue.length; index++) {\n    watcher = queue[index];\n    if (watcher.before) {\n      watcher.before();\n    }\n    id = watcher.id;\n    has[id] = null;\n    watcher.run();\n    // in dev build, check and stop circular updates.\n    if (process.env.NODE_ENV !== 'production' && has[id] != null) {\n      circular[id] = (circular[id] || 0) + 1;\n      if (circular[id] > MAX_UPDATE_COUNT) {\n        warn(\n          'You may have an infinite update loop ' + (\n            watcher.user\n              ? (\"in watcher with expression \\\"\" + (watcher.expression) + \"\\\"\")\n              : \"in a component render function.\"\n          ),\n          watcher.vm\n        );\n        break\n      }\n    }\n  }\n\n  // keep copies of post queues before resetting state\n  var activatedQueue = activatedChildren.slice();\n  var updatedQueue = queue.slice();\n\n  resetSchedulerState();\n\n  // call component updated and activated hooks\n  callActivatedHooks(activatedQueue);\n  callUpdatedHooks(updatedQueue);\n\n  // devtool hook\n  /* istanbul ignore if */\n  if (devtools && config.devtools) {\n    devtools.emit('flush');\n  }\n}\n\nfunction callUpdatedHooks (queue) {\n  var i = queue.length;\n  while (i--) {\n    var watcher = queue[i];\n    var vm = watcher.vm;\n    if (vm._watcher === watcher && vm._isMounted && !vm._isDestroyed) {\n      callHook(vm, 'updated');\n    }\n  }\n}\n\n/**\n * Queue a kept-alive component that was activated during patch.\n * The queue will be processed after the entire tree has been patched.\n */\nfunction queueActivatedComponent (vm) {\n  // setting _inactive to false here so that a render function can\n  // rely on checking whether it's in an inactive tree (e.g. router-view)\n  vm._inactive = false;\n  activatedChildren.push(vm);\n}\n\nfunction callActivatedHooks (queue) {\n  for (var i = 0; i < queue.length; i++) {\n    queue[i]._inactive = true;\n    activateChildComponent(queue[i], true /* true */);\n  }\n}\n\n/**\n * Push a watcher into the watcher queue.\n * Jobs with duplicate IDs will be skipped unless it's\n * pushed when the queue is being flushed.\n */\nfunction queueWatcher (watcher) {\n  var id = watcher.id;\n  if (has[id] == null) {\n    has[id] = true;\n    if (!flushing) {\n      queue.push(watcher);\n    } else {\n      // if already flushing, splice the watcher based on its id\n      // if already past its id, it will be run next immediately.\n      var i = queue.length - 1;\n      while (i > index && queue[i].id > watcher.id) {\n        i--;\n      }\n      queue.splice(i + 1, 0, watcher);\n    }\n    // queue the flush\n    if (!waiting) {\n      waiting = true;\n\n      if (process.env.NODE_ENV !== 'production' && !config.async) {\n        flushSchedulerQueue();\n        return\n      }\n      nextTick(flushSchedulerQueue);\n    }\n  }\n}\n\n/*  */\n\n\n\nvar uid$2 = 0;\n\n/**\n * A watcher parses an expression, collects dependencies,\n * and fires callback when the expression value changes.\n * This is used for both the $watch() api and directives.\n */\nvar Watcher = function Watcher (\n  vm,\n  expOrFn,\n  cb,\n  options,\n  isRenderWatcher\n) {\n  this.vm = vm;\n  if (isRenderWatcher) {\n    vm._watcher = this;\n  }\n  vm._watchers.push(this);\n  // options\n  if (options) {\n    this.deep = !!options.deep;\n    this.user = !!options.user;\n    this.lazy = !!options.lazy;\n    this.sync = !!options.sync;\n    this.before = options.before;\n  } else {\n    this.deep = this.user = this.lazy = this.sync = false;\n  }\n  this.cb = cb;\n  this.id = ++uid$2; // uid for batching\n  this.active = true;\n  this.dirty = this.lazy; // for lazy watchers\n  this.deps = [];\n  this.newDeps = [];\n  this.depIds = new _Set();\n  this.newDepIds = new _Set();\n  this.expression = process.env.NODE_ENV !== 'production'\n    ? expOrFn.toString()\n    : '';\n  // parse expression for getter\n  if (typeof expOrFn === 'function') {\n    this.getter = expOrFn;\n  } else {\n    this.getter = parsePath(expOrFn);\n    if (!this.getter) {\n      this.getter = noop;\n      process.env.NODE_ENV !== 'production' && warn(\n        \"Failed watching path: \\\"\" + expOrFn + \"\\\" \" +\n        'Watcher only accepts simple dot-delimited paths. ' +\n        'For full control, use a function instead.',\n        vm\n      );\n    }\n  }\n  this.value = this.lazy\n    ? undefined\n    : this.get();\n};\n\n/**\n * Evaluate the getter, and re-collect dependencies.\n */\nWatcher.prototype.get = function get () {\n  pushTarget(this);\n  var value;\n  var vm = this.vm;\n  try {\n    value = this.getter.call(vm, vm);\n  } catch (e) {\n    if (this.user) {\n      handleError(e, vm, (\"getter for watcher \\\"\" + (this.expression) + \"\\\"\"));\n    } else {\n      throw e\n    }\n  } finally {\n    // \"touch\" every property so they are all tracked as\n    // dependencies for deep watching\n    if (this.deep) {\n      traverse(value);\n    }\n    popTarget();\n    this.cleanupDeps();\n  }\n  return value\n};\n\n/**\n * Add a dependency to this directive.\n */\nWatcher.prototype.addDep = function addDep (dep) {\n  var id = dep.id;\n  if (!this.newDepIds.has(id)) {\n    this.newDepIds.add(id);\n    this.newDeps.push(dep);\n    if (!this.depIds.has(id)) {\n      dep.addSub(this);\n    }\n  }\n};\n\n/**\n * Clean up for dependency collection.\n */\nWatcher.prototype.cleanupDeps = function cleanupDeps () {\n  var i = this.deps.length;\n  while (i--) {\n    var dep = this.deps[i];\n    if (!this.newDepIds.has(dep.id)) {\n      dep.removeSub(this);\n    }\n  }\n  var tmp = this.depIds;\n  this.depIds = this.newDepIds;\n  this.newDepIds = tmp;\n  this.newDepIds.clear();\n  tmp = this.deps;\n  this.deps = this.newDeps;\n  this.newDeps = tmp;\n  this.newDeps.length = 0;\n};\n\n/**\n * Subscriber interface.\n * Will be called when a dependency changes.\n */\nWatcher.prototype.update = function update () {\n  /* istanbul ignore else */\n  if (this.lazy) {\n    this.dirty = true;\n  } else if (this.sync) {\n    this.run();\n  } else {\n    queueWatcher(this);\n  }\n};\n\n/**\n * Scheduler job interface.\n * Will be called by the scheduler.\n */\nWatcher.prototype.run = function run () {\n  if (this.active) {\n    var value = this.get();\n    if (\n      value !== this.value ||\n      // Deep watchers and watchers on Object/Arrays should fire even\n      // when the value is the same, because the value may\n      // have mutated.\n      isObject(value) ||\n      this.deep\n    ) {\n      // set new value\n      var oldValue = this.value;\n      this.value = value;\n      if (this.user) {\n        try {\n          this.cb.call(this.vm, value, oldValue);\n        } catch (e) {\n          handleError(e, this.vm, (\"callback for watcher \\\"\" + (this.expression) + \"\\\"\"));\n        }\n      } else {\n        this.cb.call(this.vm, value, oldValue);\n      }\n    }\n  }\n};\n\n/**\n * Evaluate the value of the watcher.\n * This only gets called for lazy watchers.\n */\nWatcher.prototype.evaluate = function evaluate () {\n  this.value = this.get();\n  this.dirty = false;\n};\n\n/**\n * Depend on all deps collected by this watcher.\n */\nWatcher.prototype.depend = function depend () {\n  var i = this.deps.length;\n  while (i--) {\n    this.deps[i].depend();\n  }\n};\n\n/**\n * Remove self from all dependencies' subscriber list.\n */\nWatcher.prototype.teardown = function teardown () {\n  if (this.active) {\n    // remove self from vm's watcher list\n    // this is a somewhat expensive operation so we skip it\n    // if the vm is being destroyed.\n    if (!this.vm._isBeingDestroyed) {\n      remove(this.vm._watchers, this);\n    }\n    var i = this.deps.length;\n    while (i--) {\n      this.deps[i].removeSub(this);\n    }\n    this.active = false;\n  }\n};\n\n/*  */\n\nvar sharedPropertyDefinition = {\n  enumerable: true,\n  configurable: true,\n  get: noop,\n  set: noop\n};\n\nfunction proxy (target, sourceKey, key) {\n  sharedPropertyDefinition.get = function proxyGetter () {\n    return this[sourceKey][key]\n  };\n  sharedPropertyDefinition.set = function proxySetter (val) {\n    this[sourceKey][key] = val;\n  };\n  Object.defineProperty(target, key, sharedPropertyDefinition);\n}\n\nfunction initState (vm) {\n  vm._watchers = [];\n  var opts = vm.$options;\n  if (opts.props) { initProps(vm, opts.props); }\n  if (opts.methods) { initMethods(vm, opts.methods); }\n  if (opts.data) {\n    initData(vm);\n  } else {\n    observe(vm._data = {}, true /* asRootData */);\n  }\n  if (opts.computed) { initComputed(vm, opts.computed); }\n  if (opts.watch && opts.watch !== nativeWatch) {\n    initWatch(vm, opts.watch);\n  }\n}\n\nfunction initProps (vm, propsOptions) {\n  var propsData = vm.$options.propsData || {};\n  var props = vm._props = {};\n  // cache prop keys so that future props updates can iterate using Array\n  // instead of dynamic object key enumeration.\n  var keys = vm.$options._propKeys = [];\n  var isRoot = !vm.$parent;\n  // root instance props should be converted\n  if (!isRoot) {\n    toggleObserving(false);\n  }\n  var loop = function ( key ) {\n    keys.push(key);\n    var value = validateProp(key, propsOptions, propsData, vm);\n    /* istanbul ignore else */\n    if (process.env.NODE_ENV !== 'production') {\n      var hyphenatedKey = hyphenate(key);\n      if (isReservedAttribute(hyphenatedKey) ||\n          config.isReservedAttr(hyphenatedKey)) {\n        warn(\n          (\"\\\"\" + hyphenatedKey + \"\\\" is a reserved attribute and cannot be used as component prop.\"),\n          vm\n        );\n      }\n      defineReactive$$1(props, key, value, function () {\n        if (!isRoot && !isUpdatingChildComponent) {\n          warn(\n            \"Avoid mutating a prop directly since the value will be \" +\n            \"overwritten whenever the parent component re-renders. \" +\n            \"Instead, use a data or computed property based on the prop's \" +\n            \"value. Prop being mutated: \\\"\" + key + \"\\\"\",\n            vm\n          );\n        }\n      });\n    } else {\n      defineReactive$$1(props, key, value);\n    }\n    // static props are already proxied on the component's prototype\n    // during Vue.extend(). We only need to proxy props defined at\n    // instantiation here.\n    if (!(key in vm)) {\n      proxy(vm, \"_props\", key);\n    }\n  };\n\n  for (var key in propsOptions) loop( key );\n  toggleObserving(true);\n}\n\nfunction initData (vm) {\n  var data = vm.$options.data;\n  data = vm._data = typeof data === 'function'\n    ? getData(data, vm)\n    : data || {};\n  if (!isPlainObject(data)) {\n    data = {};\n    process.env.NODE_ENV !== 'production' && warn(\n      'data functions should return an object:\\n' +\n      'https://vuejs.org/v2/guide/components.html#data-Must-Be-a-Function',\n      vm\n    );\n  }\n  // proxy data on instance\n  var keys = Object.keys(data);\n  var props = vm.$options.props;\n  var methods = vm.$options.methods;\n  var i = keys.length;\n  while (i--) {\n    var key = keys[i];\n    if (process.env.NODE_ENV !== 'production') {\n      if (methods && hasOwn(methods, key)) {\n        warn(\n          (\"Method \\\"\" + key + \"\\\" has already been defined as a data property.\"),\n          vm\n        );\n      }\n    }\n    if (props && hasOwn(props, key)) {\n      process.env.NODE_ENV !== 'production' && warn(\n        \"The data property \\\"\" + key + \"\\\" is already declared as a prop. \" +\n        \"Use prop default value instead.\",\n        vm\n      );\n    } else if (!isReserved(key)) {\n      proxy(vm, \"_data\", key);\n    }\n  }\n  // observe data\n  observe(data, true /* asRootData */);\n}\n\nfunction getData (data, vm) {\n  // #7573 disable dep collection when invoking data getters\n  pushTarget();\n  try {\n    return data.call(vm, vm)\n  } catch (e) {\n    handleError(e, vm, \"data()\");\n    return {}\n  } finally {\n    popTarget();\n  }\n}\n\nvar computedWatcherOptions = { lazy: true };\n\nfunction initComputed (vm, computed) {\n  // $flow-disable-line\n  var watchers = vm._computedWatchers = Object.create(null);\n  // computed properties are just getters during SSR\n  var isSSR = isServerRendering();\n\n  for (var key in computed) {\n    var userDef = computed[key];\n    var getter = typeof userDef === 'function' ? userDef : userDef.get;\n    if (process.env.NODE_ENV !== 'production' && getter == null) {\n      warn(\n        (\"Getter is missing for computed property \\\"\" + key + \"\\\".\"),\n        vm\n      );\n    }\n\n    if (!isSSR) {\n      // create internal watcher for the computed property.\n      watchers[key] = new Watcher(\n        vm,\n        getter || noop,\n        noop,\n        computedWatcherOptions\n      );\n    }\n\n    // component-defined computed properties are already defined on the\n    // component prototype. We only need to define computed properties defined\n    // at instantiation here.\n    if (!(key in vm)) {\n      defineComputed(vm, key, userDef);\n    } else if (process.env.NODE_ENV !== 'production') {\n      if (key in vm.$data) {\n        warn((\"The computed property \\\"\" + key + \"\\\" is already defined in data.\"), vm);\n      } else if (vm.$options.props && key in vm.$options.props) {\n        warn((\"The computed property \\\"\" + key + \"\\\" is already defined as a prop.\"), vm);\n      }\n    }\n  }\n}\n\nfunction defineComputed (\n  target,\n  key,\n  userDef\n) {\n  var shouldCache = !isServerRendering();\n  if (typeof userDef === 'function') {\n    sharedPropertyDefinition.get = shouldCache\n      ? createComputedGetter(key)\n      : createGetterInvoker(userDef);\n    sharedPropertyDefinition.set = noop;\n  } else {\n    sharedPropertyDefinition.get = userDef.get\n      ? shouldCache && userDef.cache !== false\n        ? createComputedGetter(key)\n        : createGetterInvoker(userDef.get)\n      : noop;\n    sharedPropertyDefinition.set = userDef.set || noop;\n  }\n  if (process.env.NODE_ENV !== 'production' &&\n      sharedPropertyDefinition.set === noop) {\n    sharedPropertyDefinition.set = function () {\n      warn(\n        (\"Computed property \\\"\" + key + \"\\\" was assigned to but it has no setter.\"),\n        this\n      );\n    };\n  }\n  Object.defineProperty(target, key, sharedPropertyDefinition);\n}\n\nfunction createComputedGetter (key) {\n  return function computedGetter () {\n    var watcher = this._computedWatchers && this._computedWatchers[key];\n    if (watcher) {\n      if (watcher.dirty) {\n        watcher.evaluate();\n      }\n      if (Dep.target) {\n        watcher.depend();\n      }\n      return watcher.value\n    }\n  }\n}\n\nfunction createGetterInvoker(fn) {\n  return function computedGetter () {\n    return fn.call(this, this)\n  }\n}\n\nfunction initMethods (vm, methods) {\n  var props = vm.$options.props;\n  for (var key in methods) {\n    if (process.env.NODE_ENV !== 'production') {\n      if (typeof methods[key] !== 'function') {\n        warn(\n          \"Method \\\"\" + key + \"\\\" has type \\\"\" + (typeof methods[key]) + \"\\\" in the component definition. \" +\n          \"Did you reference the function correctly?\",\n          vm\n        );\n      }\n      if (props && hasOwn(props, key)) {\n        warn(\n          (\"Method \\\"\" + key + \"\\\" has already been defined as a prop.\"),\n          vm\n        );\n      }\n      if ((key in vm) && isReserved(key)) {\n        warn(\n          \"Method \\\"\" + key + \"\\\" conflicts with an existing Vue instance method. \" +\n          \"Avoid defining component methods that start with _ or $.\"\n        );\n      }\n    }\n    vm[key] = typeof methods[key] !== 'function' ? noop : bind(methods[key], vm);\n  }\n}\n\nfunction initWatch (vm, watch) {\n  for (var key in watch) {\n    var handler = watch[key];\n    if (Array.isArray(handler)) {\n      for (var i = 0; i < handler.length; i++) {\n        createWatcher(vm, key, handler[i]);\n      }\n    } else {\n      createWatcher(vm, key, handler);\n    }\n  }\n}\n\nfunction createWatcher (\n  vm,\n  expOrFn,\n  handler,\n  options\n) {\n  if (isPlainObject(handler)) {\n    options = handler;\n    handler = handler.handler;\n  }\n  if (typeof handler === 'string') {\n    handler = vm[handler];\n  }\n  return vm.$watch(expOrFn, handler, options)\n}\n\nfunction stateMixin (Vue) {\n  // flow somehow has problems with directly declared definition object\n  // when using Object.defineProperty, so we have to procedurally build up\n  // the object here.\n  var dataDef = {};\n  dataDef.get = function () { return this._data };\n  var propsDef = {};\n  propsDef.get = function () { return this._props };\n  if (process.env.NODE_ENV !== 'production') {\n    dataDef.set = function () {\n      warn(\n        'Avoid replacing instance root $data. ' +\n        'Use nested data properties instead.',\n        this\n      );\n    };\n    propsDef.set = function () {\n      warn(\"$props is readonly.\", this);\n    };\n  }\n  Object.defineProperty(Vue.prototype, '$data', dataDef);\n  Object.defineProperty(Vue.prototype, '$props', propsDef);\n\n  Vue.prototype.$set = set;\n  Vue.prototype.$delete = del;\n\n  Vue.prototype.$watch = function (\n    expOrFn,\n    cb,\n    options\n  ) {\n    var vm = this;\n    if (isPlainObject(cb)) {\n      return createWatcher(vm, expOrFn, cb, options)\n    }\n    options = options || {};\n    options.user = true;\n    var watcher = new Watcher(vm, expOrFn, cb, options);\n    if (options.immediate) {\n      try {\n        cb.call(vm, watcher.value);\n      } catch (error) {\n        handleError(error, vm, (\"callback for immediate watcher \\\"\" + (watcher.expression) + \"\\\"\"));\n      }\n    }\n    return function unwatchFn () {\n      watcher.teardown();\n    }\n  };\n}\n\n/*  */\n\nvar uid$3 = 0;\n\nfunction initMixin (Vue) {\n  Vue.prototype._init = function (options) {\n    var vm = this;\n    // a uid\n    vm._uid = uid$3++;\n\n    var startTag, endTag;\n    /* istanbul ignore if */\n    if (process.env.NODE_ENV !== 'production' && config.performance && mark) {\n      startTag = \"vue-perf-start:\" + (vm._uid);\n      endTag = \"vue-perf-end:\" + (vm._uid);\n      mark(startTag);\n    }\n\n    // a flag to avoid this being observed\n    vm._isVue = true;\n    // merge options\n    if (options && options._isComponent) {\n      // optimize internal component instantiation\n      // since dynamic options merging is pretty slow, and none of the\n      // internal component options needs special treatment.\n      initInternalComponent(vm, options);\n    } else {\n      vm.$options = mergeOptions(\n        resolveConstructorOptions(vm.constructor),\n        options || {},\n        vm\n      );\n    }\n    /* istanbul ignore else */\n    if (process.env.NODE_ENV !== 'production') {\n      initProxy(vm);\n    } else {\n      vm._renderProxy = vm;\n    }\n    // expose real self\n    vm._self = vm;\n    initLifecycle(vm);\n    initEvents(vm);\n    initRender(vm);\n    callHook(vm, 'beforeCreate');\n    initInjections(vm); // resolve injections before data/props\n    initState(vm);\n    initProvide(vm); // resolve provide after data/props\n    callHook(vm, 'created');\n\n    /* istanbul ignore if */\n    if (process.env.NODE_ENV !== 'production' && config.performance && mark) {\n      vm._name = formatComponentName(vm, false);\n      mark(endTag);\n      measure((\"vue \" + (vm._name) + \" init\"), startTag, endTag);\n    }\n\n    if (vm.$options.el) {\n      vm.$mount(vm.$options.el);\n    }\n  };\n}\n\nfunction initInternalComponent (vm, options) {\n  var opts = vm.$options = Object.create(vm.constructor.options);\n  // doing this because it's faster than dynamic enumeration.\n  var parentVnode = options._parentVnode;\n  opts.parent = options.parent;\n  opts._parentVnode = parentVnode;\n\n  var vnodeComponentOptions = parentVnode.componentOptions;\n  opts.propsData = vnodeComponentOptions.propsData;\n  opts._parentListeners = vnodeComponentOptions.listeners;\n  opts._renderChildren = vnodeComponentOptions.children;\n  opts._componentTag = vnodeComponentOptions.tag;\n\n  if (options.render) {\n    opts.render = options.render;\n    opts.staticRenderFns = options.staticRenderFns;\n  }\n}\n\nfunction resolveConstructorOptions (Ctor) {\n  var options = Ctor.options;\n  if (Ctor.super) {\n    var superOptions = resolveConstructorOptions(Ctor.super);\n    var cachedSuperOptions = Ctor.superOptions;\n    if (superOptions !== cachedSuperOptions) {\n      // super option changed,\n      // need to resolve new options.\n      Ctor.superOptions = superOptions;\n      // check if there are any late-modified/attached options (#4976)\n      var modifiedOptions = resolveModifiedOptions(Ctor);\n      // update base extend options\n      if (modifiedOptions) {\n        extend(Ctor.extendOptions, modifiedOptions);\n      }\n      options = Ctor.options = mergeOptions(superOptions, Ctor.extendOptions);\n      if (options.name) {\n        options.components[options.name] = Ctor;\n      }\n    }\n  }\n  return options\n}\n\nfunction resolveModifiedOptions (Ctor) {\n  var modified;\n  var latest = Ctor.options;\n  var sealed = Ctor.sealedOptions;\n  for (var key in latest) {\n    if (latest[key] !== sealed[key]) {\n      if (!modified) { modified = {}; }\n      modified[key] = latest[key];\n    }\n  }\n  return modified\n}\n\nfunction Vue (options) {\n  if (process.env.NODE_ENV !== 'production' &&\n    !(this instanceof Vue)\n  ) {\n    warn('Vue is a constructor and should be called with the `new` keyword');\n  }\n  this._init(options);\n}\n\ninitMixin(Vue);\nstateMixin(Vue);\neventsMixin(Vue);\nlifecycleMixin(Vue);\nrenderMixin(Vue);\n\n/*  */\n\nfunction initUse (Vue) {\n  Vue.use = function (plugin) {\n    var installedPlugins = (this._installedPlugins || (this._installedPlugins = []));\n    if (installedPlugins.indexOf(plugin) > -1) {\n      return this\n    }\n\n    // additional parameters\n    var args = toArray(arguments, 1);\n    args.unshift(this);\n    if (typeof plugin.install === 'function') {\n      plugin.install.apply(plugin, args);\n    } else if (typeof plugin === 'function') {\n      plugin.apply(null, args);\n    }\n    installedPlugins.push(plugin);\n    return this\n  };\n}\n\n/*  */\n\nfunction initMixin$1 (Vue) {\n  Vue.mixin = function (mixin) {\n    this.options = mergeOptions(this.options, mixin);\n    return this\n  };\n}\n\n/*  */\n\nfunction initExtend (Vue) {\n  /**\n   * Each instance constructor, including Vue, has a unique\n   * cid. This enables us to create wrapped \"child\n   * constructors\" for prototypal inheritance and cache them.\n   */\n  Vue.cid = 0;\n  var cid = 1;\n\n  /**\n   * Class inheritance\n   */\n  Vue.extend = function (extendOptions) {\n    extendOptions = extendOptions || {};\n    var Super = this;\n    var SuperId = Super.cid;\n    var cachedCtors = extendOptions._Ctor || (extendOptions._Ctor = {});\n    if (cachedCtors[SuperId]) {\n      return cachedCtors[SuperId]\n    }\n\n    var name = extendOptions.name || Super.options.name;\n    if (process.env.NODE_ENV !== 'production' && name) {\n      validateComponentName(name);\n    }\n\n    var Sub = function VueComponent (options) {\n      this._init(options);\n    };\n    Sub.prototype = Object.create(Super.prototype);\n    Sub.prototype.constructor = Sub;\n    Sub.cid = cid++;\n    Sub.options = mergeOptions(\n      Super.options,\n      extendOptions\n    );\n    Sub['super'] = Super;\n\n    // For props and computed properties, we define the proxy getters on\n    // the Vue instances at extension time, on the extended prototype. This\n    // avoids Object.defineProperty calls for each instance created.\n    if (Sub.options.props) {\n      initProps$1(Sub);\n    }\n    if (Sub.options.computed) {\n      initComputed$1(Sub);\n    }\n\n    // allow further extension/mixin/plugin usage\n    Sub.extend = Super.extend;\n    Sub.mixin = Super.mixin;\n    Sub.use = Super.use;\n\n    // create asset registers, so extended classes\n    // can have their private assets too.\n    ASSET_TYPES.forEach(function (type) {\n      Sub[type] = Super[type];\n    });\n    // enable recursive self-lookup\n    if (name) {\n      Sub.options.components[name] = Sub;\n    }\n\n    // keep a reference to the super options at extension time.\n    // later at instantiation we can check if Super's options have\n    // been updated.\n    Sub.superOptions = Super.options;\n    Sub.extendOptions = extendOptions;\n    Sub.sealedOptions = extend({}, Sub.options);\n\n    // cache constructor\n    cachedCtors[SuperId] = Sub;\n    return Sub\n  };\n}\n\nfunction initProps$1 (Comp) {\n  var props = Comp.options.props;\n  for (var key in props) {\n    proxy(Comp.prototype, \"_props\", key);\n  }\n}\n\nfunction initComputed$1 (Comp) {\n  var computed = Comp.options.computed;\n  for (var key in computed) {\n    defineComputed(Comp.prototype, key, computed[key]);\n  }\n}\n\n/*  */\n\nfunction initAssetRegisters (Vue) {\n  /**\n   * Create asset registration methods.\n   */\n  ASSET_TYPES.forEach(function (type) {\n    Vue[type] = function (\n      id,\n      definition\n    ) {\n      if (!definition) {\n        return this.options[type + 's'][id]\n      } else {\n        /* istanbul ignore if */\n        if (process.env.NODE_ENV !== 'production' && type === 'component') {\n          validateComponentName(id);\n        }\n        if (type === 'component' && isPlainObject(definition)) {\n          definition.name = definition.name || id;\n          definition = this.options._base.extend(definition);\n        }\n        if (type === 'directive' && typeof definition === 'function') {\n          definition = { bind: definition, update: definition };\n        }\n        this.options[type + 's'][id] = definition;\n        return definition\n      }\n    };\n  });\n}\n\n/*  */\n\n\n\nfunction getComponentName (opts) {\n  return opts && (opts.Ctor.options.name || opts.tag)\n}\n\nfunction matches (pattern, name) {\n  if (Array.isArray(pattern)) {\n    return pattern.indexOf(name) > -1\n  } else if (typeof pattern === 'string') {\n    return pattern.split(',').indexOf(name) > -1\n  } else if (isRegExp(pattern)) {\n    return pattern.test(name)\n  }\n  /* istanbul ignore next */\n  return false\n}\n\nfunction pruneCache (keepAliveInstance, filter) {\n  var cache = keepAliveInstance.cache;\n  var keys = keepAliveInstance.keys;\n  var _vnode = keepAliveInstance._vnode;\n  for (var key in cache) {\n    var cachedNode = cache[key];\n    if (cachedNode) {\n      var name = getComponentName(cachedNode.componentOptions);\n      if (name && !filter(name)) {\n        pruneCacheEntry(cache, key, keys, _vnode);\n      }\n    }\n  }\n}\n\nfunction pruneCacheEntry (\n  cache,\n  key,\n  keys,\n  current\n) {\n  var cached$$1 = cache[key];\n  if (cached$$1 && (!current || cached$$1.tag !== current.tag)) {\n    cached$$1.componentInstance.$destroy();\n  }\n  cache[key] = null;\n  remove(keys, key);\n}\n\nvar patternTypes = [String, RegExp, Array];\n\nvar KeepAlive = {\n  name: 'keep-alive',\n  abstract: true,\n\n  props: {\n    include: patternTypes,\n    exclude: patternTypes,\n    max: [String, Number]\n  },\n\n  created: function created () {\n    this.cache = Object.create(null);\n    this.keys = [];\n  },\n\n  destroyed: function destroyed () {\n    for (var key in this.cache) {\n      pruneCacheEntry(this.cache, key, this.keys);\n    }\n  },\n\n  mounted: function mounted () {\n    var this$1 = this;\n\n    this.$watch('include', function (val) {\n      pruneCache(this$1, function (name) { return matches(val, name); });\n    });\n    this.$watch('exclude', function (val) {\n      pruneCache(this$1, function (name) { return !matches(val, name); });\n    });\n  },\n\n  render: function render () {\n    var slot = this.$slots.default;\n    var vnode = getFirstComponentChild(slot);\n    var componentOptions = vnode && vnode.componentOptions;\n    if (componentOptions) {\n      // check pattern\n      var name = getComponentName(componentOptions);\n      var ref = this;\n      var include = ref.include;\n      var exclude = ref.exclude;\n      if (\n        // not included\n        (include && (!name || !matches(include, name))) ||\n        // excluded\n        (exclude && name && matches(exclude, name))\n      ) {\n        return vnode\n      }\n\n      var ref$1 = this;\n      var cache = ref$1.cache;\n      var keys = ref$1.keys;\n      var key = vnode.key == null\n        // same constructor may get registered as different local components\n        // so cid alone is not enough (#3269)\n        ? componentOptions.Ctor.cid + (componentOptions.tag ? (\"::\" + (componentOptions.tag)) : '')\n        : vnode.key;\n      if (cache[key]) {\n        vnode.componentInstance = cache[key].componentInstance;\n        // make current key freshest\n        remove(keys, key);\n        keys.push(key);\n      } else {\n        cache[key] = vnode;\n        keys.push(key);\n        // prune oldest entry\n        if (this.max && keys.length > parseInt(this.max)) {\n          pruneCacheEntry(cache, keys[0], keys, this._vnode);\n        }\n      }\n\n      vnode.data.keepAlive = true;\n    }\n    return vnode || (slot && slot[0])\n  }\n};\n\nvar builtInComponents = {\n  KeepAlive: KeepAlive\n};\n\n/*  */\n\nfunction initGlobalAPI (Vue) {\n  // config\n  var configDef = {};\n  configDef.get = function () { return config; };\n  if (process.env.NODE_ENV !== 'production') {\n    configDef.set = function () {\n      warn(\n        'Do not replace the Vue.config object, set individual fields instead.'\n      );\n    };\n  }\n  Object.defineProperty(Vue, 'config', configDef);\n\n  // exposed util methods.\n  // NOTE: these are not considered part of the public API - avoid relying on\n  // them unless you are aware of the risk.\n  Vue.util = {\n    warn: warn,\n    extend: extend,\n    mergeOptions: mergeOptions,\n    defineReactive: defineReactive$$1\n  };\n\n  Vue.set = set;\n  Vue.delete = del;\n  Vue.nextTick = nextTick;\n\n  // 2.6 explicit observable API\n  Vue.observable = function (obj) {\n    observe(obj);\n    return obj\n  };\n\n  Vue.options = Object.create(null);\n  ASSET_TYPES.forEach(function (type) {\n    Vue.options[type + 's'] = Object.create(null);\n  });\n\n  // this is used to identify the \"base\" constructor to extend all plain-object\n  // components with in Weex's multi-instance scenarios.\n  Vue.options._base = Vue;\n\n  extend(Vue.options.components, builtInComponents);\n\n  initUse(Vue);\n  initMixin$1(Vue);\n  initExtend(Vue);\n  initAssetRegisters(Vue);\n}\n\ninitGlobalAPI(Vue);\n\nObject.defineProperty(Vue.prototype, '$isServer', {\n  get: isServerRendering\n});\n\nObject.defineProperty(Vue.prototype, '$ssrContext', {\n  get: function get () {\n    /* istanbul ignore next */\n    return this.$vnode && this.$vnode.ssrContext\n  }\n});\n\n// expose FunctionalRenderContext for ssr runtime helper installation\nObject.defineProperty(Vue, 'FunctionalRenderContext', {\n  value: FunctionalRenderContext\n});\n\nVue.version = '2.6.10';\n\n/*  */\n\n// these are reserved for web because they are directly compiled away\n// during template compilation\nvar isReservedAttr = makeMap('style,class');\n\n// attributes that should be using props for binding\nvar acceptValue = makeMap('input,textarea,option,select,progress');\nvar mustUseProp = function (tag, type, attr) {\n  return (\n    (attr === 'value' && acceptValue(tag)) && type !== 'button' ||\n    (attr === 'selected' && tag === 'option') ||\n    (attr === 'checked' && tag === 'input') ||\n    (attr === 'muted' && tag === 'video')\n  )\n};\n\nvar isEnumeratedAttr = makeMap('contenteditable,draggable,spellcheck');\n\nvar isValidContentEditableValue = makeMap('events,caret,typing,plaintext-only');\n\nvar convertEnumeratedValue = function (key, value) {\n  return isFalsyAttrValue(value) || value === 'false'\n    ? 'false'\n    // allow arbitrary string value for contenteditable\n    : key === 'contenteditable' && isValidContentEditableValue(value)\n      ? value\n      : 'true'\n};\n\nvar isBooleanAttr = makeMap(\n  'allowfullscreen,async,autofocus,autoplay,checked,compact,controls,declare,' +\n  'default,defaultchecked,defaultmuted,defaultselected,defer,disabled,' +\n  'enabled,formnovalidate,hidden,indeterminate,inert,ismap,itemscope,loop,multiple,' +\n  'muted,nohref,noresize,noshade,novalidate,nowrap,open,pauseonexit,readonly,' +\n  'required,reversed,scoped,seamless,selected,sortable,translate,' +\n  'truespeed,typemustmatch,visible'\n);\n\nvar xlinkNS = 'http://www.w3.org/1999/xlink';\n\nvar isXlink = function (name) {\n  return name.charAt(5) === ':' && name.slice(0, 5) === 'xlink'\n};\n\nvar getXlinkProp = function (name) {\n  return isXlink(name) ? name.slice(6, name.length) : ''\n};\n\nvar isFalsyAttrValue = function (val) {\n  return val == null || val === false\n};\n\n/*  */\n\nfunction genClassForVnode (vnode) {\n  var data = vnode.data;\n  var parentNode = vnode;\n  var childNode = vnode;\n  while (isDef(childNode.componentInstance)) {\n    childNode = childNode.componentInstance._vnode;\n    if (childNode && childNode.data) {\n      data = mergeClassData(childNode.data, data);\n    }\n  }\n  while (isDef(parentNode = parentNode.parent)) {\n    if (parentNode && parentNode.data) {\n      data = mergeClassData(data, parentNode.data);\n    }\n  }\n  return renderClass(data.staticClass, data.class)\n}\n\nfunction mergeClassData (child, parent) {\n  return {\n    staticClass: concat(child.staticClass, parent.staticClass),\n    class: isDef(child.class)\n      ? [child.class, parent.class]\n      : parent.class\n  }\n}\n\nfunction renderClass (\n  staticClass,\n  dynamicClass\n) {\n  if (isDef(staticClass) || isDef(dynamicClass)) {\n    return concat(staticClass, stringifyClass(dynamicClass))\n  }\n  /* istanbul ignore next */\n  return ''\n}\n\nfunction concat (a, b) {\n  return a ? b ? (a + ' ' + b) : a : (b || '')\n}\n\nfunction stringifyClass (value) {\n  if (Array.isArray(value)) {\n    return stringifyArray(value)\n  }\n  if (isObject(value)) {\n    return stringifyObject(value)\n  }\n  if (typeof value === 'string') {\n    return value\n  }\n  /* istanbul ignore next */\n  return ''\n}\n\nfunction stringifyArray (value) {\n  var res = '';\n  var stringified;\n  for (var i = 0, l = value.length; i < l; i++) {\n    if (isDef(stringified = stringifyClass(value[i])) && stringified !== '') {\n      if (res) { res += ' '; }\n      res += stringified;\n    }\n  }\n  return res\n}\n\nfunction stringifyObject (value) {\n  var res = '';\n  for (var key in value) {\n    if (value[key]) {\n      if (res) { res += ' '; }\n      res += key;\n    }\n  }\n  return res\n}\n\n/*  */\n\nvar namespaceMap = {\n  svg: 'http://www.w3.org/2000/svg',\n  math: 'http://www.w3.org/1998/Math/MathML'\n};\n\nvar isHTMLTag = makeMap(\n  'html,body,base,head,link,meta,style,title,' +\n  'address,article,aside,footer,header,h1,h2,h3,h4,h5,h6,hgroup,nav,section,' +\n  'div,dd,dl,dt,figcaption,figure,picture,hr,img,li,main,ol,p,pre,ul,' +\n  'a,b,abbr,bdi,bdo,br,cite,code,data,dfn,em,i,kbd,mark,q,rp,rt,rtc,ruby,' +\n  's,samp,small,span,strong,sub,sup,time,u,var,wbr,area,audio,map,track,video,' +\n  'embed,object,param,source,canvas,script,noscript,del,ins,' +\n  'caption,col,colgroup,table,thead,tbody,td,th,tr,' +\n  'button,datalist,fieldset,form,input,label,legend,meter,optgroup,option,' +\n  'output,progress,select,textarea,' +\n  'details,dialog,menu,menuitem,summary,' +\n  'content,element,shadow,template,blockquote,iframe,tfoot'\n);\n\n// this map is intentionally selective, only covering SVG elements that may\n// contain child elements.\nvar isSVG = makeMap(\n  'svg,animate,circle,clippath,cursor,defs,desc,ellipse,filter,font-face,' +\n  'foreignObject,g,glyph,image,line,marker,mask,missing-glyph,path,pattern,' +\n  'polygon,polyline,rect,switch,symbol,text,textpath,tspan,use,view',\n  true\n);\n\nvar isPreTag = function (tag) { return tag === 'pre'; };\n\nvar isReservedTag = function (tag) {\n  return isHTMLTag(tag) || isSVG(tag)\n};\n\nfunction getTagNamespace (tag) {\n  if (isSVG(tag)) {\n    return 'svg'\n  }\n  // basic support for MathML\n  // note it doesn't support other MathML elements being component roots\n  if (tag === 'math') {\n    return 'math'\n  }\n}\n\nvar unknownElementCache = Object.create(null);\nfunction isUnknownElement (tag) {\n  /* istanbul ignore if */\n  if (!inBrowser) {\n    return true\n  }\n  if (isReservedTag(tag)) {\n    return false\n  }\n  tag = tag.toLowerCase();\n  /* istanbul ignore if */\n  if (unknownElementCache[tag] != null) {\n    return unknownElementCache[tag]\n  }\n  var el = document.createElement(tag);\n  if (tag.indexOf('-') > -1) {\n    // http://stackoverflow.com/a/28210364/1070244\n    return (unknownElementCache[tag] = (\n      el.constructor === window.HTMLUnknownElement ||\n      el.constructor === window.HTMLElement\n    ))\n  } else {\n    return (unknownElementCache[tag] = /HTMLUnknownElement/.test(el.toString()))\n  }\n}\n\nvar isTextInputType = makeMap('text,number,password,search,email,tel,url');\n\n/*  */\n\n/**\n * Query an element selector if it's not an element already.\n */\nfunction query (el) {\n  if (typeof el === 'string') {\n    var selected = document.querySelector(el);\n    if (!selected) {\n      process.env.NODE_ENV !== 'production' && warn(\n        'Cannot find element: ' + el\n      );\n      return document.createElement('div')\n    }\n    return selected\n  } else {\n    return el\n  }\n}\n\n/*  */\n\nfunction createElement$1 (tagName, vnode) {\n  var elm = document.createElement(tagName);\n  if (tagName !== 'select') {\n    return elm\n  }\n  // false or null will remove the attribute but undefined will not\n  if (vnode.data && vnode.data.attrs && vnode.data.attrs.multiple !== undefined) {\n    elm.setAttribute('multiple', 'multiple');\n  }\n  return elm\n}\n\nfunction createElementNS (namespace, tagName) {\n  return document.createElementNS(namespaceMap[namespace], tagName)\n}\n\nfunction createTextNode (text) {\n  return document.createTextNode(text)\n}\n\nfunction createComment (text) {\n  return document.createComment(text)\n}\n\nfunction insertBefore (parentNode, newNode, referenceNode) {\n  parentNode.insertBefore(newNode, referenceNode);\n}\n\nfunction removeChild (node, child) {\n  node.removeChild(child);\n}\n\nfunction appendChild (node, child) {\n  node.appendChild(child);\n}\n\nfunction parentNode (node) {\n  return node.parentNode\n}\n\nfunction nextSibling (node) {\n  return node.nextSibling\n}\n\nfunction tagName (node) {\n  return node.tagName\n}\n\nfunction setTextContent (node, text) {\n  node.textContent = text;\n}\n\nfunction setStyleScope (node, scopeId) {\n  node.setAttribute(scopeId, '');\n}\n\nvar nodeOps = /*#__PURE__*/Object.freeze({\n  createElement: createElement$1,\n  createElementNS: createElementNS,\n  createTextNode: createTextNode,\n  createComment: createComment,\n  insertBefore: insertBefore,\n  removeChild: removeChild,\n  appendChild: appendChild,\n  parentNode: parentNode,\n  nextSibling: nextSibling,\n  tagName: tagName,\n  setTextContent: setTextContent,\n  setStyleScope: setStyleScope\n});\n\n/*  */\n\nvar ref = {\n  create: function create (_, vnode) {\n    registerRef(vnode);\n  },\n  update: function update (oldVnode, vnode) {\n    if (oldVnode.data.ref !== vnode.data.ref) {\n      registerRef(oldVnode, true);\n      registerRef(vnode);\n    }\n  },\n  destroy: function destroy (vnode) {\n    registerRef(vnode, true);\n  }\n};\n\nfunction registerRef (vnode, isRemoval) {\n  var key = vnode.data.ref;\n  if (!isDef(key)) { return }\n\n  var vm = vnode.context;\n  var ref = vnode.componentInstance || vnode.elm;\n  var refs = vm.$refs;\n  if (isRemoval) {\n    if (Array.isArray(refs[key])) {\n      remove(refs[key], ref);\n    } else if (refs[key] === ref) {\n      refs[key] = undefined;\n    }\n  } else {\n    if (vnode.data.refInFor) {\n      if (!Array.isArray(refs[key])) {\n        refs[key] = [ref];\n      } else if (refs[key].indexOf(ref) < 0) {\n        // $flow-disable-line\n        refs[key].push(ref);\n      }\n    } else {\n      refs[key] = ref;\n    }\n  }\n}\n\n/**\n * Virtual DOM patching algorithm based on Snabbdom by\n * Simon Friis Vindum (@paldepind)\n * Licensed under the MIT License\n * https://github.com/paldepind/snabbdom/blob/master/LICENSE\n *\n * modified by Evan You (@yyx990803)\n *\n * Not type-checking this because this file is perf-critical and the cost\n * of making flow understand it is not worth it.\n */\n\nvar emptyNode = new VNode('', {}, []);\n\nvar hooks = ['create', 'activate', 'update', 'remove', 'destroy'];\n\nfunction sameVnode (a, b) {\n  return (\n    a.key === b.key && (\n      (\n        a.tag === b.tag &&\n        a.isComment === b.isComment &&\n        isDef(a.data) === isDef(b.data) &&\n        sameInputType(a, b)\n      ) || (\n        isTrue(a.isAsyncPlaceholder) &&\n        a.asyncFactory === b.asyncFactory &&\n        isUndef(b.asyncFactory.error)\n      )\n    )\n  )\n}\n\nfunction sameInputType (a, b) {\n  if (a.tag !== 'input') { return true }\n  var i;\n  var typeA = isDef(i = a.data) && isDef(i = i.attrs) && i.type;\n  var typeB = isDef(i = b.data) && isDef(i = i.attrs) && i.type;\n  return typeA === typeB || isTextInputType(typeA) && isTextInputType(typeB)\n}\n\nfunction createKeyToOldIdx (children, beginIdx, endIdx) {\n  var i, key;\n  var map = {};\n  for (i = beginIdx; i <= endIdx; ++i) {\n    key = children[i].key;\n    if (isDef(key)) { map[key] = i; }\n  }\n  return map\n}\n\nfunction createPatchFunction (backend) {\n  var i, j;\n  var cbs = {};\n\n  var modules = backend.modules;\n  var nodeOps = backend.nodeOps;\n\n  for (i = 0; i < hooks.length; ++i) {\n    cbs[hooks[i]] = [];\n    for (j = 0; j < modules.length; ++j) {\n      if (isDef(modules[j][hooks[i]])) {\n        cbs[hooks[i]].push(modules[j][hooks[i]]);\n      }\n    }\n  }\n\n  function emptyNodeAt (elm) {\n    return new VNode(nodeOps.tagName(elm).toLowerCase(), {}, [], undefined, elm)\n  }\n\n  function createRmCb (childElm, listeners) {\n    function remove$$1 () {\n      if (--remove$$1.listeners === 0) {\n        removeNode(childElm);\n      }\n    }\n    remove$$1.listeners = listeners;\n    return remove$$1\n  }\n\n  function removeNode (el) {\n    var parent = nodeOps.parentNode(el);\n    // element may have already been removed due to v-html / v-text\n    if (isDef(parent)) {\n      nodeOps.removeChild(parent, el);\n    }\n  }\n\n  function isUnknownElement$$1 (vnode, inVPre) {\n    return (\n      !inVPre &&\n      !vnode.ns &&\n      !(\n        config.ignoredElements.length &&\n        config.ignoredElements.some(function (ignore) {\n          return isRegExp(ignore)\n            ? ignore.test(vnode.tag)\n            : ignore === vnode.tag\n        })\n      ) &&\n      config.isUnknownElement(vnode.tag)\n    )\n  }\n\n  var creatingElmInVPre = 0;\n\n  function createElm (\n    vnode,\n    insertedVnodeQueue,\n    parentElm,\n    refElm,\n    nested,\n    ownerArray,\n    index\n  ) {\n    if (isDef(vnode.elm) && isDef(ownerArray)) {\n      // This vnode was used in a previous render!\n      // now it's used as a new node, overwriting its elm would cause\n      // potential patch errors down the road when it's used as an insertion\n      // reference node. Instead, we clone the node on-demand before creating\n      // associated DOM element for it.\n      vnode = ownerArray[index] = cloneVNode(vnode);\n    }\n\n    vnode.isRootInsert = !nested; // for transition enter check\n    if (createComponent(vnode, insertedVnodeQueue, parentElm, refElm)) {\n      return\n    }\n\n    var data = vnode.data;\n    var children = vnode.children;\n    var tag = vnode.tag;\n    if (isDef(tag)) {\n      if (process.env.NODE_ENV !== 'production') {\n        if (data && data.pre) {\n          creatingElmInVPre++;\n        }\n        if (isUnknownElement$$1(vnode, creatingElmInVPre)) {\n          warn(\n            'Unknown custom element: <' + tag + '> - did you ' +\n            'register the component correctly? For recursive components, ' +\n            'make sure to provide the \"name\" option.',\n            vnode.context\n          );\n        }\n      }\n\n      vnode.elm = vnode.ns\n        ? nodeOps.createElementNS(vnode.ns, tag)\n        : nodeOps.createElement(tag, vnode);\n      setScope(vnode);\n\n      /* istanbul ignore if */\n      {\n        createChildren(vnode, children, insertedVnodeQueue);\n        if (isDef(data)) {\n          invokeCreateHooks(vnode, insertedVnodeQueue);\n        }\n        insert(parentElm, vnode.elm, refElm);\n      }\n\n      if (process.env.NODE_ENV !== 'production' && data && data.pre) {\n        creatingElmInVPre--;\n      }\n    } else if (isTrue(vnode.isComment)) {\n      vnode.elm = nodeOps.createComment(vnode.text);\n      insert(parentElm, vnode.elm, refElm);\n    } else {\n      vnode.elm = nodeOps.createTextNode(vnode.text);\n      insert(parentElm, vnode.elm, refElm);\n    }\n  }\n\n  function createComponent (vnode, insertedVnodeQueue, parentElm, refElm) {\n    var i = vnode.data;\n    if (isDef(i)) {\n      var isReactivated = isDef(vnode.componentInstance) && i.keepAlive;\n      if (isDef(i = i.hook) && isDef(i = i.init)) {\n        i(vnode, false /* hydrating */);\n      }\n      // after calling the init hook, if the vnode is a child component\n      // it should've created a child instance and mounted it. the child\n      // component also has set the placeholder vnode's elm.\n      // in that case we can just return the element and be done.\n      if (isDef(vnode.componentInstance)) {\n        initComponent(vnode, insertedVnodeQueue);\n        insert(parentElm, vnode.elm, refElm);\n        if (isTrue(isReactivated)) {\n          reactivateComponent(vnode, insertedVnodeQueue, parentElm, refElm);\n        }\n        return true\n      }\n    }\n  }\n\n  function initComponent (vnode, insertedVnodeQueue) {\n    if (isDef(vnode.data.pendingInsert)) {\n      insertedVnodeQueue.push.apply(insertedVnodeQueue, vnode.data.pendingInsert);\n      vnode.data.pendingInsert = null;\n    }\n    vnode.elm = vnode.componentInstance.$el;\n    if (isPatchable(vnode)) {\n      invokeCreateHooks(vnode, insertedVnodeQueue);\n      setScope(vnode);\n    } else {\n      // empty component root.\n      // skip all element-related modules except for ref (#3455)\n      registerRef(vnode);\n      // make sure to invoke the insert hook\n      insertedVnodeQueue.push(vnode);\n    }\n  }\n\n  function reactivateComponent (vnode, insertedVnodeQueue, parentElm, refElm) {\n    var i;\n    // hack for #4339: a reactivated component with inner transition\n    // does not trigger because the inner node's created hooks are not called\n    // again. It's not ideal to involve module-specific logic in here but\n    // there doesn't seem to be a better way to do it.\n    var innerNode = vnode;\n    while (innerNode.componentInstance) {\n      innerNode = innerNode.componentInstance._vnode;\n      if (isDef(i = innerNode.data) && isDef(i = i.transition)) {\n        for (i = 0; i < cbs.activate.length; ++i) {\n          cbs.activate[i](emptyNode, innerNode);\n        }\n        insertedVnodeQueue.push(innerNode);\n        break\n      }\n    }\n    // unlike a newly created component,\n    // a reactivated keep-alive component doesn't insert itself\n    insert(parentElm, vnode.elm, refElm);\n  }\n\n  function insert (parent, elm, ref$$1) {\n    if (isDef(parent)) {\n      if (isDef(ref$$1)) {\n        if (nodeOps.parentNode(ref$$1) === parent) {\n          nodeOps.insertBefore(parent, elm, ref$$1);\n        }\n      } else {\n        nodeOps.appendChild(parent, elm);\n      }\n    }\n  }\n\n  function createChildren (vnode, children, insertedVnodeQueue) {\n    if (Array.isArray(children)) {\n      if (process.env.NODE_ENV !== 'production') {\n        checkDuplicateKeys(children);\n      }\n      for (var i = 0; i < children.length; ++i) {\n        createElm(children[i], insertedVnodeQueue, vnode.elm, null, true, children, i);\n      }\n    } else if (isPrimitive(vnode.text)) {\n      nodeOps.appendChild(vnode.elm, nodeOps.createTextNode(String(vnode.text)));\n    }\n  }\n\n  function isPatchable (vnode) {\n    while (vnode.componentInstance) {\n      vnode = vnode.componentInstance._vnode;\n    }\n    return isDef(vnode.tag)\n  }\n\n  function invokeCreateHooks (vnode, insertedVnodeQueue) {\n    for (var i$1 = 0; i$1 < cbs.create.length; ++i$1) {\n      cbs.create[i$1](emptyNode, vnode);\n    }\n    i = vnode.data.hook; // Reuse variable\n    if (isDef(i)) {\n      if (isDef(i.create)) { i.create(emptyNode, vnode); }\n      if (isDef(i.insert)) { insertedVnodeQueue.push(vnode); }\n    }\n  }\n\n  // set scope id attribute for scoped CSS.\n  // this is implemented as a special case to avoid the overhead\n  // of going through the normal attribute patching process.\n  function setScope (vnode) {\n    var i;\n    if (isDef(i = vnode.fnScopeId)) {\n      nodeOps.setStyleScope(vnode.elm, i);\n    } else {\n      var ancestor = vnode;\n      while (ancestor) {\n        if (isDef(i = ancestor.context) && isDef(i = i.$options._scopeId)) {\n          nodeOps.setStyleScope(vnode.elm, i);\n        }\n        ancestor = ancestor.parent;\n      }\n    }\n    // for slot content they should also get the scopeId from the host instance.\n    if (isDef(i = activeInstance) &&\n      i !== vnode.context &&\n      i !== vnode.fnContext &&\n      isDef(i = i.$options._scopeId)\n    ) {\n      nodeOps.setStyleScope(vnode.elm, i);\n    }\n  }\n\n  function addVnodes (parentElm, refElm, vnodes, startIdx, endIdx, insertedVnodeQueue) {\n    for (; startIdx <= endIdx; ++startIdx) {\n      createElm(vnodes[startIdx], insertedVnodeQueue, parentElm, refElm, false, vnodes, startIdx);\n    }\n  }\n\n  function invokeDestroyHook (vnode) {\n    var i, j;\n    var data = vnode.data;\n    if (isDef(data)) {\n      if (isDef(i = data.hook) && isDef(i = i.destroy)) { i(vnode); }\n      for (i = 0; i < cbs.destroy.length; ++i) { cbs.destroy[i](vnode); }\n    }\n    if (isDef(i = vnode.children)) {\n      for (j = 0; j < vnode.children.length; ++j) {\n        invokeDestroyHook(vnode.children[j]);\n      }\n    }\n  }\n\n  function removeVnodes (parentElm, vnodes, startIdx, endIdx) {\n    for (; startIdx <= endIdx; ++startIdx) {\n      var ch = vnodes[startIdx];\n      if (isDef(ch)) {\n        if (isDef(ch.tag)) {\n          removeAndInvokeRemoveHook(ch);\n          invokeDestroyHook(ch);\n        } else { // Text node\n          removeNode(ch.elm);\n        }\n      }\n    }\n  }\n\n  function removeAndInvokeRemoveHook (vnode, rm) {\n    if (isDef(rm) || isDef(vnode.data)) {\n      var i;\n      var listeners = cbs.remove.length + 1;\n      if (isDef(rm)) {\n        // we have a recursively passed down rm callback\n        // increase the listeners count\n        rm.listeners += listeners;\n      } else {\n        // directly removing\n        rm = createRmCb(vnode.elm, listeners);\n      }\n      // recursively invoke hooks on child component root node\n      if (isDef(i = vnode.componentInstance) && isDef(i = i._vnode) && isDef(i.data)) {\n        removeAndInvokeRemoveHook(i, rm);\n      }\n      for (i = 0; i < cbs.remove.length; ++i) {\n        cbs.remove[i](vnode, rm);\n      }\n      if (isDef(i = vnode.data.hook) && isDef(i = i.remove)) {\n        i(vnode, rm);\n      } else {\n        rm();\n      }\n    } else {\n      removeNode(vnode.elm);\n    }\n  }\n\n  function updateChildren (parentElm, oldCh, newCh, insertedVnodeQueue, removeOnly) {\n    var oldStartIdx = 0;\n    var newStartIdx = 0;\n    var oldEndIdx = oldCh.length - 1;\n    var oldStartVnode = oldCh[0];\n    var oldEndVnode = oldCh[oldEndIdx];\n    var newEndIdx = newCh.length - 1;\n    var newStartVnode = newCh[0];\n    var newEndVnode = newCh[newEndIdx];\n    var oldKeyToIdx, idxInOld, vnodeToMove, refElm;\n\n    // removeOnly is a special flag used only by <transition-group>\n    // to ensure removed elements stay in correct relative positions\n    // during leaving transitions\n    var canMove = !removeOnly;\n\n    if (process.env.NODE_ENV !== 'production') {\n      checkDuplicateKeys(newCh);\n    }\n\n    while (oldStartIdx <= oldEndIdx && newStartIdx <= newEndIdx) {\n      if (isUndef(oldStartVnode)) {\n        oldStartVnode = oldCh[++oldStartIdx]; // Vnode has been moved left\n      } else if (isUndef(oldEndVnode)) {\n        oldEndVnode = oldCh[--oldEndIdx];\n      } else if (sameVnode(oldStartVnode, newStartVnode)) {\n        patchVnode(oldStartVnode, newStartVnode, insertedVnodeQueue, newCh, newStartIdx);\n        oldStartVnode = oldCh[++oldStartIdx];\n        newStartVnode = newCh[++newStartIdx];\n      } else if (sameVnode(oldEndVnode, newEndVnode)) {\n        patchVnode(oldEndVnode, newEndVnode, insertedVnodeQueue, newCh, newEndIdx);\n        oldEndVnode = oldCh[--oldEndIdx];\n        newEndVnode = newCh[--newEndIdx];\n      } else if (sameVnode(oldStartVnode, newEndVnode)) { // Vnode moved right\n        patchVnode(oldStartVnode, newEndVnode, insertedVnodeQueue, newCh, newEndIdx);\n        canMove && nodeOps.insertBefore(parentElm, oldStartVnode.elm, nodeOps.nextSibling(oldEndVnode.elm));\n        oldStartVnode = oldCh[++oldStartIdx];\n        newEndVnode = newCh[--newEndIdx];\n      } else if (sameVnode(oldEndVnode, newStartVnode)) { // Vnode moved left\n        patchVnode(oldEndVnode, newStartVnode, insertedVnodeQueue, newCh, newStartIdx);\n        canMove && nodeOps.insertBefore(parentElm, oldEndVnode.elm, oldStartVnode.elm);\n        oldEndVnode = oldCh[--oldEndIdx];\n        newStartVnode = newCh[++newStartIdx];\n      } else {\n        if (isUndef(oldKeyToIdx)) { oldKeyToIdx = createKeyToOldIdx(oldCh, oldStartIdx, oldEndIdx); }\n        idxInOld = isDef(newStartVnode.key)\n          ? oldKeyToIdx[newStartVnode.key]\n          : findIdxInOld(newStartVnode, oldCh, oldStartIdx, oldEndIdx);\n        if (isUndef(idxInOld)) { // New element\n          createElm(newStartVnode, insertedVnodeQueue, parentElm, oldStartVnode.elm, false, newCh, newStartIdx);\n        } else {\n          vnodeToMove = oldCh[idxInOld];\n          if (sameVnode(vnodeToMove, newStartVnode)) {\n            patchVnode(vnodeToMove, newStartVnode, insertedVnodeQueue, newCh, newStartIdx);\n            oldCh[idxInOld] = undefined;\n            canMove && nodeOps.insertBefore(parentElm, vnodeToMove.elm, oldStartVnode.elm);\n          } else {\n            // same key but different element. treat as new element\n            createElm(newStartVnode, insertedVnodeQueue, parentElm, oldStartVnode.elm, false, newCh, newStartIdx);\n          }\n        }\n        newStartVnode = newCh[++newStartIdx];\n      }\n    }\n    if (oldStartIdx > oldEndIdx) {\n      refElm = isUndef(newCh[newEndIdx + 1]) ? null : newCh[newEndIdx + 1].elm;\n      addVnodes(parentElm, refElm, newCh, newStartIdx, newEndIdx, insertedVnodeQueue);\n    } else if (newStartIdx > newEndIdx) {\n      removeVnodes(parentElm, oldCh, oldStartIdx, oldEndIdx);\n    }\n  }\n\n  function checkDuplicateKeys (children) {\n    var seenKeys = {};\n    for (var i = 0; i < children.length; i++) {\n      var vnode = children[i];\n      var key = vnode.key;\n      if (isDef(key)) {\n        if (seenKeys[key]) {\n          warn(\n            (\"Duplicate keys detected: '\" + key + \"'. This may cause an update error.\"),\n            vnode.context\n          );\n        } else {\n          seenKeys[key] = true;\n        }\n      }\n    }\n  }\n\n  function findIdxInOld (node, oldCh, start, end) {\n    for (var i = start; i < end; i++) {\n      var c = oldCh[i];\n      if (isDef(c) && sameVnode(node, c)) { return i }\n    }\n  }\n\n  function patchVnode (\n    oldVnode,\n    vnode,\n    insertedVnodeQueue,\n    ownerArray,\n    index,\n    removeOnly\n  ) {\n    if (oldVnode === vnode) {\n      return\n    }\n\n    if (isDef(vnode.elm) && isDef(ownerArray)) {\n      // clone reused vnode\n      vnode = ownerArray[index] = cloneVNode(vnode);\n    }\n\n    var elm = vnode.elm = oldVnode.elm;\n\n    if (isTrue(oldVnode.isAsyncPlaceholder)) {\n      if (isDef(vnode.asyncFactory.resolved)) {\n        hydrate(oldVnode.elm, vnode, insertedVnodeQueue);\n      } else {\n        vnode.isAsyncPlaceholder = true;\n      }\n      return\n    }\n\n    // reuse element for static trees.\n    // note we only do this if the vnode is cloned -\n    // if the new node is not cloned it means the render functions have been\n    // reset by the hot-reload-api and we need to do a proper re-render.\n    if (isTrue(vnode.isStatic) &&\n      isTrue(oldVnode.isStatic) &&\n      vnode.key === oldVnode.key &&\n      (isTrue(vnode.isCloned) || isTrue(vnode.isOnce))\n    ) {\n      vnode.componentInstance = oldVnode.componentInstance;\n      return\n    }\n\n    var i;\n    var data = vnode.data;\n    if (isDef(data) && isDef(i = data.hook) && isDef(i = i.prepatch)) {\n      i(oldVnode, vnode);\n    }\n\n    var oldCh = oldVnode.children;\n    var ch = vnode.children;\n    if (isDef(data) && isPatchable(vnode)) {\n      for (i = 0; i < cbs.update.length; ++i) { cbs.update[i](oldVnode, vnode); }\n      if (isDef(i = data.hook) && isDef(i = i.update)) { i(oldVnode, vnode); }\n    }\n    if (isUndef(vnode.text)) {\n      if (isDef(oldCh) && isDef(ch)) {\n        if (oldCh !== ch) { updateChildren(elm, oldCh, ch, insertedVnodeQueue, removeOnly); }\n      } else if (isDef(ch)) {\n        if (process.env.NODE_ENV !== 'production') {\n          checkDuplicateKeys(ch);\n        }\n        if (isDef(oldVnode.text)) { nodeOps.setTextContent(elm, ''); }\n        addVnodes(elm, null, ch, 0, ch.length - 1, insertedVnodeQueue);\n      } else if (isDef(oldCh)) {\n        removeVnodes(elm, oldCh, 0, oldCh.length - 1);\n      } else if (isDef(oldVnode.text)) {\n        nodeOps.setTextContent(elm, '');\n      }\n    } else if (oldVnode.text !== vnode.text) {\n      nodeOps.setTextContent(elm, vnode.text);\n    }\n    if (isDef(data)) {\n      if (isDef(i = data.hook) && isDef(i = i.postpatch)) { i(oldVnode, vnode); }\n    }\n  }\n\n  function invokeInsertHook (vnode, queue, initial) {\n    // delay insert hooks for component root nodes, invoke them after the\n    // element is really inserted\n    if (isTrue(initial) && isDef(vnode.parent)) {\n      vnode.parent.data.pendingInsert = queue;\n    } else {\n      for (var i = 0; i < queue.length; ++i) {\n        queue[i].data.hook.insert(queue[i]);\n      }\n    }\n  }\n\n  var hydrationBailed = false;\n  // list of modules that can skip create hook during hydration because they\n  // are already rendered on the client or has no need for initialization\n  // Note: style is excluded because it relies on initial clone for future\n  // deep updates (#7063).\n  var isRenderedModule = makeMap('attrs,class,staticClass,staticStyle,key');\n\n  // Note: this is a browser-only function so we can assume elms are DOM nodes.\n  function hydrate (elm, vnode, insertedVnodeQueue, inVPre) {\n    var i;\n    var tag = vnode.tag;\n    var data = vnode.data;\n    var children = vnode.children;\n    inVPre = inVPre || (data && data.pre);\n    vnode.elm = elm;\n\n    if (isTrue(vnode.isComment) && isDef(vnode.asyncFactory)) {\n      vnode.isAsyncPlaceholder = true;\n      return true\n    }\n    // assert node match\n    if (process.env.NODE_ENV !== 'production') {\n      if (!assertNodeMatch(elm, vnode, inVPre)) {\n        return false\n      }\n    }\n    if (isDef(data)) {\n      if (isDef(i = data.hook) && isDef(i = i.init)) { i(vnode, true /* hydrating */); }\n      if (isDef(i = vnode.componentInstance)) {\n        // child component. it should have hydrated its own tree.\n        initComponent(vnode, insertedVnodeQueue);\n        return true\n      }\n    }\n    if (isDef(tag)) {\n      if (isDef(children)) {\n        // empty element, allow client to pick up and populate children\n        if (!elm.hasChildNodes()) {\n          createChildren(vnode, children, insertedVnodeQueue);\n        } else {\n          // v-html and domProps: innerHTML\n          if (isDef(i = data) && isDef(i = i.domProps) && isDef(i = i.innerHTML)) {\n            if (i !== elm.innerHTML) {\n              /* istanbul ignore if */\n              if (process.env.NODE_ENV !== 'production' &&\n                typeof console !== 'undefined' &&\n                !hydrationBailed\n              ) {\n                hydrationBailed = true;\n                console.warn('Parent: ', elm);\n                console.warn('server innerHTML: ', i);\n                console.warn('client innerHTML: ', elm.innerHTML);\n              }\n              return false\n            }\n          } else {\n            // iterate and compare children lists\n            var childrenMatch = true;\n            var childNode = elm.firstChild;\n            for (var i$1 = 0; i$1 < children.length; i$1++) {\n              if (!childNode || !hydrate(childNode, children[i$1], insertedVnodeQueue, inVPre)) {\n                childrenMatch = false;\n                break\n              }\n              childNode = childNode.nextSibling;\n            }\n            // if childNode is not null, it means the actual childNodes list is\n            // longer than the virtual children list.\n            if (!childrenMatch || childNode) {\n              /* istanbul ignore if */\n              if (process.env.NODE_ENV !== 'production' &&\n                typeof console !== 'undefined' &&\n                !hydrationBailed\n              ) {\n                hydrationBailed = true;\n                console.warn('Parent: ', elm);\n                console.warn('Mismatching childNodes vs. VNodes: ', elm.childNodes, children);\n              }\n              return false\n            }\n          }\n        }\n      }\n      if (isDef(data)) {\n        var fullInvoke = false;\n        for (var key in data) {\n          if (!isRenderedModule(key)) {\n            fullInvoke = true;\n            invokeCreateHooks(vnode, insertedVnodeQueue);\n            break\n          }\n        }\n        if (!fullInvoke && data['class']) {\n          // ensure collecting deps for deep class bindings for future updates\n          traverse(data['class']);\n        }\n      }\n    } else if (elm.data !== vnode.text) {\n      elm.data = vnode.text;\n    }\n    return true\n  }\n\n  function assertNodeMatch (node, vnode, inVPre) {\n    if (isDef(vnode.tag)) {\n      return vnode.tag.indexOf('vue-component') === 0 || (\n        !isUnknownElement$$1(vnode, inVPre) &&\n        vnode.tag.toLowerCase() === (node.tagName && node.tagName.toLowerCase())\n      )\n    } else {\n      return node.nodeType === (vnode.isComment ? 8 : 3)\n    }\n  }\n\n  return function patch (oldVnode, vnode, hydrating, removeOnly) {\n    if (isUndef(vnode)) {\n      if (isDef(oldVnode)) { invokeDestroyHook(oldVnode); }\n      return\n    }\n\n    var isInitialPatch = false;\n    var insertedVnodeQueue = [];\n\n    if (isUndef(oldVnode)) {\n      // empty mount (likely as component), create new root element\n      isInitialPatch = true;\n      createElm(vnode, insertedVnodeQueue);\n    } else {\n      var isRealElement = isDef(oldVnode.nodeType);\n      if (!isRealElement && sameVnode(oldVnode, vnode)) {\n        // patch existing root node\n        patchVnode(oldVnode, vnode, insertedVnodeQueue, null, null, removeOnly);\n      } else {\n        if (isRealElement) {\n          // mounting to a real element\n          // check if this is server-rendered content and if we can perform\n          // a successful hydration.\n          if (oldVnode.nodeType === 1 && oldVnode.hasAttribute(SSR_ATTR)) {\n            oldVnode.removeAttribute(SSR_ATTR);\n            hydrating = true;\n          }\n          if (isTrue(hydrating)) {\n            if (hydrate(oldVnode, vnode, insertedVnodeQueue)) {\n              invokeInsertHook(vnode, insertedVnodeQueue, true);\n              return oldVnode\n            } else if (process.env.NODE_ENV !== 'production') {\n              warn(\n                'The client-side rendered virtual DOM tree is not matching ' +\n                'server-rendered content. This is likely caused by incorrect ' +\n                'HTML markup, for example nesting block-level elements inside ' +\n                '<p>, or missing <tbody>. Bailing hydration and performing ' +\n                'full client-side render.'\n              );\n            }\n          }\n          // either not server-rendered, or hydration failed.\n          // create an empty node and replace it\n          oldVnode = emptyNodeAt(oldVnode);\n        }\n\n        // replacing existing element\n        var oldElm = oldVnode.elm;\n        var parentElm = nodeOps.parentNode(oldElm);\n\n        // create new node\n        createElm(\n          vnode,\n          insertedVnodeQueue,\n          // extremely rare edge case: do not insert if old element is in a\n          // leaving transition. Only happens when combining transition +\n          // keep-alive + HOCs. (#4590)\n          oldElm._leaveCb ? null : parentElm,\n          nodeOps.nextSibling(oldElm)\n        );\n\n        // update parent placeholder node element, recursively\n        if (isDef(vnode.parent)) {\n          var ancestor = vnode.parent;\n          var patchable = isPatchable(vnode);\n          while (ancestor) {\n            for (var i = 0; i < cbs.destroy.length; ++i) {\n              cbs.destroy[i](ancestor);\n            }\n            ancestor.elm = vnode.elm;\n            if (patchable) {\n              for (var i$1 = 0; i$1 < cbs.create.length; ++i$1) {\n                cbs.create[i$1](emptyNode, ancestor);\n              }\n              // #6513\n              // invoke insert hooks that may have been merged by create hooks.\n              // e.g. for directives that uses the \"inserted\" hook.\n              var insert = ancestor.data.hook.insert;\n              if (insert.merged) {\n                // start at index 1 to avoid re-invoking component mounted hook\n                for (var i$2 = 1; i$2 < insert.fns.length; i$2++) {\n                  insert.fns[i$2]();\n                }\n              }\n            } else {\n              registerRef(ancestor);\n            }\n            ancestor = ancestor.parent;\n          }\n        }\n\n        // destroy old node\n        if (isDef(parentElm)) {\n          removeVnodes(parentElm, [oldVnode], 0, 0);\n        } else if (isDef(oldVnode.tag)) {\n          invokeDestroyHook(oldVnode);\n        }\n      }\n    }\n\n    invokeInsertHook(vnode, insertedVnodeQueue, isInitialPatch);\n    return vnode.elm\n  }\n}\n\n/*  */\n\nvar directives = {\n  create: updateDirectives,\n  update: updateDirectives,\n  destroy: function unbindDirectives (vnode) {\n    updateDirectives(vnode, emptyNode);\n  }\n};\n\nfunction updateDirectives (oldVnode, vnode) {\n  if (oldVnode.data.directives || vnode.data.directives) {\n    _update(oldVnode, vnode);\n  }\n}\n\nfunction _update (oldVnode, vnode) {\n  var isCreate = oldVnode === emptyNode;\n  var isDestroy = vnode === emptyNode;\n  var oldDirs = normalizeDirectives$1(oldVnode.data.directives, oldVnode.context);\n  var newDirs = normalizeDirectives$1(vnode.data.directives, vnode.context);\n\n  var dirsWithInsert = [];\n  var dirsWithPostpatch = [];\n\n  var key, oldDir, dir;\n  for (key in newDirs) {\n    oldDir = oldDirs[key];\n    dir = newDirs[key];\n    if (!oldDir) {\n      // new directive, bind\n      callHook$1(dir, 'bind', vnode, oldVnode);\n      if (dir.def && dir.def.inserted) {\n        dirsWithInsert.push(dir);\n      }\n    } else {\n      // existing directive, update\n      dir.oldValue = oldDir.value;\n      dir.oldArg = oldDir.arg;\n      callHook$1(dir, 'update', vnode, oldVnode);\n      if (dir.def && dir.def.componentUpdated) {\n        dirsWithPostpatch.push(dir);\n      }\n    }\n  }\n\n  if (dirsWithInsert.length) {\n    var callInsert = function () {\n      for (var i = 0; i < dirsWithInsert.length; i++) {\n        callHook$1(dirsWithInsert[i], 'inserted', vnode, oldVnode);\n      }\n    };\n    if (isCreate) {\n      mergeVNodeHook(vnode, 'insert', callInsert);\n    } else {\n      callInsert();\n    }\n  }\n\n  if (dirsWithPostpatch.length) {\n    mergeVNodeHook(vnode, 'postpatch', function () {\n      for (var i = 0; i < dirsWithPostpatch.length; i++) {\n        callHook$1(dirsWithPostpatch[i], 'componentUpdated', vnode, oldVnode);\n      }\n    });\n  }\n\n  if (!isCreate) {\n    for (key in oldDirs) {\n      if (!newDirs[key]) {\n        // no longer present, unbind\n        callHook$1(oldDirs[key], 'unbind', oldVnode, oldVnode, isDestroy);\n      }\n    }\n  }\n}\n\nvar emptyModifiers = Object.create(null);\n\nfunction normalizeDirectives$1 (\n  dirs,\n  vm\n) {\n  var res = Object.create(null);\n  if (!dirs) {\n    // $flow-disable-line\n    return res\n  }\n  var i, dir;\n  for (i = 0; i < dirs.length; i++) {\n    dir = dirs[i];\n    if (!dir.modifiers) {\n      // $flow-disable-line\n      dir.modifiers = emptyModifiers;\n    }\n    res[getRawDirName(dir)] = dir;\n    dir.def = resolveAsset(vm.$options, 'directives', dir.name, true);\n  }\n  // $flow-disable-line\n  return res\n}\n\nfunction getRawDirName (dir) {\n  return dir.rawName || ((dir.name) + \".\" + (Object.keys(dir.modifiers || {}).join('.')))\n}\n\nfunction callHook$1 (dir, hook, vnode, oldVnode, isDestroy) {\n  var fn = dir.def && dir.def[hook];\n  if (fn) {\n    try {\n      fn(vnode.elm, dir, vnode, oldVnode, isDestroy);\n    } catch (e) {\n      handleError(e, vnode.context, (\"directive \" + (dir.name) + \" \" + hook + \" hook\"));\n    }\n  }\n}\n\nvar baseModules = [\n  ref,\n  directives\n];\n\n/*  */\n\nfunction updateAttrs (oldVnode, vnode) {\n  var opts = vnode.componentOptions;\n  if (isDef(opts) && opts.Ctor.options.inheritAttrs === false) {\n    return\n  }\n  if (isUndef(oldVnode.data.attrs) && isUndef(vnode.data.attrs)) {\n    return\n  }\n  var key, cur, old;\n  var elm = vnode.elm;\n  var oldAttrs = oldVnode.data.attrs || {};\n  var attrs = vnode.data.attrs || {};\n  // clone observed objects, as the user probably wants to mutate it\n  if (isDef(attrs.__ob__)) {\n    attrs = vnode.data.attrs = extend({}, attrs);\n  }\n\n  for (key in attrs) {\n    cur = attrs[key];\n    old = oldAttrs[key];\n    if (old !== cur) {\n      setAttr(elm, key, cur);\n    }\n  }\n  // #4391: in IE9, setting type can reset value for input[type=radio]\n  // #6666: IE/Edge forces progress value down to 1 before setting a max\n  /* istanbul ignore if */\n  if ((isIE || isEdge) && attrs.value !== oldAttrs.value) {\n    setAttr(elm, 'value', attrs.value);\n  }\n  for (key in oldAttrs) {\n    if (isUndef(attrs[key])) {\n      if (isXlink(key)) {\n        elm.removeAttributeNS(xlinkNS, getXlinkProp(key));\n      } else if (!isEnumeratedAttr(key)) {\n        elm.removeAttribute(key);\n      }\n    }\n  }\n}\n\nfunction setAttr (el, key, value) {\n  if (el.tagName.indexOf('-') > -1) {\n    baseSetAttr(el, key, value);\n  } else if (isBooleanAttr(key)) {\n    // set attribute for blank value\n    // e.g. <option disabled>Select one</option>\n    if (isFalsyAttrValue(value)) {\n      el.removeAttribute(key);\n    } else {\n      // technically allowfullscreen is a boolean attribute for <iframe>,\n      // but Flash expects a value of \"true\" when used on <embed> tag\n      value = key === 'allowfullscreen' && el.tagName === 'EMBED'\n        ? 'true'\n        : key;\n      el.setAttribute(key, value);\n    }\n  } else if (isEnumeratedAttr(key)) {\n    el.setAttribute(key, convertEnumeratedValue(key, value));\n  } else if (isXlink(key)) {\n    if (isFalsyAttrValue(value)) {\n      el.removeAttributeNS(xlinkNS, getXlinkProp(key));\n    } else {\n      el.setAttributeNS(xlinkNS, key, value);\n    }\n  } else {\n    baseSetAttr(el, key, value);\n  }\n}\n\nfunction baseSetAttr (el, key, value) {\n  if (isFalsyAttrValue(value)) {\n    el.removeAttribute(key);\n  } else {\n    // #7138: IE10 & 11 fires input event when setting placeholder on\n    // <textarea>... block the first input event and remove the blocker\n    // immediately.\n    /* istanbul ignore if */\n    if (\n      isIE && !isIE9 &&\n      el.tagName === 'TEXTAREA' &&\n      key === 'placeholder' && value !== '' && !el.__ieph\n    ) {\n      var blocker = function (e) {\n        e.stopImmediatePropagation();\n        el.removeEventListener('input', blocker);\n      };\n      el.addEventListener('input', blocker);\n      // $flow-disable-line\n      el.__ieph = true; /* IE placeholder patched */\n    }\n    el.setAttribute(key, value);\n  }\n}\n\nvar attrs = {\n  create: updateAttrs,\n  update: updateAttrs\n};\n\n/*  */\n\nfunction updateClass (oldVnode, vnode) {\n  var el = vnode.elm;\n  var data = vnode.data;\n  var oldData = oldVnode.data;\n  if (\n    isUndef(data.staticClass) &&\n    isUndef(data.class) && (\n      isUndef(oldData) || (\n        isUndef(oldData.staticClass) &&\n        isUndef(oldData.class)\n      )\n    )\n  ) {\n    return\n  }\n\n  var cls = genClassForVnode(vnode);\n\n  // handle transition classes\n  var transitionClass = el._transitionClasses;\n  if (isDef(transitionClass)) {\n    cls = concat(cls, stringifyClass(transitionClass));\n  }\n\n  // set the class\n  if (cls !== el._prevClass) {\n    el.setAttribute('class', cls);\n    el._prevClass = cls;\n  }\n}\n\nvar klass = {\n  create: updateClass,\n  update: updateClass\n};\n\n/*  */\n\nvar validDivisionCharRE = /[\\w).+\\-_$\\]]/;\n\nfunction parseFilters (exp) {\n  var inSingle = false;\n  var inDouble = false;\n  var inTemplateString = false;\n  var inRegex = false;\n  var curly = 0;\n  var square = 0;\n  var paren = 0;\n  var lastFilterIndex = 0;\n  var c, prev, i, expression, filters;\n\n  for (i = 0; i < exp.length; i++) {\n    prev = c;\n    c = exp.charCodeAt(i);\n    if (inSingle) {\n      if (c === 0x27 && prev !== 0x5C) { inSingle = false; }\n    } else if (inDouble) {\n      if (c === 0x22 && prev !== 0x5C) { inDouble = false; }\n    } else if (inTemplateString) {\n      if (c === 0x60 && prev !== 0x5C) { inTemplateString = false; }\n    } else if (inRegex) {\n      if (c === 0x2f && prev !== 0x5C) { inRegex = false; }\n    } else if (\n      c === 0x7C && // pipe\n      exp.charCodeAt(i + 1) !== 0x7C &&\n      exp.charCodeAt(i - 1) !== 0x7C &&\n      !curly && !square && !paren\n    ) {\n      if (expression === undefined) {\n        // first filter, end of expression\n        lastFilterIndex = i + 1;\n        expression = exp.slice(0, i).trim();\n      } else {\n        pushFilter();\n      }\n    } else {\n      switch (c) {\n        case 0x22: inDouble = true; break         // \"\n        case 0x27: inSingle = true; break         // '\n        case 0x60: inTemplateString = true; break // `\n        case 0x28: paren++; break                 // (\n        case 0x29: paren--; break                 // )\n        case 0x5B: square++; break                // [\n        case 0x5D: square--; break                // ]\n        case 0x7B: curly++; break                 // {\n        case 0x7D: curly--; break                 // }\n      }\n      if (c === 0x2f) { // /\n        var j = i - 1;\n        var p = (void 0);\n        // find first non-whitespace prev char\n        for (; j >= 0; j--) {\n          p = exp.charAt(j);\n          if (p !== ' ') { break }\n        }\n        if (!p || !validDivisionCharRE.test(p)) {\n          inRegex = true;\n        }\n      }\n    }\n  }\n\n  if (expression === undefined) {\n    expression = exp.slice(0, i).trim();\n  } else if (lastFilterIndex !== 0) {\n    pushFilter();\n  }\n\n  function pushFilter () {\n    (filters || (filters = [])).push(exp.slice(lastFilterIndex, i).trim());\n    lastFilterIndex = i + 1;\n  }\n\n  if (filters) {\n    for (i = 0; i < filters.length; i++) {\n      expression = wrapFilter(expression, filters[i]);\n    }\n  }\n\n  return expression\n}\n\nfunction wrapFilter (exp, filter) {\n  var i = filter.indexOf('(');\n  if (i < 0) {\n    // _f: resolveFilter\n    return (\"_f(\\\"\" + filter + \"\\\")(\" + exp + \")\")\n  } else {\n    var name = filter.slice(0, i);\n    var args = filter.slice(i + 1);\n    return (\"_f(\\\"\" + name + \"\\\")(\" + exp + (args !== ')' ? ',' + args : args))\n  }\n}\n\n/*  */\n\n\n\n/* eslint-disable no-unused-vars */\nfunction baseWarn (msg, range) {\n  console.error((\"[Vue compiler]: \" + msg));\n}\n/* eslint-enable no-unused-vars */\n\nfunction pluckModuleFunction (\n  modules,\n  key\n) {\n  return modules\n    ? modules.map(function (m) { return m[key]; }).filter(function (_) { return _; })\n    : []\n}\n\nfunction addProp (el, name, value, range, dynamic) {\n  (el.props || (el.props = [])).push(rangeSetItem({ name: name, value: value, dynamic: dynamic }, range));\n  el.plain = false;\n}\n\nfunction addAttr (el, name, value, range, dynamic) {\n  var attrs = dynamic\n    ? (el.dynamicAttrs || (el.dynamicAttrs = []))\n    : (el.attrs || (el.attrs = []));\n  attrs.push(rangeSetItem({ name: name, value: value, dynamic: dynamic }, range));\n  el.plain = false;\n}\n\n// add a raw attr (use this in preTransforms)\nfunction addRawAttr (el, name, value, range) {\n  el.attrsMap[name] = value;\n  el.attrsList.push(rangeSetItem({ name: name, value: value }, range));\n}\n\nfunction addDirective (\n  el,\n  name,\n  rawName,\n  value,\n  arg,\n  isDynamicArg,\n  modifiers,\n  range\n) {\n  (el.directives || (el.directives = [])).push(rangeSetItem({\n    name: name,\n    rawName: rawName,\n    value: value,\n    arg: arg,\n    isDynamicArg: isDynamicArg,\n    modifiers: modifiers\n  }, range));\n  el.plain = false;\n}\n\nfunction prependModifierMarker (symbol, name, dynamic) {\n  return dynamic\n    ? (\"_p(\" + name + \",\\\"\" + symbol + \"\\\")\")\n    : symbol + name // mark the event as captured\n}\n\nfunction addHandler (\n  el,\n  name,\n  value,\n  modifiers,\n  important,\n  warn,\n  range,\n  dynamic\n) {\n  modifiers = modifiers || emptyObject;\n  // warn prevent and passive modifier\n  /* istanbul ignore if */\n  if (\n    process.env.NODE_ENV !== 'production' && warn &&\n    modifiers.prevent && modifiers.passive\n  ) {\n    warn(\n      'passive and prevent can\\'t be used together. ' +\n      'Passive handler can\\'t prevent default event.',\n      range\n    );\n  }\n\n  // normalize click.right and click.middle since they don't actually fire\n  // this is technically browser-specific, but at least for now browsers are\n  // the only target envs that have right/middle clicks.\n  if (modifiers.right) {\n    if (dynamic) {\n      name = \"(\" + name + \")==='click'?'contextmenu':(\" + name + \")\";\n    } else if (name === 'click') {\n      name = 'contextmenu';\n      delete modifiers.right;\n    }\n  } else if (modifiers.middle) {\n    if (dynamic) {\n      name = \"(\" + name + \")==='click'?'mouseup':(\" + name + \")\";\n    } else if (name === 'click') {\n      name = 'mouseup';\n    }\n  }\n\n  // check capture modifier\n  if (modifiers.capture) {\n    delete modifiers.capture;\n    name = prependModifierMarker('!', name, dynamic);\n  }\n  if (modifiers.once) {\n    delete modifiers.once;\n    name = prependModifierMarker('~', name, dynamic);\n  }\n  /* istanbul ignore if */\n  if (modifiers.passive) {\n    delete modifiers.passive;\n    name = prependModifierMarker('&', name, dynamic);\n  }\n\n  var events;\n  if (modifiers.native) {\n    delete modifiers.native;\n    events = el.nativeEvents || (el.nativeEvents = {});\n  } else {\n    events = el.events || (el.events = {});\n  }\n\n  var newHandler = rangeSetItem({ value: value.trim(), dynamic: dynamic }, range);\n  if (modifiers !== emptyObject) {\n    newHandler.modifiers = modifiers;\n  }\n\n  var handlers = events[name];\n  /* istanbul ignore if */\n  if (Array.isArray(handlers)) {\n    important ? handlers.unshift(newHandler) : handlers.push(newHandler);\n  } else if (handlers) {\n    events[name] = important ? [newHandler, handlers] : [handlers, newHandler];\n  } else {\n    events[name] = newHandler;\n  }\n\n  el.plain = false;\n}\n\nfunction getRawBindingAttr (\n  el,\n  name\n) {\n  return el.rawAttrsMap[':' + name] ||\n    el.rawAttrsMap['v-bind:' + name] ||\n    el.rawAttrsMap[name]\n}\n\nfunction getBindingAttr (\n  el,\n  name,\n  getStatic\n) {\n  var dynamicValue =\n    getAndRemoveAttr(el, ':' + name) ||\n    getAndRemoveAttr(el, 'v-bind:' + name);\n  if (dynamicValue != null) {\n    return parseFilters(dynamicValue)\n  } else if (getStatic !== false) {\n    var staticValue = getAndRemoveAttr(el, name);\n    if (staticValue != null) {\n      return JSON.stringify(staticValue)\n    }\n  }\n}\n\n// note: this only removes the attr from the Array (attrsList) so that it\n// doesn't get processed by processAttrs.\n// By default it does NOT remove it from the map (attrsMap) because the map is\n// needed during codegen.\nfunction getAndRemoveAttr (\n  el,\n  name,\n  removeFromMap\n) {\n  var val;\n  if ((val = el.attrsMap[name]) != null) {\n    var list = el.attrsList;\n    for (var i = 0, l = list.length; i < l; i++) {\n      if (list[i].name === name) {\n        list.splice(i, 1);\n        break\n      }\n    }\n  }\n  if (removeFromMap) {\n    delete el.attrsMap[name];\n  }\n  return val\n}\n\nfunction getAndRemoveAttrByRegex (\n  el,\n  name\n) {\n  var list = el.attrsList;\n  for (var i = 0, l = list.length; i < l; i++) {\n    var attr = list[i];\n    if (name.test(attr.name)) {\n      list.splice(i, 1);\n      return attr\n    }\n  }\n}\n\nfunction rangeSetItem (\n  item,\n  range\n) {\n  if (range) {\n    if (range.start != null) {\n      item.start = range.start;\n    }\n    if (range.end != null) {\n      item.end = range.end;\n    }\n  }\n  return item\n}\n\n/*  */\n\n/**\n * Cross-platform code generation for component v-model\n */\nfunction genComponentModel (\n  el,\n  value,\n  modifiers\n) {\n  var ref = modifiers || {};\n  var number = ref.number;\n  var trim = ref.trim;\n\n  var baseValueExpression = '$$v';\n  var valueExpression = baseValueExpression;\n  if (trim) {\n    valueExpression =\n      \"(typeof \" + baseValueExpression + \" === 'string'\" +\n      \"? \" + baseValueExpression + \".trim()\" +\n      \": \" + baseValueExpression + \")\";\n  }\n  if (number) {\n    valueExpression = \"_n(\" + valueExpression + \")\";\n  }\n  var assignment = genAssignmentCode(value, valueExpression);\n\n  el.model = {\n    value: (\"(\" + value + \")\"),\n    expression: JSON.stringify(value),\n    callback: (\"function (\" + baseValueExpression + \") {\" + assignment + \"}\")\n  };\n}\n\n/**\n * Cross-platform codegen helper for generating v-model value assignment code.\n */\nfunction genAssignmentCode (\n  value,\n  assignment\n) {\n  var res = parseModel(value);\n  if (res.key === null) {\n    return (value + \"=\" + assignment)\n  } else {\n    return (\"$set(\" + (res.exp) + \", \" + (res.key) + \", \" + assignment + \")\")\n  }\n}\n\n/**\n * Parse a v-model expression into a base path and a final key segment.\n * Handles both dot-path and possible square brackets.\n *\n * Possible cases:\n *\n * - test\n * - test[key]\n * - test[test1[key]]\n * - test[\"a\"][key]\n * - xxx.test[a[a].test1[key]]\n * - test.xxx.a[\"asa\"][test1[key]]\n *\n */\n\nvar len, str, chr, index$1, expressionPos, expressionEndPos;\n\n\n\nfunction parseModel (val) {\n  // Fix https://github.com/vuejs/vue/pull/7730\n  // allow v-model=\"obj.val \" (trailing whitespace)\n  val = val.trim();\n  len = val.length;\n\n  if (val.indexOf('[') < 0 || val.lastIndexOf(']') < len - 1) {\n    index$1 = val.lastIndexOf('.');\n    if (index$1 > -1) {\n      return {\n        exp: val.slice(0, index$1),\n        key: '\"' + val.slice(index$1 + 1) + '\"'\n      }\n    } else {\n      return {\n        exp: val,\n        key: null\n      }\n    }\n  }\n\n  str = val;\n  index$1 = expressionPos = expressionEndPos = 0;\n\n  while (!eof()) {\n    chr = next();\n    /* istanbul ignore if */\n    if (isStringStart(chr)) {\n      parseString(chr);\n    } else if (chr === 0x5B) {\n      parseBracket(chr);\n    }\n  }\n\n  return {\n    exp: val.slice(0, expressionPos),\n    key: val.slice(expressionPos + 1, expressionEndPos)\n  }\n}\n\nfunction next () {\n  return str.charCodeAt(++index$1)\n}\n\nfunction eof () {\n  return index$1 >= len\n}\n\nfunction isStringStart (chr) {\n  return chr === 0x22 || chr === 0x27\n}\n\nfunction parseBracket (chr) {\n  var inBracket = 1;\n  expressionPos = index$1;\n  while (!eof()) {\n    chr = next();\n    if (isStringStart(chr)) {\n      parseString(chr);\n      continue\n    }\n    if (chr === 0x5B) { inBracket++; }\n    if (chr === 0x5D) { inBracket--; }\n    if (inBracket === 0) {\n      expressionEndPos = index$1;\n      break\n    }\n  }\n}\n\nfunction parseString (chr) {\n  var stringQuote = chr;\n  while (!eof()) {\n    chr = next();\n    if (chr === stringQuote) {\n      break\n    }\n  }\n}\n\n/*  */\n\nvar warn$1;\n\n// in some cases, the event used has to be determined at runtime\n// so we used some reserved tokens during compile.\nvar RANGE_TOKEN = '__r';\nvar CHECKBOX_RADIO_TOKEN = '__c';\n\nfunction model (\n  el,\n  dir,\n  _warn\n) {\n  warn$1 = _warn;\n  var value = dir.value;\n  var modifiers = dir.modifiers;\n  var tag = el.tag;\n  var type = el.attrsMap.type;\n\n  if (process.env.NODE_ENV !== 'production') {\n    // inputs with type=\"file\" are read only and setting the input's\n    // value will throw an error.\n    if (tag === 'input' && type === 'file') {\n      warn$1(\n        \"<\" + (el.tag) + \" v-model=\\\"\" + value + \"\\\" type=\\\"file\\\">:\\n\" +\n        \"File inputs are read only. Use a v-on:change listener instead.\",\n        el.rawAttrsMap['v-model']\n      );\n    }\n  }\n\n  if (el.component) {\n    genComponentModel(el, value, modifiers);\n    // component v-model doesn't need extra runtime\n    return false\n  } else if (tag === 'select') {\n    genSelect(el, value, modifiers);\n  } else if (tag === 'input' && type === 'checkbox') {\n    genCheckboxModel(el, value, modifiers);\n  } else if (tag === 'input' && type === 'radio') {\n    genRadioModel(el, value, modifiers);\n  } else if (tag === 'input' || tag === 'textarea') {\n    genDefaultModel(el, value, modifiers);\n  } else if (!config.isReservedTag(tag)) {\n    genComponentModel(el, value, modifiers);\n    // component v-model doesn't need extra runtime\n    return false\n  } else if (process.env.NODE_ENV !== 'production') {\n    warn$1(\n      \"<\" + (el.tag) + \" v-model=\\\"\" + value + \"\\\">: \" +\n      \"v-model is not supported on this element type. \" +\n      'If you are working with contenteditable, it\\'s recommended to ' +\n      'wrap a library dedicated for that purpose inside a custom component.',\n      el.rawAttrsMap['v-model']\n    );\n  }\n\n  // ensure runtime directive metadata\n  return true\n}\n\nfunction genCheckboxModel (\n  el,\n  value,\n  modifiers\n) {\n  var number = modifiers && modifiers.number;\n  var valueBinding = getBindingAttr(el, 'value') || 'null';\n  var trueValueBinding = getBindingAttr(el, 'true-value') || 'true';\n  var falseValueBinding = getBindingAttr(el, 'false-value') || 'false';\n  addProp(el, 'checked',\n    \"Array.isArray(\" + value + \")\" +\n    \"?_i(\" + value + \",\" + valueBinding + \")>-1\" + (\n      trueValueBinding === 'true'\n        ? (\":(\" + value + \")\")\n        : (\":_q(\" + value + \",\" + trueValueBinding + \")\")\n    )\n  );\n  addHandler(el, 'change',\n    \"var $$a=\" + value + \",\" +\n        '$$el=$event.target,' +\n        \"$$c=$$el.checked?(\" + trueValueBinding + \"):(\" + falseValueBinding + \");\" +\n    'if(Array.isArray($$a)){' +\n      \"var $$v=\" + (number ? '_n(' + valueBinding + ')' : valueBinding) + \",\" +\n          '$$i=_i($$a,$$v);' +\n      \"if($$el.checked){$$i<0&&(\" + (genAssignmentCode(value, '$$a.concat([$$v])')) + \")}\" +\n      \"else{$$i>-1&&(\" + (genAssignmentCode(value, '$$a.slice(0,$$i).concat($$a.slice($$i+1))')) + \")}\" +\n    \"}else{\" + (genAssignmentCode(value, '$$c')) + \"}\",\n    null, true\n  );\n}\n\nfunction genRadioModel (\n  el,\n  value,\n  modifiers\n) {\n  var number = modifiers && modifiers.number;\n  var valueBinding = getBindingAttr(el, 'value') || 'null';\n  valueBinding = number ? (\"_n(\" + valueBinding + \")\") : valueBinding;\n  addProp(el, 'checked', (\"_q(\" + value + \",\" + valueBinding + \")\"));\n  addHandler(el, 'change', genAssignmentCode(value, valueBinding), null, true);\n}\n\nfunction genSelect (\n  el,\n  value,\n  modifiers\n) {\n  var number = modifiers && modifiers.number;\n  var selectedVal = \"Array.prototype.filter\" +\n    \".call($event.target.options,function(o){return o.selected})\" +\n    \".map(function(o){var val = \\\"_value\\\" in o ? o._value : o.value;\" +\n    \"return \" + (number ? '_n(val)' : 'val') + \"})\";\n\n  var assignment = '$event.target.multiple ? $$selectedVal : $$selectedVal[0]';\n  var code = \"var $$selectedVal = \" + selectedVal + \";\";\n  code = code + \" \" + (genAssignmentCode(value, assignment));\n  addHandler(el, 'change', code, null, true);\n}\n\nfunction genDefaultModel (\n  el,\n  value,\n  modifiers\n) {\n  var type = el.attrsMap.type;\n\n  // warn if v-bind:value conflicts with v-model\n  // except for inputs with v-bind:type\n  if (process.env.NODE_ENV !== 'production') {\n    var value$1 = el.attrsMap['v-bind:value'] || el.attrsMap[':value'];\n    var typeBinding = el.attrsMap['v-bind:type'] || el.attrsMap[':type'];\n    if (value$1 && !typeBinding) {\n      var binding = el.attrsMap['v-bind:value'] ? 'v-bind:value' : ':value';\n      warn$1(\n        binding + \"=\\\"\" + value$1 + \"\\\" conflicts with v-model on the same element \" +\n        'because the latter already expands to a value binding internally',\n        el.rawAttrsMap[binding]\n      );\n    }\n  }\n\n  var ref = modifiers || {};\n  var lazy = ref.lazy;\n  var number = ref.number;\n  var trim = ref.trim;\n  var needCompositionGuard = !lazy && type !== 'range';\n  var event = lazy\n    ? 'change'\n    : type === 'range'\n      ? RANGE_TOKEN\n      : 'input';\n\n  var valueExpression = '$event.target.value';\n  if (trim) {\n    valueExpression = \"$event.target.value.trim()\";\n  }\n  if (number) {\n    valueExpression = \"_n(\" + valueExpression + \")\";\n  }\n\n  var code = genAssignmentCode(value, valueExpression);\n  if (needCompositionGuard) {\n    code = \"if($event.target.composing)return;\" + code;\n  }\n\n  addProp(el, 'value', (\"(\" + value + \")\"));\n  addHandler(el, event, code, null, true);\n  if (trim || number) {\n    addHandler(el, 'blur', '$forceUpdate()');\n  }\n}\n\n/*  */\n\n// normalize v-model event tokens that can only be determined at runtime.\n// it's important to place the event as the first in the array because\n// the whole point is ensuring the v-model callback gets called before\n// user-attached handlers.\nfunction normalizeEvents (on) {\n  /* istanbul ignore if */\n  if (isDef(on[RANGE_TOKEN])) {\n    // IE input[type=range] only supports `change` event\n    var event = isIE ? 'change' : 'input';\n    on[event] = [].concat(on[RANGE_TOKEN], on[event] || []);\n    delete on[RANGE_TOKEN];\n  }\n  // This was originally intended to fix #4521 but no longer necessary\n  // after 2.5. Keeping it for backwards compat with generated code from < 2.4\n  /* istanbul ignore if */\n  if (isDef(on[CHECKBOX_RADIO_TOKEN])) {\n    on.change = [].concat(on[CHECKBOX_RADIO_TOKEN], on.change || []);\n    delete on[CHECKBOX_RADIO_TOKEN];\n  }\n}\n\nvar target$1;\n\nfunction createOnceHandler$1 (event, handler, capture) {\n  var _target = target$1; // save current target element in closure\n  return function onceHandler () {\n    var res = handler.apply(null, arguments);\n    if (res !== null) {\n      remove$2(event, onceHandler, capture, _target);\n    }\n  }\n}\n\n// #9446: Firefox <= 53 (in particular, ESR 52) has incorrect Event.timeStamp\n// implementation and does not fire microtasks in between event propagation, so\n// safe to exclude.\nvar useMicrotaskFix = isUsingMicroTask && !(isFF && Number(isFF[1]) <= 53);\n\nfunction add$1 (\n  name,\n  handler,\n  capture,\n  passive\n) {\n  // async edge case #6566: inner click event triggers patch, event handler\n  // attached to outer element during patch, and triggered again. This\n  // happens because browsers fire microtask ticks between event propagation.\n  // the solution is simple: we save the timestamp when a handler is attached,\n  // and the handler would only fire if the event passed to it was fired\n  // AFTER it was attached.\n  if (useMicrotaskFix) {\n    var attachedTimestamp = currentFlushTimestamp;\n    var original = handler;\n    handler = original._wrapper = function (e) {\n      if (\n        // no bubbling, should always fire.\n        // this is just a safety net in case event.timeStamp is unreliable in\n        // certain weird environments...\n        e.target === e.currentTarget ||\n        // event is fired after handler attachment\n        e.timeStamp >= attachedTimestamp ||\n        // bail for environments that have buggy event.timeStamp implementations\n        // #9462 iOS 9 bug: event.timeStamp is 0 after history.pushState\n        // #9681 QtWebEngine event.timeStamp is negative value\n        e.timeStamp <= 0 ||\n        // #9448 bail if event is fired in another document in a multi-page\n        // electron/nw.js app, since event.timeStamp will be using a different\n        // starting reference\n        e.target.ownerDocument !== document\n      ) {\n        return original.apply(this, arguments)\n      }\n    };\n  }\n  target$1.addEventListener(\n    name,\n    handler,\n    supportsPassive\n      ? { capture: capture, passive: passive }\n      : capture\n  );\n}\n\nfunction remove$2 (\n  name,\n  handler,\n  capture,\n  _target\n) {\n  (_target || target$1).removeEventListener(\n    name,\n    handler._wrapper || handler,\n    capture\n  );\n}\n\nfunction updateDOMListeners (oldVnode, vnode) {\n  if (isUndef(oldVnode.data.on) && isUndef(vnode.data.on)) {\n    return\n  }\n  var on = vnode.data.on || {};\n  var oldOn = oldVnode.data.on || {};\n  target$1 = vnode.elm;\n  normalizeEvents(on);\n  updateListeners(on, oldOn, add$1, remove$2, createOnceHandler$1, vnode.context);\n  target$1 = undefined;\n}\n\nvar events = {\n  create: updateDOMListeners,\n  update: updateDOMListeners\n};\n\n/*  */\n\nvar svgContainer;\n\nfunction updateDOMProps (oldVnode, vnode) {\n  if (isUndef(oldVnode.data.domProps) && isUndef(vnode.data.domProps)) {\n    return\n  }\n  var key, cur;\n  var elm = vnode.elm;\n  var oldProps = oldVnode.data.domProps || {};\n  var props = vnode.data.domProps || {};\n  // clone observed objects, as the user probably wants to mutate it\n  if (isDef(props.__ob__)) {\n    props = vnode.data.domProps = extend({}, props);\n  }\n\n  for (key in oldProps) {\n    if (!(key in props)) {\n      elm[key] = '';\n    }\n  }\n\n  for (key in props) {\n    cur = props[key];\n    // ignore children if the node has textContent or innerHTML,\n    // as these will throw away existing DOM nodes and cause removal errors\n    // on subsequent patches (#3360)\n    if (key === 'textContent' || key === 'innerHTML') {\n      if (vnode.children) { vnode.children.length = 0; }\n      if (cur === oldProps[key]) { continue }\n      // #6601 work around Chrome version <= 55 bug where single textNode\n      // replaced by innerHTML/textContent retains its parentNode property\n      if (elm.childNodes.length === 1) {\n        elm.removeChild(elm.childNodes[0]);\n      }\n    }\n\n    if (key === 'value' && elm.tagName !== 'PROGRESS') {\n      // store value as _value as well since\n      // non-string values will be stringified\n      elm._value = cur;\n      // avoid resetting cursor position when value is the same\n      var strCur = isUndef(cur) ? '' : String(cur);\n      if (shouldUpdateValue(elm, strCur)) {\n        elm.value = strCur;\n      }\n    } else if (key === 'innerHTML' && isSVG(elm.tagName) && isUndef(elm.innerHTML)) {\n      // IE doesn't support innerHTML for SVG elements\n      svgContainer = svgContainer || document.createElement('div');\n      svgContainer.innerHTML = \"<svg>\" + cur + \"</svg>\";\n      var svg = svgContainer.firstChild;\n      while (elm.firstChild) {\n        elm.removeChild(elm.firstChild);\n      }\n      while (svg.firstChild) {\n        elm.appendChild(svg.firstChild);\n      }\n    } else if (\n      // skip the update if old and new VDOM state is the same.\n      // `value` is handled separately because the DOM value may be temporarily\n      // out of sync with VDOM state due to focus, composition and modifiers.\n      // This  #4521 by skipping the unnecesarry `checked` update.\n      cur !== oldProps[key]\n    ) {\n      // some property updates can throw\n      // e.g. `value` on <progress> w/ non-finite value\n      try {\n        elm[key] = cur;\n      } catch (e) {}\n    }\n  }\n}\n\n// check platforms/web/util/attrs.js acceptValue\n\n\nfunction shouldUpdateValue (elm, checkVal) {\n  return (!elm.composing && (\n    elm.tagName === 'OPTION' ||\n    isNotInFocusAndDirty(elm, checkVal) ||\n    isDirtyWithModifiers(elm, checkVal)\n  ))\n}\n\nfunction isNotInFocusAndDirty (elm, checkVal) {\n  // return true when textbox (.number and .trim) loses focus and its value is\n  // not equal to the updated value\n  var notInFocus = true;\n  // #6157\n  // work around IE bug when accessing document.activeElement in an iframe\n  try { notInFocus = document.activeElement !== elm; } catch (e) {}\n  return notInFocus && elm.value !== checkVal\n}\n\nfunction isDirtyWithModifiers (elm, newVal) {\n  var value = elm.value;\n  var modifiers = elm._vModifiers; // injected by v-model runtime\n  if (isDef(modifiers)) {\n    if (modifiers.number) {\n      return toNumber(value) !== toNumber(newVal)\n    }\n    if (modifiers.trim) {\n      return value.trim() !== newVal.trim()\n    }\n  }\n  return value !== newVal\n}\n\nvar domProps = {\n  create: updateDOMProps,\n  update: updateDOMProps\n};\n\n/*  */\n\nvar parseStyleText = cached(function (cssText) {\n  var res = {};\n  var listDelimiter = /;(?![^(]*\\))/g;\n  var propertyDelimiter = /:(.+)/;\n  cssText.split(listDelimiter).forEach(function (item) {\n    if (item) {\n      var tmp = item.split(propertyDelimiter);\n      tmp.length > 1 && (res[tmp[0].trim()] = tmp[1].trim());\n    }\n  });\n  return res\n});\n\n// merge static and dynamic style data on the same vnode\nfunction normalizeStyleData (data) {\n  var style = normalizeStyleBinding(data.style);\n  // static style is pre-processed into an object during compilation\n  // and is always a fresh object, so it's safe to merge into it\n  return data.staticStyle\n    ? extend(data.staticStyle, style)\n    : style\n}\n\n// normalize possible array / string values into Object\nfunction normalizeStyleBinding (bindingStyle) {\n  if (Array.isArray(bindingStyle)) {\n    return toObject(bindingStyle)\n  }\n  if (typeof bindingStyle === 'string') {\n    return parseStyleText(bindingStyle)\n  }\n  return bindingStyle\n}\n\n/**\n * parent component style should be after child's\n * so that parent component's style could override it\n */\nfunction getStyle (vnode, checkChild) {\n  var res = {};\n  var styleData;\n\n  if (checkChild) {\n    var childNode = vnode;\n    while (childNode.componentInstance) {\n      childNode = childNode.componentInstance._vnode;\n      if (\n        childNode && childNode.data &&\n        (styleData = normalizeStyleData(childNode.data))\n      ) {\n        extend(res, styleData);\n      }\n    }\n  }\n\n  if ((styleData = normalizeStyleData(vnode.data))) {\n    extend(res, styleData);\n  }\n\n  var parentNode = vnode;\n  while ((parentNode = parentNode.parent)) {\n    if (parentNode.data && (styleData = normalizeStyleData(parentNode.data))) {\n      extend(res, styleData);\n    }\n  }\n  return res\n}\n\n/*  */\n\nvar cssVarRE = /^--/;\nvar importantRE = /\\s*!important$/;\nvar setProp = function (el, name, val) {\n  /* istanbul ignore if */\n  if (cssVarRE.test(name)) {\n    el.style.setProperty(name, val);\n  } else if (importantRE.test(val)) {\n    el.style.setProperty(hyphenate(name), val.replace(importantRE, ''), 'important');\n  } else {\n    var normalizedName = normalize(name);\n    if (Array.isArray(val)) {\n      // Support values array created by autoprefixer, e.g.\n      // {display: [\"-webkit-box\", \"-ms-flexbox\", \"flex\"]}\n      // Set them one by one, and the browser will only set those it can recognize\n      for (var i = 0, len = val.length; i < len; i++) {\n        el.style[normalizedName] = val[i];\n      }\n    } else {\n      el.style[normalizedName] = val;\n    }\n  }\n};\n\nvar vendorNames = ['Webkit', 'Moz', 'ms'];\n\nvar emptyStyle;\nvar normalize = cached(function (prop) {\n  emptyStyle = emptyStyle || document.createElement('div').style;\n  prop = camelize(prop);\n  if (prop !== 'filter' && (prop in emptyStyle)) {\n    return prop\n  }\n  var capName = prop.charAt(0).toUpperCase() + prop.slice(1);\n  for (var i = 0; i < vendorNames.length; i++) {\n    var name = vendorNames[i] + capName;\n    if (name in emptyStyle) {\n      return name\n    }\n  }\n});\n\nfunction updateStyle (oldVnode, vnode) {\n  var data = vnode.data;\n  var oldData = oldVnode.data;\n\n  if (isUndef(data.staticStyle) && isUndef(data.style) &&\n    isUndef(oldData.staticStyle) && isUndef(oldData.style)\n  ) {\n    return\n  }\n\n  var cur, name;\n  var el = vnode.elm;\n  var oldStaticStyle = oldData.staticStyle;\n  var oldStyleBinding = oldData.normalizedStyle || oldData.style || {};\n\n  // if static style exists, stylebinding already merged into it when doing normalizeStyleData\n  var oldStyle = oldStaticStyle || oldStyleBinding;\n\n  var style = normalizeStyleBinding(vnode.data.style) || {};\n\n  // store normalized style under a different key for next diff\n  // make sure to clone it if it's reactive, since the user likely wants\n  // to mutate it.\n  vnode.data.normalizedStyle = isDef(style.__ob__)\n    ? extend({}, style)\n    : style;\n\n  var newStyle = getStyle(vnode, true);\n\n  for (name in oldStyle) {\n    if (isUndef(newStyle[name])) {\n      setProp(el, name, '');\n    }\n  }\n  for (name in newStyle) {\n    cur = newStyle[name];\n    if (cur !== oldStyle[name]) {\n      // ie9 setting to null has no effect, must use empty string\n      setProp(el, name, cur == null ? '' : cur);\n    }\n  }\n}\n\nvar style = {\n  create: updateStyle,\n  update: updateStyle\n};\n\n/*  */\n\nvar whitespaceRE = /\\s+/;\n\n/**\n * Add class with compatibility for SVG since classList is not supported on\n * SVG elements in IE\n */\nfunction addClass (el, cls) {\n  /* istanbul ignore if */\n  if (!cls || !(cls = cls.trim())) {\n    return\n  }\n\n  /* istanbul ignore else */\n  if (el.classList) {\n    if (cls.indexOf(' ') > -1) {\n      cls.split(whitespaceRE).forEach(function (c) { return el.classList.add(c); });\n    } else {\n      el.classList.add(cls);\n    }\n  } else {\n    var cur = \" \" + (el.getAttribute('class') || '') + \" \";\n    if (cur.indexOf(' ' + cls + ' ') < 0) {\n      el.setAttribute('class', (cur + cls).trim());\n    }\n  }\n}\n\n/**\n * Remove class with compatibility for SVG since classList is not supported on\n * SVG elements in IE\n */\nfunction removeClass (el, cls) {\n  /* istanbul ignore if */\n  if (!cls || !(cls = cls.trim())) {\n    return\n  }\n\n  /* istanbul ignore else */\n  if (el.classList) {\n    if (cls.indexOf(' ') > -1) {\n      cls.split(whitespaceRE).forEach(function (c) { return el.classList.remove(c); });\n    } else {\n      el.classList.remove(cls);\n    }\n    if (!el.classList.length) {\n      el.removeAttribute('class');\n    }\n  } else {\n    var cur = \" \" + (el.getAttribute('class') || '') + \" \";\n    var tar = ' ' + cls + ' ';\n    while (cur.indexOf(tar) >= 0) {\n      cur = cur.replace(tar, ' ');\n    }\n    cur = cur.trim();\n    if (cur) {\n      el.setAttribute('class', cur);\n    } else {\n      el.removeAttribute('class');\n    }\n  }\n}\n\n/*  */\n\nfunction resolveTransition (def$$1) {\n  if (!def$$1) {\n    return\n  }\n  /* istanbul ignore else */\n  if (typeof def$$1 === 'object') {\n    var res = {};\n    if (def$$1.css !== false) {\n      extend(res, autoCssTransition(def$$1.name || 'v'));\n    }\n    extend(res, def$$1);\n    return res\n  } else if (typeof def$$1 === 'string') {\n    return autoCssTransition(def$$1)\n  }\n}\n\nvar autoCssTransition = cached(function (name) {\n  return {\n    enterClass: (name + \"-enter\"),\n    enterToClass: (name + \"-enter-to\"),\n    enterActiveClass: (name + \"-enter-active\"),\n    leaveClass: (name + \"-leave\"),\n    leaveToClass: (name + \"-leave-to\"),\n    leaveActiveClass: (name + \"-leave-active\")\n  }\n});\n\nvar hasTransition = inBrowser && !isIE9;\nvar TRANSITION = 'transition';\nvar ANIMATION = 'animation';\n\n// Transition property/event sniffing\nvar transitionProp = 'transition';\nvar transitionEndEvent = 'transitionend';\nvar animationProp = 'animation';\nvar animationEndEvent = 'animationend';\nif (hasTransition) {\n  /* istanbul ignore if */\n  if (window.ontransitionend === undefined &&\n    window.onwebkittransitionend !== undefined\n  ) {\n    transitionProp = 'WebkitTransition';\n    transitionEndEvent = 'webkitTransitionEnd';\n  }\n  if (window.onanimationend === undefined &&\n    window.onwebkitanimationend !== undefined\n  ) {\n    animationProp = 'WebkitAnimation';\n    animationEndEvent = 'webkitAnimationEnd';\n  }\n}\n\n// binding to window is necessary to make hot reload work in IE in strict mode\nvar raf = inBrowser\n  ? window.requestAnimationFrame\n    ? window.requestAnimationFrame.bind(window)\n    : setTimeout\n  : /* istanbul ignore next */ function (fn) { return fn(); };\n\nfunction nextFrame (fn) {\n  raf(function () {\n    raf(fn);\n  });\n}\n\nfunction addTransitionClass (el, cls) {\n  var transitionClasses = el._transitionClasses || (el._transitionClasses = []);\n  if (transitionClasses.indexOf(cls) < 0) {\n    transitionClasses.push(cls);\n    addClass(el, cls);\n  }\n}\n\nfunction removeTransitionClass (el, cls) {\n  if (el._transitionClasses) {\n    remove(el._transitionClasses, cls);\n  }\n  removeClass(el, cls);\n}\n\nfunction whenTransitionEnds (\n  el,\n  expectedType,\n  cb\n) {\n  var ref = getTransitionInfo(el, expectedType);\n  var type = ref.type;\n  var timeout = ref.timeout;\n  var propCount = ref.propCount;\n  if (!type) { return cb() }\n  var event = type === TRANSITION ? transitionEndEvent : animationEndEvent;\n  var ended = 0;\n  var end = function () {\n    el.removeEventListener(event, onEnd);\n    cb();\n  };\n  var onEnd = function (e) {\n    if (e.target === el) {\n      if (++ended >= propCount) {\n        end();\n      }\n    }\n  };\n  setTimeout(function () {\n    if (ended < propCount) {\n      end();\n    }\n  }, timeout + 1);\n  el.addEventListener(event, onEnd);\n}\n\nvar transformRE = /\\b(transform|all)(,|$)/;\n\nfunction getTransitionInfo (el, expectedType) {\n  var styles = window.getComputedStyle(el);\n  // JSDOM may return undefined for transition properties\n  var transitionDelays = (styles[transitionProp + 'Delay'] || '').split(', ');\n  var transitionDurations = (styles[transitionProp + 'Duration'] || '').split(', ');\n  var transitionTimeout = getTimeout(transitionDelays, transitionDurations);\n  var animationDelays = (styles[animationProp + 'Delay'] || '').split(', ');\n  var animationDurations = (styles[animationProp + 'Duration'] || '').split(', ');\n  var animationTimeout = getTimeout(animationDelays, animationDurations);\n\n  var type;\n  var timeout = 0;\n  var propCount = 0;\n  /* istanbul ignore if */\n  if (expectedType === TRANSITION) {\n    if (transitionTimeout > 0) {\n      type = TRANSITION;\n      timeout = transitionTimeout;\n      propCount = transitionDurations.length;\n    }\n  } else if (expectedType === ANIMATION) {\n    if (animationTimeout > 0) {\n      type = ANIMATION;\n      timeout = animationTimeout;\n      propCount = animationDurations.length;\n    }\n  } else {\n    timeout = Math.max(transitionTimeout, animationTimeout);\n    type = timeout > 0\n      ? transitionTimeout > animationTimeout\n        ? TRANSITION\n        : ANIMATION\n      : null;\n    propCount = type\n      ? type === TRANSITION\n        ? transitionDurations.length\n        : animationDurations.length\n      : 0;\n  }\n  var hasTransform =\n    type === TRANSITION &&\n    transformRE.test(styles[transitionProp + 'Property']);\n  return {\n    type: type,\n    timeout: timeout,\n    propCount: propCount,\n    hasTransform: hasTransform\n  }\n}\n\nfunction getTimeout (delays, durations) {\n  /* istanbul ignore next */\n  while (delays.length < durations.length) {\n    delays = delays.concat(delays);\n  }\n\n  return Math.max.apply(null, durations.map(function (d, i) {\n    return toMs(d) + toMs(delays[i])\n  }))\n}\n\n// Old versions of Chromium (below 61.0.3163.100) formats floating pointer numbers\n// in a locale-dependent way, using a comma instead of a dot.\n// If comma is not replaced with a dot, the input will be rounded down (i.e. acting\n// as a floor function) causing unexpected behaviors\nfunction toMs (s) {\n  return Number(s.slice(0, -1).replace(',', '.')) * 1000\n}\n\n/*  */\n\nfunction enter (vnode, toggleDisplay) {\n  var el = vnode.elm;\n\n  // call leave callback now\n  if (isDef(el._leaveCb)) {\n    el._leaveCb.cancelled = true;\n    el._leaveCb();\n  }\n\n  var data = resolveTransition(vnode.data.transition);\n  if (isUndef(data)) {\n    return\n  }\n\n  /* istanbul ignore if */\n  if (isDef(el._enterCb) || el.nodeType !== 1) {\n    return\n  }\n\n  var css = data.css;\n  var type = data.type;\n  var enterClass = data.enterClass;\n  var enterToClass = data.enterToClass;\n  var enterActiveClass = data.enterActiveClass;\n  var appearClass = data.appearClass;\n  var appearToClass = data.appearToClass;\n  var appearActiveClass = data.appearActiveClass;\n  var beforeEnter = data.beforeEnter;\n  var enter = data.enter;\n  var afterEnter = data.afterEnter;\n  var enterCancelled = data.enterCancelled;\n  var beforeAppear = data.beforeAppear;\n  var appear = data.appear;\n  var afterAppear = data.afterAppear;\n  var appearCancelled = data.appearCancelled;\n  var duration = data.duration;\n\n  // activeInstance will always be the <transition> component managing this\n  // transition. One edge case to check is when the <transition> is placed\n  // as the root node of a child component. In that case we need to check\n  // <transition>'s parent for appear check.\n  var context = activeInstance;\n  var transitionNode = activeInstance.$vnode;\n  while (transitionNode && transitionNode.parent) {\n    context = transitionNode.context;\n    transitionNode = transitionNode.parent;\n  }\n\n  var isAppear = !context._isMounted || !vnode.isRootInsert;\n\n  if (isAppear && !appear && appear !== '') {\n    return\n  }\n\n  var startClass = isAppear && appearClass\n    ? appearClass\n    : enterClass;\n  var activeClass = isAppear && appearActiveClass\n    ? appearActiveClass\n    : enterActiveClass;\n  var toClass = isAppear && appearToClass\n    ? appearToClass\n    : enterToClass;\n\n  var beforeEnterHook = isAppear\n    ? (beforeAppear || beforeEnter)\n    : beforeEnter;\n  var enterHook = isAppear\n    ? (typeof appear === 'function' ? appear : enter)\n    : enter;\n  var afterEnterHook = isAppear\n    ? (afterAppear || afterEnter)\n    : afterEnter;\n  var enterCancelledHook = isAppear\n    ? (appearCancelled || enterCancelled)\n    : enterCancelled;\n\n  var explicitEnterDuration = toNumber(\n    isObject(duration)\n      ? duration.enter\n      : duration\n  );\n\n  if (process.env.NODE_ENV !== 'production' && explicitEnterDuration != null) {\n    checkDuration(explicitEnterDuration, 'enter', vnode);\n  }\n\n  var expectsCSS = css !== false && !isIE9;\n  var userWantsControl = getHookArgumentsLength(enterHook);\n\n  var cb = el._enterCb = once(function () {\n    if (expectsCSS) {\n      removeTransitionClass(el, toClass);\n      removeTransitionClass(el, activeClass);\n    }\n    if (cb.cancelled) {\n      if (expectsCSS) {\n        removeTransitionClass(el, startClass);\n      }\n      enterCancelledHook && enterCancelledHook(el);\n    } else {\n      afterEnterHook && afterEnterHook(el);\n    }\n    el._enterCb = null;\n  });\n\n  if (!vnode.data.show) {\n    // remove pending leave element on enter by injecting an insert hook\n    mergeVNodeHook(vnode, 'insert', function () {\n      var parent = el.parentNode;\n      var pendingNode = parent && parent._pending && parent._pending[vnode.key];\n      if (pendingNode &&\n        pendingNode.tag === vnode.tag &&\n        pendingNode.elm._leaveCb\n      ) {\n        pendingNode.elm._leaveCb();\n      }\n      enterHook && enterHook(el, cb);\n    });\n  }\n\n  // start enter transition\n  beforeEnterHook && beforeEnterHook(el);\n  if (expectsCSS) {\n    addTransitionClass(el, startClass);\n    addTransitionClass(el, activeClass);\n    nextFrame(function () {\n      removeTransitionClass(el, startClass);\n      if (!cb.cancelled) {\n        addTransitionClass(el, toClass);\n        if (!userWantsControl) {\n          if (isValidDuration(explicitEnterDuration)) {\n            setTimeout(cb, explicitEnterDuration);\n          } else {\n            whenTransitionEnds(el, type, cb);\n          }\n        }\n      }\n    });\n  }\n\n  if (vnode.data.show) {\n    toggleDisplay && toggleDisplay();\n    enterHook && enterHook(el, cb);\n  }\n\n  if (!expectsCSS && !userWantsControl) {\n    cb();\n  }\n}\n\nfunction leave (vnode, rm) {\n  var el = vnode.elm;\n\n  // call enter callback now\n  if (isDef(el._enterCb)) {\n    el._enterCb.cancelled = true;\n    el._enterCb();\n  }\n\n  var data = resolveTransition(vnode.data.transition);\n  if (isUndef(data) || el.nodeType !== 1) {\n    return rm()\n  }\n\n  /* istanbul ignore if */\n  if (isDef(el._leaveCb)) {\n    return\n  }\n\n  var css = data.css;\n  var type = data.type;\n  var leaveClass = data.leaveClass;\n  var leaveToClass = data.leaveToClass;\n  var leaveActiveClass = data.leaveActiveClass;\n  var beforeLeave = data.beforeLeave;\n  var leave = data.leave;\n  var afterLeave = data.afterLeave;\n  var leaveCancelled = data.leaveCancelled;\n  var delayLeave = data.delayLeave;\n  var duration = data.duration;\n\n  var expectsCSS = css !== false && !isIE9;\n  var userWantsControl = getHookArgumentsLength(leave);\n\n  var explicitLeaveDuration = toNumber(\n    isObject(duration)\n      ? duration.leave\n      : duration\n  );\n\n  if (process.env.NODE_ENV !== 'production' && isDef(explicitLeaveDuration)) {\n    checkDuration(explicitLeaveDuration, 'leave', vnode);\n  }\n\n  var cb = el._leaveCb = once(function () {\n    if (el.parentNode && el.parentNode._pending) {\n      el.parentNode._pending[vnode.key] = null;\n    }\n    if (expectsCSS) {\n      removeTransitionClass(el, leaveToClass);\n      removeTransitionClass(el, leaveActiveClass);\n    }\n    if (cb.cancelled) {\n      if (expectsCSS) {\n        removeTransitionClass(el, leaveClass);\n      }\n      leaveCancelled && leaveCancelled(el);\n    } else {\n      rm();\n      afterLeave && afterLeave(el);\n    }\n    el._leaveCb = null;\n  });\n\n  if (delayLeave) {\n    delayLeave(performLeave);\n  } else {\n    performLeave();\n  }\n\n  function performLeave () {\n    // the delayed leave may have already been cancelled\n    if (cb.cancelled) {\n      return\n    }\n    // record leaving element\n    if (!vnode.data.show && el.parentNode) {\n      (el.parentNode._pending || (el.parentNode._pending = {}))[(vnode.key)] = vnode;\n    }\n    beforeLeave && beforeLeave(el);\n    if (expectsCSS) {\n      addTransitionClass(el, leaveClass);\n      addTransitionClass(el, leaveActiveClass);\n      nextFrame(function () {\n        removeTransitionClass(el, leaveClass);\n        if (!cb.cancelled) {\n          addTransitionClass(el, leaveToClass);\n          if (!userWantsControl) {\n            if (isValidDuration(explicitLeaveDuration)) {\n              setTimeout(cb, explicitLeaveDuration);\n            } else {\n              whenTransitionEnds(el, type, cb);\n            }\n          }\n        }\n      });\n    }\n    leave && leave(el, cb);\n    if (!expectsCSS && !userWantsControl) {\n      cb();\n    }\n  }\n}\n\n// only used in dev mode\nfunction checkDuration (val, name, vnode) {\n  if (typeof val !== 'number') {\n    warn(\n      \"<transition> explicit \" + name + \" duration is not a valid number - \" +\n      \"got \" + (JSON.stringify(val)) + \".\",\n      vnode.context\n    );\n  } else if (isNaN(val)) {\n    warn(\n      \"<transition> explicit \" + name + \" duration is NaN - \" +\n      'the duration expression might be incorrect.',\n      vnode.context\n    );\n  }\n}\n\nfunction isValidDuration (val) {\n  return typeof val === 'number' && !isNaN(val)\n}\n\n/**\n * Normalize a transition hook's argument length. The hook may be:\n * - a merged hook (invoker) with the original in .fns\n * - a wrapped component method (check ._length)\n * - a plain function (.length)\n */\nfunction getHookArgumentsLength (fn) {\n  if (isUndef(fn)) {\n    return false\n  }\n  var invokerFns = fn.fns;\n  if (isDef(invokerFns)) {\n    // invoker\n    return getHookArgumentsLength(\n      Array.isArray(invokerFns)\n        ? invokerFns[0]\n        : invokerFns\n    )\n  } else {\n    return (fn._length || fn.length) > 1\n  }\n}\n\nfunction _enter (_, vnode) {\n  if (vnode.data.show !== true) {\n    enter(vnode);\n  }\n}\n\nvar transition = inBrowser ? {\n  create: _enter,\n  activate: _enter,\n  remove: function remove$$1 (vnode, rm) {\n    /* istanbul ignore else */\n    if (vnode.data.show !== true) {\n      leave(vnode, rm);\n    } else {\n      rm();\n    }\n  }\n} : {};\n\nvar platformModules = [\n  attrs,\n  klass,\n  events,\n  domProps,\n  style,\n  transition\n];\n\n/*  */\n\n// the directive module should be applied last, after all\n// built-in modules have been applied.\nvar modules = platformModules.concat(baseModules);\n\nvar patch = createPatchFunction({ nodeOps: nodeOps, modules: modules });\n\n/**\n * Not type checking this file because flow doesn't like attaching\n * properties to Elements.\n */\n\n/* istanbul ignore if */\nif (isIE9) {\n  // http://www.matts411.com/post/internet-explorer-9-oninput/\n  document.addEventListener('selectionchange', function () {\n    var el = document.activeElement;\n    if (el && el.vmodel) {\n      trigger(el, 'input');\n    }\n  });\n}\n\nvar directive = {\n  inserted: function inserted (el, binding, vnode, oldVnode) {\n    if (vnode.tag === 'select') {\n      // #6903\n      if (oldVnode.elm && !oldVnode.elm._vOptions) {\n        mergeVNodeHook(vnode, 'postpatch', function () {\n          directive.componentUpdated(el, binding, vnode);\n        });\n      } else {\n        setSelected(el, binding, vnode.context);\n      }\n      el._vOptions = [].map.call(el.options, getValue);\n    } else if (vnode.tag === 'textarea' || isTextInputType(el.type)) {\n      el._vModifiers = binding.modifiers;\n      if (!binding.modifiers.lazy) {\n        el.addEventListener('compositionstart', onCompositionStart);\n        el.addEventListener('compositionend', onCompositionEnd);\n        // Safari < 10.2 & UIWebView doesn't fire compositionend when\n        // switching focus before confirming composition choice\n        // this also fixes the issue where some browsers e.g. iOS Chrome\n        // fires \"change\" instead of \"input\" on autocomplete.\n        el.addEventListener('change', onCompositionEnd);\n        /* istanbul ignore if */\n        if (isIE9) {\n          el.vmodel = true;\n        }\n      }\n    }\n  },\n\n  componentUpdated: function componentUpdated (el, binding, vnode) {\n    if (vnode.tag === 'select') {\n      setSelected(el, binding, vnode.context);\n      // in case the options rendered by v-for have changed,\n      // it's possible that the value is out-of-sync with the rendered options.\n      // detect such cases and filter out values that no longer has a matching\n      // option in the DOM.\n      var prevOptions = el._vOptions;\n      var curOptions = el._vOptions = [].map.call(el.options, getValue);\n      if (curOptions.some(function (o, i) { return !looseEqual(o, prevOptions[i]); })) {\n        // trigger change event if\n        // no matching option found for at least one value\n        var needReset = el.multiple\n          ? binding.value.some(function (v) { return hasNoMatchingOption(v, curOptions); })\n          : binding.value !== binding.oldValue && hasNoMatchingOption(binding.value, curOptions);\n        if (needReset) {\n          trigger(el, 'change');\n        }\n      }\n    }\n  }\n};\n\nfunction setSelected (el, binding, vm) {\n  actuallySetSelected(el, binding, vm);\n  /* istanbul ignore if */\n  if (isIE || isEdge) {\n    setTimeout(function () {\n      actuallySetSelected(el, binding, vm);\n    }, 0);\n  }\n}\n\nfunction actuallySetSelected (el, binding, vm) {\n  var value = binding.value;\n  var isMultiple = el.multiple;\n  if (isMultiple && !Array.isArray(value)) {\n    process.env.NODE_ENV !== 'production' && warn(\n      \"<select multiple v-model=\\\"\" + (binding.expression) + \"\\\"> \" +\n      \"expects an Array value for its binding, but got \" + (Object.prototype.toString.call(value).slice(8, -1)),\n      vm\n    );\n    return\n  }\n  var selected, option;\n  for (var i = 0, l = el.options.length; i < l; i++) {\n    option = el.options[i];\n    if (isMultiple) {\n      selected = looseIndexOf(value, getValue(option)) > -1;\n      if (option.selected !== selected) {\n        option.selected = selected;\n      }\n    } else {\n      if (looseEqual(getValue(option), value)) {\n        if (el.selectedIndex !== i) {\n          el.selectedIndex = i;\n        }\n        return\n      }\n    }\n  }\n  if (!isMultiple) {\n    el.selectedIndex = -1;\n  }\n}\n\nfunction hasNoMatchingOption (value, options) {\n  return options.every(function (o) { return !looseEqual(o, value); })\n}\n\nfunction getValue (option) {\n  return '_value' in option\n    ? option._value\n    : option.value\n}\n\nfunction onCompositionStart (e) {\n  e.target.composing = true;\n}\n\nfunction onCompositionEnd (e) {\n  // prevent triggering an input event for no reason\n  if (!e.target.composing) { return }\n  e.target.composing = false;\n  trigger(e.target, 'input');\n}\n\nfunction trigger (el, type) {\n  var e = document.createEvent('HTMLEvents');\n  e.initEvent(type, true, true);\n  el.dispatchEvent(e);\n}\n\n/*  */\n\n// recursively search for possible transition defined inside the component root\nfunction locateNode (vnode) {\n  return vnode.componentInstance && (!vnode.data || !vnode.data.transition)\n    ? locateNode(vnode.componentInstance._vnode)\n    : vnode\n}\n\nvar show = {\n  bind: function bind (el, ref, vnode) {\n    var value = ref.value;\n\n    vnode = locateNode(vnode);\n    var transition$$1 = vnode.data && vnode.data.transition;\n    var originalDisplay = el.__vOriginalDisplay =\n      el.style.display === 'none' ? '' : el.style.display;\n    if (value && transition$$1) {\n      vnode.data.show = true;\n      enter(vnode, function () {\n        el.style.display = originalDisplay;\n      });\n    } else {\n      el.style.display = value ? originalDisplay : 'none';\n    }\n  },\n\n  update: function update (el, ref, vnode) {\n    var value = ref.value;\n    var oldValue = ref.oldValue;\n\n    /* istanbul ignore if */\n    if (!value === !oldValue) { return }\n    vnode = locateNode(vnode);\n    var transition$$1 = vnode.data && vnode.data.transition;\n    if (transition$$1) {\n      vnode.data.show = true;\n      if (value) {\n        enter(vnode, function () {\n          el.style.display = el.__vOriginalDisplay;\n        });\n      } else {\n        leave(vnode, function () {\n          el.style.display = 'none';\n        });\n      }\n    } else {\n      el.style.display = value ? el.__vOriginalDisplay : 'none';\n    }\n  },\n\n  unbind: function unbind (\n    el,\n    binding,\n    vnode,\n    oldVnode,\n    isDestroy\n  ) {\n    if (!isDestroy) {\n      el.style.display = el.__vOriginalDisplay;\n    }\n  }\n};\n\nvar platformDirectives = {\n  model: directive,\n  show: show\n};\n\n/*  */\n\nvar transitionProps = {\n  name: String,\n  appear: Boolean,\n  css: Boolean,\n  mode: String,\n  type: String,\n  enterClass: String,\n  leaveClass: String,\n  enterToClass: String,\n  leaveToClass: String,\n  enterActiveClass: String,\n  leaveActiveClass: String,\n  appearClass: String,\n  appearActiveClass: String,\n  appearToClass: String,\n  duration: [Number, String, Object]\n};\n\n// in case the child is also an abstract component, e.g. <keep-alive>\n// we want to recursively retrieve the real component to be rendered\nfunction getRealChild (vnode) {\n  var compOptions = vnode && vnode.componentOptions;\n  if (compOptions && compOptions.Ctor.options.abstract) {\n    return getRealChild(getFirstComponentChild(compOptions.children))\n  } else {\n    return vnode\n  }\n}\n\nfunction extractTransitionData (comp) {\n  var data = {};\n  var options = comp.$options;\n  // props\n  for (var key in options.propsData) {\n    data[key] = comp[key];\n  }\n  // events.\n  // extract listeners and pass them directly to the transition methods\n  var listeners = options._parentListeners;\n  for (var key$1 in listeners) {\n    data[camelize(key$1)] = listeners[key$1];\n  }\n  return data\n}\n\nfunction placeholder (h, rawChild) {\n  if (/\\d-keep-alive$/.test(rawChild.tag)) {\n    return h('keep-alive', {\n      props: rawChild.componentOptions.propsData\n    })\n  }\n}\n\nfunction hasParentTransition (vnode) {\n  while ((vnode = vnode.parent)) {\n    if (vnode.data.transition) {\n      return true\n    }\n  }\n}\n\nfunction isSameChild (child, oldChild) {\n  return oldChild.key === child.key && oldChild.tag === child.tag\n}\n\nvar isNotTextNode = function (c) { return c.tag || isAsyncPlaceholder(c); };\n\nvar isVShowDirective = function (d) { return d.name === 'show'; };\n\nvar Transition = {\n  name: 'transition',\n  props: transitionProps,\n  abstract: true,\n\n  render: function render (h) {\n    var this$1 = this;\n\n    var children = this.$slots.default;\n    if (!children) {\n      return\n    }\n\n    // filter out text nodes (possible whitespaces)\n    children = children.filter(isNotTextNode);\n    /* istanbul ignore if */\n    if (!children.length) {\n      return\n    }\n\n    // warn multiple elements\n    if (process.env.NODE_ENV !== 'production' && children.length > 1) {\n      warn(\n        '<transition> can only be used on a single element. Use ' +\n        '<transition-group> for lists.',\n        this.$parent\n      );\n    }\n\n    var mode = this.mode;\n\n    // warn invalid mode\n    if (process.env.NODE_ENV !== 'production' &&\n      mode && mode !== 'in-out' && mode !== 'out-in'\n    ) {\n      warn(\n        'invalid <transition> mode: ' + mode,\n        this.$parent\n      );\n    }\n\n    var rawChild = children[0];\n\n    // if this is a component root node and the component's\n    // parent container node also has transition, skip.\n    if (hasParentTransition(this.$vnode)) {\n      return rawChild\n    }\n\n    // apply transition data to child\n    // use getRealChild() to ignore abstract components e.g. keep-alive\n    var child = getRealChild(rawChild);\n    /* istanbul ignore if */\n    if (!child) {\n      return rawChild\n    }\n\n    if (this._leaving) {\n      return placeholder(h, rawChild)\n    }\n\n    // ensure a key that is unique to the vnode type and to this transition\n    // component instance. This key will be used to remove pending leaving nodes\n    // during entering.\n    var id = \"__transition-\" + (this._uid) + \"-\";\n    child.key = child.key == null\n      ? child.isComment\n        ? id + 'comment'\n        : id + child.tag\n      : isPrimitive(child.key)\n        ? (String(child.key).indexOf(id) === 0 ? child.key : id + child.key)\n        : child.key;\n\n    var data = (child.data || (child.data = {})).transition = extractTransitionData(this);\n    var oldRawChild = this._vnode;\n    var oldChild = getRealChild(oldRawChild);\n\n    // mark v-show\n    // so that the transition module can hand over the control to the directive\n    if (child.data.directives && child.data.directives.some(isVShowDirective)) {\n      child.data.show = true;\n    }\n\n    if (\n      oldChild &&\n      oldChild.data &&\n      !isSameChild(child, oldChild) &&\n      !isAsyncPlaceholder(oldChild) &&\n      // #6687 component root is a comment node\n      !(oldChild.componentInstance && oldChild.componentInstance._vnode.isComment)\n    ) {\n      // replace old child transition data with fresh one\n      // important for dynamic transitions!\n      var oldData = oldChild.data.transition = extend({}, data);\n      // handle transition mode\n      if (mode === 'out-in') {\n        // return placeholder node and queue update when leave finishes\n        this._leaving = true;\n        mergeVNodeHook(oldData, 'afterLeave', function () {\n          this$1._leaving = false;\n          this$1.$forceUpdate();\n        });\n        return placeholder(h, rawChild)\n      } else if (mode === 'in-out') {\n        if (isAsyncPlaceholder(child)) {\n          return oldRawChild\n        }\n        var delayedLeave;\n        var performLeave = function () { delayedLeave(); };\n        mergeVNodeHook(data, 'afterEnter', performLeave);\n        mergeVNodeHook(data, 'enterCancelled', performLeave);\n        mergeVNodeHook(oldData, 'delayLeave', function (leave) { delayedLeave = leave; });\n      }\n    }\n\n    return rawChild\n  }\n};\n\n/*  */\n\nvar props = extend({\n  tag: String,\n  moveClass: String\n}, transitionProps);\n\ndelete props.mode;\n\nvar TransitionGroup = {\n  props: props,\n\n  beforeMount: function beforeMount () {\n    var this$1 = this;\n\n    var update = this._update;\n    this._update = function (vnode, hydrating) {\n      var restoreActiveInstance = setActiveInstance(this$1);\n      // force removing pass\n      this$1.__patch__(\n        this$1._vnode,\n        this$1.kept,\n        false, // hydrating\n        true // removeOnly (!important, avoids unnecessary moves)\n      );\n      this$1._vnode = this$1.kept;\n      restoreActiveInstance();\n      update.call(this$1, vnode, hydrating);\n    };\n  },\n\n  render: function render (h) {\n    var tag = this.tag || this.$vnode.data.tag || 'span';\n    var map = Object.create(null);\n    var prevChildren = this.prevChildren = this.children;\n    var rawChildren = this.$slots.default || [];\n    var children = this.children = [];\n    var transitionData = extractTransitionData(this);\n\n    for (var i = 0; i < rawChildren.length; i++) {\n      var c = rawChildren[i];\n      if (c.tag) {\n        if (c.key != null && String(c.key).indexOf('__vlist') !== 0) {\n          children.push(c);\n          map[c.key] = c\n          ;(c.data || (c.data = {})).transition = transitionData;\n        } else if (process.env.NODE_ENV !== 'production') {\n          var opts = c.componentOptions;\n          var name = opts ? (opts.Ctor.options.name || opts.tag || '') : c.tag;\n          warn((\"<transition-group> children must be keyed: <\" + name + \">\"));\n        }\n      }\n    }\n\n    if (prevChildren) {\n      var kept = [];\n      var removed = [];\n      for (var i$1 = 0; i$1 < prevChildren.length; i$1++) {\n        var c$1 = prevChildren[i$1];\n        c$1.data.transition = transitionData;\n        c$1.data.pos = c$1.elm.getBoundingClientRect();\n        if (map[c$1.key]) {\n          kept.push(c$1);\n        } else {\n          removed.push(c$1);\n        }\n      }\n      this.kept = h(tag, null, kept);\n      this.removed = removed;\n    }\n\n    return h(tag, null, children)\n  },\n\n  updated: function updated () {\n    var children = this.prevChildren;\n    var moveClass = this.moveClass || ((this.name || 'v') + '-move');\n    if (!children.length || !this.hasMove(children[0].elm, moveClass)) {\n      return\n    }\n\n    // we divide the work into three loops to avoid mixing DOM reads and writes\n    // in each iteration - which helps prevent layout thrashing.\n    children.forEach(callPendingCbs);\n    children.forEach(recordPosition);\n    children.forEach(applyTranslation);\n\n    // force reflow to put everything in position\n    // assign to this to avoid being removed in tree-shaking\n    // $flow-disable-line\n    this._reflow = document.body.offsetHeight;\n\n    children.forEach(function (c) {\n      if (c.data.moved) {\n        var el = c.elm;\n        var s = el.style;\n        addTransitionClass(el, moveClass);\n        s.transform = s.WebkitTransform = s.transitionDuration = '';\n        el.addEventListener(transitionEndEvent, el._moveCb = function cb (e) {\n          if (e && e.target !== el) {\n            return\n          }\n          if (!e || /transform$/.test(e.propertyName)) {\n            el.removeEventListener(transitionEndEvent, cb);\n            el._moveCb = null;\n            removeTransitionClass(el, moveClass);\n          }\n        });\n      }\n    });\n  },\n\n  methods: {\n    hasMove: function hasMove (el, moveClass) {\n      /* istanbul ignore if */\n      if (!hasTransition) {\n        return false\n      }\n      /* istanbul ignore if */\n      if (this._hasMove) {\n        return this._hasMove\n      }\n      // Detect whether an element with the move class applied has\n      // CSS transitions. Since the element may be inside an entering\n      // transition at this very moment, we make a clone of it and remove\n      // all other transition classes applied to ensure only the move class\n      // is applied.\n      var clone = el.cloneNode();\n      if (el._transitionClasses) {\n        el._transitionClasses.forEach(function (cls) { removeClass(clone, cls); });\n      }\n      addClass(clone, moveClass);\n      clone.style.display = 'none';\n      this.$el.appendChild(clone);\n      var info = getTransitionInfo(clone);\n      this.$el.removeChild(clone);\n      return (this._hasMove = info.hasTransform)\n    }\n  }\n};\n\nfunction callPendingCbs (c) {\n  /* istanbul ignore if */\n  if (c.elm._moveCb) {\n    c.elm._moveCb();\n  }\n  /* istanbul ignore if */\n  if (c.elm._enterCb) {\n    c.elm._enterCb();\n  }\n}\n\nfunction recordPosition (c) {\n  c.data.newPos = c.elm.getBoundingClientRect();\n}\n\nfunction applyTranslation (c) {\n  var oldPos = c.data.pos;\n  var newPos = c.data.newPos;\n  var dx = oldPos.left - newPos.left;\n  var dy = oldPos.top - newPos.top;\n  if (dx || dy) {\n    c.data.moved = true;\n    var s = c.elm.style;\n    s.transform = s.WebkitTransform = \"translate(\" + dx + \"px,\" + dy + \"px)\";\n    s.transitionDuration = '0s';\n  }\n}\n\nvar platformComponents = {\n  Transition: Transition,\n  TransitionGroup: TransitionGroup\n};\n\n/*  */\n\n// install platform specific utils\nVue.config.mustUseProp = mustUseProp;\nVue.config.isReservedTag = isReservedTag;\nVue.config.isReservedAttr = isReservedAttr;\nVue.config.getTagNamespace = getTagNamespace;\nVue.config.isUnknownElement = isUnknownElement;\n\n// install platform runtime directives & components\nextend(Vue.options.directives, platformDirectives);\nextend(Vue.options.components, platformComponents);\n\n// install platform patch function\nVue.prototype.__patch__ = inBrowser ? patch : noop;\n\n// public mount method\nVue.prototype.$mount = function (\n  el,\n  hydrating\n) {\n  el = el && inBrowser ? query(el) : undefined;\n  return mountComponent(this, el, hydrating)\n};\n\n// devtools global hook\n/* istanbul ignore next */\nif (inBrowser) {\n  setTimeout(function () {\n    if (config.devtools) {\n      if (devtools) {\n        devtools.emit('init', Vue);\n      } else if (\n        process.env.NODE_ENV !== 'production' &&\n        process.env.NODE_ENV !== 'test'\n      ) {\n        console[console.info ? 'info' : 'log'](\n          'Download the Vue Devtools extension for a better development experience:\\n' +\n          'https://github.com/vuejs/vue-devtools'\n        );\n      }\n    }\n    if (process.env.NODE_ENV !== 'production' &&\n      process.env.NODE_ENV !== 'test' &&\n      config.productionTip !== false &&\n      typeof console !== 'undefined'\n    ) {\n      console[console.info ? 'info' : 'log'](\n        \"You are running Vue in development mode.\\n\" +\n        \"Make sure to turn on production mode when deploying for production.\\n\" +\n        \"See more tips at https://vuejs.org/guide/deployment.html\"\n      );\n    }\n  }, 0);\n}\n\n/*  */\n\nvar defaultTagRE = /\\{\\{((?:.|\\r?\\n)+?)\\}\\}/g;\nvar regexEscapeRE = /[-.*+?^${}()|[\\]\\/\\\\]/g;\n\nvar buildRegex = cached(function (delimiters) {\n  var open = delimiters[0].replace(regexEscapeRE, '\\\\$&');\n  var close = delimiters[1].replace(regexEscapeRE, '\\\\$&');\n  return new RegExp(open + '((?:.|\\\\n)+?)' + close, 'g')\n});\n\n\n\nfunction parseText (\n  text,\n  delimiters\n) {\n  var tagRE = delimiters ? buildRegex(delimiters) : defaultTagRE;\n  if (!tagRE.test(text)) {\n    return\n  }\n  var tokens = [];\n  var rawTokens = [];\n  var lastIndex = tagRE.lastIndex = 0;\n  var match, index, tokenValue;\n  while ((match = tagRE.exec(text))) {\n    index = match.index;\n    // push text token\n    if (index > lastIndex) {\n      rawTokens.push(tokenValue = text.slice(lastIndex, index));\n      tokens.push(JSON.stringify(tokenValue));\n    }\n    // tag token\n    var exp = parseFilters(match[1].trim());\n    tokens.push((\"_s(\" + exp + \")\"));\n    rawTokens.push({ '@binding': exp });\n    lastIndex = index + match[0].length;\n  }\n  if (lastIndex < text.length) {\n    rawTokens.push(tokenValue = text.slice(lastIndex));\n    tokens.push(JSON.stringify(tokenValue));\n  }\n  return {\n    expression: tokens.join('+'),\n    tokens: rawTokens\n  }\n}\n\n/*  */\n\nfunction transformNode (el, options) {\n  var warn = options.warn || baseWarn;\n  var staticClass = getAndRemoveAttr(el, 'class');\n  if (process.env.NODE_ENV !== 'production' && staticClass) {\n    var res = parseText(staticClass, options.delimiters);\n    if (res) {\n      warn(\n        \"class=\\\"\" + staticClass + \"\\\": \" +\n        'Interpolation inside attributes has been removed. ' +\n        'Use v-bind or the colon shorthand instead. For example, ' +\n        'instead of <div class=\"{{ val }}\">, use <div :class=\"val\">.',\n        el.rawAttrsMap['class']\n      );\n    }\n  }\n  if (staticClass) {\n    el.staticClass = JSON.stringify(staticClass);\n  }\n  var classBinding = getBindingAttr(el, 'class', false /* getStatic */);\n  if (classBinding) {\n    el.classBinding = classBinding;\n  }\n}\n\nfunction genData (el) {\n  var data = '';\n  if (el.staticClass) {\n    data += \"staticClass:\" + (el.staticClass) + \",\";\n  }\n  if (el.classBinding) {\n    data += \"class:\" + (el.classBinding) + \",\";\n  }\n  return data\n}\n\nvar klass$1 = {\n  staticKeys: ['staticClass'],\n  transformNode: transformNode,\n  genData: genData\n};\n\n/*  */\n\nfunction transformNode$1 (el, options) {\n  var warn = options.warn || baseWarn;\n  var staticStyle = getAndRemoveAttr(el, 'style');\n  if (staticStyle) {\n    /* istanbul ignore if */\n    if (process.env.NODE_ENV !== 'production') {\n      var res = parseText(staticStyle, options.delimiters);\n      if (res) {\n        warn(\n          \"style=\\\"\" + staticStyle + \"\\\": \" +\n          'Interpolation inside attributes has been removed. ' +\n          'Use v-bind or the colon shorthand instead. For example, ' +\n          'instead of <div style=\"{{ val }}\">, use <div :style=\"val\">.',\n          el.rawAttrsMap['style']\n        );\n      }\n    }\n    el.staticStyle = JSON.stringify(parseStyleText(staticStyle));\n  }\n\n  var styleBinding = getBindingAttr(el, 'style', false /* getStatic */);\n  if (styleBinding) {\n    el.styleBinding = styleBinding;\n  }\n}\n\nfunction genData$1 (el) {\n  var data = '';\n  if (el.staticStyle) {\n    data += \"staticStyle:\" + (el.staticStyle) + \",\";\n  }\n  if (el.styleBinding) {\n    data += \"style:(\" + (el.styleBinding) + \"),\";\n  }\n  return data\n}\n\nvar style$1 = {\n  staticKeys: ['staticStyle'],\n  transformNode: transformNode$1,\n  genData: genData$1\n};\n\n/*  */\n\nvar decoder;\n\nvar he = {\n  decode: function decode (html) {\n    decoder = decoder || document.createElement('div');\n    decoder.innerHTML = html;\n    return decoder.textContent\n  }\n};\n\n/*  */\n\nvar isUnaryTag = makeMap(\n  'area,base,br,col,embed,frame,hr,img,input,isindex,keygen,' +\n  'link,meta,param,source,track,wbr'\n);\n\n// Elements that you can, intentionally, leave open\n// (and which close themselves)\nvar canBeLeftOpenTag = makeMap(\n  'colgroup,dd,dt,li,options,p,td,tfoot,th,thead,tr,source'\n);\n\n// HTML5 tags https://html.spec.whatwg.org/multipage/indices.html#elements-3\n// Phrasing Content https://html.spec.whatwg.org/multipage/dom.html#phrasing-content\nvar isNonPhrasingTag = makeMap(\n  'address,article,aside,base,blockquote,body,caption,col,colgroup,dd,' +\n  'details,dialog,div,dl,dt,fieldset,figcaption,figure,footer,form,' +\n  'h1,h2,h3,h4,h5,h6,head,header,hgroup,hr,html,legend,li,menuitem,meta,' +\n  'optgroup,option,param,rp,rt,source,style,summary,tbody,td,tfoot,th,thead,' +\n  'title,tr,track'\n);\n\n/**\n * Not type-checking this file because it's mostly vendor code.\n */\n\n// Regular Expressions for parsing tags and attributes\nvar attribute = /^\\s*([^\\s\"'<>\\/=]+)(?:\\s*(=)\\s*(?:\"([^\"]*)\"+|'([^']*)'+|([^\\s\"'=<>`]+)))?/;\nvar dynamicArgAttribute = /^\\s*((?:v-[\\w-]+:|@|:|#)\\[[^=]+\\][^\\s\"'<>\\/=]*)(?:\\s*(=)\\s*(?:\"([^\"]*)\"+|'([^']*)'+|([^\\s\"'=<>`]+)))?/;\nvar ncname = \"[a-zA-Z_][\\\\-\\\\.0-9_a-zA-Z\" + (unicodeRegExp.source) + \"]*\";\nvar qnameCapture = \"((?:\" + ncname + \"\\\\:)?\" + ncname + \")\";\nvar startTagOpen = new RegExp((\"^<\" + qnameCapture));\nvar startTagClose = /^\\s*(\\/?)>/;\nvar endTag = new RegExp((\"^<\\\\/\" + qnameCapture + \"[^>]*>\"));\nvar doctype = /^<!DOCTYPE [^>]+>/i;\n// #7298: escape - to avoid being pased as HTML comment when inlined in page\nvar comment = /^<!\\--/;\nvar conditionalComment = /^<!\\[/;\n\n// Special Elements (can contain anything)\nvar isPlainTextElement = makeMap('script,style,textarea', true);\nvar reCache = {};\n\nvar decodingMap = {\n  '&lt;': '<',\n  '&gt;': '>',\n  '&quot;': '\"',\n  '&amp;': '&',\n  '&#10;': '\\n',\n  '&#9;': '\\t',\n  '&#39;': \"'\"\n};\nvar encodedAttr = /&(?:lt|gt|quot|amp|#39);/g;\nvar encodedAttrWithNewLines = /&(?:lt|gt|quot|amp|#39|#10|#9);/g;\n\n// #5992\nvar isIgnoreNewlineTag = makeMap('pre,textarea', true);\nvar shouldIgnoreFirstNewline = function (tag, html) { return tag && isIgnoreNewlineTag(tag) && html[0] === '\\n'; };\n\nfunction decodeAttr (value, shouldDecodeNewlines) {\n  var re = shouldDecodeNewlines ? encodedAttrWithNewLines : encodedAttr;\n  return value.replace(re, function (match) { return decodingMap[match]; })\n}\n\nfunction parseHTML (html, options) {\n  var stack = [];\n  var expectHTML = options.expectHTML;\n  var isUnaryTag$$1 = options.isUnaryTag || no;\n  var canBeLeftOpenTag$$1 = options.canBeLeftOpenTag || no;\n  var index = 0;\n  var last, lastTag;\n  while (html) {\n    last = html;\n    // Make sure we're not in a plaintext content element like script/style\n    if (!lastTag || !isPlainTextElement(lastTag)) {\n      var textEnd = html.indexOf('<');\n      if (textEnd === 0) {\n        // Comment:\n        if (comment.test(html)) {\n          var commentEnd = html.indexOf('-->');\n\n          if (commentEnd >= 0) {\n            if (options.shouldKeepComment) {\n              options.comment(html.substring(4, commentEnd), index, index + commentEnd + 3);\n            }\n            advance(commentEnd + 3);\n            continue\n          }\n        }\n\n        // http://en.wikipedia.org/wiki/Conditional_comment#Downlevel-revealed_conditional_comment\n        if (conditionalComment.test(html)) {\n          var conditionalEnd = html.indexOf(']>');\n\n          if (conditionalEnd >= 0) {\n            advance(conditionalEnd + 2);\n            continue\n          }\n        }\n\n        // Doctype:\n        var doctypeMatch = html.match(doctype);\n        if (doctypeMatch) {\n          advance(doctypeMatch[0].length);\n          continue\n        }\n\n        // End tag:\n        var endTagMatch = html.match(endTag);\n        if (endTagMatch) {\n          var curIndex = index;\n          advance(endTagMatch[0].length);\n          parseEndTag(endTagMatch[1], curIndex, index);\n          continue\n        }\n\n        // Start tag:\n        var startTagMatch = parseStartTag();\n        if (startTagMatch) {\n          handleStartTag(startTagMatch);\n          if (shouldIgnoreFirstNewline(startTagMatch.tagName, html)) {\n            advance(1);\n          }\n          continue\n        }\n      }\n\n      var text = (void 0), rest = (void 0), next = (void 0);\n      if (textEnd >= 0) {\n        rest = html.slice(textEnd);\n        while (\n          !endTag.test(rest) &&\n          !startTagOpen.test(rest) &&\n          !comment.test(rest) &&\n          !conditionalComment.test(rest)\n        ) {\n          // < in plain text, be forgiving and treat it as text\n          next = rest.indexOf('<', 1);\n          if (next < 0) { break }\n          textEnd += next;\n          rest = html.slice(textEnd);\n        }\n        text = html.substring(0, textEnd);\n      }\n\n      if (textEnd < 0) {\n        text = html;\n      }\n\n      if (text) {\n        advance(text.length);\n      }\n\n      if (options.chars && text) {\n        options.chars(text, index - text.length, index);\n      }\n    } else {\n      var endTagLength = 0;\n      var stackedTag = lastTag.toLowerCase();\n      var reStackedTag = reCache[stackedTag] || (reCache[stackedTag] = new RegExp('([\\\\s\\\\S]*?)(</' + stackedTag + '[^>]*>)', 'i'));\n      var rest$1 = html.replace(reStackedTag, function (all, text, endTag) {\n        endTagLength = endTag.length;\n        if (!isPlainTextElement(stackedTag) && stackedTag !== 'noscript') {\n          text = text\n            .replace(/<!\\--([\\s\\S]*?)-->/g, '$1') // #7298\n            .replace(/<!\\[CDATA\\[([\\s\\S]*?)]]>/g, '$1');\n        }\n        if (shouldIgnoreFirstNewline(stackedTag, text)) {\n          text = text.slice(1);\n        }\n        if (options.chars) {\n          options.chars(text);\n        }\n        return ''\n      });\n      index += html.length - rest$1.length;\n      html = rest$1;\n      parseEndTag(stackedTag, index - endTagLength, index);\n    }\n\n    if (html === last) {\n      options.chars && options.chars(html);\n      if (process.env.NODE_ENV !== 'production' && !stack.length && options.warn) {\n        options.warn((\"Mal-formatted tag at end of template: \\\"\" + html + \"\\\"\"), { start: index + html.length });\n      }\n      break\n    }\n  }\n\n  // Clean up any remaining tags\n  parseEndTag();\n\n  function advance (n) {\n    index += n;\n    html = html.substring(n);\n  }\n\n  function parseStartTag () {\n    var start = html.match(startTagOpen);\n    if (start) {\n      var match = {\n        tagName: start[1],\n        attrs: [],\n        start: index\n      };\n      advance(start[0].length);\n      var end, attr;\n      while (!(end = html.match(startTagClose)) && (attr = html.match(dynamicArgAttribute) || html.match(attribute))) {\n        attr.start = index;\n        advance(attr[0].length);\n        attr.end = index;\n        match.attrs.push(attr);\n      }\n      if (end) {\n        match.unarySlash = end[1];\n        advance(end[0].length);\n        match.end = index;\n        return match\n      }\n    }\n  }\n\n  function handleStartTag (match) {\n    var tagName = match.tagName;\n    var unarySlash = match.unarySlash;\n\n    if (expectHTML) {\n      if (lastTag === 'p' && isNonPhrasingTag(tagName)) {\n        parseEndTag(lastTag);\n      }\n      if (canBeLeftOpenTag$$1(tagName) && lastTag === tagName) {\n        parseEndTag(tagName);\n      }\n    }\n\n    var unary = isUnaryTag$$1(tagName) || !!unarySlash;\n\n    var l = match.attrs.length;\n    var attrs = new Array(l);\n    for (var i = 0; i < l; i++) {\n      var args = match.attrs[i];\n      var value = args[3] || args[4] || args[5] || '';\n      var shouldDecodeNewlines = tagName === 'a' && args[1] === 'href'\n        ? options.shouldDecodeNewlinesForHref\n        : options.shouldDecodeNewlines;\n      attrs[i] = {\n        name: args[1],\n        value: decodeAttr(value, shouldDecodeNewlines)\n      };\n      if (process.env.NODE_ENV !== 'production' && options.outputSourceRange) {\n        attrs[i].start = args.start + args[0].match(/^\\s*/).length;\n        attrs[i].end = args.end;\n      }\n    }\n\n    if (!unary) {\n      stack.push({ tag: tagName, lowerCasedTag: tagName.toLowerCase(), attrs: attrs, start: match.start, end: match.end });\n      lastTag = tagName;\n    }\n\n    if (options.start) {\n      options.start(tagName, attrs, unary, match.start, match.end);\n    }\n  }\n\n  function parseEndTag (tagName, start, end) {\n    var pos, lowerCasedTagName;\n    if (start == null) { start = index; }\n    if (end == null) { end = index; }\n\n    // Find the closest opened tag of the same type\n    if (tagName) {\n      lowerCasedTagName = tagName.toLowerCase();\n      for (pos = stack.length - 1; pos >= 0; pos--) {\n        if (stack[pos].lowerCasedTag === lowerCasedTagName) {\n          break\n        }\n      }\n    } else {\n      // If no tag name is provided, clean shop\n      pos = 0;\n    }\n\n    if (pos >= 0) {\n      // Close all the open elements, up the stack\n      for (var i = stack.length - 1; i >= pos; i--) {\n        if (process.env.NODE_ENV !== 'production' &&\n          (i > pos || !tagName) &&\n          options.warn\n        ) {\n          options.warn(\n            (\"tag <\" + (stack[i].tag) + \"> has no matching end tag.\"),\n            { start: stack[i].start, end: stack[i].end }\n          );\n        }\n        if (options.end) {\n          options.end(stack[i].tag, start, end);\n        }\n      }\n\n      // Remove the open elements from the stack\n      stack.length = pos;\n      lastTag = pos && stack[pos - 1].tag;\n    } else if (lowerCasedTagName === 'br') {\n      if (options.start) {\n        options.start(tagName, [], true, start, end);\n      }\n    } else if (lowerCasedTagName === 'p') {\n      if (options.start) {\n        options.start(tagName, [], false, start, end);\n      }\n      if (options.end) {\n        options.end(tagName, start, end);\n      }\n    }\n  }\n}\n\n/*  */\n\nvar onRE = /^@|^v-on:/;\nvar dirRE = /^v-|^@|^:/;\nvar forAliasRE = /([\\s\\S]*?)\\s+(?:in|of)\\s+([\\s\\S]*)/;\nvar forIteratorRE = /,([^,\\}\\]]*)(?:,([^,\\}\\]]*))?$/;\nvar stripParensRE = /^\\(|\\)$/g;\nvar dynamicArgRE = /^\\[.*\\]$/;\n\nvar argRE = /:(.*)$/;\nvar bindRE = /^:|^\\.|^v-bind:/;\nvar modifierRE = /\\.[^.\\]]+(?=[^\\]]*$)/g;\n\nvar slotRE = /^v-slot(:|$)|^#/;\n\nvar lineBreakRE = /[\\r\\n]/;\nvar whitespaceRE$1 = /\\s+/g;\n\nvar invalidAttributeRE = /[\\s\"'<>\\/=]/;\n\nvar decodeHTMLCached = cached(he.decode);\n\nvar emptySlotScopeToken = \"_empty_\";\n\n// configurable state\nvar warn$2;\nvar delimiters;\nvar transforms;\nvar preTransforms;\nvar postTransforms;\nvar platformIsPreTag;\nvar platformMustUseProp;\nvar platformGetTagNamespace;\nvar maybeComponent;\n\nfunction createASTElement (\n  tag,\n  attrs,\n  parent\n) {\n  return {\n    type: 1,\n    tag: tag,\n    attrsList: attrs,\n    attrsMap: makeAttrsMap(attrs),\n    rawAttrsMap: {},\n    parent: parent,\n    children: []\n  }\n}\n\n/**\n * Convert HTML string to AST.\n */\nfunction parse (\n  template,\n  options\n) {\n  warn$2 = options.warn || baseWarn;\n\n  platformIsPreTag = options.isPreTag || no;\n  platformMustUseProp = options.mustUseProp || no;\n  platformGetTagNamespace = options.getTagNamespace || no;\n  var isReservedTag = options.isReservedTag || no;\n  maybeComponent = function (el) { return !!el.component || !isReservedTag(el.tag); };\n\n  transforms = pluckModuleFunction(options.modules, 'transformNode');\n  preTransforms = pluckModuleFunction(options.modules, 'preTransformNode');\n  postTransforms = pluckModuleFunction(options.modules, 'postTransformNode');\n\n  delimiters = options.delimiters;\n\n  var stack = [];\n  var preserveWhitespace = options.preserveWhitespace !== false;\n  var whitespaceOption = options.whitespace;\n  var root;\n  var currentParent;\n  var inVPre = false;\n  var inPre = false;\n  var warned = false;\n\n  function warnOnce (msg, range) {\n    if (!warned) {\n      warned = true;\n      warn$2(msg, range);\n    }\n  }\n\n  function closeElement (element) {\n    trimEndingWhitespace(element);\n    if (!inVPre && !element.processed) {\n      element = processElement(element, options);\n    }\n    // tree management\n    if (!stack.length && element !== root) {\n      // allow root elements with v-if, v-else-if and v-else\n      if (root.if && (element.elseif || element.else)) {\n        if (process.env.NODE_ENV !== 'production') {\n          checkRootConstraints(element);\n        }\n        addIfCondition(root, {\n          exp: element.elseif,\n          block: element\n        });\n      } else if (process.env.NODE_ENV !== 'production') {\n        warnOnce(\n          \"Component template should contain exactly one root element. \" +\n          \"If you are using v-if on multiple elements, \" +\n          \"use v-else-if to chain them instead.\",\n          { start: element.start }\n        );\n      }\n    }\n    if (currentParent && !element.forbidden) {\n      if (element.elseif || element.else) {\n        processIfConditions(element, currentParent);\n      } else {\n        if (element.slotScope) {\n          // scoped slot\n          // keep it in the children list so that v-else(-if) conditions can\n          // find it as the prev node.\n          var name = element.slotTarget || '\"default\"'\n          ;(currentParent.scopedSlots || (currentParent.scopedSlots = {}))[name] = element;\n        }\n        currentParent.children.push(element);\n        element.parent = currentParent;\n      }\n    }\n\n    // final children cleanup\n    // filter out scoped slots\n    element.children = element.children.filter(function (c) { return !(c).slotScope; });\n    // remove trailing whitespace node again\n    trimEndingWhitespace(element);\n\n    // check pre state\n    if (element.pre) {\n      inVPre = false;\n    }\n    if (platformIsPreTag(element.tag)) {\n      inPre = false;\n    }\n    // apply post-transforms\n    for (var i = 0; i < postTransforms.length; i++) {\n      postTransforms[i](element, options);\n    }\n  }\n\n  function trimEndingWhitespace (el) {\n    // remove trailing whitespace node\n    if (!inPre) {\n      var lastNode;\n      while (\n        (lastNode = el.children[el.children.length - 1]) &&\n        lastNode.type === 3 &&\n        lastNode.text === ' '\n      ) {\n        el.children.pop();\n      }\n    }\n  }\n\n  function checkRootConstraints (el) {\n    if (el.tag === 'slot' || el.tag === 'template') {\n      warnOnce(\n        \"Cannot use <\" + (el.tag) + \"> as component root element because it may \" +\n        'contain multiple nodes.',\n        { start: el.start }\n      );\n    }\n    if (el.attrsMap.hasOwnProperty('v-for')) {\n      warnOnce(\n        'Cannot use v-for on stateful component root element because ' +\n        'it renders multiple elements.',\n        el.rawAttrsMap['v-for']\n      );\n    }\n  }\n\n  parseHTML(template, {\n    warn: warn$2,\n    expectHTML: options.expectHTML,\n    isUnaryTag: options.isUnaryTag,\n    canBeLeftOpenTag: options.canBeLeftOpenTag,\n    shouldDecodeNewlines: options.shouldDecodeNewlines,\n    shouldDecodeNewlinesForHref: options.shouldDecodeNewlinesForHref,\n    shouldKeepComment: options.comments,\n    outputSourceRange: options.outputSourceRange,\n    start: function start (tag, attrs, unary, start$1, end) {\n      // check namespace.\n      // inherit parent ns if there is one\n      var ns = (currentParent && currentParent.ns) || platformGetTagNamespace(tag);\n\n      // handle IE svg bug\n      /* istanbul ignore if */\n      if (isIE && ns === 'svg') {\n        attrs = guardIESVGBug(attrs);\n      }\n\n      var element = createASTElement(tag, attrs, currentParent);\n      if (ns) {\n        element.ns = ns;\n      }\n\n      if (process.env.NODE_ENV !== 'production') {\n        if (options.outputSourceRange) {\n          element.start = start$1;\n          element.end = end;\n          element.rawAttrsMap = element.attrsList.reduce(function (cumulated, attr) {\n            cumulated[attr.name] = attr;\n            return cumulated\n          }, {});\n        }\n        attrs.forEach(function (attr) {\n          if (invalidAttributeRE.test(attr.name)) {\n            warn$2(\n              \"Invalid dynamic argument expression: attribute names cannot contain \" +\n              \"spaces, quotes, <, >, / or =.\",\n              {\n                start: attr.start + attr.name.indexOf(\"[\"),\n                end: attr.start + attr.name.length\n              }\n            );\n          }\n        });\n      }\n\n      if (isForbiddenTag(element) && !isServerRendering()) {\n        element.forbidden = true;\n        process.env.NODE_ENV !== 'production' && warn$2(\n          'Templates should only be responsible for mapping the state to the ' +\n          'UI. Avoid placing tags with side-effects in your templates, such as ' +\n          \"<\" + tag + \">\" + ', as they will not be parsed.',\n          { start: element.start }\n        );\n      }\n\n      // apply pre-transforms\n      for (var i = 0; i < preTransforms.length; i++) {\n        element = preTransforms[i](element, options) || element;\n      }\n\n      if (!inVPre) {\n        processPre(element);\n        if (element.pre) {\n          inVPre = true;\n        }\n      }\n      if (platformIsPreTag(element.tag)) {\n        inPre = true;\n      }\n      if (inVPre) {\n        processRawAttrs(element);\n      } else if (!element.processed) {\n        // structural directives\n        processFor(element);\n        processIf(element);\n        processOnce(element);\n      }\n\n      if (!root) {\n        root = element;\n        if (process.env.NODE_ENV !== 'production') {\n          checkRootConstraints(root);\n        }\n      }\n\n      if (!unary) {\n        currentParent = element;\n        stack.push(element);\n      } else {\n        closeElement(element);\n      }\n    },\n\n    end: function end (tag, start, end$1) {\n      var element = stack[stack.length - 1];\n      // pop stack\n      stack.length -= 1;\n      currentParent = stack[stack.length - 1];\n      if (process.env.NODE_ENV !== 'production' && options.outputSourceRange) {\n        element.end = end$1;\n      }\n      closeElement(element);\n    },\n\n    chars: function chars (text, start, end) {\n      if (!currentParent) {\n        if (process.env.NODE_ENV !== 'production') {\n          if (text === template) {\n            warnOnce(\n              'Component template requires a root element, rather than just text.',\n              { start: start }\n            );\n          } else if ((text = text.trim())) {\n            warnOnce(\n              (\"text \\\"\" + text + \"\\\" outside root element will be ignored.\"),\n              { start: start }\n            );\n          }\n        }\n        return\n      }\n      // IE textarea placeholder bug\n      /* istanbul ignore if */\n      if (isIE &&\n        currentParent.tag === 'textarea' &&\n        currentParent.attrsMap.placeholder === text\n      ) {\n        return\n      }\n      var children = currentParent.children;\n      if (inPre || text.trim()) {\n        text = isTextTag(currentParent) ? text : decodeHTMLCached(text);\n      } else if (!children.length) {\n        // remove the whitespace-only node right after an opening tag\n        text = '';\n      } else if (whitespaceOption) {\n        if (whitespaceOption === 'condense') {\n          // in condense mode, remove the whitespace node if it contains\n          // line break, otherwise condense to a single space\n          text = lineBreakRE.test(text) ? '' : ' ';\n        } else {\n          text = ' ';\n        }\n      } else {\n        text = preserveWhitespace ? ' ' : '';\n      }\n      if (text) {\n        if (!inPre && whitespaceOption === 'condense') {\n          // condense consecutive whitespaces into single space\n          text = text.replace(whitespaceRE$1, ' ');\n        }\n        var res;\n        var child;\n        if (!inVPre && text !== ' ' && (res = parseText(text, delimiters))) {\n          child = {\n            type: 2,\n            expression: res.expression,\n            tokens: res.tokens,\n            text: text\n          };\n        } else if (text !== ' ' || !children.length || children[children.length - 1].text !== ' ') {\n          child = {\n            type: 3,\n            text: text\n          };\n        }\n        if (child) {\n          if (process.env.NODE_ENV !== 'production' && options.outputSourceRange) {\n            child.start = start;\n            child.end = end;\n          }\n          children.push(child);\n        }\n      }\n    },\n    comment: function comment (text, start, end) {\n      // adding anyting as a sibling to the root node is forbidden\n      // comments should still be allowed, but ignored\n      if (currentParent) {\n        var child = {\n          type: 3,\n          text: text,\n          isComment: true\n        };\n        if (process.env.NODE_ENV !== 'production' && options.outputSourceRange) {\n          child.start = start;\n          child.end = end;\n        }\n        currentParent.children.push(child);\n      }\n    }\n  });\n  return root\n}\n\nfunction processPre (el) {\n  if (getAndRemoveAttr(el, 'v-pre') != null) {\n    el.pre = true;\n  }\n}\n\nfunction processRawAttrs (el) {\n  var list = el.attrsList;\n  var len = list.length;\n  if (len) {\n    var attrs = el.attrs = new Array(len);\n    for (var i = 0; i < len; i++) {\n      attrs[i] = {\n        name: list[i].name,\n        value: JSON.stringify(list[i].value)\n      };\n      if (list[i].start != null) {\n        attrs[i].start = list[i].start;\n        attrs[i].end = list[i].end;\n      }\n    }\n  } else if (!el.pre) {\n    // non root node in pre blocks with no attributes\n    el.plain = true;\n  }\n}\n\nfunction processElement (\n  element,\n  options\n) {\n  processKey(element);\n\n  // determine whether this is a plain element after\n  // removing structural attributes\n  element.plain = (\n    !element.key &&\n    !element.scopedSlots &&\n    !element.attrsList.length\n  );\n\n  processRef(element);\n  processSlotContent(element);\n  processSlotOutlet(element);\n  processComponent(element);\n  for (var i = 0; i < transforms.length; i++) {\n    element = transforms[i](element, options) || element;\n  }\n  processAttrs(element);\n  return element\n}\n\nfunction processKey (el) {\n  var exp = getBindingAttr(el, 'key');\n  if (exp) {\n    if (process.env.NODE_ENV !== 'production') {\n      if (el.tag === 'template') {\n        warn$2(\n          \"<template> cannot be keyed. Place the key on real elements instead.\",\n          getRawBindingAttr(el, 'key')\n        );\n      }\n      if (el.for) {\n        var iterator = el.iterator2 || el.iterator1;\n        var parent = el.parent;\n        if (iterator && iterator === exp && parent && parent.tag === 'transition-group') {\n          warn$2(\n            \"Do not use v-for index as key on <transition-group> children, \" +\n            \"this is the same as not using keys.\",\n            getRawBindingAttr(el, 'key'),\n            true /* tip */\n          );\n        }\n      }\n    }\n    el.key = exp;\n  }\n}\n\nfunction processRef (el) {\n  var ref = getBindingAttr(el, 'ref');\n  if (ref) {\n    el.ref = ref;\n    el.refInFor = checkInFor(el);\n  }\n}\n\nfunction processFor (el) {\n  var exp;\n  if ((exp = getAndRemoveAttr(el, 'v-for'))) {\n    var res = parseFor(exp);\n    if (res) {\n      extend(el, res);\n    } else if (process.env.NODE_ENV !== 'production') {\n      warn$2(\n        (\"Invalid v-for expression: \" + exp),\n        el.rawAttrsMap['v-for']\n      );\n    }\n  }\n}\n\n\n\nfunction parseFor (exp) {\n  var inMatch = exp.match(forAliasRE);\n  if (!inMatch) { return }\n  var res = {};\n  res.for = inMatch[2].trim();\n  var alias = inMatch[1].trim().replace(stripParensRE, '');\n  var iteratorMatch = alias.match(forIteratorRE);\n  if (iteratorMatch) {\n    res.alias = alias.replace(forIteratorRE, '').trim();\n    res.iterator1 = iteratorMatch[1].trim();\n    if (iteratorMatch[2]) {\n      res.iterator2 = iteratorMatch[2].trim();\n    }\n  } else {\n    res.alias = alias;\n  }\n  return res\n}\n\nfunction processIf (el) {\n  var exp = getAndRemoveAttr(el, 'v-if');\n  if (exp) {\n    el.if = exp;\n    addIfCondition(el, {\n      exp: exp,\n      block: el\n    });\n  } else {\n    if (getAndRemoveAttr(el, 'v-else') != null) {\n      el.else = true;\n    }\n    var elseif = getAndRemoveAttr(el, 'v-else-if');\n    if (elseif) {\n      el.elseif = elseif;\n    }\n  }\n}\n\nfunction processIfConditions (el, parent) {\n  var prev = findPrevElement(parent.children);\n  if (prev && prev.if) {\n    addIfCondition(prev, {\n      exp: el.elseif,\n      block: el\n    });\n  } else if (process.env.NODE_ENV !== 'production') {\n    warn$2(\n      \"v-\" + (el.elseif ? ('else-if=\"' + el.elseif + '\"') : 'else') + \" \" +\n      \"used on element <\" + (el.tag) + \"> without corresponding v-if.\",\n      el.rawAttrsMap[el.elseif ? 'v-else-if' : 'v-else']\n    );\n  }\n}\n\nfunction findPrevElement (children) {\n  var i = children.length;\n  while (i--) {\n    if (children[i].type === 1) {\n      return children[i]\n    } else {\n      if (process.env.NODE_ENV !== 'production' && children[i].text !== ' ') {\n        warn$2(\n          \"text \\\"\" + (children[i].text.trim()) + \"\\\" between v-if and v-else(-if) \" +\n          \"will be ignored.\",\n          children[i]\n        );\n      }\n      children.pop();\n    }\n  }\n}\n\nfunction addIfCondition (el, condition) {\n  if (!el.ifConditions) {\n    el.ifConditions = [];\n  }\n  el.ifConditions.push(condition);\n}\n\nfunction processOnce (el) {\n  var once$$1 = getAndRemoveAttr(el, 'v-once');\n  if (once$$1 != null) {\n    el.once = true;\n  }\n}\n\n// handle content being passed to a component as slot,\n// e.g. <template slot=\"xxx\">, <div slot-scope=\"xxx\">\nfunction processSlotContent (el) {\n  var slotScope;\n  if (el.tag === 'template') {\n    slotScope = getAndRemoveAttr(el, 'scope');\n    /* istanbul ignore if */\n    if (process.env.NODE_ENV !== 'production' && slotScope) {\n      warn$2(\n        \"the \\\"scope\\\" attribute for scoped slots have been deprecated and \" +\n        \"replaced by \\\"slot-scope\\\" since 2.5. The new \\\"slot-scope\\\" attribute \" +\n        \"can also be used on plain elements in addition to <template> to \" +\n        \"denote scoped slots.\",\n        el.rawAttrsMap['scope'],\n        true\n      );\n    }\n    el.slotScope = slotScope || getAndRemoveAttr(el, 'slot-scope');\n  } else if ((slotScope = getAndRemoveAttr(el, 'slot-scope'))) {\n    /* istanbul ignore if */\n    if (process.env.NODE_ENV !== 'production' && el.attrsMap['v-for']) {\n      warn$2(\n        \"Ambiguous combined usage of slot-scope and v-for on <\" + (el.tag) + \"> \" +\n        \"(v-for takes higher priority). Use a wrapper <template> for the \" +\n        \"scoped slot to make it clearer.\",\n        el.rawAttrsMap['slot-scope'],\n        true\n      );\n    }\n    el.slotScope = slotScope;\n  }\n\n  // slot=\"xxx\"\n  var slotTarget = getBindingAttr(el, 'slot');\n  if (slotTarget) {\n    el.slotTarget = slotTarget === '\"\"' ? '\"default\"' : slotTarget;\n    el.slotTargetDynamic = !!(el.attrsMap[':slot'] || el.attrsMap['v-bind:slot']);\n    // preserve slot as an attribute for native shadow DOM compat\n    // only for non-scoped slots.\n    if (el.tag !== 'template' && !el.slotScope) {\n      addAttr(el, 'slot', slotTarget, getRawBindingAttr(el, 'slot'));\n    }\n  }\n\n  // 2.6 v-slot syntax\n  {\n    if (el.tag === 'template') {\n      // v-slot on <template>\n      var slotBinding = getAndRemoveAttrByRegex(el, slotRE);\n      if (slotBinding) {\n        if (process.env.NODE_ENV !== 'production') {\n          if (el.slotTarget || el.slotScope) {\n            warn$2(\n              \"Unexpected mixed usage of different slot syntaxes.\",\n              el\n            );\n          }\n          if (el.parent && !maybeComponent(el.parent)) {\n            warn$2(\n              \"<template v-slot> can only appear at the root level inside \" +\n              \"the receiving the component\",\n              el\n            );\n          }\n        }\n        var ref = getSlotName(slotBinding);\n        var name = ref.name;\n        var dynamic = ref.dynamic;\n        el.slotTarget = name;\n        el.slotTargetDynamic = dynamic;\n        el.slotScope = slotBinding.value || emptySlotScopeToken; // force it into a scoped slot for perf\n      }\n    } else {\n      // v-slot on component, denotes default slot\n      var slotBinding$1 = getAndRemoveAttrByRegex(el, slotRE);\n      if (slotBinding$1) {\n        if (process.env.NODE_ENV !== 'production') {\n          if (!maybeComponent(el)) {\n            warn$2(\n              \"v-slot can only be used on components or <template>.\",\n              slotBinding$1\n            );\n          }\n          if (el.slotScope || el.slotTarget) {\n            warn$2(\n              \"Unexpected mixed usage of different slot syntaxes.\",\n              el\n            );\n          }\n          if (el.scopedSlots) {\n            warn$2(\n              \"To avoid scope ambiguity, the default slot should also use \" +\n              \"<template> syntax when there are other named slots.\",\n              slotBinding$1\n            );\n          }\n        }\n        // add the component's children to its default slot\n        var slots = el.scopedSlots || (el.scopedSlots = {});\n        var ref$1 = getSlotName(slotBinding$1);\n        var name$1 = ref$1.name;\n        var dynamic$1 = ref$1.dynamic;\n        var slotContainer = slots[name$1] = createASTElement('template', [], el);\n        slotContainer.slotTarget = name$1;\n        slotContainer.slotTargetDynamic = dynamic$1;\n        slotContainer.children = el.children.filter(function (c) {\n          if (!c.slotScope) {\n            c.parent = slotContainer;\n            return true\n          }\n        });\n        slotContainer.slotScope = slotBinding$1.value || emptySlotScopeToken;\n        // remove children as they are returned from scopedSlots now\n        el.children = [];\n        // mark el non-plain so data gets generated\n        el.plain = false;\n      }\n    }\n  }\n}\n\nfunction getSlotName (binding) {\n  var name = binding.name.replace(slotRE, '');\n  if (!name) {\n    if (binding.name[0] !== '#') {\n      name = 'default';\n    } else if (process.env.NODE_ENV !== 'production') {\n      warn$2(\n        \"v-slot shorthand syntax requires a slot name.\",\n        binding\n      );\n    }\n  }\n  return dynamicArgRE.test(name)\n    // dynamic [name]\n    ? { name: name.slice(1, -1), dynamic: true }\n    // static name\n    : { name: (\"\\\"\" + name + \"\\\"\"), dynamic: false }\n}\n\n// handle <slot/> outlets\nfunction processSlotOutlet (el) {\n  if (el.tag === 'slot') {\n    el.slotName = getBindingAttr(el, 'name');\n    if (process.env.NODE_ENV !== 'production' && el.key) {\n      warn$2(\n        \"`key` does not work on <slot> because slots are abstract outlets \" +\n        \"and can possibly expand into multiple elements. \" +\n        \"Use the key on a wrapping element instead.\",\n        getRawBindingAttr(el, 'key')\n      );\n    }\n  }\n}\n\nfunction processComponent (el) {\n  var binding;\n  if ((binding = getBindingAttr(el, 'is'))) {\n    el.component = binding;\n  }\n  if (getAndRemoveAttr(el, 'inline-template') != null) {\n    el.inlineTemplate = true;\n  }\n}\n\nfunction processAttrs (el) {\n  var list = el.attrsList;\n  var i, l, name, rawName, value, modifiers, syncGen, isDynamic;\n  for (i = 0, l = list.length; i < l; i++) {\n    name = rawName = list[i].name;\n    value = list[i].value;\n    if (dirRE.test(name)) {\n      // mark element as dynamic\n      el.hasBindings = true;\n      // modifiers\n      modifiers = parseModifiers(name.replace(dirRE, ''));\n      // support .foo shorthand syntax for the .prop modifier\n      if (modifiers) {\n        name = name.replace(modifierRE, '');\n      }\n      if (bindRE.test(name)) { // v-bind\n        name = name.replace(bindRE, '');\n        value = parseFilters(value);\n        isDynamic = dynamicArgRE.test(name);\n        if (isDynamic) {\n          name = name.slice(1, -1);\n        }\n        if (\n          process.env.NODE_ENV !== 'production' &&\n          value.trim().length === 0\n        ) {\n          warn$2(\n            (\"The value for a v-bind expression cannot be empty. Found in \\\"v-bind:\" + name + \"\\\"\")\n          );\n        }\n        if (modifiers) {\n          if (modifiers.prop && !isDynamic) {\n            name = camelize(name);\n            if (name === 'innerHtml') { name = 'innerHTML'; }\n          }\n          if (modifiers.camel && !isDynamic) {\n            name = camelize(name);\n          }\n          if (modifiers.sync) {\n            syncGen = genAssignmentCode(value, \"$event\");\n            if (!isDynamic) {\n              addHandler(\n                el,\n                (\"update:\" + (camelize(name))),\n                syncGen,\n                null,\n                false,\n                warn$2,\n                list[i]\n              );\n              if (hyphenate(name) !== camelize(name)) {\n                addHandler(\n                  el,\n                  (\"update:\" + (hyphenate(name))),\n                  syncGen,\n                  null,\n                  false,\n                  warn$2,\n                  list[i]\n                );\n              }\n            } else {\n              // handler w/ dynamic event name\n              addHandler(\n                el,\n                (\"\\\"update:\\\"+(\" + name + \")\"),\n                syncGen,\n                null,\n                false,\n                warn$2,\n                list[i],\n                true // dynamic\n              );\n            }\n          }\n        }\n        if ((modifiers && modifiers.prop) || (\n          !el.component && platformMustUseProp(el.tag, el.attrsMap.type, name)\n        )) {\n          addProp(el, name, value, list[i], isDynamic);\n        } else {\n          addAttr(el, name, value, list[i], isDynamic);\n        }\n      } else if (onRE.test(name)) { // v-on\n        name = name.replace(onRE, '');\n        isDynamic = dynamicArgRE.test(name);\n        if (isDynamic) {\n          name = name.slice(1, -1);\n        }\n        addHandler(el, name, value, modifiers, false, warn$2, list[i], isDynamic);\n      } else { // normal directives\n        name = name.replace(dirRE, '');\n        // parse arg\n        var argMatch = name.match(argRE);\n        var arg = argMatch && argMatch[1];\n        isDynamic = false;\n        if (arg) {\n          name = name.slice(0, -(arg.length + 1));\n          if (dynamicArgRE.test(arg)) {\n            arg = arg.slice(1, -1);\n            isDynamic = true;\n          }\n        }\n        addDirective(el, name, rawName, value, arg, isDynamic, modifiers, list[i]);\n        if (process.env.NODE_ENV !== 'production' && name === 'model') {\n          checkForAliasModel(el, value);\n        }\n      }\n    } else {\n      // literal attribute\n      if (process.env.NODE_ENV !== 'production') {\n        var res = parseText(value, delimiters);\n        if (res) {\n          warn$2(\n            name + \"=\\\"\" + value + \"\\\": \" +\n            'Interpolation inside attributes has been removed. ' +\n            'Use v-bind or the colon shorthand instead. For example, ' +\n            'instead of <div id=\"{{ val }}\">, use <div :id=\"val\">.',\n            list[i]\n          );\n        }\n      }\n      addAttr(el, name, JSON.stringify(value), list[i]);\n      // #6887 firefox doesn't update muted state if set via attribute\n      // even immediately after element creation\n      if (!el.component &&\n          name === 'muted' &&\n          platformMustUseProp(el.tag, el.attrsMap.type, name)) {\n        addProp(el, name, 'true', list[i]);\n      }\n    }\n  }\n}\n\nfunction checkInFor (el) {\n  var parent = el;\n  while (parent) {\n    if (parent.for !== undefined) {\n      return true\n    }\n    parent = parent.parent;\n  }\n  return false\n}\n\nfunction parseModifiers (name) {\n  var match = name.match(modifierRE);\n  if (match) {\n    var ret = {};\n    match.forEach(function (m) { ret[m.slice(1)] = true; });\n    return ret\n  }\n}\n\nfunction makeAttrsMap (attrs) {\n  var map = {};\n  for (var i = 0, l = attrs.length; i < l; i++) {\n    if (\n      process.env.NODE_ENV !== 'production' &&\n      map[attrs[i].name] && !isIE && !isEdge\n    ) {\n      warn$2('duplicate attribute: ' + attrs[i].name, attrs[i]);\n    }\n    map[attrs[i].name] = attrs[i].value;\n  }\n  return map\n}\n\n// for script (e.g. type=\"x/template\") or style, do not decode content\nfunction isTextTag (el) {\n  return el.tag === 'script' || el.tag === 'style'\n}\n\nfunction isForbiddenTag (el) {\n  return (\n    el.tag === 'style' ||\n    (el.tag === 'script' && (\n      !el.attrsMap.type ||\n      el.attrsMap.type === 'text/javascript'\n    ))\n  )\n}\n\nvar ieNSBug = /^xmlns:NS\\d+/;\nvar ieNSPrefix = /^NS\\d+:/;\n\n/* istanbul ignore next */\nfunction guardIESVGBug (attrs) {\n  var res = [];\n  for (var i = 0; i < attrs.length; i++) {\n    var attr = attrs[i];\n    if (!ieNSBug.test(attr.name)) {\n      attr.name = attr.name.replace(ieNSPrefix, '');\n      res.push(attr);\n    }\n  }\n  return res\n}\n\nfunction checkForAliasModel (el, value) {\n  var _el = el;\n  while (_el) {\n    if (_el.for && _el.alias === value) {\n      warn$2(\n        \"<\" + (el.tag) + \" v-model=\\\"\" + value + \"\\\">: \" +\n        \"You are binding v-model directly to a v-for iteration alias. \" +\n        \"This will not be able to modify the v-for source array because \" +\n        \"writing to the alias is like modifying a function local variable. \" +\n        \"Consider using an array of objects and use v-model on an object property instead.\",\n        el.rawAttrsMap['v-model']\n      );\n    }\n    _el = _el.parent;\n  }\n}\n\n/*  */\n\nfunction preTransformNode (el, options) {\n  if (el.tag === 'input') {\n    var map = el.attrsMap;\n    if (!map['v-model']) {\n      return\n    }\n\n    var typeBinding;\n    if (map[':type'] || map['v-bind:type']) {\n      typeBinding = getBindingAttr(el, 'type');\n    }\n    if (!map.type && !typeBinding && map['v-bind']) {\n      typeBinding = \"(\" + (map['v-bind']) + \").type\";\n    }\n\n    if (typeBinding) {\n      var ifCondition = getAndRemoveAttr(el, 'v-if', true);\n      var ifConditionExtra = ifCondition ? (\"&&(\" + ifCondition + \")\") : \"\";\n      var hasElse = getAndRemoveAttr(el, 'v-else', true) != null;\n      var elseIfCondition = getAndRemoveAttr(el, 'v-else-if', true);\n      // 1. checkbox\n      var branch0 = cloneASTElement(el);\n      // process for on the main node\n      processFor(branch0);\n      addRawAttr(branch0, 'type', 'checkbox');\n      processElement(branch0, options);\n      branch0.processed = true; // prevent it from double-processed\n      branch0.if = \"(\" + typeBinding + \")==='checkbox'\" + ifConditionExtra;\n      addIfCondition(branch0, {\n        exp: branch0.if,\n        block: branch0\n      });\n      // 2. add radio else-if condition\n      var branch1 = cloneASTElement(el);\n      getAndRemoveAttr(branch1, 'v-for', true);\n      addRawAttr(branch1, 'type', 'radio');\n      processElement(branch1, options);\n      addIfCondition(branch0, {\n        exp: \"(\" + typeBinding + \")==='radio'\" + ifConditionExtra,\n        block: branch1\n      });\n      // 3. other\n      var branch2 = cloneASTElement(el);\n      getAndRemoveAttr(branch2, 'v-for', true);\n      addRawAttr(branch2, ':type', typeBinding);\n      processElement(branch2, options);\n      addIfCondition(branch0, {\n        exp: ifCondition,\n        block: branch2\n      });\n\n      if (hasElse) {\n        branch0.else = true;\n      } else if (elseIfCondition) {\n        branch0.elseif = elseIfCondition;\n      }\n\n      return branch0\n    }\n  }\n}\n\nfunction cloneASTElement (el) {\n  return createASTElement(el.tag, el.attrsList.slice(), el.parent)\n}\n\nvar model$1 = {\n  preTransformNode: preTransformNode\n};\n\nvar modules$1 = [\n  klass$1,\n  style$1,\n  model$1\n];\n\n/*  */\n\nfunction text (el, dir) {\n  if (dir.value) {\n    addProp(el, 'textContent', (\"_s(\" + (dir.value) + \")\"), dir);\n  }\n}\n\n/*  */\n\nfunction html (el, dir) {\n  if (dir.value) {\n    addProp(el, 'innerHTML', (\"_s(\" + (dir.value) + \")\"), dir);\n  }\n}\n\nvar directives$1 = {\n  model: model,\n  text: text,\n  html: html\n};\n\n/*  */\n\nvar baseOptions = {\n  expectHTML: true,\n  modules: modules$1,\n  directives: directives$1,\n  isPreTag: isPreTag,\n  isUnaryTag: isUnaryTag,\n  mustUseProp: mustUseProp,\n  canBeLeftOpenTag: canBeLeftOpenTag,\n  isReservedTag: isReservedTag,\n  getTagNamespace: getTagNamespace,\n  staticKeys: genStaticKeys(modules$1)\n};\n\n/*  */\n\nvar isStaticKey;\nvar isPlatformReservedTag;\n\nvar genStaticKeysCached = cached(genStaticKeys$1);\n\n/**\n * Goal of the optimizer: walk the generated template AST tree\n * and detect sub-trees that are purely static, i.e. parts of\n * the DOM that never needs to change.\n *\n * Once we detect these sub-trees, we can:\n *\n * 1. Hoist them into constants, so that we no longer need to\n *    create fresh nodes for them on each re-render;\n * 2. Completely skip them in the patching process.\n */\nfunction optimize (root, options) {\n  if (!root) { return }\n  isStaticKey = genStaticKeysCached(options.staticKeys || '');\n  isPlatformReservedTag = options.isReservedTag || no;\n  // first pass: mark all non-static nodes.\n  markStatic$1(root);\n  // second pass: mark static roots.\n  markStaticRoots(root, false);\n}\n\nfunction genStaticKeys$1 (keys) {\n  return makeMap(\n    'type,tag,attrsList,attrsMap,plain,parent,children,attrs,start,end,rawAttrsMap' +\n    (keys ? ',' + keys : '')\n  )\n}\n\nfunction markStatic$1 (node) {\n  node.static = isStatic(node);\n  if (node.type === 1) {\n    // do not make component slot content static. this avoids\n    // 1. components not able to mutate slot nodes\n    // 2. static slot content fails for hot-reloading\n    if (\n      !isPlatformReservedTag(node.tag) &&\n      node.tag !== 'slot' &&\n      node.attrsMap['inline-template'] == null\n    ) {\n      return\n    }\n    for (var i = 0, l = node.children.length; i < l; i++) {\n      var child = node.children[i];\n      markStatic$1(child);\n      if (!child.static) {\n        node.static = false;\n      }\n    }\n    if (node.ifConditions) {\n      for (var i$1 = 1, l$1 = node.ifConditions.length; i$1 < l$1; i$1++) {\n        var block = node.ifConditions[i$1].block;\n        markStatic$1(block);\n        if (!block.static) {\n          node.static = false;\n        }\n      }\n    }\n  }\n}\n\nfunction markStaticRoots (node, isInFor) {\n  if (node.type === 1) {\n    if (node.static || node.once) {\n      node.staticInFor = isInFor;\n    }\n    // For a node to qualify as a static root, it should have children that\n    // are not just static text. Otherwise the cost of hoisting out will\n    // outweigh the benefits and it's better off to just always render it fresh.\n    if (node.static && node.children.length && !(\n      node.children.length === 1 &&\n      node.children[0].type === 3\n    )) {\n      node.staticRoot = true;\n      return\n    } else {\n      node.staticRoot = false;\n    }\n    if (node.children) {\n      for (var i = 0, l = node.children.length; i < l; i++) {\n        markStaticRoots(node.children[i], isInFor || !!node.for);\n      }\n    }\n    if (node.ifConditions) {\n      for (var i$1 = 1, l$1 = node.ifConditions.length; i$1 < l$1; i$1++) {\n        markStaticRoots(node.ifConditions[i$1].block, isInFor);\n      }\n    }\n  }\n}\n\nfunction isStatic (node) {\n  if (node.type === 2) { // expression\n    return false\n  }\n  if (node.type === 3) { // text\n    return true\n  }\n  return !!(node.pre || (\n    !node.hasBindings && // no dynamic bindings\n    !node.if && !node.for && // not v-if or v-for or v-else\n    !isBuiltInTag(node.tag) && // not a built-in\n    isPlatformReservedTag(node.tag) && // not a component\n    !isDirectChildOfTemplateFor(node) &&\n    Object.keys(node).every(isStaticKey)\n  ))\n}\n\nfunction isDirectChildOfTemplateFor (node) {\n  while (node.parent) {\n    node = node.parent;\n    if (node.tag !== 'template') {\n      return false\n    }\n    if (node.for) {\n      return true\n    }\n  }\n  return false\n}\n\n/*  */\n\nvar fnExpRE = /^([\\w$_]+|\\([^)]*?\\))\\s*=>|^function\\s*(?:[\\w$]+)?\\s*\\(/;\nvar fnInvokeRE = /\\([^)]*?\\);*$/;\nvar simplePathRE = /^[A-Za-z_$][\\w$]*(?:\\.[A-Za-z_$][\\w$]*|\\['[^']*?']|\\[\"[^\"]*?\"]|\\[\\d+]|\\[[A-Za-z_$][\\w$]*])*$/;\n\n// KeyboardEvent.keyCode aliases\nvar keyCodes = {\n  esc: 27,\n  tab: 9,\n  enter: 13,\n  space: 32,\n  up: 38,\n  left: 37,\n  right: 39,\n  down: 40,\n  'delete': [8, 46]\n};\n\n// KeyboardEvent.key aliases\nvar keyNames = {\n  // #7880: IE11 and Edge use `Esc` for Escape key name.\n  esc: ['Esc', 'Escape'],\n  tab: 'Tab',\n  enter: 'Enter',\n  // #9112: IE11 uses `Spacebar` for Space key name.\n  space: [' ', 'Spacebar'],\n  // #7806: IE11 uses key names without `Arrow` prefix for arrow keys.\n  up: ['Up', 'ArrowUp'],\n  left: ['Left', 'ArrowLeft'],\n  right: ['Right', 'ArrowRight'],\n  down: ['Down', 'ArrowDown'],\n  // #9112: IE11 uses `Del` for Delete key name.\n  'delete': ['Backspace', 'Delete', 'Del']\n};\n\n// #4868: modifiers that prevent the execution of the listener\n// need to explicitly return null so that we can determine whether to remove\n// the listener for .once\nvar genGuard = function (condition) { return (\"if(\" + condition + \")return null;\"); };\n\nvar modifierCode = {\n  stop: '$event.stopPropagation();',\n  prevent: '$event.preventDefault();',\n  self: genGuard(\"$event.target !== $event.currentTarget\"),\n  ctrl: genGuard(\"!$event.ctrlKey\"),\n  shift: genGuard(\"!$event.shiftKey\"),\n  alt: genGuard(\"!$event.altKey\"),\n  meta: genGuard(\"!$event.metaKey\"),\n  left: genGuard(\"'button' in $event && $event.button !== 0\"),\n  middle: genGuard(\"'button' in $event && $event.button !== 1\"),\n  right: genGuard(\"'button' in $event && $event.button !== 2\")\n};\n\nfunction genHandlers (\n  events,\n  isNative\n) {\n  var prefix = isNative ? 'nativeOn:' : 'on:';\n  var staticHandlers = \"\";\n  var dynamicHandlers = \"\";\n  for (var name in events) {\n    var handlerCode = genHandler(events[name]);\n    if (events[name] && events[name].dynamic) {\n      dynamicHandlers += name + \",\" + handlerCode + \",\";\n    } else {\n      staticHandlers += \"\\\"\" + name + \"\\\":\" + handlerCode + \",\";\n    }\n  }\n  staticHandlers = \"{\" + (staticHandlers.slice(0, -1)) + \"}\";\n  if (dynamicHandlers) {\n    return prefix + \"_d(\" + staticHandlers + \",[\" + (dynamicHandlers.slice(0, -1)) + \"])\"\n  } else {\n    return prefix + staticHandlers\n  }\n}\n\nfunction genHandler (handler) {\n  if (!handler) {\n    return 'function(){}'\n  }\n\n  if (Array.isArray(handler)) {\n    return (\"[\" + (handler.map(function (handler) { return genHandler(handler); }).join(',')) + \"]\")\n  }\n\n  var isMethodPath = simplePathRE.test(handler.value);\n  var isFunctionExpression = fnExpRE.test(handler.value);\n  var isFunctionInvocation = simplePathRE.test(handler.value.replace(fnInvokeRE, ''));\n\n  if (!handler.modifiers) {\n    if (isMethodPath || isFunctionExpression) {\n      return handler.value\n    }\n    return (\"function($event){\" + (isFunctionInvocation ? (\"return \" + (handler.value)) : handler.value) + \"}\") // inline statement\n  } else {\n    var code = '';\n    var genModifierCode = '';\n    var keys = [];\n    for (var key in handler.modifiers) {\n      if (modifierCode[key]) {\n        genModifierCode += modifierCode[key];\n        // left/right\n        if (keyCodes[key]) {\n          keys.push(key);\n        }\n      } else if (key === 'exact') {\n        var modifiers = (handler.modifiers);\n        genModifierCode += genGuard(\n          ['ctrl', 'shift', 'alt', 'meta']\n            .filter(function (keyModifier) { return !modifiers[keyModifier]; })\n            .map(function (keyModifier) { return (\"$event.\" + keyModifier + \"Key\"); })\n            .join('||')\n        );\n      } else {\n        keys.push(key);\n      }\n    }\n    if (keys.length) {\n      code += genKeyFilter(keys);\n    }\n    // Make sure modifiers like prevent and stop get executed after key filtering\n    if (genModifierCode) {\n      code += genModifierCode;\n    }\n    var handlerCode = isMethodPath\n      ? (\"return \" + (handler.value) + \"($event)\")\n      : isFunctionExpression\n        ? (\"return (\" + (handler.value) + \")($event)\")\n        : isFunctionInvocation\n          ? (\"return \" + (handler.value))\n          : handler.value;\n    return (\"function($event){\" + code + handlerCode + \"}\")\n  }\n}\n\nfunction genKeyFilter (keys) {\n  return (\n    // make sure the key filters only apply to KeyboardEvents\n    // #9441: can't use 'keyCode' in $event because Chrome autofill fires fake\n    // key events that do not have keyCode property...\n    \"if(!$event.type.indexOf('key')&&\" +\n    (keys.map(genFilterCode).join('&&')) + \")return null;\"\n  )\n}\n\nfunction genFilterCode (key) {\n  var keyVal = parseInt(key, 10);\n  if (keyVal) {\n    return (\"$event.keyCode!==\" + keyVal)\n  }\n  var keyCode = keyCodes[key];\n  var keyName = keyNames[key];\n  return (\n    \"_k($event.keyCode,\" +\n    (JSON.stringify(key)) + \",\" +\n    (JSON.stringify(keyCode)) + \",\" +\n    \"$event.key,\" +\n    \"\" + (JSON.stringify(keyName)) +\n    \")\"\n  )\n}\n\n/*  */\n\nfunction on (el, dir) {\n  if (process.env.NODE_ENV !== 'production' && dir.modifiers) {\n    warn(\"v-on without argument does not support modifiers.\");\n  }\n  el.wrapListeners = function (code) { return (\"_g(\" + code + \",\" + (dir.value) + \")\"); };\n}\n\n/*  */\n\nfunction bind$1 (el, dir) {\n  el.wrapData = function (code) {\n    return (\"_b(\" + code + \",'\" + (el.tag) + \"',\" + (dir.value) + \",\" + (dir.modifiers && dir.modifiers.prop ? 'true' : 'false') + (dir.modifiers && dir.modifiers.sync ? ',true' : '') + \")\")\n  };\n}\n\n/*  */\n\nvar baseDirectives = {\n  on: on,\n  bind: bind$1,\n  cloak: noop\n};\n\n/*  */\n\n\n\n\n\nvar CodegenState = function CodegenState (options) {\n  this.options = options;\n  this.warn = options.warn || baseWarn;\n  this.transforms = pluckModuleFunction(options.modules, 'transformCode');\n  this.dataGenFns = pluckModuleFunction(options.modules, 'genData');\n  this.directives = extend(extend({}, baseDirectives), options.directives);\n  var isReservedTag = options.isReservedTag || no;\n  this.maybeComponent = function (el) { return !!el.component || !isReservedTag(el.tag); };\n  this.onceId = 0;\n  this.staticRenderFns = [];\n  this.pre = false;\n};\n\n\n\nfunction generate (\n  ast,\n  options\n) {\n  var state = new CodegenState(options);\n  var code = ast ? genElement(ast, state) : '_c(\"div\")';\n  return {\n    render: (\"with(this){return \" + code + \"}\"),\n    staticRenderFns: state.staticRenderFns\n  }\n}\n\nfunction genElement (el, state) {\n  if (el.parent) {\n    el.pre = el.pre || el.parent.pre;\n  }\n\n  if (el.staticRoot && !el.staticProcessed) {\n    return genStatic(el, state)\n  } else if (el.once && !el.onceProcessed) {\n    return genOnce(el, state)\n  } else if (el.for && !el.forProcessed) {\n    return genFor(el, state)\n  } else if (el.if && !el.ifProcessed) {\n    return genIf(el, state)\n  } else if (el.tag === 'template' && !el.slotTarget && !state.pre) {\n    return genChildren(el, state) || 'void 0'\n  } else if (el.tag === 'slot') {\n    return genSlot(el, state)\n  } else {\n    // component or element\n    var code;\n    if (el.component) {\n      code = genComponent(el.component, el, state);\n    } else {\n      var data;\n      if (!el.plain || (el.pre && state.maybeComponent(el))) {\n        data = genData$2(el, state);\n      }\n\n      var children = el.inlineTemplate ? null : genChildren(el, state, true);\n      code = \"_c('\" + (el.tag) + \"'\" + (data ? (\",\" + data) : '') + (children ? (\",\" + children) : '') + \")\";\n    }\n    // module transforms\n    for (var i = 0; i < state.transforms.length; i++) {\n      code = state.transforms[i](el, code);\n    }\n    return code\n  }\n}\n\n// hoist static sub-trees out\nfunction genStatic (el, state) {\n  el.staticProcessed = true;\n  // Some elements (templates) need to behave differently inside of a v-pre\n  // node.  All pre nodes are static roots, so we can use this as a location to\n  // wrap a state change and reset it upon exiting the pre node.\n  var originalPreState = state.pre;\n  if (el.pre) {\n    state.pre = el.pre;\n  }\n  state.staticRenderFns.push((\"with(this){return \" + (genElement(el, state)) + \"}\"));\n  state.pre = originalPreState;\n  return (\"_m(\" + (state.staticRenderFns.length - 1) + (el.staticInFor ? ',true' : '') + \")\")\n}\n\n// v-once\nfunction genOnce (el, state) {\n  el.onceProcessed = true;\n  if (el.if && !el.ifProcessed) {\n    return genIf(el, state)\n  } else if (el.staticInFor) {\n    var key = '';\n    var parent = el.parent;\n    while (parent) {\n      if (parent.for) {\n        key = parent.key;\n        break\n      }\n      parent = parent.parent;\n    }\n    if (!key) {\n      process.env.NODE_ENV !== 'production' && state.warn(\n        \"v-once can only be used inside v-for that is keyed. \",\n        el.rawAttrsMap['v-once']\n      );\n      return genElement(el, state)\n    }\n    return (\"_o(\" + (genElement(el, state)) + \",\" + (state.onceId++) + \",\" + key + \")\")\n  } else {\n    return genStatic(el, state)\n  }\n}\n\nfunction genIf (\n  el,\n  state,\n  altGen,\n  altEmpty\n) {\n  el.ifProcessed = true; // avoid recursion\n  return genIfConditions(el.ifConditions.slice(), state, altGen, altEmpty)\n}\n\nfunction genIfConditions (\n  conditions,\n  state,\n  altGen,\n  altEmpty\n) {\n  if (!conditions.length) {\n    return altEmpty || '_e()'\n  }\n\n  var condition = conditions.shift();\n  if (condition.exp) {\n    return (\"(\" + (condition.exp) + \")?\" + (genTernaryExp(condition.block)) + \":\" + (genIfConditions(conditions, state, altGen, altEmpty)))\n  } else {\n    return (\"\" + (genTernaryExp(condition.block)))\n  }\n\n  // v-if with v-once should generate code like (a)?_m(0):_m(1)\n  function genTernaryExp (el) {\n    return altGen\n      ? altGen(el, state)\n      : el.once\n        ? genOnce(el, state)\n        : genElement(el, state)\n  }\n}\n\nfunction genFor (\n  el,\n  state,\n  altGen,\n  altHelper\n) {\n  var exp = el.for;\n  var alias = el.alias;\n  var iterator1 = el.iterator1 ? (\",\" + (el.iterator1)) : '';\n  var iterator2 = el.iterator2 ? (\",\" + (el.iterator2)) : '';\n\n  if (process.env.NODE_ENV !== 'production' &&\n    state.maybeComponent(el) &&\n    el.tag !== 'slot' &&\n    el.tag !== 'template' &&\n    !el.key\n  ) {\n    state.warn(\n      \"<\" + (el.tag) + \" v-for=\\\"\" + alias + \" in \" + exp + \"\\\">: component lists rendered with \" +\n      \"v-for should have explicit keys. \" +\n      \"See https://vuejs.org/guide/list.html#key for more info.\",\n      el.rawAttrsMap['v-for'],\n      true /* tip */\n    );\n  }\n\n  el.forProcessed = true; // avoid recursion\n  return (altHelper || '_l') + \"((\" + exp + \"),\" +\n    \"function(\" + alias + iterator1 + iterator2 + \"){\" +\n      \"return \" + ((altGen || genElement)(el, state)) +\n    '})'\n}\n\nfunction genData$2 (el, state) {\n  var data = '{';\n\n  // directives first.\n  // directives may mutate the el's other properties before they are generated.\n  var dirs = genDirectives(el, state);\n  if (dirs) { data += dirs + ','; }\n\n  // key\n  if (el.key) {\n    data += \"key:\" + (el.key) + \",\";\n  }\n  // ref\n  if (el.ref) {\n    data += \"ref:\" + (el.ref) + \",\";\n  }\n  if (el.refInFor) {\n    data += \"refInFor:true,\";\n  }\n  // pre\n  if (el.pre) {\n    data += \"pre:true,\";\n  }\n  // record original tag name for components using \"is\" attribute\n  if (el.component) {\n    data += \"tag:\\\"\" + (el.tag) + \"\\\",\";\n  }\n  // module data generation functions\n  for (var i = 0; i < state.dataGenFns.length; i++) {\n    data += state.dataGenFns[i](el);\n  }\n  // attributes\n  if (el.attrs) {\n    data += \"attrs:\" + (genProps(el.attrs)) + \",\";\n  }\n  // DOM props\n  if (el.props) {\n    data += \"domProps:\" + (genProps(el.props)) + \",\";\n  }\n  // event handlers\n  if (el.events) {\n    data += (genHandlers(el.events, false)) + \",\";\n  }\n  if (el.nativeEvents) {\n    data += (genHandlers(el.nativeEvents, true)) + \",\";\n  }\n  // slot target\n  // only for non-scoped slots\n  if (el.slotTarget && !el.slotScope) {\n    data += \"slot:\" + (el.slotTarget) + \",\";\n  }\n  // scoped slots\n  if (el.scopedSlots) {\n    data += (genScopedSlots(el, el.scopedSlots, state)) + \",\";\n  }\n  // component v-model\n  if (el.model) {\n    data += \"model:{value:\" + (el.model.value) + \",callback:\" + (el.model.callback) + \",expression:\" + (el.model.expression) + \"},\";\n  }\n  // inline-template\n  if (el.inlineTemplate) {\n    var inlineTemplate = genInlineTemplate(el, state);\n    if (inlineTemplate) {\n      data += inlineTemplate + \",\";\n    }\n  }\n  data = data.replace(/,$/, '') + '}';\n  // v-bind dynamic argument wrap\n  // v-bind with dynamic arguments must be applied using the same v-bind object\n  // merge helper so that class/style/mustUseProp attrs are handled correctly.\n  if (el.dynamicAttrs) {\n    data = \"_b(\" + data + \",\\\"\" + (el.tag) + \"\\\",\" + (genProps(el.dynamicAttrs)) + \")\";\n  }\n  // v-bind data wrap\n  if (el.wrapData) {\n    data = el.wrapData(data);\n  }\n  // v-on data wrap\n  if (el.wrapListeners) {\n    data = el.wrapListeners(data);\n  }\n  return data\n}\n\nfunction genDirectives (el, state) {\n  var dirs = el.directives;\n  if (!dirs) { return }\n  var res = 'directives:[';\n  var hasRuntime = false;\n  var i, l, dir, needRuntime;\n  for (i = 0, l = dirs.length; i < l; i++) {\n    dir = dirs[i];\n    needRuntime = true;\n    var gen = state.directives[dir.name];\n    if (gen) {\n      // compile-time directive that manipulates AST.\n      // returns true if it also needs a runtime counterpart.\n      needRuntime = !!gen(el, dir, state.warn);\n    }\n    if (needRuntime) {\n      hasRuntime = true;\n      res += \"{name:\\\"\" + (dir.name) + \"\\\",rawName:\\\"\" + (dir.rawName) + \"\\\"\" + (dir.value ? (\",value:(\" + (dir.value) + \"),expression:\" + (JSON.stringify(dir.value))) : '') + (dir.arg ? (\",arg:\" + (dir.isDynamicArg ? dir.arg : (\"\\\"\" + (dir.arg) + \"\\\"\"))) : '') + (dir.modifiers ? (\",modifiers:\" + (JSON.stringify(dir.modifiers))) : '') + \"},\";\n    }\n  }\n  if (hasRuntime) {\n    return res.slice(0, -1) + ']'\n  }\n}\n\nfunction genInlineTemplate (el, state) {\n  var ast = el.children[0];\n  if (process.env.NODE_ENV !== 'production' && (\n    el.children.length !== 1 || ast.type !== 1\n  )) {\n    state.warn(\n      'Inline-template components must have exactly one child element.',\n      { start: el.start }\n    );\n  }\n  if (ast && ast.type === 1) {\n    var inlineRenderFns = generate(ast, state.options);\n    return (\"inlineTemplate:{render:function(){\" + (inlineRenderFns.render) + \"},staticRenderFns:[\" + (inlineRenderFns.staticRenderFns.map(function (code) { return (\"function(){\" + code + \"}\"); }).join(',')) + \"]}\")\n  }\n}\n\nfunction genScopedSlots (\n  el,\n  slots,\n  state\n) {\n  // by default scoped slots are considered \"stable\", this allows child\n  // components with only scoped slots to skip forced updates from parent.\n  // but in some cases we have to bail-out of this optimization\n  // for example if the slot contains dynamic names, has v-if or v-for on them...\n  var needsForceUpdate = el.for || Object.keys(slots).some(function (key) {\n    var slot = slots[key];\n    return (\n      slot.slotTargetDynamic ||\n      slot.if ||\n      slot.for ||\n      containsSlotChild(slot) // is passing down slot from parent which may be dynamic\n    )\n  });\n\n  // #9534: if a component with scoped slots is inside a conditional branch,\n  // it's possible for the same component to be reused but with different\n  // compiled slot content. To avoid that, we generate a unique key based on\n  // the generated code of all the slot contents.\n  var needsKey = !!el.if;\n\n  // OR when it is inside another scoped slot or v-for (the reactivity may be\n  // disconnected due to the intermediate scope variable)\n  // #9438, #9506\n  // TODO: this can be further optimized by properly analyzing in-scope bindings\n  // and skip force updating ones that do not actually use scope variables.\n  if (!needsForceUpdate) {\n    var parent = el.parent;\n    while (parent) {\n      if (\n        (parent.slotScope && parent.slotScope !== emptySlotScopeToken) ||\n        parent.for\n      ) {\n        needsForceUpdate = true;\n        break\n      }\n      if (parent.if) {\n        needsKey = true;\n      }\n      parent = parent.parent;\n    }\n  }\n\n  var generatedSlots = Object.keys(slots)\n    .map(function (key) { return genScopedSlot(slots[key], state); })\n    .join(',');\n\n  return (\"scopedSlots:_u([\" + generatedSlots + \"]\" + (needsForceUpdate ? \",null,true\" : \"\") + (!needsForceUpdate && needsKey ? (\",null,false,\" + (hash(generatedSlots))) : \"\") + \")\")\n}\n\nfunction hash(str) {\n  var hash = 5381;\n  var i = str.length;\n  while(i) {\n    hash = (hash * 33) ^ str.charCodeAt(--i);\n  }\n  return hash >>> 0\n}\n\nfunction containsSlotChild (el) {\n  if (el.type === 1) {\n    if (el.tag === 'slot') {\n      return true\n    }\n    return el.children.some(containsSlotChild)\n  }\n  return false\n}\n\nfunction genScopedSlot (\n  el,\n  state\n) {\n  var isLegacySyntax = el.attrsMap['slot-scope'];\n  if (el.if && !el.ifProcessed && !isLegacySyntax) {\n    return genIf(el, state, genScopedSlot, \"null\")\n  }\n  if (el.for && !el.forProcessed) {\n    return genFor(el, state, genScopedSlot)\n  }\n  var slotScope = el.slotScope === emptySlotScopeToken\n    ? \"\"\n    : String(el.slotScope);\n  var fn = \"function(\" + slotScope + \"){\" +\n    \"return \" + (el.tag === 'template'\n      ? el.if && isLegacySyntax\n        ? (\"(\" + (el.if) + \")?\" + (genChildren(el, state) || 'undefined') + \":undefined\")\n        : genChildren(el, state) || 'undefined'\n      : genElement(el, state)) + \"}\";\n  // reverse proxy v-slot without scope on this.$slots\n  var reverseProxy = slotScope ? \"\" : \",proxy:true\";\n  return (\"{key:\" + (el.slotTarget || \"\\\"default\\\"\") + \",fn:\" + fn + reverseProxy + \"}\")\n}\n\nfunction genChildren (\n  el,\n  state,\n  checkSkip,\n  altGenElement,\n  altGenNode\n) {\n  var children = el.children;\n  if (children.length) {\n    var el$1 = children[0];\n    // optimize single v-for\n    if (children.length === 1 &&\n      el$1.for &&\n      el$1.tag !== 'template' &&\n      el$1.tag !== 'slot'\n    ) {\n      var normalizationType = checkSkip\n        ? state.maybeComponent(el$1) ? \",1\" : \",0\"\n        : \"\";\n      return (\"\" + ((altGenElement || genElement)(el$1, state)) + normalizationType)\n    }\n    var normalizationType$1 = checkSkip\n      ? getNormalizationType(children, state.maybeComponent)\n      : 0;\n    var gen = altGenNode || genNode;\n    return (\"[\" + (children.map(function (c) { return gen(c, state); }).join(',')) + \"]\" + (normalizationType$1 ? (\",\" + normalizationType$1) : ''))\n  }\n}\n\n// determine the normalization needed for the children array.\n// 0: no normalization needed\n// 1: simple normalization needed (possible 1-level deep nested array)\n// 2: full normalization needed\nfunction getNormalizationType (\n  children,\n  maybeComponent\n) {\n  var res = 0;\n  for (var i = 0; i < children.length; i++) {\n    var el = children[i];\n    if (el.type !== 1) {\n      continue\n    }\n    if (needsNormalization(el) ||\n        (el.ifConditions && el.ifConditions.some(function (c) { return needsNormalization(c.block); }))) {\n      res = 2;\n      break\n    }\n    if (maybeComponent(el) ||\n        (el.ifConditions && el.ifConditions.some(function (c) { return maybeComponent(c.block); }))) {\n      res = 1;\n    }\n  }\n  return res\n}\n\nfunction needsNormalization (el) {\n  return el.for !== undefined || el.tag === 'template' || el.tag === 'slot'\n}\n\nfunction genNode (node, state) {\n  if (node.type === 1) {\n    return genElement(node, state)\n  } else if (node.type === 3 && node.isComment) {\n    return genComment(node)\n  } else {\n    return genText(node)\n  }\n}\n\nfunction genText (text) {\n  return (\"_v(\" + (text.type === 2\n    ? text.expression // no need for () because already wrapped in _s()\n    : transformSpecialNewlines(JSON.stringify(text.text))) + \")\")\n}\n\nfunction genComment (comment) {\n  return (\"_e(\" + (JSON.stringify(comment.text)) + \")\")\n}\n\nfunction genSlot (el, state) {\n  var slotName = el.slotName || '\"default\"';\n  var children = genChildren(el, state);\n  var res = \"_t(\" + slotName + (children ? (\",\" + children) : '');\n  var attrs = el.attrs || el.dynamicAttrs\n    ? genProps((el.attrs || []).concat(el.dynamicAttrs || []).map(function (attr) { return ({\n        // slot props are camelized\n        name: camelize(attr.name),\n        value: attr.value,\n        dynamic: attr.dynamic\n      }); }))\n    : null;\n  var bind$$1 = el.attrsMap['v-bind'];\n  if ((attrs || bind$$1) && !children) {\n    res += \",null\";\n  }\n  if (attrs) {\n    res += \",\" + attrs;\n  }\n  if (bind$$1) {\n    res += (attrs ? '' : ',null') + \",\" + bind$$1;\n  }\n  return res + ')'\n}\n\n// componentName is el.component, take it as argument to shun flow's pessimistic refinement\nfunction genComponent (\n  componentName,\n  el,\n  state\n) {\n  var children = el.inlineTemplate ? null : genChildren(el, state, true);\n  return (\"_c(\" + componentName + \",\" + (genData$2(el, state)) + (children ? (\",\" + children) : '') + \")\")\n}\n\nfunction genProps (props) {\n  var staticProps = \"\";\n  var dynamicProps = \"\";\n  for (var i = 0; i < props.length; i++) {\n    var prop = props[i];\n    var value = transformSpecialNewlines(prop.value);\n    if (prop.dynamic) {\n      dynamicProps += (prop.name) + \",\" + value + \",\";\n    } else {\n      staticProps += \"\\\"\" + (prop.name) + \"\\\":\" + value + \",\";\n    }\n  }\n  staticProps = \"{\" + (staticProps.slice(0, -1)) + \"}\";\n  if (dynamicProps) {\n    return (\"_d(\" + staticProps + \",[\" + (dynamicProps.slice(0, -1)) + \"])\")\n  } else {\n    return staticProps\n  }\n}\n\n// #3895, #4268\nfunction transformSpecialNewlines (text) {\n  return text\n    .replace(/\\u2028/g, '\\\\u2028')\n    .replace(/\\u2029/g, '\\\\u2029')\n}\n\n/*  */\n\n\n\n// these keywords should not appear inside expressions, but operators like\n// typeof, instanceof and in are allowed\nvar prohibitedKeywordRE = new RegExp('\\\\b' + (\n  'do,if,for,let,new,try,var,case,else,with,await,break,catch,class,const,' +\n  'super,throw,while,yield,delete,export,import,return,switch,default,' +\n  'extends,finally,continue,debugger,function,arguments'\n).split(',').join('\\\\b|\\\\b') + '\\\\b');\n\n// these unary operators should not be used as property/method names\nvar unaryOperatorsRE = new RegExp('\\\\b' + (\n  'delete,typeof,void'\n).split(',').join('\\\\s*\\\\([^\\\\)]*\\\\)|\\\\b') + '\\\\s*\\\\([^\\\\)]*\\\\)');\n\n// strip strings in expressions\nvar stripStringRE = /'(?:[^'\\\\]|\\\\.)*'|\"(?:[^\"\\\\]|\\\\.)*\"|`(?:[^`\\\\]|\\\\.)*\\$\\{|\\}(?:[^`\\\\]|\\\\.)*`|`(?:[^`\\\\]|\\\\.)*`/g;\n\n// detect problematic expressions in a template\nfunction detectErrors (ast, warn) {\n  if (ast) {\n    checkNode(ast, warn);\n  }\n}\n\nfunction checkNode (node, warn) {\n  if (node.type === 1) {\n    for (var name in node.attrsMap) {\n      if (dirRE.test(name)) {\n        var value = node.attrsMap[name];\n        if (value) {\n          var range = node.rawAttrsMap[name];\n          if (name === 'v-for') {\n            checkFor(node, (\"v-for=\\\"\" + value + \"\\\"\"), warn, range);\n          } else if (onRE.test(name)) {\n            checkEvent(value, (name + \"=\\\"\" + value + \"\\\"\"), warn, range);\n          } else {\n            checkExpression(value, (name + \"=\\\"\" + value + \"\\\"\"), warn, range);\n          }\n        }\n      }\n    }\n    if (node.children) {\n      for (var i = 0; i < node.children.length; i++) {\n        checkNode(node.children[i], warn);\n      }\n    }\n  } else if (node.type === 2) {\n    checkExpression(node.expression, node.text, warn, node);\n  }\n}\n\nfunction checkEvent (exp, text, warn, range) {\n  var stipped = exp.replace(stripStringRE, '');\n  var keywordMatch = stipped.match(unaryOperatorsRE);\n  if (keywordMatch && stipped.charAt(keywordMatch.index - 1) !== '$') {\n    warn(\n      \"avoid using JavaScript unary operator as property name: \" +\n      \"\\\"\" + (keywordMatch[0]) + \"\\\" in expression \" + (text.trim()),\n      range\n    );\n  }\n  checkExpression(exp, text, warn, range);\n}\n\nfunction checkFor (node, text, warn, range) {\n  checkExpression(node.for || '', text, warn, range);\n  checkIdentifier(node.alias, 'v-for alias', text, warn, range);\n  checkIdentifier(node.iterator1, 'v-for iterator', text, warn, range);\n  checkIdentifier(node.iterator2, 'v-for iterator', text, warn, range);\n}\n\nfunction checkIdentifier (\n  ident,\n  type,\n  text,\n  warn,\n  range\n) {\n  if (typeof ident === 'string') {\n    try {\n      new Function((\"var \" + ident + \"=_\"));\n    } catch (e) {\n      warn((\"invalid \" + type + \" \\\"\" + ident + \"\\\" in expression: \" + (text.trim())), range);\n    }\n  }\n}\n\nfunction checkExpression (exp, text, warn, range) {\n  try {\n    new Function((\"return \" + exp));\n  } catch (e) {\n    var keywordMatch = exp.replace(stripStringRE, '').match(prohibitedKeywordRE);\n    if (keywordMatch) {\n      warn(\n        \"avoid using JavaScript keyword as property name: \" +\n        \"\\\"\" + (keywordMatch[0]) + \"\\\"\\n  Raw expression: \" + (text.trim()),\n        range\n      );\n    } else {\n      warn(\n        \"invalid expression: \" + (e.message) + \" in\\n\\n\" +\n        \"    \" + exp + \"\\n\\n\" +\n        \"  Raw expression: \" + (text.trim()) + \"\\n\",\n        range\n      );\n    }\n  }\n}\n\n/*  */\n\nvar range = 2;\n\nfunction generateCodeFrame (\n  source,\n  start,\n  end\n) {\n  if ( start === void 0 ) start = 0;\n  if ( end === void 0 ) end = source.length;\n\n  var lines = source.split(/\\r?\\n/);\n  var count = 0;\n  var res = [];\n  for (var i = 0; i < lines.length; i++) {\n    count += lines[i].length + 1;\n    if (count >= start) {\n      for (var j = i - range; j <= i + range || end > count; j++) {\n        if (j < 0 || j >= lines.length) { continue }\n        res.push((\"\" + (j + 1) + (repeat$1(\" \", 3 - String(j + 1).length)) + \"|  \" + (lines[j])));\n        var lineLength = lines[j].length;\n        if (j === i) {\n          // push underline\n          var pad = start - (count - lineLength) + 1;\n          var length = end > count ? lineLength - pad : end - start;\n          res.push(\"   |  \" + repeat$1(\" \", pad) + repeat$1(\"^\", length));\n        } else if (j > i) {\n          if (end > count) {\n            var length$1 = Math.min(end - count, lineLength);\n            res.push(\"   |  \" + repeat$1(\"^\", length$1));\n          }\n          count += lineLength + 1;\n        }\n      }\n      break\n    }\n  }\n  return res.join('\\n')\n}\n\nfunction repeat$1 (str, n) {\n  var result = '';\n  if (n > 0) {\n    while (true) { // eslint-disable-line\n      if (n & 1) { result += str; }\n      n >>>= 1;\n      if (n <= 0) { break }\n      str += str;\n    }\n  }\n  return result\n}\n\n/*  */\n\n\n\nfunction createFunction (code, errors) {\n  try {\n    return new Function(code)\n  } catch (err) {\n    errors.push({ err: err, code: code });\n    return noop\n  }\n}\n\nfunction createCompileToFunctionFn (compile) {\n  var cache = Object.create(null);\n\n  return function compileToFunctions (\n    template,\n    options,\n    vm\n  ) {\n    options = extend({}, options);\n    var warn$$1 = options.warn || warn;\n    delete options.warn;\n\n    /* istanbul ignore if */\n    if (process.env.NODE_ENV !== 'production') {\n      // detect possible CSP restriction\n      try {\n        new Function('return 1');\n      } catch (e) {\n        if (e.toString().match(/unsafe-eval|CSP/)) {\n          warn$$1(\n            'It seems you are using the standalone build of Vue.js in an ' +\n            'environment with Content Security Policy that prohibits unsafe-eval. ' +\n            'The template compiler cannot work in this environment. Consider ' +\n            'relaxing the policy to allow unsafe-eval or pre-compiling your ' +\n            'templates into render functions.'\n          );\n        }\n      }\n    }\n\n    // check cache\n    var key = options.delimiters\n      ? String(options.delimiters) + template\n      : template;\n    if (cache[key]) {\n      return cache[key]\n    }\n\n    // compile\n    var compiled = compile(template, options);\n\n    // check compilation errors/tips\n    if (process.env.NODE_ENV !== 'production') {\n      if (compiled.errors && compiled.errors.length) {\n        if (options.outputSourceRange) {\n          compiled.errors.forEach(function (e) {\n            warn$$1(\n              \"Error compiling template:\\n\\n\" + (e.msg) + \"\\n\\n\" +\n              generateCodeFrame(template, e.start, e.end),\n              vm\n            );\n          });\n        } else {\n          warn$$1(\n            \"Error compiling template:\\n\\n\" + template + \"\\n\\n\" +\n            compiled.errors.map(function (e) { return (\"- \" + e); }).join('\\n') + '\\n',\n            vm\n          );\n        }\n      }\n      if (compiled.tips && compiled.tips.length) {\n        if (options.outputSourceRange) {\n          compiled.tips.forEach(function (e) { return tip(e.msg, vm); });\n        } else {\n          compiled.tips.forEach(function (msg) { return tip(msg, vm); });\n        }\n      }\n    }\n\n    // turn code into functions\n    var res = {};\n    var fnGenErrors = [];\n    res.render = createFunction(compiled.render, fnGenErrors);\n    res.staticRenderFns = compiled.staticRenderFns.map(function (code) {\n      return createFunction(code, fnGenErrors)\n    });\n\n    // check function generation errors.\n    // this should only happen if there is a bug in the compiler itself.\n    // mostly for codegen development use\n    /* istanbul ignore if */\n    if (process.env.NODE_ENV !== 'production') {\n      if ((!compiled.errors || !compiled.errors.length) && fnGenErrors.length) {\n        warn$$1(\n          \"Failed to generate render function:\\n\\n\" +\n          fnGenErrors.map(function (ref) {\n            var err = ref.err;\n            var code = ref.code;\n\n            return ((err.toString()) + \" in\\n\\n\" + code + \"\\n\");\n        }).join('\\n'),\n          vm\n        );\n      }\n    }\n\n    return (cache[key] = res)\n  }\n}\n\n/*  */\n\nfunction createCompilerCreator (baseCompile) {\n  return function createCompiler (baseOptions) {\n    function compile (\n      template,\n      options\n    ) {\n      var finalOptions = Object.create(baseOptions);\n      var errors = [];\n      var tips = [];\n\n      var warn = function (msg, range, tip) {\n        (tip ? tips : errors).push(msg);\n      };\n\n      if (options) {\n        if (process.env.NODE_ENV !== 'production' && options.outputSourceRange) {\n          // $flow-disable-line\n          var leadingSpaceLength = template.match(/^\\s*/)[0].length;\n\n          warn = function (msg, range, tip) {\n            var data = { msg: msg };\n            if (range) {\n              if (range.start != null) {\n                data.start = range.start + leadingSpaceLength;\n              }\n              if (range.end != null) {\n                data.end = range.end + leadingSpaceLength;\n              }\n            }\n            (tip ? tips : errors).push(data);\n          };\n        }\n        // merge custom modules\n        if (options.modules) {\n          finalOptions.modules =\n            (baseOptions.modules || []).concat(options.modules);\n        }\n        // merge custom directives\n        if (options.directives) {\n          finalOptions.directives = extend(\n            Object.create(baseOptions.directives || null),\n            options.directives\n          );\n        }\n        // copy other options\n        for (var key in options) {\n          if (key !== 'modules' && key !== 'directives') {\n            finalOptions[key] = options[key];\n          }\n        }\n      }\n\n      finalOptions.warn = warn;\n\n      var compiled = baseCompile(template.trim(), finalOptions);\n      if (process.env.NODE_ENV !== 'production') {\n        detectErrors(compiled.ast, warn);\n      }\n      compiled.errors = errors;\n      compiled.tips = tips;\n      return compiled\n    }\n\n    return {\n      compile: compile,\n      compileToFunctions: createCompileToFunctionFn(compile)\n    }\n  }\n}\n\n/*  */\n\n// `createCompilerCreator` allows creating compilers that use alternative\n// parser/optimizer/codegen, e.g the SSR optimizing compiler.\n// Here we just export a default compiler using the default parts.\nvar createCompiler = createCompilerCreator(function baseCompile (\n  template,\n  options\n) {\n  var ast = parse(template.trim(), options);\n  if (options.optimize !== false) {\n    optimize(ast, options);\n  }\n  var code = generate(ast, options);\n  return {\n    ast: ast,\n    render: code.render,\n    staticRenderFns: code.staticRenderFns\n  }\n});\n\n/*  */\n\nvar ref$1 = createCompiler(baseOptions);\nvar compile = ref$1.compile;\nvar compileToFunctions = ref$1.compileToFunctions;\n\n/*  */\n\n// check whether current browser encodes a char inside attribute values\nvar div;\nfunction getShouldDecode (href) {\n  div = div || document.createElement('div');\n  div.innerHTML = href ? \"<a href=\\\"\\n\\\"/>\" : \"<div a=\\\"\\n\\\"/>\";\n  return div.innerHTML.indexOf('&#10;') > 0\n}\n\n// #3663: IE encodes newlines inside attribute values while other browsers don't\nvar shouldDecodeNewlines = inBrowser ? getShouldDecode(false) : false;\n// #6828: chrome encodes content in a[href]\nvar shouldDecodeNewlinesForHref = inBrowser ? getShouldDecode(true) : false;\n\n/*  */\n\nvar idToTemplate = cached(function (id) {\n  var el = query(id);\n  return el && el.innerHTML\n});\n\nvar mount = Vue.prototype.$mount;\nVue.prototype.$mount = function (\n  el,\n  hydrating\n) {\n  el = el && query(el);\n\n  /* istanbul ignore if */\n  if (el === document.body || el === document.documentElement) {\n    process.env.NODE_ENV !== 'production' && warn(\n      \"Do not mount Vue to <html> or <body> - mount to normal elements instead.\"\n    );\n    return this\n  }\n\n  var options = this.$options;\n  // resolve template/el and convert to render function\n  if (!options.render) {\n    var template = options.template;\n    if (template) {\n      if (typeof template === 'string') {\n        if (template.charAt(0) === '#') {\n          template = idToTemplate(template);\n          /* istanbul ignore if */\n          if (process.env.NODE_ENV !== 'production' && !template) {\n            warn(\n              (\"Template element not found or is empty: \" + (options.template)),\n              this\n            );\n          }\n        }\n      } else if (template.nodeType) {\n        template = template.innerHTML;\n      } else {\n        if (process.env.NODE_ENV !== 'production') {\n          warn('invalid template option:' + template, this);\n        }\n        return this\n      }\n    } else if (el) {\n      template = getOuterHTML(el);\n    }\n    if (template) {\n      /* istanbul ignore if */\n      if (process.env.NODE_ENV !== 'production' && config.performance && mark) {\n        mark('compile');\n      }\n\n      var ref = compileToFunctions(template, {\n        outputSourceRange: process.env.NODE_ENV !== 'production',\n        shouldDecodeNewlines: shouldDecodeNewlines,\n        shouldDecodeNewlinesForHref: shouldDecodeNewlinesForHref,\n        delimiters: options.delimiters,\n        comments: options.comments\n      }, this);\n      var render = ref.render;\n      var staticRenderFns = ref.staticRenderFns;\n      options.render = render;\n      options.staticRenderFns = staticRenderFns;\n\n      /* istanbul ignore if */\n      if (process.env.NODE_ENV !== 'production' && config.performance && mark) {\n        mark('compile end');\n        measure((\"vue \" + (this._name) + \" compile\"), 'compile', 'compile end');\n      }\n    }\n  }\n  return mount.call(this, el, hydrating)\n};\n\n/**\n * Get outerHTML of elements, taking care\n * of SVG elements in IE as well.\n */\nfunction getOuterHTML (el) {\n  if (el.outerHTML) {\n    return el.outerHTML\n  } else {\n    var container = document.createElement('div');\n    container.appendChild(el.cloneNode(true));\n    return container.innerHTML\n  }\n}\n\nVue.compile = compileToFunctions;\n\n/* harmony default export */ __webpack_exports__[\"a\"] = (Vue);\n\n/* WEBPACK VAR INJECTION */}.call(__webpack_exports__, __webpack_require__(11), __webpack_require__(32), __webpack_require__(114).setImmediate))\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvdnVlL2Rpc3QvdnVlLmVzbS5qcz9lZmViIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxrQ0FBa0M7O0FBRWxDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLGlCQUFpQjtBQUNsQztBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsK0JBQStCO0FBQ3JELHNCQUFzQixpQkFBaUI7QUFDdkM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrREFBa0QsaUNBQWlDLEVBQUU7QUFDckYsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixnQkFBZ0I7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsY0FBYzs7QUFFM0M7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLFVBQVU7O0FBRXZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxPQUFPO0FBQ1A7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixnQkFBZ0I7QUFDakMsa0NBQWtDO0FBQ2xDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7O0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLHFCQUFxQjtBQUN4QyxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EscUJBQXFCOztBQUVyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLLEdBQUc7QUFDUjtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTs7QUFFQTtBQUNBO0FBQ0Esb0NBQW9DO0FBQ3BDOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQztBQUNqQyx1Q0FBdUMsd0JBQXdCLEVBQUU7QUFDakUsMEJBQTBCOztBQUUxQjtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixZQUFZO0FBQ3BDLGtCQUFrQixZQUFZO0FBQzlCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQjtBQUMvQjtBQUNBLHdDQUF3QyxFQUFFO0FBQzFDO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLG9CQUFvQixFQUFFO0FBQ3JEO0FBQ0Esa0NBQWtDLE9BQU87QUFDekM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsMEJBQTBCLFNBQVMscUJBQXFCOztBQUV4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkI7QUFDM0I7QUFDQSxvQ0FBb0M7QUFDcEM7QUFDQSxxQ0FBcUM7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7Ozs7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQiwyQkFBMkI7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkMsU0FBUztBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSw2Q0FBNkMscUNBQXFDLEVBQUU7QUFDcEY7O0FBRUE7QUFDQTtBQUNBOztBQUVBLG9DQUFvQyx5Q0FBeUMsRUFBRTtBQUMvRTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QixrQkFBa0I7QUFDM0M7QUFDQTtBQUNBLDRCQUE0QjtBQUM1QixhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsc0RBQXNELEVBQUU7QUFDdEY7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLG1CQUFtQjtBQUNwQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLGtCQUFrQjtBQUNsQztBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsdUJBQXVCO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDLGlDQUFpQztBQUNuRSxjQUFjLDZCQUE2QjtBQUMzQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0MsaUNBQWlDO0FBQ25FLGNBQWMsNkJBQTZCO0FBQzNDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQix5QkFBeUI7QUFDMUMsR0FBRztBQUNIO0FBQ0E7QUFDQSxpQkFBaUIsK0JBQStCO0FBQ2hEO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixtQkFBbUI7QUFDeEM7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsOENBQThDO0FBQzlDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIscUJBQXFCO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLHFCQUFxQjtBQUNsQztBQUNBLCtDQUErQztBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULE9BQU87QUFDUDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxtQkFBbUIsaUJBQWlCO0FBQ3BDO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7O0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQyxPQUFPO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxrRUFBa0U7QUFDbEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxzQkFBc0IsbUJBQW1CO0FBQ3pDOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLE9BQU87QUFDdEM7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLGVBQWUsU0FBUztBQUN4QjtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLGtDQUFrQyxPQUFPO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCO0FBQzlCO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsNENBQTRDLGVBQWU7QUFDM0QsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLGtEQUFrRDtBQUNsRCw0Q0FBNEM7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDZDQUE2QztBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsaUJBQWlCO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLDRDQUE0QztBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEIsaUJBQWlCLGdCQUFnQjtBQUNqQztBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EsaUJBQWlCLG1CQUFtQjtBQUNwQztBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxxQ0FBcUMsZ0VBQWdFO0FBQ3JHO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCw0QkFBNEIsK0JBQStCO0FBQzNELDRCQUE0QiwrQkFBK0I7QUFDM0Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsbUJBQW1CLG1CQUFtQjtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrREFBa0Q7QUFDbEQ7QUFDQTtBQUNBLG1DQUFtQztBQUNuQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEI7QUFDOUI7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSyx1RkFBdUY7QUFDNUY7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QyxPQUFPO0FBQzlDO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QyxTQUFTO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDLE9BQU87QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsMEJBQTBCOztBQUUxQixrQkFBa0I7QUFDbEI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixxQkFBcUI7QUFDeEM7QUFDQSwwQ0FBMEM7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsdUJBQXVCO0FBQ3ZCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIseUJBQXlCO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLHlCQUF5QjtBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QyxPQUFPO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLDBCQUEwQjtBQUNwRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsb0JBQW9CLEVBQUU7O0FBRXBEO0FBQ0E7QUFDQSxpQkFBaUIsc0JBQXNCO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxpQkFBaUIsa0JBQWtCO0FBQ25DO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7O0FBSUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLDJCQUEyQjtBQUM5QyxxQkFBcUIsK0JBQStCO0FBQ3BEO0FBQ0E7QUFDQSxHQUFHO0FBQ0gseUJBQXlCO0FBQ3pCO0FBQ0Esc0JBQXNCLGlDQUFpQztBQUN2RDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQSw4QkFBOEI7O0FBRTlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLG9CQUFvQjtBQUN6QztBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCO0FBQ0EsOEJBQThCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QjtBQUN2QjtBQUNBLG9CQUFvQjtBQUNwQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLGVBQWU7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0VBQXNFO0FBQ3RFO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDOztBQUVqQztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0I7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTs7OztBQUlBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTs7QUFFQTtBQUNBLDBDQUEwQywyQkFBMkIsRUFBRTtBQUN2RSxLQUFLO0FBQ0w7QUFDQSwwQ0FBMEMsNEJBQTRCLEVBQUU7QUFDeEUsS0FBSztBQUNMLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQixlQUFlO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DLE9BQU87QUFDMUM7QUFDQSxnQkFBZ0IsWUFBWTtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLFlBQVk7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLCtCQUErQixzQkFBc0I7O0FBRXJEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxvQkFBb0I7O0FBRXBCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxnQ0FBZ0M7O0FBRWhDOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGFBQWE7QUFDakM7QUFDQSxxQkFBcUIsY0FBYztBQUNuQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsYUFBYSxrQkFBa0I7QUFDL0I7QUFDQSxlQUFlLG9CQUFvQjtBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsMkRBQTJEO0FBQzNEOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGlDQUFpQztBQUNqQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIseUJBQXlCO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLHFCQUFxQjtBQUMxQztBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxxQkFBcUIseUJBQXlCO0FBQzlDO0FBQ0E7QUFDQSx3QkFBd0I7QUFDeEI7QUFDQSw0QkFBNEIsNEJBQTRCO0FBQ3hELDRCQUE0QixnQ0FBZ0M7QUFDNUQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsVUFBVSxvQkFBb0I7QUFDOUI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseURBQXlELFVBQVU7QUFDbkUsaUJBQWlCLHdCQUF3QixPQUFPLHVCQUF1QjtBQUN2RTtBQUNBO0FBQ0EsaUJBQWlCLDJCQUEyQjtBQUM1QztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFVBQVUsb0JBQW9CO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTLE9BQU87QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLHVCQUF1QjtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDZDQUE2QztBQUM3QyxPQUFPO0FBQ1A7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLE9BQU8sa0RBQWtEO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTyxrREFBa0Q7QUFDekQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsbUNBQW1DLGdFQUFnRTtBQUNuRztBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0M7QUFDaEM7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLG1CQUFtQixxQkFBcUI7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsdUJBQXVCLFNBQVM7QUFDaEM7QUFDQSwyQ0FBMkM7QUFDM0M7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsdUJBQXVCLE9BQU8sZ0NBQWdDO0FBQy9FLHdEQUF3RCxvQkFBb0I7QUFDNUU7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLGdFQUFnRTtBQUMzRixPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DLGlDQUFpQztBQUNwRTtBQUNBLE9BQU87QUFDUDtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLDJEQUEyRCxvQkFBb0I7QUFDL0U7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLHFCQUFxQixrQkFBa0I7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNEQUFzRCxnQ0FBZ0M7QUFDdEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLHVCQUF1QjtBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSw0QkFBNEIsNkJBQTZCO0FBQ3pEO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsd0JBQXdCO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLHlCQUF5QjtBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDLHlCQUF5QjtBQUMxRDtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxxQkFBcUIsMkJBQTJCO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxxQkFBcUIsOEJBQThCO0FBQ25EO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxpQkFBaUI7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDRFQUE0RTtBQUM1RTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0M7QUFDeEM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGFBQWEsZ0JBQWdCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QyxrQkFBa0I7QUFDMUQsS0FBSztBQUNMLHdDQUF3QyxrQkFBa0I7QUFDMUQsS0FBSztBQUNMLHdDQUF3QywwQkFBMEI7QUFDbEUsS0FBSztBQUNMLHdDQUF3QyxpQkFBaUI7QUFDekQsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsbUNBQW1DO0FBQ25DLG1DQUFtQztBQUNuQywyQ0FBMkM7QUFDM0MsMkJBQTJCO0FBQzNCLDJCQUEyQjtBQUMzQiw0QkFBNEI7QUFDNUIsNEJBQTRCO0FBQzVCLDJCQUEyQjtBQUMzQiwyQkFBMkI7QUFDM0I7QUFDQSx1QkFBdUI7QUFDdkI7QUFDQTtBQUNBO0FBQ0EsY0FBYyxRQUFRO0FBQ3RCO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGVBQWUsb0JBQW9CO0FBQ25DO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7OztBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQyxlQUFlLEVBQUUsdUJBQXVCLFVBQVUsRUFBRTtBQUNwRjtBQUNBOztBQUVBO0FBQ0EsbURBQW1ELDZDQUE2QztBQUNoRztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLDZDQUE2QztBQUN4RTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQywyQkFBMkI7QUFDN0Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EscURBQXFEO0FBQ3JELEdBQUc7QUFDSCx5Q0FBeUM7QUFDekM7O0FBRUEsaUNBQWlDLHdDQUF3QztBQUN6RTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQyxPQUFPO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQyxPQUFPO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esd0RBQXdELG1CQUFtQjtBQUMzRTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7O0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixhQUFhO0FBQ3BDLHVCQUF1QixhQUFhO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlGQUFpRjtBQUNqRiw0QkFBNEI7QUFDNUI7QUFDQSwyQkFBMkI7QUFDM0Isd0JBQXdCLGlFQUFpRTtBQUN6RixZQUFZLDBGQUEwRjtBQUN0RyxNQUFNLEtBQUssMENBQTBDO0FBQ3JEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDLGtCQUFrQjtBQUMvRCxzQkFBc0IsK0NBQStDO0FBQ3JFLGlEQUFpRDs7QUFFakQ7QUFDQSxzREFBc0Q7QUFDdEQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSw4Q0FBOEM7QUFDOUM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDO0FBQzNDOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLDJCQUEyQjtBQUN0RCxrQ0FBa0M7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7O0FBRUE7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU8sNkNBQTZDLEVBQUU7QUFDdEQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esa0NBQWtDO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSx3QkFBd0I7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQSx1Q0FBdUMsU0FBUztBQUNoRDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsd0JBQXdCO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLG9EQUFvRCw0QkFBNEIsRUFBRTtBQUNsRixLQUFLO0FBQ0w7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLG9EQUFvRCwrQkFBK0IsRUFBRTtBQUNyRixLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDLGFBQWE7O0FBRTNEO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkRBQTZEO0FBQzdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxpQ0FBaUMscUNBQXFDOztBQUV0RTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkMsdUNBQXVDLEVBQUU7QUFDcEY7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDLDJDQUEyQyxFQUFFO0FBQzFGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDLE9BQU87QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHFDQUFxQyw4QkFBOEIsRUFBRTtBQUNyRTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsNEJBQTRCO0FBQzVCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBOztBQUVBO0FBQ0EsK0JBQStCO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULE9BQU87QUFDUDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLGtDQUFrQyx1Q0FBdUM7O0FBRXpFLHFDQUFxQywwQkFBMEI7O0FBRS9EO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsOENBQThDO0FBQzlDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdEQUF3RDtBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QyxnQkFBZ0I7QUFDeEQ7QUFDQTtBQUNBLGdFQUFnRSxzQkFBc0IsRUFBRTtBQUN4RjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxtQkFBbUIsd0JBQXdCO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLHVCQUF1QjtBQUNsQyxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QiwyQkFBMkI7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLEtBQUs7QUFDTCxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzREFBc0QseUJBQXlCLEVBQUU7QUFDakY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBOztBQUVBLHNCQUFzQixFQUFFLGlCQUFpQixFQUFFO0FBQzNDLCtCQUErQjs7QUFFL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOzs7O0FBSUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0Isa0JBQWtCO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0MsT0FBTztBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0MsT0FBTztBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtB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QUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixTQUFTO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLHVCQUF1QjtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FBSUE7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnRUFBZ0U7QUFDaEU7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwREFBMEQ7QUFDMUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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Q0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDLE9BQU87QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1REFBdUQsV0FBVztBQUNsRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSwrQ0FBK0MsT0FBTztBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVEQUF1RCxXQUFXO0FBQ2xFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSx3QkFBd0I7QUFDeEI7QUFDQTtBQUNBLHdCQUF3QjtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLDZCQUE2QjtBQUM3Qjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7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O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esd0JBQXdCO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQztBQUNyQzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFZSw0REFBRyxFQUFDIiwiZmlsZSI6IjExMy5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8qIVxuICogVnVlLmpzIHYyLjYuMTBcbiAqIChjKSAyMDE0LTIwMTkgRXZhbiBZb3VcbiAqIFJlbGVhc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cbiAqL1xuLyogICovXG5cbnZhciBlbXB0eU9iamVjdCA9IE9iamVjdC5mcmVlemUoe30pO1xuXG4vLyBUaGVzZSBoZWxwZXJzIHByb2R1Y2UgYmV0dGVyIFZNIGNvZGUgaW4gSlMgZW5naW5lcyBkdWUgdG8gdGhlaXJcbi8vIGV4cGxpY2l0bmVzcyBhbmQgZnVuY3Rpb24gaW5saW5pbmcuXG5mdW5jdGlvbiBpc1VuZGVmICh2KSB7XG4gIHJldHVybiB2ID09PSB1bmRlZmluZWQgfHwgdiA9PT0gbnVsbFxufVxuXG5mdW5jdGlvbiBpc0RlZiAodikge1xuICByZXR1cm4gdiAhPT0gdW5kZWZpbmVkICYmIHYgIT09IG51bGxcbn1cblxuZnVuY3Rpb24gaXNUcnVlICh2KSB7XG4gIHJldHVybiB2ID09PSB0cnVlXG59XG5cbmZ1bmN0aW9uIGlzRmFsc2UgKHYpIHtcbiAgcmV0dXJuIHYgPT09IGZhbHNlXG59XG5cbi8qKlxuICogQ2hlY2sgaWYgdmFsdWUgaXMgcHJpbWl0aXZlLlxuICovXG5mdW5jdGlvbiBpc1ByaW1pdGl2ZSAodmFsdWUpIHtcbiAgcmV0dXJuIChcbiAgICB0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnIHx8XG4gICAgdHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJyB8fFxuICAgIC8vICRmbG93LWRpc2FibGUtbGluZVxuICAgIHR5cGVvZiB2YWx1ZSA9PT0gJ3N5bWJvbCcgfHxcbiAgICB0eXBlb2YgdmFsdWUgPT09ICdib29sZWFuJ1xuICApXG59XG5cbi8qKlxuICogUXVpY2sgb2JqZWN0IGNoZWNrIC0gdGhpcyBpcyBwcmltYXJpbHkgdXNlZCB0byB0ZWxsXG4gKiBPYmplY3RzIGZyb20gcHJpbWl0aXZlIHZhbHVlcyB3aGVuIHdlIGtub3cgdGhlIHZhbHVlXG4gKiBpcyBhIEpTT04tY29tcGxpYW50IHR5cGUuXG4gKi9cbmZ1bmN0aW9uIGlzT2JqZWN0IChvYmopIHtcbiAgcmV0dXJuIG9iaiAhPT0gbnVsbCAmJiB0eXBlb2Ygb2JqID09PSAnb2JqZWN0J1xufVxuXG4vKipcbiAqIEdldCB0aGUgcmF3IHR5cGUgc3RyaW5nIG9mIGEgdmFsdWUsIGUuZy4sIFtvYmplY3QgT2JqZWN0XS5cbiAqL1xudmFyIF90b1N0cmluZyA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmc7XG5cbmZ1bmN0aW9uIHRvUmF3VHlwZSAodmFsdWUpIHtcbiAgcmV0dXJuIF90b1N0cmluZy5jYWxsKHZhbHVlKS5zbGljZSg4LCAtMSlcbn1cblxuLyoqXG4gKiBTdHJpY3Qgb2JqZWN0IHR5cGUgY2hlY2suIE9ubHkgcmV0dXJucyB0cnVlXG4gKiBmb3IgcGxhaW4gSmF2YVNjcmlwdCBvYmplY3RzLlxuICovXG5mdW5jdGlvbiBpc1BsYWluT2JqZWN0IChvYmopIHtcbiAgcmV0dXJuIF90b1N0cmluZy5jYWxsKG9iaikgPT09ICdbb2JqZWN0IE9iamVjdF0nXG59XG5cbmZ1bmN0aW9uIGlzUmVnRXhwICh2KSB7XG4gIHJldHVybiBfdG9TdHJpbmcuY2FsbCh2KSA9PT0gJ1tvYmplY3QgUmVnRXhwXSdcbn1cblxuLyoqXG4gKiBDaGVjayBpZiB2YWwgaXMgYSB2YWxpZCBhcnJheSBpbmRleC5cbiAqL1xuZnVuY3Rpb24gaXNWYWxpZEFycmF5SW5kZXggKHZhbCkge1xuICB2YXIgbiA9IHBhcnNlRmxvYXQoU3RyaW5nKHZhbCkpO1xuICByZXR1cm4gbiA+PSAwICYmIE1hdGguZmxvb3IobikgPT09IG4gJiYgaXNGaW5pdGUodmFsKVxufVxuXG5mdW5jdGlvbiBpc1Byb21pc2UgKHZhbCkge1xuICByZXR1cm4gKFxuICAgIGlzRGVmKHZhbCkgJiZcbiAgICB0eXBlb2YgdmFsLnRoZW4gPT09ICdmdW5jdGlvbicgJiZcbiAgICB0eXBlb2YgdmFsLmNhdGNoID09PSAnZnVuY3Rpb24nXG4gIClcbn1cblxuLyoqXG4gKiBDb252ZXJ0IGEgdmFsdWUgdG8gYSBzdHJpbmcgdGhhdCBpcyBhY3R1YWxseSByZW5kZXJlZC5cbiAqL1xuZnVuY3Rpb24gdG9TdHJpbmcgKHZhbCkge1xuICByZXR1cm4gdmFsID09IG51bGxcbiAgICA/ICcnXG4gICAgOiBBcnJheS5pc0FycmF5KHZhbCkgfHwgKGlzUGxhaW5PYmplY3QodmFsKSAmJiB2YWwudG9TdHJpbmcgPT09IF90b1N0cmluZylcbiAgICAgID8gSlNPTi5zdHJpbmdpZnkodmFsLCBudWxsLCAyKVxuICAgICAgOiBTdHJpbmcodmFsKVxufVxuXG4vKipcbiAqIENvbnZlcnQgYW4gaW5wdXQgdmFsdWUgdG8gYSBudW1iZXIgZm9yIHBlcnNpc3RlbmNlLlxuICogSWYgdGhlIGNvbnZlcnNpb24gZmFpbHMsIHJldHVybiBvcmlnaW5hbCBzdHJpbmcuXG4gKi9cbmZ1bmN0aW9uIHRvTnVtYmVyICh2YWwpIHtcbiAgdmFyIG4gPSBwYXJzZUZsb2F0KHZhbCk7XG4gIHJldHVybiBpc05hTihuKSA/IHZhbCA6IG5cbn1cblxuLyoqXG4gKiBNYWtlIGEgbWFwIGFuZCByZXR1cm4gYSBmdW5jdGlvbiBmb3IgY2hlY2tpbmcgaWYgYSBrZXlcbiAqIGlzIGluIHRoYXQgbWFwLlxuICovXG5mdW5jdGlvbiBtYWtlTWFwIChcbiAgc3RyLFxuICBleHBlY3RzTG93ZXJDYXNlXG4pIHtcbiAgdmFyIG1hcCA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gIHZhciBsaXN0ID0gc3RyLnNwbGl0KCcsJyk7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGlzdC5sZW5ndGg7IGkrKykge1xuICAgIG1hcFtsaXN0W2ldXSA9IHRydWU7XG4gIH1cbiAgcmV0dXJuIGV4cGVjdHNMb3dlckNhc2VcbiAgICA/IGZ1bmN0aW9uICh2YWwpIHsgcmV0dXJuIG1hcFt2YWwudG9Mb3dlckNhc2UoKV07IH1cbiAgICA6IGZ1bmN0aW9uICh2YWwpIHsgcmV0dXJuIG1hcFt2YWxdOyB9XG59XG5cbi8qKlxuICogQ2hlY2sgaWYgYSB0YWcgaXMgYSBidWlsdC1pbiB0YWcuXG4gKi9cbnZhciBpc0J1aWx0SW5UYWcgPSBtYWtlTWFwKCdzbG90LGNvbXBvbmVudCcsIHRydWUpO1xuXG4vKipcbiAqIENoZWNrIGlmIGFuIGF0dHJpYnV0ZSBpcyBhIHJlc2VydmVkIGF0dHJpYnV0ZS5cbiAqL1xudmFyIGlzUmVzZXJ2ZWRBdHRyaWJ1dGUgPSBtYWtlTWFwKCdrZXkscmVmLHNsb3Qsc2xvdC1zY29wZSxpcycpO1xuXG4vKipcbiAqIFJlbW92ZSBhbiBpdGVtIGZyb20gYW4gYXJyYXkuXG4gKi9cbmZ1bmN0aW9uIHJlbW92ZSAoYXJyLCBpdGVtKSB7XG4gIGlmIChhcnIubGVuZ3RoKSB7XG4gICAgdmFyIGluZGV4ID0gYXJyLmluZGV4T2YoaXRlbSk7XG4gICAgaWYgKGluZGV4ID4gLTEpIHtcbiAgICAgIHJldHVybiBhcnIuc3BsaWNlKGluZGV4LCAxKVxuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIENoZWNrIHdoZXRoZXIgYW4gb2JqZWN0IGhhcyB0aGUgcHJvcGVydHkuXG4gKi9cbnZhciBoYXNPd25Qcm9wZXJ0eSA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG5mdW5jdGlvbiBoYXNPd24gKG9iaiwga2V5KSB7XG4gIHJldHVybiBoYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwga2V5KVxufVxuXG4vKipcbiAqIENyZWF0ZSBhIGNhY2hlZCB2ZXJzaW9uIG9mIGEgcHVyZSBmdW5jdGlvbi5cbiAqL1xuZnVuY3Rpb24gY2FjaGVkIChmbikge1xuICB2YXIgY2FjaGUgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICByZXR1cm4gKGZ1bmN0aW9uIGNhY2hlZEZuIChzdHIpIHtcbiAgICB2YXIgaGl0ID0gY2FjaGVbc3RyXTtcbiAgICByZXR1cm4gaGl0IHx8IChjYWNoZVtzdHJdID0gZm4oc3RyKSlcbiAgfSlcbn1cblxuLyoqXG4gKiBDYW1lbGl6ZSBhIGh5cGhlbi1kZWxpbWl0ZWQgc3RyaW5nLlxuICovXG52YXIgY2FtZWxpemVSRSA9IC8tKFxcdykvZztcbnZhciBjYW1lbGl6ZSA9IGNhY2hlZChmdW5jdGlvbiAoc3RyKSB7XG4gIHJldHVybiBzdHIucmVwbGFjZShjYW1lbGl6ZVJFLCBmdW5jdGlvbiAoXywgYykgeyByZXR1cm4gYyA/IGMudG9VcHBlckNhc2UoKSA6ICcnOyB9KVxufSk7XG5cbi8qKlxuICogQ2FwaXRhbGl6ZSBhIHN0cmluZy5cbiAqL1xudmFyIGNhcGl0YWxpemUgPSBjYWNoZWQoZnVuY3Rpb24gKHN0cikge1xuICByZXR1cm4gc3RyLmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpICsgc3RyLnNsaWNlKDEpXG59KTtcblxuLyoqXG4gKiBIeXBoZW5hdGUgYSBjYW1lbENhc2Ugc3RyaW5nLlxuICovXG52YXIgaHlwaGVuYXRlUkUgPSAvXFxCKFtBLVpdKS9nO1xudmFyIGh5cGhlbmF0ZSA9IGNhY2hlZChmdW5jdGlvbiAoc3RyKSB7XG4gIHJldHVybiBzdHIucmVwbGFjZShoeXBoZW5hdGVSRSwgJy0kMScpLnRvTG93ZXJDYXNlKClcbn0pO1xuXG4vKipcbiAqIFNpbXBsZSBiaW5kIHBvbHlmaWxsIGZvciBlbnZpcm9ubWVudHMgdGhhdCBkbyBub3Qgc3VwcG9ydCBpdCxcbiAqIGUuZy4sIFBoYW50b21KUyAxLnguIFRlY2huaWNhbGx5LCB3ZSBkb24ndCBuZWVkIHRoaXMgYW55bW9yZVxuICogc2luY2UgbmF0aXZlIGJpbmQgaXMgbm93IHBlcmZvcm1hbnQgZW5vdWdoIGluIG1vc3QgYnJvd3NlcnMuXG4gKiBCdXQgcmVtb3ZpbmcgaXQgd291bGQgbWVhbiBicmVha2luZyBjb2RlIHRoYXQgd2FzIGFibGUgdG8gcnVuIGluXG4gKiBQaGFudG9tSlMgMS54LCBzbyB0aGlzIG11c3QgYmUga2VwdCBmb3IgYmFja3dhcmQgY29tcGF0aWJpbGl0eS5cbiAqL1xuXG4vKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuZnVuY3Rpb24gcG9seWZpbGxCaW5kIChmbiwgY3R4KSB7XG4gIGZ1bmN0aW9uIGJvdW5kRm4gKGEpIHtcbiAgICB2YXIgbCA9IGFyZ3VtZW50cy5sZW5ndGg7XG4gICAgcmV0dXJuIGxcbiAgICAgID8gbCA+IDFcbiAgICAgICAgPyBmbi5hcHBseShjdHgsIGFyZ3VtZW50cylcbiAgICAgICAgOiBmbi5jYWxsKGN0eCwgYSlcbiAgICAgIDogZm4uY2FsbChjdHgpXG4gIH1cblxuICBib3VuZEZuLl9sZW5ndGggPSBmbi5sZW5ndGg7XG4gIHJldHVybiBib3VuZEZuXG59XG5cbmZ1bmN0aW9uIG5hdGl2ZUJpbmQgKGZuLCBjdHgpIHtcbiAgcmV0dXJuIGZuLmJpbmQoY3R4KVxufVxuXG52YXIgYmluZCA9IEZ1bmN0aW9uLnByb3RvdHlwZS5iaW5kXG4gID8gbmF0aXZlQmluZFxuICA6IHBvbHlmaWxsQmluZDtcblxuLyoqXG4gKiBDb252ZXJ0IGFuIEFycmF5LWxpa2Ugb2JqZWN0IHRvIGEgcmVhbCBBcnJheS5cbiAqL1xuZnVuY3Rpb24gdG9BcnJheSAobGlzdCwgc3RhcnQpIHtcbiAgc3RhcnQgPSBzdGFydCB8fCAwO1xuICB2YXIgaSA9IGxpc3QubGVuZ3RoIC0gc3RhcnQ7XG4gIHZhciByZXQgPSBuZXcgQXJyYXkoaSk7XG4gIHdoaWxlIChpLS0pIHtcbiAgICByZXRbaV0gPSBsaXN0W2kgKyBzdGFydF07XG4gIH1cbiAgcmV0dXJuIHJldFxufVxuXG4vKipcbiAqIE1peCBwcm9wZXJ0aWVzIGludG8gdGFyZ2V0IG9iamVjdC5cbiAqL1xuZnVuY3Rpb24gZXh0ZW5kICh0bywgX2Zyb20pIHtcbiAgZm9yICh2YXIga2V5IGluIF9mcm9tKSB7XG4gICAgdG9ba2V5XSA9IF9mcm9tW2tleV07XG4gIH1cbiAgcmV0dXJuIHRvXG59XG5cbi8qKlxuICogTWVyZ2UgYW4gQXJyYXkgb2YgT2JqZWN0cyBpbnRvIGEgc2luZ2xlIE9iamVjdC5cbiAqL1xuZnVuY3Rpb24gdG9PYmplY3QgKGFycikge1xuICB2YXIgcmVzID0ge307XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgYXJyLmxlbmd0aDsgaSsrKSB7XG4gICAgaWYgKGFycltpXSkge1xuICAgICAgZXh0ZW5kKHJlcywgYXJyW2ldKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc1xufVxuXG4vKiBlc2xpbnQtZGlzYWJsZSBuby11bnVzZWQtdmFycyAqL1xuXG4vKipcbiAqIFBlcmZvcm0gbm8gb3BlcmF0aW9uLlxuICogU3R1YmJpbmcgYXJncyB0byBtYWtlIEZsb3cgaGFwcHkgd2l0aG91dCBsZWF2aW5nIHVzZWxlc3MgdHJhbnNwaWxlZCBjb2RlXG4gKiB3aXRoIC4uLnJlc3QgKGh0dHBzOi8vZmxvdy5vcmcvYmxvZy8yMDE3LzA1LzA3L1N0cmljdC1GdW5jdGlvbi1DYWxsLUFyaXR5LykuXG4gKi9cbmZ1bmN0aW9uIG5vb3AgKGEsIGIsIGMpIHt9XG5cbi8qKlxuICogQWx3YXlzIHJldHVybiBmYWxzZS5cbiAqL1xudmFyIG5vID0gZnVuY3Rpb24gKGEsIGIsIGMpIHsgcmV0dXJuIGZhbHNlOyB9O1xuXG4vKiBlc2xpbnQtZW5hYmxlIG5vLXVudXNlZC12YXJzICovXG5cbi8qKlxuICogUmV0dXJuIHRoZSBzYW1lIHZhbHVlLlxuICovXG52YXIgaWRlbnRpdHkgPSBmdW5jdGlvbiAoXykgeyByZXR1cm4gXzsgfTtcblxuLyoqXG4gKiBHZW5lcmF0ZSBhIHN0cmluZyBjb250YWluaW5nIHN0YXRpYyBrZXlzIGZyb20gY29tcGlsZXIgbW9kdWxlcy5cbiAqL1xuZnVuY3Rpb24gZ2VuU3RhdGljS2V5cyAobW9kdWxlcykge1xuICByZXR1cm4gbW9kdWxlcy5yZWR1Y2UoZnVuY3Rpb24gKGtleXMsIG0pIHtcbiAgICByZXR1cm4ga2V5cy5jb25jYXQobS5zdGF0aWNLZXlzIHx8IFtdKVxuICB9LCBbXSkuam9pbignLCcpXG59XG5cbi8qKlxuICogQ2hlY2sgaWYgdHdvIHZhbHVlcyBhcmUgbG9vc2VseSBlcXVhbCAtIHRoYXQgaXMsXG4gKiBpZiB0aGV5IGFyZSBwbGFpbiBvYmplY3RzLCBkbyB0aGV5IGhhdmUgdGhlIHNhbWUgc2hhcGU/XG4gKi9cbmZ1bmN0aW9uIGxvb3NlRXF1YWwgKGEsIGIpIHtcbiAgaWYgKGEgPT09IGIpIHsgcmV0dXJuIHRydWUgfVxuICB2YXIgaXNPYmplY3RBID0gaXNPYmplY3QoYSk7XG4gIHZhciBpc09iamVjdEIgPSBpc09iamVjdChiKTtcbiAgaWYgKGlzT2JqZWN0QSAmJiBpc09iamVjdEIpIHtcbiAgICB0cnkge1xuICAgICAgdmFyIGlzQXJyYXlBID0gQXJyYXkuaXNBcnJheShhKTtcbiAgICAgIHZhciBpc0FycmF5QiA9IEFycmF5LmlzQXJyYXkoYik7XG4gICAgICBpZiAoaXNBcnJheUEgJiYgaXNBcnJheUIpIHtcbiAgICAgICAgcmV0dXJuIGEubGVuZ3RoID09PSBiLmxlbmd0aCAmJiBhLmV2ZXJ5KGZ1bmN0aW9uIChlLCBpKSB7XG4gICAgICAgICAgcmV0dXJuIGxvb3NlRXF1YWwoZSwgYltpXSlcbiAgICAgICAgfSlcbiAgICAgIH0gZWxzZSBpZiAoYSBpbnN0YW5jZW9mIERhdGUgJiYgYiBpbnN0YW5jZW9mIERhdGUpIHtcbiAgICAgICAgcmV0dXJuIGEuZ2V0VGltZSgpID09PSBiLmdldFRpbWUoKVxuICAgICAgfSBlbHNlIGlmICghaXNBcnJheUEgJiYgIWlzQXJyYXlCKSB7XG4gICAgICAgIHZhciBrZXlzQSA9IE9iamVjdC5rZXlzKGEpO1xuICAgICAgICB2YXIga2V5c0IgPSBPYmplY3Qua2V5cyhiKTtcbiAgICAgICAgcmV0dXJuIGtleXNBLmxlbmd0aCA9PT0ga2V5c0IubGVuZ3RoICYmIGtleXNBLmV2ZXJ5KGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgICByZXR1cm4gbG9vc2VFcXVhbChhW2tleV0sIGJba2V5XSlcbiAgICAgICAgfSlcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgfVxuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgICByZXR1cm4gZmFsc2VcbiAgICB9XG4gIH0gZWxzZSBpZiAoIWlzT2JqZWN0QSAmJiAhaXNPYmplY3RCKSB7XG4gICAgcmV0dXJuIFN0cmluZyhhKSA9PT0gU3RyaW5nKGIpXG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cbn1cblxuLyoqXG4gKiBSZXR1cm4gdGhlIGZpcnN0IGluZGV4IGF0IHdoaWNoIGEgbG9vc2VseSBlcXVhbCB2YWx1ZSBjYW4gYmVcbiAqIGZvdW5kIGluIHRoZSBhcnJheSAoaWYgdmFsdWUgaXMgYSBwbGFpbiBvYmplY3QsIHRoZSBhcnJheSBtdXN0XG4gKiBjb250YWluIGFuIG9iamVjdCBvZiB0aGUgc2FtZSBzaGFwZSksIG9yIC0xIGlmIGl0IGlzIG5vdCBwcmVzZW50LlxuICovXG5mdW5jdGlvbiBsb29zZUluZGV4T2YgKGFyciwgdmFsKSB7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgYXJyLmxlbmd0aDsgaSsrKSB7XG4gICAgaWYgKGxvb3NlRXF1YWwoYXJyW2ldLCB2YWwpKSB7IHJldHVybiBpIH1cbiAgfVxuICByZXR1cm4gLTFcbn1cblxuLyoqXG4gKiBFbnN1cmUgYSBmdW5jdGlvbiBpcyBjYWxsZWQgb25seSBvbmNlLlxuICovXG5mdW5jdGlvbiBvbmNlIChmbikge1xuICB2YXIgY2FsbGVkID0gZmFsc2U7XG4gIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKCFjYWxsZWQpIHtcbiAgICAgIGNhbGxlZCA9IHRydWU7XG4gICAgICBmbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH1cbiAgfVxufVxuXG52YXIgU1NSX0FUVFIgPSAnZGF0YS1zZXJ2ZXItcmVuZGVyZWQnO1xuXG52YXIgQVNTRVRfVFlQRVMgPSBbXG4gICdjb21wb25lbnQnLFxuICAnZGlyZWN0aXZlJyxcbiAgJ2ZpbHRlcidcbl07XG5cbnZhciBMSUZFQ1lDTEVfSE9PS1MgPSBbXG4gICdiZWZvcmVDcmVhdGUnLFxuICAnY3JlYXRlZCcsXG4gICdiZWZvcmVNb3VudCcsXG4gICdtb3VudGVkJyxcbiAgJ2JlZm9yZVVwZGF0ZScsXG4gICd1cGRhdGVkJyxcbiAgJ2JlZm9yZURlc3Ryb3knLFxuICAnZGVzdHJveWVkJyxcbiAgJ2FjdGl2YXRlZCcsXG4gICdkZWFjdGl2YXRlZCcsXG4gICdlcnJvckNhcHR1cmVkJyxcbiAgJ3NlcnZlclByZWZldGNoJ1xuXTtcblxuLyogICovXG5cblxuXG52YXIgY29uZmlnID0gKHtcbiAgLyoqXG4gICAqIE9wdGlvbiBtZXJnZSBzdHJhdGVnaWVzICh1c2VkIGluIGNvcmUvdXRpbC9vcHRpb25zKVxuICAgKi9cbiAgLy8gJGZsb3ctZGlzYWJsZS1saW5lXG4gIG9wdGlvbk1lcmdlU3RyYXRlZ2llczogT2JqZWN0LmNyZWF0ZShudWxsKSxcblxuICAvKipcbiAgICogV2hldGhlciB0byBzdXBwcmVzcyB3YXJuaW5ncy5cbiAgICovXG4gIHNpbGVudDogZmFsc2UsXG5cbiAgLyoqXG4gICAqIFNob3cgcHJvZHVjdGlvbiBtb2RlIHRpcCBtZXNzYWdlIG9uIGJvb3Q/XG4gICAqL1xuICBwcm9kdWN0aW9uVGlwOiBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nLFxuXG4gIC8qKlxuICAgKiBXaGV0aGVyIHRvIGVuYWJsZSBkZXZ0b29sc1xuICAgKi9cbiAgZGV2dG9vbHM6IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicsXG5cbiAgLyoqXG4gICAqIFdoZXRoZXIgdG8gcmVjb3JkIHBlcmZcbiAgICovXG4gIHBlcmZvcm1hbmNlOiBmYWxzZSxcblxuICAvKipcbiAgICogRXJyb3IgaGFuZGxlciBmb3Igd2F0Y2hlciBlcnJvcnNcbiAgICovXG4gIGVycm9ySGFuZGxlcjogbnVsbCxcblxuICAvKipcbiAgICogV2FybiBoYW5kbGVyIGZvciB3YXRjaGVyIHdhcm5zXG4gICAqL1xuICB3YXJuSGFuZGxlcjogbnVsbCxcblxuICAvKipcbiAgICogSWdub3JlIGNlcnRhaW4gY3VzdG9tIGVsZW1lbnRzXG4gICAqL1xuICBpZ25vcmVkRWxlbWVudHM6IFtdLFxuXG4gIC8qKlxuICAgKiBDdXN0b20gdXNlciBrZXkgYWxpYXNlcyBmb3Igdi1vblxuICAgKi9cbiAgLy8gJGZsb3ctZGlzYWJsZS1saW5lXG4gIGtleUNvZGVzOiBPYmplY3QuY3JlYXRlKG51bGwpLFxuXG4gIC8qKlxuICAgKiBDaGVjayBpZiBhIHRhZyBpcyByZXNlcnZlZCBzbyB0aGF0IGl0IGNhbm5vdCBiZSByZWdpc3RlcmVkIGFzIGFcbiAgICogY29tcG9uZW50LiBUaGlzIGlzIHBsYXRmb3JtLWRlcGVuZGVudCBhbmQgbWF5IGJlIG92ZXJ3cml0dGVuLlxuICAgKi9cbiAgaXNSZXNlcnZlZFRhZzogbm8sXG5cbiAgLyoqXG4gICAqIENoZWNrIGlmIGFuIGF0dHJpYnV0ZSBpcyByZXNlcnZlZCBzbyB0aGF0IGl0IGNhbm5vdCBiZSB1c2VkIGFzIGEgY29tcG9uZW50XG4gICAqIHByb3AuIFRoaXMgaXMgcGxhdGZvcm0tZGVwZW5kZW50IGFuZCBtYXkgYmUgb3ZlcndyaXR0ZW4uXG4gICAqL1xuICBpc1Jlc2VydmVkQXR0cjogbm8sXG5cbiAgLyoqXG4gICAqIENoZWNrIGlmIGEgdGFnIGlzIGFuIHVua25vd24gZWxlbWVudC5cbiAgICogUGxhdGZvcm0tZGVwZW5kZW50LlxuICAgKi9cbiAgaXNVbmtub3duRWxlbWVudDogbm8sXG5cbiAgLyoqXG4gICAqIEdldCB0aGUgbmFtZXNwYWNlIG9mIGFuIGVsZW1lbnRcbiAgICovXG4gIGdldFRhZ05hbWVzcGFjZTogbm9vcCxcblxuICAvKipcbiAgICogUGFyc2UgdGhlIHJlYWwgdGFnIG5hbWUgZm9yIHRoZSBzcGVjaWZpYyBwbGF0Zm9ybS5cbiAgICovXG4gIHBhcnNlUGxhdGZvcm1UYWdOYW1lOiBpZGVudGl0eSxcblxuICAvKipcbiAgICogQ2hlY2sgaWYgYW4gYXR0cmlidXRlIG11c3QgYmUgYm91bmQgdXNpbmcgcHJvcGVydHksIGUuZy4gdmFsdWVcbiAgICogUGxhdGZvcm0tZGVwZW5kZW50LlxuICAgKi9cbiAgbXVzdFVzZVByb3A6IG5vLFxuXG4gIC8qKlxuICAgKiBQZXJmb3JtIHVwZGF0ZXMgYXN5bmNocm9ub3VzbHkuIEludGVuZGVkIHRvIGJlIHVzZWQgYnkgVnVlIFRlc3QgVXRpbHNcbiAgICogVGhpcyB3aWxsIHNpZ25pZmljYW50bHkgcmVkdWNlIHBlcmZvcm1hbmNlIGlmIHNldCB0byBmYWxzZS5cbiAgICovXG4gIGFzeW5jOiB0cnVlLFxuXG4gIC8qKlxuICAgKiBFeHBvc2VkIGZvciBsZWdhY3kgcmVhc29uc1xuICAgKi9cbiAgX2xpZmVjeWNsZUhvb2tzOiBMSUZFQ1lDTEVfSE9PS1Ncbn0pO1xuXG4vKiAgKi9cblxuLyoqXG4gKiB1bmljb2RlIGxldHRlcnMgdXNlZCBmb3IgcGFyc2luZyBodG1sIHRhZ3MsIGNvbXBvbmVudCBuYW1lcyBhbmQgcHJvcGVydHkgcGF0aHMuXG4gKiB1c2luZyBodHRwczovL3d3dy53My5vcmcvVFIvaHRtbDUzL3NlbWFudGljcy1zY3JpcHRpbmcuaHRtbCNwb3RlbnRpYWxjdXN0b21lbGVtZW50bmFtZVxuICogc2tpcHBpbmcgXFx1MTAwMDAtXFx1RUZGRkYgZHVlIHRvIGl0IGZyZWV6aW5nIHVwIFBoYW50b21KU1xuICovXG52YXIgdW5pY29kZVJlZ0V4cCA9IC9hLXpBLVpcXHUwMEI3XFx1MDBDMC1cXHUwMEQ2XFx1MDBEOC1cXHUwMEY2XFx1MDBGOC1cXHUwMzdEXFx1MDM3Ri1cXHUxRkZGXFx1MjAwQy1cXHUyMDBEXFx1MjAzRi1cXHUyMDQwXFx1MjA3MC1cXHUyMThGXFx1MkMwMC1cXHUyRkVGXFx1MzAwMS1cXHVEN0ZGXFx1RjkwMC1cXHVGRENGXFx1RkRGMC1cXHVGRkZELztcblxuLyoqXG4gKiBDaGVjayBpZiBhIHN0cmluZyBzdGFydHMgd2l0aCAkIG9yIF9cbiAqL1xuZnVuY3Rpb24gaXNSZXNlcnZlZCAoc3RyKSB7XG4gIHZhciBjID0gKHN0ciArICcnKS5jaGFyQ29kZUF0KDApO1xuICByZXR1cm4gYyA9PT0gMHgyNCB8fCBjID09PSAweDVGXG59XG5cbi8qKlxuICogRGVmaW5lIGEgcHJvcGVydHkuXG4gKi9cbmZ1bmN0aW9uIGRlZiAob2JqLCBrZXksIHZhbCwgZW51bWVyYWJsZSkge1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHtcbiAgICB2YWx1ZTogdmFsLFxuICAgIGVudW1lcmFibGU6ICEhZW51bWVyYWJsZSxcbiAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICBjb25maWd1cmFibGU6IHRydWVcbiAgfSk7XG59XG5cbi8qKlxuICogUGFyc2Ugc2ltcGxlIHBhdGguXG4gKi9cbnZhciBiYWlsUkUgPSBuZXcgUmVnRXhwKChcIlteXCIgKyAodW5pY29kZVJlZ0V4cC5zb3VyY2UpICsgXCIuJF9cXFxcZF1cIikpO1xuZnVuY3Rpb24gcGFyc2VQYXRoIChwYXRoKSB7XG4gIGlmIChiYWlsUkUudGVzdChwYXRoKSkge1xuICAgIHJldHVyblxuICB9XG4gIHZhciBzZWdtZW50cyA9IHBhdGguc3BsaXQoJy4nKTtcbiAgcmV0dXJuIGZ1bmN0aW9uIChvYmopIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNlZ21lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAoIW9iaikgeyByZXR1cm4gfVxuICAgICAgb2JqID0gb2JqW3NlZ21lbnRzW2ldXTtcbiAgICB9XG4gICAgcmV0dXJuIG9ialxuICB9XG59XG5cbi8qICAqL1xuXG4vLyBjYW4gd2UgdXNlIF9fcHJvdG9fXz9cbnZhciBoYXNQcm90byA9ICdfX3Byb3RvX18nIGluIHt9O1xuXG4vLyBCcm93c2VyIGVudmlyb25tZW50IHNuaWZmaW5nXG52YXIgaW5Ccm93c2VyID0gdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCc7XG52YXIgaW5XZWV4ID0gdHlwZW9mIFdYRW52aXJvbm1lbnQgIT09ICd1bmRlZmluZWQnICYmICEhV1hFbnZpcm9ubWVudC5wbGF0Zm9ybTtcbnZhciB3ZWV4UGxhdGZvcm0gPSBpbldlZXggJiYgV1hFbnZpcm9ubWVudC5wbGF0Zm9ybS50b0xvd2VyQ2FzZSgpO1xudmFyIFVBID0gaW5Ccm93c2VyICYmIHdpbmRvdy5uYXZpZ2F0b3IudXNlckFnZW50LnRvTG93ZXJDYXNlKCk7XG52YXIgaXNJRSA9IFVBICYmIC9tc2llfHRyaWRlbnQvLnRlc3QoVUEpO1xudmFyIGlzSUU5ID0gVUEgJiYgVUEuaW5kZXhPZignbXNpZSA5LjAnKSA+IDA7XG52YXIgaXNFZGdlID0gVUEgJiYgVUEuaW5kZXhPZignZWRnZS8nKSA+IDA7XG52YXIgaXNBbmRyb2lkID0gKFVBICYmIFVBLmluZGV4T2YoJ2FuZHJvaWQnKSA+IDApIHx8ICh3ZWV4UGxhdGZvcm0gPT09ICdhbmRyb2lkJyk7XG52YXIgaXNJT1MgPSAoVUEgJiYgL2lwaG9uZXxpcGFkfGlwb2R8aW9zLy50ZXN0KFVBKSkgfHwgKHdlZXhQbGF0Zm9ybSA9PT0gJ2lvcycpO1xudmFyIGlzQ2hyb21lID0gVUEgJiYgL2Nocm9tZVxcL1xcZCsvLnRlc3QoVUEpICYmICFpc0VkZ2U7XG52YXIgaXNQaGFudG9tSlMgPSBVQSAmJiAvcGhhbnRvbWpzLy50ZXN0KFVBKTtcbnZhciBpc0ZGID0gVUEgJiYgVUEubWF0Y2goL2ZpcmVmb3hcXC8oXFxkKykvKTtcblxuLy8gRmlyZWZveCBoYXMgYSBcIndhdGNoXCIgZnVuY3Rpb24gb24gT2JqZWN0LnByb3RvdHlwZS4uLlxudmFyIG5hdGl2ZVdhdGNoID0gKHt9KS53YXRjaDtcblxudmFyIHN1cHBvcnRzUGFzc2l2ZSA9IGZhbHNlO1xuaWYgKGluQnJvd3Nlcikge1xuICB0cnkge1xuICAgIHZhciBvcHRzID0ge307XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9wdHMsICdwYXNzaXZlJywgKHtcbiAgICAgIGdldDogZnVuY3Rpb24gZ2V0ICgpIHtcbiAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICAgICAgc3VwcG9ydHNQYXNzaXZlID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9KSk7IC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9mbG93L2lzc3Vlcy8yODVcbiAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcigndGVzdC1wYXNzaXZlJywgbnVsbCwgb3B0cyk7XG4gIH0gY2F0Y2ggKGUpIHt9XG59XG5cbi8vIHRoaXMgbmVlZHMgdG8gYmUgbGF6eS1ldmFsZWQgYmVjYXVzZSB2dWUgbWF5IGJlIHJlcXVpcmVkIGJlZm9yZVxuLy8gdnVlLXNlcnZlci1yZW5kZXJlciBjYW4gc2V0IFZVRV9FTlZcbnZhciBfaXNTZXJ2ZXI7XG52YXIgaXNTZXJ2ZXJSZW5kZXJpbmcgPSBmdW5jdGlvbiAoKSB7XG4gIGlmIChfaXNTZXJ2ZXIgPT09IHVuZGVmaW5lZCkge1xuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgIGlmICghaW5Ccm93c2VyICYmICFpbldlZXggJiYgdHlwZW9mIGdsb2JhbCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIC8vIGRldGVjdCBwcmVzZW5jZSBvZiB2dWUtc2VydmVyLXJlbmRlcmVyIGFuZCBhdm9pZFxuICAgICAgLy8gV2VicGFjayBzaGltbWluZyB0aGUgcHJvY2Vzc1xuICAgICAgX2lzU2VydmVyID0gZ2xvYmFsWydwcm9jZXNzJ10gJiYgZ2xvYmFsWydwcm9jZXNzJ10uZW52LlZVRV9FTlYgPT09ICdzZXJ2ZXInO1xuICAgIH0gZWxzZSB7XG4gICAgICBfaXNTZXJ2ZXIgPSBmYWxzZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIF9pc1NlcnZlclxufTtcblxuLy8gZGV0ZWN0IGRldnRvb2xzXG52YXIgZGV2dG9vbHMgPSBpbkJyb3dzZXIgJiYgd2luZG93Ll9fVlVFX0RFVlRPT0xTX0dMT0JBTF9IT09LX187XG5cbi8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG5mdW5jdGlvbiBpc05hdGl2ZSAoQ3Rvcikge1xuICByZXR1cm4gdHlwZW9mIEN0b3IgPT09ICdmdW5jdGlvbicgJiYgL25hdGl2ZSBjb2RlLy50ZXN0KEN0b3IudG9TdHJpbmcoKSlcbn1cblxudmFyIGhhc1N5bWJvbCA9XG4gIHR5cGVvZiBTeW1ib2wgIT09ICd1bmRlZmluZWQnICYmIGlzTmF0aXZlKFN5bWJvbCkgJiZcbiAgdHlwZW9mIFJlZmxlY3QgIT09ICd1bmRlZmluZWQnICYmIGlzTmF0aXZlKFJlZmxlY3Qub3duS2V5cyk7XG5cbnZhciBfU2V0O1xuLyogaXN0YW5idWwgaWdub3JlIGlmICovIC8vICRmbG93LWRpc2FibGUtbGluZVxuaWYgKHR5cGVvZiBTZXQgIT09ICd1bmRlZmluZWQnICYmIGlzTmF0aXZlKFNldCkpIHtcbiAgLy8gdXNlIG5hdGl2ZSBTZXQgd2hlbiBhdmFpbGFibGUuXG4gIF9TZXQgPSBTZXQ7XG59IGVsc2Uge1xuICAvLyBhIG5vbi1zdGFuZGFyZCBTZXQgcG9seWZpbGwgdGhhdCBvbmx5IHdvcmtzIHdpdGggcHJpbWl0aXZlIGtleXMuXG4gIF9TZXQgPSAvKkBfX1BVUkVfXyovKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBTZXQgKCkge1xuICAgICAgdGhpcy5zZXQgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgIH1cbiAgICBTZXQucHJvdG90eXBlLmhhcyA9IGZ1bmN0aW9uIGhhcyAoa2V5KSB7XG4gICAgICByZXR1cm4gdGhpcy5zZXRba2V5XSA9PT0gdHJ1ZVxuICAgIH07XG4gICAgU2V0LnByb3RvdHlwZS5hZGQgPSBmdW5jdGlvbiBhZGQgKGtleSkge1xuICAgICAgdGhpcy5zZXRba2V5XSA9IHRydWU7XG4gICAgfTtcbiAgICBTZXQucHJvdG90eXBlLmNsZWFyID0gZnVuY3Rpb24gY2xlYXIgKCkge1xuICAgICAgdGhpcy5zZXQgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgIH07XG5cbiAgICByZXR1cm4gU2V0O1xuICB9KCkpO1xufVxuXG4vKiAgKi9cblxudmFyIHdhcm4gPSBub29wO1xudmFyIHRpcCA9IG5vb3A7XG52YXIgZ2VuZXJhdGVDb21wb25lbnRUcmFjZSA9IChub29wKTsgLy8gd29yayBhcm91bmQgZmxvdyBjaGVja1xudmFyIGZvcm1hdENvbXBvbmVudE5hbWUgPSAobm9vcCk7XG5cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIHZhciBoYXNDb25zb2xlID0gdHlwZW9mIGNvbnNvbGUgIT09ICd1bmRlZmluZWQnO1xuICB2YXIgY2xhc3NpZnlSRSA9IC8oPzpefFstX10pKFxcdykvZztcbiAgdmFyIGNsYXNzaWZ5ID0gZnVuY3Rpb24gKHN0cikgeyByZXR1cm4gc3RyXG4gICAgLnJlcGxhY2UoY2xhc3NpZnlSRSwgZnVuY3Rpb24gKGMpIHsgcmV0dXJuIGMudG9VcHBlckNhc2UoKTsgfSlcbiAgICAucmVwbGFjZSgvWy1fXS9nLCAnJyk7IH07XG5cbiAgd2FybiA9IGZ1bmN0aW9uIChtc2csIHZtKSB7XG4gICAgdmFyIHRyYWNlID0gdm0gPyBnZW5lcmF0ZUNvbXBvbmVudFRyYWNlKHZtKSA6ICcnO1xuXG4gICAgaWYgKGNvbmZpZy53YXJuSGFuZGxlcikge1xuICAgICAgY29uZmlnLndhcm5IYW5kbGVyLmNhbGwobnVsbCwgbXNnLCB2bSwgdHJhY2UpO1xuICAgIH0gZWxzZSBpZiAoaGFzQ29uc29sZSAmJiAoIWNvbmZpZy5zaWxlbnQpKSB7XG4gICAgICBjb25zb2xlLmVycm9yKChcIltWdWUgd2Fybl06IFwiICsgbXNnICsgdHJhY2UpKTtcbiAgICB9XG4gIH07XG5cbiAgdGlwID0gZnVuY3Rpb24gKG1zZywgdm0pIHtcbiAgICBpZiAoaGFzQ29uc29sZSAmJiAoIWNvbmZpZy5zaWxlbnQpKSB7XG4gICAgICBjb25zb2xlLndhcm4oXCJbVnVlIHRpcF06IFwiICsgbXNnICsgKFxuICAgICAgICB2bSA/IGdlbmVyYXRlQ29tcG9uZW50VHJhY2Uodm0pIDogJydcbiAgICAgICkpO1xuICAgIH1cbiAgfTtcblxuICBmb3JtYXRDb21wb25lbnROYW1lID0gZnVuY3Rpb24gKHZtLCBpbmNsdWRlRmlsZSkge1xuICAgIGlmICh2bS4kcm9vdCA9PT0gdm0pIHtcbiAgICAgIHJldHVybiAnPFJvb3Q+J1xuICAgIH1cbiAgICB2YXIgb3B0aW9ucyA9IHR5cGVvZiB2bSA9PT0gJ2Z1bmN0aW9uJyAmJiB2bS5jaWQgIT0gbnVsbFxuICAgICAgPyB2bS5vcHRpb25zXG4gICAgICA6IHZtLl9pc1Z1ZVxuICAgICAgICA/IHZtLiRvcHRpb25zIHx8IHZtLmNvbnN0cnVjdG9yLm9wdGlvbnNcbiAgICAgICAgOiB2bTtcbiAgICB2YXIgbmFtZSA9IG9wdGlvbnMubmFtZSB8fCBvcHRpb25zLl9jb21wb25lbnRUYWc7XG4gICAgdmFyIGZpbGUgPSBvcHRpb25zLl9fZmlsZTtcbiAgICBpZiAoIW5hbWUgJiYgZmlsZSkge1xuICAgICAgdmFyIG1hdGNoID0gZmlsZS5tYXRjaCgvKFteL1xcXFxdKylcXC52dWUkLyk7XG4gICAgICBuYW1lID0gbWF0Y2ggJiYgbWF0Y2hbMV07XG4gICAgfVxuXG4gICAgcmV0dXJuIChcbiAgICAgIChuYW1lID8gKFwiPFwiICsgKGNsYXNzaWZ5KG5hbWUpKSArIFwiPlwiKSA6IFwiPEFub255bW91cz5cIikgK1xuICAgICAgKGZpbGUgJiYgaW5jbHVkZUZpbGUgIT09IGZhbHNlID8gKFwiIGF0IFwiICsgZmlsZSkgOiAnJylcbiAgICApXG4gIH07XG5cbiAgdmFyIHJlcGVhdCA9IGZ1bmN0aW9uIChzdHIsIG4pIHtcbiAgICB2YXIgcmVzID0gJyc7XG4gICAgd2hpbGUgKG4pIHtcbiAgICAgIGlmIChuICUgMiA9PT0gMSkgeyByZXMgKz0gc3RyOyB9XG4gICAgICBpZiAobiA+IDEpIHsgc3RyICs9IHN0cjsgfVxuICAgICAgbiA+Pj0gMTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc1xuICB9O1xuXG4gIGdlbmVyYXRlQ29tcG9uZW50VHJhY2UgPSBmdW5jdGlvbiAodm0pIHtcbiAgICBpZiAodm0uX2lzVnVlICYmIHZtLiRwYXJlbnQpIHtcbiAgICAgIHZhciB0cmVlID0gW107XG4gICAgICB2YXIgY3VycmVudFJlY3Vyc2l2ZVNlcXVlbmNlID0gMDtcbiAgICAgIHdoaWxlICh2bSkge1xuICAgICAgICBpZiAodHJlZS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgdmFyIGxhc3QgPSB0cmVlW3RyZWUubGVuZ3RoIC0gMV07XG4gICAgICAgICAgaWYgKGxhc3QuY29uc3RydWN0b3IgPT09IHZtLmNvbnN0cnVjdG9yKSB7XG4gICAgICAgICAgICBjdXJyZW50UmVjdXJzaXZlU2VxdWVuY2UrKztcbiAgICAgICAgICAgIHZtID0gdm0uJHBhcmVudDtcbiAgICAgICAgICAgIGNvbnRpbnVlXG4gICAgICAgICAgfSBlbHNlIGlmIChjdXJyZW50UmVjdXJzaXZlU2VxdWVuY2UgPiAwKSB7XG4gICAgICAgICAgICB0cmVlW3RyZWUubGVuZ3RoIC0gMV0gPSBbbGFzdCwgY3VycmVudFJlY3Vyc2l2ZVNlcXVlbmNlXTtcbiAgICAgICAgICAgIGN1cnJlbnRSZWN1cnNpdmVTZXF1ZW5jZSA9IDA7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRyZWUucHVzaCh2bSk7XG4gICAgICAgIHZtID0gdm0uJHBhcmVudDtcbiAgICAgIH1cbiAgICAgIHJldHVybiAnXFxuXFxuZm91bmQgaW5cXG5cXG4nICsgdHJlZVxuICAgICAgICAubWFwKGZ1bmN0aW9uICh2bSwgaSkgeyByZXR1cm4gKFwiXCIgKyAoaSA9PT0gMCA/ICctLS0+ICcgOiByZXBlYXQoJyAnLCA1ICsgaSAqIDIpKSArIChBcnJheS5pc0FycmF5KHZtKVxuICAgICAgICAgICAgPyAoKGZvcm1hdENvbXBvbmVudE5hbWUodm1bMF0pKSArIFwiLi4uIChcIiArICh2bVsxXSkgKyBcIiByZWN1cnNpdmUgY2FsbHMpXCIpXG4gICAgICAgICAgICA6IGZvcm1hdENvbXBvbmVudE5hbWUodm0pKSk7IH0pXG4gICAgICAgIC5qb2luKCdcXG4nKVxuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gKFwiXFxuXFxuKGZvdW5kIGluIFwiICsgKGZvcm1hdENvbXBvbmVudE5hbWUodm0pKSArIFwiKVwiKVxuICAgIH1cbiAgfTtcbn1cblxuLyogICovXG5cbnZhciB1aWQgPSAwO1xuXG4vKipcbiAqIEEgZGVwIGlzIGFuIG9ic2VydmFibGUgdGhhdCBjYW4gaGF2ZSBtdWx0aXBsZVxuICogZGlyZWN0aXZlcyBzdWJzY3JpYmluZyB0byBpdC5cbiAqL1xudmFyIERlcCA9IGZ1bmN0aW9uIERlcCAoKSB7XG4gIHRoaXMuaWQgPSB1aWQrKztcbiAgdGhpcy5zdWJzID0gW107XG59O1xuXG5EZXAucHJvdG90eXBlLmFkZFN1YiA9IGZ1bmN0aW9uIGFkZFN1YiAoc3ViKSB7XG4gIHRoaXMuc3Vicy5wdXNoKHN1Yik7XG59O1xuXG5EZXAucHJvdG90eXBlLnJlbW92ZVN1YiA9IGZ1bmN0aW9uIHJlbW92ZVN1YiAoc3ViKSB7XG4gIHJlbW92ZSh0aGlzLnN1YnMsIHN1Yik7XG59O1xuXG5EZXAucHJvdG90eXBlLmRlcGVuZCA9IGZ1bmN0aW9uIGRlcGVuZCAoKSB7XG4gIGlmIChEZXAudGFyZ2V0KSB7XG4gICAgRGVwLnRhcmdldC5hZGREZXAodGhpcyk7XG4gIH1cbn07XG5cbkRlcC5wcm90b3R5cGUubm90aWZ5ID0gZnVuY3Rpb24gbm90aWZ5ICgpIHtcbiAgLy8gc3RhYmlsaXplIHRoZSBzdWJzY3JpYmVyIGxpc3QgZmlyc3RcbiAgdmFyIHN1YnMgPSB0aGlzLnN1YnMuc2xpY2UoKTtcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgIWNvbmZpZy5hc3luYykge1xuICAgIC8vIHN1YnMgYXJlbid0IHNvcnRlZCBpbiBzY2hlZHVsZXIgaWYgbm90IHJ1bm5pbmcgYXN5bmNcbiAgICAvLyB3ZSBuZWVkIHRvIHNvcnQgdGhlbSBub3cgdG8gbWFrZSBzdXJlIHRoZXkgZmlyZSBpbiBjb3JyZWN0XG4gICAgLy8gb3JkZXJcbiAgICBzdWJzLnNvcnQoZnVuY3Rpb24gKGEsIGIpIHsgcmV0dXJuIGEuaWQgLSBiLmlkOyB9KTtcbiAgfVxuICBmb3IgKHZhciBpID0gMCwgbCA9IHN1YnMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgc3Vic1tpXS51cGRhdGUoKTtcbiAgfVxufTtcblxuLy8gVGhlIGN1cnJlbnQgdGFyZ2V0IHdhdGNoZXIgYmVpbmcgZXZhbHVhdGVkLlxuLy8gVGhpcyBpcyBnbG9iYWxseSB1bmlxdWUgYmVjYXVzZSBvbmx5IG9uZSB3YXRjaGVyXG4vLyBjYW4gYmUgZXZhbHVhdGVkIGF0IGEgdGltZS5cbkRlcC50YXJnZXQgPSBudWxsO1xudmFyIHRhcmdldFN0YWNrID0gW107XG5cbmZ1bmN0aW9uIHB1c2hUYXJnZXQgKHRhcmdldCkge1xuICB0YXJnZXRTdGFjay5wdXNoKHRhcmdldCk7XG4gIERlcC50YXJnZXQgPSB0YXJnZXQ7XG59XG5cbmZ1bmN0aW9uIHBvcFRhcmdldCAoKSB7XG4gIHRhcmdldFN0YWNrLnBvcCgpO1xuICBEZXAudGFyZ2V0ID0gdGFyZ2V0U3RhY2tbdGFyZ2V0U3RhY2subGVuZ3RoIC0gMV07XG59XG5cbi8qICAqL1xuXG52YXIgVk5vZGUgPSBmdW5jdGlvbiBWTm9kZSAoXG4gIHRhZyxcbiAgZGF0YSxcbiAgY2hpbGRyZW4sXG4gIHRleHQsXG4gIGVsbSxcbiAgY29udGV4dCxcbiAgY29tcG9uZW50T3B0aW9ucyxcbiAgYXN5bmNGYWN0b3J5XG4pIHtcbiAgdGhpcy50YWcgPSB0YWc7XG4gIHRoaXMuZGF0YSA9IGRhdGE7XG4gIHRoaXMuY2hpbGRyZW4gPSBjaGlsZHJlbjtcbiAgdGhpcy50ZXh0ID0gdGV4dDtcbiAgdGhpcy5lbG0gPSBlbG07XG4gIHRoaXMubnMgPSB1bmRlZmluZWQ7XG4gIHRoaXMuY29udGV4dCA9IGNvbnRleHQ7XG4gIHRoaXMuZm5Db250ZXh0ID0gdW5kZWZpbmVkO1xuICB0aGlzLmZuT3B0aW9ucyA9IHVuZGVmaW5lZDtcbiAgdGhpcy5mblNjb3BlSWQgPSB1bmRlZmluZWQ7XG4gIHRoaXMua2V5ID0gZGF0YSAmJiBkYXRhLmtleTtcbiAgdGhpcy5jb21wb25lbnRPcHRpb25zID0gY29tcG9uZW50T3B0aW9ucztcbiAgdGhpcy5jb21wb25lbnRJbnN0YW5jZSA9IHVuZGVmaW5lZDtcbiAgdGhpcy5wYXJlbnQgPSB1bmRlZmluZWQ7XG4gIHRoaXMucmF3ID0gZmFsc2U7XG4gIHRoaXMuaXNTdGF0aWMgPSBmYWxzZTtcbiAgdGhpcy5pc1Jvb3RJbnNlcnQgPSB0cnVlO1xuICB0aGlzLmlzQ29tbWVudCA9IGZhbHNlO1xuICB0aGlzLmlzQ2xvbmVkID0gZmFsc2U7XG4gIHRoaXMuaXNPbmNlID0gZmFsc2U7XG4gIHRoaXMuYXN5bmNGYWN0b3J5ID0gYXN5bmNGYWN0b3J5O1xuICB0aGlzLmFzeW5jTWV0YSA9IHVuZGVmaW5lZDtcbiAgdGhpcy5pc0FzeW5jUGxhY2Vob2xkZXIgPSBmYWxzZTtcbn07XG5cbnZhciBwcm90b3R5cGVBY2Nlc3NvcnMgPSB7IGNoaWxkOiB7IGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH07XG5cbi8vIERFUFJFQ0FURUQ6IGFsaWFzIGZvciBjb21wb25lbnRJbnN0YW5jZSBmb3IgYmFja3dhcmRzIGNvbXBhdC5cbi8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG5wcm90b3R5cGVBY2Nlc3NvcnMuY2hpbGQuZ2V0ID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gdGhpcy5jb21wb25lbnRJbnN0YW5jZVxufTtcblxuT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoIFZOb2RlLnByb3RvdHlwZSwgcHJvdG90eXBlQWNjZXNzb3JzICk7XG5cbnZhciBjcmVhdGVFbXB0eVZOb2RlID0gZnVuY3Rpb24gKHRleHQpIHtcbiAgaWYgKCB0ZXh0ID09PSB2b2lkIDAgKSB0ZXh0ID0gJyc7XG5cbiAgdmFyIG5vZGUgPSBuZXcgVk5vZGUoKTtcbiAgbm9kZS50ZXh0ID0gdGV4dDtcbiAgbm9kZS5pc0NvbW1lbnQgPSB0cnVlO1xuICByZXR1cm4gbm9kZVxufTtcblxuZnVuY3Rpb24gY3JlYXRlVGV4dFZOb2RlICh2YWwpIHtcbiAgcmV0dXJuIG5ldyBWTm9kZSh1bmRlZmluZWQsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCBTdHJpbmcodmFsKSlcbn1cblxuLy8gb3B0aW1pemVkIHNoYWxsb3cgY2xvbmVcbi8vIHVzZWQgZm9yIHN0YXRpYyBub2RlcyBhbmQgc2xvdCBub2RlcyBiZWNhdXNlIHRoZXkgbWF5IGJlIHJldXNlZCBhY3Jvc3Ncbi8vIG11bHRpcGxlIHJlbmRlcnMsIGNsb25pbmcgdGhlbSBhdm9pZHMgZXJyb3JzIHdoZW4gRE9NIG1hbmlwdWxhdGlvbnMgcmVseVxuLy8gb24gdGhlaXIgZWxtIHJlZmVyZW5jZS5cbmZ1bmN0aW9uIGNsb25lVk5vZGUgKHZub2RlKSB7XG4gIHZhciBjbG9uZWQgPSBuZXcgVk5vZGUoXG4gICAgdm5vZGUudGFnLFxuICAgIHZub2RlLmRhdGEsXG4gICAgLy8gIzc5NzVcbiAgICAvLyBjbG9uZSBjaGlsZHJlbiBhcnJheSB0byBhdm9pZCBtdXRhdGluZyBvcmlnaW5hbCBpbiBjYXNlIG9mIGNsb25pbmdcbiAgICAvLyBhIGNoaWxkLlxuICAgIHZub2RlLmNoaWxkcmVuICYmIHZub2RlLmNoaWxkcmVuLnNsaWNlKCksXG4gICAgdm5vZGUudGV4dCxcbiAgICB2bm9kZS5lbG0sXG4gICAgdm5vZGUuY29udGV4dCxcbiAgICB2bm9kZS5jb21wb25lbnRPcHRpb25zLFxuICAgIHZub2RlLmFzeW5jRmFjdG9yeVxuICApO1xuICBjbG9uZWQubnMgPSB2bm9kZS5ucztcbiAgY2xvbmVkLmlzU3RhdGljID0gdm5vZGUuaXNTdGF0aWM7XG4gIGNsb25lZC5rZXkgPSB2bm9kZS5rZXk7XG4gIGNsb25lZC5pc0NvbW1lbnQgPSB2bm9kZS5pc0NvbW1lbnQ7XG4gIGNsb25lZC5mbkNvbnRleHQgPSB2bm9kZS5mbkNvbnRleHQ7XG4gIGNsb25lZC5mbk9wdGlvbnMgPSB2bm9kZS5mbk9wdGlvbnM7XG4gIGNsb25lZC5mblNjb3BlSWQgPSB2bm9kZS5mblNjb3BlSWQ7XG4gIGNsb25lZC5hc3luY01ldGEgPSB2bm9kZS5hc3luY01ldGE7XG4gIGNsb25lZC5pc0Nsb25lZCA9IHRydWU7XG4gIHJldHVybiBjbG9uZWRcbn1cblxuLypcbiAqIG5vdCB0eXBlIGNoZWNraW5nIHRoaXMgZmlsZSBiZWNhdXNlIGZsb3cgZG9lc24ndCBwbGF5IHdlbGwgd2l0aFxuICogZHluYW1pY2FsbHkgYWNjZXNzaW5nIG1ldGhvZHMgb24gQXJyYXkgcHJvdG90eXBlXG4gKi9cblxudmFyIGFycmF5UHJvdG8gPSBBcnJheS5wcm90b3R5cGU7XG52YXIgYXJyYXlNZXRob2RzID0gT2JqZWN0LmNyZWF0ZShhcnJheVByb3RvKTtcblxudmFyIG1ldGhvZHNUb1BhdGNoID0gW1xuICAncHVzaCcsXG4gICdwb3AnLFxuICAnc2hpZnQnLFxuICAndW5zaGlmdCcsXG4gICdzcGxpY2UnLFxuICAnc29ydCcsXG4gICdyZXZlcnNlJ1xuXTtcblxuLyoqXG4gKiBJbnRlcmNlcHQgbXV0YXRpbmcgbWV0aG9kcyBhbmQgZW1pdCBldmVudHNcbiAqL1xubWV0aG9kc1RvUGF0Y2guZm9yRWFjaChmdW5jdGlvbiAobWV0aG9kKSB7XG4gIC8vIGNhY2hlIG9yaWdpbmFsIG1ldGhvZFxuICB2YXIgb3JpZ2luYWwgPSBhcnJheVByb3RvW21ldGhvZF07XG4gIGRlZihhcnJheU1ldGhvZHMsIG1ldGhvZCwgZnVuY3Rpb24gbXV0YXRvciAoKSB7XG4gICAgdmFyIGFyZ3MgPSBbXSwgbGVuID0gYXJndW1lbnRzLmxlbmd0aDtcbiAgICB3aGlsZSAoIGxlbi0tICkgYXJnc1sgbGVuIF0gPSBhcmd1bWVudHNbIGxlbiBdO1xuXG4gICAgdmFyIHJlc3VsdCA9IG9yaWdpbmFsLmFwcGx5KHRoaXMsIGFyZ3MpO1xuICAgIHZhciBvYiA9IHRoaXMuX19vYl9fO1xuICAgIHZhciBpbnNlcnRlZDtcbiAgICBzd2l0Y2ggKG1ldGhvZCkge1xuICAgICAgY2FzZSAncHVzaCc6XG4gICAgICBjYXNlICd1bnNoaWZ0JzpcbiAgICAgICAgaW5zZXJ0ZWQgPSBhcmdzO1xuICAgICAgICBicmVha1xuICAgICAgY2FzZSAnc3BsaWNlJzpcbiAgICAgICAgaW5zZXJ0ZWQgPSBhcmdzLnNsaWNlKDIpO1xuICAgICAgICBicmVha1xuICAgIH1cbiAgICBpZiAoaW5zZXJ0ZWQpIHsgb2Iub2JzZXJ2ZUFycmF5KGluc2VydGVkKTsgfVxuICAgIC8vIG5vdGlmeSBjaGFuZ2VcbiAgICBvYi5kZXAubm90aWZ5KCk7XG4gICAgcmV0dXJuIHJlc3VsdFxuICB9KTtcbn0pO1xuXG4vKiAgKi9cblxudmFyIGFycmF5S2V5cyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKGFycmF5TWV0aG9kcyk7XG5cbi8qKlxuICogSW4gc29tZSBjYXNlcyB3ZSBtYXkgd2FudCB0byBkaXNhYmxlIG9ic2VydmF0aW9uIGluc2lkZSBhIGNvbXBvbmVudCdzXG4gKiB1cGRhdGUgY29tcHV0YXRpb24uXG4gKi9cbnZhciBzaG91bGRPYnNlcnZlID0gdHJ1ZTtcblxuZnVuY3Rpb24gdG9nZ2xlT2JzZXJ2aW5nICh2YWx1ZSkge1xuICBzaG91bGRPYnNlcnZlID0gdmFsdWU7XG59XG5cbi8qKlxuICogT2JzZXJ2ZXIgY2xhc3MgdGhhdCBpcyBhdHRhY2hlZCB0byBlYWNoIG9ic2VydmVkXG4gKiBvYmplY3QuIE9uY2UgYXR0YWNoZWQsIHRoZSBvYnNlcnZlciBjb252ZXJ0cyB0aGUgdGFyZ2V0XG4gKiBvYmplY3QncyBwcm9wZXJ0eSBrZXlzIGludG8gZ2V0dGVyL3NldHRlcnMgdGhhdFxuICogY29sbGVjdCBkZXBlbmRlbmNpZXMgYW5kIGRpc3BhdGNoIHVwZGF0ZXMuXG4gKi9cbnZhciBPYnNlcnZlciA9IGZ1bmN0aW9uIE9ic2VydmVyICh2YWx1ZSkge1xuICB0aGlzLnZhbHVlID0gdmFsdWU7XG4gIHRoaXMuZGVwID0gbmV3IERlcCgpO1xuICB0aGlzLnZtQ291bnQgPSAwO1xuICBkZWYodmFsdWUsICdfX29iX18nLCB0aGlzKTtcbiAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgaWYgKGhhc1Byb3RvKSB7XG4gICAgICBwcm90b0F1Z21lbnQodmFsdWUsIGFycmF5TWV0aG9kcyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvcHlBdWdtZW50KHZhbHVlLCBhcnJheU1ldGhvZHMsIGFycmF5S2V5cyk7XG4gICAgfVxuICAgIHRoaXMub2JzZXJ2ZUFycmF5KHZhbHVlKTtcbiAgfSBlbHNlIHtcbiAgICB0aGlzLndhbGsodmFsdWUpO1xuICB9XG59O1xuXG4vKipcbiAqIFdhbGsgdGhyb3VnaCBhbGwgcHJvcGVydGllcyBhbmQgY29udmVydCB0aGVtIGludG9cbiAqIGdldHRlci9zZXR0ZXJzLiBUaGlzIG1ldGhvZCBzaG91bGQgb25seSBiZSBjYWxsZWQgd2hlblxuICogdmFsdWUgdHlwZSBpcyBPYmplY3QuXG4gKi9cbk9ic2VydmVyLnByb3RvdHlwZS53YWxrID0gZnVuY3Rpb24gd2FsayAob2JqKSB7XG4gIHZhciBrZXlzID0gT2JqZWN0LmtleXMob2JqKTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAgZGVmaW5lUmVhY3RpdmUkJDEob2JqLCBrZXlzW2ldKTtcbiAgfVxufTtcblxuLyoqXG4gKiBPYnNlcnZlIGEgbGlzdCBvZiBBcnJheSBpdGVtcy5cbiAqL1xuT2JzZXJ2ZXIucHJvdG90eXBlLm9ic2VydmVBcnJheSA9IGZ1bmN0aW9uIG9ic2VydmVBcnJheSAoaXRlbXMpIHtcbiAgZm9yICh2YXIgaSA9IDAsIGwgPSBpdGVtcy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICBvYnNlcnZlKGl0ZW1zW2ldKTtcbiAgfVxufTtcblxuLy8gaGVscGVyc1xuXG4vKipcbiAqIEF1Z21lbnQgYSB0YXJnZXQgT2JqZWN0IG9yIEFycmF5IGJ5IGludGVyY2VwdGluZ1xuICogdGhlIHByb3RvdHlwZSBjaGFpbiB1c2luZyBfX3Byb3RvX19cbiAqL1xuZnVuY3Rpb24gcHJvdG9BdWdtZW50ICh0YXJnZXQsIHNyYykge1xuICAvKiBlc2xpbnQtZGlzYWJsZSBuby1wcm90byAqL1xuICB0YXJnZXQuX19wcm90b19fID0gc3JjO1xuICAvKiBlc2xpbnQtZW5hYmxlIG5vLXByb3RvICovXG59XG5cbi8qKlxuICogQXVnbWVudCBhIHRhcmdldCBPYmplY3Qgb3IgQXJyYXkgYnkgZGVmaW5pbmdcbiAqIGhpZGRlbiBwcm9wZXJ0aWVzLlxuICovXG4vKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuZnVuY3Rpb24gY29weUF1Z21lbnQgKHRhcmdldCwgc3JjLCBrZXlzKSB7XG4gIGZvciAodmFyIGkgPSAwLCBsID0ga2V5cy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICB2YXIga2V5ID0ga2V5c1tpXTtcbiAgICBkZWYodGFyZ2V0LCBrZXksIHNyY1trZXldKTtcbiAgfVxufVxuXG4vKipcbiAqIEF0dGVtcHQgdG8gY3JlYXRlIGFuIG9ic2VydmVyIGluc3RhbmNlIGZvciBhIHZhbHVlLFxuICogcmV0dXJucyB0aGUgbmV3IG9ic2VydmVyIGlmIHN1Y2Nlc3NmdWxseSBvYnNlcnZlZCxcbiAqIG9yIHRoZSBleGlzdGluZyBvYnNlcnZlciBpZiB0aGUgdmFsdWUgYWxyZWFkeSBoYXMgb25lLlxuICovXG5mdW5jdGlvbiBvYnNlcnZlICh2YWx1ZSwgYXNSb290RGF0YSkge1xuICBpZiAoIWlzT2JqZWN0KHZhbHVlKSB8fCB2YWx1ZSBpbnN0YW5jZW9mIFZOb2RlKSB7XG4gICAgcmV0dXJuXG4gIH1cbiAgdmFyIG9iO1xuICBpZiAoaGFzT3duKHZhbHVlLCAnX19vYl9fJykgJiYgdmFsdWUuX19vYl9fIGluc3RhbmNlb2YgT2JzZXJ2ZXIpIHtcbiAgICBvYiA9IHZhbHVlLl9fb2JfXztcbiAgfSBlbHNlIGlmIChcbiAgICBzaG91bGRPYnNlcnZlICYmXG4gICAgIWlzU2VydmVyUmVuZGVyaW5nKCkgJiZcbiAgICAoQXJyYXkuaXNBcnJheSh2YWx1ZSkgfHwgaXNQbGFpbk9iamVjdCh2YWx1ZSkpICYmXG4gICAgT2JqZWN0LmlzRXh0ZW5zaWJsZSh2YWx1ZSkgJiZcbiAgICAhdmFsdWUuX2lzVnVlXG4gICkge1xuICAgIG9iID0gbmV3IE9ic2VydmVyKHZhbHVlKTtcbiAgfVxuICBpZiAoYXNSb290RGF0YSAmJiBvYikge1xuICAgIG9iLnZtQ291bnQrKztcbiAgfVxuICByZXR1cm4gb2Jcbn1cblxuLyoqXG4gKiBEZWZpbmUgYSByZWFjdGl2ZSBwcm9wZXJ0eSBvbiBhbiBPYmplY3QuXG4gKi9cbmZ1bmN0aW9uIGRlZmluZVJlYWN0aXZlJCQxIChcbiAgb2JqLFxuICBrZXksXG4gIHZhbCxcbiAgY3VzdG9tU2V0dGVyLFxuICBzaGFsbG93XG4pIHtcbiAgdmFyIGRlcCA9IG5ldyBEZXAoKTtcblxuICB2YXIgcHJvcGVydHkgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG9iaiwga2V5KTtcbiAgaWYgKHByb3BlcnR5ICYmIHByb3BlcnR5LmNvbmZpZ3VyYWJsZSA9PT0gZmFsc2UpIHtcbiAgICByZXR1cm5cbiAgfVxuXG4gIC8vIGNhdGVyIGZvciBwcmUtZGVmaW5lZCBnZXR0ZXIvc2V0dGVyc1xuICB2YXIgZ2V0dGVyID0gcHJvcGVydHkgJiYgcHJvcGVydHkuZ2V0O1xuICB2YXIgc2V0dGVyID0gcHJvcGVydHkgJiYgcHJvcGVydHkuc2V0O1xuICBpZiAoKCFnZXR0ZXIgfHwgc2V0dGVyKSAmJiBhcmd1bWVudHMubGVuZ3RoID09PSAyKSB7XG4gICAgdmFsID0gb2JqW2tleV07XG4gIH1cblxuICB2YXIgY2hpbGRPYiA9ICFzaGFsbG93ICYmIG9ic2VydmUodmFsKTtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iaiwga2V5LCB7XG4gICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgZ2V0OiBmdW5jdGlvbiByZWFjdGl2ZUdldHRlciAoKSB7XG4gICAgICB2YXIgdmFsdWUgPSBnZXR0ZXIgPyBnZXR0ZXIuY2FsbChvYmopIDogdmFsO1xuICAgICAgaWYgKERlcC50YXJnZXQpIHtcbiAgICAgICAgZGVwLmRlcGVuZCgpO1xuICAgICAgICBpZiAoY2hpbGRPYikge1xuICAgICAgICAgIGNoaWxkT2IuZGVwLmRlcGVuZCgpO1xuICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgICAgICAgICAgZGVwZW5kQXJyYXkodmFsdWUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHZhbHVlXG4gICAgfSxcbiAgICBzZXQ6IGZ1bmN0aW9uIHJlYWN0aXZlU2V0dGVyIChuZXdWYWwpIHtcbiAgICAgIHZhciB2YWx1ZSA9IGdldHRlciA/IGdldHRlci5jYWxsKG9iaikgOiB2YWw7XG4gICAgICAvKiBlc2xpbnQtZGlzYWJsZSBuby1zZWxmLWNvbXBhcmUgKi9cbiAgICAgIGlmIChuZXdWYWwgPT09IHZhbHVlIHx8IChuZXdWYWwgIT09IG5ld1ZhbCAmJiB2YWx1ZSAhPT0gdmFsdWUpKSB7XG4gICAgICAgIHJldHVyblxuICAgICAgfVxuICAgICAgLyogZXNsaW50LWVuYWJsZSBuby1zZWxmLWNvbXBhcmUgKi9cbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIGN1c3RvbVNldHRlcikge1xuICAgICAgICBjdXN0b21TZXR0ZXIoKTtcbiAgICAgIH1cbiAgICAgIC8vICM3OTgxOiBmb3IgYWNjZXNzb3IgcHJvcGVydGllcyB3aXRob3V0IHNldHRlclxuICAgICAgaWYgKGdldHRlciAmJiAhc2V0dGVyKSB7IHJldHVybiB9XG4gICAgICBpZiAoc2V0dGVyKSB7XG4gICAgICAgIHNldHRlci5jYWxsKG9iaiwgbmV3VmFsKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhbCA9IG5ld1ZhbDtcbiAgICAgIH1cbiAgICAgIGNoaWxkT2IgPSAhc2hhbGxvdyAmJiBvYnNlcnZlKG5ld1ZhbCk7XG4gICAgICBkZXAubm90aWZ5KCk7XG4gICAgfVxuICB9KTtcbn1cblxuLyoqXG4gKiBTZXQgYSBwcm9wZXJ0eSBvbiBhbiBvYmplY3QuIEFkZHMgdGhlIG5ldyBwcm9wZXJ0eSBhbmRcbiAqIHRyaWdnZXJzIGNoYW5nZSBub3RpZmljYXRpb24gaWYgdGhlIHByb3BlcnR5IGRvZXNuJ3RcbiAqIGFscmVhZHkgZXhpc3QuXG4gKi9cbmZ1bmN0aW9uIHNldCAodGFyZ2V0LCBrZXksIHZhbCkge1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJlxuICAgIChpc1VuZGVmKHRhcmdldCkgfHwgaXNQcmltaXRpdmUodGFyZ2V0KSlcbiAgKSB7XG4gICAgd2FybigoXCJDYW5ub3Qgc2V0IHJlYWN0aXZlIHByb3BlcnR5IG9uIHVuZGVmaW5lZCwgbnVsbCwgb3IgcHJpbWl0aXZlIHZhbHVlOiBcIiArICgodGFyZ2V0KSkpKTtcbiAgfVxuICBpZiAoQXJyYXkuaXNBcnJheSh0YXJnZXQpICYmIGlzVmFsaWRBcnJheUluZGV4KGtleSkpIHtcbiAgICB0YXJnZXQubGVuZ3RoID0gTWF0aC5tYXgodGFyZ2V0Lmxlbmd0aCwga2V5KTtcbiAgICB0YXJnZXQuc3BsaWNlKGtleSwgMSwgdmFsKTtcbiAgICByZXR1cm4gdmFsXG4gIH1cbiAgaWYgKGtleSBpbiB0YXJnZXQgJiYgIShrZXkgaW4gT2JqZWN0LnByb3RvdHlwZSkpIHtcbiAgICB0YXJnZXRba2V5XSA9IHZhbDtcbiAgICByZXR1cm4gdmFsXG4gIH1cbiAgdmFyIG9iID0gKHRhcmdldCkuX19vYl9fO1xuICBpZiAodGFyZ2V0Ll9pc1Z1ZSB8fCAob2IgJiYgb2Iudm1Db3VudCkpIHtcbiAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIHdhcm4oXG4gICAgICAnQXZvaWQgYWRkaW5nIHJlYWN0aXZlIHByb3BlcnRpZXMgdG8gYSBWdWUgaW5zdGFuY2Ugb3IgaXRzIHJvb3QgJGRhdGEgJyArXG4gICAgICAnYXQgcnVudGltZSAtIGRlY2xhcmUgaXQgdXBmcm9udCBpbiB0aGUgZGF0YSBvcHRpb24uJ1xuICAgICk7XG4gICAgcmV0dXJuIHZhbFxuICB9XG4gIGlmICghb2IpIHtcbiAgICB0YXJnZXRba2V5XSA9IHZhbDtcbiAgICByZXR1cm4gdmFsXG4gIH1cbiAgZGVmaW5lUmVhY3RpdmUkJDEob2IudmFsdWUsIGtleSwgdmFsKTtcbiAgb2IuZGVwLm5vdGlmeSgpO1xuICByZXR1cm4gdmFsXG59XG5cbi8qKlxuICogRGVsZXRlIGEgcHJvcGVydHkgYW5kIHRyaWdnZXIgY2hhbmdlIGlmIG5lY2Vzc2FyeS5cbiAqL1xuZnVuY3Rpb24gZGVsICh0YXJnZXQsIGtleSkge1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJlxuICAgIChpc1VuZGVmKHRhcmdldCkgfHwgaXNQcmltaXRpdmUodGFyZ2V0KSlcbiAgKSB7XG4gICAgd2FybigoXCJDYW5ub3QgZGVsZXRlIHJlYWN0aXZlIHByb3BlcnR5IG9uIHVuZGVmaW5lZCwgbnVsbCwgb3IgcHJpbWl0aXZlIHZhbHVlOiBcIiArICgodGFyZ2V0KSkpKTtcbiAgfVxuICBpZiAoQXJyYXkuaXNBcnJheSh0YXJnZXQpICYmIGlzVmFsaWRBcnJheUluZGV4KGtleSkpIHtcbiAgICB0YXJnZXQuc3BsaWNlKGtleSwgMSk7XG4gICAgcmV0dXJuXG4gIH1cbiAgdmFyIG9iID0gKHRhcmdldCkuX19vYl9fO1xuICBpZiAodGFyZ2V0Ll9pc1Z1ZSB8fCAob2IgJiYgb2Iudm1Db3VudCkpIHtcbiAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIHdhcm4oXG4gICAgICAnQXZvaWQgZGVsZXRpbmcgcHJvcGVydGllcyBvbiBhIFZ1ZSBpbnN0YW5jZSBvciBpdHMgcm9vdCAkZGF0YSAnICtcbiAgICAgICctIGp1c3Qgc2V0IGl0IHRvIG51bGwuJ1xuICAgICk7XG4gICAgcmV0dXJuXG4gIH1cbiAgaWYgKCFoYXNPd24odGFyZ2V0LCBrZXkpKSB7XG4gICAgcmV0dXJuXG4gIH1cbiAgZGVsZXRlIHRhcmdldFtrZXldO1xuICBpZiAoIW9iKSB7XG4gICAgcmV0dXJuXG4gIH1cbiAgb2IuZGVwLm5vdGlmeSgpO1xufVxuXG4vKipcbiAqIENvbGxlY3QgZGVwZW5kZW5jaWVzIG9uIGFycmF5IGVsZW1lbnRzIHdoZW4gdGhlIGFycmF5IGlzIHRvdWNoZWQsIHNpbmNlXG4gKiB3ZSBjYW5ub3QgaW50ZXJjZXB0IGFycmF5IGVsZW1lbnQgYWNjZXNzIGxpa2UgcHJvcGVydHkgZ2V0dGVycy5cbiAqL1xuZnVuY3Rpb24gZGVwZW5kQXJyYXkgKHZhbHVlKSB7XG4gIGZvciAodmFyIGUgPSAodm9pZCAwKSwgaSA9IDAsIGwgPSB2YWx1ZS5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICBlID0gdmFsdWVbaV07XG4gICAgZSAmJiBlLl9fb2JfXyAmJiBlLl9fb2JfXy5kZXAuZGVwZW5kKCk7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkoZSkpIHtcbiAgICAgIGRlcGVuZEFycmF5KGUpO1xuICAgIH1cbiAgfVxufVxuXG4vKiAgKi9cblxuLyoqXG4gKiBPcHRpb24gb3ZlcndyaXRpbmcgc3RyYXRlZ2llcyBhcmUgZnVuY3Rpb25zIHRoYXQgaGFuZGxlXG4gKiBob3cgdG8gbWVyZ2UgYSBwYXJlbnQgb3B0aW9uIHZhbHVlIGFuZCBhIGNoaWxkIG9wdGlvblxuICogdmFsdWUgaW50byB0aGUgZmluYWwgdmFsdWUuXG4gKi9cbnZhciBzdHJhdHMgPSBjb25maWcub3B0aW9uTWVyZ2VTdHJhdGVnaWVzO1xuXG4vKipcbiAqIE9wdGlvbnMgd2l0aCByZXN0cmljdGlvbnNcbiAqL1xuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgc3RyYXRzLmVsID0gc3RyYXRzLnByb3BzRGF0YSA9IGZ1bmN0aW9uIChwYXJlbnQsIGNoaWxkLCB2bSwga2V5KSB7XG4gICAgaWYgKCF2bSkge1xuICAgICAgd2FybihcbiAgICAgICAgXCJvcHRpb24gXFxcIlwiICsga2V5ICsgXCJcXFwiIGNhbiBvbmx5IGJlIHVzZWQgZHVyaW5nIGluc3RhbmNlIFwiICtcbiAgICAgICAgJ2NyZWF0aW9uIHdpdGggdGhlIGBuZXdgIGtleXdvcmQuJ1xuICAgICAgKTtcbiAgICB9XG4gICAgcmV0dXJuIGRlZmF1bHRTdHJhdChwYXJlbnQsIGNoaWxkKVxuICB9O1xufVxuXG4vKipcbiAqIEhlbHBlciB0aGF0IHJlY3Vyc2l2ZWx5IG1lcmdlcyB0d28gZGF0YSBvYmplY3RzIHRvZ2V0aGVyLlxuICovXG5mdW5jdGlvbiBtZXJnZURhdGEgKHRvLCBmcm9tKSB7XG4gIGlmICghZnJvbSkgeyByZXR1cm4gdG8gfVxuICB2YXIga2V5LCB0b1ZhbCwgZnJvbVZhbDtcblxuICB2YXIga2V5cyA9IGhhc1N5bWJvbFxuICAgID8gUmVmbGVjdC5vd25LZXlzKGZyb20pXG4gICAgOiBPYmplY3Qua2V5cyhmcm9tKTtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyBpKyspIHtcbiAgICBrZXkgPSBrZXlzW2ldO1xuICAgIC8vIGluIGNhc2UgdGhlIG9iamVjdCBpcyBhbHJlYWR5IG9ic2VydmVkLi4uXG4gICAgaWYgKGtleSA9PT0gJ19fb2JfXycpIHsgY29udGludWUgfVxuICAgIHRvVmFsID0gdG9ba2V5XTtcbiAgICBmcm9tVmFsID0gZnJvbVtrZXldO1xuICAgIGlmICghaGFzT3duKHRvLCBrZXkpKSB7XG4gICAgICBzZXQodG8sIGtleSwgZnJvbVZhbCk7XG4gICAgfSBlbHNlIGlmIChcbiAgICAgIHRvVmFsICE9PSBmcm9tVmFsICYmXG4gICAgICBpc1BsYWluT2JqZWN0KHRvVmFsKSAmJlxuICAgICAgaXNQbGFpbk9iamVjdChmcm9tVmFsKVxuICAgICkge1xuICAgICAgbWVyZ2VEYXRhKHRvVmFsLCBmcm9tVmFsKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRvXG59XG5cbi8qKlxuICogRGF0YVxuICovXG5mdW5jdGlvbiBtZXJnZURhdGFPckZuIChcbiAgcGFyZW50VmFsLFxuICBjaGlsZFZhbCxcbiAgdm1cbikge1xuICBpZiAoIXZtKSB7XG4gICAgLy8gaW4gYSBWdWUuZXh0ZW5kIG1lcmdlLCBib3RoIHNob3VsZCBiZSBmdW5jdGlvbnNcbiAgICBpZiAoIWNoaWxkVmFsKSB7XG4gICAgICByZXR1cm4gcGFyZW50VmFsXG4gICAgfVxuICAgIGlmICghcGFyZW50VmFsKSB7XG4gICAgICByZXR1cm4gY2hpbGRWYWxcbiAgICB9XG4gICAgLy8gd2hlbiBwYXJlbnRWYWwgJiBjaGlsZFZhbCBhcmUgYm90aCBwcmVzZW50LFxuICAgIC8vIHdlIG5lZWQgdG8gcmV0dXJuIGEgZnVuY3Rpb24gdGhhdCByZXR1cm5zIHRoZVxuICAgIC8vIG1lcmdlZCByZXN1bHQgb2YgYm90aCBmdW5jdGlvbnMuLi4gbm8gbmVlZCB0b1xuICAgIC8vIGNoZWNrIGlmIHBhcmVudFZhbCBpcyBhIGZ1bmN0aW9uIGhlcmUgYmVjYXVzZVxuICAgIC8vIGl0IGhhcyB0byBiZSBhIGZ1bmN0aW9uIHRvIHBhc3MgcHJldmlvdXMgbWVyZ2VzLlxuICAgIHJldHVybiBmdW5jdGlvbiBtZXJnZWREYXRhRm4gKCkge1xuICAgICAgcmV0dXJuIG1lcmdlRGF0YShcbiAgICAgICAgdHlwZW9mIGNoaWxkVmFsID09PSAnZnVuY3Rpb24nID8gY2hpbGRWYWwuY2FsbCh0aGlzLCB0aGlzKSA6IGNoaWxkVmFsLFxuICAgICAgICB0eXBlb2YgcGFyZW50VmFsID09PSAnZnVuY3Rpb24nID8gcGFyZW50VmFsLmNhbGwodGhpcywgdGhpcykgOiBwYXJlbnRWYWxcbiAgICAgIClcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIG1lcmdlZEluc3RhbmNlRGF0YUZuICgpIHtcbiAgICAgIC8vIGluc3RhbmNlIG1lcmdlXG4gICAgICB2YXIgaW5zdGFuY2VEYXRhID0gdHlwZW9mIGNoaWxkVmFsID09PSAnZnVuY3Rpb24nXG4gICAgICAgID8gY2hpbGRWYWwuY2FsbCh2bSwgdm0pXG4gICAgICAgIDogY2hpbGRWYWw7XG4gICAgICB2YXIgZGVmYXVsdERhdGEgPSB0eXBlb2YgcGFyZW50VmFsID09PSAnZnVuY3Rpb24nXG4gICAgICAgID8gcGFyZW50VmFsLmNhbGwodm0sIHZtKVxuICAgICAgICA6IHBhcmVudFZhbDtcbiAgICAgIGlmIChpbnN0YW5jZURhdGEpIHtcbiAgICAgICAgcmV0dXJuIG1lcmdlRGF0YShpbnN0YW5jZURhdGEsIGRlZmF1bHREYXRhKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGRlZmF1bHREYXRhXG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbnN0cmF0cy5kYXRhID0gZnVuY3Rpb24gKFxuICBwYXJlbnRWYWwsXG4gIGNoaWxkVmFsLFxuICB2bVxuKSB7XG4gIGlmICghdm0pIHtcbiAgICBpZiAoY2hpbGRWYWwgJiYgdHlwZW9mIGNoaWxkVmFsICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIHdhcm4oXG4gICAgICAgICdUaGUgXCJkYXRhXCIgb3B0aW9uIHNob3VsZCBiZSBhIGZ1bmN0aW9uICcgK1xuICAgICAgICAndGhhdCByZXR1cm5zIGEgcGVyLWluc3RhbmNlIHZhbHVlIGluIGNvbXBvbmVudCAnICtcbiAgICAgICAgJ2RlZmluaXRpb25zLicsXG4gICAgICAgIHZtXG4gICAgICApO1xuXG4gICAgICByZXR1cm4gcGFyZW50VmFsXG4gICAgfVxuICAgIHJldHVybiBtZXJnZURhdGFPckZuKHBhcmVudFZhbCwgY2hpbGRWYWwpXG4gIH1cblxuICByZXR1cm4gbWVyZ2VEYXRhT3JGbihwYXJlbnRWYWwsIGNoaWxkVmFsLCB2bSlcbn07XG5cbi8qKlxuICogSG9va3MgYW5kIHByb3BzIGFyZSBtZXJnZWQgYXMgYXJyYXlzLlxuICovXG5mdW5jdGlvbiBtZXJnZUhvb2sgKFxuICBwYXJlbnRWYWwsXG4gIGNoaWxkVmFsXG4pIHtcbiAgdmFyIHJlcyA9IGNoaWxkVmFsXG4gICAgPyBwYXJlbnRWYWxcbiAgICAgID8gcGFyZW50VmFsLmNvbmNhdChjaGlsZFZhbClcbiAgICAgIDogQXJyYXkuaXNBcnJheShjaGlsZFZhbClcbiAgICAgICAgPyBjaGlsZFZhbFxuICAgICAgICA6IFtjaGlsZFZhbF1cbiAgICA6IHBhcmVudFZhbDtcbiAgcmV0dXJuIHJlc1xuICAgID8gZGVkdXBlSG9va3MocmVzKVxuICAgIDogcmVzXG59XG5cbmZ1bmN0aW9uIGRlZHVwZUhvb2tzIChob29rcykge1xuICB2YXIgcmVzID0gW107XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgaG9va3MubGVuZ3RoOyBpKyspIHtcbiAgICBpZiAocmVzLmluZGV4T2YoaG9va3NbaV0pID09PSAtMSkge1xuICAgICAgcmVzLnB1c2goaG9va3NbaV0pO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzXG59XG5cbkxJRkVDWUNMRV9IT09LUy5mb3JFYWNoKGZ1bmN0aW9uIChob29rKSB7XG4gIHN0cmF0c1tob29rXSA9IG1lcmdlSG9vaztcbn0pO1xuXG4vKipcbiAqIEFzc2V0c1xuICpcbiAqIFdoZW4gYSB2bSBpcyBwcmVzZW50IChpbnN0YW5jZSBjcmVhdGlvbiksIHdlIG5lZWQgdG8gZG9cbiAqIGEgdGhyZWUtd2F5IG1lcmdlIGJldHdlZW4gY29uc3RydWN0b3Igb3B0aW9ucywgaW5zdGFuY2VcbiAqIG9wdGlvbnMgYW5kIHBhcmVudCBvcHRpb25zLlxuICovXG5mdW5jdGlvbiBtZXJnZUFzc2V0cyAoXG4gIHBhcmVudFZhbCxcbiAgY2hpbGRWYWwsXG4gIHZtLFxuICBrZXlcbikge1xuICB2YXIgcmVzID0gT2JqZWN0LmNyZWF0ZShwYXJlbnRWYWwgfHwgbnVsbCk7XG4gIGlmIChjaGlsZFZhbCkge1xuICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgYXNzZXJ0T2JqZWN0VHlwZShrZXksIGNoaWxkVmFsLCB2bSk7XG4gICAgcmV0dXJuIGV4dGVuZChyZXMsIGNoaWxkVmFsKVxuICB9IGVsc2Uge1xuICAgIHJldHVybiByZXNcbiAgfVxufVxuXG5BU1NFVF9UWVBFUy5mb3JFYWNoKGZ1bmN0aW9uICh0eXBlKSB7XG4gIHN0cmF0c1t0eXBlICsgJ3MnXSA9IG1lcmdlQXNzZXRzO1xufSk7XG5cbi8qKlxuICogV2F0Y2hlcnMuXG4gKlxuICogV2F0Y2hlcnMgaGFzaGVzIHNob3VsZCBub3Qgb3ZlcndyaXRlIG9uZVxuICogYW5vdGhlciwgc28gd2UgbWVyZ2UgdGhlbSBhcyBhcnJheXMuXG4gKi9cbnN0cmF0cy53YXRjaCA9IGZ1bmN0aW9uIChcbiAgcGFyZW50VmFsLFxuICBjaGlsZFZhbCxcbiAgdm0sXG4gIGtleVxuKSB7XG4gIC8vIHdvcmsgYXJvdW5kIEZpcmVmb3gncyBPYmplY3QucHJvdG90eXBlLndhdGNoLi4uXG4gIGlmIChwYXJlbnRWYWwgPT09IG5hdGl2ZVdhdGNoKSB7IHBhcmVudFZhbCA9IHVuZGVmaW5lZDsgfVxuICBpZiAoY2hpbGRWYWwgPT09IG5hdGl2ZVdhdGNoKSB7IGNoaWxkVmFsID0gdW5kZWZpbmVkOyB9XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICBpZiAoIWNoaWxkVmFsKSB7IHJldHVybiBPYmplY3QuY3JlYXRlKHBhcmVudFZhbCB8fCBudWxsKSB9XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgYXNzZXJ0T2JqZWN0VHlwZShrZXksIGNoaWxkVmFsLCB2bSk7XG4gIH1cbiAgaWYgKCFwYXJlbnRWYWwpIHsgcmV0dXJuIGNoaWxkVmFsIH1cbiAgdmFyIHJldCA9IHt9O1xuICBleHRlbmQocmV0LCBwYXJlbnRWYWwpO1xuICBmb3IgKHZhciBrZXkkMSBpbiBjaGlsZFZhbCkge1xuICAgIHZhciBwYXJlbnQgPSByZXRba2V5JDFdO1xuICAgIHZhciBjaGlsZCA9IGNoaWxkVmFsW2tleSQxXTtcbiAgICBpZiAocGFyZW50ICYmICFBcnJheS5pc0FycmF5KHBhcmVudCkpIHtcbiAgICAgIHBhcmVudCA9IFtwYXJlbnRdO1xuICAgIH1cbiAgICByZXRba2V5JDFdID0gcGFyZW50XG4gICAgICA/IHBhcmVudC5jb25jYXQoY2hpbGQpXG4gICAgICA6IEFycmF5LmlzQXJyYXkoY2hpbGQpID8gY2hpbGQgOiBbY2hpbGRdO1xuICB9XG4gIHJldHVybiByZXRcbn07XG5cbi8qKlxuICogT3RoZXIgb2JqZWN0IGhhc2hlcy5cbiAqL1xuc3RyYXRzLnByb3BzID1cbnN0cmF0cy5tZXRob2RzID1cbnN0cmF0cy5pbmplY3QgPVxuc3RyYXRzLmNvbXB1dGVkID0gZnVuY3Rpb24gKFxuICBwYXJlbnRWYWwsXG4gIGNoaWxkVmFsLFxuICB2bSxcbiAga2V5XG4pIHtcbiAgaWYgKGNoaWxkVmFsICYmIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICBhc3NlcnRPYmplY3RUeXBlKGtleSwgY2hpbGRWYWwsIHZtKTtcbiAgfVxuICBpZiAoIXBhcmVudFZhbCkgeyByZXR1cm4gY2hpbGRWYWwgfVxuICB2YXIgcmV0ID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgZXh0ZW5kKHJldCwgcGFyZW50VmFsKTtcbiAgaWYgKGNoaWxkVmFsKSB7IGV4dGVuZChyZXQsIGNoaWxkVmFsKTsgfVxuICByZXR1cm4gcmV0XG59O1xuc3RyYXRzLnByb3ZpZGUgPSBtZXJnZURhdGFPckZuO1xuXG4vKipcbiAqIERlZmF1bHQgc3RyYXRlZ3kuXG4gKi9cbnZhciBkZWZhdWx0U3RyYXQgPSBmdW5jdGlvbiAocGFyZW50VmFsLCBjaGlsZFZhbCkge1xuICByZXR1cm4gY2hpbGRWYWwgPT09IHVuZGVmaW5lZFxuICAgID8gcGFyZW50VmFsXG4gICAgOiBjaGlsZFZhbFxufTtcblxuLyoqXG4gKiBWYWxpZGF0ZSBjb21wb25lbnQgbmFtZXNcbiAqL1xuZnVuY3Rpb24gY2hlY2tDb21wb25lbnRzIChvcHRpb25zKSB7XG4gIGZvciAodmFyIGtleSBpbiBvcHRpb25zLmNvbXBvbmVudHMpIHtcbiAgICB2YWxpZGF0ZUNvbXBvbmVudE5hbWUoa2V5KTtcbiAgfVxufVxuXG5mdW5jdGlvbiB2YWxpZGF0ZUNvbXBvbmVudE5hbWUgKG5hbWUpIHtcbiAgaWYgKCFuZXcgUmVnRXhwKChcIl5bYS16QS1aXVtcXFxcLVxcXFwuMC05X1wiICsgKHVuaWNvZGVSZWdFeHAuc291cmNlKSArIFwiXSokXCIpKS50ZXN0KG5hbWUpKSB7XG4gICAgd2FybihcbiAgICAgICdJbnZhbGlkIGNvbXBvbmVudCBuYW1lOiBcIicgKyBuYW1lICsgJ1wiLiBDb21wb25lbnQgbmFtZXMgJyArXG4gICAgICAnc2hvdWxkIGNvbmZvcm0gdG8gdmFsaWQgY3VzdG9tIGVsZW1lbnQgbmFtZSBpbiBodG1sNSBzcGVjaWZpY2F0aW9uLidcbiAgICApO1xuICB9XG4gIGlmIChpc0J1aWx0SW5UYWcobmFtZSkgfHwgY29uZmlnLmlzUmVzZXJ2ZWRUYWcobmFtZSkpIHtcbiAgICB3YXJuKFxuICAgICAgJ0RvIG5vdCB1c2UgYnVpbHQtaW4gb3IgcmVzZXJ2ZWQgSFRNTCBlbGVtZW50cyBhcyBjb21wb25lbnQgJyArXG4gICAgICAnaWQ6ICcgKyBuYW1lXG4gICAgKTtcbiAgfVxufVxuXG4vKipcbiAqIEVuc3VyZSBhbGwgcHJvcHMgb3B0aW9uIHN5bnRheCBhcmUgbm9ybWFsaXplZCBpbnRvIHRoZVxuICogT2JqZWN0LWJhc2VkIGZvcm1hdC5cbiAqL1xuZnVuY3Rpb24gbm9ybWFsaXplUHJvcHMgKG9wdGlvbnMsIHZtKSB7XG4gIHZhciBwcm9wcyA9IG9wdGlvbnMucHJvcHM7XG4gIGlmICghcHJvcHMpIHsgcmV0dXJuIH1cbiAgdmFyIHJlcyA9IHt9O1xuICB2YXIgaSwgdmFsLCBuYW1lO1xuICBpZiAoQXJyYXkuaXNBcnJheShwcm9wcykpIHtcbiAgICBpID0gcHJvcHMubGVuZ3RoO1xuICAgIHdoaWxlIChpLS0pIHtcbiAgICAgIHZhbCA9IHByb3BzW2ldO1xuICAgICAgaWYgKHR5cGVvZiB2YWwgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIG5hbWUgPSBjYW1lbGl6ZSh2YWwpO1xuICAgICAgICByZXNbbmFtZV0gPSB7IHR5cGU6IG51bGwgfTtcbiAgICAgIH0gZWxzZSBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICB3YXJuKCdwcm9wcyBtdXN0IGJlIHN0cmluZ3Mgd2hlbiB1c2luZyBhcnJheSBzeW50YXguJyk7XG4gICAgICB9XG4gICAgfVxuICB9IGVsc2UgaWYgKGlzUGxhaW5PYmplY3QocHJvcHMpKSB7XG4gICAgZm9yICh2YXIga2V5IGluIHByb3BzKSB7XG4gICAgICB2YWwgPSBwcm9wc1trZXldO1xuICAgICAgbmFtZSA9IGNhbWVsaXplKGtleSk7XG4gICAgICByZXNbbmFtZV0gPSBpc1BsYWluT2JqZWN0KHZhbClcbiAgICAgICAgPyB2YWxcbiAgICAgICAgOiB7IHR5cGU6IHZhbCB9O1xuICAgIH1cbiAgfSBlbHNlIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgd2FybihcbiAgICAgIFwiSW52YWxpZCB2YWx1ZSBmb3Igb3B0aW9uIFxcXCJwcm9wc1xcXCI6IGV4cGVjdGVkIGFuIEFycmF5IG9yIGFuIE9iamVjdCwgXCIgK1xuICAgICAgXCJidXQgZ290IFwiICsgKHRvUmF3VHlwZShwcm9wcykpICsgXCIuXCIsXG4gICAgICB2bVxuICAgICk7XG4gIH1cbiAgb3B0aW9ucy5wcm9wcyA9IHJlcztcbn1cblxuLyoqXG4gKiBOb3JtYWxpemUgYWxsIGluamVjdGlvbnMgaW50byBPYmplY3QtYmFzZWQgZm9ybWF0XG4gKi9cbmZ1bmN0aW9uIG5vcm1hbGl6ZUluamVjdCAob3B0aW9ucywgdm0pIHtcbiAgdmFyIGluamVjdCA9IG9wdGlvbnMuaW5qZWN0O1xuICBpZiAoIWluamVjdCkgeyByZXR1cm4gfVxuICB2YXIgbm9ybWFsaXplZCA9IG9wdGlvbnMuaW5qZWN0ID0ge307XG4gIGlmIChBcnJheS5pc0FycmF5KGluamVjdCkpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGluamVjdC5sZW5ndGg7IGkrKykge1xuICAgICAgbm9ybWFsaXplZFtpbmplY3RbaV1dID0geyBmcm9tOiBpbmplY3RbaV0gfTtcbiAgICB9XG4gIH0gZWxzZSBpZiAoaXNQbGFpbk9iamVjdChpbmplY3QpKSB7XG4gICAgZm9yICh2YXIga2V5IGluIGluamVjdCkge1xuICAgICAgdmFyIHZhbCA9IGluamVjdFtrZXldO1xuICAgICAgbm9ybWFsaXplZFtrZXldID0gaXNQbGFpbk9iamVjdCh2YWwpXG4gICAgICAgID8gZXh0ZW5kKHsgZnJvbToga2V5IH0sIHZhbClcbiAgICAgICAgOiB7IGZyb206IHZhbCB9O1xuICAgIH1cbiAgfSBlbHNlIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgd2FybihcbiAgICAgIFwiSW52YWxpZCB2YWx1ZSBmb3Igb3B0aW9uIFxcXCJpbmplY3RcXFwiOiBleHBlY3RlZCBhbiBBcnJheSBvciBhbiBPYmplY3QsIFwiICtcbiAgICAgIFwiYnV0IGdvdCBcIiArICh0b1Jhd1R5cGUoaW5qZWN0KSkgKyBcIi5cIixcbiAgICAgIHZtXG4gICAgKTtcbiAgfVxufVxuXG4vKipcbiAqIE5vcm1hbGl6ZSByYXcgZnVuY3Rpb24gZGlyZWN0aXZlcyBpbnRvIG9iamVjdCBmb3JtYXQuXG4gKi9cbmZ1bmN0aW9uIG5vcm1hbGl6ZURpcmVjdGl2ZXMgKG9wdGlvbnMpIHtcbiAgdmFyIGRpcnMgPSBvcHRpb25zLmRpcmVjdGl2ZXM7XG4gIGlmIChkaXJzKSB7XG4gICAgZm9yICh2YXIga2V5IGluIGRpcnMpIHtcbiAgICAgIHZhciBkZWYkJDEgPSBkaXJzW2tleV07XG4gICAgICBpZiAodHlwZW9mIGRlZiQkMSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBkaXJzW2tleV0gPSB7IGJpbmQ6IGRlZiQkMSwgdXBkYXRlOiBkZWYkJDEgfTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gYXNzZXJ0T2JqZWN0VHlwZSAobmFtZSwgdmFsdWUsIHZtKSB7XG4gIGlmICghaXNQbGFpbk9iamVjdCh2YWx1ZSkpIHtcbiAgICB3YXJuKFxuICAgICAgXCJJbnZhbGlkIHZhbHVlIGZvciBvcHRpb24gXFxcIlwiICsgbmFtZSArIFwiXFxcIjogZXhwZWN0ZWQgYW4gT2JqZWN0LCBcIiArXG4gICAgICBcImJ1dCBnb3QgXCIgKyAodG9SYXdUeXBlKHZhbHVlKSkgKyBcIi5cIixcbiAgICAgIHZtXG4gICAgKTtcbiAgfVxufVxuXG4vKipcbiAqIE1lcmdlIHR3byBvcHRpb24gb2JqZWN0cyBpbnRvIGEgbmV3IG9uZS5cbiAqIENvcmUgdXRpbGl0eSB1c2VkIGluIGJvdGggaW5zdGFudGlhdGlvbiBhbmQgaW5oZXJpdGFuY2UuXG4gKi9cbmZ1bmN0aW9uIG1lcmdlT3B0aW9ucyAoXG4gIHBhcmVudCxcbiAgY2hpbGQsXG4gIHZtXG4pIHtcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICBjaGVja0NvbXBvbmVudHMoY2hpbGQpO1xuICB9XG5cbiAgaWYgKHR5cGVvZiBjaGlsZCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGNoaWxkID0gY2hpbGQub3B0aW9ucztcbiAgfVxuXG4gIG5vcm1hbGl6ZVByb3BzKGNoaWxkLCB2bSk7XG4gIG5vcm1hbGl6ZUluamVjdChjaGlsZCwgdm0pO1xuICBub3JtYWxpemVEaXJlY3RpdmVzKGNoaWxkKTtcblxuICAvLyBBcHBseSBleHRlbmRzIGFuZCBtaXhpbnMgb24gdGhlIGNoaWxkIG9wdGlvbnMsXG4gIC8vIGJ1dCBvbmx5IGlmIGl0IGlzIGEgcmF3IG9wdGlvbnMgb2JqZWN0IHRoYXQgaXNuJ3RcbiAgLy8gdGhlIHJlc3VsdCBvZiBhbm90aGVyIG1lcmdlT3B0aW9ucyBjYWxsLlxuICAvLyBPbmx5IG1lcmdlZCBvcHRpb25zIGhhcyB0aGUgX2Jhc2UgcHJvcGVydHkuXG4gIGlmICghY2hpbGQuX2Jhc2UpIHtcbiAgICBpZiAoY2hpbGQuZXh0ZW5kcykge1xuICAgICAgcGFyZW50ID0gbWVyZ2VPcHRpb25zKHBhcmVudCwgY2hpbGQuZXh0ZW5kcywgdm0pO1xuICAgIH1cbiAgICBpZiAoY2hpbGQubWl4aW5zKSB7XG4gICAgICBmb3IgKHZhciBpID0gMCwgbCA9IGNoaWxkLm1peGlucy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgcGFyZW50ID0gbWVyZ2VPcHRpb25zKHBhcmVudCwgY2hpbGQubWl4aW5zW2ldLCB2bSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgdmFyIG9wdGlvbnMgPSB7fTtcbiAgdmFyIGtleTtcbiAgZm9yIChrZXkgaW4gcGFyZW50KSB7XG4gICAgbWVyZ2VGaWVsZChrZXkpO1xuICB9XG4gIGZvciAoa2V5IGluIGNoaWxkKSB7XG4gICAgaWYgKCFoYXNPd24ocGFyZW50LCBrZXkpKSB7XG4gICAgICBtZXJnZUZpZWxkKGtleSk7XG4gICAgfVxuICB9XG4gIGZ1bmN0aW9uIG1lcmdlRmllbGQgKGtleSkge1xuICAgIHZhciBzdHJhdCA9IHN0cmF0c1trZXldIHx8IGRlZmF1bHRTdHJhdDtcbiAgICBvcHRpb25zW2tleV0gPSBzdHJhdChwYXJlbnRba2V5XSwgY2hpbGRba2V5XSwgdm0sIGtleSk7XG4gIH1cbiAgcmV0dXJuIG9wdGlvbnNcbn1cblxuLyoqXG4gKiBSZXNvbHZlIGFuIGFzc2V0LlxuICogVGhpcyBmdW5jdGlvbiBpcyB1c2VkIGJlY2F1c2UgY2hpbGQgaW5zdGFuY2VzIG5lZWQgYWNjZXNzXG4gKiB0byBhc3NldHMgZGVmaW5lZCBpbiBpdHMgYW5jZXN0b3IgY2hhaW4uXG4gKi9cbmZ1bmN0aW9uIHJlc29sdmVBc3NldCAoXG4gIG9wdGlvbnMsXG4gIHR5cGUsXG4gIGlkLFxuICB3YXJuTWlzc2luZ1xuKSB7XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICBpZiAodHlwZW9mIGlkICE9PSAnc3RyaW5nJykge1xuICAgIHJldHVyblxuICB9XG4gIHZhciBhc3NldHMgPSBvcHRpb25zW3R5cGVdO1xuICAvLyBjaGVjayBsb2NhbCByZWdpc3RyYXRpb24gdmFyaWF0aW9ucyBmaXJzdFxuICBpZiAoaGFzT3duKGFzc2V0cywgaWQpKSB7IHJldHVybiBhc3NldHNbaWRdIH1cbiAgdmFyIGNhbWVsaXplZElkID0gY2FtZWxpemUoaWQpO1xuICBpZiAoaGFzT3duKGFzc2V0cywgY2FtZWxpemVkSWQpKSB7IHJldHVybiBhc3NldHNbY2FtZWxpemVkSWRdIH1cbiAgdmFyIFBhc2NhbENhc2VJZCA9IGNhcGl0YWxpemUoY2FtZWxpemVkSWQpO1xuICBpZiAoaGFzT3duKGFzc2V0cywgUGFzY2FsQ2FzZUlkKSkgeyByZXR1cm4gYXNzZXRzW1Bhc2NhbENhc2VJZF0gfVxuICAvLyBmYWxsYmFjayB0byBwcm90b3R5cGUgY2hhaW5cbiAgdmFyIHJlcyA9IGFzc2V0c1tpZF0gfHwgYXNzZXRzW2NhbWVsaXplZElkXSB8fCBhc3NldHNbUGFzY2FsQ2FzZUlkXTtcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgd2Fybk1pc3NpbmcgJiYgIXJlcykge1xuICAgIHdhcm4oXG4gICAgICAnRmFpbGVkIHRvIHJlc29sdmUgJyArIHR5cGUuc2xpY2UoMCwgLTEpICsgJzogJyArIGlkLFxuICAgICAgb3B0aW9uc1xuICAgICk7XG4gIH1cbiAgcmV0dXJuIHJlc1xufVxuXG4vKiAgKi9cblxuXG5cbmZ1bmN0aW9uIHZhbGlkYXRlUHJvcCAoXG4gIGtleSxcbiAgcHJvcE9wdGlvbnMsXG4gIHByb3BzRGF0YSxcbiAgdm1cbikge1xuICB2YXIgcHJvcCA9IHByb3BPcHRpb25zW2tleV07XG4gIHZhciBhYnNlbnQgPSAhaGFzT3duKHByb3BzRGF0YSwga2V5KTtcbiAgdmFyIHZhbHVlID0gcHJvcHNEYXRhW2tleV07XG4gIC8vIGJvb2xlYW4gY2FzdGluZ1xuICB2YXIgYm9vbGVhbkluZGV4ID0gZ2V0VHlwZUluZGV4KEJvb2xlYW4sIHByb3AudHlwZSk7XG4gIGlmIChib29sZWFuSW5kZXggPiAtMSkge1xuICAgIGlmIChhYnNlbnQgJiYgIWhhc093bihwcm9wLCAnZGVmYXVsdCcpKSB7XG4gICAgICB2YWx1ZSA9IGZhbHNlO1xuICAgIH0gZWxzZSBpZiAodmFsdWUgPT09ICcnIHx8IHZhbHVlID09PSBoeXBoZW5hdGUoa2V5KSkge1xuICAgICAgLy8gb25seSBjYXN0IGVtcHR5IHN0cmluZyAvIHNhbWUgbmFtZSB0byBib29sZWFuIGlmXG4gICAgICAvLyBib29sZWFuIGhhcyBoaWdoZXIgcHJpb3JpdHlcbiAgICAgIHZhciBzdHJpbmdJbmRleCA9IGdldFR5cGVJbmRleChTdHJpbmcsIHByb3AudHlwZSk7XG4gICAgICBpZiAoc3RyaW5nSW5kZXggPCAwIHx8IGJvb2xlYW5JbmRleCA8IHN0cmluZ0luZGV4KSB7XG4gICAgICAgIHZhbHVlID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgLy8gY2hlY2sgZGVmYXVsdCB2YWx1ZVxuICBpZiAodmFsdWUgPT09IHVuZGVmaW5lZCkge1xuICAgIHZhbHVlID0gZ2V0UHJvcERlZmF1bHRWYWx1ZSh2bSwgcHJvcCwga2V5KTtcbiAgICAvLyBzaW5jZSB0aGUgZGVmYXVsdCB2YWx1ZSBpcyBhIGZyZXNoIGNvcHksXG4gICAgLy8gbWFrZSBzdXJlIHRvIG9ic2VydmUgaXQuXG4gICAgdmFyIHByZXZTaG91bGRPYnNlcnZlID0gc2hvdWxkT2JzZXJ2ZTtcbiAgICB0b2dnbGVPYnNlcnZpbmcodHJ1ZSk7XG4gICAgb2JzZXJ2ZSh2YWx1ZSk7XG4gICAgdG9nZ2xlT2JzZXJ2aW5nKHByZXZTaG91bGRPYnNlcnZlKTtcbiAgfVxuICBpZiAoXG4gICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJlxuICAgIC8vIHNraXAgdmFsaWRhdGlvbiBmb3Igd2VleCByZWN5Y2xlLWxpc3QgY2hpbGQgY29tcG9uZW50IHByb3BzXG4gICAgIShmYWxzZSlcbiAgKSB7XG4gICAgYXNzZXJ0UHJvcChwcm9wLCBrZXksIHZhbHVlLCB2bSwgYWJzZW50KTtcbiAgfVxuICByZXR1cm4gdmFsdWVcbn1cblxuLyoqXG4gKiBHZXQgdGhlIGRlZmF1bHQgdmFsdWUgb2YgYSBwcm9wLlxuICovXG5mdW5jdGlvbiBnZXRQcm9wRGVmYXVsdFZhbHVlICh2bSwgcHJvcCwga2V5KSB7XG4gIC8vIG5vIGRlZmF1bHQsIHJldHVybiB1bmRlZmluZWRcbiAgaWYgKCFoYXNPd24ocHJvcCwgJ2RlZmF1bHQnKSkge1xuICAgIHJldHVybiB1bmRlZmluZWRcbiAgfVxuICB2YXIgZGVmID0gcHJvcC5kZWZhdWx0O1xuICAvLyB3YXJuIGFnYWluc3Qgbm9uLWZhY3RvcnkgZGVmYXVsdHMgZm9yIE9iamVjdCAmIEFycmF5XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIGlzT2JqZWN0KGRlZikpIHtcbiAgICB3YXJuKFxuICAgICAgJ0ludmFsaWQgZGVmYXVsdCB2YWx1ZSBmb3IgcHJvcCBcIicgKyBrZXkgKyAnXCI6ICcgK1xuICAgICAgJ1Byb3BzIHdpdGggdHlwZSBPYmplY3QvQXJyYXkgbXVzdCB1c2UgYSBmYWN0b3J5IGZ1bmN0aW9uICcgK1xuICAgICAgJ3RvIHJldHVybiB0aGUgZGVmYXVsdCB2YWx1ZS4nLFxuICAgICAgdm1cbiAgICApO1xuICB9XG4gIC8vIHRoZSByYXcgcHJvcCB2YWx1ZSB3YXMgYWxzbyB1bmRlZmluZWQgZnJvbSBwcmV2aW91cyByZW5kZXIsXG4gIC8vIHJldHVybiBwcmV2aW91cyBkZWZhdWx0IHZhbHVlIHRvIGF2b2lkIHVubmVjZXNzYXJ5IHdhdGNoZXIgdHJpZ2dlclxuICBpZiAodm0gJiYgdm0uJG9wdGlvbnMucHJvcHNEYXRhICYmXG4gICAgdm0uJG9wdGlvbnMucHJvcHNEYXRhW2tleV0gPT09IHVuZGVmaW5lZCAmJlxuICAgIHZtLl9wcm9wc1trZXldICE9PSB1bmRlZmluZWRcbiAgKSB7XG4gICAgcmV0dXJuIHZtLl9wcm9wc1trZXldXG4gIH1cbiAgLy8gY2FsbCBmYWN0b3J5IGZ1bmN0aW9uIGZvciBub24tRnVuY3Rpb24gdHlwZXNcbiAgLy8gYSB2YWx1ZSBpcyBGdW5jdGlvbiBpZiBpdHMgcHJvdG90eXBlIGlzIGZ1bmN0aW9uIGV2ZW4gYWNyb3NzIGRpZmZlcmVudCBleGVjdXRpb24gY29udGV4dFxuICByZXR1cm4gdHlwZW9mIGRlZiA9PT0gJ2Z1bmN0aW9uJyAmJiBnZXRUeXBlKHByb3AudHlwZSkgIT09ICdGdW5jdGlvbidcbiAgICA/IGRlZi5jYWxsKHZtKVxuICAgIDogZGVmXG59XG5cbi8qKlxuICogQXNzZXJ0IHdoZXRoZXIgYSBwcm9wIGlzIHZhbGlkLlxuICovXG5mdW5jdGlvbiBhc3NlcnRQcm9wIChcbiAgcHJvcCxcbiAgbmFtZSxcbiAgdmFsdWUsXG4gIHZtLFxuICBhYnNlbnRcbikge1xuICBpZiAocHJvcC5yZXF1aXJlZCAmJiBhYnNlbnQpIHtcbiAgICB3YXJuKFxuICAgICAgJ01pc3NpbmcgcmVxdWlyZWQgcHJvcDogXCInICsgbmFtZSArICdcIicsXG4gICAgICB2bVxuICAgICk7XG4gICAgcmV0dXJuXG4gIH1cbiAgaWYgKHZhbHVlID09IG51bGwgJiYgIXByb3AucmVxdWlyZWQpIHtcbiAgICByZXR1cm5cbiAgfVxuICB2YXIgdHlwZSA9IHByb3AudHlwZTtcbiAgdmFyIHZhbGlkID0gIXR5cGUgfHwgdHlwZSA9PT0gdHJ1ZTtcbiAgdmFyIGV4cGVjdGVkVHlwZXMgPSBbXTtcbiAgaWYgKHR5cGUpIHtcbiAgICBpZiAoIUFycmF5LmlzQXJyYXkodHlwZSkpIHtcbiAgICAgIHR5cGUgPSBbdHlwZV07XG4gICAgfVxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdHlwZS5sZW5ndGggJiYgIXZhbGlkOyBpKyspIHtcbiAgICAgIHZhciBhc3NlcnRlZFR5cGUgPSBhc3NlcnRUeXBlKHZhbHVlLCB0eXBlW2ldKTtcbiAgICAgIGV4cGVjdGVkVHlwZXMucHVzaChhc3NlcnRlZFR5cGUuZXhwZWN0ZWRUeXBlIHx8ICcnKTtcbiAgICAgIHZhbGlkID0gYXNzZXJ0ZWRUeXBlLnZhbGlkO1xuICAgIH1cbiAgfVxuXG4gIGlmICghdmFsaWQpIHtcbiAgICB3YXJuKFxuICAgICAgZ2V0SW52YWxpZFR5cGVNZXNzYWdlKG5hbWUsIHZhbHVlLCBleHBlY3RlZFR5cGVzKSxcbiAgICAgIHZtXG4gICAgKTtcbiAgICByZXR1cm5cbiAgfVxuICB2YXIgdmFsaWRhdG9yID0gcHJvcC52YWxpZGF0b3I7XG4gIGlmICh2YWxpZGF0b3IpIHtcbiAgICBpZiAoIXZhbGlkYXRvcih2YWx1ZSkpIHtcbiAgICAgIHdhcm4oXG4gICAgICAgICdJbnZhbGlkIHByb3A6IGN1c3RvbSB2YWxpZGF0b3IgY2hlY2sgZmFpbGVkIGZvciBwcm9wIFwiJyArIG5hbWUgKyAnXCIuJyxcbiAgICAgICAgdm1cbiAgICAgICk7XG4gICAgfVxuICB9XG59XG5cbnZhciBzaW1wbGVDaGVja1JFID0gL14oU3RyaW5nfE51bWJlcnxCb29sZWFufEZ1bmN0aW9ufFN5bWJvbCkkLztcblxuZnVuY3Rpb24gYXNzZXJ0VHlwZSAodmFsdWUsIHR5cGUpIHtcbiAgdmFyIHZhbGlkO1xuICB2YXIgZXhwZWN0ZWRUeXBlID0gZ2V0VHlwZSh0eXBlKTtcbiAgaWYgKHNpbXBsZUNoZWNrUkUudGVzdChleHBlY3RlZFR5cGUpKSB7XG4gICAgdmFyIHQgPSB0eXBlb2YgdmFsdWU7XG4gICAgdmFsaWQgPSB0ID09PSBleHBlY3RlZFR5cGUudG9Mb3dlckNhc2UoKTtcbiAgICAvLyBmb3IgcHJpbWl0aXZlIHdyYXBwZXIgb2JqZWN0c1xuICAgIGlmICghdmFsaWQgJiYgdCA9PT0gJ29iamVjdCcpIHtcbiAgICAgIHZhbGlkID0gdmFsdWUgaW5zdGFuY2VvZiB0eXBlO1xuICAgIH1cbiAgfSBlbHNlIGlmIChleHBlY3RlZFR5cGUgPT09ICdPYmplY3QnKSB7XG4gICAgdmFsaWQgPSBpc1BsYWluT2JqZWN0KHZhbHVlKTtcbiAgfSBlbHNlIGlmIChleHBlY3RlZFR5cGUgPT09ICdBcnJheScpIHtcbiAgICB2YWxpZCA9IEFycmF5LmlzQXJyYXkodmFsdWUpO1xuICB9IGVsc2Uge1xuICAgIHZhbGlkID0gdmFsdWUgaW5zdGFuY2VvZiB0eXBlO1xuICB9XG4gIHJldHVybiB7XG4gICAgdmFsaWQ6IHZhbGlkLFxuICAgIGV4cGVjdGVkVHlwZTogZXhwZWN0ZWRUeXBlXG4gIH1cbn1cblxuLyoqXG4gKiBVc2UgZnVuY3Rpb24gc3RyaW5nIG5hbWUgdG8gY2hlY2sgYnVpbHQtaW4gdHlwZXMsXG4gKiBiZWNhdXNlIGEgc2ltcGxlIGVxdWFsaXR5IGNoZWNrIHdpbGwgZmFpbCB3aGVuIHJ1bm5pbmdcbiAqIGFjcm9zcyBkaWZmZXJlbnQgdm1zIC8gaWZyYW1lcy5cbiAqL1xuZnVuY3Rpb24gZ2V0VHlwZSAoZm4pIHtcbiAgdmFyIG1hdGNoID0gZm4gJiYgZm4udG9TdHJpbmcoKS5tYXRjaCgvXlxccypmdW5jdGlvbiAoXFx3KykvKTtcbiAgcmV0dXJuIG1hdGNoID8gbWF0Y2hbMV0gOiAnJ1xufVxuXG5mdW5jdGlvbiBpc1NhbWVUeXBlIChhLCBiKSB7XG4gIHJldHVybiBnZXRUeXBlKGEpID09PSBnZXRUeXBlKGIpXG59XG5cbmZ1bmN0aW9uIGdldFR5cGVJbmRleCAodHlwZSwgZXhwZWN0ZWRUeXBlcykge1xuICBpZiAoIUFycmF5LmlzQXJyYXkoZXhwZWN0ZWRUeXBlcykpIHtcbiAgICByZXR1cm4gaXNTYW1lVHlwZShleHBlY3RlZFR5cGVzLCB0eXBlKSA/IDAgOiAtMVxuICB9XG4gIGZvciAodmFyIGkgPSAwLCBsZW4gPSBleHBlY3RlZFR5cGVzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgaWYgKGlzU2FtZVR5cGUoZXhwZWN0ZWRUeXBlc1tpXSwgdHlwZSkpIHtcbiAgICAgIHJldHVybiBpXG4gICAgfVxuICB9XG4gIHJldHVybiAtMVxufVxuXG5mdW5jdGlvbiBnZXRJbnZhbGlkVHlwZU1lc3NhZ2UgKG5hbWUsIHZhbHVlLCBleHBlY3RlZFR5cGVzKSB7XG4gIHZhciBtZXNzYWdlID0gXCJJbnZhbGlkIHByb3A6IHR5cGUgY2hlY2sgZmFpbGVkIGZvciBwcm9wIFxcXCJcIiArIG5hbWUgKyBcIlxcXCIuXCIgK1xuICAgIFwiIEV4cGVjdGVkIFwiICsgKGV4cGVjdGVkVHlwZXMubWFwKGNhcGl0YWxpemUpLmpvaW4oJywgJykpO1xuICB2YXIgZXhwZWN0ZWRUeXBlID0gZXhwZWN0ZWRUeXBlc1swXTtcbiAgdmFyIHJlY2VpdmVkVHlwZSA9IHRvUmF3VHlwZSh2YWx1ZSk7XG4gIHZhciBleHBlY3RlZFZhbHVlID0gc3R5bGVWYWx1ZSh2YWx1ZSwgZXhwZWN0ZWRUeXBlKTtcbiAgdmFyIHJlY2VpdmVkVmFsdWUgPSBzdHlsZVZhbHVlKHZhbHVlLCByZWNlaXZlZFR5cGUpO1xuICAvLyBjaGVjayBpZiB3ZSBuZWVkIHRvIHNwZWNpZnkgZXhwZWN0ZWQgdmFsdWVcbiAgaWYgKGV4cGVjdGVkVHlwZXMubGVuZ3RoID09PSAxICYmXG4gICAgICBpc0V4cGxpY2FibGUoZXhwZWN0ZWRUeXBlKSAmJlxuICAgICAgIWlzQm9vbGVhbihleHBlY3RlZFR5cGUsIHJlY2VpdmVkVHlwZSkpIHtcbiAgICBtZXNzYWdlICs9IFwiIHdpdGggdmFsdWUgXCIgKyBleHBlY3RlZFZhbHVlO1xuICB9XG4gIG1lc3NhZ2UgKz0gXCIsIGdvdCBcIiArIHJlY2VpdmVkVHlwZSArIFwiIFwiO1xuICAvLyBjaGVjayBpZiB3ZSBuZWVkIHRvIHNwZWNpZnkgcmVjZWl2ZWQgdmFsdWVcbiAgaWYgKGlzRXhwbGljYWJsZShyZWNlaXZlZFR5cGUpKSB7XG4gICAgbWVzc2FnZSArPSBcIndpdGggdmFsdWUgXCIgKyByZWNlaXZlZFZhbHVlICsgXCIuXCI7XG4gIH1cbiAgcmV0dXJuIG1lc3NhZ2Vcbn1cblxuZnVuY3Rpb24gc3R5bGVWYWx1ZSAodmFsdWUsIHR5cGUpIHtcbiAgaWYgKHR5cGUgPT09ICdTdHJpbmcnKSB7XG4gICAgcmV0dXJuIChcIlxcXCJcIiArIHZhbHVlICsgXCJcXFwiXCIpXG4gIH0gZWxzZSBpZiAodHlwZSA9PT0gJ051bWJlcicpIHtcbiAgICByZXR1cm4gKFwiXCIgKyAoTnVtYmVyKHZhbHVlKSkpXG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIChcIlwiICsgdmFsdWUpXG4gIH1cbn1cblxuZnVuY3Rpb24gaXNFeHBsaWNhYmxlICh2YWx1ZSkge1xuICB2YXIgZXhwbGljaXRUeXBlcyA9IFsnc3RyaW5nJywgJ251bWJlcicsICdib29sZWFuJ107XG4gIHJldHVybiBleHBsaWNpdFR5cGVzLnNvbWUoZnVuY3Rpb24gKGVsZW0pIHsgcmV0dXJuIHZhbHVlLnRvTG93ZXJDYXNlKCkgPT09IGVsZW07IH0pXG59XG5cbmZ1bmN0aW9uIGlzQm9vbGVhbiAoKSB7XG4gIHZhciBhcmdzID0gW10sIGxlbiA9IGFyZ3VtZW50cy5sZW5ndGg7XG4gIHdoaWxlICggbGVuLS0gKSBhcmdzWyBsZW4gXSA9IGFyZ3VtZW50c1sgbGVuIF07XG5cbiAgcmV0dXJuIGFyZ3Muc29tZShmdW5jdGlvbiAoZWxlbSkgeyByZXR1cm4gZWxlbS50b0xvd2VyQ2FzZSgpID09PSAnYm9vbGVhbic7IH0pXG59XG5cbi8qICAqL1xuXG5mdW5jdGlvbiBoYW5kbGVFcnJvciAoZXJyLCB2bSwgaW5mbykge1xuICAvLyBEZWFjdGl2YXRlIGRlcHMgdHJhY2tpbmcgd2hpbGUgcHJvY2Vzc2luZyBlcnJvciBoYW5kbGVyIHRvIGF2b2lkIHBvc3NpYmxlIGluZmluaXRlIHJlbmRlcmluZy5cbiAgLy8gU2VlOiBodHRwczovL2dpdGh1Yi5jb20vdnVlanMvdnVleC9pc3N1ZXMvMTUwNVxuICBwdXNoVGFyZ2V0KCk7XG4gIHRyeSB7XG4gICAgaWYgKHZtKSB7XG4gICAgICB2YXIgY3VyID0gdm07XG4gICAgICB3aGlsZSAoKGN1ciA9IGN1ci4kcGFyZW50KSkge1xuICAgICAgICB2YXIgaG9va3MgPSBjdXIuJG9wdGlvbnMuZXJyb3JDYXB0dXJlZDtcbiAgICAgICAgaWYgKGhvb2tzKSB7XG4gICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBob29rcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgdmFyIGNhcHR1cmUgPSBob29rc1tpXS5jYWxsKGN1ciwgZXJyLCB2bSwgaW5mbykgPT09IGZhbHNlO1xuICAgICAgICAgICAgICBpZiAoY2FwdHVyZSkgeyByZXR1cm4gfVxuICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICBnbG9iYWxIYW5kbGVFcnJvcihlLCBjdXIsICdlcnJvckNhcHR1cmVkIGhvb2snKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgZ2xvYmFsSGFuZGxlRXJyb3IoZXJyLCB2bSwgaW5mbyk7XG4gIH0gZmluYWxseSB7XG4gICAgcG9wVGFyZ2V0KCk7XG4gIH1cbn1cblxuZnVuY3Rpb24gaW52b2tlV2l0aEVycm9ySGFuZGxpbmcgKFxuICBoYW5kbGVyLFxuICBjb250ZXh0LFxuICBhcmdzLFxuICB2bSxcbiAgaW5mb1xuKSB7XG4gIHZhciByZXM7XG4gIHRyeSB7XG4gICAgcmVzID0gYXJncyA/IGhhbmRsZXIuYXBwbHkoY29udGV4dCwgYXJncykgOiBoYW5kbGVyLmNhbGwoY29udGV4dCk7XG4gICAgaWYgKHJlcyAmJiAhcmVzLl9pc1Z1ZSAmJiBpc1Byb21pc2UocmVzKSAmJiAhcmVzLl9oYW5kbGVkKSB7XG4gICAgICByZXMuY2F0Y2goZnVuY3Rpb24gKGUpIHsgcmV0dXJuIGhhbmRsZUVycm9yKGUsIHZtLCBpbmZvICsgXCIgKFByb21pc2UvYXN5bmMpXCIpOyB9KTtcbiAgICAgIC8vIGlzc3VlICM5NTExXG4gICAgICAvLyBhdm9pZCBjYXRjaCB0cmlnZ2VyaW5nIG11bHRpcGxlIHRpbWVzIHdoZW4gbmVzdGVkIGNhbGxzXG4gICAgICByZXMuX2hhbmRsZWQgPSB0cnVlO1xuICAgIH1cbiAgfSBjYXRjaCAoZSkge1xuICAgIGhhbmRsZUVycm9yKGUsIHZtLCBpbmZvKTtcbiAgfVxuICByZXR1cm4gcmVzXG59XG5cbmZ1bmN0aW9uIGdsb2JhbEhhbmRsZUVycm9yIChlcnIsIHZtLCBpbmZvKSB7XG4gIGlmIChjb25maWcuZXJyb3JIYW5kbGVyKSB7XG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiBjb25maWcuZXJyb3JIYW5kbGVyLmNhbGwobnVsbCwgZXJyLCB2bSwgaW5mbylcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICAvLyBpZiB0aGUgdXNlciBpbnRlbnRpb25hbGx5IHRocm93cyB0aGUgb3JpZ2luYWwgZXJyb3IgaW4gdGhlIGhhbmRsZXIsXG4gICAgICAvLyBkbyBub3QgbG9nIGl0IHR3aWNlXG4gICAgICBpZiAoZSAhPT0gZXJyKSB7XG4gICAgICAgIGxvZ0Vycm9yKGUsIG51bGwsICdjb25maWcuZXJyb3JIYW5kbGVyJyk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGxvZ0Vycm9yKGVyciwgdm0sIGluZm8pO1xufVxuXG5mdW5jdGlvbiBsb2dFcnJvciAoZXJyLCB2bSwgaW5mbykge1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgIHdhcm4oKFwiRXJyb3IgaW4gXCIgKyBpbmZvICsgXCI6IFxcXCJcIiArIChlcnIudG9TdHJpbmcoKSkgKyBcIlxcXCJcIiksIHZtKTtcbiAgfVxuICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICBpZiAoKGluQnJvd3NlciB8fCBpbldlZXgpICYmIHR5cGVvZiBjb25zb2xlICE9PSAndW5kZWZpbmVkJykge1xuICAgIGNvbnNvbGUuZXJyb3IoZXJyKTtcbiAgfSBlbHNlIHtcbiAgICB0aHJvdyBlcnJcbiAgfVxufVxuXG4vKiAgKi9cblxudmFyIGlzVXNpbmdNaWNyb1Rhc2sgPSBmYWxzZTtcblxudmFyIGNhbGxiYWNrcyA9IFtdO1xudmFyIHBlbmRpbmcgPSBmYWxzZTtcblxuZnVuY3Rpb24gZmx1c2hDYWxsYmFja3MgKCkge1xuICBwZW5kaW5nID0gZmFsc2U7XG4gIHZhciBjb3BpZXMgPSBjYWxsYmFja3Muc2xpY2UoMCk7XG4gIGNhbGxiYWNrcy5sZW5ndGggPSAwO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGNvcGllcy5sZW5ndGg7IGkrKykge1xuICAgIGNvcGllc1tpXSgpO1xuICB9XG59XG5cbi8vIEhlcmUgd2UgaGF2ZSBhc3luYyBkZWZlcnJpbmcgd3JhcHBlcnMgdXNpbmcgbWljcm90YXNrcy5cbi8vIEluIDIuNSB3ZSB1c2VkIChtYWNybykgdGFza3MgKGluIGNvbWJpbmF0aW9uIHdpdGggbWljcm90YXNrcykuXG4vLyBIb3dldmVyLCBpdCBoYXMgc3VidGxlIHByb2JsZW1zIHdoZW4gc3RhdGUgaXMgY2hhbmdlZCByaWdodCBiZWZvcmUgcmVwYWludFxuLy8gKGUuZy4gIzY4MTMsIG91dC1pbiB0cmFuc2l0aW9ucykuXG4vLyBBbHNvLCB1c2luZyAobWFjcm8pIHRhc2tzIGluIGV2ZW50IGhhbmRsZXIgd291bGQgY2F1c2Ugc29tZSB3ZWlyZCBiZWhhdmlvcnNcbi8vIHRoYXQgY2Fubm90IGJlIGNpcmN1bXZlbnRlZCAoZS5nLiAjNzEwOSwgIzcxNTMsICM3NTQ2LCAjNzgzNCwgIzgxMDkpLlxuLy8gU28gd2Ugbm93IHVzZSBtaWNyb3Rhc2tzIGV2ZXJ5d2hlcmUsIGFnYWluLlxuLy8gQSBtYWpvciBkcmF3YmFjayBvZiB0aGlzIHRyYWRlb2ZmIGlzIHRoYXQgdGhlcmUgYXJlIHNvbWUgc2NlbmFyaW9zXG4vLyB3aGVyZSBtaWNyb3Rhc2tzIGhhdmUgdG9vIGhpZ2ggYSBwcmlvcml0eSBhbmQgZmlyZSBpbiBiZXR3ZWVuIHN1cHBvc2VkbHlcbi8vIHNlcXVlbnRpYWwgZXZlbnRzIChlLmcuICM0NTIxLCAjNjY5MCwgd2hpY2ggaGF2ZSB3b3JrYXJvdW5kcylcbi8vIG9yIGV2ZW4gYmV0d2VlbiBidWJibGluZyBvZiB0aGUgc2FtZSBldmVudCAoIzY1NjYpLlxudmFyIHRpbWVyRnVuYztcblxuLy8gVGhlIG5leHRUaWNrIGJlaGF2aW9yIGxldmVyYWdlcyB0aGUgbWljcm90YXNrIHF1ZXVlLCB3aGljaCBjYW4gYmUgYWNjZXNzZWRcbi8vIHZpYSBlaXRoZXIgbmF0aXZlIFByb21pc2UudGhlbiBvciBNdXRhdGlvbk9ic2VydmVyLlxuLy8gTXV0YXRpb25PYnNlcnZlciBoYXMgd2lkZXIgc3VwcG9ydCwgaG93ZXZlciBpdCBpcyBzZXJpb3VzbHkgYnVnZ2VkIGluXG4vLyBVSVdlYlZpZXcgaW4gaU9TID49IDkuMy4zIHdoZW4gdHJpZ2dlcmVkIGluIHRvdWNoIGV2ZW50IGhhbmRsZXJzLiBJdFxuLy8gY29tcGxldGVseSBzdG9wcyB3b3JraW5nIGFmdGVyIHRyaWdnZXJpbmcgYSBmZXcgdGltZXMuLi4gc28sIGlmIG5hdGl2ZVxuLy8gUHJvbWlzZSBpcyBhdmFpbGFibGUsIHdlIHdpbGwgdXNlIGl0OlxuLyogaXN0YW5idWwgaWdub3JlIG5leHQsICRmbG93LWRpc2FibGUtbGluZSAqL1xuaWYgKHR5cGVvZiBQcm9taXNlICE9PSAndW5kZWZpbmVkJyAmJiBpc05hdGl2ZShQcm9taXNlKSkge1xuICB2YXIgcCA9IFByb21pc2UucmVzb2x2ZSgpO1xuICB0aW1lckZ1bmMgPSBmdW5jdGlvbiAoKSB7XG4gICAgcC50aGVuKGZsdXNoQ2FsbGJhY2tzKTtcbiAgICAvLyBJbiBwcm9ibGVtYXRpYyBVSVdlYlZpZXdzLCBQcm9taXNlLnRoZW4gZG9lc24ndCBjb21wbGV0ZWx5IGJyZWFrLCBidXRcbiAgICAvLyBpdCBjYW4gZ2V0IHN0dWNrIGluIGEgd2VpcmQgc3RhdGUgd2hlcmUgY2FsbGJhY2tzIGFyZSBwdXNoZWQgaW50byB0aGVcbiAgICAvLyBtaWNyb3Rhc2sgcXVldWUgYnV0IHRoZSBxdWV1ZSBpc24ndCBiZWluZyBmbHVzaGVkLCB1bnRpbCB0aGUgYnJvd3NlclxuICAgIC8vIG5lZWRzIHRvIGRvIHNvbWUgb3RoZXIgd29yaywgZS5nLiBoYW5kbGUgYSB0aW1lci4gVGhlcmVmb3JlIHdlIGNhblxuICAgIC8vIFwiZm9yY2VcIiB0aGUgbWljcm90YXNrIHF1ZXVlIHRvIGJlIGZsdXNoZWQgYnkgYWRkaW5nIGFuIGVtcHR5IHRpbWVyLlxuICAgIGlmIChpc0lPUykgeyBzZXRUaW1lb3V0KG5vb3ApOyB9XG4gIH07XG4gIGlzVXNpbmdNaWNyb1Rhc2sgPSB0cnVlO1xufSBlbHNlIGlmICghaXNJRSAmJiB0eXBlb2YgTXV0YXRpb25PYnNlcnZlciAhPT0gJ3VuZGVmaW5lZCcgJiYgKFxuICBpc05hdGl2ZShNdXRhdGlvbk9ic2VydmVyKSB8fFxuICAvLyBQaGFudG9tSlMgYW5kIGlPUyA3LnhcbiAgTXV0YXRpb25PYnNlcnZlci50b1N0cmluZygpID09PSAnW29iamVjdCBNdXRhdGlvbk9ic2VydmVyQ29uc3RydWN0b3JdJ1xuKSkge1xuICAvLyBVc2UgTXV0YXRpb25PYnNlcnZlciB3aGVyZSBuYXRpdmUgUHJvbWlzZSBpcyBub3QgYXZhaWxhYmxlLFxuICAvLyBlLmcuIFBoYW50b21KUywgaU9TNywgQW5kcm9pZCA0LjRcbiAgLy8gKCM2NDY2IE11dGF0aW9uT2JzZXJ2ZXIgaXMgdW5yZWxpYWJsZSBpbiBJRTExKVxuICB2YXIgY291bnRlciA9IDE7XG4gIHZhciBvYnNlcnZlciA9IG5ldyBNdXRhdGlvbk9ic2VydmVyKGZsdXNoQ2FsbGJhY2tzKTtcbiAgdmFyIHRleHROb2RlID0gZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoU3RyaW5nKGNvdW50ZXIpKTtcbiAgb2JzZXJ2ZXIub2JzZXJ2ZSh0ZXh0Tm9kZSwge1xuICAgIGNoYXJhY3RlckRhdGE6IHRydWVcbiAgfSk7XG4gIHRpbWVyRnVuYyA9IGZ1bmN0aW9uICgpIHtcbiAgICBjb3VudGVyID0gKGNvdW50ZXIgKyAxKSAlIDI7XG4gICAgdGV4dE5vZGUuZGF0YSA9IFN0cmluZyhjb3VudGVyKTtcbiAgfTtcbiAgaXNVc2luZ01pY3JvVGFzayA9IHRydWU7XG59IGVsc2UgaWYgKHR5cGVvZiBzZXRJbW1lZGlhdGUgIT09ICd1bmRlZmluZWQnICYmIGlzTmF0aXZlKHNldEltbWVkaWF0ZSkpIHtcbiAgLy8gRmFsbGJhY2sgdG8gc2V0SW1tZWRpYXRlLlxuICAvLyBUZWNoaW5pY2FsbHkgaXQgbGV2ZXJhZ2VzIHRoZSAobWFjcm8pIHRhc2sgcXVldWUsXG4gIC8vIGJ1dCBpdCBpcyBzdGlsbCBhIGJldHRlciBjaG9pY2UgdGhhbiBzZXRUaW1lb3V0LlxuICB0aW1lckZ1bmMgPSBmdW5jdGlvbiAoKSB7XG4gICAgc2V0SW1tZWRpYXRlKGZsdXNoQ2FsbGJhY2tzKTtcbiAgfTtcbn0gZWxzZSB7XG4gIC8vIEZhbGxiYWNrIHRvIHNldFRpbWVvdXQuXG4gIHRpbWVyRnVuYyA9IGZ1bmN0aW9uICgpIHtcbiAgICBzZXRUaW1lb3V0KGZsdXNoQ2FsbGJhY2tzLCAwKTtcbiAgfTtcbn1cblxuZnVuY3Rpb24gbmV4dFRpY2sgKGNiLCBjdHgpIHtcbiAgdmFyIF9yZXNvbHZlO1xuICBjYWxsYmFja3MucHVzaChmdW5jdGlvbiAoKSB7XG4gICAgaWYgKGNiKSB7XG4gICAgICB0cnkge1xuICAgICAgICBjYi5jYWxsKGN0eCk7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGhhbmRsZUVycm9yKGUsIGN0eCwgJ25leHRUaWNrJyk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChfcmVzb2x2ZSkge1xuICAgICAgX3Jlc29sdmUoY3R4KTtcbiAgICB9XG4gIH0pO1xuICBpZiAoIXBlbmRpbmcpIHtcbiAgICBwZW5kaW5nID0gdHJ1ZTtcbiAgICB0aW1lckZ1bmMoKTtcbiAgfVxuICAvLyAkZmxvdy1kaXNhYmxlLWxpbmVcbiAgaWYgKCFjYiAmJiB0eXBlb2YgUHJvbWlzZSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUpIHtcbiAgICAgIF9yZXNvbHZlID0gcmVzb2x2ZTtcbiAgICB9KVxuICB9XG59XG5cbi8qICAqL1xuXG52YXIgbWFyaztcbnZhciBtZWFzdXJlO1xuXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICB2YXIgcGVyZiA9IGluQnJvd3NlciAmJiB3aW5kb3cucGVyZm9ybWFuY2U7XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICBpZiAoXG4gICAgcGVyZiAmJlxuICAgIHBlcmYubWFyayAmJlxuICAgIHBlcmYubWVhc3VyZSAmJlxuICAgIHBlcmYuY2xlYXJNYXJrcyAmJlxuICAgIHBlcmYuY2xlYXJNZWFzdXJlc1xuICApIHtcbiAgICBtYXJrID0gZnVuY3Rpb24gKHRhZykgeyByZXR1cm4gcGVyZi5tYXJrKHRhZyk7IH07XG4gICAgbWVhc3VyZSA9IGZ1bmN0aW9uIChuYW1lLCBzdGFydFRhZywgZW5kVGFnKSB7XG4gICAgICBwZXJmLm1lYXN1cmUobmFtZSwgc3RhcnRUYWcsIGVuZFRhZyk7XG4gICAgICBwZXJmLmNsZWFyTWFya3Moc3RhcnRUYWcpO1xuICAgICAgcGVyZi5jbGVhck1hcmtzKGVuZFRhZyk7XG4gICAgICAvLyBwZXJmLmNsZWFyTWVhc3VyZXMobmFtZSlcbiAgICB9O1xuICB9XG59XG5cbi8qIG5vdCB0eXBlIGNoZWNraW5nIHRoaXMgZmlsZSBiZWNhdXNlIGZsb3cgZG9lc24ndCBwbGF5IHdlbGwgd2l0aCBQcm94eSAqL1xuXG52YXIgaW5pdFByb3h5O1xuXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICB2YXIgYWxsb3dlZEdsb2JhbHMgPSBtYWtlTWFwKFxuICAgICdJbmZpbml0eSx1bmRlZmluZWQsTmFOLGlzRmluaXRlLGlzTmFOLCcgK1xuICAgICdwYXJzZUZsb2F0LHBhcnNlSW50LGRlY29kZVVSSSxkZWNvZGVVUklDb21wb25lbnQsZW5jb2RlVVJJLGVuY29kZVVSSUNvbXBvbmVudCwnICtcbiAgICAnTWF0aCxOdW1iZXIsRGF0ZSxBcnJheSxPYmplY3QsQm9vbGVhbixTdHJpbmcsUmVnRXhwLE1hcCxTZXQsSlNPTixJbnRsLCcgK1xuICAgICdyZXF1aXJlJyAvLyBmb3IgV2VicGFjay9Ccm93c2VyaWZ5XG4gICk7XG5cbiAgdmFyIHdhcm5Ob25QcmVzZW50ID0gZnVuY3Rpb24gKHRhcmdldCwga2V5KSB7XG4gICAgd2FybihcbiAgICAgIFwiUHJvcGVydHkgb3IgbWV0aG9kIFxcXCJcIiArIGtleSArIFwiXFxcIiBpcyBub3QgZGVmaW5lZCBvbiB0aGUgaW5zdGFuY2UgYnV0IFwiICtcbiAgICAgICdyZWZlcmVuY2VkIGR1cmluZyByZW5kZXIuIE1ha2Ugc3VyZSB0aGF0IHRoaXMgcHJvcGVydHkgaXMgcmVhY3RpdmUsICcgK1xuICAgICAgJ2VpdGhlciBpbiB0aGUgZGF0YSBvcHRpb24sIG9yIGZvciBjbGFzcy1iYXNlZCBjb21wb25lbnRzLCBieSAnICtcbiAgICAgICdpbml0aWFsaXppbmcgdGhlIHByb3BlcnR5LiAnICtcbiAgICAgICdTZWU6IGh0dHBzOi8vdnVlanMub3JnL3YyL2d1aWRlL3JlYWN0aXZpdHkuaHRtbCNEZWNsYXJpbmctUmVhY3RpdmUtUHJvcGVydGllcy4nLFxuICAgICAgdGFyZ2V0XG4gICAgKTtcbiAgfTtcblxuICB2YXIgd2FyblJlc2VydmVkUHJlZml4ID0gZnVuY3Rpb24gKHRhcmdldCwga2V5KSB7XG4gICAgd2FybihcbiAgICAgIFwiUHJvcGVydHkgXFxcIlwiICsga2V5ICsgXCJcXFwiIG11c3QgYmUgYWNjZXNzZWQgd2l0aCBcXFwiJGRhdGEuXCIgKyBrZXkgKyBcIlxcXCIgYmVjYXVzZSBcIiArXG4gICAgICAncHJvcGVydGllcyBzdGFydGluZyB3aXRoIFwiJFwiIG9yIFwiX1wiIGFyZSBub3QgcHJveGllZCBpbiB0aGUgVnVlIGluc3RhbmNlIHRvICcgK1xuICAgICAgJ3ByZXZlbnQgY29uZmxpY3RzIHdpdGggVnVlIGludGVybmFscycgK1xuICAgICAgJ1NlZTogaHR0cHM6Ly92dWVqcy5vcmcvdjIvYXBpLyNkYXRhJyxcbiAgICAgIHRhcmdldFxuICAgICk7XG4gIH07XG5cbiAgdmFyIGhhc1Byb3h5ID1cbiAgICB0eXBlb2YgUHJveHkgIT09ICd1bmRlZmluZWQnICYmIGlzTmF0aXZlKFByb3h5KTtcblxuICBpZiAoaGFzUHJveHkpIHtcbiAgICB2YXIgaXNCdWlsdEluTW9kaWZpZXIgPSBtYWtlTWFwKCdzdG9wLHByZXZlbnQsc2VsZixjdHJsLHNoaWZ0LGFsdCxtZXRhLGV4YWN0Jyk7XG4gICAgY29uZmlnLmtleUNvZGVzID0gbmV3IFByb3h5KGNvbmZpZy5rZXlDb2Rlcywge1xuICAgICAgc2V0OiBmdW5jdGlvbiBzZXQgKHRhcmdldCwga2V5LCB2YWx1ZSkge1xuICAgICAgICBpZiAoaXNCdWlsdEluTW9kaWZpZXIoa2V5KSkge1xuICAgICAgICAgIHdhcm4oKFwiQXZvaWQgb3ZlcndyaXRpbmcgYnVpbHQtaW4gbW9kaWZpZXIgaW4gY29uZmlnLmtleUNvZGVzOiAuXCIgKyBrZXkpKTtcbiAgICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0YXJnZXRba2V5XSA9IHZhbHVlO1xuICAgICAgICAgIHJldHVybiB0cnVlXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIHZhciBoYXNIYW5kbGVyID0ge1xuICAgIGhhczogZnVuY3Rpb24gaGFzICh0YXJnZXQsIGtleSkge1xuICAgICAgdmFyIGhhcyA9IGtleSBpbiB0YXJnZXQ7XG4gICAgICB2YXIgaXNBbGxvd2VkID0gYWxsb3dlZEdsb2JhbHMoa2V5KSB8fFxuICAgICAgICAodHlwZW9mIGtleSA9PT0gJ3N0cmluZycgJiYga2V5LmNoYXJBdCgwKSA9PT0gJ18nICYmICEoa2V5IGluIHRhcmdldC4kZGF0YSkpO1xuICAgICAgaWYgKCFoYXMgJiYgIWlzQWxsb3dlZCkge1xuICAgICAgICBpZiAoa2V5IGluIHRhcmdldC4kZGF0YSkgeyB3YXJuUmVzZXJ2ZWRQcmVmaXgodGFyZ2V0LCBrZXkpOyB9XG4gICAgICAgIGVsc2UgeyB3YXJuTm9uUHJlc2VudCh0YXJnZXQsIGtleSk7IH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBoYXMgfHwgIWlzQWxsb3dlZFxuICAgIH1cbiAgfTtcblxuICB2YXIgZ2V0SGFuZGxlciA9IHtcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCAodGFyZ2V0LCBrZXkpIHtcbiAgICAgIGlmICh0eXBlb2Yga2V5ID09PSAnc3RyaW5nJyAmJiAhKGtleSBpbiB0YXJnZXQpKSB7XG4gICAgICAgIGlmIChrZXkgaW4gdGFyZ2V0LiRkYXRhKSB7IHdhcm5SZXNlcnZlZFByZWZpeCh0YXJnZXQsIGtleSk7IH1cbiAgICAgICAgZWxzZSB7IHdhcm5Ob25QcmVzZW50KHRhcmdldCwga2V5KTsgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHRhcmdldFtrZXldXG4gICAgfVxuICB9O1xuXG4gIGluaXRQcm94eSA9IGZ1bmN0aW9uIGluaXRQcm94eSAodm0pIHtcbiAgICBpZiAoaGFzUHJveHkpIHtcbiAgICAgIC8vIGRldGVybWluZSB3aGljaCBwcm94eSBoYW5kbGVyIHRvIHVzZVxuICAgICAgdmFyIG9wdGlvbnMgPSB2bS4kb3B0aW9ucztcbiAgICAgIHZhciBoYW5kbGVycyA9IG9wdGlvbnMucmVuZGVyICYmIG9wdGlvbnMucmVuZGVyLl93aXRoU3RyaXBwZWRcbiAgICAgICAgPyBnZXRIYW5kbGVyXG4gICAgICAgIDogaGFzSGFuZGxlcjtcbiAgICAgIHZtLl9yZW5kZXJQcm94eSA9IG5ldyBQcm94eSh2bSwgaGFuZGxlcnMpO1xuICAgIH0gZWxzZSB7XG4gICAgICB2bS5fcmVuZGVyUHJveHkgPSB2bTtcbiAgICB9XG4gIH07XG59XG5cbi8qICAqL1xuXG52YXIgc2Vlbk9iamVjdHMgPSBuZXcgX1NldCgpO1xuXG4vKipcbiAqIFJlY3Vyc2l2ZWx5IHRyYXZlcnNlIGFuIG9iamVjdCB0byBldm9rZSBhbGwgY29udmVydGVkXG4gKiBnZXR0ZXJzLCBzbyB0aGF0IGV2ZXJ5IG5lc3RlZCBwcm9wZXJ0eSBpbnNpZGUgdGhlIG9iamVjdFxuICogaXMgY29sbGVjdGVkIGFzIGEgXCJkZWVwXCIgZGVwZW5kZW5jeS5cbiAqL1xuZnVuY3Rpb24gdHJhdmVyc2UgKHZhbCkge1xuICBfdHJhdmVyc2UodmFsLCBzZWVuT2JqZWN0cyk7XG4gIHNlZW5PYmplY3RzLmNsZWFyKCk7XG59XG5cbmZ1bmN0aW9uIF90cmF2ZXJzZSAodmFsLCBzZWVuKSB7XG4gIHZhciBpLCBrZXlzO1xuICB2YXIgaXNBID0gQXJyYXkuaXNBcnJheSh2YWwpO1xuICBpZiAoKCFpc0EgJiYgIWlzT2JqZWN0KHZhbCkpIHx8IE9iamVjdC5pc0Zyb3plbih2YWwpIHx8IHZhbCBpbnN0YW5jZW9mIFZOb2RlKSB7XG4gICAgcmV0dXJuXG4gIH1cbiAgaWYgKHZhbC5fX29iX18pIHtcbiAgICB2YXIgZGVwSWQgPSB2YWwuX19vYl9fLmRlcC5pZDtcbiAgICBpZiAoc2Vlbi5oYXMoZGVwSWQpKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG4gICAgc2Vlbi5hZGQoZGVwSWQpO1xuICB9XG4gIGlmIChpc0EpIHtcbiAgICBpID0gdmFsLmxlbmd0aDtcbiAgICB3aGlsZSAoaS0tKSB7IF90cmF2ZXJzZSh2YWxbaV0sIHNlZW4pOyB9XG4gIH0gZWxzZSB7XG4gICAga2V5cyA9IE9iamVjdC5rZXlzKHZhbCk7XG4gICAgaSA9IGtleXMubGVuZ3RoO1xuICAgIHdoaWxlIChpLS0pIHsgX3RyYXZlcnNlKHZhbFtrZXlzW2ldXSwgc2Vlbik7IH1cbiAgfVxufVxuXG4vKiAgKi9cblxudmFyIG5vcm1hbGl6ZUV2ZW50ID0gY2FjaGVkKGZ1bmN0aW9uIChuYW1lKSB7XG4gIHZhciBwYXNzaXZlID0gbmFtZS5jaGFyQXQoMCkgPT09ICcmJztcbiAgbmFtZSA9IHBhc3NpdmUgPyBuYW1lLnNsaWNlKDEpIDogbmFtZTtcbiAgdmFyIG9uY2UkJDEgPSBuYW1lLmNoYXJBdCgwKSA9PT0gJ34nOyAvLyBQcmVmaXhlZCBsYXN0LCBjaGVja2VkIGZpcnN0XG4gIG5hbWUgPSBvbmNlJCQxID8gbmFtZS5zbGljZSgxKSA6IG5hbWU7XG4gIHZhciBjYXB0dXJlID0gbmFtZS5jaGFyQXQoMCkgPT09ICchJztcbiAgbmFtZSA9IGNhcHR1cmUgPyBuYW1lLnNsaWNlKDEpIDogbmFtZTtcbiAgcmV0dXJuIHtcbiAgICBuYW1lOiBuYW1lLFxuICAgIG9uY2U6IG9uY2UkJDEsXG4gICAgY2FwdHVyZTogY2FwdHVyZSxcbiAgICBwYXNzaXZlOiBwYXNzaXZlXG4gIH1cbn0pO1xuXG5mdW5jdGlvbiBjcmVhdGVGbkludm9rZXIgKGZucywgdm0pIHtcbiAgZnVuY3Rpb24gaW52b2tlciAoKSB7XG4gICAgdmFyIGFyZ3VtZW50cyQxID0gYXJndW1lbnRzO1xuXG4gICAgdmFyIGZucyA9IGludm9rZXIuZm5zO1xuICAgIGlmIChBcnJheS5pc0FycmF5KGZucykpIHtcbiAgICAgIHZhciBjbG9uZWQgPSBmbnMuc2xpY2UoKTtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2xvbmVkLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGludm9rZVdpdGhFcnJvckhhbmRsaW5nKGNsb25lZFtpXSwgbnVsbCwgYXJndW1lbnRzJDEsIHZtLCBcInYtb24gaGFuZGxlclwiKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgLy8gcmV0dXJuIGhhbmRsZXIgcmV0dXJuIHZhbHVlIGZvciBzaW5nbGUgaGFuZGxlcnNcbiAgICAgIHJldHVybiBpbnZva2VXaXRoRXJyb3JIYW5kbGluZyhmbnMsIG51bGwsIGFyZ3VtZW50cywgdm0sIFwidi1vbiBoYW5kbGVyXCIpXG4gICAgfVxuICB9XG4gIGludm9rZXIuZm5zID0gZm5zO1xuICByZXR1cm4gaW52b2tlclxufVxuXG5mdW5jdGlvbiB1cGRhdGVMaXN0ZW5lcnMgKFxuICBvbixcbiAgb2xkT24sXG4gIGFkZCxcbiAgcmVtb3ZlJCQxLFxuICBjcmVhdGVPbmNlSGFuZGxlcixcbiAgdm1cbikge1xuICB2YXIgbmFtZSwgZGVmJCQxLCBjdXIsIG9sZCwgZXZlbnQ7XG4gIGZvciAobmFtZSBpbiBvbikge1xuICAgIGRlZiQkMSA9IGN1ciA9IG9uW25hbWVdO1xuICAgIG9sZCA9IG9sZE9uW25hbWVdO1xuICAgIGV2ZW50ID0gbm9ybWFsaXplRXZlbnQobmFtZSk7XG4gICAgaWYgKGlzVW5kZWYoY3VyKSkge1xuICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiB3YXJuKFxuICAgICAgICBcIkludmFsaWQgaGFuZGxlciBmb3IgZXZlbnQgXFxcIlwiICsgKGV2ZW50Lm5hbWUpICsgXCJcXFwiOiBnb3QgXCIgKyBTdHJpbmcoY3VyKSxcbiAgICAgICAgdm1cbiAgICAgICk7XG4gICAgfSBlbHNlIGlmIChpc1VuZGVmKG9sZCkpIHtcbiAgICAgIGlmIChpc1VuZGVmKGN1ci5mbnMpKSB7XG4gICAgICAgIGN1ciA9IG9uW25hbWVdID0gY3JlYXRlRm5JbnZva2VyKGN1ciwgdm0pO1xuICAgICAgfVxuICAgICAgaWYgKGlzVHJ1ZShldmVudC5vbmNlKSkge1xuICAgICAgICBjdXIgPSBvbltuYW1lXSA9IGNyZWF0ZU9uY2VIYW5kbGVyKGV2ZW50Lm5hbWUsIGN1ciwgZXZlbnQuY2FwdHVyZSk7XG4gICAgICB9XG4gICAgICBhZGQoZXZlbnQubmFtZSwgY3VyLCBldmVudC5jYXB0dXJlLCBldmVudC5wYXNzaXZlLCBldmVudC5wYXJhbXMpO1xuICAgIH0gZWxzZSBpZiAoY3VyICE9PSBvbGQpIHtcbiAgICAgIG9sZC5mbnMgPSBjdXI7XG4gICAgICBvbltuYW1lXSA9IG9sZDtcbiAgICB9XG4gIH1cbiAgZm9yIChuYW1lIGluIG9sZE9uKSB7XG4gICAgaWYgKGlzVW5kZWYob25bbmFtZV0pKSB7XG4gICAgICBldmVudCA9IG5vcm1hbGl6ZUV2ZW50KG5hbWUpO1xuICAgICAgcmVtb3ZlJCQxKGV2ZW50Lm5hbWUsIG9sZE9uW25hbWVdLCBldmVudC5jYXB0dXJlKTtcbiAgICB9XG4gIH1cbn1cblxuLyogICovXG5cbmZ1bmN0aW9uIG1lcmdlVk5vZGVIb29rIChkZWYsIGhvb2tLZXksIGhvb2spIHtcbiAgaWYgKGRlZiBpbnN0YW5jZW9mIFZOb2RlKSB7XG4gICAgZGVmID0gZGVmLmRhdGEuaG9vayB8fCAoZGVmLmRhdGEuaG9vayA9IHt9KTtcbiAgfVxuICB2YXIgaW52b2tlcjtcbiAgdmFyIG9sZEhvb2sgPSBkZWZbaG9va0tleV07XG5cbiAgZnVuY3Rpb24gd3JhcHBlZEhvb2sgKCkge1xuICAgIGhvb2suYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAvLyBpbXBvcnRhbnQ6IHJlbW92ZSBtZXJnZWQgaG9vayB0byBlbnN1cmUgaXQncyBjYWxsZWQgb25seSBvbmNlXG4gICAgLy8gYW5kIHByZXZlbnQgbWVtb3J5IGxlYWtcbiAgICByZW1vdmUoaW52b2tlci5mbnMsIHdyYXBwZWRIb29rKTtcbiAgfVxuXG4gIGlmIChpc1VuZGVmKG9sZEhvb2spKSB7XG4gICAgLy8gbm8gZXhpc3RpbmcgaG9va1xuICAgIGludm9rZXIgPSBjcmVhdGVGbkludm9rZXIoW3dyYXBwZWRIb29rXSk7XG4gIH0gZWxzZSB7XG4gICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgaWYgKGlzRGVmKG9sZEhvb2suZm5zKSAmJiBpc1RydWUob2xkSG9vay5tZXJnZWQpKSB7XG4gICAgICAvLyBhbHJlYWR5IGEgbWVyZ2VkIGludm9rZXJcbiAgICAgIGludm9rZXIgPSBvbGRIb29rO1xuICAgICAgaW52b2tlci5mbnMucHVzaCh3cmFwcGVkSG9vayk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIGV4aXN0aW5nIHBsYWluIGhvb2tcbiAgICAgIGludm9rZXIgPSBjcmVhdGVGbkludm9rZXIoW29sZEhvb2ssIHdyYXBwZWRIb29rXSk7XG4gICAgfVxuICB9XG5cbiAgaW52b2tlci5tZXJnZWQgPSB0cnVlO1xuICBkZWZbaG9va0tleV0gPSBpbnZva2VyO1xufVxuXG4vKiAgKi9cblxuZnVuY3Rpb24gZXh0cmFjdFByb3BzRnJvbVZOb2RlRGF0YSAoXG4gIGRhdGEsXG4gIEN0b3IsXG4gIHRhZ1xuKSB7XG4gIC8vIHdlIGFyZSBvbmx5IGV4dHJhY3RpbmcgcmF3IHZhbHVlcyBoZXJlLlxuICAvLyB2YWxpZGF0aW9uIGFuZCBkZWZhdWx0IHZhbHVlcyBhcmUgaGFuZGxlZCBpbiB0aGUgY2hpbGRcbiAgLy8gY29tcG9uZW50IGl0c2VsZi5cbiAgdmFyIHByb3BPcHRpb25zID0gQ3Rvci5vcHRpb25zLnByb3BzO1xuICBpZiAoaXNVbmRlZihwcm9wT3B0aW9ucykpIHtcbiAgICByZXR1cm5cbiAgfVxuICB2YXIgcmVzID0ge307XG4gIHZhciBhdHRycyA9IGRhdGEuYXR0cnM7XG4gIHZhciBwcm9wcyA9IGRhdGEucHJvcHM7XG4gIGlmIChpc0RlZihhdHRycykgfHwgaXNEZWYocHJvcHMpKSB7XG4gICAgZm9yICh2YXIga2V5IGluIHByb3BPcHRpb25zKSB7XG4gICAgICB2YXIgYWx0S2V5ID0gaHlwaGVuYXRlKGtleSk7XG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICB2YXIga2V5SW5Mb3dlckNhc2UgPSBrZXkudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgaWYgKFxuICAgICAgICAgIGtleSAhPT0ga2V5SW5Mb3dlckNhc2UgJiZcbiAgICAgICAgICBhdHRycyAmJiBoYXNPd24oYXR0cnMsIGtleUluTG93ZXJDYXNlKVxuICAgICAgICApIHtcbiAgICAgICAgICB0aXAoXG4gICAgICAgICAgICBcIlByb3AgXFxcIlwiICsga2V5SW5Mb3dlckNhc2UgKyBcIlxcXCIgaXMgcGFzc2VkIHRvIGNvbXBvbmVudCBcIiArXG4gICAgICAgICAgICAoZm9ybWF0Q29tcG9uZW50TmFtZSh0YWcgfHwgQ3RvcikpICsgXCIsIGJ1dCB0aGUgZGVjbGFyZWQgcHJvcCBuYW1lIGlzXCIgK1xuICAgICAgICAgICAgXCIgXFxcIlwiICsga2V5ICsgXCJcXFwiLiBcIiArXG4gICAgICAgICAgICBcIk5vdGUgdGhhdCBIVE1MIGF0dHJpYnV0ZXMgYXJlIGNhc2UtaW5zZW5zaXRpdmUgYW5kIGNhbWVsQ2FzZWQgXCIgK1xuICAgICAgICAgICAgXCJwcm9wcyBuZWVkIHRvIHVzZSB0aGVpciBrZWJhYi1jYXNlIGVxdWl2YWxlbnRzIHdoZW4gdXNpbmcgaW4tRE9NIFwiICtcbiAgICAgICAgICAgIFwidGVtcGxhdGVzLiBZb3Ugc2hvdWxkIHByb2JhYmx5IHVzZSBcXFwiXCIgKyBhbHRLZXkgKyBcIlxcXCIgaW5zdGVhZCBvZiBcXFwiXCIgKyBrZXkgKyBcIlxcXCIuXCJcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBjaGVja1Byb3AocmVzLCBwcm9wcywga2V5LCBhbHRLZXksIHRydWUpIHx8XG4gICAgICBjaGVja1Byb3AocmVzLCBhdHRycywga2V5LCBhbHRLZXksIGZhbHNlKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc1xufVxuXG5mdW5jdGlvbiBjaGVja1Byb3AgKFxuICByZXMsXG4gIGhhc2gsXG4gIGtleSxcbiAgYWx0S2V5LFxuICBwcmVzZXJ2ZVxuKSB7XG4gIGlmIChpc0RlZihoYXNoKSkge1xuICAgIGlmIChoYXNPd24oaGFzaCwga2V5KSkge1xuICAgICAgcmVzW2tleV0gPSBoYXNoW2tleV07XG4gICAgICBpZiAoIXByZXNlcnZlKSB7XG4gICAgICAgIGRlbGV0ZSBoYXNoW2tleV07XG4gICAgICB9XG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIH0gZWxzZSBpZiAoaGFzT3duKGhhc2gsIGFsdEtleSkpIHtcbiAgICAgIHJlc1trZXldID0gaGFzaFthbHRLZXldO1xuICAgICAgaWYgKCFwcmVzZXJ2ZSkge1xuICAgICAgICBkZWxldGUgaGFzaFthbHRLZXldO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRydWVcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGZhbHNlXG59XG5cbi8qICAqL1xuXG4vLyBUaGUgdGVtcGxhdGUgY29tcGlsZXIgYXR0ZW1wdHMgdG8gbWluaW1pemUgdGhlIG5lZWQgZm9yIG5vcm1hbGl6YXRpb24gYnlcbi8vIHN0YXRpY2FsbHkgYW5hbHl6aW5nIHRoZSB0ZW1wbGF0ZSBhdCBjb21waWxlIHRpbWUuXG4vL1xuLy8gRm9yIHBsYWluIEhUTUwgbWFya3VwLCBub3JtYWxpemF0aW9uIGNhbiBiZSBjb21wbGV0ZWx5IHNraXBwZWQgYmVjYXVzZSB0aGVcbi8vIGdlbmVyYXRlZCByZW5kZXIgZnVuY3Rpb24gaXMgZ3VhcmFudGVlZCB0byByZXR1cm4gQXJyYXk8Vk5vZGU+LiBUaGVyZSBhcmVcbi8vIHR3byBjYXNlcyB3aGVyZSBleHRyYSBub3JtYWxpemF0aW9uIGlzIG5lZWRlZDpcblxuLy8gMS4gV2hlbiB0aGUgY2hpbGRyZW4gY29udGFpbnMgY29tcG9uZW50cyAtIGJlY2F1c2UgYSBmdW5jdGlvbmFsIGNvbXBvbmVudFxuLy8gbWF5IHJldHVybiBhbiBBcnJheSBpbnN0ZWFkIG9mIGEgc2luZ2xlIHJvb3QuIEluIHRoaXMgY2FzZSwganVzdCBhIHNpbXBsZVxuLy8gbm9ybWFsaXphdGlvbiBpcyBuZWVkZWQgLSBpZiBhbnkgY2hpbGQgaXMgYW4gQXJyYXksIHdlIGZsYXR0ZW4gdGhlIHdob2xlXG4vLyB0aGluZyB3aXRoIEFycmF5LnByb3RvdHlwZS5jb25jYXQuIEl0IGlzIGd1YXJhbnRlZWQgdG8gYmUgb25seSAxLWxldmVsIGRlZXBcbi8vIGJlY2F1c2UgZnVuY3Rpb25hbCBjb21wb25lbnRzIGFscmVhZHkgbm9ybWFsaXplIHRoZWlyIG93biBjaGlsZHJlbi5cbmZ1bmN0aW9uIHNpbXBsZU5vcm1hbGl6ZUNoaWxkcmVuIChjaGlsZHJlbikge1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkoY2hpbGRyZW5baV0pKSB7XG4gICAgICByZXR1cm4gQXJyYXkucHJvdG90eXBlLmNvbmNhdC5hcHBseShbXSwgY2hpbGRyZW4pXG4gICAgfVxuICB9XG4gIHJldHVybiBjaGlsZHJlblxufVxuXG4vLyAyLiBXaGVuIHRoZSBjaGlsZHJlbiBjb250YWlucyBjb25zdHJ1Y3RzIHRoYXQgYWx3YXlzIGdlbmVyYXRlZCBuZXN0ZWQgQXJyYXlzLFxuLy8gZS5nLiA8dGVtcGxhdGU+LCA8c2xvdD4sIHYtZm9yLCBvciB3aGVuIHRoZSBjaGlsZHJlbiBpcyBwcm92aWRlZCBieSB1c2VyXG4vLyB3aXRoIGhhbmQtd3JpdHRlbiByZW5kZXIgZnVuY3Rpb25zIC8gSlNYLiBJbiBzdWNoIGNhc2VzIGEgZnVsbCBub3JtYWxpemF0aW9uXG4vLyBpcyBuZWVkZWQgdG8gY2F0ZXIgdG8gYWxsIHBvc3NpYmxlIHR5cGVzIG9mIGNoaWxkcmVuIHZhbHVlcy5cbmZ1bmN0aW9uIG5vcm1hbGl6ZUNoaWxkcmVuIChjaGlsZHJlbikge1xuICByZXR1cm4gaXNQcmltaXRpdmUoY2hpbGRyZW4pXG4gICAgPyBbY3JlYXRlVGV4dFZOb2RlKGNoaWxkcmVuKV1cbiAgICA6IEFycmF5LmlzQXJyYXkoY2hpbGRyZW4pXG4gICAgICA/IG5vcm1hbGl6ZUFycmF5Q2hpbGRyZW4oY2hpbGRyZW4pXG4gICAgICA6IHVuZGVmaW5lZFxufVxuXG5mdW5jdGlvbiBpc1RleHROb2RlIChub2RlKSB7XG4gIHJldHVybiBpc0RlZihub2RlKSAmJiBpc0RlZihub2RlLnRleHQpICYmIGlzRmFsc2Uobm9kZS5pc0NvbW1lbnQpXG59XG5cbmZ1bmN0aW9uIG5vcm1hbGl6ZUFycmF5Q2hpbGRyZW4gKGNoaWxkcmVuLCBuZXN0ZWRJbmRleCkge1xuICB2YXIgcmVzID0gW107XG4gIHZhciBpLCBjLCBsYXN0SW5kZXgsIGxhc3Q7XG4gIGZvciAoaSA9IDA7IGkgPCBjaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgIGMgPSBjaGlsZHJlbltpXTtcbiAgICBpZiAoaXNVbmRlZihjKSB8fCB0eXBlb2YgYyA9PT0gJ2Jvb2xlYW4nKSB7IGNvbnRpbnVlIH1cbiAgICBsYXN0SW5kZXggPSByZXMubGVuZ3RoIC0gMTtcbiAgICBsYXN0ID0gcmVzW2xhc3RJbmRleF07XG4gICAgLy8gIG5lc3RlZFxuICAgIGlmIChBcnJheS5pc0FycmF5KGMpKSB7XG4gICAgICBpZiAoYy5sZW5ndGggPiAwKSB7XG4gICAgICAgIGMgPSBub3JtYWxpemVBcnJheUNoaWxkcmVuKGMsICgobmVzdGVkSW5kZXggfHwgJycpICsgXCJfXCIgKyBpKSk7XG4gICAgICAgIC8vIG1lcmdlIGFkamFjZW50IHRleHQgbm9kZXNcbiAgICAgICAgaWYgKGlzVGV4dE5vZGUoY1swXSkgJiYgaXNUZXh0Tm9kZShsYXN0KSkge1xuICAgICAgICAgIHJlc1tsYXN0SW5kZXhdID0gY3JlYXRlVGV4dFZOb2RlKGxhc3QudGV4dCArIChjWzBdKS50ZXh0KTtcbiAgICAgICAgICBjLnNoaWZ0KCk7XG4gICAgICAgIH1cbiAgICAgICAgcmVzLnB1c2guYXBwbHkocmVzLCBjKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGlzUHJpbWl0aXZlKGMpKSB7XG4gICAgICBpZiAoaXNUZXh0Tm9kZShsYXN0KSkge1xuICAgICAgICAvLyBtZXJnZSBhZGphY2VudCB0ZXh0IG5vZGVzXG4gICAgICAgIC8vIHRoaXMgaXMgbmVjZXNzYXJ5IGZvciBTU1IgaHlkcmF0aW9uIGJlY2F1c2UgdGV4dCBub2RlcyBhcmVcbiAgICAgICAgLy8gZXNzZW50aWFsbHkgbWVyZ2VkIHdoZW4gcmVuZGVyZWQgdG8gSFRNTCBzdHJpbmdzXG4gICAgICAgIHJlc1tsYXN0SW5kZXhdID0gY3JlYXRlVGV4dFZOb2RlKGxhc3QudGV4dCArIGMpO1xuICAgICAgfSBlbHNlIGlmIChjICE9PSAnJykge1xuICAgICAgICAvLyBjb252ZXJ0IHByaW1pdGl2ZSB0byB2bm9kZVxuICAgICAgICByZXMucHVzaChjcmVhdGVUZXh0Vk5vZGUoYykpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoaXNUZXh0Tm9kZShjKSAmJiBpc1RleHROb2RlKGxhc3QpKSB7XG4gICAgICAgIC8vIG1lcmdlIGFkamFjZW50IHRleHQgbm9kZXNcbiAgICAgICAgcmVzW2xhc3RJbmRleF0gPSBjcmVhdGVUZXh0Vk5vZGUobGFzdC50ZXh0ICsgYy50ZXh0KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIGRlZmF1bHQga2V5IGZvciBuZXN0ZWQgYXJyYXkgY2hpbGRyZW4gKGxpa2VseSBnZW5lcmF0ZWQgYnkgdi1mb3IpXG4gICAgICAgIGlmIChpc1RydWUoY2hpbGRyZW4uX2lzVkxpc3QpICYmXG4gICAgICAgICAgaXNEZWYoYy50YWcpICYmXG4gICAgICAgICAgaXNVbmRlZihjLmtleSkgJiZcbiAgICAgICAgICBpc0RlZihuZXN0ZWRJbmRleCkpIHtcbiAgICAgICAgICBjLmtleSA9IFwiX192bGlzdFwiICsgbmVzdGVkSW5kZXggKyBcIl9cIiArIGkgKyBcIl9fXCI7XG4gICAgICAgIH1cbiAgICAgICAgcmVzLnB1c2goYyk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiByZXNcbn1cblxuLyogICovXG5cbmZ1bmN0aW9uIGluaXRQcm92aWRlICh2bSkge1xuICB2YXIgcHJvdmlkZSA9IHZtLiRvcHRpb25zLnByb3ZpZGU7XG4gIGlmIChwcm92aWRlKSB7XG4gICAgdm0uX3Byb3ZpZGVkID0gdHlwZW9mIHByb3ZpZGUgPT09ICdmdW5jdGlvbidcbiAgICAgID8gcHJvdmlkZS5jYWxsKHZtKVxuICAgICAgOiBwcm92aWRlO1xuICB9XG59XG5cbmZ1bmN0aW9uIGluaXRJbmplY3Rpb25zICh2bSkge1xuICB2YXIgcmVzdWx0ID0gcmVzb2x2ZUluamVjdCh2bS4kb3B0aW9ucy5pbmplY3QsIHZtKTtcbiAgaWYgKHJlc3VsdCkge1xuICAgIHRvZ2dsZU9ic2VydmluZyhmYWxzZSk7XG4gICAgT2JqZWN0LmtleXMocmVzdWx0KS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovXG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICBkZWZpbmVSZWFjdGl2ZSQkMSh2bSwga2V5LCByZXN1bHRba2V5XSwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHdhcm4oXG4gICAgICAgICAgICBcIkF2b2lkIG11dGF0aW5nIGFuIGluamVjdGVkIHZhbHVlIGRpcmVjdGx5IHNpbmNlIHRoZSBjaGFuZ2VzIHdpbGwgYmUgXCIgK1xuICAgICAgICAgICAgXCJvdmVyd3JpdHRlbiB3aGVuZXZlciB0aGUgcHJvdmlkZWQgY29tcG9uZW50IHJlLXJlbmRlcnMuIFwiICtcbiAgICAgICAgICAgIFwiaW5qZWN0aW9uIGJlaW5nIG11dGF0ZWQ6IFxcXCJcIiArIGtleSArIFwiXFxcIlwiLFxuICAgICAgICAgICAgdm1cbiAgICAgICAgICApO1xuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGRlZmluZVJlYWN0aXZlJCQxKHZtLCBrZXksIHJlc3VsdFtrZXldKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICB0b2dnbGVPYnNlcnZpbmcodHJ1ZSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gcmVzb2x2ZUluamVjdCAoaW5qZWN0LCB2bSkge1xuICBpZiAoaW5qZWN0KSB7XG4gICAgLy8gaW5qZWN0IGlzIDphbnkgYmVjYXVzZSBmbG93IGlzIG5vdCBzbWFydCBlbm91Z2ggdG8gZmlndXJlIG91dCBjYWNoZWRcbiAgICB2YXIgcmVzdWx0ID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICB2YXIga2V5cyA9IGhhc1N5bWJvbFxuICAgICAgPyBSZWZsZWN0Lm93bktleXMoaW5qZWN0KVxuICAgICAgOiBPYmplY3Qua2V5cyhpbmplY3QpO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIga2V5ID0ga2V5c1tpXTtcbiAgICAgIC8vICM2NTc0IGluIGNhc2UgdGhlIGluamVjdCBvYmplY3QgaXMgb2JzZXJ2ZWQuLi5cbiAgICAgIGlmIChrZXkgPT09ICdfX29iX18nKSB7IGNvbnRpbnVlIH1cbiAgICAgIHZhciBwcm92aWRlS2V5ID0gaW5qZWN0W2tleV0uZnJvbTtcbiAgICAgIHZhciBzb3VyY2UgPSB2bTtcbiAgICAgIHdoaWxlIChzb3VyY2UpIHtcbiAgICAgICAgaWYgKHNvdXJjZS5fcHJvdmlkZWQgJiYgaGFzT3duKHNvdXJjZS5fcHJvdmlkZWQsIHByb3ZpZGVLZXkpKSB7XG4gICAgICAgICAgcmVzdWx0W2tleV0gPSBzb3VyY2UuX3Byb3ZpZGVkW3Byb3ZpZGVLZXldO1xuICAgICAgICAgIGJyZWFrXG4gICAgICAgIH1cbiAgICAgICAgc291cmNlID0gc291cmNlLiRwYXJlbnQ7XG4gICAgICB9XG4gICAgICBpZiAoIXNvdXJjZSkge1xuICAgICAgICBpZiAoJ2RlZmF1bHQnIGluIGluamVjdFtrZXldKSB7XG4gICAgICAgICAgdmFyIHByb3ZpZGVEZWZhdWx0ID0gaW5qZWN0W2tleV0uZGVmYXVsdDtcbiAgICAgICAgICByZXN1bHRba2V5XSA9IHR5cGVvZiBwcm92aWRlRGVmYXVsdCA9PT0gJ2Z1bmN0aW9uJ1xuICAgICAgICAgICAgPyBwcm92aWRlRGVmYXVsdC5jYWxsKHZtKVxuICAgICAgICAgICAgOiBwcm92aWRlRGVmYXVsdDtcbiAgICAgICAgfSBlbHNlIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgICAgd2FybigoXCJJbmplY3Rpb24gXFxcIlwiICsga2V5ICsgXCJcXFwiIG5vdCBmb3VuZFwiKSwgdm0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXN1bHRcbiAgfVxufVxuXG4vKiAgKi9cblxuXG5cbi8qKlxuICogUnVudGltZSBoZWxwZXIgZm9yIHJlc29sdmluZyByYXcgY2hpbGRyZW4gVk5vZGVzIGludG8gYSBzbG90IG9iamVjdC5cbiAqL1xuZnVuY3Rpb24gcmVzb2x2ZVNsb3RzIChcbiAgY2hpbGRyZW4sXG4gIGNvbnRleHRcbikge1xuICBpZiAoIWNoaWxkcmVuIHx8ICFjaGlsZHJlbi5sZW5ndGgpIHtcbiAgICByZXR1cm4ge31cbiAgfVxuICB2YXIgc2xvdHMgPSB7fTtcbiAgZm9yICh2YXIgaSA9IDAsIGwgPSBjaGlsZHJlbi5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICB2YXIgY2hpbGQgPSBjaGlsZHJlbltpXTtcbiAgICB2YXIgZGF0YSA9IGNoaWxkLmRhdGE7XG4gICAgLy8gcmVtb3ZlIHNsb3QgYXR0cmlidXRlIGlmIHRoZSBub2RlIGlzIHJlc29sdmVkIGFzIGEgVnVlIHNsb3Qgbm9kZVxuICAgIGlmIChkYXRhICYmIGRhdGEuYXR0cnMgJiYgZGF0YS5hdHRycy5zbG90KSB7XG4gICAgICBkZWxldGUgZGF0YS5hdHRycy5zbG90O1xuICAgIH1cbiAgICAvLyBuYW1lZCBzbG90cyBzaG91bGQgb25seSBiZSByZXNwZWN0ZWQgaWYgdGhlIHZub2RlIHdhcyByZW5kZXJlZCBpbiB0aGVcbiAgICAvLyBzYW1lIGNvbnRleHQuXG4gICAgaWYgKChjaGlsZC5jb250ZXh0ID09PSBjb250ZXh0IHx8IGNoaWxkLmZuQ29udGV4dCA9PT0gY29udGV4dCkgJiZcbiAgICAgIGRhdGEgJiYgZGF0YS5zbG90ICE9IG51bGxcbiAgICApIHtcbiAgICAgIHZhciBuYW1lID0gZGF0YS5zbG90O1xuICAgICAgdmFyIHNsb3QgPSAoc2xvdHNbbmFtZV0gfHwgKHNsb3RzW25hbWVdID0gW10pKTtcbiAgICAgIGlmIChjaGlsZC50YWcgPT09ICd0ZW1wbGF0ZScpIHtcbiAgICAgICAgc2xvdC5wdXNoLmFwcGx5KHNsb3QsIGNoaWxkLmNoaWxkcmVuIHx8IFtdKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHNsb3QucHVzaChjaGlsZCk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIChzbG90cy5kZWZhdWx0IHx8IChzbG90cy5kZWZhdWx0ID0gW10pKS5wdXNoKGNoaWxkKTtcbiAgICB9XG4gIH1cbiAgLy8gaWdub3JlIHNsb3RzIHRoYXQgY29udGFpbnMgb25seSB3aGl0ZXNwYWNlXG4gIGZvciAodmFyIG5hbWUkMSBpbiBzbG90cykge1xuICAgIGlmIChzbG90c1tuYW1lJDFdLmV2ZXJ5KGlzV2hpdGVzcGFjZSkpIHtcbiAgICAgIGRlbGV0ZSBzbG90c1tuYW1lJDFdO1xuICAgIH1cbiAgfVxuICByZXR1cm4gc2xvdHNcbn1cblxuZnVuY3Rpb24gaXNXaGl0ZXNwYWNlIChub2RlKSB7XG4gIHJldHVybiAobm9kZS5pc0NvbW1lbnQgJiYgIW5vZGUuYXN5bmNGYWN0b3J5KSB8fCBub2RlLnRleHQgPT09ICcgJ1xufVxuXG4vKiAgKi9cblxuZnVuY3Rpb24gbm9ybWFsaXplU2NvcGVkU2xvdHMgKFxuICBzbG90cyxcbiAgbm9ybWFsU2xvdHMsXG4gIHByZXZTbG90c1xuKSB7XG4gIHZhciByZXM7XG4gIHZhciBoYXNOb3JtYWxTbG90cyA9IE9iamVjdC5rZXlzKG5vcm1hbFNsb3RzKS5sZW5ndGggPiAwO1xuICB2YXIgaXNTdGFibGUgPSBzbG90cyA/ICEhc2xvdHMuJHN0YWJsZSA6ICFoYXNOb3JtYWxTbG90cztcbiAgdmFyIGtleSA9IHNsb3RzICYmIHNsb3RzLiRrZXk7XG4gIGlmICghc2xvdHMpIHtcbiAgICByZXMgPSB7fTtcbiAgfSBlbHNlIGlmIChzbG90cy5fbm9ybWFsaXplZCkge1xuICAgIC8vIGZhc3QgcGF0aCAxOiBjaGlsZCBjb21wb25lbnQgcmUtcmVuZGVyIG9ubHksIHBhcmVudCBkaWQgbm90IGNoYW5nZVxuICAgIHJldHVybiBzbG90cy5fbm9ybWFsaXplZFxuICB9IGVsc2UgaWYgKFxuICAgIGlzU3RhYmxlICYmXG4gICAgcHJldlNsb3RzICYmXG4gICAgcHJldlNsb3RzICE9PSBlbXB0eU9iamVjdCAmJlxuICAgIGtleSA9PT0gcHJldlNsb3RzLiRrZXkgJiZcbiAgICAhaGFzTm9ybWFsU2xvdHMgJiZcbiAgICAhcHJldlNsb3RzLiRoYXNOb3JtYWxcbiAgKSB7XG4gICAgLy8gZmFzdCBwYXRoIDI6IHN0YWJsZSBzY29wZWQgc2xvdHMgdy8gbm8gbm9ybWFsIHNsb3RzIHRvIHByb3h5LFxuICAgIC8vIG9ubHkgbmVlZCB0byBub3JtYWxpemUgb25jZVxuICAgIHJldHVybiBwcmV2U2xvdHNcbiAgfSBlbHNlIHtcbiAgICByZXMgPSB7fTtcbiAgICBmb3IgKHZhciBrZXkkMSBpbiBzbG90cykge1xuICAgICAgaWYgKHNsb3RzW2tleSQxXSAmJiBrZXkkMVswXSAhPT0gJyQnKSB7XG4gICAgICAgIHJlc1trZXkkMV0gPSBub3JtYWxpemVTY29wZWRTbG90KG5vcm1hbFNsb3RzLCBrZXkkMSwgc2xvdHNba2V5JDFdKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgLy8gZXhwb3NlIG5vcm1hbCBzbG90cyBvbiBzY29wZWRTbG90c1xuICBmb3IgKHZhciBrZXkkMiBpbiBub3JtYWxTbG90cykge1xuICAgIGlmICghKGtleSQyIGluIHJlcykpIHtcbiAgICAgIHJlc1trZXkkMl0gPSBwcm94eU5vcm1hbFNsb3Qobm9ybWFsU2xvdHMsIGtleSQyKTtcbiAgICB9XG4gIH1cbiAgLy8gYXZvcmlheiBzZWVtcyB0byBtb2NrIGEgbm9uLWV4dGVuc2libGUgJHNjb3BlZFNsb3RzIG9iamVjdFxuICAvLyBhbmQgd2hlbiB0aGF0IGlzIHBhc3NlZCBkb3duIHRoaXMgd291bGQgY2F1c2UgYW4gZXJyb3JcbiAgaWYgKHNsb3RzICYmIE9iamVjdC5pc0V4dGVuc2libGUoc2xvdHMpKSB7XG4gICAgKHNsb3RzKS5fbm9ybWFsaXplZCA9IHJlcztcbiAgfVxuICBkZWYocmVzLCAnJHN0YWJsZScsIGlzU3RhYmxlKTtcbiAgZGVmKHJlcywgJyRrZXknLCBrZXkpO1xuICBkZWYocmVzLCAnJGhhc05vcm1hbCcsIGhhc05vcm1hbFNsb3RzKTtcbiAgcmV0dXJuIHJlc1xufVxuXG5mdW5jdGlvbiBub3JtYWxpemVTY29wZWRTbG90KG5vcm1hbFNsb3RzLCBrZXksIGZuKSB7XG4gIHZhciBub3JtYWxpemVkID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciByZXMgPSBhcmd1bWVudHMubGVuZ3RoID8gZm4uYXBwbHkobnVsbCwgYXJndW1lbnRzKSA6IGZuKHt9KTtcbiAgICByZXMgPSByZXMgJiYgdHlwZW9mIHJlcyA9PT0gJ29iamVjdCcgJiYgIUFycmF5LmlzQXJyYXkocmVzKVxuICAgICAgPyBbcmVzXSAvLyBzaW5nbGUgdm5vZGVcbiAgICAgIDogbm9ybWFsaXplQ2hpbGRyZW4ocmVzKTtcbiAgICByZXR1cm4gcmVzICYmIChcbiAgICAgIHJlcy5sZW5ndGggPT09IDAgfHxcbiAgICAgIChyZXMubGVuZ3RoID09PSAxICYmIHJlc1swXS5pc0NvbW1lbnQpIC8vICM5NjU4XG4gICAgKSA/IHVuZGVmaW5lZFxuICAgICAgOiByZXNcbiAgfTtcbiAgLy8gdGhpcyBpcyBhIHNsb3QgdXNpbmcgdGhlIG5ldyB2LXNsb3Qgc3ludGF4IHdpdGhvdXQgc2NvcGUuIGFsdGhvdWdoIGl0IGlzXG4gIC8vIGNvbXBpbGVkIGFzIGEgc2NvcGVkIHNsb3QsIHJlbmRlciBmbiB1c2VycyB3b3VsZCBleHBlY3QgaXQgdG8gYmUgcHJlc2VudFxuICAvLyBvbiB0aGlzLiRzbG90cyBiZWNhdXNlIHRoZSB1c2FnZSBpcyBzZW1hbnRpY2FsbHkgYSBub3JtYWwgc2xvdC5cbiAgaWYgKGZuLnByb3h5KSB7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG5vcm1hbFNsb3RzLCBrZXksIHtcbiAgICAgIGdldDogbm9ybWFsaXplZCxcbiAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgfVxuICByZXR1cm4gbm9ybWFsaXplZFxufVxuXG5mdW5jdGlvbiBwcm94eU5vcm1hbFNsb3Qoc2xvdHMsIGtleSkge1xuICByZXR1cm4gZnVuY3Rpb24gKCkgeyByZXR1cm4gc2xvdHNba2V5XTsgfVxufVxuXG4vKiAgKi9cblxuLyoqXG4gKiBSdW50aW1lIGhlbHBlciBmb3IgcmVuZGVyaW5nIHYtZm9yIGxpc3RzLlxuICovXG5mdW5jdGlvbiByZW5kZXJMaXN0IChcbiAgdmFsLFxuICByZW5kZXJcbikge1xuICB2YXIgcmV0LCBpLCBsLCBrZXlzLCBrZXk7XG4gIGlmIChBcnJheS5pc0FycmF5KHZhbCkgfHwgdHlwZW9mIHZhbCA9PT0gJ3N0cmluZycpIHtcbiAgICByZXQgPSBuZXcgQXJyYXkodmFsLmxlbmd0aCk7XG4gICAgZm9yIChpID0gMCwgbCA9IHZhbC5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgIHJldFtpXSA9IHJlbmRlcih2YWxbaV0sIGkpO1xuICAgIH1cbiAgfSBlbHNlIGlmICh0eXBlb2YgdmFsID09PSAnbnVtYmVyJykge1xuICAgIHJldCA9IG5ldyBBcnJheSh2YWwpO1xuICAgIGZvciAoaSA9IDA7IGkgPCB2YWw7IGkrKykge1xuICAgICAgcmV0W2ldID0gcmVuZGVyKGkgKyAxLCBpKTtcbiAgICB9XG4gIH0gZWxzZSBpZiAoaXNPYmplY3QodmFsKSkge1xuICAgIGlmIChoYXNTeW1ib2wgJiYgdmFsW1N5bWJvbC5pdGVyYXRvcl0pIHtcbiAgICAgIHJldCA9IFtdO1xuICAgICAgdmFyIGl0ZXJhdG9yID0gdmFsW1N5bWJvbC5pdGVyYXRvcl0oKTtcbiAgICAgIHZhciByZXN1bHQgPSBpdGVyYXRvci5uZXh0KCk7XG4gICAgICB3aGlsZSAoIXJlc3VsdC5kb25lKSB7XG4gICAgICAgIHJldC5wdXNoKHJlbmRlcihyZXN1bHQudmFsdWUsIHJldC5sZW5ndGgpKTtcbiAgICAgICAgcmVzdWx0ID0gaXRlcmF0b3IubmV4dCgpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBrZXlzID0gT2JqZWN0LmtleXModmFsKTtcbiAgICAgIHJldCA9IG5ldyBBcnJheShrZXlzLmxlbmd0aCk7XG4gICAgICBmb3IgKGkgPSAwLCBsID0ga2V5cy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAga2V5ID0ga2V5c1tpXTtcbiAgICAgICAgcmV0W2ldID0gcmVuZGVyKHZhbFtrZXldLCBrZXksIGkpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBpZiAoIWlzRGVmKHJldCkpIHtcbiAgICByZXQgPSBbXTtcbiAgfVxuICAocmV0KS5faXNWTGlzdCA9IHRydWU7XG4gIHJldHVybiByZXRcbn1cblxuLyogICovXG5cbi8qKlxuICogUnVudGltZSBoZWxwZXIgZm9yIHJlbmRlcmluZyA8c2xvdD5cbiAqL1xuZnVuY3Rpb24gcmVuZGVyU2xvdCAoXG4gIG5hbWUsXG4gIGZhbGxiYWNrLFxuICBwcm9wcyxcbiAgYmluZE9iamVjdFxuKSB7XG4gIHZhciBzY29wZWRTbG90Rm4gPSB0aGlzLiRzY29wZWRTbG90c1tuYW1lXTtcbiAgdmFyIG5vZGVzO1xuICBpZiAoc2NvcGVkU2xvdEZuKSB7IC8vIHNjb3BlZCBzbG90XG4gICAgcHJvcHMgPSBwcm9wcyB8fCB7fTtcbiAgICBpZiAoYmluZE9iamVjdCkge1xuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgIWlzT2JqZWN0KGJpbmRPYmplY3QpKSB7XG4gICAgICAgIHdhcm4oXG4gICAgICAgICAgJ3Nsb3Qgdi1iaW5kIHdpdGhvdXQgYXJndW1lbnQgZXhwZWN0cyBhbiBPYmplY3QnLFxuICAgICAgICAgIHRoaXNcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIHByb3BzID0gZXh0ZW5kKGV4dGVuZCh7fSwgYmluZE9iamVjdCksIHByb3BzKTtcbiAgICB9XG4gICAgbm9kZXMgPSBzY29wZWRTbG90Rm4ocHJvcHMpIHx8IGZhbGxiYWNrO1xuICB9IGVsc2Uge1xuICAgIG5vZGVzID0gdGhpcy4kc2xvdHNbbmFtZV0gfHwgZmFsbGJhY2s7XG4gIH1cblxuICB2YXIgdGFyZ2V0ID0gcHJvcHMgJiYgcHJvcHMuc2xvdDtcbiAgaWYgKHRhcmdldCkge1xuICAgIHJldHVybiB0aGlzLiRjcmVhdGVFbGVtZW50KCd0ZW1wbGF0ZScsIHsgc2xvdDogdGFyZ2V0IH0sIG5vZGVzKVxuICB9IGVsc2Uge1xuICAgIHJldHVybiBub2Rlc1xuICB9XG59XG5cbi8qICAqL1xuXG4vKipcbiAqIFJ1bnRpbWUgaGVscGVyIGZvciByZXNvbHZpbmcgZmlsdGVyc1xuICovXG5mdW5jdGlvbiByZXNvbHZlRmlsdGVyIChpZCkge1xuICByZXR1cm4gcmVzb2x2ZUFzc2V0KHRoaXMuJG9wdGlvbnMsICdmaWx0ZXJzJywgaWQsIHRydWUpIHx8IGlkZW50aXR5XG59XG5cbi8qICAqL1xuXG5mdW5jdGlvbiBpc0tleU5vdE1hdGNoIChleHBlY3QsIGFjdHVhbCkge1xuICBpZiAoQXJyYXkuaXNBcnJheShleHBlY3QpKSB7XG4gICAgcmV0dXJuIGV4cGVjdC5pbmRleE9mKGFjdHVhbCkgPT09IC0xXG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGV4cGVjdCAhPT0gYWN0dWFsXG4gIH1cbn1cblxuLyoqXG4gKiBSdW50aW1lIGhlbHBlciBmb3IgY2hlY2tpbmcga2V5Q29kZXMgZnJvbSBjb25maWcuXG4gKiBleHBvc2VkIGFzIFZ1ZS5wcm90b3R5cGUuX2tcbiAqIHBhc3NpbmcgaW4gZXZlbnRLZXlOYW1lIGFzIGxhc3QgYXJndW1lbnQgc2VwYXJhdGVseSBmb3IgYmFja3dhcmRzIGNvbXBhdFxuICovXG5mdW5jdGlvbiBjaGVja0tleUNvZGVzIChcbiAgZXZlbnRLZXlDb2RlLFxuICBrZXksXG4gIGJ1aWx0SW5LZXlDb2RlLFxuICBldmVudEtleU5hbWUsXG4gIGJ1aWx0SW5LZXlOYW1lXG4pIHtcbiAgdmFyIG1hcHBlZEtleUNvZGUgPSBjb25maWcua2V5Q29kZXNba2V5XSB8fCBidWlsdEluS2V5Q29kZTtcbiAgaWYgKGJ1aWx0SW5LZXlOYW1lICYmIGV2ZW50S2V5TmFtZSAmJiAhY29uZmlnLmtleUNvZGVzW2tleV0pIHtcbiAgICByZXR1cm4gaXNLZXlOb3RNYXRjaChidWlsdEluS2V5TmFtZSwgZXZlbnRLZXlOYW1lKVxuICB9IGVsc2UgaWYgKG1hcHBlZEtleUNvZGUpIHtcbiAgICByZXR1cm4gaXNLZXlOb3RNYXRjaChtYXBwZWRLZXlDb2RlLCBldmVudEtleUNvZGUpXG4gIH0gZWxzZSBpZiAoZXZlbnRLZXlOYW1lKSB7XG4gICAgcmV0dXJuIGh5cGhlbmF0ZShldmVudEtleU5hbWUpICE9PSBrZXlcbiAgfVxufVxuXG4vKiAgKi9cblxuLyoqXG4gKiBSdW50aW1lIGhlbHBlciBmb3IgbWVyZ2luZyB2LWJpbmQ9XCJvYmplY3RcIiBpbnRvIGEgVk5vZGUncyBkYXRhLlxuICovXG5mdW5jdGlvbiBiaW5kT2JqZWN0UHJvcHMgKFxuICBkYXRhLFxuICB0YWcsXG4gIHZhbHVlLFxuICBhc1Byb3AsXG4gIGlzU3luY1xuKSB7XG4gIGlmICh2YWx1ZSkge1xuICAgIGlmICghaXNPYmplY3QodmFsdWUpKSB7XG4gICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIHdhcm4oXG4gICAgICAgICd2LWJpbmQgd2l0aG91dCBhcmd1bWVudCBleHBlY3RzIGFuIE9iamVjdCBvciBBcnJheSB2YWx1ZScsXG4gICAgICAgIHRoaXNcbiAgICAgICk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgICAgICB2YWx1ZSA9IHRvT2JqZWN0KHZhbHVlKTtcbiAgICAgIH1cbiAgICAgIHZhciBoYXNoO1xuICAgICAgdmFyIGxvb3AgPSBmdW5jdGlvbiAoIGtleSApIHtcbiAgICAgICAgaWYgKFxuICAgICAgICAgIGtleSA9PT0gJ2NsYXNzJyB8fFxuICAgICAgICAgIGtleSA9PT0gJ3N0eWxlJyB8fFxuICAgICAgICAgIGlzUmVzZXJ2ZWRBdHRyaWJ1dGUoa2V5KVxuICAgICAgICApIHtcbiAgICAgICAgICBoYXNoID0gZGF0YTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YXIgdHlwZSA9IGRhdGEuYXR0cnMgJiYgZGF0YS5hdHRycy50eXBlO1xuICAgICAgICAgIGhhc2ggPSBhc1Byb3AgfHwgY29uZmlnLm11c3RVc2VQcm9wKHRhZywgdHlwZSwga2V5KVxuICAgICAgICAgICAgPyBkYXRhLmRvbVByb3BzIHx8IChkYXRhLmRvbVByb3BzID0ge30pXG4gICAgICAgICAgICA6IGRhdGEuYXR0cnMgfHwgKGRhdGEuYXR0cnMgPSB7fSk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGNhbWVsaXplZEtleSA9IGNhbWVsaXplKGtleSk7XG4gICAgICAgIHZhciBoeXBoZW5hdGVkS2V5ID0gaHlwaGVuYXRlKGtleSk7XG4gICAgICAgIGlmICghKGNhbWVsaXplZEtleSBpbiBoYXNoKSAmJiAhKGh5cGhlbmF0ZWRLZXkgaW4gaGFzaCkpIHtcbiAgICAgICAgICBoYXNoW2tleV0gPSB2YWx1ZVtrZXldO1xuXG4gICAgICAgICAgaWYgKGlzU3luYykge1xuICAgICAgICAgICAgdmFyIG9uID0gZGF0YS5vbiB8fCAoZGF0YS5vbiA9IHt9KTtcbiAgICAgICAgICAgIG9uWyhcInVwZGF0ZTpcIiArIGtleSldID0gZnVuY3Rpb24gKCRldmVudCkge1xuICAgICAgICAgICAgICB2YWx1ZVtrZXldID0gJGV2ZW50O1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH07XG5cbiAgICAgIGZvciAodmFyIGtleSBpbiB2YWx1ZSkgbG9vcCgga2V5ICk7XG4gICAgfVxuICB9XG4gIHJldHVybiBkYXRhXG59XG5cbi8qICAqL1xuXG4vKipcbiAqIFJ1bnRpbWUgaGVscGVyIGZvciByZW5kZXJpbmcgc3RhdGljIHRyZWVzLlxuICovXG5mdW5jdGlvbiByZW5kZXJTdGF0aWMgKFxuICBpbmRleCxcbiAgaXNJbkZvclxuKSB7XG4gIHZhciBjYWNoZWQgPSB0aGlzLl9zdGF0aWNUcmVlcyB8fCAodGhpcy5fc3RhdGljVHJlZXMgPSBbXSk7XG4gIHZhciB0cmVlID0gY2FjaGVkW2luZGV4XTtcbiAgLy8gaWYgaGFzIGFscmVhZHktcmVuZGVyZWQgc3RhdGljIHRyZWUgYW5kIG5vdCBpbnNpZGUgdi1mb3IsXG4gIC8vIHdlIGNhbiByZXVzZSB0aGUgc2FtZSB0cmVlLlxuICBpZiAodHJlZSAmJiAhaXNJbkZvcikge1xuICAgIHJldHVybiB0cmVlXG4gIH1cbiAgLy8gb3RoZXJ3aXNlLCByZW5kZXIgYSBmcmVzaCB0cmVlLlxuICB0cmVlID0gY2FjaGVkW2luZGV4XSA9IHRoaXMuJG9wdGlvbnMuc3RhdGljUmVuZGVyRm5zW2luZGV4XS5jYWxsKFxuICAgIHRoaXMuX3JlbmRlclByb3h5LFxuICAgIG51bGwsXG4gICAgdGhpcyAvLyBmb3IgcmVuZGVyIGZucyBnZW5lcmF0ZWQgZm9yIGZ1bmN0aW9uYWwgY29tcG9uZW50IHRlbXBsYXRlc1xuICApO1xuICBtYXJrU3RhdGljKHRyZWUsIChcIl9fc3RhdGljX19cIiArIGluZGV4KSwgZmFsc2UpO1xuICByZXR1cm4gdHJlZVxufVxuXG4vKipcbiAqIFJ1bnRpbWUgaGVscGVyIGZvciB2LW9uY2UuXG4gKiBFZmZlY3RpdmVseSBpdCBtZWFucyBtYXJraW5nIHRoZSBub2RlIGFzIHN0YXRpYyB3aXRoIGEgdW5pcXVlIGtleS5cbiAqL1xuZnVuY3Rpb24gbWFya09uY2UgKFxuICB0cmVlLFxuICBpbmRleCxcbiAga2V5XG4pIHtcbiAgbWFya1N0YXRpYyh0cmVlLCAoXCJfX29uY2VfX1wiICsgaW5kZXggKyAoa2V5ID8gKFwiX1wiICsga2V5KSA6IFwiXCIpKSwgdHJ1ZSk7XG4gIHJldHVybiB0cmVlXG59XG5cbmZ1bmN0aW9uIG1hcmtTdGF0aWMgKFxuICB0cmVlLFxuICBrZXksXG4gIGlzT25jZVxuKSB7XG4gIGlmIChBcnJheS5pc0FycmF5KHRyZWUpKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0cmVlLmxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAodHJlZVtpXSAmJiB0eXBlb2YgdHJlZVtpXSAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgbWFya1N0YXRpY05vZGUodHJlZVtpXSwgKGtleSArIFwiX1wiICsgaSksIGlzT25jZSk7XG4gICAgICB9XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIG1hcmtTdGF0aWNOb2RlKHRyZWUsIGtleSwgaXNPbmNlKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBtYXJrU3RhdGljTm9kZSAobm9kZSwga2V5LCBpc09uY2UpIHtcbiAgbm9kZS5pc1N0YXRpYyA9IHRydWU7XG4gIG5vZGUua2V5ID0ga2V5O1xuICBub2RlLmlzT25jZSA9IGlzT25jZTtcbn1cblxuLyogICovXG5cbmZ1bmN0aW9uIGJpbmRPYmplY3RMaXN0ZW5lcnMgKGRhdGEsIHZhbHVlKSB7XG4gIGlmICh2YWx1ZSkge1xuICAgIGlmICghaXNQbGFpbk9iamVjdCh2YWx1ZSkpIHtcbiAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgd2FybihcbiAgICAgICAgJ3Ytb24gd2l0aG91dCBhcmd1bWVudCBleHBlY3RzIGFuIE9iamVjdCB2YWx1ZScsXG4gICAgICAgIHRoaXNcbiAgICAgICk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBvbiA9IGRhdGEub24gPSBkYXRhLm9uID8gZXh0ZW5kKHt9LCBkYXRhLm9uKSA6IHt9O1xuICAgICAgZm9yICh2YXIga2V5IGluIHZhbHVlKSB7XG4gICAgICAgIHZhciBleGlzdGluZyA9IG9uW2tleV07XG4gICAgICAgIHZhciBvdXJzID0gdmFsdWVba2V5XTtcbiAgICAgICAgb25ba2V5XSA9IGV4aXN0aW5nID8gW10uY29uY2F0KGV4aXN0aW5nLCBvdXJzKSA6IG91cnM7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiBkYXRhXG59XG5cbi8qICAqL1xuXG5mdW5jdGlvbiByZXNvbHZlU2NvcGVkU2xvdHMgKFxuICBmbnMsIC8vIHNlZSBmbG93L3Zub2RlXG4gIHJlcyxcbiAgLy8gdGhlIGZvbGxvd2luZyBhcmUgYWRkZWQgaW4gMi42XG4gIGhhc0R5bmFtaWNLZXlzLFxuICBjb250ZW50SGFzaEtleVxuKSB7XG4gIHJlcyA9IHJlcyB8fCB7ICRzdGFibGU6ICFoYXNEeW5hbWljS2V5cyB9O1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGZucy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBzbG90ID0gZm5zW2ldO1xuICAgIGlmIChBcnJheS5pc0FycmF5KHNsb3QpKSB7XG4gICAgICByZXNvbHZlU2NvcGVkU2xvdHMoc2xvdCwgcmVzLCBoYXNEeW5hbWljS2V5cyk7XG4gICAgfSBlbHNlIGlmIChzbG90KSB7XG4gICAgICAvLyBtYXJrZXIgZm9yIHJldmVyc2UgcHJveHlpbmcgdi1zbG90IHdpdGhvdXQgc2NvcGUgb24gdGhpcy4kc2xvdHNcbiAgICAgIGlmIChzbG90LnByb3h5KSB7XG4gICAgICAgIHNsb3QuZm4ucHJveHkgPSB0cnVlO1xuICAgICAgfVxuICAgICAgcmVzW3Nsb3Qua2V5XSA9IHNsb3QuZm47XG4gICAgfVxuICB9XG4gIGlmIChjb250ZW50SGFzaEtleSkge1xuICAgIChyZXMpLiRrZXkgPSBjb250ZW50SGFzaEtleTtcbiAgfVxuICByZXR1cm4gcmVzXG59XG5cbi8qICAqL1xuXG5mdW5jdGlvbiBiaW5kRHluYW1pY0tleXMgKGJhc2VPYmosIHZhbHVlcykge1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHZhbHVlcy5sZW5ndGg7IGkgKz0gMikge1xuICAgIHZhciBrZXkgPSB2YWx1ZXNbaV07XG4gICAgaWYgKHR5cGVvZiBrZXkgPT09ICdzdHJpbmcnICYmIGtleSkge1xuICAgICAgYmFzZU9ialt2YWx1ZXNbaV1dID0gdmFsdWVzW2kgKyAxXTtcbiAgICB9IGVsc2UgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYga2V5ICE9PSAnJyAmJiBrZXkgIT09IG51bGwpIHtcbiAgICAgIC8vIG51bGwgaXMgYSBzcGVpY2FsIHZhbHVlIGZvciBleHBsaWNpdGx5IHJlbW92aW5nIGEgYmluZGluZ1xuICAgICAgd2FybihcbiAgICAgICAgKFwiSW52YWxpZCB2YWx1ZSBmb3IgZHluYW1pYyBkaXJlY3RpdmUgYXJndW1lbnQgKGV4cGVjdGVkIHN0cmluZyBvciBudWxsKTogXCIgKyBrZXkpLFxuICAgICAgICB0aGlzXG4gICAgICApO1xuICAgIH1cbiAgfVxuICByZXR1cm4gYmFzZU9ialxufVxuXG4vLyBoZWxwZXIgdG8gZHluYW1pY2FsbHkgYXBwZW5kIG1vZGlmaWVyIHJ1bnRpbWUgbWFya2VycyB0byBldmVudCBuYW1lcy5cbi8vIGVuc3VyZSBvbmx5IGFwcGVuZCB3aGVuIHZhbHVlIGlzIGFscmVhZHkgc3RyaW5nLCBvdGhlcndpc2UgaXQgd2lsbCBiZSBjYXN0XG4vLyB0byBzdHJpbmcgYW5kIGNhdXNlIHRoZSB0eXBlIGNoZWNrIHRvIG1pc3MuXG5mdW5jdGlvbiBwcmVwZW5kTW9kaWZpZXIgKHZhbHVlLCBzeW1ib2wpIHtcbiAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycgPyBzeW1ib2wgKyB2YWx1ZSA6IHZhbHVlXG59XG5cbi8qICAqL1xuXG5mdW5jdGlvbiBpbnN0YWxsUmVuZGVySGVscGVycyAodGFyZ2V0KSB7XG4gIHRhcmdldC5fbyA9IG1hcmtPbmNlO1xuICB0YXJnZXQuX24gPSB0b051bWJlcjtcbiAgdGFyZ2V0Ll9zID0gdG9TdHJpbmc7XG4gIHRhcmdldC5fbCA9IHJlbmRlckxpc3Q7XG4gIHRhcmdldC5fdCA9IHJlbmRlclNsb3Q7XG4gIHRhcmdldC5fcSA9IGxvb3NlRXF1YWw7XG4gIHRhcmdldC5faSA9IGxvb3NlSW5kZXhPZjtcbiAgdGFyZ2V0Ll9tID0gcmVuZGVyU3RhdGljO1xuICB0YXJnZXQuX2YgPSByZXNvbHZlRmlsdGVyO1xuICB0YXJnZXQuX2sgPSBjaGVja0tleUNvZGVzO1xuICB0YXJnZXQuX2IgPSBiaW5kT2JqZWN0UHJvcHM7XG4gIHRhcmdldC5fdiA9IGNyZWF0ZVRleHRWTm9kZTtcbiAgdGFyZ2V0Ll9lID0gY3JlYXRlRW1wdHlWTm9kZTtcbiAgdGFyZ2V0Ll91ID0gcmVzb2x2ZVNjb3BlZFNsb3RzO1xuICB0YXJnZXQuX2cgPSBiaW5kT2JqZWN0TGlzdGVuZXJzO1xuICB0YXJnZXQuX2QgPSBiaW5kRHluYW1pY0tleXM7XG4gIHRhcmdldC5fcCA9IHByZXBlbmRNb2RpZmllcjtcbn1cblxuLyogICovXG5cbmZ1bmN0aW9uIEZ1bmN0aW9uYWxSZW5kZXJDb250ZXh0IChcbiAgZGF0YSxcbiAgcHJvcHMsXG4gIGNoaWxkcmVuLFxuICBwYXJlbnQsXG4gIEN0b3Jcbikge1xuICB2YXIgdGhpcyQxID0gdGhpcztcblxuICB2YXIgb3B0aW9ucyA9IEN0b3Iub3B0aW9ucztcbiAgLy8gZW5zdXJlIHRoZSBjcmVhdGVFbGVtZW50IGZ1bmN0aW9uIGluIGZ1bmN0aW9uYWwgY29tcG9uZW50c1xuICAvLyBnZXRzIGEgdW5pcXVlIGNvbnRleHQgLSB0aGlzIGlzIG5lY2Vzc2FyeSBmb3IgY29ycmVjdCBuYW1lZCBzbG90IGNoZWNrXG4gIHZhciBjb250ZXh0Vm07XG4gIGlmIChoYXNPd24ocGFyZW50LCAnX3VpZCcpKSB7XG4gICAgY29udGV4dFZtID0gT2JqZWN0LmNyZWF0ZShwYXJlbnQpO1xuICAgIC8vICRmbG93LWRpc2FibGUtbGluZVxuICAgIGNvbnRleHRWbS5fb3JpZ2luYWwgPSBwYXJlbnQ7XG4gIH0gZWxzZSB7XG4gICAgLy8gdGhlIGNvbnRleHQgdm0gcGFzc2VkIGluIGlzIGEgZnVuY3Rpb25hbCBjb250ZXh0IGFzIHdlbGwuXG4gICAgLy8gaW4gdGhpcyBjYXNlIHdlIHdhbnQgdG8gbWFrZSBzdXJlIHdlIGFyZSBhYmxlIHRvIGdldCBhIGhvbGQgdG8gdGhlXG4gICAgLy8gcmVhbCBjb250ZXh0IGluc3RhbmNlLlxuICAgIGNvbnRleHRWbSA9IHBhcmVudDtcbiAgICAvLyAkZmxvdy1kaXNhYmxlLWxpbmVcbiAgICBwYXJlbnQgPSBwYXJlbnQuX29yaWdpbmFsO1xuICB9XG4gIHZhciBpc0NvbXBpbGVkID0gaXNUcnVlKG9wdGlvbnMuX2NvbXBpbGVkKTtcbiAgdmFyIG5lZWROb3JtYWxpemF0aW9uID0gIWlzQ29tcGlsZWQ7XG5cbiAgdGhpcy5kYXRhID0gZGF0YTtcbiAgdGhpcy5wcm9wcyA9IHByb3BzO1xuICB0aGlzLmNoaWxkcmVuID0gY2hpbGRyZW47XG4gIHRoaXMucGFyZW50ID0gcGFyZW50O1xuICB0aGlzLmxpc3RlbmVycyA9IGRhdGEub24gfHwgZW1wdHlPYmplY3Q7XG4gIHRoaXMuaW5qZWN0aW9ucyA9IHJlc29sdmVJbmplY3Qob3B0aW9ucy5pbmplY3QsIHBhcmVudCk7XG4gIHRoaXMuc2xvdHMgPSBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKCF0aGlzJDEuJHNsb3RzKSB7XG4gICAgICBub3JtYWxpemVTY29wZWRTbG90cyhcbiAgICAgICAgZGF0YS5zY29wZWRTbG90cyxcbiAgICAgICAgdGhpcyQxLiRzbG90cyA9IHJlc29sdmVTbG90cyhjaGlsZHJlbiwgcGFyZW50KVxuICAgICAgKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMkMS4kc2xvdHNcbiAgfTtcblxuICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgJ3Njb3BlZFNsb3RzJywgKHtcbiAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0ICgpIHtcbiAgICAgIHJldHVybiBub3JtYWxpemVTY29wZWRTbG90cyhkYXRhLnNjb3BlZFNsb3RzLCB0aGlzLnNsb3RzKCkpXG4gICAgfVxuICB9KSk7XG5cbiAgLy8gc3VwcG9ydCBmb3IgY29tcGlsZWQgZnVuY3Rpb25hbCB0ZW1wbGF0ZVxuICBpZiAoaXNDb21waWxlZCkge1xuICAgIC8vIGV4cG9zaW5nICRvcHRpb25zIGZvciByZW5kZXJTdGF0aWMoKVxuICAgIHRoaXMuJG9wdGlvbnMgPSBvcHRpb25zO1xuICAgIC8vIHByZS1yZXNvbHZlIHNsb3RzIGZvciByZW5kZXJTbG90KClcbiAgICB0aGlzLiRzbG90cyA9IHRoaXMuc2xvdHMoKTtcbiAgICB0aGlzLiRzY29wZWRTbG90cyA9IG5vcm1hbGl6ZVNjb3BlZFNsb3RzKGRhdGEuc2NvcGVkU2xvdHMsIHRoaXMuJHNsb3RzKTtcbiAgfVxuXG4gIGlmIChvcHRpb25zLl9zY29wZUlkKSB7XG4gICAgdGhpcy5fYyA9IGZ1bmN0aW9uIChhLCBiLCBjLCBkKSB7XG4gICAgICB2YXIgdm5vZGUgPSBjcmVhdGVFbGVtZW50KGNvbnRleHRWbSwgYSwgYiwgYywgZCwgbmVlZE5vcm1hbGl6YXRpb24pO1xuICAgICAgaWYgKHZub2RlICYmICFBcnJheS5pc0FycmF5KHZub2RlKSkge1xuICAgICAgICB2bm9kZS5mblNjb3BlSWQgPSBvcHRpb25zLl9zY29wZUlkO1xuICAgICAgICB2bm9kZS5mbkNvbnRleHQgPSBwYXJlbnQ7XG4gICAgICB9XG4gICAgICByZXR1cm4gdm5vZGVcbiAgICB9O1xuICB9IGVsc2Uge1xuICAgIHRoaXMuX2MgPSBmdW5jdGlvbiAoYSwgYiwgYywgZCkgeyByZXR1cm4gY3JlYXRlRWxlbWVudChjb250ZXh0Vm0sIGEsIGIsIGMsIGQsIG5lZWROb3JtYWxpemF0aW9uKTsgfTtcbiAgfVxufVxuXG5pbnN0YWxsUmVuZGVySGVscGVycyhGdW5jdGlvbmFsUmVuZGVyQ29udGV4dC5wcm90b3R5cGUpO1xuXG5mdW5jdGlvbiBjcmVhdGVGdW5jdGlvbmFsQ29tcG9uZW50IChcbiAgQ3RvcixcbiAgcHJvcHNEYXRhLFxuICBkYXRhLFxuICBjb250ZXh0Vm0sXG4gIGNoaWxkcmVuXG4pIHtcbiAgdmFyIG9wdGlvbnMgPSBDdG9yLm9wdGlvbnM7XG4gIHZhciBwcm9wcyA9IHt9O1xuICB2YXIgcHJvcE9wdGlvbnMgPSBvcHRpb25zLnByb3BzO1xuICBpZiAoaXNEZWYocHJvcE9wdGlvbnMpKSB7XG4gICAgZm9yICh2YXIga2V5IGluIHByb3BPcHRpb25zKSB7XG4gICAgICBwcm9wc1trZXldID0gdmFsaWRhdGVQcm9wKGtleSwgcHJvcE9wdGlvbnMsIHByb3BzRGF0YSB8fCBlbXB0eU9iamVjdCk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGlmIChpc0RlZihkYXRhLmF0dHJzKSkgeyBtZXJnZVByb3BzKHByb3BzLCBkYXRhLmF0dHJzKTsgfVxuICAgIGlmIChpc0RlZihkYXRhLnByb3BzKSkgeyBtZXJnZVByb3BzKHByb3BzLCBkYXRhLnByb3BzKTsgfVxuICB9XG5cbiAgdmFyIHJlbmRlckNvbnRleHQgPSBuZXcgRnVuY3Rpb25hbFJlbmRlckNvbnRleHQoXG4gICAgZGF0YSxcbiAgICBwcm9wcyxcbiAgICBjaGlsZHJlbixcbiAgICBjb250ZXh0Vm0sXG4gICAgQ3RvclxuICApO1xuXG4gIHZhciB2bm9kZSA9IG9wdGlvbnMucmVuZGVyLmNhbGwobnVsbCwgcmVuZGVyQ29udGV4dC5fYywgcmVuZGVyQ29udGV4dCk7XG5cbiAgaWYgKHZub2RlIGluc3RhbmNlb2YgVk5vZGUpIHtcbiAgICByZXR1cm4gY2xvbmVBbmRNYXJrRnVuY3Rpb25hbFJlc3VsdCh2bm9kZSwgZGF0YSwgcmVuZGVyQ29udGV4dC5wYXJlbnQsIG9wdGlvbnMsIHJlbmRlckNvbnRleHQpXG4gIH0gZWxzZSBpZiAoQXJyYXkuaXNBcnJheSh2bm9kZSkpIHtcbiAgICB2YXIgdm5vZGVzID0gbm9ybWFsaXplQ2hpbGRyZW4odm5vZGUpIHx8IFtdO1xuICAgIHZhciByZXMgPSBuZXcgQXJyYXkodm5vZGVzLmxlbmd0aCk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB2bm9kZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHJlc1tpXSA9IGNsb25lQW5kTWFya0Z1bmN0aW9uYWxSZXN1bHQodm5vZGVzW2ldLCBkYXRhLCByZW5kZXJDb250ZXh0LnBhcmVudCwgb3B0aW9ucywgcmVuZGVyQ29udGV4dCk7XG4gICAgfVxuICAgIHJldHVybiByZXNcbiAgfVxufVxuXG5mdW5jdGlvbiBjbG9uZUFuZE1hcmtGdW5jdGlvbmFsUmVzdWx0ICh2bm9kZSwgZGF0YSwgY29udGV4dFZtLCBvcHRpb25zLCByZW5kZXJDb250ZXh0KSB7XG4gIC8vICM3ODE3IGNsb25lIG5vZGUgYmVmb3JlIHNldHRpbmcgZm5Db250ZXh0LCBvdGhlcndpc2UgaWYgdGhlIG5vZGUgaXMgcmV1c2VkXG4gIC8vIChlLmcuIGl0IHdhcyBmcm9tIGEgY2FjaGVkIG5vcm1hbCBzbG90KSB0aGUgZm5Db250ZXh0IGNhdXNlcyBuYW1lZCBzbG90c1xuICAvLyB0aGF0IHNob3VsZCBub3QgYmUgbWF0Y2hlZCB0byBtYXRjaC5cbiAgdmFyIGNsb25lID0gY2xvbmVWTm9kZSh2bm9kZSk7XG4gIGNsb25lLmZuQ29udGV4dCA9IGNvbnRleHRWbTtcbiAgY2xvbmUuZm5PcHRpb25zID0gb3B0aW9ucztcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAoY2xvbmUuZGV2dG9vbHNNZXRhID0gY2xvbmUuZGV2dG9vbHNNZXRhIHx8IHt9KS5yZW5kZXJDb250ZXh0ID0gcmVuZGVyQ29udGV4dDtcbiAgfVxuICBpZiAoZGF0YS5zbG90KSB7XG4gICAgKGNsb25lLmRhdGEgfHwgKGNsb25lLmRhdGEgPSB7fSkpLnNsb3QgPSBkYXRhLnNsb3Q7XG4gIH1cbiAgcmV0dXJuIGNsb25lXG59XG5cbmZ1bmN0aW9uIG1lcmdlUHJvcHMgKHRvLCBmcm9tKSB7XG4gIGZvciAodmFyIGtleSBpbiBmcm9tKSB7XG4gICAgdG9bY2FtZWxpemUoa2V5KV0gPSBmcm9tW2tleV07XG4gIH1cbn1cblxuLyogICovXG5cbi8qICAqL1xuXG4vKiAgKi9cblxuLyogICovXG5cbi8vIGlubGluZSBob29rcyB0byBiZSBpbnZva2VkIG9uIGNvbXBvbmVudCBWTm9kZXMgZHVyaW5nIHBhdGNoXG52YXIgY29tcG9uZW50Vk5vZGVIb29rcyA9IHtcbiAgaW5pdDogZnVuY3Rpb24gaW5pdCAodm5vZGUsIGh5ZHJhdGluZykge1xuICAgIGlmIChcbiAgICAgIHZub2RlLmNvbXBvbmVudEluc3RhbmNlICYmXG4gICAgICAhdm5vZGUuY29tcG9uZW50SW5zdGFuY2UuX2lzRGVzdHJveWVkICYmXG4gICAgICB2bm9kZS5kYXRhLmtlZXBBbGl2ZVxuICAgICkge1xuICAgICAgLy8ga2VwdC1hbGl2ZSBjb21wb25lbnRzLCB0cmVhdCBhcyBhIHBhdGNoXG4gICAgICB2YXIgbW91bnRlZE5vZGUgPSB2bm9kZTsgLy8gd29yayBhcm91bmQgZmxvd1xuICAgICAgY29tcG9uZW50Vk5vZGVIb29rcy5wcmVwYXRjaChtb3VudGVkTm9kZSwgbW91bnRlZE5vZGUpO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgY2hpbGQgPSB2bm9kZS5jb21wb25lbnRJbnN0YW5jZSA9IGNyZWF0ZUNvbXBvbmVudEluc3RhbmNlRm9yVm5vZGUoXG4gICAgICAgIHZub2RlLFxuICAgICAgICBhY3RpdmVJbnN0YW5jZVxuICAgICAgKTtcbiAgICAgIGNoaWxkLiRtb3VudChoeWRyYXRpbmcgPyB2bm9kZS5lbG0gOiB1bmRlZmluZWQsIGh5ZHJhdGluZyk7XG4gICAgfVxuICB9LFxuXG4gIHByZXBhdGNoOiBmdW5jdGlvbiBwcmVwYXRjaCAob2xkVm5vZGUsIHZub2RlKSB7XG4gICAgdmFyIG9wdGlvbnMgPSB2bm9kZS5jb21wb25lbnRPcHRpb25zO1xuICAgIHZhciBjaGlsZCA9IHZub2RlLmNvbXBvbmVudEluc3RhbmNlID0gb2xkVm5vZGUuY29tcG9uZW50SW5zdGFuY2U7XG4gICAgdXBkYXRlQ2hpbGRDb21wb25lbnQoXG4gICAgICBjaGlsZCxcbiAgICAgIG9wdGlvbnMucHJvcHNEYXRhLCAvLyB1cGRhdGVkIHByb3BzXG4gICAgICBvcHRpb25zLmxpc3RlbmVycywgLy8gdXBkYXRlZCBsaXN0ZW5lcnNcbiAgICAgIHZub2RlLCAvLyBuZXcgcGFyZW50IHZub2RlXG4gICAgICBvcHRpb25zLmNoaWxkcmVuIC8vIG5ldyBjaGlsZHJlblxuICAgICk7XG4gIH0sXG5cbiAgaW5zZXJ0OiBmdW5jdGlvbiBpbnNlcnQgKHZub2RlKSB7XG4gICAgdmFyIGNvbnRleHQgPSB2bm9kZS5jb250ZXh0O1xuICAgIHZhciBjb21wb25lbnRJbnN0YW5jZSA9IHZub2RlLmNvbXBvbmVudEluc3RhbmNlO1xuICAgIGlmICghY29tcG9uZW50SW5zdGFuY2UuX2lzTW91bnRlZCkge1xuICAgICAgY29tcG9uZW50SW5zdGFuY2UuX2lzTW91bnRlZCA9IHRydWU7XG4gICAgICBjYWxsSG9vayhjb21wb25lbnRJbnN0YW5jZSwgJ21vdW50ZWQnKTtcbiAgICB9XG4gICAgaWYgKHZub2RlLmRhdGEua2VlcEFsaXZlKSB7XG4gICAgICBpZiAoY29udGV4dC5faXNNb3VudGVkKSB7XG4gICAgICAgIC8vIHZ1ZS1yb3V0ZXIjMTIxMlxuICAgICAgICAvLyBEdXJpbmcgdXBkYXRlcywgYSBrZXB0LWFsaXZlIGNvbXBvbmVudCdzIGNoaWxkIGNvbXBvbmVudHMgbWF5XG4gICAgICAgIC8vIGNoYW5nZSwgc28gZGlyZWN0bHkgd2Fsa2luZyB0aGUgdHJlZSBoZXJlIG1heSBjYWxsIGFjdGl2YXRlZCBob29rc1xuICAgICAgICAvLyBvbiBpbmNvcnJlY3QgY2hpbGRyZW4uIEluc3RlYWQgd2UgcHVzaCB0aGVtIGludG8gYSBxdWV1ZSB3aGljaCB3aWxsXG4gICAgICAgIC8vIGJlIHByb2Nlc3NlZCBhZnRlciB0aGUgd2hvbGUgcGF0Y2ggcHJvY2VzcyBlbmRlZC5cbiAgICAgICAgcXVldWVBY3RpdmF0ZWRDb21wb25lbnQoY29tcG9uZW50SW5zdGFuY2UpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYWN0aXZhdGVDaGlsZENvbXBvbmVudChjb21wb25lbnRJbnN0YW5jZSwgdHJ1ZSAvKiBkaXJlY3QgKi8pO1xuICAgICAgfVxuICAgIH1cbiAgfSxcblxuICBkZXN0cm95OiBmdW5jdGlvbiBkZXN0cm95ICh2bm9kZSkge1xuICAgIHZhciBjb21wb25lbnRJbnN0YW5jZSA9IHZub2RlLmNvbXBvbmVudEluc3RhbmNlO1xuICAgIGlmICghY29tcG9uZW50SW5zdGFuY2UuX2lzRGVzdHJveWVkKSB7XG4gICAgICBpZiAoIXZub2RlLmRhdGEua2VlcEFsaXZlKSB7XG4gICAgICAgIGNvbXBvbmVudEluc3RhbmNlLiRkZXN0cm95KCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBkZWFjdGl2YXRlQ2hpbGRDb21wb25lbnQoY29tcG9uZW50SW5zdGFuY2UsIHRydWUgLyogZGlyZWN0ICovKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn07XG5cbnZhciBob29rc1RvTWVyZ2UgPSBPYmplY3Qua2V5cyhjb21wb25lbnRWTm9kZUhvb2tzKTtcblxuZnVuY3Rpb24gY3JlYXRlQ29tcG9uZW50IChcbiAgQ3RvcixcbiAgZGF0YSxcbiAgY29udGV4dCxcbiAgY2hpbGRyZW4sXG4gIHRhZ1xuKSB7XG4gIGlmIChpc1VuZGVmKEN0b3IpKSB7XG4gICAgcmV0dXJuXG4gIH1cblxuICB2YXIgYmFzZUN0b3IgPSBjb250ZXh0LiRvcHRpb25zLl9iYXNlO1xuXG4gIC8vIHBsYWluIG9wdGlvbnMgb2JqZWN0OiB0dXJuIGl0IGludG8gYSBjb25zdHJ1Y3RvclxuICBpZiAoaXNPYmplY3QoQ3RvcikpIHtcbiAgICBDdG9yID0gYmFzZUN0b3IuZXh0ZW5kKEN0b3IpO1xuICB9XG5cbiAgLy8gaWYgYXQgdGhpcyBzdGFnZSBpdCdzIG5vdCBhIGNvbnN0cnVjdG9yIG9yIGFuIGFzeW5jIGNvbXBvbmVudCBmYWN0b3J5LFxuICAvLyByZWplY3QuXG4gIGlmICh0eXBlb2YgQ3RvciAhPT0gJ2Z1bmN0aW9uJykge1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICB3YXJuKChcIkludmFsaWQgQ29tcG9uZW50IGRlZmluaXRpb246IFwiICsgKFN0cmluZyhDdG9yKSkpLCBjb250ZXh0KTtcbiAgICB9XG4gICAgcmV0dXJuXG4gIH1cblxuICAvLyBhc3luYyBjb21wb25lbnRcbiAgdmFyIGFzeW5jRmFjdG9yeTtcbiAgaWYgKGlzVW5kZWYoQ3Rvci5jaWQpKSB7XG4gICAgYXN5bmNGYWN0b3J5ID0gQ3RvcjtcbiAgICBDdG9yID0gcmVzb2x2ZUFzeW5jQ29tcG9uZW50KGFzeW5jRmFjdG9yeSwgYmFzZUN0b3IpO1xuICAgIGlmIChDdG9yID09PSB1bmRlZmluZWQpIHtcbiAgICAgIC8vIHJldHVybiBhIHBsYWNlaG9sZGVyIG5vZGUgZm9yIGFzeW5jIGNvbXBvbmVudCwgd2hpY2ggaXMgcmVuZGVyZWRcbiAgICAgIC8vIGFzIGEgY29tbWVudCBub2RlIGJ1dCBwcmVzZXJ2ZXMgYWxsIHRoZSByYXcgaW5mb3JtYXRpb24gZm9yIHRoZSBub2RlLlxuICAgICAgLy8gdGhlIGluZm9ybWF0aW9uIHdpbGwgYmUgdXNlZCBmb3IgYXN5bmMgc2VydmVyLXJlbmRlcmluZyBhbmQgaHlkcmF0aW9uLlxuICAgICAgcmV0dXJuIGNyZWF0ZUFzeW5jUGxhY2Vob2xkZXIoXG4gICAgICAgIGFzeW5jRmFjdG9yeSxcbiAgICAgICAgZGF0YSxcbiAgICAgICAgY29udGV4dCxcbiAgICAgICAgY2hpbGRyZW4sXG4gICAgICAgIHRhZ1xuICAgICAgKVxuICAgIH1cbiAgfVxuXG4gIGRhdGEgPSBkYXRhIHx8IHt9O1xuXG4gIC8vIHJlc29sdmUgY29uc3RydWN0b3Igb3B0aW9ucyBpbiBjYXNlIGdsb2JhbCBtaXhpbnMgYXJlIGFwcGxpZWQgYWZ0ZXJcbiAgLy8gY29tcG9uZW50IGNvbnN0cnVjdG9yIGNyZWF0aW9uXG4gIHJlc29sdmVDb25zdHJ1Y3Rvck9wdGlvbnMoQ3Rvcik7XG5cbiAgLy8gdHJhbnNmb3JtIGNvbXBvbmVudCB2LW1vZGVsIGRhdGEgaW50byBwcm9wcyAmIGV2ZW50c1xuICBpZiAoaXNEZWYoZGF0YS5tb2RlbCkpIHtcbiAgICB0cmFuc2Zvcm1Nb2RlbChDdG9yLm9wdGlvbnMsIGRhdGEpO1xuICB9XG5cbiAgLy8gZXh0cmFjdCBwcm9wc1xuICB2YXIgcHJvcHNEYXRhID0gZXh0cmFjdFByb3BzRnJvbVZOb2RlRGF0YShkYXRhLCBDdG9yLCB0YWcpO1xuXG4gIC8vIGZ1bmN0aW9uYWwgY29tcG9uZW50XG4gIGlmIChpc1RydWUoQ3Rvci5vcHRpb25zLmZ1bmN0aW9uYWwpKSB7XG4gICAgcmV0dXJuIGNyZWF0ZUZ1bmN0aW9uYWxDb21wb25lbnQoQ3RvciwgcHJvcHNEYXRhLCBkYXRhLCBjb250ZXh0LCBjaGlsZHJlbilcbiAgfVxuXG4gIC8vIGV4dHJhY3QgbGlzdGVuZXJzLCBzaW5jZSB0aGVzZSBuZWVkcyB0byBiZSB0cmVhdGVkIGFzXG4gIC8vIGNoaWxkIGNvbXBvbmVudCBsaXN0ZW5lcnMgaW5zdGVhZCBvZiBET00gbGlzdGVuZXJzXG4gIHZhciBsaXN0ZW5lcnMgPSBkYXRhLm9uO1xuICAvLyByZXBsYWNlIHdpdGggbGlzdGVuZXJzIHdpdGggLm5hdGl2ZSBtb2RpZmllclxuICAvLyBzbyBpdCBnZXRzIHByb2Nlc3NlZCBkdXJpbmcgcGFyZW50IGNvbXBvbmVudCBwYXRjaC5cbiAgZGF0YS5vbiA9IGRhdGEubmF0aXZlT247XG5cbiAgaWYgKGlzVHJ1ZShDdG9yLm9wdGlvbnMuYWJzdHJhY3QpKSB7XG4gICAgLy8gYWJzdHJhY3QgY29tcG9uZW50cyBkbyBub3Qga2VlcCBhbnl0aGluZ1xuICAgIC8vIG90aGVyIHRoYW4gcHJvcHMgJiBsaXN0ZW5lcnMgJiBzbG90XG5cbiAgICAvLyB3b3JrIGFyb3VuZCBmbG93XG4gICAgdmFyIHNsb3QgPSBkYXRhLnNsb3Q7XG4gICAgZGF0YSA9IHt9O1xuICAgIGlmIChzbG90KSB7XG4gICAgICBkYXRhLnNsb3QgPSBzbG90O1xuICAgIH1cbiAgfVxuXG4gIC8vIGluc3RhbGwgY29tcG9uZW50IG1hbmFnZW1lbnQgaG9va3Mgb250byB0aGUgcGxhY2Vob2xkZXIgbm9kZVxuICBpbnN0YWxsQ29tcG9uZW50SG9va3MoZGF0YSk7XG5cbiAgLy8gcmV0dXJuIGEgcGxhY2Vob2xkZXIgdm5vZGVcbiAgdmFyIG5hbWUgPSBDdG9yLm9wdGlvbnMubmFtZSB8fCB0YWc7XG4gIHZhciB2bm9kZSA9IG5ldyBWTm9kZShcbiAgICAoXCJ2dWUtY29tcG9uZW50LVwiICsgKEN0b3IuY2lkKSArIChuYW1lID8gKFwiLVwiICsgbmFtZSkgOiAnJykpLFxuICAgIGRhdGEsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCB1bmRlZmluZWQsIGNvbnRleHQsXG4gICAgeyBDdG9yOiBDdG9yLCBwcm9wc0RhdGE6IHByb3BzRGF0YSwgbGlzdGVuZXJzOiBsaXN0ZW5lcnMsIHRhZzogdGFnLCBjaGlsZHJlbjogY2hpbGRyZW4gfSxcbiAgICBhc3luY0ZhY3RvcnlcbiAgKTtcblxuICByZXR1cm4gdm5vZGVcbn1cblxuZnVuY3Rpb24gY3JlYXRlQ29tcG9uZW50SW5zdGFuY2VGb3JWbm9kZSAoXG4gIHZub2RlLCAvLyB3ZSBrbm93IGl0J3MgTW91bnRlZENvbXBvbmVudFZOb2RlIGJ1dCBmbG93IGRvZXNuJ3RcbiAgcGFyZW50IC8vIGFjdGl2ZUluc3RhbmNlIGluIGxpZmVjeWNsZSBzdGF0ZVxuKSB7XG4gIHZhciBvcHRpb25zID0ge1xuICAgIF9pc0NvbXBvbmVudDogdHJ1ZSxcbiAgICBfcGFyZW50Vm5vZGU6IHZub2RlLFxuICAgIHBhcmVudDogcGFyZW50XG4gIH07XG4gIC8vIGNoZWNrIGlubGluZS10ZW1wbGF0ZSByZW5kZXIgZnVuY3Rpb25zXG4gIHZhciBpbmxpbmVUZW1wbGF0ZSA9IHZub2RlLmRhdGEuaW5saW5lVGVtcGxhdGU7XG4gIGlmIChpc0RlZihpbmxpbmVUZW1wbGF0ZSkpIHtcbiAgICBvcHRpb25zLnJlbmRlciA9IGlubGluZVRlbXBsYXRlLnJlbmRlcjtcbiAgICBvcHRpb25zLnN0YXRpY1JlbmRlckZucyA9IGlubGluZVRlbXBsYXRlLnN0YXRpY1JlbmRlckZucztcbiAgfVxuICByZXR1cm4gbmV3IHZub2RlLmNvbXBvbmVudE9wdGlvbnMuQ3RvcihvcHRpb25zKVxufVxuXG5mdW5jdGlvbiBpbnN0YWxsQ29tcG9uZW50SG9va3MgKGRhdGEpIHtcbiAgdmFyIGhvb2tzID0gZGF0YS5ob29rIHx8IChkYXRhLmhvb2sgPSB7fSk7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgaG9va3NUb01lcmdlLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGtleSA9IGhvb2tzVG9NZXJnZVtpXTtcbiAgICB2YXIgZXhpc3RpbmcgPSBob29rc1trZXldO1xuICAgIHZhciB0b01lcmdlID0gY29tcG9uZW50Vk5vZGVIb29rc1trZXldO1xuICAgIGlmIChleGlzdGluZyAhPT0gdG9NZXJnZSAmJiAhKGV4aXN0aW5nICYmIGV4aXN0aW5nLl9tZXJnZWQpKSB7XG4gICAgICBob29rc1trZXldID0gZXhpc3RpbmcgPyBtZXJnZUhvb2skMSh0b01lcmdlLCBleGlzdGluZykgOiB0b01lcmdlO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBtZXJnZUhvb2skMSAoZjEsIGYyKSB7XG4gIHZhciBtZXJnZWQgPSBmdW5jdGlvbiAoYSwgYikge1xuICAgIC8vIGZsb3cgY29tcGxhaW5zIGFib3V0IGV4dHJhIGFyZ3Mgd2hpY2ggaXMgd2h5IHdlIHVzZSBhbnlcbiAgICBmMShhLCBiKTtcbiAgICBmMihhLCBiKTtcbiAgfTtcbiAgbWVyZ2VkLl9tZXJnZWQgPSB0cnVlO1xuICByZXR1cm4gbWVyZ2VkXG59XG5cbi8vIHRyYW5zZm9ybSBjb21wb25lbnQgdi1tb2RlbCBpbmZvICh2YWx1ZSBhbmQgY2FsbGJhY2spIGludG9cbi8vIHByb3AgYW5kIGV2ZW50IGhhbmRsZXIgcmVzcGVjdGl2ZWx5LlxuZnVuY3Rpb24gdHJhbnNmb3JtTW9kZWwgKG9wdGlvbnMsIGRhdGEpIHtcbiAgdmFyIHByb3AgPSAob3B0aW9ucy5tb2RlbCAmJiBvcHRpb25zLm1vZGVsLnByb3ApIHx8ICd2YWx1ZSc7XG4gIHZhciBldmVudCA9IChvcHRpb25zLm1vZGVsICYmIG9wdGlvbnMubW9kZWwuZXZlbnQpIHx8ICdpbnB1dCdcbiAgOyhkYXRhLmF0dHJzIHx8IChkYXRhLmF0dHJzID0ge30pKVtwcm9wXSA9IGRhdGEubW9kZWwudmFsdWU7XG4gIHZhciBvbiA9IGRhdGEub24gfHwgKGRhdGEub24gPSB7fSk7XG4gIHZhciBleGlzdGluZyA9IG9uW2V2ZW50XTtcbiAgdmFyIGNhbGxiYWNrID0gZGF0YS5tb2RlbC5jYWxsYmFjaztcbiAgaWYgKGlzRGVmKGV4aXN0aW5nKSkge1xuICAgIGlmIChcbiAgICAgIEFycmF5LmlzQXJyYXkoZXhpc3RpbmcpXG4gICAgICAgID8gZXhpc3RpbmcuaW5kZXhPZihjYWxsYmFjaykgPT09IC0xXG4gICAgICAgIDogZXhpc3RpbmcgIT09IGNhbGxiYWNrXG4gICAgKSB7XG4gICAgICBvbltldmVudF0gPSBbY2FsbGJhY2tdLmNvbmNhdChleGlzdGluZyk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIG9uW2V2ZW50XSA9IGNhbGxiYWNrO1xuICB9XG59XG5cbi8qICAqL1xuXG52YXIgU0lNUExFX05PUk1BTElaRSA9IDE7XG52YXIgQUxXQVlTX05PUk1BTElaRSA9IDI7XG5cbi8vIHdyYXBwZXIgZnVuY3Rpb24gZm9yIHByb3ZpZGluZyBhIG1vcmUgZmxleGlibGUgaW50ZXJmYWNlXG4vLyB3aXRob3V0IGdldHRpbmcgeWVsbGVkIGF0IGJ5IGZsb3dcbmZ1bmN0aW9uIGNyZWF0ZUVsZW1lbnQgKFxuICBjb250ZXh0LFxuICB0YWcsXG4gIGRhdGEsXG4gIGNoaWxkcmVuLFxuICBub3JtYWxpemF0aW9uVHlwZSxcbiAgYWx3YXlzTm9ybWFsaXplXG4pIHtcbiAgaWYgKEFycmF5LmlzQXJyYXkoZGF0YSkgfHwgaXNQcmltaXRpdmUoZGF0YSkpIHtcbiAgICBub3JtYWxpemF0aW9uVHlwZSA9IGNoaWxkcmVuO1xuICAgIGNoaWxkcmVuID0gZGF0YTtcbiAgICBkYXRhID0gdW5kZWZpbmVkO1xuICB9XG4gIGlmIChpc1RydWUoYWx3YXlzTm9ybWFsaXplKSkge1xuICAgIG5vcm1hbGl6YXRpb25UeXBlID0gQUxXQVlTX05PUk1BTElaRTtcbiAgfVxuICByZXR1cm4gX2NyZWF0ZUVsZW1lbnQoY29udGV4dCwgdGFnLCBkYXRhLCBjaGlsZHJlbiwgbm9ybWFsaXphdGlvblR5cGUpXG59XG5cbmZ1bmN0aW9uIF9jcmVhdGVFbGVtZW50IChcbiAgY29udGV4dCxcbiAgdGFnLFxuICBkYXRhLFxuICBjaGlsZHJlbixcbiAgbm9ybWFsaXphdGlvblR5cGVcbikge1xuICBpZiAoaXNEZWYoZGF0YSkgJiYgaXNEZWYoKGRhdGEpLl9fb2JfXykpIHtcbiAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIHdhcm4oXG4gICAgICBcIkF2b2lkIHVzaW5nIG9ic2VydmVkIGRhdGEgb2JqZWN0IGFzIHZub2RlIGRhdGE6IFwiICsgKEpTT04uc3RyaW5naWZ5KGRhdGEpKSArIFwiXFxuXCIgK1xuICAgICAgJ0Fsd2F5cyBjcmVhdGUgZnJlc2ggdm5vZGUgZGF0YSBvYmplY3RzIGluIGVhY2ggcmVuZGVyIScsXG4gICAgICBjb250ZXh0XG4gICAgKTtcbiAgICByZXR1cm4gY3JlYXRlRW1wdHlWTm9kZSgpXG4gIH1cbiAgLy8gb2JqZWN0IHN5bnRheCBpbiB2LWJpbmRcbiAgaWYgKGlzRGVmKGRhdGEpICYmIGlzRGVmKGRhdGEuaXMpKSB7XG4gICAgdGFnID0gZGF0YS5pcztcbiAgfVxuICBpZiAoIXRhZykge1xuICAgIC8vIGluIGNhc2Ugb2YgY29tcG9uZW50IDppcyBzZXQgdG8gZmFsc3kgdmFsdWVcbiAgICByZXR1cm4gY3JlYXRlRW1wdHlWTm9kZSgpXG4gIH1cbiAgLy8gd2FybiBhZ2FpbnN0IG5vbi1wcmltaXRpdmUga2V5XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmXG4gICAgaXNEZWYoZGF0YSkgJiYgaXNEZWYoZGF0YS5rZXkpICYmICFpc1ByaW1pdGl2ZShkYXRhLmtleSlcbiAgKSB7XG4gICAge1xuICAgICAgd2FybihcbiAgICAgICAgJ0F2b2lkIHVzaW5nIG5vbi1wcmltaXRpdmUgdmFsdWUgYXMga2V5LCAnICtcbiAgICAgICAgJ3VzZSBzdHJpbmcvbnVtYmVyIHZhbHVlIGluc3RlYWQuJyxcbiAgICAgICAgY29udGV4dFxuICAgICAgKTtcbiAgICB9XG4gIH1cbiAgLy8gc3VwcG9ydCBzaW5nbGUgZnVuY3Rpb24gY2hpbGRyZW4gYXMgZGVmYXVsdCBzY29wZWQgc2xvdFxuICBpZiAoQXJyYXkuaXNBcnJheShjaGlsZHJlbikgJiZcbiAgICB0eXBlb2YgY2hpbGRyZW5bMF0gPT09ICdmdW5jdGlvbidcbiAgKSB7XG4gICAgZGF0YSA9IGRhdGEgfHwge307XG4gICAgZGF0YS5zY29wZWRTbG90cyA9IHsgZGVmYXVsdDogY2hpbGRyZW5bMF0gfTtcbiAgICBjaGlsZHJlbi5sZW5ndGggPSAwO1xuICB9XG4gIGlmIChub3JtYWxpemF0aW9uVHlwZSA9PT0gQUxXQVlTX05PUk1BTElaRSkge1xuICAgIGNoaWxkcmVuID0gbm9ybWFsaXplQ2hpbGRyZW4oY2hpbGRyZW4pO1xuICB9IGVsc2UgaWYgKG5vcm1hbGl6YXRpb25UeXBlID09PSBTSU1QTEVfTk9STUFMSVpFKSB7XG4gICAgY2hpbGRyZW4gPSBzaW1wbGVOb3JtYWxpemVDaGlsZHJlbihjaGlsZHJlbik7XG4gIH1cbiAgdmFyIHZub2RlLCBucztcbiAgaWYgKHR5cGVvZiB0YWcgPT09ICdzdHJpbmcnKSB7XG4gICAgdmFyIEN0b3I7XG4gICAgbnMgPSAoY29udGV4dC4kdm5vZGUgJiYgY29udGV4dC4kdm5vZGUubnMpIHx8IGNvbmZpZy5nZXRUYWdOYW1lc3BhY2UodGFnKTtcbiAgICBpZiAoY29uZmlnLmlzUmVzZXJ2ZWRUYWcodGFnKSkge1xuICAgICAgLy8gcGxhdGZvcm0gYnVpbHQtaW4gZWxlbWVudHNcbiAgICAgIHZub2RlID0gbmV3IFZOb2RlKFxuICAgICAgICBjb25maWcucGFyc2VQbGF0Zm9ybVRhZ05hbWUodGFnKSwgZGF0YSwgY2hpbGRyZW4sXG4gICAgICAgIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCBjb250ZXh0XG4gICAgICApO1xuICAgIH0gZWxzZSBpZiAoKCFkYXRhIHx8ICFkYXRhLnByZSkgJiYgaXNEZWYoQ3RvciA9IHJlc29sdmVBc3NldChjb250ZXh0LiRvcHRpb25zLCAnY29tcG9uZW50cycsIHRhZykpKSB7XG4gICAgICAvLyBjb21wb25lbnRcbiAgICAgIHZub2RlID0gY3JlYXRlQ29tcG9uZW50KEN0b3IsIGRhdGEsIGNvbnRleHQsIGNoaWxkcmVuLCB0YWcpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyB1bmtub3duIG9yIHVubGlzdGVkIG5hbWVzcGFjZWQgZWxlbWVudHNcbiAgICAgIC8vIGNoZWNrIGF0IHJ1bnRpbWUgYmVjYXVzZSBpdCBtYXkgZ2V0IGFzc2lnbmVkIGEgbmFtZXNwYWNlIHdoZW4gaXRzXG4gICAgICAvLyBwYXJlbnQgbm9ybWFsaXplcyBjaGlsZHJlblxuICAgICAgdm5vZGUgPSBuZXcgVk5vZGUoXG4gICAgICAgIHRhZywgZGF0YSwgY2hpbGRyZW4sXG4gICAgICAgIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCBjb250ZXh0XG4gICAgICApO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICAvLyBkaXJlY3QgY29tcG9uZW50IG9wdGlvbnMgLyBjb25zdHJ1Y3RvclxuICAgIHZub2RlID0gY3JlYXRlQ29tcG9uZW50KHRhZywgZGF0YSwgY29udGV4dCwgY2hpbGRyZW4pO1xuICB9XG4gIGlmIChBcnJheS5pc0FycmF5KHZub2RlKSkge1xuICAgIHJldHVybiB2bm9kZVxuICB9IGVsc2UgaWYgKGlzRGVmKHZub2RlKSkge1xuICAgIGlmIChpc0RlZihucykpIHsgYXBwbHlOUyh2bm9kZSwgbnMpOyB9XG4gICAgaWYgKGlzRGVmKGRhdGEpKSB7IHJlZ2lzdGVyRGVlcEJpbmRpbmdzKGRhdGEpOyB9XG4gICAgcmV0dXJuIHZub2RlXG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGNyZWF0ZUVtcHR5Vk5vZGUoKVxuICB9XG59XG5cbmZ1bmN0aW9uIGFwcGx5TlMgKHZub2RlLCBucywgZm9yY2UpIHtcbiAgdm5vZGUubnMgPSBucztcbiAgaWYgKHZub2RlLnRhZyA9PT0gJ2ZvcmVpZ25PYmplY3QnKSB7XG4gICAgLy8gdXNlIGRlZmF1bHQgbmFtZXNwYWNlIGluc2lkZSBmb3JlaWduT2JqZWN0XG4gICAgbnMgPSB1bmRlZmluZWQ7XG4gICAgZm9yY2UgPSB0cnVlO1xuICB9XG4gIGlmIChpc0RlZih2bm9kZS5jaGlsZHJlbikpIHtcbiAgICBmb3IgKHZhciBpID0gMCwgbCA9IHZub2RlLmNoaWxkcmVuLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgdmFyIGNoaWxkID0gdm5vZGUuY2hpbGRyZW5baV07XG4gICAgICBpZiAoaXNEZWYoY2hpbGQudGFnKSAmJiAoXG4gICAgICAgIGlzVW5kZWYoY2hpbGQubnMpIHx8IChpc1RydWUoZm9yY2UpICYmIGNoaWxkLnRhZyAhPT0gJ3N2ZycpKSkge1xuICAgICAgICBhcHBseU5TKGNoaWxkLCBucywgZm9yY2UpO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG4vLyByZWYgIzUzMThcbi8vIG5lY2Vzc2FyeSB0byBlbnN1cmUgcGFyZW50IHJlLXJlbmRlciB3aGVuIGRlZXAgYmluZGluZ3MgbGlrZSA6c3R5bGUgYW5kXG4vLyA6Y2xhc3MgYXJlIHVzZWQgb24gc2xvdCBub2Rlc1xuZnVuY3Rpb24gcmVnaXN0ZXJEZWVwQmluZGluZ3MgKGRhdGEpIHtcbiAgaWYgKGlzT2JqZWN0KGRhdGEuc3R5bGUpKSB7XG4gICAgdHJhdmVyc2UoZGF0YS5zdHlsZSk7XG4gIH1cbiAgaWYgKGlzT2JqZWN0KGRhdGEuY2xhc3MpKSB7XG4gICAgdHJhdmVyc2UoZGF0YS5jbGFzcyk7XG4gIH1cbn1cblxuLyogICovXG5cbmZ1bmN0aW9uIGluaXRSZW5kZXIgKHZtKSB7XG4gIHZtLl92bm9kZSA9IG51bGw7IC8vIHRoZSByb290IG9mIHRoZSBjaGlsZCB0cmVlXG4gIHZtLl9zdGF0aWNUcmVlcyA9IG51bGw7IC8vIHYtb25jZSBjYWNoZWQgdHJlZXNcbiAgdmFyIG9wdGlvbnMgPSB2bS4kb3B0aW9ucztcbiAgdmFyIHBhcmVudFZub2RlID0gdm0uJHZub2RlID0gb3B0aW9ucy5fcGFyZW50Vm5vZGU7IC8vIHRoZSBwbGFjZWhvbGRlciBub2RlIGluIHBhcmVudCB0cmVlXG4gIHZhciByZW5kZXJDb250ZXh0ID0gcGFyZW50Vm5vZGUgJiYgcGFyZW50Vm5vZGUuY29udGV4dDtcbiAgdm0uJHNsb3RzID0gcmVzb2x2ZVNsb3RzKG9wdGlvbnMuX3JlbmRlckNoaWxkcmVuLCByZW5kZXJDb250ZXh0KTtcbiAgdm0uJHNjb3BlZFNsb3RzID0gZW1wdHlPYmplY3Q7XG4gIC8vIGJpbmQgdGhlIGNyZWF0ZUVsZW1lbnQgZm4gdG8gdGhpcyBpbnN0YW5jZVxuICAvLyBzbyB0aGF0IHdlIGdldCBwcm9wZXIgcmVuZGVyIGNvbnRleHQgaW5zaWRlIGl0LlxuICAvLyBhcmdzIG9yZGVyOiB0YWcsIGRhdGEsIGNoaWxkcmVuLCBub3JtYWxpemF0aW9uVHlwZSwgYWx3YXlzTm9ybWFsaXplXG4gIC8vIGludGVybmFsIHZlcnNpb24gaXMgdXNlZCBieSByZW5kZXIgZnVuY3Rpb25zIGNvbXBpbGVkIGZyb20gdGVtcGxhdGVzXG4gIHZtLl9jID0gZnVuY3Rpb24gKGEsIGIsIGMsIGQpIHsgcmV0dXJuIGNyZWF0ZUVsZW1lbnQodm0sIGEsIGIsIGMsIGQsIGZhbHNlKTsgfTtcbiAgLy8gbm9ybWFsaXphdGlvbiBpcyBhbHdheXMgYXBwbGllZCBmb3IgdGhlIHB1YmxpYyB2ZXJzaW9uLCB1c2VkIGluXG4gIC8vIHVzZXItd3JpdHRlbiByZW5kZXIgZnVuY3Rpb25zLlxuICB2bS4kY3JlYXRlRWxlbWVudCA9IGZ1bmN0aW9uIChhLCBiLCBjLCBkKSB7IHJldHVybiBjcmVhdGVFbGVtZW50KHZtLCBhLCBiLCBjLCBkLCB0cnVlKTsgfTtcblxuICAvLyAkYXR0cnMgJiAkbGlzdGVuZXJzIGFyZSBleHBvc2VkIGZvciBlYXNpZXIgSE9DIGNyZWF0aW9uLlxuICAvLyB0aGV5IG5lZWQgdG8gYmUgcmVhY3RpdmUgc28gdGhhdCBIT0NzIHVzaW5nIHRoZW0gYXJlIGFsd2F5cyB1cGRhdGVkXG4gIHZhciBwYXJlbnREYXRhID0gcGFyZW50Vm5vZGUgJiYgcGFyZW50Vm5vZGUuZGF0YTtcblxuICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgIGRlZmluZVJlYWN0aXZlJCQxKHZtLCAnJGF0dHJzJywgcGFyZW50RGF0YSAmJiBwYXJlbnREYXRhLmF0dHJzIHx8IGVtcHR5T2JqZWN0LCBmdW5jdGlvbiAoKSB7XG4gICAgICAhaXNVcGRhdGluZ0NoaWxkQ29tcG9uZW50ICYmIHdhcm4oXCIkYXR0cnMgaXMgcmVhZG9ubHkuXCIsIHZtKTtcbiAgICB9LCB0cnVlKTtcbiAgICBkZWZpbmVSZWFjdGl2ZSQkMSh2bSwgJyRsaXN0ZW5lcnMnLCBvcHRpb25zLl9wYXJlbnRMaXN0ZW5lcnMgfHwgZW1wdHlPYmplY3QsIGZ1bmN0aW9uICgpIHtcbiAgICAgICFpc1VwZGF0aW5nQ2hpbGRDb21wb25lbnQgJiYgd2FybihcIiRsaXN0ZW5lcnMgaXMgcmVhZG9ubHkuXCIsIHZtKTtcbiAgICB9LCB0cnVlKTtcbiAgfSBlbHNlIHtcbiAgICBkZWZpbmVSZWFjdGl2ZSQkMSh2bSwgJyRhdHRycycsIHBhcmVudERhdGEgJiYgcGFyZW50RGF0YS5hdHRycyB8fCBlbXB0eU9iamVjdCwgbnVsbCwgdHJ1ZSk7XG4gICAgZGVmaW5lUmVhY3RpdmUkJDEodm0sICckbGlzdGVuZXJzJywgb3B0aW9ucy5fcGFyZW50TGlzdGVuZXJzIHx8IGVtcHR5T2JqZWN0LCBudWxsLCB0cnVlKTtcbiAgfVxufVxuXG52YXIgY3VycmVudFJlbmRlcmluZ0luc3RhbmNlID0gbnVsbDtcblxuZnVuY3Rpb24gcmVuZGVyTWl4aW4gKFZ1ZSkge1xuICAvLyBpbnN0YWxsIHJ1bnRpbWUgY29udmVuaWVuY2UgaGVscGVyc1xuICBpbnN0YWxsUmVuZGVySGVscGVycyhWdWUucHJvdG90eXBlKTtcblxuICBWdWUucHJvdG90eXBlLiRuZXh0VGljayA9IGZ1bmN0aW9uIChmbikge1xuICAgIHJldHVybiBuZXh0VGljayhmbiwgdGhpcylcbiAgfTtcblxuICBWdWUucHJvdG90eXBlLl9yZW5kZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHZtID0gdGhpcztcbiAgICB2YXIgcmVmID0gdm0uJG9wdGlvbnM7XG4gICAgdmFyIHJlbmRlciA9IHJlZi5yZW5kZXI7XG4gICAgdmFyIF9wYXJlbnRWbm9kZSA9IHJlZi5fcGFyZW50Vm5vZGU7XG5cbiAgICBpZiAoX3BhcmVudFZub2RlKSB7XG4gICAgICB2bS4kc2NvcGVkU2xvdHMgPSBub3JtYWxpemVTY29wZWRTbG90cyhcbiAgICAgICAgX3BhcmVudFZub2RlLmRhdGEuc2NvcGVkU2xvdHMsXG4gICAgICAgIHZtLiRzbG90cyxcbiAgICAgICAgdm0uJHNjb3BlZFNsb3RzXG4gICAgICApO1xuICAgIH1cblxuICAgIC8vIHNldCBwYXJlbnQgdm5vZGUuIHRoaXMgYWxsb3dzIHJlbmRlciBmdW5jdGlvbnMgdG8gaGF2ZSBhY2Nlc3NcbiAgICAvLyB0byB0aGUgZGF0YSBvbiB0aGUgcGxhY2Vob2xkZXIgbm9kZS5cbiAgICB2bS4kdm5vZGUgPSBfcGFyZW50Vm5vZGU7XG4gICAgLy8gcmVuZGVyIHNlbGZcbiAgICB2YXIgdm5vZGU7XG4gICAgdHJ5IHtcbiAgICAgIC8vIFRoZXJlJ3Mgbm8gbmVlZCB0byBtYWludGFpbiBhIHN0YWNrIGJlY2F1ZXMgYWxsIHJlbmRlciBmbnMgYXJlIGNhbGxlZFxuICAgICAgLy8gc2VwYXJhdGVseSBmcm9tIG9uZSBhbm90aGVyLiBOZXN0ZWQgY29tcG9uZW50J3MgcmVuZGVyIGZucyBhcmUgY2FsbGVkXG4gICAgICAvLyB3aGVuIHBhcmVudCBjb21wb25lbnQgaXMgcGF0Y2hlZC5cbiAgICAgIGN1cnJlbnRSZW5kZXJpbmdJbnN0YW5jZSA9IHZtO1xuICAgICAgdm5vZGUgPSByZW5kZXIuY2FsbCh2bS5fcmVuZGVyUHJveHksIHZtLiRjcmVhdGVFbGVtZW50KTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICBoYW5kbGVFcnJvcihlLCB2bSwgXCJyZW5kZXJcIik7XG4gICAgICAvLyByZXR1cm4gZXJyb3IgcmVuZGVyIHJlc3VsdCxcbiAgICAgIC8vIG9yIHByZXZpb3VzIHZub2RlIHRvIHByZXZlbnQgcmVuZGVyIGVycm9yIGNhdXNpbmcgYmxhbmsgY29tcG9uZW50XG4gICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgdm0uJG9wdGlvbnMucmVuZGVyRXJyb3IpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICB2bm9kZSA9IHZtLiRvcHRpb25zLnJlbmRlckVycm9yLmNhbGwodm0uX3JlbmRlclByb3h5LCB2bS4kY3JlYXRlRWxlbWVudCwgZSk7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICBoYW5kbGVFcnJvcihlLCB2bSwgXCJyZW5kZXJFcnJvclwiKTtcbiAgICAgICAgICB2bm9kZSA9IHZtLl92bm9kZTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdm5vZGUgPSB2bS5fdm5vZGU7XG4gICAgICB9XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIGN1cnJlbnRSZW5kZXJpbmdJbnN0YW5jZSA9IG51bGw7XG4gICAgfVxuICAgIC8vIGlmIHRoZSByZXR1cm5lZCBhcnJheSBjb250YWlucyBvbmx5IGEgc2luZ2xlIG5vZGUsIGFsbG93IGl0XG4gICAgaWYgKEFycmF5LmlzQXJyYXkodm5vZGUpICYmIHZub2RlLmxlbmd0aCA9PT0gMSkge1xuICAgICAgdm5vZGUgPSB2bm9kZVswXTtcbiAgICB9XG4gICAgLy8gcmV0dXJuIGVtcHR5IHZub2RlIGluIGNhc2UgdGhlIHJlbmRlciBmdW5jdGlvbiBlcnJvcmVkIG91dFxuICAgIGlmICghKHZub2RlIGluc3RhbmNlb2YgVk5vZGUpKSB7XG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiBBcnJheS5pc0FycmF5KHZub2RlKSkge1xuICAgICAgICB3YXJuKFxuICAgICAgICAgICdNdWx0aXBsZSByb290IG5vZGVzIHJldHVybmVkIGZyb20gcmVuZGVyIGZ1bmN0aW9uLiBSZW5kZXIgZnVuY3Rpb24gJyArXG4gICAgICAgICAgJ3Nob3VsZCByZXR1cm4gYSBzaW5nbGUgcm9vdCBub2RlLicsXG4gICAgICAgICAgdm1cbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIHZub2RlID0gY3JlYXRlRW1wdHlWTm9kZSgpO1xuICAgIH1cbiAgICAvLyBzZXQgcGFyZW50XG4gICAgdm5vZGUucGFyZW50ID0gX3BhcmVudFZub2RlO1xuICAgIHJldHVybiB2bm9kZVxuICB9O1xufVxuXG4vKiAgKi9cblxuZnVuY3Rpb24gZW5zdXJlQ3RvciAoY29tcCwgYmFzZSkge1xuICBpZiAoXG4gICAgY29tcC5fX2VzTW9kdWxlIHx8XG4gICAgKGhhc1N5bWJvbCAmJiBjb21wW1N5bWJvbC50b1N0cmluZ1RhZ10gPT09ICdNb2R1bGUnKVxuICApIHtcbiAgICBjb21wID0gY29tcC5kZWZhdWx0O1xuICB9XG4gIHJldHVybiBpc09iamVjdChjb21wKVxuICAgID8gYmFzZS5leHRlbmQoY29tcClcbiAgICA6IGNvbXBcbn1cblxuZnVuY3Rpb24gY3JlYXRlQXN5bmNQbGFjZWhvbGRlciAoXG4gIGZhY3RvcnksXG4gIGRhdGEsXG4gIGNvbnRleHQsXG4gIGNoaWxkcmVuLFxuICB0YWdcbikge1xuICB2YXIgbm9kZSA9IGNyZWF0ZUVtcHR5Vk5vZGUoKTtcbiAgbm9kZS5hc3luY0ZhY3RvcnkgPSBmYWN0b3J5O1xuICBub2RlLmFzeW5jTWV0YSA9IHsgZGF0YTogZGF0YSwgY29udGV4dDogY29udGV4dCwgY2hpbGRyZW46IGNoaWxkcmVuLCB0YWc6IHRhZyB9O1xuICByZXR1cm4gbm9kZVxufVxuXG5mdW5jdGlvbiByZXNvbHZlQXN5bmNDb21wb25lbnQgKFxuICBmYWN0b3J5LFxuICBiYXNlQ3RvclxuKSB7XG4gIGlmIChpc1RydWUoZmFjdG9yeS5lcnJvcikgJiYgaXNEZWYoZmFjdG9yeS5lcnJvckNvbXApKSB7XG4gICAgcmV0dXJuIGZhY3RvcnkuZXJyb3JDb21wXG4gIH1cblxuICBpZiAoaXNEZWYoZmFjdG9yeS5yZXNvbHZlZCkpIHtcbiAgICByZXR1cm4gZmFjdG9yeS5yZXNvbHZlZFxuICB9XG5cbiAgdmFyIG93bmVyID0gY3VycmVudFJlbmRlcmluZ0luc3RhbmNlO1xuICBpZiAob3duZXIgJiYgaXNEZWYoZmFjdG9yeS5vd25lcnMpICYmIGZhY3Rvcnkub3duZXJzLmluZGV4T2Yob3duZXIpID09PSAtMSkge1xuICAgIC8vIGFscmVhZHkgcGVuZGluZ1xuICAgIGZhY3Rvcnkub3duZXJzLnB1c2gob3duZXIpO1xuICB9XG5cbiAgaWYgKGlzVHJ1ZShmYWN0b3J5LmxvYWRpbmcpICYmIGlzRGVmKGZhY3RvcnkubG9hZGluZ0NvbXApKSB7XG4gICAgcmV0dXJuIGZhY3RvcnkubG9hZGluZ0NvbXBcbiAgfVxuXG4gIGlmIChvd25lciAmJiAhaXNEZWYoZmFjdG9yeS5vd25lcnMpKSB7XG4gICAgdmFyIG93bmVycyA9IGZhY3Rvcnkub3duZXJzID0gW293bmVyXTtcbiAgICB2YXIgc3luYyA9IHRydWU7XG4gICAgdmFyIHRpbWVyTG9hZGluZyA9IG51bGw7XG4gICAgdmFyIHRpbWVyVGltZW91dCA9IG51bGxcblxuICAgIDsob3duZXIpLiRvbignaG9vazpkZXN0cm95ZWQnLCBmdW5jdGlvbiAoKSB7IHJldHVybiByZW1vdmUob3duZXJzLCBvd25lcik7IH0pO1xuXG4gICAgdmFyIGZvcmNlUmVuZGVyID0gZnVuY3Rpb24gKHJlbmRlckNvbXBsZXRlZCkge1xuICAgICAgZm9yICh2YXIgaSA9IDAsIGwgPSBvd25lcnMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgIChvd25lcnNbaV0pLiRmb3JjZVVwZGF0ZSgpO1xuICAgICAgfVxuXG4gICAgICBpZiAocmVuZGVyQ29tcGxldGVkKSB7XG4gICAgICAgIG93bmVycy5sZW5ndGggPSAwO1xuICAgICAgICBpZiAodGltZXJMb2FkaW5nICE9PSBudWxsKSB7XG4gICAgICAgICAgY2xlYXJUaW1lb3V0KHRpbWVyTG9hZGluZyk7XG4gICAgICAgICAgdGltZXJMb2FkaW5nID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGltZXJUaW1lb3V0ICE9PSBudWxsKSB7XG4gICAgICAgICAgY2xlYXJUaW1lb3V0KHRpbWVyVGltZW91dCk7XG4gICAgICAgICAgdGltZXJUaW1lb3V0ID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG5cbiAgICB2YXIgcmVzb2x2ZSA9IG9uY2UoZnVuY3Rpb24gKHJlcykge1xuICAgICAgLy8gY2FjaGUgcmVzb2x2ZWRcbiAgICAgIGZhY3RvcnkucmVzb2x2ZWQgPSBlbnN1cmVDdG9yKHJlcywgYmFzZUN0b3IpO1xuICAgICAgLy8gaW52b2tlIGNhbGxiYWNrcyBvbmx5IGlmIHRoaXMgaXMgbm90IGEgc3luY2hyb25vdXMgcmVzb2x2ZVxuICAgICAgLy8gKGFzeW5jIHJlc29sdmVzIGFyZSBzaGltbWVkIGFzIHN5bmNocm9ub3VzIGR1cmluZyBTU1IpXG4gICAgICBpZiAoIXN5bmMpIHtcbiAgICAgICAgZm9yY2VSZW5kZXIodHJ1ZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBvd25lcnMubGVuZ3RoID0gMDtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIHZhciByZWplY3QgPSBvbmNlKGZ1bmN0aW9uIChyZWFzb24pIHtcbiAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgd2FybihcbiAgICAgICAgXCJGYWlsZWQgdG8gcmVzb2x2ZSBhc3luYyBjb21wb25lbnQ6IFwiICsgKFN0cmluZyhmYWN0b3J5KSkgK1xuICAgICAgICAocmVhc29uID8gKFwiXFxuUmVhc29uOiBcIiArIHJlYXNvbikgOiAnJylcbiAgICAgICk7XG4gICAgICBpZiAoaXNEZWYoZmFjdG9yeS5lcnJvckNvbXApKSB7XG4gICAgICAgIGZhY3RvcnkuZXJyb3IgPSB0cnVlO1xuICAgICAgICBmb3JjZVJlbmRlcih0cnVlKTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIHZhciByZXMgPSBmYWN0b3J5KHJlc29sdmUsIHJlamVjdCk7XG5cbiAgICBpZiAoaXNPYmplY3QocmVzKSkge1xuICAgICAgaWYgKGlzUHJvbWlzZShyZXMpKSB7XG4gICAgICAgIC8vICgpID0+IFByb21pc2VcbiAgICAgICAgaWYgKGlzVW5kZWYoZmFjdG9yeS5yZXNvbHZlZCkpIHtcbiAgICAgICAgICByZXMudGhlbihyZXNvbHZlLCByZWplY3QpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKGlzUHJvbWlzZShyZXMuY29tcG9uZW50KSkge1xuICAgICAgICByZXMuY29tcG9uZW50LnRoZW4ocmVzb2x2ZSwgcmVqZWN0KTtcblxuICAgICAgICBpZiAoaXNEZWYocmVzLmVycm9yKSkge1xuICAgICAgICAgIGZhY3RvcnkuZXJyb3JDb21wID0gZW5zdXJlQ3RvcihyZXMuZXJyb3IsIGJhc2VDdG9yKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChpc0RlZihyZXMubG9hZGluZykpIHtcbiAgICAgICAgICBmYWN0b3J5LmxvYWRpbmdDb21wID0gZW5zdXJlQ3RvcihyZXMubG9hZGluZywgYmFzZUN0b3IpO1xuICAgICAgICAgIGlmIChyZXMuZGVsYXkgPT09IDApIHtcbiAgICAgICAgICAgIGZhY3RvcnkubG9hZGluZyA9IHRydWU7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRpbWVyTG9hZGluZyA9IHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICB0aW1lckxvYWRpbmcgPSBudWxsO1xuICAgICAgICAgICAgICBpZiAoaXNVbmRlZihmYWN0b3J5LnJlc29sdmVkKSAmJiBpc1VuZGVmKGZhY3RvcnkuZXJyb3IpKSB7XG4gICAgICAgICAgICAgICAgZmFjdG9yeS5sb2FkaW5nID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBmb3JjZVJlbmRlcihmYWxzZSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIHJlcy5kZWxheSB8fCAyMDApO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChpc0RlZihyZXMudGltZW91dCkpIHtcbiAgICAgICAgICB0aW1lclRpbWVvdXQgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHRpbWVyVGltZW91dCA9IG51bGw7XG4gICAgICAgICAgICBpZiAoaXNVbmRlZihmYWN0b3J5LnJlc29sdmVkKSkge1xuICAgICAgICAgICAgICByZWplY3QoXG4gICAgICAgICAgICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJ1xuICAgICAgICAgICAgICAgICAgPyAoXCJ0aW1lb3V0IChcIiArIChyZXMudGltZW91dCkgKyBcIm1zKVwiKVxuICAgICAgICAgICAgICAgICAgOiBudWxsXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSwgcmVzLnRpbWVvdXQpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgc3luYyA9IGZhbHNlO1xuICAgIC8vIHJldHVybiBpbiBjYXNlIHJlc29sdmVkIHN5bmNocm9ub3VzbHlcbiAgICByZXR1cm4gZmFjdG9yeS5sb2FkaW5nXG4gICAgICA/IGZhY3RvcnkubG9hZGluZ0NvbXBcbiAgICAgIDogZmFjdG9yeS5yZXNvbHZlZFxuICB9XG59XG5cbi8qICAqL1xuXG5mdW5jdGlvbiBpc0FzeW5jUGxhY2Vob2xkZXIgKG5vZGUpIHtcbiAgcmV0dXJuIG5vZGUuaXNDb21tZW50ICYmIG5vZGUuYXN5bmNGYWN0b3J5XG59XG5cbi8qICAqL1xuXG5mdW5jdGlvbiBnZXRGaXJzdENvbXBvbmVudENoaWxkIChjaGlsZHJlbikge1xuICBpZiAoQXJyYXkuaXNBcnJheShjaGlsZHJlbikpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgYyA9IGNoaWxkcmVuW2ldO1xuICAgICAgaWYgKGlzRGVmKGMpICYmIChpc0RlZihjLmNvbXBvbmVudE9wdGlvbnMpIHx8IGlzQXN5bmNQbGFjZWhvbGRlcihjKSkpIHtcbiAgICAgICAgcmV0dXJuIGNcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuLyogICovXG5cbi8qICAqL1xuXG5mdW5jdGlvbiBpbml0RXZlbnRzICh2bSkge1xuICB2bS5fZXZlbnRzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgdm0uX2hhc0hvb2tFdmVudCA9IGZhbHNlO1xuICAvLyBpbml0IHBhcmVudCBhdHRhY2hlZCBldmVudHNcbiAgdmFyIGxpc3RlbmVycyA9IHZtLiRvcHRpb25zLl9wYXJlbnRMaXN0ZW5lcnM7XG4gIGlmIChsaXN0ZW5lcnMpIHtcbiAgICB1cGRhdGVDb21wb25lbnRMaXN0ZW5lcnModm0sIGxpc3RlbmVycyk7XG4gIH1cbn1cblxudmFyIHRhcmdldDtcblxuZnVuY3Rpb24gYWRkIChldmVudCwgZm4pIHtcbiAgdGFyZ2V0LiRvbihldmVudCwgZm4pO1xufVxuXG5mdW5jdGlvbiByZW1vdmUkMSAoZXZlbnQsIGZuKSB7XG4gIHRhcmdldC4kb2ZmKGV2ZW50LCBmbik7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZU9uY2VIYW5kbGVyIChldmVudCwgZm4pIHtcbiAgdmFyIF90YXJnZXQgPSB0YXJnZXQ7XG4gIHJldHVybiBmdW5jdGlvbiBvbmNlSGFuZGxlciAoKSB7XG4gICAgdmFyIHJlcyA9IGZuLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG4gICAgaWYgKHJlcyAhPT0gbnVsbCkge1xuICAgICAgX3RhcmdldC4kb2ZmKGV2ZW50LCBvbmNlSGFuZGxlcik7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIHVwZGF0ZUNvbXBvbmVudExpc3RlbmVycyAoXG4gIHZtLFxuICBsaXN0ZW5lcnMsXG4gIG9sZExpc3RlbmVyc1xuKSB7XG4gIHRhcmdldCA9IHZtO1xuICB1cGRhdGVMaXN0ZW5lcnMobGlzdGVuZXJzLCBvbGRMaXN0ZW5lcnMgfHwge30sIGFkZCwgcmVtb3ZlJDEsIGNyZWF0ZU9uY2VIYW5kbGVyLCB2bSk7XG4gIHRhcmdldCA9IHVuZGVmaW5lZDtcbn1cblxuZnVuY3Rpb24gZXZlbnRzTWl4aW4gKFZ1ZSkge1xuICB2YXIgaG9va1JFID0gL15ob29rOi87XG4gIFZ1ZS5wcm90b3R5cGUuJG9uID0gZnVuY3Rpb24gKGV2ZW50LCBmbikge1xuICAgIHZhciB2bSA9IHRoaXM7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkoZXZlbnQpKSB7XG4gICAgICBmb3IgKHZhciBpID0gMCwgbCA9IGV2ZW50Lmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICB2bS4kb24oZXZlbnRbaV0sIGZuKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgKHZtLl9ldmVudHNbZXZlbnRdIHx8ICh2bS5fZXZlbnRzW2V2ZW50XSA9IFtdKSkucHVzaChmbik7XG4gICAgICAvLyBvcHRpbWl6ZSBob29rOmV2ZW50IGNvc3QgYnkgdXNpbmcgYSBib29sZWFuIGZsYWcgbWFya2VkIGF0IHJlZ2lzdHJhdGlvblxuICAgICAgLy8gaW5zdGVhZCBvZiBhIGhhc2ggbG9va3VwXG4gICAgICBpZiAoaG9va1JFLnRlc3QoZXZlbnQpKSB7XG4gICAgICAgIHZtLl9oYXNIb29rRXZlbnQgPSB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdm1cbiAgfTtcblxuICBWdWUucHJvdG90eXBlLiRvbmNlID0gZnVuY3Rpb24gKGV2ZW50LCBmbikge1xuICAgIHZhciB2bSA9IHRoaXM7XG4gICAgZnVuY3Rpb24gb24gKCkge1xuICAgICAgdm0uJG9mZihldmVudCwgb24pO1xuICAgICAgZm4uYXBwbHkodm0sIGFyZ3VtZW50cyk7XG4gICAgfVxuICAgIG9uLmZuID0gZm47XG4gICAgdm0uJG9uKGV2ZW50LCBvbik7XG4gICAgcmV0dXJuIHZtXG4gIH07XG5cbiAgVnVlLnByb3RvdHlwZS4kb2ZmID0gZnVuY3Rpb24gKGV2ZW50LCBmbikge1xuICAgIHZhciB2bSA9IHRoaXM7XG4gICAgLy8gYWxsXG4gICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSB7XG4gICAgICB2bS5fZXZlbnRzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICAgIHJldHVybiB2bVxuICAgIH1cbiAgICAvLyBhcnJheSBvZiBldmVudHNcbiAgICBpZiAoQXJyYXkuaXNBcnJheShldmVudCkpIHtcbiAgICAgIGZvciAodmFyIGkkMSA9IDAsIGwgPSBldmVudC5sZW5ndGg7IGkkMSA8IGw7IGkkMSsrKSB7XG4gICAgICAgIHZtLiRvZmYoZXZlbnRbaSQxXSwgZm4pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHZtXG4gICAgfVxuICAgIC8vIHNwZWNpZmljIGV2ZW50XG4gICAgdmFyIGNicyA9IHZtLl9ldmVudHNbZXZlbnRdO1xuICAgIGlmICghY2JzKSB7XG4gICAgICByZXR1cm4gdm1cbiAgICB9XG4gICAgaWYgKCFmbikge1xuICAgICAgdm0uX2V2ZW50c1tldmVudF0gPSBudWxsO1xuICAgICAgcmV0dXJuIHZtXG4gICAgfVxuICAgIC8vIHNwZWNpZmljIGhhbmRsZXJcbiAgICB2YXIgY2I7XG4gICAgdmFyIGkgPSBjYnMubGVuZ3RoO1xuICAgIHdoaWxlIChpLS0pIHtcbiAgICAgIGNiID0gY2JzW2ldO1xuICAgICAgaWYgKGNiID09PSBmbiB8fCBjYi5mbiA9PT0gZm4pIHtcbiAgICAgICAgY2JzLnNwbGljZShpLCAxKTtcbiAgICAgICAgYnJlYWtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHZtXG4gIH07XG5cbiAgVnVlLnByb3RvdHlwZS4kZW1pdCA9IGZ1bmN0aW9uIChldmVudCkge1xuICAgIHZhciB2bSA9IHRoaXM7XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIHZhciBsb3dlckNhc2VFdmVudCA9IGV2ZW50LnRvTG93ZXJDYXNlKCk7XG4gICAgICBpZiAobG93ZXJDYXNlRXZlbnQgIT09IGV2ZW50ICYmIHZtLl9ldmVudHNbbG93ZXJDYXNlRXZlbnRdKSB7XG4gICAgICAgIHRpcChcbiAgICAgICAgICBcIkV2ZW50IFxcXCJcIiArIGxvd2VyQ2FzZUV2ZW50ICsgXCJcXFwiIGlzIGVtaXR0ZWQgaW4gY29tcG9uZW50IFwiICtcbiAgICAgICAgICAoZm9ybWF0Q29tcG9uZW50TmFtZSh2bSkpICsgXCIgYnV0IHRoZSBoYW5kbGVyIGlzIHJlZ2lzdGVyZWQgZm9yIFxcXCJcIiArIGV2ZW50ICsgXCJcXFwiLiBcIiArXG4gICAgICAgICAgXCJOb3RlIHRoYXQgSFRNTCBhdHRyaWJ1dGVzIGFyZSBjYXNlLWluc2Vuc2l0aXZlIGFuZCB5b3UgY2Fubm90IHVzZSBcIiArXG4gICAgICAgICAgXCJ2LW9uIHRvIGxpc3RlbiB0byBjYW1lbENhc2UgZXZlbnRzIHdoZW4gdXNpbmcgaW4tRE9NIHRlbXBsYXRlcy4gXCIgK1xuICAgICAgICAgIFwiWW91IHNob3VsZCBwcm9iYWJseSB1c2UgXFxcIlwiICsgKGh5cGhlbmF0ZShldmVudCkpICsgXCJcXFwiIGluc3RlYWQgb2YgXFxcIlwiICsgZXZlbnQgKyBcIlxcXCIuXCJcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9XG4gICAgdmFyIGNicyA9IHZtLl9ldmVudHNbZXZlbnRdO1xuICAgIGlmIChjYnMpIHtcbiAgICAgIGNicyA9IGNicy5sZW5ndGggPiAxID8gdG9BcnJheShjYnMpIDogY2JzO1xuICAgICAgdmFyIGFyZ3MgPSB0b0FycmF5KGFyZ3VtZW50cywgMSk7XG4gICAgICB2YXIgaW5mbyA9IFwiZXZlbnQgaGFuZGxlciBmb3IgXFxcIlwiICsgZXZlbnQgKyBcIlxcXCJcIjtcbiAgICAgIGZvciAodmFyIGkgPSAwLCBsID0gY2JzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICBpbnZva2VXaXRoRXJyb3JIYW5kbGluZyhjYnNbaV0sIHZtLCBhcmdzLCB2bSwgaW5mbyk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB2bVxuICB9O1xufVxuXG4vKiAgKi9cblxudmFyIGFjdGl2ZUluc3RhbmNlID0gbnVsbDtcbnZhciBpc1VwZGF0aW5nQ2hpbGRDb21wb25lbnQgPSBmYWxzZTtcblxuZnVuY3Rpb24gc2V0QWN0aXZlSW5zdGFuY2Uodm0pIHtcbiAgdmFyIHByZXZBY3RpdmVJbnN0YW5jZSA9IGFjdGl2ZUluc3RhbmNlO1xuICBhY3RpdmVJbnN0YW5jZSA9IHZtO1xuICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgIGFjdGl2ZUluc3RhbmNlID0gcHJldkFjdGl2ZUluc3RhbmNlO1xuICB9XG59XG5cbmZ1bmN0aW9uIGluaXRMaWZlY3ljbGUgKHZtKSB7XG4gIHZhciBvcHRpb25zID0gdm0uJG9wdGlvbnM7XG5cbiAgLy8gbG9jYXRlIGZpcnN0IG5vbi1hYnN0cmFjdCBwYXJlbnRcbiAgdmFyIHBhcmVudCA9IG9wdGlvbnMucGFyZW50O1xuICBpZiAocGFyZW50ICYmICFvcHRpb25zLmFic3RyYWN0KSB7XG4gICAgd2hpbGUgKHBhcmVudC4kb3B0aW9ucy5hYnN0cmFjdCAmJiBwYXJlbnQuJHBhcmVudCkge1xuICAgICAgcGFyZW50ID0gcGFyZW50LiRwYXJlbnQ7XG4gICAgfVxuICAgIHBhcmVudC4kY2hpbGRyZW4ucHVzaCh2bSk7XG4gIH1cblxuICB2bS4kcGFyZW50ID0gcGFyZW50O1xuICB2bS4kcm9vdCA9IHBhcmVudCA/IHBhcmVudC4kcm9vdCA6IHZtO1xuXG4gIHZtLiRjaGlsZHJlbiA9IFtdO1xuICB2bS4kcmVmcyA9IHt9O1xuXG4gIHZtLl93YXRjaGVyID0gbnVsbDtcbiAgdm0uX2luYWN0aXZlID0gbnVsbDtcbiAgdm0uX2RpcmVjdEluYWN0aXZlID0gZmFsc2U7XG4gIHZtLl9pc01vdW50ZWQgPSBmYWxzZTtcbiAgdm0uX2lzRGVzdHJveWVkID0gZmFsc2U7XG4gIHZtLl9pc0JlaW5nRGVzdHJveWVkID0gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIGxpZmVjeWNsZU1peGluIChWdWUpIHtcbiAgVnVlLnByb3RvdHlwZS5fdXBkYXRlID0gZnVuY3Rpb24gKHZub2RlLCBoeWRyYXRpbmcpIHtcbiAgICB2YXIgdm0gPSB0aGlzO1xuICAgIHZhciBwcmV2RWwgPSB2bS4kZWw7XG4gICAgdmFyIHByZXZWbm9kZSA9IHZtLl92bm9kZTtcbiAgICB2YXIgcmVzdG9yZUFjdGl2ZUluc3RhbmNlID0gc2V0QWN0aXZlSW5zdGFuY2Uodm0pO1xuICAgIHZtLl92bm9kZSA9IHZub2RlO1xuICAgIC8vIFZ1ZS5wcm90b3R5cGUuX19wYXRjaF9fIGlzIGluamVjdGVkIGluIGVudHJ5IHBvaW50c1xuICAgIC8vIGJhc2VkIG9uIHRoZSByZW5kZXJpbmcgYmFja2VuZCB1c2VkLlxuICAgIGlmICghcHJldlZub2RlKSB7XG4gICAgICAvLyBpbml0aWFsIHJlbmRlclxuICAgICAgdm0uJGVsID0gdm0uX19wYXRjaF9fKHZtLiRlbCwgdm5vZGUsIGh5ZHJhdGluZywgZmFsc2UgLyogcmVtb3ZlT25seSAqLyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIHVwZGF0ZXNcbiAgICAgIHZtLiRlbCA9IHZtLl9fcGF0Y2hfXyhwcmV2Vm5vZGUsIHZub2RlKTtcbiAgICB9XG4gICAgcmVzdG9yZUFjdGl2ZUluc3RhbmNlKCk7XG4gICAgLy8gdXBkYXRlIF9fdnVlX18gcmVmZXJlbmNlXG4gICAgaWYgKHByZXZFbCkge1xuICAgICAgcHJldkVsLl9fdnVlX18gPSBudWxsO1xuICAgIH1cbiAgICBpZiAodm0uJGVsKSB7XG4gICAgICB2bS4kZWwuX192dWVfXyA9IHZtO1xuICAgIH1cbiAgICAvLyBpZiBwYXJlbnQgaXMgYW4gSE9DLCB1cGRhdGUgaXRzICRlbCBhcyB3ZWxsXG4gICAgaWYgKHZtLiR2bm9kZSAmJiB2bS4kcGFyZW50ICYmIHZtLiR2bm9kZSA9PT0gdm0uJHBhcmVudC5fdm5vZGUpIHtcbiAgICAgIHZtLiRwYXJlbnQuJGVsID0gdm0uJGVsO1xuICAgIH1cbiAgICAvLyB1cGRhdGVkIGhvb2sgaXMgY2FsbGVkIGJ5IHRoZSBzY2hlZHVsZXIgdG8gZW5zdXJlIHRoYXQgY2hpbGRyZW4gYXJlXG4gICAgLy8gdXBkYXRlZCBpbiBhIHBhcmVudCdzIHVwZGF0ZWQgaG9vay5cbiAgfTtcblxuICBWdWUucHJvdG90eXBlLiRmb3JjZVVwZGF0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgdm0gPSB0aGlzO1xuICAgIGlmICh2bS5fd2F0Y2hlcikge1xuICAgICAgdm0uX3dhdGNoZXIudXBkYXRlKCk7XG4gICAgfVxuICB9O1xuXG4gIFZ1ZS5wcm90b3R5cGUuJGRlc3Ryb3kgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHZtID0gdGhpcztcbiAgICBpZiAodm0uX2lzQmVpbmdEZXN0cm95ZWQpIHtcbiAgICAgIHJldHVyblxuICAgIH1cbiAgICBjYWxsSG9vayh2bSwgJ2JlZm9yZURlc3Ryb3knKTtcbiAgICB2bS5faXNCZWluZ0Rlc3Ryb3llZCA9IHRydWU7XG4gICAgLy8gcmVtb3ZlIHNlbGYgZnJvbSBwYXJlbnRcbiAgICB2YXIgcGFyZW50ID0gdm0uJHBhcmVudDtcbiAgICBpZiAocGFyZW50ICYmICFwYXJlbnQuX2lzQmVpbmdEZXN0cm95ZWQgJiYgIXZtLiRvcHRpb25zLmFic3RyYWN0KSB7XG4gICAgICByZW1vdmUocGFyZW50LiRjaGlsZHJlbiwgdm0pO1xuICAgIH1cbiAgICAvLyB0ZWFyZG93biB3YXRjaGVyc1xuICAgIGlmICh2bS5fd2F0Y2hlcikge1xuICAgICAgdm0uX3dhdGNoZXIudGVhcmRvd24oKTtcbiAgICB9XG4gICAgdmFyIGkgPSB2bS5fd2F0Y2hlcnMubGVuZ3RoO1xuICAgIHdoaWxlIChpLS0pIHtcbiAgICAgIHZtLl93YXRjaGVyc1tpXS50ZWFyZG93bigpO1xuICAgIH1cbiAgICAvLyByZW1vdmUgcmVmZXJlbmNlIGZyb20gZGF0YSBvYlxuICAgIC8vIGZyb3plbiBvYmplY3QgbWF5IG5vdCBoYXZlIG9ic2VydmVyLlxuICAgIGlmICh2bS5fZGF0YS5fX29iX18pIHtcbiAgICAgIHZtLl9kYXRhLl9fb2JfXy52bUNvdW50LS07XG4gICAgfVxuICAgIC8vIGNhbGwgdGhlIGxhc3QgaG9vay4uLlxuICAgIHZtLl9pc0Rlc3Ryb3llZCA9IHRydWU7XG4gICAgLy8gaW52b2tlIGRlc3Ryb3kgaG9va3Mgb24gY3VycmVudCByZW5kZXJlZCB0cmVlXG4gICAgdm0uX19wYXRjaF9fKHZtLl92bm9kZSwgbnVsbCk7XG4gICAgLy8gZmlyZSBkZXN0cm95ZWQgaG9va1xuICAgIGNhbGxIb29rKHZtLCAnZGVzdHJveWVkJyk7XG4gICAgLy8gdHVybiBvZmYgYWxsIGluc3RhbmNlIGxpc3RlbmVycy5cbiAgICB2bS4kb2ZmKCk7XG4gICAgLy8gcmVtb3ZlIF9fdnVlX18gcmVmZXJlbmNlXG4gICAgaWYgKHZtLiRlbCkge1xuICAgICAgdm0uJGVsLl9fdnVlX18gPSBudWxsO1xuICAgIH1cbiAgICAvLyByZWxlYXNlIGNpcmN1bGFyIHJlZmVyZW5jZSAoIzY3NTkpXG4gICAgaWYgKHZtLiR2bm9kZSkge1xuICAgICAgdm0uJHZub2RlLnBhcmVudCA9IG51bGw7XG4gICAgfVxuICB9O1xufVxuXG5mdW5jdGlvbiBtb3VudENvbXBvbmVudCAoXG4gIHZtLFxuICBlbCxcbiAgaHlkcmF0aW5nXG4pIHtcbiAgdm0uJGVsID0gZWw7XG4gIGlmICghdm0uJG9wdGlvbnMucmVuZGVyKSB7XG4gICAgdm0uJG9wdGlvbnMucmVuZGVyID0gY3JlYXRlRW1wdHlWTm9kZTtcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgICBpZiAoKHZtLiRvcHRpb25zLnRlbXBsYXRlICYmIHZtLiRvcHRpb25zLnRlbXBsYXRlLmNoYXJBdCgwKSAhPT0gJyMnKSB8fFxuICAgICAgICB2bS4kb3B0aW9ucy5lbCB8fCBlbCkge1xuICAgICAgICB3YXJuKFxuICAgICAgICAgICdZb3UgYXJlIHVzaW5nIHRoZSBydW50aW1lLW9ubHkgYnVpbGQgb2YgVnVlIHdoZXJlIHRoZSB0ZW1wbGF0ZSAnICtcbiAgICAgICAgICAnY29tcGlsZXIgaXMgbm90IGF2YWlsYWJsZS4gRWl0aGVyIHByZS1jb21waWxlIHRoZSB0ZW1wbGF0ZXMgaW50byAnICtcbiAgICAgICAgICAncmVuZGVyIGZ1bmN0aW9ucywgb3IgdXNlIHRoZSBjb21waWxlci1pbmNsdWRlZCBidWlsZC4nLFxuICAgICAgICAgIHZtXG4gICAgICAgICk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB3YXJuKFxuICAgICAgICAgICdGYWlsZWQgdG8gbW91bnQgY29tcG9uZW50OiB0ZW1wbGF0ZSBvciByZW5kZXIgZnVuY3Rpb24gbm90IGRlZmluZWQuJyxcbiAgICAgICAgICB2bVxuICAgICAgICApO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBjYWxsSG9vayh2bSwgJ2JlZm9yZU1vdW50Jyk7XG5cbiAgdmFyIHVwZGF0ZUNvbXBvbmVudDtcbiAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIGNvbmZpZy5wZXJmb3JtYW5jZSAmJiBtYXJrKSB7XG4gICAgdXBkYXRlQ29tcG9uZW50ID0gZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIG5hbWUgPSB2bS5fbmFtZTtcbiAgICAgIHZhciBpZCA9IHZtLl91aWQ7XG4gICAgICB2YXIgc3RhcnRUYWcgPSBcInZ1ZS1wZXJmLXN0YXJ0OlwiICsgaWQ7XG4gICAgICB2YXIgZW5kVGFnID0gXCJ2dWUtcGVyZi1lbmQ6XCIgKyBpZDtcblxuICAgICAgbWFyayhzdGFydFRhZyk7XG4gICAgICB2YXIgdm5vZGUgPSB2bS5fcmVuZGVyKCk7XG4gICAgICBtYXJrKGVuZFRhZyk7XG4gICAgICBtZWFzdXJlKChcInZ1ZSBcIiArIG5hbWUgKyBcIiByZW5kZXJcIiksIHN0YXJ0VGFnLCBlbmRUYWcpO1xuXG4gICAgICBtYXJrKHN0YXJ0VGFnKTtcbiAgICAgIHZtLl91cGRhdGUodm5vZGUsIGh5ZHJhdGluZyk7XG4gICAgICBtYXJrKGVuZFRhZyk7XG4gICAgICBtZWFzdXJlKChcInZ1ZSBcIiArIG5hbWUgKyBcIiBwYXRjaFwiKSwgc3RhcnRUYWcsIGVuZFRhZyk7XG4gICAgfTtcbiAgfSBlbHNlIHtcbiAgICB1cGRhdGVDb21wb25lbnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICB2bS5fdXBkYXRlKHZtLl9yZW5kZXIoKSwgaHlkcmF0aW5nKTtcbiAgICB9O1xuICB9XG5cbiAgLy8gd2Ugc2V0IHRoaXMgdG8gdm0uX3dhdGNoZXIgaW5zaWRlIHRoZSB3YXRjaGVyJ3MgY29uc3RydWN0b3JcbiAgLy8gc2luY2UgdGhlIHdhdGNoZXIncyBpbml0aWFsIHBhdGNoIG1heSBjYWxsICRmb3JjZVVwZGF0ZSAoZS5nLiBpbnNpZGUgY2hpbGRcbiAgLy8gY29tcG9uZW50J3MgbW91bnRlZCBob29rKSwgd2hpY2ggcmVsaWVzIG9uIHZtLl93YXRjaGVyIGJlaW5nIGFscmVhZHkgZGVmaW5lZFxuICBuZXcgV2F0Y2hlcih2bSwgdXBkYXRlQ29tcG9uZW50LCBub29wLCB7XG4gICAgYmVmb3JlOiBmdW5jdGlvbiBiZWZvcmUgKCkge1xuICAgICAgaWYgKHZtLl9pc01vdW50ZWQgJiYgIXZtLl9pc0Rlc3Ryb3llZCkge1xuICAgICAgICBjYWxsSG9vayh2bSwgJ2JlZm9yZVVwZGF0ZScpO1xuICAgICAgfVxuICAgIH1cbiAgfSwgdHJ1ZSAvKiBpc1JlbmRlcldhdGNoZXIgKi8pO1xuICBoeWRyYXRpbmcgPSBmYWxzZTtcblxuICAvLyBtYW51YWxseSBtb3VudGVkIGluc3RhbmNlLCBjYWxsIG1vdW50ZWQgb24gc2VsZlxuICAvLyBtb3VudGVkIGlzIGNhbGxlZCBmb3IgcmVuZGVyLWNyZWF0ZWQgY2hpbGQgY29tcG9uZW50cyBpbiBpdHMgaW5zZXJ0ZWQgaG9va1xuICBpZiAodm0uJHZub2RlID09IG51bGwpIHtcbiAgICB2bS5faXNNb3VudGVkID0gdHJ1ZTtcbiAgICBjYWxsSG9vayh2bSwgJ21vdW50ZWQnKTtcbiAgfVxuICByZXR1cm4gdm1cbn1cblxuZnVuY3Rpb24gdXBkYXRlQ2hpbGRDb21wb25lbnQgKFxuICB2bSxcbiAgcHJvcHNEYXRhLFxuICBsaXN0ZW5lcnMsXG4gIHBhcmVudFZub2RlLFxuICByZW5kZXJDaGlsZHJlblxuKSB7XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgaXNVcGRhdGluZ0NoaWxkQ29tcG9uZW50ID0gdHJ1ZTtcbiAgfVxuXG4gIC8vIGRldGVybWluZSB3aGV0aGVyIGNvbXBvbmVudCBoYXMgc2xvdCBjaGlsZHJlblxuICAvLyB3ZSBuZWVkIHRvIGRvIHRoaXMgYmVmb3JlIG92ZXJ3cml0aW5nICRvcHRpb25zLl9yZW5kZXJDaGlsZHJlbi5cblxuICAvLyBjaGVjayBpZiB0aGVyZSBhcmUgZHluYW1pYyBzY29wZWRTbG90cyAoaGFuZC13cml0dGVuIG9yIGNvbXBpbGVkIGJ1dCB3aXRoXG4gIC8vIGR5bmFtaWMgc2xvdCBuYW1lcykuIFN0YXRpYyBzY29wZWQgc2xvdHMgY29tcGlsZWQgZnJvbSB0ZW1wbGF0ZSBoYXMgdGhlXG4gIC8vIFwiJHN0YWJsZVwiIG1hcmtlci5cbiAgdmFyIG5ld1Njb3BlZFNsb3RzID0gcGFyZW50Vm5vZGUuZGF0YS5zY29wZWRTbG90cztcbiAgdmFyIG9sZFNjb3BlZFNsb3RzID0gdm0uJHNjb3BlZFNsb3RzO1xuICB2YXIgaGFzRHluYW1pY1Njb3BlZFNsb3QgPSAhIShcbiAgICAobmV3U2NvcGVkU2xvdHMgJiYgIW5ld1Njb3BlZFNsb3RzLiRzdGFibGUpIHx8XG4gICAgKG9sZFNjb3BlZFNsb3RzICE9PSBlbXB0eU9iamVjdCAmJiAhb2xkU2NvcGVkU2xvdHMuJHN0YWJsZSkgfHxcbiAgICAobmV3U2NvcGVkU2xvdHMgJiYgdm0uJHNjb3BlZFNsb3RzLiRrZXkgIT09IG5ld1Njb3BlZFNsb3RzLiRrZXkpXG4gICk7XG5cbiAgLy8gQW55IHN0YXRpYyBzbG90IGNoaWxkcmVuIGZyb20gdGhlIHBhcmVudCBtYXkgaGF2ZSBjaGFuZ2VkIGR1cmluZyBwYXJlbnQnc1xuICAvLyB1cGRhdGUuIER5bmFtaWMgc2NvcGVkIHNsb3RzIG1heSBhbHNvIGhhdmUgY2hhbmdlZC4gSW4gc3VjaCBjYXNlcywgYSBmb3JjZWRcbiAgLy8gdXBkYXRlIGlzIG5lY2Vzc2FyeSB0byBlbnN1cmUgY29ycmVjdG5lc3MuXG4gIHZhciBuZWVkc0ZvcmNlVXBkYXRlID0gISEoXG4gICAgcmVuZGVyQ2hpbGRyZW4gfHwgICAgICAgICAgICAgICAvLyBoYXMgbmV3IHN0YXRpYyBzbG90c1xuICAgIHZtLiRvcHRpb25zLl9yZW5kZXJDaGlsZHJlbiB8fCAgLy8gaGFzIG9sZCBzdGF0aWMgc2xvdHNcbiAgICBoYXNEeW5hbWljU2NvcGVkU2xvdFxuICApO1xuXG4gIHZtLiRvcHRpb25zLl9wYXJlbnRWbm9kZSA9IHBhcmVudFZub2RlO1xuICB2bS4kdm5vZGUgPSBwYXJlbnRWbm9kZTsgLy8gdXBkYXRlIHZtJ3MgcGxhY2Vob2xkZXIgbm9kZSB3aXRob3V0IHJlLXJlbmRlclxuXG4gIGlmICh2bS5fdm5vZGUpIHsgLy8gdXBkYXRlIGNoaWxkIHRyZWUncyBwYXJlbnRcbiAgICB2bS5fdm5vZGUucGFyZW50ID0gcGFyZW50Vm5vZGU7XG4gIH1cbiAgdm0uJG9wdGlvbnMuX3JlbmRlckNoaWxkcmVuID0gcmVuZGVyQ2hpbGRyZW47XG5cbiAgLy8gdXBkYXRlICRhdHRycyBhbmQgJGxpc3RlbmVycyBoYXNoXG4gIC8vIHRoZXNlIGFyZSBhbHNvIHJlYWN0aXZlIHNvIHRoZXkgbWF5IHRyaWdnZXIgY2hpbGQgdXBkYXRlIGlmIHRoZSBjaGlsZFxuICAvLyB1c2VkIHRoZW0gZHVyaW5nIHJlbmRlclxuICB2bS4kYXR0cnMgPSBwYXJlbnRWbm9kZS5kYXRhLmF0dHJzIHx8IGVtcHR5T2JqZWN0O1xuICB2bS4kbGlzdGVuZXJzID0gbGlzdGVuZXJzIHx8IGVtcHR5T2JqZWN0O1xuXG4gIC8vIHVwZGF0ZSBwcm9wc1xuICBpZiAocHJvcHNEYXRhICYmIHZtLiRvcHRpb25zLnByb3BzKSB7XG4gICAgdG9nZ2xlT2JzZXJ2aW5nKGZhbHNlKTtcbiAgICB2YXIgcHJvcHMgPSB2bS5fcHJvcHM7XG4gICAgdmFyIHByb3BLZXlzID0gdm0uJG9wdGlvbnMuX3Byb3BLZXlzIHx8IFtdO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcEtleXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBrZXkgPSBwcm9wS2V5c1tpXTtcbiAgICAgIHZhciBwcm9wT3B0aW9ucyA9IHZtLiRvcHRpb25zLnByb3BzOyAvLyB3dGYgZmxvdz9cbiAgICAgIHByb3BzW2tleV0gPSB2YWxpZGF0ZVByb3Aoa2V5LCBwcm9wT3B0aW9ucywgcHJvcHNEYXRhLCB2bSk7XG4gICAgfVxuICAgIHRvZ2dsZU9ic2VydmluZyh0cnVlKTtcbiAgICAvLyBrZWVwIGEgY29weSBvZiByYXcgcHJvcHNEYXRhXG4gICAgdm0uJG9wdGlvbnMucHJvcHNEYXRhID0gcHJvcHNEYXRhO1xuICB9XG5cbiAgLy8gdXBkYXRlIGxpc3RlbmVyc1xuICBsaXN0ZW5lcnMgPSBsaXN0ZW5lcnMgfHwgZW1wdHlPYmplY3Q7XG4gIHZhciBvbGRMaXN0ZW5lcnMgPSB2bS4kb3B0aW9ucy5fcGFyZW50TGlzdGVuZXJzO1xuICB2bS4kb3B0aW9ucy5fcGFyZW50TGlzdGVuZXJzID0gbGlzdGVuZXJzO1xuICB1cGRhdGVDb21wb25lbnRMaXN0ZW5lcnModm0sIGxpc3RlbmVycywgb2xkTGlzdGVuZXJzKTtcblxuICAvLyByZXNvbHZlIHNsb3RzICsgZm9yY2UgdXBkYXRlIGlmIGhhcyBjaGlsZHJlblxuICBpZiAobmVlZHNGb3JjZVVwZGF0ZSkge1xuICAgIHZtLiRzbG90cyA9IHJlc29sdmVTbG90cyhyZW5kZXJDaGlsZHJlbiwgcGFyZW50Vm5vZGUuY29udGV4dCk7XG4gICAgdm0uJGZvcmNlVXBkYXRlKCk7XG4gIH1cblxuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgIGlzVXBkYXRpbmdDaGlsZENvbXBvbmVudCA9IGZhbHNlO1xuICB9XG59XG5cbmZ1bmN0aW9uIGlzSW5JbmFjdGl2ZVRyZWUgKHZtKSB7XG4gIHdoaWxlICh2bSAmJiAodm0gPSB2bS4kcGFyZW50KSkge1xuICAgIGlmICh2bS5faW5hY3RpdmUpIHsgcmV0dXJuIHRydWUgfVxuICB9XG4gIHJldHVybiBmYWxzZVxufVxuXG5mdW5jdGlvbiBhY3RpdmF0ZUNoaWxkQ29tcG9uZW50ICh2bSwgZGlyZWN0KSB7XG4gIGlmIChkaXJlY3QpIHtcbiAgICB2bS5fZGlyZWN0SW5hY3RpdmUgPSBmYWxzZTtcbiAgICBpZiAoaXNJbkluYWN0aXZlVHJlZSh2bSkpIHtcbiAgICAgIHJldHVyblxuICAgIH1cbiAgfSBlbHNlIGlmICh2bS5fZGlyZWN0SW5hY3RpdmUpIHtcbiAgICByZXR1cm5cbiAgfVxuICBpZiAodm0uX2luYWN0aXZlIHx8IHZtLl9pbmFjdGl2ZSA9PT0gbnVsbCkge1xuICAgIHZtLl9pbmFjdGl2ZSA9IGZhbHNlO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdm0uJGNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICBhY3RpdmF0ZUNoaWxkQ29tcG9uZW50KHZtLiRjaGlsZHJlbltpXSk7XG4gICAgfVxuICAgIGNhbGxIb29rKHZtLCAnYWN0aXZhdGVkJyk7XG4gIH1cbn1cblxuZnVuY3Rpb24gZGVhY3RpdmF0ZUNoaWxkQ29tcG9uZW50ICh2bSwgZGlyZWN0KSB7XG4gIGlmIChkaXJlY3QpIHtcbiAgICB2bS5fZGlyZWN0SW5hY3RpdmUgPSB0cnVlO1xuICAgIGlmIChpc0luSW5hY3RpdmVUcmVlKHZtKSkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuICB9XG4gIGlmICghdm0uX2luYWN0aXZlKSB7XG4gICAgdm0uX2luYWN0aXZlID0gdHJ1ZTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHZtLiRjaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgZGVhY3RpdmF0ZUNoaWxkQ29tcG9uZW50KHZtLiRjaGlsZHJlbltpXSk7XG4gICAgfVxuICAgIGNhbGxIb29rKHZtLCAnZGVhY3RpdmF0ZWQnKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBjYWxsSG9vayAodm0sIGhvb2spIHtcbiAgLy8gIzc1NzMgZGlzYWJsZSBkZXAgY29sbGVjdGlvbiB3aGVuIGludm9raW5nIGxpZmVjeWNsZSBob29rc1xuICBwdXNoVGFyZ2V0KCk7XG4gIHZhciBoYW5kbGVycyA9IHZtLiRvcHRpb25zW2hvb2tdO1xuICB2YXIgaW5mbyA9IGhvb2sgKyBcIiBob29rXCI7XG4gIGlmIChoYW5kbGVycykge1xuICAgIGZvciAodmFyIGkgPSAwLCBqID0gaGFuZGxlcnMubGVuZ3RoOyBpIDwgajsgaSsrKSB7XG4gICAgICBpbnZva2VXaXRoRXJyb3JIYW5kbGluZyhoYW5kbGVyc1tpXSwgdm0sIG51bGwsIHZtLCBpbmZvKTtcbiAgICB9XG4gIH1cbiAgaWYgKHZtLl9oYXNIb29rRXZlbnQpIHtcbiAgICB2bS4kZW1pdCgnaG9vazonICsgaG9vayk7XG4gIH1cbiAgcG9wVGFyZ2V0KCk7XG59XG5cbi8qICAqL1xuXG52YXIgTUFYX1VQREFURV9DT1VOVCA9IDEwMDtcblxudmFyIHF1ZXVlID0gW107XG52YXIgYWN0aXZhdGVkQ2hpbGRyZW4gPSBbXTtcbnZhciBoYXMgPSB7fTtcbnZhciBjaXJjdWxhciA9IHt9O1xudmFyIHdhaXRpbmcgPSBmYWxzZTtcbnZhciBmbHVzaGluZyA9IGZhbHNlO1xudmFyIGluZGV4ID0gMDtcblxuLyoqXG4gKiBSZXNldCB0aGUgc2NoZWR1bGVyJ3Mgc3RhdGUuXG4gKi9cbmZ1bmN0aW9uIHJlc2V0U2NoZWR1bGVyU3RhdGUgKCkge1xuICBpbmRleCA9IHF1ZXVlLmxlbmd0aCA9IGFjdGl2YXRlZENoaWxkcmVuLmxlbmd0aCA9IDA7XG4gIGhhcyA9IHt9O1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgIGNpcmN1bGFyID0ge307XG4gIH1cbiAgd2FpdGluZyA9IGZsdXNoaW5nID0gZmFsc2U7XG59XG5cbi8vIEFzeW5jIGVkZ2UgY2FzZSAjNjU2NiByZXF1aXJlcyBzYXZpbmcgdGhlIHRpbWVzdGFtcCB3aGVuIGV2ZW50IGxpc3RlbmVycyBhcmVcbi8vIGF0dGFjaGVkLiBIb3dldmVyLCBjYWxsaW5nIHBlcmZvcm1hbmNlLm5vdygpIGhhcyBhIHBlcmYgb3ZlcmhlYWQgZXNwZWNpYWxseVxuLy8gaWYgdGhlIHBhZ2UgaGFzIHRob3VzYW5kcyBvZiBldmVudCBsaXN0ZW5lcnMuIEluc3RlYWQsIHdlIHRha2UgYSB0aW1lc3RhbXBcbi8vIGV2ZXJ5IHRpbWUgdGhlIHNjaGVkdWxlciBmbHVzaGVzIGFuZCB1c2UgdGhhdCBmb3IgYWxsIGV2ZW50IGxpc3RlbmVyc1xuLy8gYXR0YWNoZWQgZHVyaW5nIHRoYXQgZmx1c2guXG52YXIgY3VycmVudEZsdXNoVGltZXN0YW1wID0gMDtcblxuLy8gQXN5bmMgZWRnZSBjYXNlIGZpeCByZXF1aXJlcyBzdG9yaW5nIGFuIGV2ZW50IGxpc3RlbmVyJ3MgYXR0YWNoIHRpbWVzdGFtcC5cbnZhciBnZXROb3cgPSBEYXRlLm5vdztcblxuLy8gRGV0ZXJtaW5lIHdoYXQgZXZlbnQgdGltZXN0YW1wIHRoZSBicm93c2VyIGlzIHVzaW5nLiBBbm5veWluZ2x5LCB0aGVcbi8vIHRpbWVzdGFtcCBjYW4gZWl0aGVyIGJlIGhpLXJlcyAocmVsYXRpdmUgdG8gcGFnZSBsb2FkKSBvciBsb3ctcmVzXG4vLyAocmVsYXRpdmUgdG8gVU5JWCBlcG9jaCksIHNvIGluIG9yZGVyIHRvIGNvbXBhcmUgdGltZSB3ZSBoYXZlIHRvIHVzZSB0aGVcbi8vIHNhbWUgdGltZXN0YW1wIHR5cGUgd2hlbiBzYXZpbmcgdGhlIGZsdXNoIHRpbWVzdGFtcC5cbi8vIEFsbCBJRSB2ZXJzaW9ucyB1c2UgbG93LXJlcyBldmVudCB0aW1lc3RhbXBzLCBhbmQgaGF2ZSBwcm9ibGVtYXRpYyBjbG9ja1xuLy8gaW1wbGVtZW50YXRpb25zICgjOTYzMilcbmlmIChpbkJyb3dzZXIgJiYgIWlzSUUpIHtcbiAgdmFyIHBlcmZvcm1hbmNlID0gd2luZG93LnBlcmZvcm1hbmNlO1xuICBpZiAoXG4gICAgcGVyZm9ybWFuY2UgJiZcbiAgICB0eXBlb2YgcGVyZm9ybWFuY2Uubm93ID09PSAnZnVuY3Rpb24nICYmXG4gICAgZ2V0Tm93KCkgPiBkb2N1bWVudC5jcmVhdGVFdmVudCgnRXZlbnQnKS50aW1lU3RhbXBcbiAgKSB7XG4gICAgLy8gaWYgdGhlIGV2ZW50IHRpbWVzdGFtcCwgYWx0aG91Z2ggZXZhbHVhdGVkIEFGVEVSIHRoZSBEYXRlLm5vdygpLCBpc1xuICAgIC8vIHNtYWxsZXIgdGhhbiBpdCwgaXQgbWVhbnMgdGhlIGV2ZW50IGlzIHVzaW5nIGEgaGktcmVzIHRpbWVzdGFtcCxcbiAgICAvLyBhbmQgd2UgbmVlZCB0byB1c2UgdGhlIGhpLXJlcyB2ZXJzaW9uIGZvciBldmVudCBsaXN0ZW5lciB0aW1lc3RhbXBzIGFzXG4gICAgLy8gd2VsbC5cbiAgICBnZXROb3cgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBwZXJmb3JtYW5jZS5ub3coKTsgfTtcbiAgfVxufVxuXG4vKipcbiAqIEZsdXNoIGJvdGggcXVldWVzIGFuZCBydW4gdGhlIHdhdGNoZXJzLlxuICovXG5mdW5jdGlvbiBmbHVzaFNjaGVkdWxlclF1ZXVlICgpIHtcbiAgY3VycmVudEZsdXNoVGltZXN0YW1wID0gZ2V0Tm93KCk7XG4gIGZsdXNoaW5nID0gdHJ1ZTtcbiAgdmFyIHdhdGNoZXIsIGlkO1xuXG4gIC8vIFNvcnQgcXVldWUgYmVmb3JlIGZsdXNoLlxuICAvLyBUaGlzIGVuc3VyZXMgdGhhdDpcbiAgLy8gMS4gQ29tcG9uZW50cyBhcmUgdXBkYXRlZCBmcm9tIHBhcmVudCB0byBjaGlsZC4gKGJlY2F1c2UgcGFyZW50IGlzIGFsd2F5c1xuICAvLyAgICBjcmVhdGVkIGJlZm9yZSB0aGUgY2hpbGQpXG4gIC8vIDIuIEEgY29tcG9uZW50J3MgdXNlciB3YXRjaGVycyBhcmUgcnVuIGJlZm9yZSBpdHMgcmVuZGVyIHdhdGNoZXIgKGJlY2F1c2VcbiAgLy8gICAgdXNlciB3YXRjaGVycyBhcmUgY3JlYXRlZCBiZWZvcmUgdGhlIHJlbmRlciB3YXRjaGVyKVxuICAvLyAzLiBJZiBhIGNvbXBvbmVudCBpcyBkZXN0cm95ZWQgZHVyaW5nIGEgcGFyZW50IGNvbXBvbmVudCdzIHdhdGNoZXIgcnVuLFxuICAvLyAgICBpdHMgd2F0Y2hlcnMgY2FuIGJlIHNraXBwZWQuXG4gIHF1ZXVlLnNvcnQoZnVuY3Rpb24gKGEsIGIpIHsgcmV0dXJuIGEuaWQgLSBiLmlkOyB9KTtcblxuICAvLyBkbyBub3QgY2FjaGUgbGVuZ3RoIGJlY2F1c2UgbW9yZSB3YXRjaGVycyBtaWdodCBiZSBwdXNoZWRcbiAgLy8gYXMgd2UgcnVuIGV4aXN0aW5nIHdhdGNoZXJzXG4gIGZvciAoaW5kZXggPSAwOyBpbmRleCA8IHF1ZXVlLmxlbmd0aDsgaW5kZXgrKykge1xuICAgIHdhdGNoZXIgPSBxdWV1ZVtpbmRleF07XG4gICAgaWYgKHdhdGNoZXIuYmVmb3JlKSB7XG4gICAgICB3YXRjaGVyLmJlZm9yZSgpO1xuICAgIH1cbiAgICBpZCA9IHdhdGNoZXIuaWQ7XG4gICAgaGFzW2lkXSA9IG51bGw7XG4gICAgd2F0Y2hlci5ydW4oKTtcbiAgICAvLyBpbiBkZXYgYnVpbGQsIGNoZWNrIGFuZCBzdG9wIGNpcmN1bGFyIHVwZGF0ZXMuXG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgaGFzW2lkXSAhPSBudWxsKSB7XG4gICAgICBjaXJjdWxhcltpZF0gPSAoY2lyY3VsYXJbaWRdIHx8IDApICsgMTtcbiAgICAgIGlmIChjaXJjdWxhcltpZF0gPiBNQVhfVVBEQVRFX0NPVU5UKSB7XG4gICAgICAgIHdhcm4oXG4gICAgICAgICAgJ1lvdSBtYXkgaGF2ZSBhbiBpbmZpbml0ZSB1cGRhdGUgbG9vcCAnICsgKFxuICAgICAgICAgICAgd2F0Y2hlci51c2VyXG4gICAgICAgICAgICAgID8gKFwiaW4gd2F0Y2hlciB3aXRoIGV4cHJlc3Npb24gXFxcIlwiICsgKHdhdGNoZXIuZXhwcmVzc2lvbikgKyBcIlxcXCJcIilcbiAgICAgICAgICAgICAgOiBcImluIGEgY29tcG9uZW50IHJlbmRlciBmdW5jdGlvbi5cIlxuICAgICAgICAgICksXG4gICAgICAgICAgd2F0Y2hlci52bVxuICAgICAgICApO1xuICAgICAgICBicmVha1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8vIGtlZXAgY29waWVzIG9mIHBvc3QgcXVldWVzIGJlZm9yZSByZXNldHRpbmcgc3RhdGVcbiAgdmFyIGFjdGl2YXRlZFF1ZXVlID0gYWN0aXZhdGVkQ2hpbGRyZW4uc2xpY2UoKTtcbiAgdmFyIHVwZGF0ZWRRdWV1ZSA9IHF1ZXVlLnNsaWNlKCk7XG5cbiAgcmVzZXRTY2hlZHVsZXJTdGF0ZSgpO1xuXG4gIC8vIGNhbGwgY29tcG9uZW50IHVwZGF0ZWQgYW5kIGFjdGl2YXRlZCBob29rc1xuICBjYWxsQWN0aXZhdGVkSG9va3MoYWN0aXZhdGVkUXVldWUpO1xuICBjYWxsVXBkYXRlZEhvb2tzKHVwZGF0ZWRRdWV1ZSk7XG5cbiAgLy8gZGV2dG9vbCBob29rXG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICBpZiAoZGV2dG9vbHMgJiYgY29uZmlnLmRldnRvb2xzKSB7XG4gICAgZGV2dG9vbHMuZW1pdCgnZmx1c2gnKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBjYWxsVXBkYXRlZEhvb2tzIChxdWV1ZSkge1xuICB2YXIgaSA9IHF1ZXVlLmxlbmd0aDtcbiAgd2hpbGUgKGktLSkge1xuICAgIHZhciB3YXRjaGVyID0gcXVldWVbaV07XG4gICAgdmFyIHZtID0gd2F0Y2hlci52bTtcbiAgICBpZiAodm0uX3dhdGNoZXIgPT09IHdhdGNoZXIgJiYgdm0uX2lzTW91bnRlZCAmJiAhdm0uX2lzRGVzdHJveWVkKSB7XG4gICAgICBjYWxsSG9vayh2bSwgJ3VwZGF0ZWQnKTtcbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBRdWV1ZSBhIGtlcHQtYWxpdmUgY29tcG9uZW50IHRoYXQgd2FzIGFjdGl2YXRlZCBkdXJpbmcgcGF0Y2guXG4gKiBUaGUgcXVldWUgd2lsbCBiZSBwcm9jZXNzZWQgYWZ0ZXIgdGhlIGVudGlyZSB0cmVlIGhhcyBiZWVuIHBhdGNoZWQuXG4gKi9cbmZ1bmN0aW9uIHF1ZXVlQWN0aXZhdGVkQ29tcG9uZW50ICh2bSkge1xuICAvLyBzZXR0aW5nIF9pbmFjdGl2ZSB0byBmYWxzZSBoZXJlIHNvIHRoYXQgYSByZW5kZXIgZnVuY3Rpb24gY2FuXG4gIC8vIHJlbHkgb24gY2hlY2tpbmcgd2hldGhlciBpdCdzIGluIGFuIGluYWN0aXZlIHRyZWUgKGUuZy4gcm91dGVyLXZpZXcpXG4gIHZtLl9pbmFjdGl2ZSA9IGZhbHNlO1xuICBhY3RpdmF0ZWRDaGlsZHJlbi5wdXNoKHZtKTtcbn1cblxuZnVuY3Rpb24gY2FsbEFjdGl2YXRlZEhvb2tzIChxdWV1ZSkge1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHF1ZXVlLmxlbmd0aDsgaSsrKSB7XG4gICAgcXVldWVbaV0uX2luYWN0aXZlID0gdHJ1ZTtcbiAgICBhY3RpdmF0ZUNoaWxkQ29tcG9uZW50KHF1ZXVlW2ldLCB0cnVlIC8qIHRydWUgKi8pO1xuICB9XG59XG5cbi8qKlxuICogUHVzaCBhIHdhdGNoZXIgaW50byB0aGUgd2F0Y2hlciBxdWV1ZS5cbiAqIEpvYnMgd2l0aCBkdXBsaWNhdGUgSURzIHdpbGwgYmUgc2tpcHBlZCB1bmxlc3MgaXQnc1xuICogcHVzaGVkIHdoZW4gdGhlIHF1ZXVlIGlzIGJlaW5nIGZsdXNoZWQuXG4gKi9cbmZ1bmN0aW9uIHF1ZXVlV2F0Y2hlciAod2F0Y2hlcikge1xuICB2YXIgaWQgPSB3YXRjaGVyLmlkO1xuICBpZiAoaGFzW2lkXSA9PSBudWxsKSB7XG4gICAgaGFzW2lkXSA9IHRydWU7XG4gICAgaWYgKCFmbHVzaGluZykge1xuICAgICAgcXVldWUucHVzaCh3YXRjaGVyKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gaWYgYWxyZWFkeSBmbHVzaGluZywgc3BsaWNlIHRoZSB3YXRjaGVyIGJhc2VkIG9uIGl0cyBpZFxuICAgICAgLy8gaWYgYWxyZWFkeSBwYXN0IGl0cyBpZCwgaXQgd2lsbCBiZSBydW4gbmV4dCBpbW1lZGlhdGVseS5cbiAgICAgIHZhciBpID0gcXVldWUubGVuZ3RoIC0gMTtcbiAgICAgIHdoaWxlIChpID4gaW5kZXggJiYgcXVldWVbaV0uaWQgPiB3YXRjaGVyLmlkKSB7XG4gICAgICAgIGktLTtcbiAgICAgIH1cbiAgICAgIHF1ZXVlLnNwbGljZShpICsgMSwgMCwgd2F0Y2hlcik7XG4gICAgfVxuICAgIC8vIHF1ZXVlIHRoZSBmbHVzaFxuICAgIGlmICghd2FpdGluZykge1xuICAgICAgd2FpdGluZyA9IHRydWU7XG5cbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmICFjb25maWcuYXN5bmMpIHtcbiAgICAgICAgZmx1c2hTY2hlZHVsZXJRdWV1ZSgpO1xuICAgICAgICByZXR1cm5cbiAgICAgIH1cbiAgICAgIG5leHRUaWNrKGZsdXNoU2NoZWR1bGVyUXVldWUpO1xuICAgIH1cbiAgfVxufVxuXG4vKiAgKi9cblxuXG5cbnZhciB1aWQkMiA9IDA7XG5cbi8qKlxuICogQSB3YXRjaGVyIHBhcnNlcyBhbiBleHByZXNzaW9uLCBjb2xsZWN0cyBkZXBlbmRlbmNpZXMsXG4gKiBhbmQgZmlyZXMgY2FsbGJhY2sgd2hlbiB0aGUgZXhwcmVzc2lvbiB2YWx1ZSBjaGFuZ2VzLlxuICogVGhpcyBpcyB1c2VkIGZvciBib3RoIHRoZSAkd2F0Y2goKSBhcGkgYW5kIGRpcmVjdGl2ZXMuXG4gKi9cbnZhciBXYXRjaGVyID0gZnVuY3Rpb24gV2F0Y2hlciAoXG4gIHZtLFxuICBleHBPckZuLFxuICBjYixcbiAgb3B0aW9ucyxcbiAgaXNSZW5kZXJXYXRjaGVyXG4pIHtcbiAgdGhpcy52bSA9IHZtO1xuICBpZiAoaXNSZW5kZXJXYXRjaGVyKSB7XG4gICAgdm0uX3dhdGNoZXIgPSB0aGlzO1xuICB9XG4gIHZtLl93YXRjaGVycy5wdXNoKHRoaXMpO1xuICAvLyBvcHRpb25zXG4gIGlmIChvcHRpb25zKSB7XG4gICAgdGhpcy5kZWVwID0gISFvcHRpb25zLmRlZXA7XG4gICAgdGhpcy51c2VyID0gISFvcHRpb25zLnVzZXI7XG4gICAgdGhpcy5sYXp5ID0gISFvcHRpb25zLmxhenk7XG4gICAgdGhpcy5zeW5jID0gISFvcHRpb25zLnN5bmM7XG4gICAgdGhpcy5iZWZvcmUgPSBvcHRpb25zLmJlZm9yZTtcbiAgfSBlbHNlIHtcbiAgICB0aGlzLmRlZXAgPSB0aGlzLnVzZXIgPSB0aGlzLmxhenkgPSB0aGlzLnN5bmMgPSBmYWxzZTtcbiAgfVxuICB0aGlzLmNiID0gY2I7XG4gIHRoaXMuaWQgPSArK3VpZCQyOyAvLyB1aWQgZm9yIGJhdGNoaW5nXG4gIHRoaXMuYWN0aXZlID0gdHJ1ZTtcbiAgdGhpcy5kaXJ0eSA9IHRoaXMubGF6eTsgLy8gZm9yIGxhenkgd2F0Y2hlcnNcbiAgdGhpcy5kZXBzID0gW107XG4gIHRoaXMubmV3RGVwcyA9IFtdO1xuICB0aGlzLmRlcElkcyA9IG5ldyBfU2V0KCk7XG4gIHRoaXMubmV3RGVwSWRzID0gbmV3IF9TZXQoKTtcbiAgdGhpcy5leHByZXNzaW9uID0gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJ1xuICAgID8gZXhwT3JGbi50b1N0cmluZygpXG4gICAgOiAnJztcbiAgLy8gcGFyc2UgZXhwcmVzc2lvbiBmb3IgZ2V0dGVyXG4gIGlmICh0eXBlb2YgZXhwT3JGbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHRoaXMuZ2V0dGVyID0gZXhwT3JGbjtcbiAgfSBlbHNlIHtcbiAgICB0aGlzLmdldHRlciA9IHBhcnNlUGF0aChleHBPckZuKTtcbiAgICBpZiAoIXRoaXMuZ2V0dGVyKSB7XG4gICAgICB0aGlzLmdldHRlciA9IG5vb3A7XG4gICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIHdhcm4oXG4gICAgICAgIFwiRmFpbGVkIHdhdGNoaW5nIHBhdGg6IFxcXCJcIiArIGV4cE9yRm4gKyBcIlxcXCIgXCIgK1xuICAgICAgICAnV2F0Y2hlciBvbmx5IGFjY2VwdHMgc2ltcGxlIGRvdC1kZWxpbWl0ZWQgcGF0aHMuICcgK1xuICAgICAgICAnRm9yIGZ1bGwgY29udHJvbCwgdXNlIGEgZnVuY3Rpb24gaW5zdGVhZC4nLFxuICAgICAgICB2bVxuICAgICAgKTtcbiAgICB9XG4gIH1cbiAgdGhpcy52YWx1ZSA9IHRoaXMubGF6eVxuICAgID8gdW5kZWZpbmVkXG4gICAgOiB0aGlzLmdldCgpO1xufTtcblxuLyoqXG4gKiBFdmFsdWF0ZSB0aGUgZ2V0dGVyLCBhbmQgcmUtY29sbGVjdCBkZXBlbmRlbmNpZXMuXG4gKi9cbldhdGNoZXIucHJvdG90eXBlLmdldCA9IGZ1bmN0aW9uIGdldCAoKSB7XG4gIHB1c2hUYXJnZXQodGhpcyk7XG4gIHZhciB2YWx1ZTtcbiAgdmFyIHZtID0gdGhpcy52bTtcbiAgdHJ5IHtcbiAgICB2YWx1ZSA9IHRoaXMuZ2V0dGVyLmNhbGwodm0sIHZtKTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIGlmICh0aGlzLnVzZXIpIHtcbiAgICAgIGhhbmRsZUVycm9yKGUsIHZtLCAoXCJnZXR0ZXIgZm9yIHdhdGNoZXIgXFxcIlwiICsgKHRoaXMuZXhwcmVzc2lvbikgKyBcIlxcXCJcIikpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBlXG4gICAgfVxuICB9IGZpbmFsbHkge1xuICAgIC8vIFwidG91Y2hcIiBldmVyeSBwcm9wZXJ0eSBzbyB0aGV5IGFyZSBhbGwgdHJhY2tlZCBhc1xuICAgIC8vIGRlcGVuZGVuY2llcyBmb3IgZGVlcCB3YXRjaGluZ1xuICAgIGlmICh0aGlzLmRlZXApIHtcbiAgICAgIHRyYXZlcnNlKHZhbHVlKTtcbiAgICB9XG4gICAgcG9wVGFyZ2V0KCk7XG4gICAgdGhpcy5jbGVhbnVwRGVwcygpO1xuICB9XG4gIHJldHVybiB2YWx1ZVxufTtcblxuLyoqXG4gKiBBZGQgYSBkZXBlbmRlbmN5IHRvIHRoaXMgZGlyZWN0aXZlLlxuICovXG5XYXRjaGVyLnByb3RvdHlwZS5hZGREZXAgPSBmdW5jdGlvbiBhZGREZXAgKGRlcCkge1xuICB2YXIgaWQgPSBkZXAuaWQ7XG4gIGlmICghdGhpcy5uZXdEZXBJZHMuaGFzKGlkKSkge1xuICAgIHRoaXMubmV3RGVwSWRzLmFkZChpZCk7XG4gICAgdGhpcy5uZXdEZXBzLnB1c2goZGVwKTtcbiAgICBpZiAoIXRoaXMuZGVwSWRzLmhhcyhpZCkpIHtcbiAgICAgIGRlcC5hZGRTdWIodGhpcyk7XG4gICAgfVxuICB9XG59O1xuXG4vKipcbiAqIENsZWFuIHVwIGZvciBkZXBlbmRlbmN5IGNvbGxlY3Rpb24uXG4gKi9cbldhdGNoZXIucHJvdG90eXBlLmNsZWFudXBEZXBzID0gZnVuY3Rpb24gY2xlYW51cERlcHMgKCkge1xuICB2YXIgaSA9IHRoaXMuZGVwcy5sZW5ndGg7XG4gIHdoaWxlIChpLS0pIHtcbiAgICB2YXIgZGVwID0gdGhpcy5kZXBzW2ldO1xuICAgIGlmICghdGhpcy5uZXdEZXBJZHMuaGFzKGRlcC5pZCkpIHtcbiAgICAgIGRlcC5yZW1vdmVTdWIodGhpcyk7XG4gICAgfVxuICB9XG4gIHZhciB0bXAgPSB0aGlzLmRlcElkcztcbiAgdGhpcy5kZXBJZHMgPSB0aGlzLm5ld0RlcElkcztcbiAgdGhpcy5uZXdEZXBJZHMgPSB0bXA7XG4gIHRoaXMubmV3RGVwSWRzLmNsZWFyKCk7XG4gIHRtcCA9IHRoaXMuZGVwcztcbiAgdGhpcy5kZXBzID0gdGhpcy5uZXdEZXBzO1xuICB0aGlzLm5ld0RlcHMgPSB0bXA7XG4gIHRoaXMubmV3RGVwcy5sZW5ndGggPSAwO1xufTtcblxuLyoqXG4gKiBTdWJzY3JpYmVyIGludGVyZmFjZS5cbiAqIFdpbGwgYmUgY2FsbGVkIHdoZW4gYSBkZXBlbmRlbmN5IGNoYW5nZXMuXG4gKi9cbldhdGNoZXIucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uIHVwZGF0ZSAoKSB7XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovXG4gIGlmICh0aGlzLmxhenkpIHtcbiAgICB0aGlzLmRpcnR5ID0gdHJ1ZTtcbiAgfSBlbHNlIGlmICh0aGlzLnN5bmMpIHtcbiAgICB0aGlzLnJ1bigpO1xuICB9IGVsc2Uge1xuICAgIHF1ZXVlV2F0Y2hlcih0aGlzKTtcbiAgfVxufTtcblxuLyoqXG4gKiBTY2hlZHVsZXIgam9iIGludGVyZmFjZS5cbiAqIFdpbGwgYmUgY2FsbGVkIGJ5IHRoZSBzY2hlZHVsZXIuXG4gKi9cbldhdGNoZXIucHJvdG90eXBlLnJ1biA9IGZ1bmN0aW9uIHJ1biAoKSB7XG4gIGlmICh0aGlzLmFjdGl2ZSkge1xuICAgIHZhciB2YWx1ZSA9IHRoaXMuZ2V0KCk7XG4gICAgaWYgKFxuICAgICAgdmFsdWUgIT09IHRoaXMudmFsdWUgfHxcbiAgICAgIC8vIERlZXAgd2F0Y2hlcnMgYW5kIHdhdGNoZXJzIG9uIE9iamVjdC9BcnJheXMgc2hvdWxkIGZpcmUgZXZlblxuICAgICAgLy8gd2hlbiB0aGUgdmFsdWUgaXMgdGhlIHNhbWUsIGJlY2F1c2UgdGhlIHZhbHVlIG1heVxuICAgICAgLy8gaGF2ZSBtdXRhdGVkLlxuICAgICAgaXNPYmplY3QodmFsdWUpIHx8XG4gICAgICB0aGlzLmRlZXBcbiAgICApIHtcbiAgICAgIC8vIHNldCBuZXcgdmFsdWVcbiAgICAgIHZhciBvbGRWYWx1ZSA9IHRoaXMudmFsdWU7XG4gICAgICB0aGlzLnZhbHVlID0gdmFsdWU7XG4gICAgICBpZiAodGhpcy51c2VyKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgdGhpcy5jYi5jYWxsKHRoaXMudm0sIHZhbHVlLCBvbGRWYWx1ZSk7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICBoYW5kbGVFcnJvcihlLCB0aGlzLnZtLCAoXCJjYWxsYmFjayBmb3Igd2F0Y2hlciBcXFwiXCIgKyAodGhpcy5leHByZXNzaW9uKSArIFwiXFxcIlwiKSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuY2IuY2FsbCh0aGlzLnZtLCB2YWx1ZSwgb2xkVmFsdWUpO1xuICAgICAgfVxuICAgIH1cbiAgfVxufTtcblxuLyoqXG4gKiBFdmFsdWF0ZSB0aGUgdmFsdWUgb2YgdGhlIHdhdGNoZXIuXG4gKiBUaGlzIG9ubHkgZ2V0cyBjYWxsZWQgZm9yIGxhenkgd2F0Y2hlcnMuXG4gKi9cbldhdGNoZXIucHJvdG90eXBlLmV2YWx1YXRlID0gZnVuY3Rpb24gZXZhbHVhdGUgKCkge1xuICB0aGlzLnZhbHVlID0gdGhpcy5nZXQoKTtcbiAgdGhpcy5kaXJ0eSA9IGZhbHNlO1xufTtcblxuLyoqXG4gKiBEZXBlbmQgb24gYWxsIGRlcHMgY29sbGVjdGVkIGJ5IHRoaXMgd2F0Y2hlci5cbiAqL1xuV2F0Y2hlci5wcm90b3R5cGUuZGVwZW5kID0gZnVuY3Rpb24gZGVwZW5kICgpIHtcbiAgdmFyIGkgPSB0aGlzLmRlcHMubGVuZ3RoO1xuICB3aGlsZSAoaS0tKSB7XG4gICAgdGhpcy5kZXBzW2ldLmRlcGVuZCgpO1xuICB9XG59O1xuXG4vKipcbiAqIFJlbW92ZSBzZWxmIGZyb20gYWxsIGRlcGVuZGVuY2llcycgc3Vic2NyaWJlciBsaXN0LlxuICovXG5XYXRjaGVyLnByb3RvdHlwZS50ZWFyZG93biA9IGZ1bmN0aW9uIHRlYXJkb3duICgpIHtcbiAgaWYgKHRoaXMuYWN0aXZlKSB7XG4gICAgLy8gcmVtb3ZlIHNlbGYgZnJvbSB2bSdzIHdhdGNoZXIgbGlzdFxuICAgIC8vIHRoaXMgaXMgYSBzb21ld2hhdCBleHBlbnNpdmUgb3BlcmF0aW9uIHNvIHdlIHNraXAgaXRcbiAgICAvLyBpZiB0aGUgdm0gaXMgYmVpbmcgZGVzdHJveWVkLlxuICAgIGlmICghdGhpcy52bS5faXNCZWluZ0Rlc3Ryb3llZCkge1xuICAgICAgcmVtb3ZlKHRoaXMudm0uX3dhdGNoZXJzLCB0aGlzKTtcbiAgICB9XG4gICAgdmFyIGkgPSB0aGlzLmRlcHMubGVuZ3RoO1xuICAgIHdoaWxlIChpLS0pIHtcbiAgICAgIHRoaXMuZGVwc1tpXS5yZW1vdmVTdWIodGhpcyk7XG4gICAgfVxuICAgIHRoaXMuYWN0aXZlID0gZmFsc2U7XG4gIH1cbn07XG5cbi8qICAqL1xuXG52YXIgc2hhcmVkUHJvcGVydHlEZWZpbml0aW9uID0ge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBjb25maWd1cmFibGU6IHRydWUsXG4gIGdldDogbm9vcCxcbiAgc2V0OiBub29wXG59O1xuXG5mdW5jdGlvbiBwcm94eSAodGFyZ2V0LCBzb3VyY2VLZXksIGtleSkge1xuICBzaGFyZWRQcm9wZXJ0eURlZmluaXRpb24uZ2V0ID0gZnVuY3Rpb24gcHJveHlHZXR0ZXIgKCkge1xuICAgIHJldHVybiB0aGlzW3NvdXJjZUtleV1ba2V5XVxuICB9O1xuICBzaGFyZWRQcm9wZXJ0eURlZmluaXRpb24uc2V0ID0gZnVuY3Rpb24gcHJveHlTZXR0ZXIgKHZhbCkge1xuICAgIHRoaXNbc291cmNlS2V5XVtrZXldID0gdmFsO1xuICB9O1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHNoYXJlZFByb3BlcnR5RGVmaW5pdGlvbik7XG59XG5cbmZ1bmN0aW9uIGluaXRTdGF0ZSAodm0pIHtcbiAgdm0uX3dhdGNoZXJzID0gW107XG4gIHZhciBvcHRzID0gdm0uJG9wdGlvbnM7XG4gIGlmIChvcHRzLnByb3BzKSB7IGluaXRQcm9wcyh2bSwgb3B0cy5wcm9wcyk7IH1cbiAgaWYgKG9wdHMubWV0aG9kcykgeyBpbml0TWV0aG9kcyh2bSwgb3B0cy5tZXRob2RzKTsgfVxuICBpZiAob3B0cy5kYXRhKSB7XG4gICAgaW5pdERhdGEodm0pO1xuICB9IGVsc2Uge1xuICAgIG9ic2VydmUodm0uX2RhdGEgPSB7fSwgdHJ1ZSAvKiBhc1Jvb3REYXRhICovKTtcbiAgfVxuICBpZiAob3B0cy5jb21wdXRlZCkgeyBpbml0Q29tcHV0ZWQodm0sIG9wdHMuY29tcHV0ZWQpOyB9XG4gIGlmIChvcHRzLndhdGNoICYmIG9wdHMud2F0Y2ggIT09IG5hdGl2ZVdhdGNoKSB7XG4gICAgaW5pdFdhdGNoKHZtLCBvcHRzLndhdGNoKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBpbml0UHJvcHMgKHZtLCBwcm9wc09wdGlvbnMpIHtcbiAgdmFyIHByb3BzRGF0YSA9IHZtLiRvcHRpb25zLnByb3BzRGF0YSB8fCB7fTtcbiAgdmFyIHByb3BzID0gdm0uX3Byb3BzID0ge307XG4gIC8vIGNhY2hlIHByb3Aga2V5cyBzbyB0aGF0IGZ1dHVyZSBwcm9wcyB1cGRhdGVzIGNhbiBpdGVyYXRlIHVzaW5nIEFycmF5XG4gIC8vIGluc3RlYWQgb2YgZHluYW1pYyBvYmplY3Qga2V5IGVudW1lcmF0aW9uLlxuICB2YXIga2V5cyA9IHZtLiRvcHRpb25zLl9wcm9wS2V5cyA9IFtdO1xuICB2YXIgaXNSb290ID0gIXZtLiRwYXJlbnQ7XG4gIC8vIHJvb3QgaW5zdGFuY2UgcHJvcHMgc2hvdWxkIGJlIGNvbnZlcnRlZFxuICBpZiAoIWlzUm9vdCkge1xuICAgIHRvZ2dsZU9ic2VydmluZyhmYWxzZSk7XG4gIH1cbiAgdmFyIGxvb3AgPSBmdW5jdGlvbiAoIGtleSApIHtcbiAgICBrZXlzLnB1c2goa2V5KTtcbiAgICB2YXIgdmFsdWUgPSB2YWxpZGF0ZVByb3Aoa2V5LCBwcm9wc09wdGlvbnMsIHByb3BzRGF0YSwgdm0pO1xuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovXG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIHZhciBoeXBoZW5hdGVkS2V5ID0gaHlwaGVuYXRlKGtleSk7XG4gICAgICBpZiAoaXNSZXNlcnZlZEF0dHJpYnV0ZShoeXBoZW5hdGVkS2V5KSB8fFxuICAgICAgICAgIGNvbmZpZy5pc1Jlc2VydmVkQXR0cihoeXBoZW5hdGVkS2V5KSkge1xuICAgICAgICB3YXJuKFxuICAgICAgICAgIChcIlxcXCJcIiArIGh5cGhlbmF0ZWRLZXkgKyBcIlxcXCIgaXMgYSByZXNlcnZlZCBhdHRyaWJ1dGUgYW5kIGNhbm5vdCBiZSB1c2VkIGFzIGNvbXBvbmVudCBwcm9wLlwiKSxcbiAgICAgICAgICB2bVxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgZGVmaW5lUmVhY3RpdmUkJDEocHJvcHMsIGtleSwgdmFsdWUsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKCFpc1Jvb3QgJiYgIWlzVXBkYXRpbmdDaGlsZENvbXBvbmVudCkge1xuICAgICAgICAgIHdhcm4oXG4gICAgICAgICAgICBcIkF2b2lkIG11dGF0aW5nIGEgcHJvcCBkaXJlY3RseSBzaW5jZSB0aGUgdmFsdWUgd2lsbCBiZSBcIiArXG4gICAgICAgICAgICBcIm92ZXJ3cml0dGVuIHdoZW5ldmVyIHRoZSBwYXJlbnQgY29tcG9uZW50IHJlLXJlbmRlcnMuIFwiICtcbiAgICAgICAgICAgIFwiSW5zdGVhZCwgdXNlIGEgZGF0YSBvciBjb21wdXRlZCBwcm9wZXJ0eSBiYXNlZCBvbiB0aGUgcHJvcCdzIFwiICtcbiAgICAgICAgICAgIFwidmFsdWUuIFByb3AgYmVpbmcgbXV0YXRlZDogXFxcIlwiICsga2V5ICsgXCJcXFwiXCIsXG4gICAgICAgICAgICB2bVxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBkZWZpbmVSZWFjdGl2ZSQkMShwcm9wcywga2V5LCB2YWx1ZSk7XG4gICAgfVxuICAgIC8vIHN0YXRpYyBwcm9wcyBhcmUgYWxyZWFkeSBwcm94aWVkIG9uIHRoZSBjb21wb25lbnQncyBwcm90b3R5cGVcbiAgICAvLyBkdXJpbmcgVnVlLmV4dGVuZCgpLiBXZSBvbmx5IG5lZWQgdG8gcHJveHkgcHJvcHMgZGVmaW5lZCBhdFxuICAgIC8vIGluc3RhbnRpYXRpb24gaGVyZS5cbiAgICBpZiAoIShrZXkgaW4gdm0pKSB7XG4gICAgICBwcm94eSh2bSwgXCJfcHJvcHNcIiwga2V5KTtcbiAgICB9XG4gIH07XG5cbiAgZm9yICh2YXIga2V5IGluIHByb3BzT3B0aW9ucykgbG9vcCgga2V5ICk7XG4gIHRvZ2dsZU9ic2VydmluZyh0cnVlKTtcbn1cblxuZnVuY3Rpb24gaW5pdERhdGEgKHZtKSB7XG4gIHZhciBkYXRhID0gdm0uJG9wdGlvbnMuZGF0YTtcbiAgZGF0YSA9IHZtLl9kYXRhID0gdHlwZW9mIGRhdGEgPT09ICdmdW5jdGlvbidcbiAgICA/IGdldERhdGEoZGF0YSwgdm0pXG4gICAgOiBkYXRhIHx8IHt9O1xuICBpZiAoIWlzUGxhaW5PYmplY3QoZGF0YSkpIHtcbiAgICBkYXRhID0ge307XG4gICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiB3YXJuKFxuICAgICAgJ2RhdGEgZnVuY3Rpb25zIHNob3VsZCByZXR1cm4gYW4gb2JqZWN0OlxcbicgK1xuICAgICAgJ2h0dHBzOi8vdnVlanMub3JnL3YyL2d1aWRlL2NvbXBvbmVudHMuaHRtbCNkYXRhLU11c3QtQmUtYS1GdW5jdGlvbicsXG4gICAgICB2bVxuICAgICk7XG4gIH1cbiAgLy8gcHJveHkgZGF0YSBvbiBpbnN0YW5jZVxuICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKGRhdGEpO1xuICB2YXIgcHJvcHMgPSB2bS4kb3B0aW9ucy5wcm9wcztcbiAgdmFyIG1ldGhvZHMgPSB2bS4kb3B0aW9ucy5tZXRob2RzO1xuICB2YXIgaSA9IGtleXMubGVuZ3RoO1xuICB3aGlsZSAoaS0tKSB7XG4gICAgdmFyIGtleSA9IGtleXNbaV07XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIGlmIChtZXRob2RzICYmIGhhc093bihtZXRob2RzLCBrZXkpKSB7XG4gICAgICAgIHdhcm4oXG4gICAgICAgICAgKFwiTWV0aG9kIFxcXCJcIiArIGtleSArIFwiXFxcIiBoYXMgYWxyZWFkeSBiZWVuIGRlZmluZWQgYXMgYSBkYXRhIHByb3BlcnR5LlwiKSxcbiAgICAgICAgICB2bVxuICAgICAgICApO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAocHJvcHMgJiYgaGFzT3duKHByb3BzLCBrZXkpKSB7XG4gICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIHdhcm4oXG4gICAgICAgIFwiVGhlIGRhdGEgcHJvcGVydHkgXFxcIlwiICsga2V5ICsgXCJcXFwiIGlzIGFscmVhZHkgZGVjbGFyZWQgYXMgYSBwcm9wLiBcIiArXG4gICAgICAgIFwiVXNlIHByb3AgZGVmYXVsdCB2YWx1ZSBpbnN0ZWFkLlwiLFxuICAgICAgICB2bVxuICAgICAgKTtcbiAgICB9IGVsc2UgaWYgKCFpc1Jlc2VydmVkKGtleSkpIHtcbiAgICAgIHByb3h5KHZtLCBcIl9kYXRhXCIsIGtleSk7XG4gICAgfVxuICB9XG4gIC8vIG9ic2VydmUgZGF0YVxuICBvYnNlcnZlKGRhdGEsIHRydWUgLyogYXNSb290RGF0YSAqLyk7XG59XG5cbmZ1bmN0aW9uIGdldERhdGEgKGRhdGEsIHZtKSB7XG4gIC8vICM3NTczIGRpc2FibGUgZGVwIGNvbGxlY3Rpb24gd2hlbiBpbnZva2luZyBkYXRhIGdldHRlcnNcbiAgcHVzaFRhcmdldCgpO1xuICB0cnkge1xuICAgIHJldHVybiBkYXRhLmNhbGwodm0sIHZtKVxuICB9IGNhdGNoIChlKSB7XG4gICAgaGFuZGxlRXJyb3IoZSwgdm0sIFwiZGF0YSgpXCIpO1xuICAgIHJldHVybiB7fVxuICB9IGZpbmFsbHkge1xuICAgIHBvcFRhcmdldCgpO1xuICB9XG59XG5cbnZhciBjb21wdXRlZFdhdGNoZXJPcHRpb25zID0geyBsYXp5OiB0cnVlIH07XG5cbmZ1bmN0aW9uIGluaXRDb21wdXRlZCAodm0sIGNvbXB1dGVkKSB7XG4gIC8vICRmbG93LWRpc2FibGUtbGluZVxuICB2YXIgd2F0Y2hlcnMgPSB2bS5fY29tcHV0ZWRXYXRjaGVycyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gIC8vIGNvbXB1dGVkIHByb3BlcnRpZXMgYXJlIGp1c3QgZ2V0dGVycyBkdXJpbmcgU1NSXG4gIHZhciBpc1NTUiA9IGlzU2VydmVyUmVuZGVyaW5nKCk7XG5cbiAgZm9yICh2YXIga2V5IGluIGNvbXB1dGVkKSB7XG4gICAgdmFyIHVzZXJEZWYgPSBjb21wdXRlZFtrZXldO1xuICAgIHZhciBnZXR0ZXIgPSB0eXBlb2YgdXNlckRlZiA9PT0gJ2Z1bmN0aW9uJyA/IHVzZXJEZWYgOiB1c2VyRGVmLmdldDtcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiBnZXR0ZXIgPT0gbnVsbCkge1xuICAgICAgd2FybihcbiAgICAgICAgKFwiR2V0dGVyIGlzIG1pc3NpbmcgZm9yIGNvbXB1dGVkIHByb3BlcnR5IFxcXCJcIiArIGtleSArIFwiXFxcIi5cIiksXG4gICAgICAgIHZtXG4gICAgICApO1xuICAgIH1cblxuICAgIGlmICghaXNTU1IpIHtcbiAgICAgIC8vIGNyZWF0ZSBpbnRlcm5hbCB3YXRjaGVyIGZvciB0aGUgY29tcHV0ZWQgcHJvcGVydHkuXG4gICAgICB3YXRjaGVyc1trZXldID0gbmV3IFdhdGNoZXIoXG4gICAgICAgIHZtLFxuICAgICAgICBnZXR0ZXIgfHwgbm9vcCxcbiAgICAgICAgbm9vcCxcbiAgICAgICAgY29tcHV0ZWRXYXRjaGVyT3B0aW9uc1xuICAgICAgKTtcbiAgICB9XG5cbiAgICAvLyBjb21wb25lbnQtZGVmaW5lZCBjb21wdXRlZCBwcm9wZXJ0aWVzIGFyZSBhbHJlYWR5IGRlZmluZWQgb24gdGhlXG4gICAgLy8gY29tcG9uZW50IHByb3RvdHlwZS4gV2Ugb25seSBuZWVkIHRvIGRlZmluZSBjb21wdXRlZCBwcm9wZXJ0aWVzIGRlZmluZWRcbiAgICAvLyBhdCBpbnN0YW50aWF0aW9uIGhlcmUuXG4gICAgaWYgKCEoa2V5IGluIHZtKSkge1xuICAgICAgZGVmaW5lQ29tcHV0ZWQodm0sIGtleSwgdXNlckRlZik7XG4gICAgfSBlbHNlIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICBpZiAoa2V5IGluIHZtLiRkYXRhKSB7XG4gICAgICAgIHdhcm4oKFwiVGhlIGNvbXB1dGVkIHByb3BlcnR5IFxcXCJcIiArIGtleSArIFwiXFxcIiBpcyBhbHJlYWR5IGRlZmluZWQgaW4gZGF0YS5cIiksIHZtKTtcbiAgICAgIH0gZWxzZSBpZiAodm0uJG9wdGlvbnMucHJvcHMgJiYga2V5IGluIHZtLiRvcHRpb25zLnByb3BzKSB7XG4gICAgICAgIHdhcm4oKFwiVGhlIGNvbXB1dGVkIHByb3BlcnR5IFxcXCJcIiArIGtleSArIFwiXFxcIiBpcyBhbHJlYWR5IGRlZmluZWQgYXMgYSBwcm9wLlwiKSwgdm0pO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBkZWZpbmVDb21wdXRlZCAoXG4gIHRhcmdldCxcbiAga2V5LFxuICB1c2VyRGVmXG4pIHtcbiAgdmFyIHNob3VsZENhY2hlID0gIWlzU2VydmVyUmVuZGVyaW5nKCk7XG4gIGlmICh0eXBlb2YgdXNlckRlZiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHNoYXJlZFByb3BlcnR5RGVmaW5pdGlvbi5nZXQgPSBzaG91bGRDYWNoZVxuICAgICAgPyBjcmVhdGVDb21wdXRlZEdldHRlcihrZXkpXG4gICAgICA6IGNyZWF0ZUdldHRlckludm9rZXIodXNlckRlZik7XG4gICAgc2hhcmVkUHJvcGVydHlEZWZpbml0aW9uLnNldCA9IG5vb3A7XG4gIH0gZWxzZSB7XG4gICAgc2hhcmVkUHJvcGVydHlEZWZpbml0aW9uLmdldCA9IHVzZXJEZWYuZ2V0XG4gICAgICA/IHNob3VsZENhY2hlICYmIHVzZXJEZWYuY2FjaGUgIT09IGZhbHNlXG4gICAgICAgID8gY3JlYXRlQ29tcHV0ZWRHZXR0ZXIoa2V5KVxuICAgICAgICA6IGNyZWF0ZUdldHRlckludm9rZXIodXNlckRlZi5nZXQpXG4gICAgICA6IG5vb3A7XG4gICAgc2hhcmVkUHJvcGVydHlEZWZpbml0aW9uLnNldCA9IHVzZXJEZWYuc2V0IHx8IG5vb3A7XG4gIH1cbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiZcbiAgICAgIHNoYXJlZFByb3BlcnR5RGVmaW5pdGlvbi5zZXQgPT09IG5vb3ApIHtcbiAgICBzaGFyZWRQcm9wZXJ0eURlZmluaXRpb24uc2V0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgd2FybihcbiAgICAgICAgKFwiQ29tcHV0ZWQgcHJvcGVydHkgXFxcIlwiICsga2V5ICsgXCJcXFwiIHdhcyBhc3NpZ25lZCB0byBidXQgaXQgaGFzIG5vIHNldHRlci5cIiksXG4gICAgICAgIHRoaXNcbiAgICAgICk7XG4gICAgfTtcbiAgfVxuICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHNoYXJlZFByb3BlcnR5RGVmaW5pdGlvbik7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUNvbXB1dGVkR2V0dGVyIChrZXkpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIGNvbXB1dGVkR2V0dGVyICgpIHtcbiAgICB2YXIgd2F0Y2hlciA9IHRoaXMuX2NvbXB1dGVkV2F0Y2hlcnMgJiYgdGhpcy5fY29tcHV0ZWRXYXRjaGVyc1trZXldO1xuICAgIGlmICh3YXRjaGVyKSB7XG4gICAgICBpZiAod2F0Y2hlci5kaXJ0eSkge1xuICAgICAgICB3YXRjaGVyLmV2YWx1YXRlKCk7XG4gICAgICB9XG4gICAgICBpZiAoRGVwLnRhcmdldCkge1xuICAgICAgICB3YXRjaGVyLmRlcGVuZCgpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHdhdGNoZXIudmFsdWVcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gY3JlYXRlR2V0dGVySW52b2tlcihmbikge1xuICByZXR1cm4gZnVuY3Rpb24gY29tcHV0ZWRHZXR0ZXIgKCkge1xuICAgIHJldHVybiBmbi5jYWxsKHRoaXMsIHRoaXMpXG4gIH1cbn1cblxuZnVuY3Rpb24gaW5pdE1ldGhvZHMgKHZtLCBtZXRob2RzKSB7XG4gIHZhciBwcm9wcyA9IHZtLiRvcHRpb25zLnByb3BzO1xuICBmb3IgKHZhciBrZXkgaW4gbWV0aG9kcykge1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICBpZiAodHlwZW9mIG1ldGhvZHNba2V5XSAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICB3YXJuKFxuICAgICAgICAgIFwiTWV0aG9kIFxcXCJcIiArIGtleSArIFwiXFxcIiBoYXMgdHlwZSBcXFwiXCIgKyAodHlwZW9mIG1ldGhvZHNba2V5XSkgKyBcIlxcXCIgaW4gdGhlIGNvbXBvbmVudCBkZWZpbml0aW9uLiBcIiArXG4gICAgICAgICAgXCJEaWQgeW91IHJlZmVyZW5jZSB0aGUgZnVuY3Rpb24gY29ycmVjdGx5P1wiLFxuICAgICAgICAgIHZtXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICBpZiAocHJvcHMgJiYgaGFzT3duKHByb3BzLCBrZXkpKSB7XG4gICAgICAgIHdhcm4oXG4gICAgICAgICAgKFwiTWV0aG9kIFxcXCJcIiArIGtleSArIFwiXFxcIiBoYXMgYWxyZWFkeSBiZWVuIGRlZmluZWQgYXMgYSBwcm9wLlwiKSxcbiAgICAgICAgICB2bVxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgaWYgKChrZXkgaW4gdm0pICYmIGlzUmVzZXJ2ZWQoa2V5KSkge1xuICAgICAgICB3YXJuKFxuICAgICAgICAgIFwiTWV0aG9kIFxcXCJcIiArIGtleSArIFwiXFxcIiBjb25mbGljdHMgd2l0aCBhbiBleGlzdGluZyBWdWUgaW5zdGFuY2UgbWV0aG9kLiBcIiArXG4gICAgICAgICAgXCJBdm9pZCBkZWZpbmluZyBjb21wb25lbnQgbWV0aG9kcyB0aGF0IHN0YXJ0IHdpdGggXyBvciAkLlwiXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfVxuICAgIHZtW2tleV0gPSB0eXBlb2YgbWV0aG9kc1trZXldICE9PSAnZnVuY3Rpb24nID8gbm9vcCA6IGJpbmQobWV0aG9kc1trZXldLCB2bSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gaW5pdFdhdGNoICh2bSwgd2F0Y2gpIHtcbiAgZm9yICh2YXIga2V5IGluIHdhdGNoKSB7XG4gICAgdmFyIGhhbmRsZXIgPSB3YXRjaFtrZXldO1xuICAgIGlmIChBcnJheS5pc0FycmF5KGhhbmRsZXIpKSB7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGhhbmRsZXIubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY3JlYXRlV2F0Y2hlcih2bSwga2V5LCBoYW5kbGVyW2ldKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgY3JlYXRlV2F0Y2hlcih2bSwga2V5LCBoYW5kbGVyKTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gY3JlYXRlV2F0Y2hlciAoXG4gIHZtLFxuICBleHBPckZuLFxuICBoYW5kbGVyLFxuICBvcHRpb25zXG4pIHtcbiAgaWYgKGlzUGxhaW5PYmplY3QoaGFuZGxlcikpIHtcbiAgICBvcHRpb25zID0gaGFuZGxlcjtcbiAgICBoYW5kbGVyID0gaGFuZGxlci5oYW5kbGVyO1xuICB9XG4gIGlmICh0eXBlb2YgaGFuZGxlciA9PT0gJ3N0cmluZycpIHtcbiAgICBoYW5kbGVyID0gdm1baGFuZGxlcl07XG4gIH1cbiAgcmV0dXJuIHZtLiR3YXRjaChleHBPckZuLCBoYW5kbGVyLCBvcHRpb25zKVxufVxuXG5mdW5jdGlvbiBzdGF0ZU1peGluIChWdWUpIHtcbiAgLy8gZmxvdyBzb21laG93IGhhcyBwcm9ibGVtcyB3aXRoIGRpcmVjdGx5IGRlY2xhcmVkIGRlZmluaXRpb24gb2JqZWN0XG4gIC8vIHdoZW4gdXNpbmcgT2JqZWN0LmRlZmluZVByb3BlcnR5LCBzbyB3ZSBoYXZlIHRvIHByb2NlZHVyYWxseSBidWlsZCB1cFxuICAvLyB0aGUgb2JqZWN0IGhlcmUuXG4gIHZhciBkYXRhRGVmID0ge307XG4gIGRhdGFEZWYuZ2V0ID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5fZGF0YSB9O1xuICB2YXIgcHJvcHNEZWYgPSB7fTtcbiAgcHJvcHNEZWYuZ2V0ID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5fcHJvcHMgfTtcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICBkYXRhRGVmLnNldCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHdhcm4oXG4gICAgICAgICdBdm9pZCByZXBsYWNpbmcgaW5zdGFuY2Ugcm9vdCAkZGF0YS4gJyArXG4gICAgICAgICdVc2UgbmVzdGVkIGRhdGEgcHJvcGVydGllcyBpbnN0ZWFkLicsXG4gICAgICAgIHRoaXNcbiAgICAgICk7XG4gICAgfTtcbiAgICBwcm9wc0RlZi5zZXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICB3YXJuKFwiJHByb3BzIGlzIHJlYWRvbmx5LlwiLCB0aGlzKTtcbiAgICB9O1xuICB9XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShWdWUucHJvdG90eXBlLCAnJGRhdGEnLCBkYXRhRGVmKTtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFZ1ZS5wcm90b3R5cGUsICckcHJvcHMnLCBwcm9wc0RlZik7XG5cbiAgVnVlLnByb3RvdHlwZS4kc2V0ID0gc2V0O1xuICBWdWUucHJvdG90eXBlLiRkZWxldGUgPSBkZWw7XG5cbiAgVnVlLnByb3RvdHlwZS4kd2F0Y2ggPSBmdW5jdGlvbiAoXG4gICAgZXhwT3JGbixcbiAgICBjYixcbiAgICBvcHRpb25zXG4gICkge1xuICAgIHZhciB2bSA9IHRoaXM7XG4gICAgaWYgKGlzUGxhaW5PYmplY3QoY2IpKSB7XG4gICAgICByZXR1cm4gY3JlYXRlV2F0Y2hlcih2bSwgZXhwT3JGbiwgY2IsIG9wdGlvbnMpXG4gICAgfVxuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICAgIG9wdGlvbnMudXNlciA9IHRydWU7XG4gICAgdmFyIHdhdGNoZXIgPSBuZXcgV2F0Y2hlcih2bSwgZXhwT3JGbiwgY2IsIG9wdGlvbnMpO1xuICAgIGlmIChvcHRpb25zLmltbWVkaWF0ZSkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgY2IuY2FsbCh2bSwgd2F0Y2hlci52YWx1ZSk7XG4gICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICBoYW5kbGVFcnJvcihlcnJvciwgdm0sIChcImNhbGxiYWNrIGZvciBpbW1lZGlhdGUgd2F0Y2hlciBcXFwiXCIgKyAod2F0Y2hlci5leHByZXNzaW9uKSArIFwiXFxcIlwiKSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBmdW5jdGlvbiB1bndhdGNoRm4gKCkge1xuICAgICAgd2F0Y2hlci50ZWFyZG93bigpO1xuICAgIH1cbiAgfTtcbn1cblxuLyogICovXG5cbnZhciB1aWQkMyA9IDA7XG5cbmZ1bmN0aW9uIGluaXRNaXhpbiAoVnVlKSB7XG4gIFZ1ZS5wcm90b3R5cGUuX2luaXQgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgIHZhciB2bSA9IHRoaXM7XG4gICAgLy8gYSB1aWRcbiAgICB2bS5fdWlkID0gdWlkJDMrKztcblxuICAgIHZhciBzdGFydFRhZywgZW5kVGFnO1xuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIGNvbmZpZy5wZXJmb3JtYW5jZSAmJiBtYXJrKSB7XG4gICAgICBzdGFydFRhZyA9IFwidnVlLXBlcmYtc3RhcnQ6XCIgKyAodm0uX3VpZCk7XG4gICAgICBlbmRUYWcgPSBcInZ1ZS1wZXJmLWVuZDpcIiArICh2bS5fdWlkKTtcbiAgICAgIG1hcmsoc3RhcnRUYWcpO1xuICAgIH1cblxuICAgIC8vIGEgZmxhZyB0byBhdm9pZCB0aGlzIGJlaW5nIG9ic2VydmVkXG4gICAgdm0uX2lzVnVlID0gdHJ1ZTtcbiAgICAvLyBtZXJnZSBvcHRpb25zXG4gICAgaWYgKG9wdGlvbnMgJiYgb3B0aW9ucy5faXNDb21wb25lbnQpIHtcbiAgICAgIC8vIG9wdGltaXplIGludGVybmFsIGNvbXBvbmVudCBpbnN0YW50aWF0aW9uXG4gICAgICAvLyBzaW5jZSBkeW5hbWljIG9wdGlvbnMgbWVyZ2luZyBpcyBwcmV0dHkgc2xvdywgYW5kIG5vbmUgb2YgdGhlXG4gICAgICAvLyBpbnRlcm5hbCBjb21wb25lbnQgb3B0aW9ucyBuZWVkcyBzcGVjaWFsIHRyZWF0bWVudC5cbiAgICAgIGluaXRJbnRlcm5hbENvbXBvbmVudCh2bSwgb3B0aW9ucyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZtLiRvcHRpb25zID0gbWVyZ2VPcHRpb25zKFxuICAgICAgICByZXNvbHZlQ29uc3RydWN0b3JPcHRpb25zKHZtLmNvbnN0cnVjdG9yKSxcbiAgICAgICAgb3B0aW9ucyB8fCB7fSxcbiAgICAgICAgdm1cbiAgICAgICk7XG4gICAgfVxuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovXG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIGluaXRQcm94eSh2bSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZtLl9yZW5kZXJQcm94eSA9IHZtO1xuICAgIH1cbiAgICAvLyBleHBvc2UgcmVhbCBzZWxmXG4gICAgdm0uX3NlbGYgPSB2bTtcbiAgICBpbml0TGlmZWN5Y2xlKHZtKTtcbiAgICBpbml0RXZlbnRzKHZtKTtcbiAgICBpbml0UmVuZGVyKHZtKTtcbiAgICBjYWxsSG9vayh2bSwgJ2JlZm9yZUNyZWF0ZScpO1xuICAgIGluaXRJbmplY3Rpb25zKHZtKTsgLy8gcmVzb2x2ZSBpbmplY3Rpb25zIGJlZm9yZSBkYXRhL3Byb3BzXG4gICAgaW5pdFN0YXRlKHZtKTtcbiAgICBpbml0UHJvdmlkZSh2bSk7IC8vIHJlc29sdmUgcHJvdmlkZSBhZnRlciBkYXRhL3Byb3BzXG4gICAgY2FsbEhvb2sodm0sICdjcmVhdGVkJyk7XG5cbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiBjb25maWcucGVyZm9ybWFuY2UgJiYgbWFyaykge1xuICAgICAgdm0uX25hbWUgPSBmb3JtYXRDb21wb25lbnROYW1lKHZtLCBmYWxzZSk7XG4gICAgICBtYXJrKGVuZFRhZyk7XG4gICAgICBtZWFzdXJlKChcInZ1ZSBcIiArICh2bS5fbmFtZSkgKyBcIiBpbml0XCIpLCBzdGFydFRhZywgZW5kVGFnKTtcbiAgICB9XG5cbiAgICBpZiAodm0uJG9wdGlvbnMuZWwpIHtcbiAgICAgIHZtLiRtb3VudCh2bS4kb3B0aW9ucy5lbCk7XG4gICAgfVxuICB9O1xufVxuXG5mdW5jdGlvbiBpbml0SW50ZXJuYWxDb21wb25lbnQgKHZtLCBvcHRpb25zKSB7XG4gIHZhciBvcHRzID0gdm0uJG9wdGlvbnMgPSBPYmplY3QuY3JlYXRlKHZtLmNvbnN0cnVjdG9yLm9wdGlvbnMpO1xuICAvLyBkb2luZyB0aGlzIGJlY2F1c2UgaXQncyBmYXN0ZXIgdGhhbiBkeW5hbWljIGVudW1lcmF0aW9uLlxuICB2YXIgcGFyZW50Vm5vZGUgPSBvcHRpb25zLl9wYXJlbnRWbm9kZTtcbiAgb3B0cy5wYXJlbnQgPSBvcHRpb25zLnBhcmVudDtcbiAgb3B0cy5fcGFyZW50Vm5vZGUgPSBwYXJlbnRWbm9kZTtcblxuICB2YXIgdm5vZGVDb21wb25lbnRPcHRpb25zID0gcGFyZW50Vm5vZGUuY29tcG9uZW50T3B0aW9ucztcbiAgb3B0cy5wcm9wc0RhdGEgPSB2bm9kZUNvbXBvbmVudE9wdGlvbnMucHJvcHNEYXRhO1xuICBvcHRzLl9wYXJlbnRMaXN0ZW5lcnMgPSB2bm9kZUNvbXBvbmVudE9wdGlvbnMubGlzdGVuZXJzO1xuICBvcHRzLl9yZW5kZXJDaGlsZHJlbiA9IHZub2RlQ29tcG9uZW50T3B0aW9ucy5jaGlsZHJlbjtcbiAgb3B0cy5fY29tcG9uZW50VGFnID0gdm5vZGVDb21wb25lbnRPcHRpb25zLnRhZztcblxuICBpZiAob3B0aW9ucy5yZW5kZXIpIHtcbiAgICBvcHRzLnJlbmRlciA9IG9wdGlvbnMucmVuZGVyO1xuICAgIG9wdHMuc3RhdGljUmVuZGVyRm5zID0gb3B0aW9ucy5zdGF0aWNSZW5kZXJGbnM7XG4gIH1cbn1cblxuZnVuY3Rpb24gcmVzb2x2ZUNvbnN0cnVjdG9yT3B0aW9ucyAoQ3Rvcikge1xuICB2YXIgb3B0aW9ucyA9IEN0b3Iub3B0aW9ucztcbiAgaWYgKEN0b3Iuc3VwZXIpIHtcbiAgICB2YXIgc3VwZXJPcHRpb25zID0gcmVzb2x2ZUNvbnN0cnVjdG9yT3B0aW9ucyhDdG9yLnN1cGVyKTtcbiAgICB2YXIgY2FjaGVkU3VwZXJPcHRpb25zID0gQ3Rvci5zdXBlck9wdGlvbnM7XG4gICAgaWYgKHN1cGVyT3B0aW9ucyAhPT0gY2FjaGVkU3VwZXJPcHRpb25zKSB7XG4gICAgICAvLyBzdXBlciBvcHRpb24gY2hhbmdlZCxcbiAgICAgIC8vIG5lZWQgdG8gcmVzb2x2ZSBuZXcgb3B0aW9ucy5cbiAgICAgIEN0b3Iuc3VwZXJPcHRpb25zID0gc3VwZXJPcHRpb25zO1xuICAgICAgLy8gY2hlY2sgaWYgdGhlcmUgYXJlIGFueSBsYXRlLW1vZGlmaWVkL2F0dGFjaGVkIG9wdGlvbnMgKCM0OTc2KVxuICAgICAgdmFyIG1vZGlmaWVkT3B0aW9ucyA9IHJlc29sdmVNb2RpZmllZE9wdGlvbnMoQ3Rvcik7XG4gICAgICAvLyB1cGRhdGUgYmFzZSBleHRlbmQgb3B0aW9uc1xuICAgICAgaWYgKG1vZGlmaWVkT3B0aW9ucykge1xuICAgICAgICBleHRlbmQoQ3Rvci5leHRlbmRPcHRpb25zLCBtb2RpZmllZE9wdGlvbnMpO1xuICAgICAgfVxuICAgICAgb3B0aW9ucyA9IEN0b3Iub3B0aW9ucyA9IG1lcmdlT3B0aW9ucyhzdXBlck9wdGlvbnMsIEN0b3IuZXh0ZW5kT3B0aW9ucyk7XG4gICAgICBpZiAob3B0aW9ucy5uYW1lKSB7XG4gICAgICAgIG9wdGlvbnMuY29tcG9uZW50c1tvcHRpb25zLm5hbWVdID0gQ3RvcjtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIG9wdGlvbnNcbn1cblxuZnVuY3Rpb24gcmVzb2x2ZU1vZGlmaWVkT3B0aW9ucyAoQ3Rvcikge1xuICB2YXIgbW9kaWZpZWQ7XG4gIHZhciBsYXRlc3QgPSBDdG9yLm9wdGlvbnM7XG4gIHZhciBzZWFsZWQgPSBDdG9yLnNlYWxlZE9wdGlvbnM7XG4gIGZvciAodmFyIGtleSBpbiBsYXRlc3QpIHtcbiAgICBpZiAobGF0ZXN0W2tleV0gIT09IHNlYWxlZFtrZXldKSB7XG4gICAgICBpZiAoIW1vZGlmaWVkKSB7IG1vZGlmaWVkID0ge307IH1cbiAgICAgIG1vZGlmaWVkW2tleV0gPSBsYXRlc3Rba2V5XTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIG1vZGlmaWVkXG59XG5cbmZ1bmN0aW9uIFZ1ZSAob3B0aW9ucykge1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJlxuICAgICEodGhpcyBpbnN0YW5jZW9mIFZ1ZSlcbiAgKSB7XG4gICAgd2FybignVnVlIGlzIGEgY29uc3RydWN0b3IgYW5kIHNob3VsZCBiZSBjYWxsZWQgd2l0aCB0aGUgYG5ld2Aga2V5d29yZCcpO1xuICB9XG4gIHRoaXMuX2luaXQob3B0aW9ucyk7XG59XG5cbmluaXRNaXhpbihWdWUpO1xuc3RhdGVNaXhpbihWdWUpO1xuZXZlbnRzTWl4aW4oVnVlKTtcbmxpZmVjeWNsZU1peGluKFZ1ZSk7XG5yZW5kZXJNaXhpbihWdWUpO1xuXG4vKiAgKi9cblxuZnVuY3Rpb24gaW5pdFVzZSAoVnVlKSB7XG4gIFZ1ZS51c2UgPSBmdW5jdGlvbiAocGx1Z2luKSB7XG4gICAgdmFyIGluc3RhbGxlZFBsdWdpbnMgPSAodGhpcy5faW5zdGFsbGVkUGx1Z2lucyB8fCAodGhpcy5faW5zdGFsbGVkUGx1Z2lucyA9IFtdKSk7XG4gICAgaWYgKGluc3RhbGxlZFBsdWdpbnMuaW5kZXhPZihwbHVnaW4pID4gLTEpIHtcbiAgICAgIHJldHVybiB0aGlzXG4gICAgfVxuXG4gICAgLy8gYWRkaXRpb25hbCBwYXJhbWV0ZXJzXG4gICAgdmFyIGFyZ3MgPSB0b0FycmF5KGFyZ3VtZW50cywgMSk7XG4gICAgYXJncy51bnNoaWZ0KHRoaXMpO1xuICAgIGlmICh0eXBlb2YgcGx1Z2luLmluc3RhbGwgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHBsdWdpbi5pbnN0YWxsLmFwcGx5KHBsdWdpbiwgYXJncyk7XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgcGx1Z2luID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBwbHVnaW4uYXBwbHkobnVsbCwgYXJncyk7XG4gICAgfVxuICAgIGluc3RhbGxlZFBsdWdpbnMucHVzaChwbHVnaW4pO1xuICAgIHJldHVybiB0aGlzXG4gIH07XG59XG5cbi8qICAqL1xuXG5mdW5jdGlvbiBpbml0TWl4aW4kMSAoVnVlKSB7XG4gIFZ1ZS5taXhpbiA9IGZ1bmN0aW9uIChtaXhpbikge1xuICAgIHRoaXMub3B0aW9ucyA9IG1lcmdlT3B0aW9ucyh0aGlzLm9wdGlvbnMsIG1peGluKTtcbiAgICByZXR1cm4gdGhpc1xuICB9O1xufVxuXG4vKiAgKi9cblxuZnVuY3Rpb24gaW5pdEV4dGVuZCAoVnVlKSB7XG4gIC8qKlxuICAgKiBFYWNoIGluc3RhbmNlIGNvbnN0cnVjdG9yLCBpbmNsdWRpbmcgVnVlLCBoYXMgYSB1bmlxdWVcbiAgICogY2lkLiBUaGlzIGVuYWJsZXMgdXMgdG8gY3JlYXRlIHdyYXBwZWQgXCJjaGlsZFxuICAgKiBjb25zdHJ1Y3RvcnNcIiBmb3IgcHJvdG90eXBhbCBpbmhlcml0YW5jZSBhbmQgY2FjaGUgdGhlbS5cbiAgICovXG4gIFZ1ZS5jaWQgPSAwO1xuICB2YXIgY2lkID0gMTtcblxuICAvKipcbiAgICogQ2xhc3MgaW5oZXJpdGFuY2VcbiAgICovXG4gIFZ1ZS5leHRlbmQgPSBmdW5jdGlvbiAoZXh0ZW5kT3B0aW9ucykge1xuICAgIGV4dGVuZE9wdGlvbnMgPSBleHRlbmRPcHRpb25zIHx8IHt9O1xuICAgIHZhciBTdXBlciA9IHRoaXM7XG4gICAgdmFyIFN1cGVySWQgPSBTdXBlci5jaWQ7XG4gICAgdmFyIGNhY2hlZEN0b3JzID0gZXh0ZW5kT3B0aW9ucy5fQ3RvciB8fCAoZXh0ZW5kT3B0aW9ucy5fQ3RvciA9IHt9KTtcbiAgICBpZiAoY2FjaGVkQ3RvcnNbU3VwZXJJZF0pIHtcbiAgICAgIHJldHVybiBjYWNoZWRDdG9yc1tTdXBlcklkXVxuICAgIH1cblxuICAgIHZhciBuYW1lID0gZXh0ZW5kT3B0aW9ucy5uYW1lIHx8IFN1cGVyLm9wdGlvbnMubmFtZTtcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiBuYW1lKSB7XG4gICAgICB2YWxpZGF0ZUNvbXBvbmVudE5hbWUobmFtZSk7XG4gICAgfVxuXG4gICAgdmFyIFN1YiA9IGZ1bmN0aW9uIFZ1ZUNvbXBvbmVudCAob3B0aW9ucykge1xuICAgICAgdGhpcy5faW5pdChvcHRpb25zKTtcbiAgICB9O1xuICAgIFN1Yi5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKFN1cGVyLnByb3RvdHlwZSk7XG4gICAgU3ViLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFN1YjtcbiAgICBTdWIuY2lkID0gY2lkKys7XG4gICAgU3ViLm9wdGlvbnMgPSBtZXJnZU9wdGlvbnMoXG4gICAgICBTdXBlci5vcHRpb25zLFxuICAgICAgZXh0ZW5kT3B0aW9uc1xuICAgICk7XG4gICAgU3ViWydzdXBlciddID0gU3VwZXI7XG5cbiAgICAvLyBGb3IgcHJvcHMgYW5kIGNvbXB1dGVkIHByb3BlcnRpZXMsIHdlIGRlZmluZSB0aGUgcHJveHkgZ2V0dGVycyBvblxuICAgIC8vIHRoZSBWdWUgaW5zdGFuY2VzIGF0IGV4dGVuc2lvbiB0aW1lLCBvbiB0aGUgZXh0ZW5kZWQgcHJvdG90eXBlLiBUaGlzXG4gICAgLy8gYXZvaWRzIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSBjYWxscyBmb3IgZWFjaCBpbnN0YW5jZSBjcmVhdGVkLlxuICAgIGlmIChTdWIub3B0aW9ucy5wcm9wcykge1xuICAgICAgaW5pdFByb3BzJDEoU3ViKTtcbiAgICB9XG4gICAgaWYgKFN1Yi5vcHRpb25zLmNvbXB1dGVkKSB7XG4gICAgICBpbml0Q29tcHV0ZWQkMShTdWIpO1xuICAgIH1cblxuICAgIC8vIGFsbG93IGZ1cnRoZXIgZXh0ZW5zaW9uL21peGluL3BsdWdpbiB1c2FnZVxuICAgIFN1Yi5leHRlbmQgPSBTdXBlci5leHRlbmQ7XG4gICAgU3ViLm1peGluID0gU3VwZXIubWl4aW47XG4gICAgU3ViLnVzZSA9IFN1cGVyLnVzZTtcblxuICAgIC8vIGNyZWF0ZSBhc3NldCByZWdpc3RlcnMsIHNvIGV4dGVuZGVkIGNsYXNzZXNcbiAgICAvLyBjYW4gaGF2ZSB0aGVpciBwcml2YXRlIGFzc2V0cyB0b28uXG4gICAgQVNTRVRfVFlQRVMuZm9yRWFjaChmdW5jdGlvbiAodHlwZSkge1xuICAgICAgU3ViW3R5cGVdID0gU3VwZXJbdHlwZV07XG4gICAgfSk7XG4gICAgLy8gZW5hYmxlIHJlY3Vyc2l2ZSBzZWxmLWxvb2t1cFxuICAgIGlmIChuYW1lKSB7XG4gICAgICBTdWIub3B0aW9ucy5jb21wb25lbnRzW25hbWVdID0gU3ViO1xuICAgIH1cblxuICAgIC8vIGtlZXAgYSByZWZlcmVuY2UgdG8gdGhlIHN1cGVyIG9wdGlvbnMgYXQgZXh0ZW5zaW9uIHRpbWUuXG4gICAgLy8gbGF0ZXIgYXQgaW5zdGFudGlhdGlvbiB3ZSBjYW4gY2hlY2sgaWYgU3VwZXIncyBvcHRpb25zIGhhdmVcbiAgICAvLyBiZWVuIHVwZGF0ZWQuXG4gICAgU3ViLnN1cGVyT3B0aW9ucyA9IFN1cGVyLm9wdGlvbnM7XG4gICAgU3ViLmV4dGVuZE9wdGlvbnMgPSBleHRlbmRPcHRpb25zO1xuICAgIFN1Yi5zZWFsZWRPcHRpb25zID0gZXh0ZW5kKHt9LCBTdWIub3B0aW9ucyk7XG5cbiAgICAvLyBjYWNoZSBjb25zdHJ1Y3RvclxuICAgIGNhY2hlZEN0b3JzW1N1cGVySWRdID0gU3ViO1xuICAgIHJldHVybiBTdWJcbiAgfTtcbn1cblxuZnVuY3Rpb24gaW5pdFByb3BzJDEgKENvbXApIHtcbiAgdmFyIHByb3BzID0gQ29tcC5vcHRpb25zLnByb3BzO1xuICBmb3IgKHZhciBrZXkgaW4gcHJvcHMpIHtcbiAgICBwcm94eShDb21wLnByb3RvdHlwZSwgXCJfcHJvcHNcIiwga2V5KTtcbiAgfVxufVxuXG5mdW5jdGlvbiBpbml0Q29tcHV0ZWQkMSAoQ29tcCkge1xuICB2YXIgY29tcHV0ZWQgPSBDb21wLm9wdGlvbnMuY29tcHV0ZWQ7XG4gIGZvciAodmFyIGtleSBpbiBjb21wdXRlZCkge1xuICAgIGRlZmluZUNvbXB1dGVkKENvbXAucHJvdG90eXBlLCBrZXksIGNvbXB1dGVkW2tleV0pO1xuICB9XG59XG5cbi8qICAqL1xuXG5mdW5jdGlvbiBpbml0QXNzZXRSZWdpc3RlcnMgKFZ1ZSkge1xuICAvKipcbiAgICogQ3JlYXRlIGFzc2V0IHJlZ2lzdHJhdGlvbiBtZXRob2RzLlxuICAgKi9cbiAgQVNTRVRfVFlQRVMuZm9yRWFjaChmdW5jdGlvbiAodHlwZSkge1xuICAgIFZ1ZVt0eXBlXSA9IGZ1bmN0aW9uIChcbiAgICAgIGlkLFxuICAgICAgZGVmaW5pdGlvblxuICAgICkge1xuICAgICAgaWYgKCFkZWZpbml0aW9uKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm9wdGlvbnNbdHlwZSArICdzJ11baWRdXG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgdHlwZSA9PT0gJ2NvbXBvbmVudCcpIHtcbiAgICAgICAgICB2YWxpZGF0ZUNvbXBvbmVudE5hbWUoaWQpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlID09PSAnY29tcG9uZW50JyAmJiBpc1BsYWluT2JqZWN0KGRlZmluaXRpb24pKSB7XG4gICAgICAgICAgZGVmaW5pdGlvbi5uYW1lID0gZGVmaW5pdGlvbi5uYW1lIHx8IGlkO1xuICAgICAgICAgIGRlZmluaXRpb24gPSB0aGlzLm9wdGlvbnMuX2Jhc2UuZXh0ZW5kKGRlZmluaXRpb24pO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlID09PSAnZGlyZWN0aXZlJyAmJiB0eXBlb2YgZGVmaW5pdGlvbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgIGRlZmluaXRpb24gPSB7IGJpbmQ6IGRlZmluaXRpb24sIHVwZGF0ZTogZGVmaW5pdGlvbiB9O1xuICAgICAgICB9XG4gICAgICAgIHRoaXMub3B0aW9uc1t0eXBlICsgJ3MnXVtpZF0gPSBkZWZpbml0aW9uO1xuICAgICAgICByZXR1cm4gZGVmaW5pdGlvblxuICAgICAgfVxuICAgIH07XG4gIH0pO1xufVxuXG4vKiAgKi9cblxuXG5cbmZ1bmN0aW9uIGdldENvbXBvbmVudE5hbWUgKG9wdHMpIHtcbiAgcmV0dXJuIG9wdHMgJiYgKG9wdHMuQ3Rvci5vcHRpb25zLm5hbWUgfHwgb3B0cy50YWcpXG59XG5cbmZ1bmN0aW9uIG1hdGNoZXMgKHBhdHRlcm4sIG5hbWUpIHtcbiAgaWYgKEFycmF5LmlzQXJyYXkocGF0dGVybikpIHtcbiAgICByZXR1cm4gcGF0dGVybi5pbmRleE9mKG5hbWUpID4gLTFcbiAgfSBlbHNlIGlmICh0eXBlb2YgcGF0dGVybiA9PT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gcGF0dGVybi5zcGxpdCgnLCcpLmluZGV4T2YobmFtZSkgPiAtMVxuICB9IGVsc2UgaWYgKGlzUmVnRXhwKHBhdHRlcm4pKSB7XG4gICAgcmV0dXJuIHBhdHRlcm4udGVzdChuYW1lKVxuICB9XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gIHJldHVybiBmYWxzZVxufVxuXG5mdW5jdGlvbiBwcnVuZUNhY2hlIChrZWVwQWxpdmVJbnN0YW5jZSwgZmlsdGVyKSB7XG4gIHZhciBjYWNoZSA9IGtlZXBBbGl2ZUluc3RhbmNlLmNhY2hlO1xuICB2YXIga2V5cyA9IGtlZXBBbGl2ZUluc3RhbmNlLmtleXM7XG4gIHZhciBfdm5vZGUgPSBrZWVwQWxpdmVJbnN0YW5jZS5fdm5vZGU7XG4gIGZvciAodmFyIGtleSBpbiBjYWNoZSkge1xuICAgIHZhciBjYWNoZWROb2RlID0gY2FjaGVba2V5XTtcbiAgICBpZiAoY2FjaGVkTm9kZSkge1xuICAgICAgdmFyIG5hbWUgPSBnZXRDb21wb25lbnROYW1lKGNhY2hlZE5vZGUuY29tcG9uZW50T3B0aW9ucyk7XG4gICAgICBpZiAobmFtZSAmJiAhZmlsdGVyKG5hbWUpKSB7XG4gICAgICAgIHBydW5lQ2FjaGVFbnRyeShjYWNoZSwga2V5LCBrZXlzLCBfdm5vZGUpO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBwcnVuZUNhY2hlRW50cnkgKFxuICBjYWNoZSxcbiAga2V5LFxuICBrZXlzLFxuICBjdXJyZW50XG4pIHtcbiAgdmFyIGNhY2hlZCQkMSA9IGNhY2hlW2tleV07XG4gIGlmIChjYWNoZWQkJDEgJiYgKCFjdXJyZW50IHx8IGNhY2hlZCQkMS50YWcgIT09IGN1cnJlbnQudGFnKSkge1xuICAgIGNhY2hlZCQkMS5jb21wb25lbnRJbnN0YW5jZS4kZGVzdHJveSgpO1xuICB9XG4gIGNhY2hlW2tleV0gPSBudWxsO1xuICByZW1vdmUoa2V5cywga2V5KTtcbn1cblxudmFyIHBhdHRlcm5UeXBlcyA9IFtTdHJpbmcsIFJlZ0V4cCwgQXJyYXldO1xuXG52YXIgS2VlcEFsaXZlID0ge1xuICBuYW1lOiAna2VlcC1hbGl2ZScsXG4gIGFic3RyYWN0OiB0cnVlLFxuXG4gIHByb3BzOiB7XG4gICAgaW5jbHVkZTogcGF0dGVyblR5cGVzLFxuICAgIGV4Y2x1ZGU6IHBhdHRlcm5UeXBlcyxcbiAgICBtYXg6IFtTdHJpbmcsIE51bWJlcl1cbiAgfSxcblxuICBjcmVhdGVkOiBmdW5jdGlvbiBjcmVhdGVkICgpIHtcbiAgICB0aGlzLmNhY2hlID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICB0aGlzLmtleXMgPSBbXTtcbiAgfSxcblxuICBkZXN0cm95ZWQ6IGZ1bmN0aW9uIGRlc3Ryb3llZCAoKSB7XG4gICAgZm9yICh2YXIga2V5IGluIHRoaXMuY2FjaGUpIHtcbiAgICAgIHBydW5lQ2FjaGVFbnRyeSh0aGlzLmNhY2hlLCBrZXksIHRoaXMua2V5cyk7XG4gICAgfVxuICB9LFxuXG4gIG1vdW50ZWQ6IGZ1bmN0aW9uIG1vdW50ZWQgKCkge1xuICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gICAgdGhpcy4kd2F0Y2goJ2luY2x1ZGUnLCBmdW5jdGlvbiAodmFsKSB7XG4gICAgICBwcnVuZUNhY2hlKHRoaXMkMSwgZnVuY3Rpb24gKG5hbWUpIHsgcmV0dXJuIG1hdGNoZXModmFsLCBuYW1lKTsgfSk7XG4gICAgfSk7XG4gICAgdGhpcy4kd2F0Y2goJ2V4Y2x1ZGUnLCBmdW5jdGlvbiAodmFsKSB7XG4gICAgICBwcnVuZUNhY2hlKHRoaXMkMSwgZnVuY3Rpb24gKG5hbWUpIHsgcmV0dXJuICFtYXRjaGVzKHZhbCwgbmFtZSk7IH0pO1xuICAgIH0pO1xuICB9LFxuXG4gIHJlbmRlcjogZnVuY3Rpb24gcmVuZGVyICgpIHtcbiAgICB2YXIgc2xvdCA9IHRoaXMuJHNsb3RzLmRlZmF1bHQ7XG4gICAgdmFyIHZub2RlID0gZ2V0Rmlyc3RDb21wb25lbnRDaGlsZChzbG90KTtcbiAgICB2YXIgY29tcG9uZW50T3B0aW9ucyA9IHZub2RlICYmIHZub2RlLmNvbXBvbmVudE9wdGlvbnM7XG4gICAgaWYgKGNvbXBvbmVudE9wdGlvbnMpIHtcbiAgICAgIC8vIGNoZWNrIHBhdHRlcm5cbiAgICAgIHZhciBuYW1lID0gZ2V0Q29tcG9uZW50TmFtZShjb21wb25lbnRPcHRpb25zKTtcbiAgICAgIHZhciByZWYgPSB0aGlzO1xuICAgICAgdmFyIGluY2x1ZGUgPSByZWYuaW5jbHVkZTtcbiAgICAgIHZhciBleGNsdWRlID0gcmVmLmV4Y2x1ZGU7XG4gICAgICBpZiAoXG4gICAgICAgIC8vIG5vdCBpbmNsdWRlZFxuICAgICAgICAoaW5jbHVkZSAmJiAoIW5hbWUgfHwgIW1hdGNoZXMoaW5jbHVkZSwgbmFtZSkpKSB8fFxuICAgICAgICAvLyBleGNsdWRlZFxuICAgICAgICAoZXhjbHVkZSAmJiBuYW1lICYmIG1hdGNoZXMoZXhjbHVkZSwgbmFtZSkpXG4gICAgICApIHtcbiAgICAgICAgcmV0dXJuIHZub2RlXG4gICAgICB9XG5cbiAgICAgIHZhciByZWYkMSA9IHRoaXM7XG4gICAgICB2YXIgY2FjaGUgPSByZWYkMS5jYWNoZTtcbiAgICAgIHZhciBrZXlzID0gcmVmJDEua2V5cztcbiAgICAgIHZhciBrZXkgPSB2bm9kZS5rZXkgPT0gbnVsbFxuICAgICAgICAvLyBzYW1lIGNvbnN0cnVjdG9yIG1heSBnZXQgcmVnaXN0ZXJlZCBhcyBkaWZmZXJlbnQgbG9jYWwgY29tcG9uZW50c1xuICAgICAgICAvLyBzbyBjaWQgYWxvbmUgaXMgbm90IGVub3VnaCAoIzMyNjkpXG4gICAgICAgID8gY29tcG9uZW50T3B0aW9ucy5DdG9yLmNpZCArIChjb21wb25lbnRPcHRpb25zLnRhZyA/IChcIjo6XCIgKyAoY29tcG9uZW50T3B0aW9ucy50YWcpKSA6ICcnKVxuICAgICAgICA6IHZub2RlLmtleTtcbiAgICAgIGlmIChjYWNoZVtrZXldKSB7XG4gICAgICAgIHZub2RlLmNvbXBvbmVudEluc3RhbmNlID0gY2FjaGVba2V5XS5jb21wb25lbnRJbnN0YW5jZTtcbiAgICAgICAgLy8gbWFrZSBjdXJyZW50IGtleSBmcmVzaGVzdFxuICAgICAgICByZW1vdmUoa2V5cywga2V5KTtcbiAgICAgICAga2V5cy5wdXNoKGtleSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjYWNoZVtrZXldID0gdm5vZGU7XG4gICAgICAgIGtleXMucHVzaChrZXkpO1xuICAgICAgICAvLyBwcnVuZSBvbGRlc3QgZW50cnlcbiAgICAgICAgaWYgKHRoaXMubWF4ICYmIGtleXMubGVuZ3RoID4gcGFyc2VJbnQodGhpcy5tYXgpKSB7XG4gICAgICAgICAgcHJ1bmVDYWNoZUVudHJ5KGNhY2hlLCBrZXlzWzBdLCBrZXlzLCB0aGlzLl92bm9kZSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdm5vZGUuZGF0YS5rZWVwQWxpdmUgPSB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gdm5vZGUgfHwgKHNsb3QgJiYgc2xvdFswXSlcbiAgfVxufTtcblxudmFyIGJ1aWx0SW5Db21wb25lbnRzID0ge1xuICBLZWVwQWxpdmU6IEtlZXBBbGl2ZVxufTtcblxuLyogICovXG5cbmZ1bmN0aW9uIGluaXRHbG9iYWxBUEkgKFZ1ZSkge1xuICAvLyBjb25maWdcbiAgdmFyIGNvbmZpZ0RlZiA9IHt9O1xuICBjb25maWdEZWYuZ2V0ID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gY29uZmlnOyB9O1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgIGNvbmZpZ0RlZi5zZXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICB3YXJuKFxuICAgICAgICAnRG8gbm90IHJlcGxhY2UgdGhlIFZ1ZS5jb25maWcgb2JqZWN0LCBzZXQgaW5kaXZpZHVhbCBmaWVsZHMgaW5zdGVhZC4nXG4gICAgICApO1xuICAgIH07XG4gIH1cbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFZ1ZSwgJ2NvbmZpZycsIGNvbmZpZ0RlZik7XG5cbiAgLy8gZXhwb3NlZCB1dGlsIG1ldGhvZHMuXG4gIC8vIE5PVEU6IHRoZXNlIGFyZSBub3QgY29uc2lkZXJlZCBwYXJ0IG9mIHRoZSBwdWJsaWMgQVBJIC0gYXZvaWQgcmVseWluZyBvblxuICAvLyB0aGVtIHVubGVzcyB5b3UgYXJlIGF3YXJlIG9mIHRoZSByaXNrLlxuICBWdWUudXRpbCA9IHtcbiAgICB3YXJuOiB3YXJuLFxuICAgIGV4dGVuZDogZXh0ZW5kLFxuICAgIG1lcmdlT3B0aW9uczogbWVyZ2VPcHRpb25zLFxuICAgIGRlZmluZVJlYWN0aXZlOiBkZWZpbmVSZWFjdGl2ZSQkMVxuICB9O1xuXG4gIFZ1ZS5zZXQgPSBzZXQ7XG4gIFZ1ZS5kZWxldGUgPSBkZWw7XG4gIFZ1ZS5uZXh0VGljayA9IG5leHRUaWNrO1xuXG4gIC8vIDIuNiBleHBsaWNpdCBvYnNlcnZhYmxlIEFQSVxuICBWdWUub2JzZXJ2YWJsZSA9IGZ1bmN0aW9uIChvYmopIHtcbiAgICBvYnNlcnZlKG9iaik7XG4gICAgcmV0dXJuIG9ialxuICB9O1xuXG4gIFZ1ZS5vcHRpb25zID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgQVNTRVRfVFlQRVMuZm9yRWFjaChmdW5jdGlvbiAodHlwZSkge1xuICAgIFZ1ZS5vcHRpb25zW3R5cGUgKyAncyddID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgfSk7XG5cbiAgLy8gdGhpcyBpcyB1c2VkIHRvIGlkZW50aWZ5IHRoZSBcImJhc2VcIiBjb25zdHJ1Y3RvciB0byBleHRlbmQgYWxsIHBsYWluLW9iamVjdFxuICAvLyBjb21wb25lbnRzIHdpdGggaW4gV2VleCdzIG11bHRpLWluc3RhbmNlIHNjZW5hcmlvcy5cbiAgVnVlLm9wdGlvbnMuX2Jhc2UgPSBWdWU7XG5cbiAgZXh0ZW5kKFZ1ZS5vcHRpb25zLmNvbXBvbmVudHMsIGJ1aWx0SW5Db21wb25lbnRzKTtcblxuICBpbml0VXNlKFZ1ZSk7XG4gIGluaXRNaXhpbiQxKFZ1ZSk7XG4gIGluaXRFeHRlbmQoVnVlKTtcbiAgaW5pdEFzc2V0UmVnaXN0ZXJzKFZ1ZSk7XG59XG5cbmluaXRHbG9iYWxBUEkoVnVlKTtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KFZ1ZS5wcm90b3R5cGUsICckaXNTZXJ2ZXInLCB7XG4gIGdldDogaXNTZXJ2ZXJSZW5kZXJpbmdcbn0pO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoVnVlLnByb3RvdHlwZSwgJyRzc3JDb250ZXh0Jywge1xuICBnZXQ6IGZ1bmN0aW9uIGdldCAoKSB7XG4gICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICByZXR1cm4gdGhpcy4kdm5vZGUgJiYgdGhpcy4kdm5vZGUuc3NyQ29udGV4dFxuICB9XG59KTtcblxuLy8gZXhwb3NlIEZ1bmN0aW9uYWxSZW5kZXJDb250ZXh0IGZvciBzc3IgcnVudGltZSBoZWxwZXIgaW5zdGFsbGF0aW9uXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoVnVlLCAnRnVuY3Rpb25hbFJlbmRlckNvbnRleHQnLCB7XG4gIHZhbHVlOiBGdW5jdGlvbmFsUmVuZGVyQ29udGV4dFxufSk7XG5cblZ1ZS52ZXJzaW9uID0gJzIuNi4xMCc7XG5cbi8qICAqL1xuXG4vLyB0aGVzZSBhcmUgcmVzZXJ2ZWQgZm9yIHdlYiBiZWNhdXNlIHRoZXkgYXJlIGRpcmVjdGx5IGNvbXBpbGVkIGF3YXlcbi8vIGR1cmluZyB0ZW1wbGF0ZSBjb21waWxhdGlvblxudmFyIGlzUmVzZXJ2ZWRBdHRyID0gbWFrZU1hcCgnc3R5bGUsY2xhc3MnKTtcblxuLy8gYXR0cmlidXRlcyB0aGF0IHNob3VsZCBiZSB1c2luZyBwcm9wcyBmb3IgYmluZGluZ1xudmFyIGFjY2VwdFZhbHVlID0gbWFrZU1hcCgnaW5wdXQsdGV4dGFyZWEsb3B0aW9uLHNlbGVjdCxwcm9ncmVzcycpO1xudmFyIG11c3RVc2VQcm9wID0gZnVuY3Rpb24gKHRhZywgdHlwZSwgYXR0cikge1xuICByZXR1cm4gKFxuICAgIChhdHRyID09PSAndmFsdWUnICYmIGFjY2VwdFZhbHVlKHRhZykpICYmIHR5cGUgIT09ICdidXR0b24nIHx8XG4gICAgKGF0dHIgPT09ICdzZWxlY3RlZCcgJiYgdGFnID09PSAnb3B0aW9uJykgfHxcbiAgICAoYXR0ciA9PT0gJ2NoZWNrZWQnICYmIHRhZyA9PT0gJ2lucHV0JykgfHxcbiAgICAoYXR0ciA9PT0gJ211dGVkJyAmJiB0YWcgPT09ICd2aWRlbycpXG4gIClcbn07XG5cbnZhciBpc0VudW1lcmF0ZWRBdHRyID0gbWFrZU1hcCgnY29udGVudGVkaXRhYmxlLGRyYWdnYWJsZSxzcGVsbGNoZWNrJyk7XG5cbnZhciBpc1ZhbGlkQ29udGVudEVkaXRhYmxlVmFsdWUgPSBtYWtlTWFwKCdldmVudHMsY2FyZXQsdHlwaW5nLHBsYWludGV4dC1vbmx5Jyk7XG5cbnZhciBjb252ZXJ0RW51bWVyYXRlZFZhbHVlID0gZnVuY3Rpb24gKGtleSwgdmFsdWUpIHtcbiAgcmV0dXJuIGlzRmFsc3lBdHRyVmFsdWUodmFsdWUpIHx8IHZhbHVlID09PSAnZmFsc2UnXG4gICAgPyAnZmFsc2UnXG4gICAgLy8gYWxsb3cgYXJiaXRyYXJ5IHN0cmluZyB2YWx1ZSBmb3IgY29udGVudGVkaXRhYmxlXG4gICAgOiBrZXkgPT09ICdjb250ZW50ZWRpdGFibGUnICYmIGlzVmFsaWRDb250ZW50RWRpdGFibGVWYWx1ZSh2YWx1ZSlcbiAgICAgID8gdmFsdWVcbiAgICAgIDogJ3RydWUnXG59O1xuXG52YXIgaXNCb29sZWFuQXR0ciA9IG1ha2VNYXAoXG4gICdhbGxvd2Z1bGxzY3JlZW4sYXN5bmMsYXV0b2ZvY3VzLGF1dG9wbGF5LGNoZWNrZWQsY29tcGFjdCxjb250cm9scyxkZWNsYXJlLCcgK1xuICAnZGVmYXVsdCxkZWZhdWx0Y2hlY2tlZCxkZWZhdWx0bXV0ZWQsZGVmYXVsdHNlbGVjdGVkLGRlZmVyLGRpc2FibGVkLCcgK1xuICAnZW5hYmxlZCxmb3Jtbm92YWxpZGF0ZSxoaWRkZW4saW5kZXRlcm1pbmF0ZSxpbmVydCxpc21hcCxpdGVtc2NvcGUsbG9vcCxtdWx0aXBsZSwnICtcbiAgJ211dGVkLG5vaHJlZixub3Jlc2l6ZSxub3NoYWRlLG5vdmFsaWRhdGUsbm93cmFwLG9wZW4scGF1c2VvbmV4aXQscmVhZG9ubHksJyArXG4gICdyZXF1aXJlZCxyZXZlcnNlZCxzY29wZWQsc2VhbWxlc3Msc2VsZWN0ZWQsc29ydGFibGUsdHJhbnNsYXRlLCcgK1xuICAndHJ1ZXNwZWVkLHR5cGVtdXN0bWF0Y2gsdmlzaWJsZSdcbik7XG5cbnZhciB4bGlua05TID0gJ2h0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsnO1xuXG52YXIgaXNYbGluayA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gIHJldHVybiBuYW1lLmNoYXJBdCg1KSA9PT0gJzonICYmIG5hbWUuc2xpY2UoMCwgNSkgPT09ICd4bGluaydcbn07XG5cbnZhciBnZXRYbGlua1Byb3AgPSBmdW5jdGlvbiAobmFtZSkge1xuICByZXR1cm4gaXNYbGluayhuYW1lKSA/IG5hbWUuc2xpY2UoNiwgbmFtZS5sZW5ndGgpIDogJydcbn07XG5cbnZhciBpc0ZhbHN5QXR0clZhbHVlID0gZnVuY3Rpb24gKHZhbCkge1xuICByZXR1cm4gdmFsID09IG51bGwgfHwgdmFsID09PSBmYWxzZVxufTtcblxuLyogICovXG5cbmZ1bmN0aW9uIGdlbkNsYXNzRm9yVm5vZGUgKHZub2RlKSB7XG4gIHZhciBkYXRhID0gdm5vZGUuZGF0YTtcbiAgdmFyIHBhcmVudE5vZGUgPSB2bm9kZTtcbiAgdmFyIGNoaWxkTm9kZSA9IHZub2RlO1xuICB3aGlsZSAoaXNEZWYoY2hpbGROb2RlLmNvbXBvbmVudEluc3RhbmNlKSkge1xuICAgIGNoaWxkTm9kZSA9IGNoaWxkTm9kZS5jb21wb25lbnRJbnN0YW5jZS5fdm5vZGU7XG4gICAgaWYgKGNoaWxkTm9kZSAmJiBjaGlsZE5vZGUuZGF0YSkge1xuICAgICAgZGF0YSA9IG1lcmdlQ2xhc3NEYXRhKGNoaWxkTm9kZS5kYXRhLCBkYXRhKTtcbiAgICB9XG4gIH1cbiAgd2hpbGUgKGlzRGVmKHBhcmVudE5vZGUgPSBwYXJlbnROb2RlLnBhcmVudCkpIHtcbiAgICBpZiAocGFyZW50Tm9kZSAmJiBwYXJlbnROb2RlLmRhdGEpIHtcbiAgICAgIGRhdGEgPSBtZXJnZUNsYXNzRGF0YShkYXRhLCBwYXJlbnROb2RlLmRhdGEpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVuZGVyQ2xhc3MoZGF0YS5zdGF0aWNDbGFzcywgZGF0YS5jbGFzcylcbn1cblxuZnVuY3Rpb24gbWVyZ2VDbGFzc0RhdGEgKGNoaWxkLCBwYXJlbnQpIHtcbiAgcmV0dXJuIHtcbiAgICBzdGF0aWNDbGFzczogY29uY2F0KGNoaWxkLnN0YXRpY0NsYXNzLCBwYXJlbnQuc3RhdGljQ2xhc3MpLFxuICAgIGNsYXNzOiBpc0RlZihjaGlsZC5jbGFzcylcbiAgICAgID8gW2NoaWxkLmNsYXNzLCBwYXJlbnQuY2xhc3NdXG4gICAgICA6IHBhcmVudC5jbGFzc1xuICB9XG59XG5cbmZ1bmN0aW9uIHJlbmRlckNsYXNzIChcbiAgc3RhdGljQ2xhc3MsXG4gIGR5bmFtaWNDbGFzc1xuKSB7XG4gIGlmIChpc0RlZihzdGF0aWNDbGFzcykgfHwgaXNEZWYoZHluYW1pY0NsYXNzKSkge1xuICAgIHJldHVybiBjb25jYXQoc3RhdGljQ2xhc3MsIHN0cmluZ2lmeUNsYXNzKGR5bmFtaWNDbGFzcykpXG4gIH1cbiAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgcmV0dXJuICcnXG59XG5cbmZ1bmN0aW9uIGNvbmNhdCAoYSwgYikge1xuICByZXR1cm4gYSA/IGIgPyAoYSArICcgJyArIGIpIDogYSA6IChiIHx8ICcnKVxufVxuXG5mdW5jdGlvbiBzdHJpbmdpZnlDbGFzcyAodmFsdWUpIHtcbiAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgcmV0dXJuIHN0cmluZ2lmeUFycmF5KHZhbHVlKVxuICB9XG4gIGlmIChpc09iamVjdCh2YWx1ZSkpIHtcbiAgICByZXR1cm4gc3RyaW5naWZ5T2JqZWN0KHZhbHVlKVxuICB9XG4gIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIHZhbHVlXG4gIH1cbiAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgcmV0dXJuICcnXG59XG5cbmZ1bmN0aW9uIHN0cmluZ2lmeUFycmF5ICh2YWx1ZSkge1xuICB2YXIgcmVzID0gJyc7XG4gIHZhciBzdHJpbmdpZmllZDtcbiAgZm9yICh2YXIgaSA9IDAsIGwgPSB2YWx1ZS5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICBpZiAoaXNEZWYoc3RyaW5naWZpZWQgPSBzdHJpbmdpZnlDbGFzcyh2YWx1ZVtpXSkpICYmIHN0cmluZ2lmaWVkICE9PSAnJykge1xuICAgICAgaWYgKHJlcykgeyByZXMgKz0gJyAnOyB9XG4gICAgICByZXMgKz0gc3RyaW5naWZpZWQ7XG4gICAgfVxuICB9XG4gIHJldHVybiByZXNcbn1cblxuZnVuY3Rpb24gc3RyaW5naWZ5T2JqZWN0ICh2YWx1ZSkge1xuICB2YXIgcmVzID0gJyc7XG4gIGZvciAodmFyIGtleSBpbiB2YWx1ZSkge1xuICAgIGlmICh2YWx1ZVtrZXldKSB7XG4gICAgICBpZiAocmVzKSB7IHJlcyArPSAnICc7IH1cbiAgICAgIHJlcyArPSBrZXk7XG4gICAgfVxuICB9XG4gIHJldHVybiByZXNcbn1cblxuLyogICovXG5cbnZhciBuYW1lc3BhY2VNYXAgPSB7XG4gIHN2ZzogJ2h0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnJyxcbiAgbWF0aDogJ2h0dHA6Ly93d3cudzMub3JnLzE5OTgvTWF0aC9NYXRoTUwnXG59O1xuXG52YXIgaXNIVE1MVGFnID0gbWFrZU1hcChcbiAgJ2h0bWwsYm9keSxiYXNlLGhlYWQsbGluayxtZXRhLHN0eWxlLHRpdGxlLCcgK1xuICAnYWRkcmVzcyxhcnRpY2xlLGFzaWRlLGZvb3RlcixoZWFkZXIsaDEsaDIsaDMsaDQsaDUsaDYsaGdyb3VwLG5hdixzZWN0aW9uLCcgK1xuICAnZGl2LGRkLGRsLGR0LGZpZ2NhcHRpb24sZmlndXJlLHBpY3R1cmUsaHIsaW1nLGxpLG1haW4sb2wscCxwcmUsdWwsJyArXG4gICdhLGIsYWJicixiZGksYmRvLGJyLGNpdGUsY29kZSxkYXRhLGRmbixlbSxpLGtiZCxtYXJrLHEscnAscnQscnRjLHJ1YnksJyArXG4gICdzLHNhbXAsc21hbGwsc3BhbixzdHJvbmcsc3ViLHN1cCx0aW1lLHUsdmFyLHdicixhcmVhLGF1ZGlvLG1hcCx0cmFjayx2aWRlbywnICtcbiAgJ2VtYmVkLG9iamVjdCxwYXJhbSxzb3VyY2UsY2FudmFzLHNjcmlwdCxub3NjcmlwdCxkZWwsaW5zLCcgK1xuICAnY2FwdGlvbixjb2wsY29sZ3JvdXAsdGFibGUsdGhlYWQsdGJvZHksdGQsdGgsdHIsJyArXG4gICdidXR0b24sZGF0YWxpc3QsZmllbGRzZXQsZm9ybSxpbnB1dCxsYWJlbCxsZWdlbmQsbWV0ZXIsb3B0Z3JvdXAsb3B0aW9uLCcgK1xuICAnb3V0cHV0LHByb2dyZXNzLHNlbGVjdCx0ZXh0YXJlYSwnICtcbiAgJ2RldGFpbHMsZGlhbG9nLG1lbnUsbWVudWl0ZW0sc3VtbWFyeSwnICtcbiAgJ2NvbnRlbnQsZWxlbWVudCxzaGFkb3csdGVtcGxhdGUsYmxvY2txdW90ZSxpZnJhbWUsdGZvb3QnXG4pO1xuXG4vLyB0aGlzIG1hcCBpcyBpbnRlbnRpb25hbGx5IHNlbGVjdGl2ZSwgb25seSBjb3ZlcmluZyBTVkcgZWxlbWVudHMgdGhhdCBtYXlcbi8vIGNvbnRhaW4gY2hpbGQgZWxlbWVudHMuXG52YXIgaXNTVkcgPSBtYWtlTWFwKFxuICAnc3ZnLGFuaW1hdGUsY2lyY2xlLGNsaXBwYXRoLGN1cnNvcixkZWZzLGRlc2MsZWxsaXBzZSxmaWx0ZXIsZm9udC1mYWNlLCcgK1xuICAnZm9yZWlnbk9iamVjdCxnLGdseXBoLGltYWdlLGxpbmUsbWFya2VyLG1hc2ssbWlzc2luZy1nbHlwaCxwYXRoLHBhdHRlcm4sJyArXG4gICdwb2x5Z29uLHBvbHlsaW5lLHJlY3Qsc3dpdGNoLHN5bWJvbCx0ZXh0LHRleHRwYXRoLHRzcGFuLHVzZSx2aWV3JyxcbiAgdHJ1ZVxuKTtcblxudmFyIGlzUHJlVGFnID0gZnVuY3Rpb24gKHRhZykgeyByZXR1cm4gdGFnID09PSAncHJlJzsgfTtcblxudmFyIGlzUmVzZXJ2ZWRUYWcgPSBmdW5jdGlvbiAodGFnKSB7XG4gIHJldHVybiBpc0hUTUxUYWcodGFnKSB8fCBpc1NWRyh0YWcpXG59O1xuXG5mdW5jdGlvbiBnZXRUYWdOYW1lc3BhY2UgKHRhZykge1xuICBpZiAoaXNTVkcodGFnKSkge1xuICAgIHJldHVybiAnc3ZnJ1xuICB9XG4gIC8vIGJhc2ljIHN1cHBvcnQgZm9yIE1hdGhNTFxuICAvLyBub3RlIGl0IGRvZXNuJ3Qgc3VwcG9ydCBvdGhlciBNYXRoTUwgZWxlbWVudHMgYmVpbmcgY29tcG9uZW50IHJvb3RzXG4gIGlmICh0YWcgPT09ICdtYXRoJykge1xuICAgIHJldHVybiAnbWF0aCdcbiAgfVxufVxuXG52YXIgdW5rbm93bkVsZW1lbnRDYWNoZSA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG5mdW5jdGlvbiBpc1Vua25vd25FbGVtZW50ICh0YWcpIHtcbiAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gIGlmICghaW5Ccm93c2VyKSB7XG4gICAgcmV0dXJuIHRydWVcbiAgfVxuICBpZiAoaXNSZXNlcnZlZFRhZyh0YWcpKSB7XG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cbiAgdGFnID0gdGFnLnRvTG93ZXJDYXNlKCk7XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICBpZiAodW5rbm93bkVsZW1lbnRDYWNoZVt0YWddICE9IG51bGwpIHtcbiAgICByZXR1cm4gdW5rbm93bkVsZW1lbnRDYWNoZVt0YWddXG4gIH1cbiAgdmFyIGVsID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCh0YWcpO1xuICBpZiAodGFnLmluZGV4T2YoJy0nKSA+IC0xKSB7XG4gICAgLy8gaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL2EvMjgyMTAzNjQvMTA3MDI0NFxuICAgIHJldHVybiAodW5rbm93bkVsZW1lbnRDYWNoZVt0YWddID0gKFxuICAgICAgZWwuY29uc3RydWN0b3IgPT09IHdpbmRvdy5IVE1MVW5rbm93bkVsZW1lbnQgfHxcbiAgICAgIGVsLmNvbnN0cnVjdG9yID09PSB3aW5kb3cuSFRNTEVsZW1lbnRcbiAgICApKVxuICB9IGVsc2Uge1xuICAgIHJldHVybiAodW5rbm93bkVsZW1lbnRDYWNoZVt0YWddID0gL0hUTUxVbmtub3duRWxlbWVudC8udGVzdChlbC50b1N0cmluZygpKSlcbiAgfVxufVxuXG52YXIgaXNUZXh0SW5wdXRUeXBlID0gbWFrZU1hcCgndGV4dCxudW1iZXIscGFzc3dvcmQsc2VhcmNoLGVtYWlsLHRlbCx1cmwnKTtcblxuLyogICovXG5cbi8qKlxuICogUXVlcnkgYW4gZWxlbWVudCBzZWxlY3RvciBpZiBpdCdzIG5vdCBhbiBlbGVtZW50IGFscmVhZHkuXG4gKi9cbmZ1bmN0aW9uIHF1ZXJ5IChlbCkge1xuICBpZiAodHlwZW9mIGVsID09PSAnc3RyaW5nJykge1xuICAgIHZhciBzZWxlY3RlZCA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoZWwpO1xuICAgIGlmICghc2VsZWN0ZWQpIHtcbiAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgd2FybihcbiAgICAgICAgJ0Nhbm5vdCBmaW5kIGVsZW1lbnQ6ICcgKyBlbFxuICAgICAgKTtcbiAgICAgIHJldHVybiBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKVxuICAgIH1cbiAgICByZXR1cm4gc2VsZWN0ZWRcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gZWxcbiAgfVxufVxuXG4vKiAgKi9cblxuZnVuY3Rpb24gY3JlYXRlRWxlbWVudCQxICh0YWdOYW1lLCB2bm9kZSkge1xuICB2YXIgZWxtID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCh0YWdOYW1lKTtcbiAgaWYgKHRhZ05hbWUgIT09ICdzZWxlY3QnKSB7XG4gICAgcmV0dXJuIGVsbVxuICB9XG4gIC8vIGZhbHNlIG9yIG51bGwgd2lsbCByZW1vdmUgdGhlIGF0dHJpYnV0ZSBidXQgdW5kZWZpbmVkIHdpbGwgbm90XG4gIGlmICh2bm9kZS5kYXRhICYmIHZub2RlLmRhdGEuYXR0cnMgJiYgdm5vZGUuZGF0YS5hdHRycy5tdWx0aXBsZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgZWxtLnNldEF0dHJpYnV0ZSgnbXVsdGlwbGUnLCAnbXVsdGlwbGUnKTtcbiAgfVxuICByZXR1cm4gZWxtXG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUVsZW1lbnROUyAobmFtZXNwYWNlLCB0YWdOYW1lKSB7XG4gIHJldHVybiBkb2N1bWVudC5jcmVhdGVFbGVtZW50TlMobmFtZXNwYWNlTWFwW25hbWVzcGFjZV0sIHRhZ05hbWUpXG59XG5cbmZ1bmN0aW9uIGNyZWF0ZVRleHROb2RlICh0ZXh0KSB7XG4gIHJldHVybiBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZSh0ZXh0KVxufVxuXG5mdW5jdGlvbiBjcmVhdGVDb21tZW50ICh0ZXh0KSB7XG4gIHJldHVybiBkb2N1bWVudC5jcmVhdGVDb21tZW50KHRleHQpXG59XG5cbmZ1bmN0aW9uIGluc2VydEJlZm9yZSAocGFyZW50Tm9kZSwgbmV3Tm9kZSwgcmVmZXJlbmNlTm9kZSkge1xuICBwYXJlbnROb2RlLmluc2VydEJlZm9yZShuZXdOb2RlLCByZWZlcmVuY2VOb2RlKTtcbn1cblxuZnVuY3Rpb24gcmVtb3ZlQ2hpbGQgKG5vZGUsIGNoaWxkKSB7XG4gIG5vZGUucmVtb3ZlQ2hpbGQoY2hpbGQpO1xufVxuXG5mdW5jdGlvbiBhcHBlbmRDaGlsZCAobm9kZSwgY2hpbGQpIHtcbiAgbm9kZS5hcHBlbmRDaGlsZChjaGlsZCk7XG59XG5cbmZ1bmN0aW9uIHBhcmVudE5vZGUgKG5vZGUpIHtcbiAgcmV0dXJuIG5vZGUucGFyZW50Tm9kZVxufVxuXG5mdW5jdGlvbiBuZXh0U2libGluZyAobm9kZSkge1xuICByZXR1cm4gbm9kZS5uZXh0U2libGluZ1xufVxuXG5mdW5jdGlvbiB0YWdOYW1lIChub2RlKSB7XG4gIHJldHVybiBub2RlLnRhZ05hbWVcbn1cblxuZnVuY3Rpb24gc2V0VGV4dENvbnRlbnQgKG5vZGUsIHRleHQpIHtcbiAgbm9kZS50ZXh0Q29udGVudCA9IHRleHQ7XG59XG5cbmZ1bmN0aW9uIHNldFN0eWxlU2NvcGUgKG5vZGUsIHNjb3BlSWQpIHtcbiAgbm9kZS5zZXRBdHRyaWJ1dGUoc2NvcGVJZCwgJycpO1xufVxuXG52YXIgbm9kZU9wcyA9IC8qI19fUFVSRV9fKi9PYmplY3QuZnJlZXplKHtcbiAgY3JlYXRlRWxlbWVudDogY3JlYXRlRWxlbWVudCQxLFxuICBjcmVhdGVFbGVtZW50TlM6IGNyZWF0ZUVsZW1lbnROUyxcbiAgY3JlYXRlVGV4dE5vZGU6IGNyZWF0ZVRleHROb2RlLFxuICBjcmVhdGVDb21tZW50OiBjcmVhdGVDb21tZW50LFxuICBpbnNlcnRCZWZvcmU6IGluc2VydEJlZm9yZSxcbiAgcmVtb3ZlQ2hpbGQ6IHJlbW92ZUNoaWxkLFxuICBhcHBlbmRDaGlsZDogYXBwZW5kQ2hpbGQsXG4gIHBhcmVudE5vZGU6IHBhcmVudE5vZGUsXG4gIG5leHRTaWJsaW5nOiBuZXh0U2libGluZyxcbiAgdGFnTmFtZTogdGFnTmFtZSxcbiAgc2V0VGV4dENvbnRlbnQ6IHNldFRleHRDb250ZW50LFxuICBzZXRTdHlsZVNjb3BlOiBzZXRTdHlsZVNjb3BlXG59KTtcblxuLyogICovXG5cbnZhciByZWYgPSB7XG4gIGNyZWF0ZTogZnVuY3Rpb24gY3JlYXRlIChfLCB2bm9kZSkge1xuICAgIHJlZ2lzdGVyUmVmKHZub2RlKTtcbiAgfSxcbiAgdXBkYXRlOiBmdW5jdGlvbiB1cGRhdGUgKG9sZFZub2RlLCB2bm9kZSkge1xuICAgIGlmIChvbGRWbm9kZS5kYXRhLnJlZiAhPT0gdm5vZGUuZGF0YS5yZWYpIHtcbiAgICAgIHJlZ2lzdGVyUmVmKG9sZFZub2RlLCB0cnVlKTtcbiAgICAgIHJlZ2lzdGVyUmVmKHZub2RlKTtcbiAgICB9XG4gIH0sXG4gIGRlc3Ryb3k6IGZ1bmN0aW9uIGRlc3Ryb3kgKHZub2RlKSB7XG4gICAgcmVnaXN0ZXJSZWYodm5vZGUsIHRydWUpO1xuICB9XG59O1xuXG5mdW5jdGlvbiByZWdpc3RlclJlZiAodm5vZGUsIGlzUmVtb3ZhbCkge1xuICB2YXIga2V5ID0gdm5vZGUuZGF0YS5yZWY7XG4gIGlmICghaXNEZWYoa2V5KSkgeyByZXR1cm4gfVxuXG4gIHZhciB2bSA9IHZub2RlLmNvbnRleHQ7XG4gIHZhciByZWYgPSB2bm9kZS5jb21wb25lbnRJbnN0YW5jZSB8fCB2bm9kZS5lbG07XG4gIHZhciByZWZzID0gdm0uJHJlZnM7XG4gIGlmIChpc1JlbW92YWwpIHtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShyZWZzW2tleV0pKSB7XG4gICAgICByZW1vdmUocmVmc1trZXldLCByZWYpO1xuICAgIH0gZWxzZSBpZiAocmVmc1trZXldID09PSByZWYpIHtcbiAgICAgIHJlZnNba2V5XSA9IHVuZGVmaW5lZDtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgaWYgKHZub2RlLmRhdGEucmVmSW5Gb3IpIHtcbiAgICAgIGlmICghQXJyYXkuaXNBcnJheShyZWZzW2tleV0pKSB7XG4gICAgICAgIHJlZnNba2V5XSA9IFtyZWZdO1xuICAgICAgfSBlbHNlIGlmIChyZWZzW2tleV0uaW5kZXhPZihyZWYpIDwgMCkge1xuICAgICAgICAvLyAkZmxvdy1kaXNhYmxlLWxpbmVcbiAgICAgICAgcmVmc1trZXldLnB1c2gocmVmKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgcmVmc1trZXldID0gcmVmO1xuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIFZpcnR1YWwgRE9NIHBhdGNoaW5nIGFsZ29yaXRobSBiYXNlZCBvbiBTbmFiYmRvbSBieVxuICogU2ltb24gRnJpaXMgVmluZHVtIChAcGFsZGVwaW5kKVxuICogTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlXG4gKiBodHRwczovL2dpdGh1Yi5jb20vcGFsZGVwaW5kL3NuYWJiZG9tL2Jsb2IvbWFzdGVyL0xJQ0VOU0VcbiAqXG4gKiBtb2RpZmllZCBieSBFdmFuIFlvdSAoQHl5eDk5MDgwMylcbiAqXG4gKiBOb3QgdHlwZS1jaGVja2luZyB0aGlzIGJlY2F1c2UgdGhpcyBmaWxlIGlzIHBlcmYtY3JpdGljYWwgYW5kIHRoZSBjb3N0XG4gKiBvZiBtYWtpbmcgZmxvdyB1bmRlcnN0YW5kIGl0IGlzIG5vdCB3b3J0aCBpdC5cbiAqL1xuXG52YXIgZW1wdHlOb2RlID0gbmV3IFZOb2RlKCcnLCB7fSwgW10pO1xuXG52YXIgaG9va3MgPSBbJ2NyZWF0ZScsICdhY3RpdmF0ZScsICd1cGRhdGUnLCAncmVtb3ZlJywgJ2Rlc3Ryb3knXTtcblxuZnVuY3Rpb24gc2FtZVZub2RlIChhLCBiKSB7XG4gIHJldHVybiAoXG4gICAgYS5rZXkgPT09IGIua2V5ICYmIChcbiAgICAgIChcbiAgICAgICAgYS50YWcgPT09IGIudGFnICYmXG4gICAgICAgIGEuaXNDb21tZW50ID09PSBiLmlzQ29tbWVudCAmJlxuICAgICAgICBpc0RlZihhLmRhdGEpID09PSBpc0RlZihiLmRhdGEpICYmXG4gICAgICAgIHNhbWVJbnB1dFR5cGUoYSwgYilcbiAgICAgICkgfHwgKFxuICAgICAgICBpc1RydWUoYS5pc0FzeW5jUGxhY2Vob2xkZXIpICYmXG4gICAgICAgIGEuYXN5bmNGYWN0b3J5ID09PSBiLmFzeW5jRmFjdG9yeSAmJlxuICAgICAgICBpc1VuZGVmKGIuYXN5bmNGYWN0b3J5LmVycm9yKVxuICAgICAgKVxuICAgIClcbiAgKVxufVxuXG5mdW5jdGlvbiBzYW1lSW5wdXRUeXBlIChhLCBiKSB7XG4gIGlmIChhLnRhZyAhPT0gJ2lucHV0JykgeyByZXR1cm4gdHJ1ZSB9XG4gIHZhciBpO1xuICB2YXIgdHlwZUEgPSBpc0RlZihpID0gYS5kYXRhKSAmJiBpc0RlZihpID0gaS5hdHRycykgJiYgaS50eXBlO1xuICB2YXIgdHlwZUIgPSBpc0RlZihpID0gYi5kYXRhKSAmJiBpc0RlZihpID0gaS5hdHRycykgJiYgaS50eXBlO1xuICByZXR1cm4gdHlwZUEgPT09IHR5cGVCIHx8IGlzVGV4dElucHV0VHlwZSh0eXBlQSkgJiYgaXNUZXh0SW5wdXRUeXBlKHR5cGVCKVxufVxuXG5mdW5jdGlvbiBjcmVhdGVLZXlUb09sZElkeCAoY2hpbGRyZW4sIGJlZ2luSWR4LCBlbmRJZHgpIHtcbiAgdmFyIGksIGtleTtcbiAgdmFyIG1hcCA9IHt9O1xuICBmb3IgKGkgPSBiZWdpbklkeDsgaSA8PSBlbmRJZHg7ICsraSkge1xuICAgIGtleSA9IGNoaWxkcmVuW2ldLmtleTtcbiAgICBpZiAoaXNEZWYoa2V5KSkgeyBtYXBba2V5XSA9IGk7IH1cbiAgfVxuICByZXR1cm4gbWFwXG59XG5cbmZ1bmN0aW9uIGNyZWF0ZVBhdGNoRnVuY3Rpb24gKGJhY2tlbmQpIHtcbiAgdmFyIGksIGo7XG4gIHZhciBjYnMgPSB7fTtcblxuICB2YXIgbW9kdWxlcyA9IGJhY2tlbmQubW9kdWxlcztcbiAgdmFyIG5vZGVPcHMgPSBiYWNrZW5kLm5vZGVPcHM7XG5cbiAgZm9yIChpID0gMDsgaSA8IGhvb2tzLmxlbmd0aDsgKytpKSB7XG4gICAgY2JzW2hvb2tzW2ldXSA9IFtdO1xuICAgIGZvciAoaiA9IDA7IGogPCBtb2R1bGVzLmxlbmd0aDsgKytqKSB7XG4gICAgICBpZiAoaXNEZWYobW9kdWxlc1tqXVtob29rc1tpXV0pKSB7XG4gICAgICAgIGNic1tob29rc1tpXV0ucHVzaChtb2R1bGVzW2pdW2hvb2tzW2ldXSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gZW1wdHlOb2RlQXQgKGVsbSkge1xuICAgIHJldHVybiBuZXcgVk5vZGUobm9kZU9wcy50YWdOYW1lKGVsbSkudG9Mb3dlckNhc2UoKSwge30sIFtdLCB1bmRlZmluZWQsIGVsbSlcbiAgfVxuXG4gIGZ1bmN0aW9uIGNyZWF0ZVJtQ2IgKGNoaWxkRWxtLCBsaXN0ZW5lcnMpIHtcbiAgICBmdW5jdGlvbiByZW1vdmUkJDEgKCkge1xuICAgICAgaWYgKC0tcmVtb3ZlJCQxLmxpc3RlbmVycyA9PT0gMCkge1xuICAgICAgICByZW1vdmVOb2RlKGNoaWxkRWxtKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmVtb3ZlJCQxLmxpc3RlbmVycyA9IGxpc3RlbmVycztcbiAgICByZXR1cm4gcmVtb3ZlJCQxXG4gIH1cblxuICBmdW5jdGlvbiByZW1vdmVOb2RlIChlbCkge1xuICAgIHZhciBwYXJlbnQgPSBub2RlT3BzLnBhcmVudE5vZGUoZWwpO1xuICAgIC8vIGVsZW1lbnQgbWF5IGhhdmUgYWxyZWFkeSBiZWVuIHJlbW92ZWQgZHVlIHRvIHYtaHRtbCAvIHYtdGV4dFxuICAgIGlmIChpc0RlZihwYXJlbnQpKSB7XG4gICAgICBub2RlT3BzLnJlbW92ZUNoaWxkKHBhcmVudCwgZWwpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGlzVW5rbm93bkVsZW1lbnQkJDEgKHZub2RlLCBpblZQcmUpIHtcbiAgICByZXR1cm4gKFxuICAgICAgIWluVlByZSAmJlxuICAgICAgIXZub2RlLm5zICYmXG4gICAgICAhKFxuICAgICAgICBjb25maWcuaWdub3JlZEVsZW1lbnRzLmxlbmd0aCAmJlxuICAgICAgICBjb25maWcuaWdub3JlZEVsZW1lbnRzLnNvbWUoZnVuY3Rpb24gKGlnbm9yZSkge1xuICAgICAgICAgIHJldHVybiBpc1JlZ0V4cChpZ25vcmUpXG4gICAgICAgICAgICA/IGlnbm9yZS50ZXN0KHZub2RlLnRhZylcbiAgICAgICAgICAgIDogaWdub3JlID09PSB2bm9kZS50YWdcbiAgICAgICAgfSlcbiAgICAgICkgJiZcbiAgICAgIGNvbmZpZy5pc1Vua25vd25FbGVtZW50KHZub2RlLnRhZylcbiAgICApXG4gIH1cblxuICB2YXIgY3JlYXRpbmdFbG1JblZQcmUgPSAwO1xuXG4gIGZ1bmN0aW9uIGNyZWF0ZUVsbSAoXG4gICAgdm5vZGUsXG4gICAgaW5zZXJ0ZWRWbm9kZVF1ZXVlLFxuICAgIHBhcmVudEVsbSxcbiAgICByZWZFbG0sXG4gICAgbmVzdGVkLFxuICAgIG93bmVyQXJyYXksXG4gICAgaW5kZXhcbiAgKSB7XG4gICAgaWYgKGlzRGVmKHZub2RlLmVsbSkgJiYgaXNEZWYob3duZXJBcnJheSkpIHtcbiAgICAgIC8vIFRoaXMgdm5vZGUgd2FzIHVzZWQgaW4gYSBwcmV2aW91cyByZW5kZXIhXG4gICAgICAvLyBub3cgaXQncyB1c2VkIGFzIGEgbmV3IG5vZGUsIG92ZXJ3cml0aW5nIGl0cyBlbG0gd291bGQgY2F1c2VcbiAgICAgIC8vIHBvdGVudGlhbCBwYXRjaCBlcnJvcnMgZG93biB0aGUgcm9hZCB3aGVuIGl0J3MgdXNlZCBhcyBhbiBpbnNlcnRpb25cbiAgICAgIC8vIHJlZmVyZW5jZSBub2RlLiBJbnN0ZWFkLCB3ZSBjbG9uZSB0aGUgbm9kZSBvbi1kZW1hbmQgYmVmb3JlIGNyZWF0aW5nXG4gICAgICAvLyBhc3NvY2lhdGVkIERPTSBlbGVtZW50IGZvciBpdC5cbiAgICAgIHZub2RlID0gb3duZXJBcnJheVtpbmRleF0gPSBjbG9uZVZOb2RlKHZub2RlKTtcbiAgICB9XG5cbiAgICB2bm9kZS5pc1Jvb3RJbnNlcnQgPSAhbmVzdGVkOyAvLyBmb3IgdHJhbnNpdGlvbiBlbnRlciBjaGVja1xuICAgIGlmIChjcmVhdGVDb21wb25lbnQodm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSwgcGFyZW50RWxtLCByZWZFbG0pKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICB2YXIgZGF0YSA9IHZub2RlLmRhdGE7XG4gICAgdmFyIGNoaWxkcmVuID0gdm5vZGUuY2hpbGRyZW47XG4gICAgdmFyIHRhZyA9IHZub2RlLnRhZztcbiAgICBpZiAoaXNEZWYodGFnKSkge1xuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgaWYgKGRhdGEgJiYgZGF0YS5wcmUpIHtcbiAgICAgICAgICBjcmVhdGluZ0VsbUluVlByZSsrO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpc1Vua25vd25FbGVtZW50JCQxKHZub2RlLCBjcmVhdGluZ0VsbUluVlByZSkpIHtcbiAgICAgICAgICB3YXJuKFxuICAgICAgICAgICAgJ1Vua25vd24gY3VzdG9tIGVsZW1lbnQ6IDwnICsgdGFnICsgJz4gLSBkaWQgeW91ICcgK1xuICAgICAgICAgICAgJ3JlZ2lzdGVyIHRoZSBjb21wb25lbnQgY29ycmVjdGx5PyBGb3IgcmVjdXJzaXZlIGNvbXBvbmVudHMsICcgK1xuICAgICAgICAgICAgJ21ha2Ugc3VyZSB0byBwcm92aWRlIHRoZSBcIm5hbWVcIiBvcHRpb24uJyxcbiAgICAgICAgICAgIHZub2RlLmNvbnRleHRcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHZub2RlLmVsbSA9IHZub2RlLm5zXG4gICAgICAgID8gbm9kZU9wcy5jcmVhdGVFbGVtZW50TlModm5vZGUubnMsIHRhZylcbiAgICAgICAgOiBub2RlT3BzLmNyZWF0ZUVsZW1lbnQodGFnLCB2bm9kZSk7XG4gICAgICBzZXRTY29wZSh2bm9kZSk7XG5cbiAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgICAge1xuICAgICAgICBjcmVhdGVDaGlsZHJlbih2bm9kZSwgY2hpbGRyZW4sIGluc2VydGVkVm5vZGVRdWV1ZSk7XG4gICAgICAgIGlmIChpc0RlZihkYXRhKSkge1xuICAgICAgICAgIGludm9rZUNyZWF0ZUhvb2tzKHZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUpO1xuICAgICAgICB9XG4gICAgICAgIGluc2VydChwYXJlbnRFbG0sIHZub2RlLmVsbSwgcmVmRWxtKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgZGF0YSAmJiBkYXRhLnByZSkge1xuICAgICAgICBjcmVhdGluZ0VsbUluVlByZS0tO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoaXNUcnVlKHZub2RlLmlzQ29tbWVudCkpIHtcbiAgICAgIHZub2RlLmVsbSA9IG5vZGVPcHMuY3JlYXRlQ29tbWVudCh2bm9kZS50ZXh0KTtcbiAgICAgIGluc2VydChwYXJlbnRFbG0sIHZub2RlLmVsbSwgcmVmRWxtKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdm5vZGUuZWxtID0gbm9kZU9wcy5jcmVhdGVUZXh0Tm9kZSh2bm9kZS50ZXh0KTtcbiAgICAgIGluc2VydChwYXJlbnRFbG0sIHZub2RlLmVsbSwgcmVmRWxtKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBjcmVhdGVDb21wb25lbnQgKHZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUsIHBhcmVudEVsbSwgcmVmRWxtKSB7XG4gICAgdmFyIGkgPSB2bm9kZS5kYXRhO1xuICAgIGlmIChpc0RlZihpKSkge1xuICAgICAgdmFyIGlzUmVhY3RpdmF0ZWQgPSBpc0RlZih2bm9kZS5jb21wb25lbnRJbnN0YW5jZSkgJiYgaS5rZWVwQWxpdmU7XG4gICAgICBpZiAoaXNEZWYoaSA9IGkuaG9vaykgJiYgaXNEZWYoaSA9IGkuaW5pdCkpIHtcbiAgICAgICAgaSh2bm9kZSwgZmFsc2UgLyogaHlkcmF0aW5nICovKTtcbiAgICAgIH1cbiAgICAgIC8vIGFmdGVyIGNhbGxpbmcgdGhlIGluaXQgaG9vaywgaWYgdGhlIHZub2RlIGlzIGEgY2hpbGQgY29tcG9uZW50XG4gICAgICAvLyBpdCBzaG91bGQndmUgY3JlYXRlZCBhIGNoaWxkIGluc3RhbmNlIGFuZCBtb3VudGVkIGl0LiB0aGUgY2hpbGRcbiAgICAgIC8vIGNvbXBvbmVudCBhbHNvIGhhcyBzZXQgdGhlIHBsYWNlaG9sZGVyIHZub2RlJ3MgZWxtLlxuICAgICAgLy8gaW4gdGhhdCBjYXNlIHdlIGNhbiBqdXN0IHJldHVybiB0aGUgZWxlbWVudCBhbmQgYmUgZG9uZS5cbiAgICAgIGlmIChpc0RlZih2bm9kZS5jb21wb25lbnRJbnN0YW5jZSkpIHtcbiAgICAgICAgaW5pdENvbXBvbmVudCh2bm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlKTtcbiAgICAgICAgaW5zZXJ0KHBhcmVudEVsbSwgdm5vZGUuZWxtLCByZWZFbG0pO1xuICAgICAgICBpZiAoaXNUcnVlKGlzUmVhY3RpdmF0ZWQpKSB7XG4gICAgICAgICAgcmVhY3RpdmF0ZUNvbXBvbmVudCh2bm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlLCBwYXJlbnRFbG0sIHJlZkVsbSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWVcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBpbml0Q29tcG9uZW50ICh2bm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlKSB7XG4gICAgaWYgKGlzRGVmKHZub2RlLmRhdGEucGVuZGluZ0luc2VydCkpIHtcbiAgICAgIGluc2VydGVkVm5vZGVRdWV1ZS5wdXNoLmFwcGx5KGluc2VydGVkVm5vZGVRdWV1ZSwgdm5vZGUuZGF0YS5wZW5kaW5nSW5zZXJ0KTtcbiAgICAgIHZub2RlLmRhdGEucGVuZGluZ0luc2VydCA9IG51bGw7XG4gICAgfVxuICAgIHZub2RlLmVsbSA9IHZub2RlLmNvbXBvbmVudEluc3RhbmNlLiRlbDtcbiAgICBpZiAoaXNQYXRjaGFibGUodm5vZGUpKSB7XG4gICAgICBpbnZva2VDcmVhdGVIb29rcyh2bm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlKTtcbiAgICAgIHNldFNjb3BlKHZub2RlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gZW1wdHkgY29tcG9uZW50IHJvb3QuXG4gICAgICAvLyBza2lwIGFsbCBlbGVtZW50LXJlbGF0ZWQgbW9kdWxlcyBleGNlcHQgZm9yIHJlZiAoIzM0NTUpXG4gICAgICByZWdpc3RlclJlZih2bm9kZSk7XG4gICAgICAvLyBtYWtlIHN1cmUgdG8gaW52b2tlIHRoZSBpbnNlcnQgaG9va1xuICAgICAgaW5zZXJ0ZWRWbm9kZVF1ZXVlLnB1c2godm5vZGUpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHJlYWN0aXZhdGVDb21wb25lbnQgKHZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUsIHBhcmVudEVsbSwgcmVmRWxtKSB7XG4gICAgdmFyIGk7XG4gICAgLy8gaGFjayBmb3IgIzQzMzk6IGEgcmVhY3RpdmF0ZWQgY29tcG9uZW50IHdpdGggaW5uZXIgdHJhbnNpdGlvblxuICAgIC8vIGRvZXMgbm90IHRyaWdnZXIgYmVjYXVzZSB0aGUgaW5uZXIgbm9kZSdzIGNyZWF0ZWQgaG9va3MgYXJlIG5vdCBjYWxsZWRcbiAgICAvLyBhZ2Fpbi4gSXQncyBub3QgaWRlYWwgdG8gaW52b2x2ZSBtb2R1bGUtc3BlY2lmaWMgbG9naWMgaW4gaGVyZSBidXRcbiAgICAvLyB0aGVyZSBkb2Vzbid0IHNlZW0gdG8gYmUgYSBiZXR0ZXIgd2F5IHRvIGRvIGl0LlxuICAgIHZhciBpbm5lck5vZGUgPSB2bm9kZTtcbiAgICB3aGlsZSAoaW5uZXJOb2RlLmNvbXBvbmVudEluc3RhbmNlKSB7XG4gICAgICBpbm5lck5vZGUgPSBpbm5lck5vZGUuY29tcG9uZW50SW5zdGFuY2UuX3Zub2RlO1xuICAgICAgaWYgKGlzRGVmKGkgPSBpbm5lck5vZGUuZGF0YSkgJiYgaXNEZWYoaSA9IGkudHJhbnNpdGlvbikpIHtcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IGNicy5hY3RpdmF0ZS5sZW5ndGg7ICsraSkge1xuICAgICAgICAgIGNicy5hY3RpdmF0ZVtpXShlbXB0eU5vZGUsIGlubmVyTm9kZSk7XG4gICAgICAgIH1cbiAgICAgICAgaW5zZXJ0ZWRWbm9kZVF1ZXVlLnB1c2goaW5uZXJOb2RlKTtcbiAgICAgICAgYnJlYWtcbiAgICAgIH1cbiAgICB9XG4gICAgLy8gdW5saWtlIGEgbmV3bHkgY3JlYXRlZCBjb21wb25lbnQsXG4gICAgLy8gYSByZWFjdGl2YXRlZCBrZWVwLWFsaXZlIGNvbXBvbmVudCBkb2Vzbid0IGluc2VydCBpdHNlbGZcbiAgICBpbnNlcnQocGFyZW50RWxtLCB2bm9kZS5lbG0sIHJlZkVsbSk7XG4gIH1cblxuICBmdW5jdGlvbiBpbnNlcnQgKHBhcmVudCwgZWxtLCByZWYkJDEpIHtcbiAgICBpZiAoaXNEZWYocGFyZW50KSkge1xuICAgICAgaWYgKGlzRGVmKHJlZiQkMSkpIHtcbiAgICAgICAgaWYgKG5vZGVPcHMucGFyZW50Tm9kZShyZWYkJDEpID09PSBwYXJlbnQpIHtcbiAgICAgICAgICBub2RlT3BzLmluc2VydEJlZm9yZShwYXJlbnQsIGVsbSwgcmVmJCQxKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbm9kZU9wcy5hcHBlbmRDaGlsZChwYXJlbnQsIGVsbSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gY3JlYXRlQ2hpbGRyZW4gKHZub2RlLCBjaGlsZHJlbiwgaW5zZXJ0ZWRWbm9kZVF1ZXVlKSB7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkoY2hpbGRyZW4pKSB7XG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICBjaGVja0R1cGxpY2F0ZUtleXMoY2hpbGRyZW4pO1xuICAgICAgfVxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjaGlsZHJlbi5sZW5ndGg7ICsraSkge1xuICAgICAgICBjcmVhdGVFbG0oY2hpbGRyZW5baV0sIGluc2VydGVkVm5vZGVRdWV1ZSwgdm5vZGUuZWxtLCBudWxsLCB0cnVlLCBjaGlsZHJlbiwgaSk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChpc1ByaW1pdGl2ZSh2bm9kZS50ZXh0KSkge1xuICAgICAgbm9kZU9wcy5hcHBlbmRDaGlsZCh2bm9kZS5lbG0sIG5vZGVPcHMuY3JlYXRlVGV4dE5vZGUoU3RyaW5nKHZub2RlLnRleHQpKSk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gaXNQYXRjaGFibGUgKHZub2RlKSB7XG4gICAgd2hpbGUgKHZub2RlLmNvbXBvbmVudEluc3RhbmNlKSB7XG4gICAgICB2bm9kZSA9IHZub2RlLmNvbXBvbmVudEluc3RhbmNlLl92bm9kZTtcbiAgICB9XG4gICAgcmV0dXJuIGlzRGVmKHZub2RlLnRhZylcbiAgfVxuXG4gIGZ1bmN0aW9uIGludm9rZUNyZWF0ZUhvb2tzICh2bm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlKSB7XG4gICAgZm9yICh2YXIgaSQxID0gMDsgaSQxIDwgY2JzLmNyZWF0ZS5sZW5ndGg7ICsraSQxKSB7XG4gICAgICBjYnMuY3JlYXRlW2kkMV0oZW1wdHlOb2RlLCB2bm9kZSk7XG4gICAgfVxuICAgIGkgPSB2bm9kZS5kYXRhLmhvb2s7IC8vIFJldXNlIHZhcmlhYmxlXG4gICAgaWYgKGlzRGVmKGkpKSB7XG4gICAgICBpZiAoaXNEZWYoaS5jcmVhdGUpKSB7IGkuY3JlYXRlKGVtcHR5Tm9kZSwgdm5vZGUpOyB9XG4gICAgICBpZiAoaXNEZWYoaS5pbnNlcnQpKSB7IGluc2VydGVkVm5vZGVRdWV1ZS5wdXNoKHZub2RlKTsgfVxuICAgIH1cbiAgfVxuXG4gIC8vIHNldCBzY29wZSBpZCBhdHRyaWJ1dGUgZm9yIHNjb3BlZCBDU1MuXG4gIC8vIHRoaXMgaXMgaW1wbGVtZW50ZWQgYXMgYSBzcGVjaWFsIGNhc2UgdG8gYXZvaWQgdGhlIG92ZXJoZWFkXG4gIC8vIG9mIGdvaW5nIHRocm91Z2ggdGhlIG5vcm1hbCBhdHRyaWJ1dGUgcGF0Y2hpbmcgcHJvY2Vzcy5cbiAgZnVuY3Rpb24gc2V0U2NvcGUgKHZub2RlKSB7XG4gICAgdmFyIGk7XG4gICAgaWYgKGlzRGVmKGkgPSB2bm9kZS5mblNjb3BlSWQpKSB7XG4gICAgICBub2RlT3BzLnNldFN0eWxlU2NvcGUodm5vZGUuZWxtLCBpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIGFuY2VzdG9yID0gdm5vZGU7XG4gICAgICB3aGlsZSAoYW5jZXN0b3IpIHtcbiAgICAgICAgaWYgKGlzRGVmKGkgPSBhbmNlc3Rvci5jb250ZXh0KSAmJiBpc0RlZihpID0gaS4kb3B0aW9ucy5fc2NvcGVJZCkpIHtcbiAgICAgICAgICBub2RlT3BzLnNldFN0eWxlU2NvcGUodm5vZGUuZWxtLCBpKTtcbiAgICAgICAgfVxuICAgICAgICBhbmNlc3RvciA9IGFuY2VzdG9yLnBhcmVudDtcbiAgICAgIH1cbiAgICB9XG4gICAgLy8gZm9yIHNsb3QgY29udGVudCB0aGV5IHNob3VsZCBhbHNvIGdldCB0aGUgc2NvcGVJZCBmcm9tIHRoZSBob3N0IGluc3RhbmNlLlxuICAgIGlmIChpc0RlZihpID0gYWN0aXZlSW5zdGFuY2UpICYmXG4gICAgICBpICE9PSB2bm9kZS5jb250ZXh0ICYmXG4gICAgICBpICE9PSB2bm9kZS5mbkNvbnRleHQgJiZcbiAgICAgIGlzRGVmKGkgPSBpLiRvcHRpb25zLl9zY29wZUlkKVxuICAgICkge1xuICAgICAgbm9kZU9wcy5zZXRTdHlsZVNjb3BlKHZub2RlLmVsbSwgaSk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gYWRkVm5vZGVzIChwYXJlbnRFbG0sIHJlZkVsbSwgdm5vZGVzLCBzdGFydElkeCwgZW5kSWR4LCBpbnNlcnRlZFZub2RlUXVldWUpIHtcbiAgICBmb3IgKDsgc3RhcnRJZHggPD0gZW5kSWR4OyArK3N0YXJ0SWR4KSB7XG4gICAgICBjcmVhdGVFbG0odm5vZGVzW3N0YXJ0SWR4XSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlLCBwYXJlbnRFbG0sIHJlZkVsbSwgZmFsc2UsIHZub2Rlcywgc3RhcnRJZHgpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGludm9rZURlc3Ryb3lIb29rICh2bm9kZSkge1xuICAgIHZhciBpLCBqO1xuICAgIHZhciBkYXRhID0gdm5vZGUuZGF0YTtcbiAgICBpZiAoaXNEZWYoZGF0YSkpIHtcbiAgICAgIGlmIChpc0RlZihpID0gZGF0YS5ob29rKSAmJiBpc0RlZihpID0gaS5kZXN0cm95KSkgeyBpKHZub2RlKTsgfVxuICAgICAgZm9yIChpID0gMDsgaSA8IGNicy5kZXN0cm95Lmxlbmd0aDsgKytpKSB7IGNicy5kZXN0cm95W2ldKHZub2RlKTsgfVxuICAgIH1cbiAgICBpZiAoaXNEZWYoaSA9IHZub2RlLmNoaWxkcmVuKSkge1xuICAgICAgZm9yIChqID0gMDsgaiA8IHZub2RlLmNoaWxkcmVuLmxlbmd0aDsgKytqKSB7XG4gICAgICAgIGludm9rZURlc3Ryb3lIb29rKHZub2RlLmNoaWxkcmVuW2pdKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiByZW1vdmVWbm9kZXMgKHBhcmVudEVsbSwgdm5vZGVzLCBzdGFydElkeCwgZW5kSWR4KSB7XG4gICAgZm9yICg7IHN0YXJ0SWR4IDw9IGVuZElkeDsgKytzdGFydElkeCkge1xuICAgICAgdmFyIGNoID0gdm5vZGVzW3N0YXJ0SWR4XTtcbiAgICAgIGlmIChpc0RlZihjaCkpIHtcbiAgICAgICAgaWYgKGlzRGVmKGNoLnRhZykpIHtcbiAgICAgICAgICByZW1vdmVBbmRJbnZva2VSZW1vdmVIb29rKGNoKTtcbiAgICAgICAgICBpbnZva2VEZXN0cm95SG9vayhjaCk7XG4gICAgICAgIH0gZWxzZSB7IC8vIFRleHQgbm9kZVxuICAgICAgICAgIHJlbW92ZU5vZGUoY2guZWxtKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHJlbW92ZUFuZEludm9rZVJlbW92ZUhvb2sgKHZub2RlLCBybSkge1xuICAgIGlmIChpc0RlZihybSkgfHwgaXNEZWYodm5vZGUuZGF0YSkpIHtcbiAgICAgIHZhciBpO1xuICAgICAgdmFyIGxpc3RlbmVycyA9IGNicy5yZW1vdmUubGVuZ3RoICsgMTtcbiAgICAgIGlmIChpc0RlZihybSkpIHtcbiAgICAgICAgLy8gd2UgaGF2ZSBhIHJlY3Vyc2l2ZWx5IHBhc3NlZCBkb3duIHJtIGNhbGxiYWNrXG4gICAgICAgIC8vIGluY3JlYXNlIHRoZSBsaXN0ZW5lcnMgY291bnRcbiAgICAgICAgcm0ubGlzdGVuZXJzICs9IGxpc3RlbmVycztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIGRpcmVjdGx5IHJlbW92aW5nXG4gICAgICAgIHJtID0gY3JlYXRlUm1DYih2bm9kZS5lbG0sIGxpc3RlbmVycyk7XG4gICAgICB9XG4gICAgICAvLyByZWN1cnNpdmVseSBpbnZva2UgaG9va3Mgb24gY2hpbGQgY29tcG9uZW50IHJvb3Qgbm9kZVxuICAgICAgaWYgKGlzRGVmKGkgPSB2bm9kZS5jb21wb25lbnRJbnN0YW5jZSkgJiYgaXNEZWYoaSA9IGkuX3Zub2RlKSAmJiBpc0RlZihpLmRhdGEpKSB7XG4gICAgICAgIHJlbW92ZUFuZEludm9rZVJlbW92ZUhvb2soaSwgcm0pO1xuICAgICAgfVxuICAgICAgZm9yIChpID0gMDsgaSA8IGNicy5yZW1vdmUubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgY2JzLnJlbW92ZVtpXSh2bm9kZSwgcm0pO1xuICAgICAgfVxuICAgICAgaWYgKGlzRGVmKGkgPSB2bm9kZS5kYXRhLmhvb2spICYmIGlzRGVmKGkgPSBpLnJlbW92ZSkpIHtcbiAgICAgICAgaSh2bm9kZSwgcm0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcm0oKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgcmVtb3ZlTm9kZSh2bm9kZS5lbG0pO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHVwZGF0ZUNoaWxkcmVuIChwYXJlbnRFbG0sIG9sZENoLCBuZXdDaCwgaW5zZXJ0ZWRWbm9kZVF1ZXVlLCByZW1vdmVPbmx5KSB7XG4gICAgdmFyIG9sZFN0YXJ0SWR4ID0gMDtcbiAgICB2YXIgbmV3U3RhcnRJZHggPSAwO1xuICAgIHZhciBvbGRFbmRJZHggPSBvbGRDaC5sZW5ndGggLSAxO1xuICAgIHZhciBvbGRTdGFydFZub2RlID0gb2xkQ2hbMF07XG4gICAgdmFyIG9sZEVuZFZub2RlID0gb2xkQ2hbb2xkRW5kSWR4XTtcbiAgICB2YXIgbmV3RW5kSWR4ID0gbmV3Q2gubGVuZ3RoIC0gMTtcbiAgICB2YXIgbmV3U3RhcnRWbm9kZSA9IG5ld0NoWzBdO1xuICAgIHZhciBuZXdFbmRWbm9kZSA9IG5ld0NoW25ld0VuZElkeF07XG4gICAgdmFyIG9sZEtleVRvSWR4LCBpZHhJbk9sZCwgdm5vZGVUb01vdmUsIHJlZkVsbTtcblxuICAgIC8vIHJlbW92ZU9ubHkgaXMgYSBzcGVjaWFsIGZsYWcgdXNlZCBvbmx5IGJ5IDx0cmFuc2l0aW9uLWdyb3VwPlxuICAgIC8vIHRvIGVuc3VyZSByZW1vdmVkIGVsZW1lbnRzIHN0YXkgaW4gY29ycmVjdCByZWxhdGl2ZSBwb3NpdGlvbnNcbiAgICAvLyBkdXJpbmcgbGVhdmluZyB0cmFuc2l0aW9uc1xuICAgIHZhciBjYW5Nb3ZlID0gIXJlbW92ZU9ubHk7XG5cbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgY2hlY2tEdXBsaWNhdGVLZXlzKG5ld0NoKTtcbiAgICB9XG5cbiAgICB3aGlsZSAob2xkU3RhcnRJZHggPD0gb2xkRW5kSWR4ICYmIG5ld1N0YXJ0SWR4IDw9IG5ld0VuZElkeCkge1xuICAgICAgaWYgKGlzVW5kZWYob2xkU3RhcnRWbm9kZSkpIHtcbiAgICAgICAgb2xkU3RhcnRWbm9kZSA9IG9sZENoWysrb2xkU3RhcnRJZHhdOyAvLyBWbm9kZSBoYXMgYmVlbiBtb3ZlZCBsZWZ0XG4gICAgICB9IGVsc2UgaWYgKGlzVW5kZWYob2xkRW5kVm5vZGUpKSB7XG4gICAgICAgIG9sZEVuZFZub2RlID0gb2xkQ2hbLS1vbGRFbmRJZHhdO1xuICAgICAgfSBlbHNlIGlmIChzYW1lVm5vZGUob2xkU3RhcnRWbm9kZSwgbmV3U3RhcnRWbm9kZSkpIHtcbiAgICAgICAgcGF0Y2hWbm9kZShvbGRTdGFydFZub2RlLCBuZXdTdGFydFZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUsIG5ld0NoLCBuZXdTdGFydElkeCk7XG4gICAgICAgIG9sZFN0YXJ0Vm5vZGUgPSBvbGRDaFsrK29sZFN0YXJ0SWR4XTtcbiAgICAgICAgbmV3U3RhcnRWbm9kZSA9IG5ld0NoWysrbmV3U3RhcnRJZHhdO1xuICAgICAgfSBlbHNlIGlmIChzYW1lVm5vZGUob2xkRW5kVm5vZGUsIG5ld0VuZFZub2RlKSkge1xuICAgICAgICBwYXRjaFZub2RlKG9sZEVuZFZub2RlLCBuZXdFbmRWbm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlLCBuZXdDaCwgbmV3RW5kSWR4KTtcbiAgICAgICAgb2xkRW5kVm5vZGUgPSBvbGRDaFstLW9sZEVuZElkeF07XG4gICAgICAgIG5ld0VuZFZub2RlID0gbmV3Q2hbLS1uZXdFbmRJZHhdO1xuICAgICAgfSBlbHNlIGlmIChzYW1lVm5vZGUob2xkU3RhcnRWbm9kZSwgbmV3RW5kVm5vZGUpKSB7IC8vIFZub2RlIG1vdmVkIHJpZ2h0XG4gICAgICAgIHBhdGNoVm5vZGUob2xkU3RhcnRWbm9kZSwgbmV3RW5kVm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSwgbmV3Q2gsIG5ld0VuZElkeCk7XG4gICAgICAgIGNhbk1vdmUgJiYgbm9kZU9wcy5pbnNlcnRCZWZvcmUocGFyZW50RWxtLCBvbGRTdGFydFZub2RlLmVsbSwgbm9kZU9wcy5uZXh0U2libGluZyhvbGRFbmRWbm9kZS5lbG0pKTtcbiAgICAgICAgb2xkU3RhcnRWbm9kZSA9IG9sZENoWysrb2xkU3RhcnRJZHhdO1xuICAgICAgICBuZXdFbmRWbm9kZSA9IG5ld0NoWy0tbmV3RW5kSWR4XTtcbiAgICAgIH0gZWxzZSBpZiAoc2FtZVZub2RlKG9sZEVuZFZub2RlLCBuZXdTdGFydFZub2RlKSkgeyAvLyBWbm9kZSBtb3ZlZCBsZWZ0XG4gICAgICAgIHBhdGNoVm5vZGUob2xkRW5kVm5vZGUsIG5ld1N0YXJ0Vm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSwgbmV3Q2gsIG5ld1N0YXJ0SWR4KTtcbiAgICAgICAgY2FuTW92ZSAmJiBub2RlT3BzLmluc2VydEJlZm9yZShwYXJlbnRFbG0sIG9sZEVuZFZub2RlLmVsbSwgb2xkU3RhcnRWbm9kZS5lbG0pO1xuICAgICAgICBvbGRFbmRWbm9kZSA9IG9sZENoWy0tb2xkRW5kSWR4XTtcbiAgICAgICAgbmV3U3RhcnRWbm9kZSA9IG5ld0NoWysrbmV3U3RhcnRJZHhdO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKGlzVW5kZWYob2xkS2V5VG9JZHgpKSB7IG9sZEtleVRvSWR4ID0gY3JlYXRlS2V5VG9PbGRJZHgob2xkQ2gsIG9sZFN0YXJ0SWR4LCBvbGRFbmRJZHgpOyB9XG4gICAgICAgIGlkeEluT2xkID0gaXNEZWYobmV3U3RhcnRWbm9kZS5rZXkpXG4gICAgICAgICAgPyBvbGRLZXlUb0lkeFtuZXdTdGFydFZub2RlLmtleV1cbiAgICAgICAgICA6IGZpbmRJZHhJbk9sZChuZXdTdGFydFZub2RlLCBvbGRDaCwgb2xkU3RhcnRJZHgsIG9sZEVuZElkeCk7XG4gICAgICAgIGlmIChpc1VuZGVmKGlkeEluT2xkKSkgeyAvLyBOZXcgZWxlbWVudFxuICAgICAgICAgIGNyZWF0ZUVsbShuZXdTdGFydFZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUsIHBhcmVudEVsbSwgb2xkU3RhcnRWbm9kZS5lbG0sIGZhbHNlLCBuZXdDaCwgbmV3U3RhcnRJZHgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZub2RlVG9Nb3ZlID0gb2xkQ2hbaWR4SW5PbGRdO1xuICAgICAgICAgIGlmIChzYW1lVm5vZGUodm5vZGVUb01vdmUsIG5ld1N0YXJ0Vm5vZGUpKSB7XG4gICAgICAgICAgICBwYXRjaFZub2RlKHZub2RlVG9Nb3ZlLCBuZXdTdGFydFZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUsIG5ld0NoLCBuZXdTdGFydElkeCk7XG4gICAgICAgICAgICBvbGRDaFtpZHhJbk9sZF0gPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICBjYW5Nb3ZlICYmIG5vZGVPcHMuaW5zZXJ0QmVmb3JlKHBhcmVudEVsbSwgdm5vZGVUb01vdmUuZWxtLCBvbGRTdGFydFZub2RlLmVsbSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIHNhbWUga2V5IGJ1dCBkaWZmZXJlbnQgZWxlbWVudC4gdHJlYXQgYXMgbmV3IGVsZW1lbnRcbiAgICAgICAgICAgIGNyZWF0ZUVsbShuZXdTdGFydFZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUsIHBhcmVudEVsbSwgb2xkU3RhcnRWbm9kZS5lbG0sIGZhbHNlLCBuZXdDaCwgbmV3U3RhcnRJZHgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBuZXdTdGFydFZub2RlID0gbmV3Q2hbKytuZXdTdGFydElkeF07XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChvbGRTdGFydElkeCA+IG9sZEVuZElkeCkge1xuICAgICAgcmVmRWxtID0gaXNVbmRlZihuZXdDaFtuZXdFbmRJZHggKyAxXSkgPyBudWxsIDogbmV3Q2hbbmV3RW5kSWR4ICsgMV0uZWxtO1xuICAgICAgYWRkVm5vZGVzKHBhcmVudEVsbSwgcmVmRWxtLCBuZXdDaCwgbmV3U3RhcnRJZHgsIG5ld0VuZElkeCwgaW5zZXJ0ZWRWbm9kZVF1ZXVlKTtcbiAgICB9IGVsc2UgaWYgKG5ld1N0YXJ0SWR4ID4gbmV3RW5kSWR4KSB7XG4gICAgICByZW1vdmVWbm9kZXMocGFyZW50RWxtLCBvbGRDaCwgb2xkU3RhcnRJZHgsIG9sZEVuZElkeCk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gY2hlY2tEdXBsaWNhdGVLZXlzIChjaGlsZHJlbikge1xuICAgIHZhciBzZWVuS2V5cyA9IHt9O1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciB2bm9kZSA9IGNoaWxkcmVuW2ldO1xuICAgICAgdmFyIGtleSA9IHZub2RlLmtleTtcbiAgICAgIGlmIChpc0RlZihrZXkpKSB7XG4gICAgICAgIGlmIChzZWVuS2V5c1trZXldKSB7XG4gICAgICAgICAgd2FybihcbiAgICAgICAgICAgIChcIkR1cGxpY2F0ZSBrZXlzIGRldGVjdGVkOiAnXCIgKyBrZXkgKyBcIicuIFRoaXMgbWF5IGNhdXNlIGFuIHVwZGF0ZSBlcnJvci5cIiksXG4gICAgICAgICAgICB2bm9kZS5jb250ZXh0XG4gICAgICAgICAgKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBzZWVuS2V5c1trZXldID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGZpbmRJZHhJbk9sZCAobm9kZSwgb2xkQ2gsIHN0YXJ0LCBlbmQpIHtcbiAgICBmb3IgKHZhciBpID0gc3RhcnQ7IGkgPCBlbmQ7IGkrKykge1xuICAgICAgdmFyIGMgPSBvbGRDaFtpXTtcbiAgICAgIGlmIChpc0RlZihjKSAmJiBzYW1lVm5vZGUobm9kZSwgYykpIHsgcmV0dXJuIGkgfVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHBhdGNoVm5vZGUgKFxuICAgIG9sZFZub2RlLFxuICAgIHZub2RlLFxuICAgIGluc2VydGVkVm5vZGVRdWV1ZSxcbiAgICBvd25lckFycmF5LFxuICAgIGluZGV4LFxuICAgIHJlbW92ZU9ubHlcbiAgKSB7XG4gICAgaWYgKG9sZFZub2RlID09PSB2bm9kZSkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgaWYgKGlzRGVmKHZub2RlLmVsbSkgJiYgaXNEZWYob3duZXJBcnJheSkpIHtcbiAgICAgIC8vIGNsb25lIHJldXNlZCB2bm9kZVxuICAgICAgdm5vZGUgPSBvd25lckFycmF5W2luZGV4XSA9IGNsb25lVk5vZGUodm5vZGUpO1xuICAgIH1cblxuICAgIHZhciBlbG0gPSB2bm9kZS5lbG0gPSBvbGRWbm9kZS5lbG07XG5cbiAgICBpZiAoaXNUcnVlKG9sZFZub2RlLmlzQXN5bmNQbGFjZWhvbGRlcikpIHtcbiAgICAgIGlmIChpc0RlZih2bm9kZS5hc3luY0ZhY3RvcnkucmVzb2x2ZWQpKSB7XG4gICAgICAgIGh5ZHJhdGUob2xkVm5vZGUuZWxtLCB2bm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZub2RlLmlzQXN5bmNQbGFjZWhvbGRlciA9IHRydWU7XG4gICAgICB9XG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICAvLyByZXVzZSBlbGVtZW50IGZvciBzdGF0aWMgdHJlZXMuXG4gICAgLy8gbm90ZSB3ZSBvbmx5IGRvIHRoaXMgaWYgdGhlIHZub2RlIGlzIGNsb25lZCAtXG4gICAgLy8gaWYgdGhlIG5ldyBub2RlIGlzIG5vdCBjbG9uZWQgaXQgbWVhbnMgdGhlIHJlbmRlciBmdW5jdGlvbnMgaGF2ZSBiZWVuXG4gICAgLy8gcmVzZXQgYnkgdGhlIGhvdC1yZWxvYWQtYXBpIGFuZCB3ZSBuZWVkIHRvIGRvIGEgcHJvcGVyIHJlLXJlbmRlci5cbiAgICBpZiAoaXNUcnVlKHZub2RlLmlzU3RhdGljKSAmJlxuICAgICAgaXNUcnVlKG9sZFZub2RlLmlzU3RhdGljKSAmJlxuICAgICAgdm5vZGUua2V5ID09PSBvbGRWbm9kZS5rZXkgJiZcbiAgICAgIChpc1RydWUodm5vZGUuaXNDbG9uZWQpIHx8IGlzVHJ1ZSh2bm9kZS5pc09uY2UpKVxuICAgICkge1xuICAgICAgdm5vZGUuY29tcG9uZW50SW5zdGFuY2UgPSBvbGRWbm9kZS5jb21wb25lbnRJbnN0YW5jZTtcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIHZhciBpO1xuICAgIHZhciBkYXRhID0gdm5vZGUuZGF0YTtcbiAgICBpZiAoaXNEZWYoZGF0YSkgJiYgaXNEZWYoaSA9IGRhdGEuaG9vaykgJiYgaXNEZWYoaSA9IGkucHJlcGF0Y2gpKSB7XG4gICAgICBpKG9sZFZub2RlLCB2bm9kZSk7XG4gICAgfVxuXG4gICAgdmFyIG9sZENoID0gb2xkVm5vZGUuY2hpbGRyZW47XG4gICAgdmFyIGNoID0gdm5vZGUuY2hpbGRyZW47XG4gICAgaWYgKGlzRGVmKGRhdGEpICYmIGlzUGF0Y2hhYmxlKHZub2RlKSkge1xuICAgICAgZm9yIChpID0gMDsgaSA8IGNicy51cGRhdGUubGVuZ3RoOyArK2kpIHsgY2JzLnVwZGF0ZVtpXShvbGRWbm9kZSwgdm5vZGUpOyB9XG4gICAgICBpZiAoaXNEZWYoaSA9IGRhdGEuaG9vaykgJiYgaXNEZWYoaSA9IGkudXBkYXRlKSkgeyBpKG9sZFZub2RlLCB2bm9kZSk7IH1cbiAgICB9XG4gICAgaWYgKGlzVW5kZWYodm5vZGUudGV4dCkpIHtcbiAgICAgIGlmIChpc0RlZihvbGRDaCkgJiYgaXNEZWYoY2gpKSB7XG4gICAgICAgIGlmIChvbGRDaCAhPT0gY2gpIHsgdXBkYXRlQ2hpbGRyZW4oZWxtLCBvbGRDaCwgY2gsIGluc2VydGVkVm5vZGVRdWV1ZSwgcmVtb3ZlT25seSk7IH1cbiAgICAgIH0gZWxzZSBpZiAoaXNEZWYoY2gpKSB7XG4gICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgICAgY2hlY2tEdXBsaWNhdGVLZXlzKGNoKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaXNEZWYob2xkVm5vZGUudGV4dCkpIHsgbm9kZU9wcy5zZXRUZXh0Q29udGVudChlbG0sICcnKTsgfVxuICAgICAgICBhZGRWbm9kZXMoZWxtLCBudWxsLCBjaCwgMCwgY2gubGVuZ3RoIC0gMSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlKTtcbiAgICAgIH0gZWxzZSBpZiAoaXNEZWYob2xkQ2gpKSB7XG4gICAgICAgIHJlbW92ZVZub2RlcyhlbG0sIG9sZENoLCAwLCBvbGRDaC5sZW5ndGggLSAxKTtcbiAgICAgIH0gZWxzZSBpZiAoaXNEZWYob2xkVm5vZGUudGV4dCkpIHtcbiAgICAgICAgbm9kZU9wcy5zZXRUZXh0Q29udGVudChlbG0sICcnKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKG9sZFZub2RlLnRleHQgIT09IHZub2RlLnRleHQpIHtcbiAgICAgIG5vZGVPcHMuc2V0VGV4dENvbnRlbnQoZWxtLCB2bm9kZS50ZXh0KTtcbiAgICB9XG4gICAgaWYgKGlzRGVmKGRhdGEpKSB7XG4gICAgICBpZiAoaXNEZWYoaSA9IGRhdGEuaG9vaykgJiYgaXNEZWYoaSA9IGkucG9zdHBhdGNoKSkgeyBpKG9sZFZub2RlLCB2bm9kZSk7IH1cbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBpbnZva2VJbnNlcnRIb29rICh2bm9kZSwgcXVldWUsIGluaXRpYWwpIHtcbiAgICAvLyBkZWxheSBpbnNlcnQgaG9va3MgZm9yIGNvbXBvbmVudCByb290IG5vZGVzLCBpbnZva2UgdGhlbSBhZnRlciB0aGVcbiAgICAvLyBlbGVtZW50IGlzIHJlYWxseSBpbnNlcnRlZFxuICAgIGlmIChpc1RydWUoaW5pdGlhbCkgJiYgaXNEZWYodm5vZGUucGFyZW50KSkge1xuICAgICAgdm5vZGUucGFyZW50LmRhdGEucGVuZGluZ0luc2VydCA9IHF1ZXVlO1xuICAgIH0gZWxzZSB7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHF1ZXVlLmxlbmd0aDsgKytpKSB7XG4gICAgICAgIHF1ZXVlW2ldLmRhdGEuaG9vay5pbnNlcnQocXVldWVbaV0pO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHZhciBoeWRyYXRpb25CYWlsZWQgPSBmYWxzZTtcbiAgLy8gbGlzdCBvZiBtb2R1bGVzIHRoYXQgY2FuIHNraXAgY3JlYXRlIGhvb2sgZHVyaW5nIGh5ZHJhdGlvbiBiZWNhdXNlIHRoZXlcbiAgLy8gYXJlIGFscmVhZHkgcmVuZGVyZWQgb24gdGhlIGNsaWVudCBvciBoYXMgbm8gbmVlZCBmb3IgaW5pdGlhbGl6YXRpb25cbiAgLy8gTm90ZTogc3R5bGUgaXMgZXhjbHVkZWQgYmVjYXVzZSBpdCByZWxpZXMgb24gaW5pdGlhbCBjbG9uZSBmb3IgZnV0dXJlXG4gIC8vIGRlZXAgdXBkYXRlcyAoIzcwNjMpLlxuICB2YXIgaXNSZW5kZXJlZE1vZHVsZSA9IG1ha2VNYXAoJ2F0dHJzLGNsYXNzLHN0YXRpY0NsYXNzLHN0YXRpY1N0eWxlLGtleScpO1xuXG4gIC8vIE5vdGU6IHRoaXMgaXMgYSBicm93c2VyLW9ubHkgZnVuY3Rpb24gc28gd2UgY2FuIGFzc3VtZSBlbG1zIGFyZSBET00gbm9kZXMuXG4gIGZ1bmN0aW9uIGh5ZHJhdGUgKGVsbSwgdm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSwgaW5WUHJlKSB7XG4gICAgdmFyIGk7XG4gICAgdmFyIHRhZyA9IHZub2RlLnRhZztcbiAgICB2YXIgZGF0YSA9IHZub2RlLmRhdGE7XG4gICAgdmFyIGNoaWxkcmVuID0gdm5vZGUuY2hpbGRyZW47XG4gICAgaW5WUHJlID0gaW5WUHJlIHx8IChkYXRhICYmIGRhdGEucHJlKTtcbiAgICB2bm9kZS5lbG0gPSBlbG07XG5cbiAgICBpZiAoaXNUcnVlKHZub2RlLmlzQ29tbWVudCkgJiYgaXNEZWYodm5vZGUuYXN5bmNGYWN0b3J5KSkge1xuICAgICAgdm5vZGUuaXNBc3luY1BsYWNlaG9sZGVyID0gdHJ1ZTtcbiAgICAgIHJldHVybiB0cnVlXG4gICAgfVxuICAgIC8vIGFzc2VydCBub2RlIG1hdGNoXG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIGlmICghYXNzZXJ0Tm9kZU1hdGNoKGVsbSwgdm5vZGUsIGluVlByZSkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICB9XG4gICAgfVxuICAgIGlmIChpc0RlZihkYXRhKSkge1xuICAgICAgaWYgKGlzRGVmKGkgPSBkYXRhLmhvb2spICYmIGlzRGVmKGkgPSBpLmluaXQpKSB7IGkodm5vZGUsIHRydWUgLyogaHlkcmF0aW5nICovKTsgfVxuICAgICAgaWYgKGlzRGVmKGkgPSB2bm9kZS5jb21wb25lbnRJbnN0YW5jZSkpIHtcbiAgICAgICAgLy8gY2hpbGQgY29tcG9uZW50LiBpdCBzaG91bGQgaGF2ZSBoeWRyYXRlZCBpdHMgb3duIHRyZWUuXG4gICAgICAgIGluaXRDb21wb25lbnQodm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSk7XG4gICAgICAgIHJldHVybiB0cnVlXG4gICAgICB9XG4gICAgfVxuICAgIGlmIChpc0RlZih0YWcpKSB7XG4gICAgICBpZiAoaXNEZWYoY2hpbGRyZW4pKSB7XG4gICAgICAgIC8vIGVtcHR5IGVsZW1lbnQsIGFsbG93IGNsaWVudCB0byBwaWNrIHVwIGFuZCBwb3B1bGF0ZSBjaGlsZHJlblxuICAgICAgICBpZiAoIWVsbS5oYXNDaGlsZE5vZGVzKCkpIHtcbiAgICAgICAgICBjcmVhdGVDaGlsZHJlbih2bm9kZSwgY2hpbGRyZW4sIGluc2VydGVkVm5vZGVRdWV1ZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gdi1odG1sIGFuZCBkb21Qcm9wczogaW5uZXJIVE1MXG4gICAgICAgICAgaWYgKGlzRGVmKGkgPSBkYXRhKSAmJiBpc0RlZihpID0gaS5kb21Qcm9wcykgJiYgaXNEZWYoaSA9IGkuaW5uZXJIVE1MKSkge1xuICAgICAgICAgICAgaWYgKGkgIT09IGVsbS5pbm5lckhUTUwpIHtcbiAgICAgICAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgICAgICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmXG4gICAgICAgICAgICAgICAgdHlwZW9mIGNvbnNvbGUgIT09ICd1bmRlZmluZWQnICYmXG4gICAgICAgICAgICAgICAgIWh5ZHJhdGlvbkJhaWxlZFxuICAgICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICBoeWRyYXRpb25CYWlsZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybignUGFyZW50OiAnLCBlbG0pO1xuICAgICAgICAgICAgICAgIGNvbnNvbGUud2Fybignc2VydmVyIGlubmVySFRNTDogJywgaSk7XG4gICAgICAgICAgICAgICAgY29uc29sZS53YXJuKCdjbGllbnQgaW5uZXJIVE1MOiAnLCBlbG0uaW5uZXJIVE1MKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gaXRlcmF0ZSBhbmQgY29tcGFyZSBjaGlsZHJlbiBsaXN0c1xuICAgICAgICAgICAgdmFyIGNoaWxkcmVuTWF0Y2ggPSB0cnVlO1xuICAgICAgICAgICAgdmFyIGNoaWxkTm9kZSA9IGVsbS5maXJzdENoaWxkO1xuICAgICAgICAgICAgZm9yICh2YXIgaSQxID0gMDsgaSQxIDwgY2hpbGRyZW4ubGVuZ3RoOyBpJDErKykge1xuICAgICAgICAgICAgICBpZiAoIWNoaWxkTm9kZSB8fCAhaHlkcmF0ZShjaGlsZE5vZGUsIGNoaWxkcmVuW2kkMV0sIGluc2VydGVkVm5vZGVRdWV1ZSwgaW5WUHJlKSkge1xuICAgICAgICAgICAgICAgIGNoaWxkcmVuTWF0Y2ggPSBmYWxzZTtcbiAgICAgICAgICAgICAgICBicmVha1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGNoaWxkTm9kZSA9IGNoaWxkTm9kZS5uZXh0U2libGluZztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIGlmIGNoaWxkTm9kZSBpcyBub3QgbnVsbCwgaXQgbWVhbnMgdGhlIGFjdHVhbCBjaGlsZE5vZGVzIGxpc3QgaXNcbiAgICAgICAgICAgIC8vIGxvbmdlciB0aGFuIHRoZSB2aXJ0dWFsIGNoaWxkcmVuIGxpc3QuXG4gICAgICAgICAgICBpZiAoIWNoaWxkcmVuTWF0Y2ggfHwgY2hpbGROb2RlKSB7XG4gICAgICAgICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgICAgICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJlxuICAgICAgICAgICAgICAgIHR5cGVvZiBjb25zb2xlICE9PSAndW5kZWZpbmVkJyAmJlxuICAgICAgICAgICAgICAgICFoeWRyYXRpb25CYWlsZWRcbiAgICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgaHlkcmF0aW9uQmFpbGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oJ1BhcmVudDogJywgZWxtKTtcbiAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oJ01pc21hdGNoaW5nIGNoaWxkTm9kZXMgdnMuIFZOb2RlczogJywgZWxtLmNoaWxkTm9kZXMsIGNoaWxkcmVuKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChpc0RlZihkYXRhKSkge1xuICAgICAgICB2YXIgZnVsbEludm9rZSA9IGZhbHNlO1xuICAgICAgICBmb3IgKHZhciBrZXkgaW4gZGF0YSkge1xuICAgICAgICAgIGlmICghaXNSZW5kZXJlZE1vZHVsZShrZXkpKSB7XG4gICAgICAgICAgICBmdWxsSW52b2tlID0gdHJ1ZTtcbiAgICAgICAgICAgIGludm9rZUNyZWF0ZUhvb2tzKHZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUpO1xuICAgICAgICAgICAgYnJlYWtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFmdWxsSW52b2tlICYmIGRhdGFbJ2NsYXNzJ10pIHtcbiAgICAgICAgICAvLyBlbnN1cmUgY29sbGVjdGluZyBkZXBzIGZvciBkZWVwIGNsYXNzIGJpbmRpbmdzIGZvciBmdXR1cmUgdXBkYXRlc1xuICAgICAgICAgIHRyYXZlcnNlKGRhdGFbJ2NsYXNzJ10pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChlbG0uZGF0YSAhPT0gdm5vZGUudGV4dCkge1xuICAgICAgZWxtLmRhdGEgPSB2bm9kZS50ZXh0O1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZVxuICB9XG5cbiAgZnVuY3Rpb24gYXNzZXJ0Tm9kZU1hdGNoIChub2RlLCB2bm9kZSwgaW5WUHJlKSB7XG4gICAgaWYgKGlzRGVmKHZub2RlLnRhZykpIHtcbiAgICAgIHJldHVybiB2bm9kZS50YWcuaW5kZXhPZigndnVlLWNvbXBvbmVudCcpID09PSAwIHx8IChcbiAgICAgICAgIWlzVW5rbm93bkVsZW1lbnQkJDEodm5vZGUsIGluVlByZSkgJiZcbiAgICAgICAgdm5vZGUudGFnLnRvTG93ZXJDYXNlKCkgPT09IChub2RlLnRhZ05hbWUgJiYgbm9kZS50YWdOYW1lLnRvTG93ZXJDYXNlKCkpXG4gICAgICApXG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBub2RlLm5vZGVUeXBlID09PSAodm5vZGUuaXNDb21tZW50ID8gOCA6IDMpXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGZ1bmN0aW9uIHBhdGNoIChvbGRWbm9kZSwgdm5vZGUsIGh5ZHJhdGluZywgcmVtb3ZlT25seSkge1xuICAgIGlmIChpc1VuZGVmKHZub2RlKSkge1xuICAgICAgaWYgKGlzRGVmKG9sZFZub2RlKSkgeyBpbnZva2VEZXN0cm95SG9vayhvbGRWbm9kZSk7IH1cbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIHZhciBpc0luaXRpYWxQYXRjaCA9IGZhbHNlO1xuICAgIHZhciBpbnNlcnRlZFZub2RlUXVldWUgPSBbXTtcblxuICAgIGlmIChpc1VuZGVmKG9sZFZub2RlKSkge1xuICAgICAgLy8gZW1wdHkgbW91bnQgKGxpa2VseSBhcyBjb21wb25lbnQpLCBjcmVhdGUgbmV3IHJvb3QgZWxlbWVudFxuICAgICAgaXNJbml0aWFsUGF0Y2ggPSB0cnVlO1xuICAgICAgY3JlYXRlRWxtKHZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgaXNSZWFsRWxlbWVudCA9IGlzRGVmKG9sZFZub2RlLm5vZGVUeXBlKTtcbiAgICAgIGlmICghaXNSZWFsRWxlbWVudCAmJiBzYW1lVm5vZGUob2xkVm5vZGUsIHZub2RlKSkge1xuICAgICAgICAvLyBwYXRjaCBleGlzdGluZyByb290IG5vZGVcbiAgICAgICAgcGF0Y2hWbm9kZShvbGRWbm9kZSwgdm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSwgbnVsbCwgbnVsbCwgcmVtb3ZlT25seSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoaXNSZWFsRWxlbWVudCkge1xuICAgICAgICAgIC8vIG1vdW50aW5nIHRvIGEgcmVhbCBlbGVtZW50XG4gICAgICAgICAgLy8gY2hlY2sgaWYgdGhpcyBpcyBzZXJ2ZXItcmVuZGVyZWQgY29udGVudCBhbmQgaWYgd2UgY2FuIHBlcmZvcm1cbiAgICAgICAgICAvLyBhIHN1Y2Nlc3NmdWwgaHlkcmF0aW9uLlxuICAgICAgICAgIGlmIChvbGRWbm9kZS5ub2RlVHlwZSA9PT0gMSAmJiBvbGRWbm9kZS5oYXNBdHRyaWJ1dGUoU1NSX0FUVFIpKSB7XG4gICAgICAgICAgICBvbGRWbm9kZS5yZW1vdmVBdHRyaWJ1dGUoU1NSX0FUVFIpO1xuICAgICAgICAgICAgaHlkcmF0aW5nID0gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGlzVHJ1ZShoeWRyYXRpbmcpKSB7XG4gICAgICAgICAgICBpZiAoaHlkcmF0ZShvbGRWbm9kZSwgdm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSkpIHtcbiAgICAgICAgICAgICAgaW52b2tlSW5zZXJ0SG9vayh2bm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlLCB0cnVlKTtcbiAgICAgICAgICAgICAgcmV0dXJuIG9sZFZub2RlXG4gICAgICAgICAgICB9IGVsc2UgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgICAgICAgd2FybihcbiAgICAgICAgICAgICAgICAnVGhlIGNsaWVudC1zaWRlIHJlbmRlcmVkIHZpcnR1YWwgRE9NIHRyZWUgaXMgbm90IG1hdGNoaW5nICcgK1xuICAgICAgICAgICAgICAgICdzZXJ2ZXItcmVuZGVyZWQgY29udGVudC4gVGhpcyBpcyBsaWtlbHkgY2F1c2VkIGJ5IGluY29ycmVjdCAnICtcbiAgICAgICAgICAgICAgICAnSFRNTCBtYXJrdXAsIGZvciBleGFtcGxlIG5lc3RpbmcgYmxvY2stbGV2ZWwgZWxlbWVudHMgaW5zaWRlICcgK1xuICAgICAgICAgICAgICAgICc8cD4sIG9yIG1pc3NpbmcgPHRib2R5Pi4gQmFpbGluZyBoeWRyYXRpb24gYW5kIHBlcmZvcm1pbmcgJyArXG4gICAgICAgICAgICAgICAgJ2Z1bGwgY2xpZW50LXNpZGUgcmVuZGVyLidcbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgLy8gZWl0aGVyIG5vdCBzZXJ2ZXItcmVuZGVyZWQsIG9yIGh5ZHJhdGlvbiBmYWlsZWQuXG4gICAgICAgICAgLy8gY3JlYXRlIGFuIGVtcHR5IG5vZGUgYW5kIHJlcGxhY2UgaXRcbiAgICAgICAgICBvbGRWbm9kZSA9IGVtcHR5Tm9kZUF0KG9sZFZub2RlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHJlcGxhY2luZyBleGlzdGluZyBlbGVtZW50XG4gICAgICAgIHZhciBvbGRFbG0gPSBvbGRWbm9kZS5lbG07XG4gICAgICAgIHZhciBwYXJlbnRFbG0gPSBub2RlT3BzLnBhcmVudE5vZGUob2xkRWxtKTtcblxuICAgICAgICAvLyBjcmVhdGUgbmV3IG5vZGVcbiAgICAgICAgY3JlYXRlRWxtKFxuICAgICAgICAgIHZub2RlLFxuICAgICAgICAgIGluc2VydGVkVm5vZGVRdWV1ZSxcbiAgICAgICAgICAvLyBleHRyZW1lbHkgcmFyZSBlZGdlIGNhc2U6IGRvIG5vdCBpbnNlcnQgaWYgb2xkIGVsZW1lbnQgaXMgaW4gYVxuICAgICAgICAgIC8vIGxlYXZpbmcgdHJhbnNpdGlvbi4gT25seSBoYXBwZW5zIHdoZW4gY29tYmluaW5nIHRyYW5zaXRpb24gK1xuICAgICAgICAgIC8vIGtlZXAtYWxpdmUgKyBIT0NzLiAoIzQ1OTApXG4gICAgICAgICAgb2xkRWxtLl9sZWF2ZUNiID8gbnVsbCA6IHBhcmVudEVsbSxcbiAgICAgICAgICBub2RlT3BzLm5leHRTaWJsaW5nKG9sZEVsbSlcbiAgICAgICAgKTtcblxuICAgICAgICAvLyB1cGRhdGUgcGFyZW50IHBsYWNlaG9sZGVyIG5vZGUgZWxlbWVudCwgcmVjdXJzaXZlbHlcbiAgICAgICAgaWYgKGlzRGVmKHZub2RlLnBhcmVudCkpIHtcbiAgICAgICAgICB2YXIgYW5jZXN0b3IgPSB2bm9kZS5wYXJlbnQ7XG4gICAgICAgICAgdmFyIHBhdGNoYWJsZSA9IGlzUGF0Y2hhYmxlKHZub2RlKTtcbiAgICAgICAgICB3aGlsZSAoYW5jZXN0b3IpIHtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2JzLmRlc3Ryb3kubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgICAgY2JzLmRlc3Ryb3lbaV0oYW5jZXN0b3IpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYW5jZXN0b3IuZWxtID0gdm5vZGUuZWxtO1xuICAgICAgICAgICAgaWYgKHBhdGNoYWJsZSkge1xuICAgICAgICAgICAgICBmb3IgKHZhciBpJDEgPSAwOyBpJDEgPCBjYnMuY3JlYXRlLmxlbmd0aDsgKytpJDEpIHtcbiAgICAgICAgICAgICAgICBjYnMuY3JlYXRlW2kkMV0oZW1wdHlOb2RlLCBhbmNlc3Rvcik7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgLy8gIzY1MTNcbiAgICAgICAgICAgICAgLy8gaW52b2tlIGluc2VydCBob29rcyB0aGF0IG1heSBoYXZlIGJlZW4gbWVyZ2VkIGJ5IGNyZWF0ZSBob29rcy5cbiAgICAgICAgICAgICAgLy8gZS5nLiBmb3IgZGlyZWN0aXZlcyB0aGF0IHVzZXMgdGhlIFwiaW5zZXJ0ZWRcIiBob29rLlxuICAgICAgICAgICAgICB2YXIgaW5zZXJ0ID0gYW5jZXN0b3IuZGF0YS5ob29rLmluc2VydDtcbiAgICAgICAgICAgICAgaWYgKGluc2VydC5tZXJnZWQpIHtcbiAgICAgICAgICAgICAgICAvLyBzdGFydCBhdCBpbmRleCAxIHRvIGF2b2lkIHJlLWludm9raW5nIGNvbXBvbmVudCBtb3VudGVkIGhvb2tcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpJDIgPSAxOyBpJDIgPCBpbnNlcnQuZm5zLmxlbmd0aDsgaSQyKyspIHtcbiAgICAgICAgICAgICAgICAgIGluc2VydC5mbnNbaSQyXSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgcmVnaXN0ZXJSZWYoYW5jZXN0b3IpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYW5jZXN0b3IgPSBhbmNlc3Rvci5wYXJlbnQ7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gZGVzdHJveSBvbGQgbm9kZVxuICAgICAgICBpZiAoaXNEZWYocGFyZW50RWxtKSkge1xuICAgICAgICAgIHJlbW92ZVZub2RlcyhwYXJlbnRFbG0sIFtvbGRWbm9kZV0sIDAsIDApO1xuICAgICAgICB9IGVsc2UgaWYgKGlzRGVmKG9sZFZub2RlLnRhZykpIHtcbiAgICAgICAgICBpbnZva2VEZXN0cm95SG9vayhvbGRWbm9kZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBpbnZva2VJbnNlcnRIb29rKHZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUsIGlzSW5pdGlhbFBhdGNoKTtcbiAgICByZXR1cm4gdm5vZGUuZWxtXG4gIH1cbn1cblxuLyogICovXG5cbnZhciBkaXJlY3RpdmVzID0ge1xuICBjcmVhdGU6IHVwZGF0ZURpcmVjdGl2ZXMsXG4gIHVwZGF0ZTogdXBkYXRlRGlyZWN0aXZlcyxcbiAgZGVzdHJveTogZnVuY3Rpb24gdW5iaW5kRGlyZWN0aXZlcyAodm5vZGUpIHtcbiAgICB1cGRhdGVEaXJlY3RpdmVzKHZub2RlLCBlbXB0eU5vZGUpO1xuICB9XG59O1xuXG5mdW5jdGlvbiB1cGRhdGVEaXJlY3RpdmVzIChvbGRWbm9kZSwgdm5vZGUpIHtcbiAgaWYgKG9sZFZub2RlLmRhdGEuZGlyZWN0aXZlcyB8fCB2bm9kZS5kYXRhLmRpcmVjdGl2ZXMpIHtcbiAgICBfdXBkYXRlKG9sZFZub2RlLCB2bm9kZSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gX3VwZGF0ZSAob2xkVm5vZGUsIHZub2RlKSB7XG4gIHZhciBpc0NyZWF0ZSA9IG9sZFZub2RlID09PSBlbXB0eU5vZGU7XG4gIHZhciBpc0Rlc3Ryb3kgPSB2bm9kZSA9PT0gZW1wdHlOb2RlO1xuICB2YXIgb2xkRGlycyA9IG5vcm1hbGl6ZURpcmVjdGl2ZXMkMShvbGRWbm9kZS5kYXRhLmRpcmVjdGl2ZXMsIG9sZFZub2RlLmNvbnRleHQpO1xuICB2YXIgbmV3RGlycyA9IG5vcm1hbGl6ZURpcmVjdGl2ZXMkMSh2bm9kZS5kYXRhLmRpcmVjdGl2ZXMsIHZub2RlLmNvbnRleHQpO1xuXG4gIHZhciBkaXJzV2l0aEluc2VydCA9IFtdO1xuICB2YXIgZGlyc1dpdGhQb3N0cGF0Y2ggPSBbXTtcblxuICB2YXIga2V5LCBvbGREaXIsIGRpcjtcbiAgZm9yIChrZXkgaW4gbmV3RGlycykge1xuICAgIG9sZERpciA9IG9sZERpcnNba2V5XTtcbiAgICBkaXIgPSBuZXdEaXJzW2tleV07XG4gICAgaWYgKCFvbGREaXIpIHtcbiAgICAgIC8vIG5ldyBkaXJlY3RpdmUsIGJpbmRcbiAgICAgIGNhbGxIb29rJDEoZGlyLCAnYmluZCcsIHZub2RlLCBvbGRWbm9kZSk7XG4gICAgICBpZiAoZGlyLmRlZiAmJiBkaXIuZGVmLmluc2VydGVkKSB7XG4gICAgICAgIGRpcnNXaXRoSW5zZXJ0LnB1c2goZGlyKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgLy8gZXhpc3RpbmcgZGlyZWN0aXZlLCB1cGRhdGVcbiAgICAgIGRpci5vbGRWYWx1ZSA9IG9sZERpci52YWx1ZTtcbiAgICAgIGRpci5vbGRBcmcgPSBvbGREaXIuYXJnO1xuICAgICAgY2FsbEhvb2skMShkaXIsICd1cGRhdGUnLCB2bm9kZSwgb2xkVm5vZGUpO1xuICAgICAgaWYgKGRpci5kZWYgJiYgZGlyLmRlZi5jb21wb25lbnRVcGRhdGVkKSB7XG4gICAgICAgIGRpcnNXaXRoUG9zdHBhdGNoLnB1c2goZGlyKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBpZiAoZGlyc1dpdGhJbnNlcnQubGVuZ3RoKSB7XG4gICAgdmFyIGNhbGxJbnNlcnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGRpcnNXaXRoSW5zZXJ0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNhbGxIb29rJDEoZGlyc1dpdGhJbnNlcnRbaV0sICdpbnNlcnRlZCcsIHZub2RlLCBvbGRWbm9kZSk7XG4gICAgICB9XG4gICAgfTtcbiAgICBpZiAoaXNDcmVhdGUpIHtcbiAgICAgIG1lcmdlVk5vZGVIb29rKHZub2RlLCAnaW5zZXJ0JywgY2FsbEluc2VydCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNhbGxJbnNlcnQoKTtcbiAgICB9XG4gIH1cblxuICBpZiAoZGlyc1dpdGhQb3N0cGF0Y2gubGVuZ3RoKSB7XG4gICAgbWVyZ2VWTm9kZUhvb2sodm5vZGUsICdwb3N0cGF0Y2gnLCBmdW5jdGlvbiAoKSB7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGRpcnNXaXRoUG9zdHBhdGNoLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNhbGxIb29rJDEoZGlyc1dpdGhQb3N0cGF0Y2hbaV0sICdjb21wb25lbnRVcGRhdGVkJywgdm5vZGUsIG9sZFZub2RlKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIGlmICghaXNDcmVhdGUpIHtcbiAgICBmb3IgKGtleSBpbiBvbGREaXJzKSB7XG4gICAgICBpZiAoIW5ld0RpcnNba2V5XSkge1xuICAgICAgICAvLyBubyBsb25nZXIgcHJlc2VudCwgdW5iaW5kXG4gICAgICAgIGNhbGxIb29rJDEob2xkRGlyc1trZXldLCAndW5iaW5kJywgb2xkVm5vZGUsIG9sZFZub2RlLCBpc0Rlc3Ryb3kpO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG52YXIgZW1wdHlNb2RpZmllcnMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuXG5mdW5jdGlvbiBub3JtYWxpemVEaXJlY3RpdmVzJDEgKFxuICBkaXJzLFxuICB2bVxuKSB7XG4gIHZhciByZXMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICBpZiAoIWRpcnMpIHtcbiAgICAvLyAkZmxvdy1kaXNhYmxlLWxpbmVcbiAgICByZXR1cm4gcmVzXG4gIH1cbiAgdmFyIGksIGRpcjtcbiAgZm9yIChpID0gMDsgaSA8IGRpcnMubGVuZ3RoOyBpKyspIHtcbiAgICBkaXIgPSBkaXJzW2ldO1xuICAgIGlmICghZGlyLm1vZGlmaWVycykge1xuICAgICAgLy8gJGZsb3ctZGlzYWJsZS1saW5lXG4gICAgICBkaXIubW9kaWZpZXJzID0gZW1wdHlNb2RpZmllcnM7XG4gICAgfVxuICAgIHJlc1tnZXRSYXdEaXJOYW1lKGRpcildID0gZGlyO1xuICAgIGRpci5kZWYgPSByZXNvbHZlQXNzZXQodm0uJG9wdGlvbnMsICdkaXJlY3RpdmVzJywgZGlyLm5hbWUsIHRydWUpO1xuICB9XG4gIC8vICRmbG93LWRpc2FibGUtbGluZVxuICByZXR1cm4gcmVzXG59XG5cbmZ1bmN0aW9uIGdldFJhd0Rpck5hbWUgKGRpcikge1xuICByZXR1cm4gZGlyLnJhd05hbWUgfHwgKChkaXIubmFtZSkgKyBcIi5cIiArIChPYmplY3Qua2V5cyhkaXIubW9kaWZpZXJzIHx8IHt9KS5qb2luKCcuJykpKVxufVxuXG5mdW5jdGlvbiBjYWxsSG9vayQxIChkaXIsIGhvb2ssIHZub2RlLCBvbGRWbm9kZSwgaXNEZXN0cm95KSB7XG4gIHZhciBmbiA9IGRpci5kZWYgJiYgZGlyLmRlZltob29rXTtcbiAgaWYgKGZuKSB7XG4gICAgdHJ5IHtcbiAgICAgIGZuKHZub2RlLmVsbSwgZGlyLCB2bm9kZSwgb2xkVm5vZGUsIGlzRGVzdHJveSk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgaGFuZGxlRXJyb3IoZSwgdm5vZGUuY29udGV4dCwgKFwiZGlyZWN0aXZlIFwiICsgKGRpci5uYW1lKSArIFwiIFwiICsgaG9vayArIFwiIGhvb2tcIikpO1xuICAgIH1cbiAgfVxufVxuXG52YXIgYmFzZU1vZHVsZXMgPSBbXG4gIHJlZixcbiAgZGlyZWN0aXZlc1xuXTtcblxuLyogICovXG5cbmZ1bmN0aW9uIHVwZGF0ZUF0dHJzIChvbGRWbm9kZSwgdm5vZGUpIHtcbiAgdmFyIG9wdHMgPSB2bm9kZS5jb21wb25lbnRPcHRpb25zO1xuICBpZiAoaXNEZWYob3B0cykgJiYgb3B0cy5DdG9yLm9wdGlvbnMuaW5oZXJpdEF0dHJzID09PSBmYWxzZSkge1xuICAgIHJldHVyblxuICB9XG4gIGlmIChpc1VuZGVmKG9sZFZub2RlLmRhdGEuYXR0cnMpICYmIGlzVW5kZWYodm5vZGUuZGF0YS5hdHRycykpIHtcbiAgICByZXR1cm5cbiAgfVxuICB2YXIga2V5LCBjdXIsIG9sZDtcbiAgdmFyIGVsbSA9IHZub2RlLmVsbTtcbiAgdmFyIG9sZEF0dHJzID0gb2xkVm5vZGUuZGF0YS5hdHRycyB8fCB7fTtcbiAgdmFyIGF0dHJzID0gdm5vZGUuZGF0YS5hdHRycyB8fCB7fTtcbiAgLy8gY2xvbmUgb2JzZXJ2ZWQgb2JqZWN0cywgYXMgdGhlIHVzZXIgcHJvYmFibHkgd2FudHMgdG8gbXV0YXRlIGl0XG4gIGlmIChpc0RlZihhdHRycy5fX29iX18pKSB7XG4gICAgYXR0cnMgPSB2bm9kZS5kYXRhLmF0dHJzID0gZXh0ZW5kKHt9LCBhdHRycyk7XG4gIH1cblxuICBmb3IgKGtleSBpbiBhdHRycykge1xuICAgIGN1ciA9IGF0dHJzW2tleV07XG4gICAgb2xkID0gb2xkQXR0cnNba2V5XTtcbiAgICBpZiAob2xkICE9PSBjdXIpIHtcbiAgICAgIHNldEF0dHIoZWxtLCBrZXksIGN1cik7XG4gICAgfVxuICB9XG4gIC8vICM0MzkxOiBpbiBJRTksIHNldHRpbmcgdHlwZSBjYW4gcmVzZXQgdmFsdWUgZm9yIGlucHV0W3R5cGU9cmFkaW9dXG4gIC8vICM2NjY2OiBJRS9FZGdlIGZvcmNlcyBwcm9ncmVzcyB2YWx1ZSBkb3duIHRvIDEgYmVmb3JlIHNldHRpbmcgYSBtYXhcbiAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gIGlmICgoaXNJRSB8fCBpc0VkZ2UpICYmIGF0dHJzLnZhbHVlICE9PSBvbGRBdHRycy52YWx1ZSkge1xuICAgIHNldEF0dHIoZWxtLCAndmFsdWUnLCBhdHRycy52YWx1ZSk7XG4gIH1cbiAgZm9yIChrZXkgaW4gb2xkQXR0cnMpIHtcbiAgICBpZiAoaXNVbmRlZihhdHRyc1trZXldKSkge1xuICAgICAgaWYgKGlzWGxpbmsoa2V5KSkge1xuICAgICAgICBlbG0ucmVtb3ZlQXR0cmlidXRlTlMoeGxpbmtOUywgZ2V0WGxpbmtQcm9wKGtleSkpO1xuICAgICAgfSBlbHNlIGlmICghaXNFbnVtZXJhdGVkQXR0cihrZXkpKSB7XG4gICAgICAgIGVsbS5yZW1vdmVBdHRyaWJ1dGUoa2V5KTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gc2V0QXR0ciAoZWwsIGtleSwgdmFsdWUpIHtcbiAgaWYgKGVsLnRhZ05hbWUuaW5kZXhPZignLScpID4gLTEpIHtcbiAgICBiYXNlU2V0QXR0cihlbCwga2V5LCB2YWx1ZSk7XG4gIH0gZWxzZSBpZiAoaXNCb29sZWFuQXR0cihrZXkpKSB7XG4gICAgLy8gc2V0IGF0dHJpYnV0ZSBmb3IgYmxhbmsgdmFsdWVcbiAgICAvLyBlLmcuIDxvcHRpb24gZGlzYWJsZWQ+U2VsZWN0IG9uZTwvb3B0aW9uPlxuICAgIGlmIChpc0ZhbHN5QXR0clZhbHVlKHZhbHVlKSkge1xuICAgICAgZWwucmVtb3ZlQXR0cmlidXRlKGtleSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIHRlY2huaWNhbGx5IGFsbG93ZnVsbHNjcmVlbiBpcyBhIGJvb2xlYW4gYXR0cmlidXRlIGZvciA8aWZyYW1lPixcbiAgICAgIC8vIGJ1dCBGbGFzaCBleHBlY3RzIGEgdmFsdWUgb2YgXCJ0cnVlXCIgd2hlbiB1c2VkIG9uIDxlbWJlZD4gdGFnXG4gICAgICB2YWx1ZSA9IGtleSA9PT0gJ2FsbG93ZnVsbHNjcmVlbicgJiYgZWwudGFnTmFtZSA9PT0gJ0VNQkVEJ1xuICAgICAgICA/ICd0cnVlJ1xuICAgICAgICA6IGtleTtcbiAgICAgIGVsLnNldEF0dHJpYnV0ZShrZXksIHZhbHVlKTtcbiAgICB9XG4gIH0gZWxzZSBpZiAoaXNFbnVtZXJhdGVkQXR0cihrZXkpKSB7XG4gICAgZWwuc2V0QXR0cmlidXRlKGtleSwgY29udmVydEVudW1lcmF0ZWRWYWx1ZShrZXksIHZhbHVlKSk7XG4gIH0gZWxzZSBpZiAoaXNYbGluayhrZXkpKSB7XG4gICAgaWYgKGlzRmFsc3lBdHRyVmFsdWUodmFsdWUpKSB7XG4gICAgICBlbC5yZW1vdmVBdHRyaWJ1dGVOUyh4bGlua05TLCBnZXRYbGlua1Byb3Aoa2V5KSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGVsLnNldEF0dHJpYnV0ZU5TKHhsaW5rTlMsIGtleSwgdmFsdWUpO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBiYXNlU2V0QXR0cihlbCwga2V5LCB2YWx1ZSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gYmFzZVNldEF0dHIgKGVsLCBrZXksIHZhbHVlKSB7XG4gIGlmIChpc0ZhbHN5QXR0clZhbHVlKHZhbHVlKSkge1xuICAgIGVsLnJlbW92ZUF0dHJpYnV0ZShrZXkpO1xuICB9IGVsc2Uge1xuICAgIC8vICM3MTM4OiBJRTEwICYgMTEgZmlyZXMgaW5wdXQgZXZlbnQgd2hlbiBzZXR0aW5nIHBsYWNlaG9sZGVyIG9uXG4gICAgLy8gPHRleHRhcmVhPi4uLiBibG9jayB0aGUgZmlyc3QgaW5wdXQgZXZlbnQgYW5kIHJlbW92ZSB0aGUgYmxvY2tlclxuICAgIC8vIGltbWVkaWF0ZWx5LlxuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgIGlmIChcbiAgICAgIGlzSUUgJiYgIWlzSUU5ICYmXG4gICAgICBlbC50YWdOYW1lID09PSAnVEVYVEFSRUEnICYmXG4gICAgICBrZXkgPT09ICdwbGFjZWhvbGRlcicgJiYgdmFsdWUgIT09ICcnICYmICFlbC5fX2llcGhcbiAgICApIHtcbiAgICAgIHZhciBibG9ja2VyID0gZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgZS5zdG9wSW1tZWRpYXRlUHJvcGFnYXRpb24oKTtcbiAgICAgICAgZWwucmVtb3ZlRXZlbnRMaXN0ZW5lcignaW5wdXQnLCBibG9ja2VyKTtcbiAgICAgIH07XG4gICAgICBlbC5hZGRFdmVudExpc3RlbmVyKCdpbnB1dCcsIGJsb2NrZXIpO1xuICAgICAgLy8gJGZsb3ctZGlzYWJsZS1saW5lXG4gICAgICBlbC5fX2llcGggPSB0cnVlOyAvKiBJRSBwbGFjZWhvbGRlciBwYXRjaGVkICovXG4gICAgfVxuICAgIGVsLnNldEF0dHJpYnV0ZShrZXksIHZhbHVlKTtcbiAgfVxufVxuXG52YXIgYXR0cnMgPSB7XG4gIGNyZWF0ZTogdXBkYXRlQXR0cnMsXG4gIHVwZGF0ZTogdXBkYXRlQXR0cnNcbn07XG5cbi8qICAqL1xuXG5mdW5jdGlvbiB1cGRhdGVDbGFzcyAob2xkVm5vZGUsIHZub2RlKSB7XG4gIHZhciBlbCA9IHZub2RlLmVsbTtcbiAgdmFyIGRhdGEgPSB2bm9kZS5kYXRhO1xuICB2YXIgb2xkRGF0YSA9IG9sZFZub2RlLmRhdGE7XG4gIGlmIChcbiAgICBpc1VuZGVmKGRhdGEuc3RhdGljQ2xhc3MpICYmXG4gICAgaXNVbmRlZihkYXRhLmNsYXNzKSAmJiAoXG4gICAgICBpc1VuZGVmKG9sZERhdGEpIHx8IChcbiAgICAgICAgaXNVbmRlZihvbGREYXRhLnN0YXRpY0NsYXNzKSAmJlxuICAgICAgICBpc1VuZGVmKG9sZERhdGEuY2xhc3MpXG4gICAgICApXG4gICAgKVxuICApIHtcbiAgICByZXR1cm5cbiAgfVxuXG4gIHZhciBjbHMgPSBnZW5DbGFzc0ZvclZub2RlKHZub2RlKTtcblxuICAvLyBoYW5kbGUgdHJhbnNpdGlvbiBjbGFzc2VzXG4gIHZhciB0cmFuc2l0aW9uQ2xhc3MgPSBlbC5fdHJhbnNpdGlvbkNsYXNzZXM7XG4gIGlmIChpc0RlZih0cmFuc2l0aW9uQ2xhc3MpKSB7XG4gICAgY2xzID0gY29uY2F0KGNscywgc3RyaW5naWZ5Q2xhc3ModHJhbnNpdGlvbkNsYXNzKSk7XG4gIH1cblxuICAvLyBzZXQgdGhlIGNsYXNzXG4gIGlmIChjbHMgIT09IGVsLl9wcmV2Q2xhc3MpIHtcbiAgICBlbC5zZXRBdHRyaWJ1dGUoJ2NsYXNzJywgY2xzKTtcbiAgICBlbC5fcHJldkNsYXNzID0gY2xzO1xuICB9XG59XG5cbnZhciBrbGFzcyA9IHtcbiAgY3JlYXRlOiB1cGRhdGVDbGFzcyxcbiAgdXBkYXRlOiB1cGRhdGVDbGFzc1xufTtcblxuLyogICovXG5cbnZhciB2YWxpZERpdmlzaW9uQ2hhclJFID0gL1tcXHcpLitcXC1fJFxcXV0vO1xuXG5mdW5jdGlvbiBwYXJzZUZpbHRlcnMgKGV4cCkge1xuICB2YXIgaW5TaW5nbGUgPSBmYWxzZTtcbiAgdmFyIGluRG91YmxlID0gZmFsc2U7XG4gIHZhciBpblRlbXBsYXRlU3RyaW5nID0gZmFsc2U7XG4gIHZhciBpblJlZ2V4ID0gZmFsc2U7XG4gIHZhciBjdXJseSA9IDA7XG4gIHZhciBzcXVhcmUgPSAwO1xuICB2YXIgcGFyZW4gPSAwO1xuICB2YXIgbGFzdEZpbHRlckluZGV4ID0gMDtcbiAgdmFyIGMsIHByZXYsIGksIGV4cHJlc3Npb24sIGZpbHRlcnM7XG5cbiAgZm9yIChpID0gMDsgaSA8IGV4cC5sZW5ndGg7IGkrKykge1xuICAgIHByZXYgPSBjO1xuICAgIGMgPSBleHAuY2hhckNvZGVBdChpKTtcbiAgICBpZiAoaW5TaW5nbGUpIHtcbiAgICAgIGlmIChjID09PSAweDI3ICYmIHByZXYgIT09IDB4NUMpIHsgaW5TaW5nbGUgPSBmYWxzZTsgfVxuICAgIH0gZWxzZSBpZiAoaW5Eb3VibGUpIHtcbiAgICAgIGlmIChjID09PSAweDIyICYmIHByZXYgIT09IDB4NUMpIHsgaW5Eb3VibGUgPSBmYWxzZTsgfVxuICAgIH0gZWxzZSBpZiAoaW5UZW1wbGF0ZVN0cmluZykge1xuICAgICAgaWYgKGMgPT09IDB4NjAgJiYgcHJldiAhPT0gMHg1QykgeyBpblRlbXBsYXRlU3RyaW5nID0gZmFsc2U7IH1cbiAgICB9IGVsc2UgaWYgKGluUmVnZXgpIHtcbiAgICAgIGlmIChjID09PSAweDJmICYmIHByZXYgIT09IDB4NUMpIHsgaW5SZWdleCA9IGZhbHNlOyB9XG4gICAgfSBlbHNlIGlmIChcbiAgICAgIGMgPT09IDB4N0MgJiYgLy8gcGlwZVxuICAgICAgZXhwLmNoYXJDb2RlQXQoaSArIDEpICE9PSAweDdDICYmXG4gICAgICBleHAuY2hhckNvZGVBdChpIC0gMSkgIT09IDB4N0MgJiZcbiAgICAgICFjdXJseSAmJiAhc3F1YXJlICYmICFwYXJlblxuICAgICkge1xuICAgICAgaWYgKGV4cHJlc3Npb24gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAvLyBmaXJzdCBmaWx0ZXIsIGVuZCBvZiBleHByZXNzaW9uXG4gICAgICAgIGxhc3RGaWx0ZXJJbmRleCA9IGkgKyAxO1xuICAgICAgICBleHByZXNzaW9uID0gZXhwLnNsaWNlKDAsIGkpLnRyaW0oKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHB1c2hGaWx0ZXIoKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgc3dpdGNoIChjKSB7XG4gICAgICAgIGNhc2UgMHgyMjogaW5Eb3VibGUgPSB0cnVlOyBicmVhayAgICAgICAgIC8vIFwiXG4gICAgICAgIGNhc2UgMHgyNzogaW5TaW5nbGUgPSB0cnVlOyBicmVhayAgICAgICAgIC8vICdcbiAgICAgICAgY2FzZSAweDYwOiBpblRlbXBsYXRlU3RyaW5nID0gdHJ1ZTsgYnJlYWsgLy8gYFxuICAgICAgICBjYXNlIDB4Mjg6IHBhcmVuKys7IGJyZWFrICAgICAgICAgICAgICAgICAvLyAoXG4gICAgICAgIGNhc2UgMHgyOTogcGFyZW4tLTsgYnJlYWsgICAgICAgICAgICAgICAgIC8vIClcbiAgICAgICAgY2FzZSAweDVCOiBzcXVhcmUrKzsgYnJlYWsgICAgICAgICAgICAgICAgLy8gW1xuICAgICAgICBjYXNlIDB4NUQ6IHNxdWFyZS0tOyBicmVhayAgICAgICAgICAgICAgICAvLyBdXG4gICAgICAgIGNhc2UgMHg3QjogY3VybHkrKzsgYnJlYWsgICAgICAgICAgICAgICAgIC8vIHtcbiAgICAgICAgY2FzZSAweDdEOiBjdXJseS0tOyBicmVhayAgICAgICAgICAgICAgICAgLy8gfVxuICAgICAgfVxuICAgICAgaWYgKGMgPT09IDB4MmYpIHsgLy8gL1xuICAgICAgICB2YXIgaiA9IGkgLSAxO1xuICAgICAgICB2YXIgcCA9ICh2b2lkIDApO1xuICAgICAgICAvLyBmaW5kIGZpcnN0IG5vbi13aGl0ZXNwYWNlIHByZXYgY2hhclxuICAgICAgICBmb3IgKDsgaiA+PSAwOyBqLS0pIHtcbiAgICAgICAgICBwID0gZXhwLmNoYXJBdChqKTtcbiAgICAgICAgICBpZiAocCAhPT0gJyAnKSB7IGJyZWFrIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoIXAgfHwgIXZhbGlkRGl2aXNpb25DaGFyUkUudGVzdChwKSkge1xuICAgICAgICAgIGluUmVnZXggPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgaWYgKGV4cHJlc3Npb24gPT09IHVuZGVmaW5lZCkge1xuICAgIGV4cHJlc3Npb24gPSBleHAuc2xpY2UoMCwgaSkudHJpbSgpO1xuICB9IGVsc2UgaWYgKGxhc3RGaWx0ZXJJbmRleCAhPT0gMCkge1xuICAgIHB1c2hGaWx0ZXIoKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHB1c2hGaWx0ZXIgKCkge1xuICAgIChmaWx0ZXJzIHx8IChmaWx0ZXJzID0gW10pKS5wdXNoKGV4cC5zbGljZShsYXN0RmlsdGVySW5kZXgsIGkpLnRyaW0oKSk7XG4gICAgbGFzdEZpbHRlckluZGV4ID0gaSArIDE7XG4gIH1cblxuICBpZiAoZmlsdGVycykge1xuICAgIGZvciAoaSA9IDA7IGkgPCBmaWx0ZXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBleHByZXNzaW9uID0gd3JhcEZpbHRlcihleHByZXNzaW9uLCBmaWx0ZXJzW2ldKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZXhwcmVzc2lvblxufVxuXG5mdW5jdGlvbiB3cmFwRmlsdGVyIChleHAsIGZpbHRlcikge1xuICB2YXIgaSA9IGZpbHRlci5pbmRleE9mKCcoJyk7XG4gIGlmIChpIDwgMCkge1xuICAgIC8vIF9mOiByZXNvbHZlRmlsdGVyXG4gICAgcmV0dXJuIChcIl9mKFxcXCJcIiArIGZpbHRlciArIFwiXFxcIikoXCIgKyBleHAgKyBcIilcIilcbiAgfSBlbHNlIHtcbiAgICB2YXIgbmFtZSA9IGZpbHRlci5zbGljZSgwLCBpKTtcbiAgICB2YXIgYXJncyA9IGZpbHRlci5zbGljZShpICsgMSk7XG4gICAgcmV0dXJuIChcIl9mKFxcXCJcIiArIG5hbWUgKyBcIlxcXCIpKFwiICsgZXhwICsgKGFyZ3MgIT09ICcpJyA/ICcsJyArIGFyZ3MgOiBhcmdzKSlcbiAgfVxufVxuXG4vKiAgKi9cblxuXG5cbi8qIGVzbGludC1kaXNhYmxlIG5vLXVudXNlZC12YXJzICovXG5mdW5jdGlvbiBiYXNlV2FybiAobXNnLCByYW5nZSkge1xuICBjb25zb2xlLmVycm9yKChcIltWdWUgY29tcGlsZXJdOiBcIiArIG1zZykpO1xufVxuLyogZXNsaW50LWVuYWJsZSBuby11bnVzZWQtdmFycyAqL1xuXG5mdW5jdGlvbiBwbHVja01vZHVsZUZ1bmN0aW9uIChcbiAgbW9kdWxlcyxcbiAga2V5XG4pIHtcbiAgcmV0dXJuIG1vZHVsZXNcbiAgICA/IG1vZHVsZXMubWFwKGZ1bmN0aW9uIChtKSB7IHJldHVybiBtW2tleV07IH0pLmZpbHRlcihmdW5jdGlvbiAoXykgeyByZXR1cm4gXzsgfSlcbiAgICA6IFtdXG59XG5cbmZ1bmN0aW9uIGFkZFByb3AgKGVsLCBuYW1lLCB2YWx1ZSwgcmFuZ2UsIGR5bmFtaWMpIHtcbiAgKGVsLnByb3BzIHx8IChlbC5wcm9wcyA9IFtdKSkucHVzaChyYW5nZVNldEl0ZW0oeyBuYW1lOiBuYW1lLCB2YWx1ZTogdmFsdWUsIGR5bmFtaWM6IGR5bmFtaWMgfSwgcmFuZ2UpKTtcbiAgZWwucGxhaW4gPSBmYWxzZTtcbn1cblxuZnVuY3Rpb24gYWRkQXR0ciAoZWwsIG5hbWUsIHZhbHVlLCByYW5nZSwgZHluYW1pYykge1xuICB2YXIgYXR0cnMgPSBkeW5hbWljXG4gICAgPyAoZWwuZHluYW1pY0F0dHJzIHx8IChlbC5keW5hbWljQXR0cnMgPSBbXSkpXG4gICAgOiAoZWwuYXR0cnMgfHwgKGVsLmF0dHJzID0gW10pKTtcbiAgYXR0cnMucHVzaChyYW5nZVNldEl0ZW0oeyBuYW1lOiBuYW1lLCB2YWx1ZTogdmFsdWUsIGR5bmFtaWM6IGR5bmFtaWMgfSwgcmFuZ2UpKTtcbiAgZWwucGxhaW4gPSBmYWxzZTtcbn1cblxuLy8gYWRkIGEgcmF3IGF0dHIgKHVzZSB0aGlzIGluIHByZVRyYW5zZm9ybXMpXG5mdW5jdGlvbiBhZGRSYXdBdHRyIChlbCwgbmFtZSwgdmFsdWUsIHJhbmdlKSB7XG4gIGVsLmF0dHJzTWFwW25hbWVdID0gdmFsdWU7XG4gIGVsLmF0dHJzTGlzdC5wdXNoKHJhbmdlU2V0SXRlbSh7IG5hbWU6IG5hbWUsIHZhbHVlOiB2YWx1ZSB9LCByYW5nZSkpO1xufVxuXG5mdW5jdGlvbiBhZGREaXJlY3RpdmUgKFxuICBlbCxcbiAgbmFtZSxcbiAgcmF3TmFtZSxcbiAgdmFsdWUsXG4gIGFyZyxcbiAgaXNEeW5hbWljQXJnLFxuICBtb2RpZmllcnMsXG4gIHJhbmdlXG4pIHtcbiAgKGVsLmRpcmVjdGl2ZXMgfHwgKGVsLmRpcmVjdGl2ZXMgPSBbXSkpLnB1c2gocmFuZ2VTZXRJdGVtKHtcbiAgICBuYW1lOiBuYW1lLFxuICAgIHJhd05hbWU6IHJhd05hbWUsXG4gICAgdmFsdWU6IHZhbHVlLFxuICAgIGFyZzogYXJnLFxuICAgIGlzRHluYW1pY0FyZzogaXNEeW5hbWljQXJnLFxuICAgIG1vZGlmaWVyczogbW9kaWZpZXJzXG4gIH0sIHJhbmdlKSk7XG4gIGVsLnBsYWluID0gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIHByZXBlbmRNb2RpZmllck1hcmtlciAoc3ltYm9sLCBuYW1lLCBkeW5hbWljKSB7XG4gIHJldHVybiBkeW5hbWljXG4gICAgPyAoXCJfcChcIiArIG5hbWUgKyBcIixcXFwiXCIgKyBzeW1ib2wgKyBcIlxcXCIpXCIpXG4gICAgOiBzeW1ib2wgKyBuYW1lIC8vIG1hcmsgdGhlIGV2ZW50IGFzIGNhcHR1cmVkXG59XG5cbmZ1bmN0aW9uIGFkZEhhbmRsZXIgKFxuICBlbCxcbiAgbmFtZSxcbiAgdmFsdWUsXG4gIG1vZGlmaWVycyxcbiAgaW1wb3J0YW50LFxuICB3YXJuLFxuICByYW5nZSxcbiAgZHluYW1pY1xuKSB7XG4gIG1vZGlmaWVycyA9IG1vZGlmaWVycyB8fCBlbXB0eU9iamVjdDtcbiAgLy8gd2FybiBwcmV2ZW50IGFuZCBwYXNzaXZlIG1vZGlmaWVyXG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICBpZiAoXG4gICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiB3YXJuICYmXG4gICAgbW9kaWZpZXJzLnByZXZlbnQgJiYgbW9kaWZpZXJzLnBhc3NpdmVcbiAgKSB7XG4gICAgd2FybihcbiAgICAgICdwYXNzaXZlIGFuZCBwcmV2ZW50IGNhblxcJ3QgYmUgdXNlZCB0b2dldGhlci4gJyArXG4gICAgICAnUGFzc2l2ZSBoYW5kbGVyIGNhblxcJ3QgcHJldmVudCBkZWZhdWx0IGV2ZW50LicsXG4gICAgICByYW5nZVxuICAgICk7XG4gIH1cblxuICAvLyBub3JtYWxpemUgY2xpY2sucmlnaHQgYW5kIGNsaWNrLm1pZGRsZSBzaW5jZSB0aGV5IGRvbid0IGFjdHVhbGx5IGZpcmVcbiAgLy8gdGhpcyBpcyB0ZWNobmljYWxseSBicm93c2VyLXNwZWNpZmljLCBidXQgYXQgbGVhc3QgZm9yIG5vdyBicm93c2VycyBhcmVcbiAgLy8gdGhlIG9ubHkgdGFyZ2V0IGVudnMgdGhhdCBoYXZlIHJpZ2h0L21pZGRsZSBjbGlja3MuXG4gIGlmIChtb2RpZmllcnMucmlnaHQpIHtcbiAgICBpZiAoZHluYW1pYykge1xuICAgICAgbmFtZSA9IFwiKFwiICsgbmFtZSArIFwiKT09PSdjbGljayc/J2NvbnRleHRtZW51JzooXCIgKyBuYW1lICsgXCIpXCI7XG4gICAgfSBlbHNlIGlmIChuYW1lID09PSAnY2xpY2snKSB7XG4gICAgICBuYW1lID0gJ2NvbnRleHRtZW51JztcbiAgICAgIGRlbGV0ZSBtb2RpZmllcnMucmlnaHQ7XG4gICAgfVxuICB9IGVsc2UgaWYgKG1vZGlmaWVycy5taWRkbGUpIHtcbiAgICBpZiAoZHluYW1pYykge1xuICAgICAgbmFtZSA9IFwiKFwiICsgbmFtZSArIFwiKT09PSdjbGljayc/J21vdXNldXAnOihcIiArIG5hbWUgKyBcIilcIjtcbiAgICB9IGVsc2UgaWYgKG5hbWUgPT09ICdjbGljaycpIHtcbiAgICAgIG5hbWUgPSAnbW91c2V1cCc7XG4gICAgfVxuICB9XG5cbiAgLy8gY2hlY2sgY2FwdHVyZSBtb2RpZmllclxuICBpZiAobW9kaWZpZXJzLmNhcHR1cmUpIHtcbiAgICBkZWxldGUgbW9kaWZpZXJzLmNhcHR1cmU7XG4gICAgbmFtZSA9IHByZXBlbmRNb2RpZmllck1hcmtlcignIScsIG5hbWUsIGR5bmFtaWMpO1xuICB9XG4gIGlmIChtb2RpZmllcnMub25jZSkge1xuICAgIGRlbGV0ZSBtb2RpZmllcnMub25jZTtcbiAgICBuYW1lID0gcHJlcGVuZE1vZGlmaWVyTWFya2VyKCd+JywgbmFtZSwgZHluYW1pYyk7XG4gIH1cbiAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gIGlmIChtb2RpZmllcnMucGFzc2l2ZSkge1xuICAgIGRlbGV0ZSBtb2RpZmllcnMucGFzc2l2ZTtcbiAgICBuYW1lID0gcHJlcGVuZE1vZGlmaWVyTWFya2VyKCcmJywgbmFtZSwgZHluYW1pYyk7XG4gIH1cblxuICB2YXIgZXZlbnRzO1xuICBpZiAobW9kaWZpZXJzLm5hdGl2ZSkge1xuICAgIGRlbGV0ZSBtb2RpZmllcnMubmF0aXZlO1xuICAgIGV2ZW50cyA9IGVsLm5hdGl2ZUV2ZW50cyB8fCAoZWwubmF0aXZlRXZlbnRzID0ge30pO1xuICB9IGVsc2Uge1xuICAgIGV2ZW50cyA9IGVsLmV2ZW50cyB8fCAoZWwuZXZlbnRzID0ge30pO1xuICB9XG5cbiAgdmFyIG5ld0hhbmRsZXIgPSByYW5nZVNldEl0ZW0oeyB2YWx1ZTogdmFsdWUudHJpbSgpLCBkeW5hbWljOiBkeW5hbWljIH0sIHJhbmdlKTtcbiAgaWYgKG1vZGlmaWVycyAhPT0gZW1wdHlPYmplY3QpIHtcbiAgICBuZXdIYW5kbGVyLm1vZGlmaWVycyA9IG1vZGlmaWVycztcbiAgfVxuXG4gIHZhciBoYW5kbGVycyA9IGV2ZW50c1tuYW1lXTtcbiAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gIGlmIChBcnJheS5pc0FycmF5KGhhbmRsZXJzKSkge1xuICAgIGltcG9ydGFudCA/IGhhbmRsZXJzLnVuc2hpZnQobmV3SGFuZGxlcikgOiBoYW5kbGVycy5wdXNoKG5ld0hhbmRsZXIpO1xuICB9IGVsc2UgaWYgKGhhbmRsZXJzKSB7XG4gICAgZXZlbnRzW25hbWVdID0gaW1wb3J0YW50ID8gW25ld0hhbmRsZXIsIGhhbmRsZXJzXSA6IFtoYW5kbGVycywgbmV3SGFuZGxlcl07XG4gIH0gZWxzZSB7XG4gICAgZXZlbnRzW25hbWVdID0gbmV3SGFuZGxlcjtcbiAgfVxuXG4gIGVsLnBsYWluID0gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIGdldFJhd0JpbmRpbmdBdHRyIChcbiAgZWwsXG4gIG5hbWVcbikge1xuICByZXR1cm4gZWwucmF3QXR0cnNNYXBbJzonICsgbmFtZV0gfHxcbiAgICBlbC5yYXdBdHRyc01hcFsndi1iaW5kOicgKyBuYW1lXSB8fFxuICAgIGVsLnJhd0F0dHJzTWFwW25hbWVdXG59XG5cbmZ1bmN0aW9uIGdldEJpbmRpbmdBdHRyIChcbiAgZWwsXG4gIG5hbWUsXG4gIGdldFN0YXRpY1xuKSB7XG4gIHZhciBkeW5hbWljVmFsdWUgPVxuICAgIGdldEFuZFJlbW92ZUF0dHIoZWwsICc6JyArIG5hbWUpIHx8XG4gICAgZ2V0QW5kUmVtb3ZlQXR0cihlbCwgJ3YtYmluZDonICsgbmFtZSk7XG4gIGlmIChkeW5hbWljVmFsdWUgIT0gbnVsbCkge1xuICAgIHJldHVybiBwYXJzZUZpbHRlcnMoZHluYW1pY1ZhbHVlKVxuICB9IGVsc2UgaWYgKGdldFN0YXRpYyAhPT0gZmFsc2UpIHtcbiAgICB2YXIgc3RhdGljVmFsdWUgPSBnZXRBbmRSZW1vdmVBdHRyKGVsLCBuYW1lKTtcbiAgICBpZiAoc3RhdGljVmFsdWUgIT0gbnVsbCkge1xuICAgICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KHN0YXRpY1ZhbHVlKVxuICAgIH1cbiAgfVxufVxuXG4vLyBub3RlOiB0aGlzIG9ubHkgcmVtb3ZlcyB0aGUgYXR0ciBmcm9tIHRoZSBBcnJheSAoYXR0cnNMaXN0KSBzbyB0aGF0IGl0XG4vLyBkb2Vzbid0IGdldCBwcm9jZXNzZWQgYnkgcHJvY2Vzc0F0dHJzLlxuLy8gQnkgZGVmYXVsdCBpdCBkb2VzIE5PVCByZW1vdmUgaXQgZnJvbSB0aGUgbWFwIChhdHRyc01hcCkgYmVjYXVzZSB0aGUgbWFwIGlzXG4vLyBuZWVkZWQgZHVyaW5nIGNvZGVnZW4uXG5mdW5jdGlvbiBnZXRBbmRSZW1vdmVBdHRyIChcbiAgZWwsXG4gIG5hbWUsXG4gIHJlbW92ZUZyb21NYXBcbikge1xuICB2YXIgdmFsO1xuICBpZiAoKHZhbCA9IGVsLmF0dHJzTWFwW25hbWVdKSAhPSBudWxsKSB7XG4gICAgdmFyIGxpc3QgPSBlbC5hdHRyc0xpc3Q7XG4gICAgZm9yICh2YXIgaSA9IDAsIGwgPSBsaXN0Lmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgaWYgKGxpc3RbaV0ubmFtZSA9PT0gbmFtZSkge1xuICAgICAgICBsaXN0LnNwbGljZShpLCAxKTtcbiAgICAgICAgYnJlYWtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgaWYgKHJlbW92ZUZyb21NYXApIHtcbiAgICBkZWxldGUgZWwuYXR0cnNNYXBbbmFtZV07XG4gIH1cbiAgcmV0dXJuIHZhbFxufVxuXG5mdW5jdGlvbiBnZXRBbmRSZW1vdmVBdHRyQnlSZWdleCAoXG4gIGVsLFxuICBuYW1lXG4pIHtcbiAgdmFyIGxpc3QgPSBlbC5hdHRyc0xpc3Q7XG4gIGZvciAodmFyIGkgPSAwLCBsID0gbGlzdC5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICB2YXIgYXR0ciA9IGxpc3RbaV07XG4gICAgaWYgKG5hbWUudGVzdChhdHRyLm5hbWUpKSB7XG4gICAgICBsaXN0LnNwbGljZShpLCAxKTtcbiAgICAgIHJldHVybiBhdHRyXG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIHJhbmdlU2V0SXRlbSAoXG4gIGl0ZW0sXG4gIHJhbmdlXG4pIHtcbiAgaWYgKHJhbmdlKSB7XG4gICAgaWYgKHJhbmdlLnN0YXJ0ICE9IG51bGwpIHtcbiAgICAgIGl0ZW0uc3RhcnQgPSByYW5nZS5zdGFydDtcbiAgICB9XG4gICAgaWYgKHJhbmdlLmVuZCAhPSBudWxsKSB7XG4gICAgICBpdGVtLmVuZCA9IHJhbmdlLmVuZDtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGl0ZW1cbn1cblxuLyogICovXG5cbi8qKlxuICogQ3Jvc3MtcGxhdGZvcm0gY29kZSBnZW5lcmF0aW9uIGZvciBjb21wb25lbnQgdi1tb2RlbFxuICovXG5mdW5jdGlvbiBnZW5Db21wb25lbnRNb2RlbCAoXG4gIGVsLFxuICB2YWx1ZSxcbiAgbW9kaWZpZXJzXG4pIHtcbiAgdmFyIHJlZiA9IG1vZGlmaWVycyB8fCB7fTtcbiAgdmFyIG51bWJlciA9IHJlZi5udW1iZXI7XG4gIHZhciB0cmltID0gcmVmLnRyaW07XG5cbiAgdmFyIGJhc2VWYWx1ZUV4cHJlc3Npb24gPSAnJCR2JztcbiAgdmFyIHZhbHVlRXhwcmVzc2lvbiA9IGJhc2VWYWx1ZUV4cHJlc3Npb247XG4gIGlmICh0cmltKSB7XG4gICAgdmFsdWVFeHByZXNzaW9uID1cbiAgICAgIFwiKHR5cGVvZiBcIiArIGJhc2VWYWx1ZUV4cHJlc3Npb24gKyBcIiA9PT0gJ3N0cmluZydcIiArXG4gICAgICBcIj8gXCIgKyBiYXNlVmFsdWVFeHByZXNzaW9uICsgXCIudHJpbSgpXCIgK1xuICAgICAgXCI6IFwiICsgYmFzZVZhbHVlRXhwcmVzc2lvbiArIFwiKVwiO1xuICB9XG4gIGlmIChudW1iZXIpIHtcbiAgICB2YWx1ZUV4cHJlc3Npb24gPSBcIl9uKFwiICsgdmFsdWVFeHByZXNzaW9uICsgXCIpXCI7XG4gIH1cbiAgdmFyIGFzc2lnbm1lbnQgPSBnZW5Bc3NpZ25tZW50Q29kZSh2YWx1ZSwgdmFsdWVFeHByZXNzaW9uKTtcblxuICBlbC5tb2RlbCA9IHtcbiAgICB2YWx1ZTogKFwiKFwiICsgdmFsdWUgKyBcIilcIiksXG4gICAgZXhwcmVzc2lvbjogSlNPTi5zdHJpbmdpZnkodmFsdWUpLFxuICAgIGNhbGxiYWNrOiAoXCJmdW5jdGlvbiAoXCIgKyBiYXNlVmFsdWVFeHByZXNzaW9uICsgXCIpIHtcIiArIGFzc2lnbm1lbnQgKyBcIn1cIilcbiAgfTtcbn1cblxuLyoqXG4gKiBDcm9zcy1wbGF0Zm9ybSBjb2RlZ2VuIGhlbHBlciBmb3IgZ2VuZXJhdGluZyB2LW1vZGVsIHZhbHVlIGFzc2lnbm1lbnQgY29kZS5cbiAqL1xuZnVuY3Rpb24gZ2VuQXNzaWdubWVudENvZGUgKFxuICB2YWx1ZSxcbiAgYXNzaWdubWVudFxuKSB7XG4gIHZhciByZXMgPSBwYXJzZU1vZGVsKHZhbHVlKTtcbiAgaWYgKHJlcy5rZXkgPT09IG51bGwpIHtcbiAgICByZXR1cm4gKHZhbHVlICsgXCI9XCIgKyBhc3NpZ25tZW50KVxuICB9IGVsc2Uge1xuICAgIHJldHVybiAoXCIkc2V0KFwiICsgKHJlcy5leHApICsgXCIsIFwiICsgKHJlcy5rZXkpICsgXCIsIFwiICsgYXNzaWdubWVudCArIFwiKVwiKVxuICB9XG59XG5cbi8qKlxuICogUGFyc2UgYSB2LW1vZGVsIGV4cHJlc3Npb24gaW50byBhIGJhc2UgcGF0aCBhbmQgYSBmaW5hbCBrZXkgc2VnbWVudC5cbiAqIEhhbmRsZXMgYm90aCBkb3QtcGF0aCBhbmQgcG9zc2libGUgc3F1YXJlIGJyYWNrZXRzLlxuICpcbiAqIFBvc3NpYmxlIGNhc2VzOlxuICpcbiAqIC0gdGVzdFxuICogLSB0ZXN0W2tleV1cbiAqIC0gdGVzdFt0ZXN0MVtrZXldXVxuICogLSB0ZXN0W1wiYVwiXVtrZXldXG4gKiAtIHh4eC50ZXN0W2FbYV0udGVzdDFba2V5XV1cbiAqIC0gdGVzdC54eHguYVtcImFzYVwiXVt0ZXN0MVtrZXldXVxuICpcbiAqL1xuXG52YXIgbGVuLCBzdHIsIGNociwgaW5kZXgkMSwgZXhwcmVzc2lvblBvcywgZXhwcmVzc2lvbkVuZFBvcztcblxuXG5cbmZ1bmN0aW9uIHBhcnNlTW9kZWwgKHZhbCkge1xuICAvLyBGaXggaHR0cHM6Ly9naXRodWIuY29tL3Z1ZWpzL3Z1ZS9wdWxsLzc3MzBcbiAgLy8gYWxsb3cgdi1tb2RlbD1cIm9iai52YWwgXCIgKHRyYWlsaW5nIHdoaXRlc3BhY2UpXG4gIHZhbCA9IHZhbC50cmltKCk7XG4gIGxlbiA9IHZhbC5sZW5ndGg7XG5cbiAgaWYgKHZhbC5pbmRleE9mKCdbJykgPCAwIHx8IHZhbC5sYXN0SW5kZXhPZignXScpIDwgbGVuIC0gMSkge1xuICAgIGluZGV4JDEgPSB2YWwubGFzdEluZGV4T2YoJy4nKTtcbiAgICBpZiAoaW5kZXgkMSA+IC0xKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBleHA6IHZhbC5zbGljZSgwLCBpbmRleCQxKSxcbiAgICAgICAga2V5OiAnXCInICsgdmFsLnNsaWNlKGluZGV4JDEgKyAxKSArICdcIidcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgZXhwOiB2YWwsXG4gICAgICAgIGtleTogbnVsbFxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHN0ciA9IHZhbDtcbiAgaW5kZXgkMSA9IGV4cHJlc3Npb25Qb3MgPSBleHByZXNzaW9uRW5kUG9zID0gMDtcblxuICB3aGlsZSAoIWVvZigpKSB7XG4gICAgY2hyID0gbmV4dCgpO1xuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgIGlmIChpc1N0cmluZ1N0YXJ0KGNocikpIHtcbiAgICAgIHBhcnNlU3RyaW5nKGNocik7XG4gICAgfSBlbHNlIGlmIChjaHIgPT09IDB4NUIpIHtcbiAgICAgIHBhcnNlQnJhY2tldChjaHIpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB7XG4gICAgZXhwOiB2YWwuc2xpY2UoMCwgZXhwcmVzc2lvblBvcyksXG4gICAga2V5OiB2YWwuc2xpY2UoZXhwcmVzc2lvblBvcyArIDEsIGV4cHJlc3Npb25FbmRQb3MpXG4gIH1cbn1cblxuZnVuY3Rpb24gbmV4dCAoKSB7XG4gIHJldHVybiBzdHIuY2hhckNvZGVBdCgrK2luZGV4JDEpXG59XG5cbmZ1bmN0aW9uIGVvZiAoKSB7XG4gIHJldHVybiBpbmRleCQxID49IGxlblxufVxuXG5mdW5jdGlvbiBpc1N0cmluZ1N0YXJ0IChjaHIpIHtcbiAgcmV0dXJuIGNociA9PT0gMHgyMiB8fCBjaHIgPT09IDB4Mjdcbn1cblxuZnVuY3Rpb24gcGFyc2VCcmFja2V0IChjaHIpIHtcbiAgdmFyIGluQnJhY2tldCA9IDE7XG4gIGV4cHJlc3Npb25Qb3MgPSBpbmRleCQxO1xuICB3aGlsZSAoIWVvZigpKSB7XG4gICAgY2hyID0gbmV4dCgpO1xuICAgIGlmIChpc1N0cmluZ1N0YXJ0KGNocikpIHtcbiAgICAgIHBhcnNlU3RyaW5nKGNocik7XG4gICAgICBjb250aW51ZVxuICAgIH1cbiAgICBpZiAoY2hyID09PSAweDVCKSB7IGluQnJhY2tldCsrOyB9XG4gICAgaWYgKGNociA9PT0gMHg1RCkgeyBpbkJyYWNrZXQtLTsgfVxuICAgIGlmIChpbkJyYWNrZXQgPT09IDApIHtcbiAgICAgIGV4cHJlc3Npb25FbmRQb3MgPSBpbmRleCQxO1xuICAgICAgYnJlYWtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gcGFyc2VTdHJpbmcgKGNocikge1xuICB2YXIgc3RyaW5nUXVvdGUgPSBjaHI7XG4gIHdoaWxlICghZW9mKCkpIHtcbiAgICBjaHIgPSBuZXh0KCk7XG4gICAgaWYgKGNociA9PT0gc3RyaW5nUXVvdGUpIHtcbiAgICAgIGJyZWFrXG4gICAgfVxuICB9XG59XG5cbi8qICAqL1xuXG52YXIgd2FybiQxO1xuXG4vLyBpbiBzb21lIGNhc2VzLCB0aGUgZXZlbnQgdXNlZCBoYXMgdG8gYmUgZGV0ZXJtaW5lZCBhdCBydW50aW1lXG4vLyBzbyB3ZSB1c2VkIHNvbWUgcmVzZXJ2ZWQgdG9rZW5zIGR1cmluZyBjb21waWxlLlxudmFyIFJBTkdFX1RPS0VOID0gJ19fcic7XG52YXIgQ0hFQ0tCT1hfUkFESU9fVE9LRU4gPSAnX19jJztcblxuZnVuY3Rpb24gbW9kZWwgKFxuICBlbCxcbiAgZGlyLFxuICBfd2FyblxuKSB7XG4gIHdhcm4kMSA9IF93YXJuO1xuICB2YXIgdmFsdWUgPSBkaXIudmFsdWU7XG4gIHZhciBtb2RpZmllcnMgPSBkaXIubW9kaWZpZXJzO1xuICB2YXIgdGFnID0gZWwudGFnO1xuICB2YXIgdHlwZSA9IGVsLmF0dHJzTWFwLnR5cGU7XG5cbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAvLyBpbnB1dHMgd2l0aCB0eXBlPVwiZmlsZVwiIGFyZSByZWFkIG9ubHkgYW5kIHNldHRpbmcgdGhlIGlucHV0J3NcbiAgICAvLyB2YWx1ZSB3aWxsIHRocm93IGFuIGVycm9yLlxuICAgIGlmICh0YWcgPT09ICdpbnB1dCcgJiYgdHlwZSA9PT0gJ2ZpbGUnKSB7XG4gICAgICB3YXJuJDEoXG4gICAgICAgIFwiPFwiICsgKGVsLnRhZykgKyBcIiB2LW1vZGVsPVxcXCJcIiArIHZhbHVlICsgXCJcXFwiIHR5cGU9XFxcImZpbGVcXFwiPjpcXG5cIiArXG4gICAgICAgIFwiRmlsZSBpbnB1dHMgYXJlIHJlYWQgb25seS4gVXNlIGEgdi1vbjpjaGFuZ2UgbGlzdGVuZXIgaW5zdGVhZC5cIixcbiAgICAgICAgZWwucmF3QXR0cnNNYXBbJ3YtbW9kZWwnXVxuICAgICAgKTtcbiAgICB9XG4gIH1cblxuICBpZiAoZWwuY29tcG9uZW50KSB7XG4gICAgZ2VuQ29tcG9uZW50TW9kZWwoZWwsIHZhbHVlLCBtb2RpZmllcnMpO1xuICAgIC8vIGNvbXBvbmVudCB2LW1vZGVsIGRvZXNuJ3QgbmVlZCBleHRyYSBydW50aW1lXG4gICAgcmV0dXJuIGZhbHNlXG4gIH0gZWxzZSBpZiAodGFnID09PSAnc2VsZWN0Jykge1xuICAgIGdlblNlbGVjdChlbCwgdmFsdWUsIG1vZGlmaWVycyk7XG4gIH0gZWxzZSBpZiAodGFnID09PSAnaW5wdXQnICYmIHR5cGUgPT09ICdjaGVja2JveCcpIHtcbiAgICBnZW5DaGVja2JveE1vZGVsKGVsLCB2YWx1ZSwgbW9kaWZpZXJzKTtcbiAgfSBlbHNlIGlmICh0YWcgPT09ICdpbnB1dCcgJiYgdHlwZSA9PT0gJ3JhZGlvJykge1xuICAgIGdlblJhZGlvTW9kZWwoZWwsIHZhbHVlLCBtb2RpZmllcnMpO1xuICB9IGVsc2UgaWYgKHRhZyA9PT0gJ2lucHV0JyB8fCB0YWcgPT09ICd0ZXh0YXJlYScpIHtcbiAgICBnZW5EZWZhdWx0TW9kZWwoZWwsIHZhbHVlLCBtb2RpZmllcnMpO1xuICB9IGVsc2UgaWYgKCFjb25maWcuaXNSZXNlcnZlZFRhZyh0YWcpKSB7XG4gICAgZ2VuQ29tcG9uZW50TW9kZWwoZWwsIHZhbHVlLCBtb2RpZmllcnMpO1xuICAgIC8vIGNvbXBvbmVudCB2LW1vZGVsIGRvZXNuJ3QgbmVlZCBleHRyYSBydW50aW1lXG4gICAgcmV0dXJuIGZhbHNlXG4gIH0gZWxzZSBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgIHdhcm4kMShcbiAgICAgIFwiPFwiICsgKGVsLnRhZykgKyBcIiB2LW1vZGVsPVxcXCJcIiArIHZhbHVlICsgXCJcXFwiPjogXCIgK1xuICAgICAgXCJ2LW1vZGVsIGlzIG5vdCBzdXBwb3J0ZWQgb24gdGhpcyBlbGVtZW50IHR5cGUuIFwiICtcbiAgICAgICdJZiB5b3UgYXJlIHdvcmtpbmcgd2l0aCBjb250ZW50ZWRpdGFibGUsIGl0XFwncyByZWNvbW1lbmRlZCB0byAnICtcbiAgICAgICd3cmFwIGEgbGlicmFyeSBkZWRpY2F0ZWQgZm9yIHRoYXQgcHVycG9zZSBpbnNpZGUgYSBjdXN0b20gY29tcG9uZW50LicsXG4gICAgICBlbC5yYXdBdHRyc01hcFsndi1tb2RlbCddXG4gICAgKTtcbiAgfVxuXG4gIC8vIGVuc3VyZSBydW50aW1lIGRpcmVjdGl2ZSBtZXRhZGF0YVxuICByZXR1cm4gdHJ1ZVxufVxuXG5mdW5jdGlvbiBnZW5DaGVja2JveE1vZGVsIChcbiAgZWwsXG4gIHZhbHVlLFxuICBtb2RpZmllcnNcbikge1xuICB2YXIgbnVtYmVyID0gbW9kaWZpZXJzICYmIG1vZGlmaWVycy5udW1iZXI7XG4gIHZhciB2YWx1ZUJpbmRpbmcgPSBnZXRCaW5kaW5nQXR0cihlbCwgJ3ZhbHVlJykgfHwgJ251bGwnO1xuICB2YXIgdHJ1ZVZhbHVlQmluZGluZyA9IGdldEJpbmRpbmdBdHRyKGVsLCAndHJ1ZS12YWx1ZScpIHx8ICd0cnVlJztcbiAgdmFyIGZhbHNlVmFsdWVCaW5kaW5nID0gZ2V0QmluZGluZ0F0dHIoZWwsICdmYWxzZS12YWx1ZScpIHx8ICdmYWxzZSc7XG4gIGFkZFByb3AoZWwsICdjaGVja2VkJyxcbiAgICBcIkFycmF5LmlzQXJyYXkoXCIgKyB2YWx1ZSArIFwiKVwiICtcbiAgICBcIj9faShcIiArIHZhbHVlICsgXCIsXCIgKyB2YWx1ZUJpbmRpbmcgKyBcIik+LTFcIiArIChcbiAgICAgIHRydWVWYWx1ZUJpbmRpbmcgPT09ICd0cnVlJ1xuICAgICAgICA/IChcIjooXCIgKyB2YWx1ZSArIFwiKVwiKVxuICAgICAgICA6IChcIjpfcShcIiArIHZhbHVlICsgXCIsXCIgKyB0cnVlVmFsdWVCaW5kaW5nICsgXCIpXCIpXG4gICAgKVxuICApO1xuICBhZGRIYW5kbGVyKGVsLCAnY2hhbmdlJyxcbiAgICBcInZhciAkJGE9XCIgKyB2YWx1ZSArIFwiLFwiICtcbiAgICAgICAgJyQkZWw9JGV2ZW50LnRhcmdldCwnICtcbiAgICAgICAgXCIkJGM9JCRlbC5jaGVja2VkPyhcIiArIHRydWVWYWx1ZUJpbmRpbmcgKyBcIik6KFwiICsgZmFsc2VWYWx1ZUJpbmRpbmcgKyBcIik7XCIgK1xuICAgICdpZihBcnJheS5pc0FycmF5KCQkYSkpeycgK1xuICAgICAgXCJ2YXIgJCR2PVwiICsgKG51bWJlciA/ICdfbignICsgdmFsdWVCaW5kaW5nICsgJyknIDogdmFsdWVCaW5kaW5nKSArIFwiLFwiICtcbiAgICAgICAgICAnJCRpPV9pKCQkYSwkJHYpOycgK1xuICAgICAgXCJpZigkJGVsLmNoZWNrZWQpeyQkaTwwJiYoXCIgKyAoZ2VuQXNzaWdubWVudENvZGUodmFsdWUsICckJGEuY29uY2F0KFskJHZdKScpKSArIFwiKX1cIiArXG4gICAgICBcImVsc2V7JCRpPi0xJiYoXCIgKyAoZ2VuQXNzaWdubWVudENvZGUodmFsdWUsICckJGEuc2xpY2UoMCwkJGkpLmNvbmNhdCgkJGEuc2xpY2UoJCRpKzEpKScpKSArIFwiKX1cIiArXG4gICAgXCJ9ZWxzZXtcIiArIChnZW5Bc3NpZ25tZW50Q29kZSh2YWx1ZSwgJyQkYycpKSArIFwifVwiLFxuICAgIG51bGwsIHRydWVcbiAgKTtcbn1cblxuZnVuY3Rpb24gZ2VuUmFkaW9Nb2RlbCAoXG4gIGVsLFxuICB2YWx1ZSxcbiAgbW9kaWZpZXJzXG4pIHtcbiAgdmFyIG51bWJlciA9IG1vZGlmaWVycyAmJiBtb2RpZmllcnMubnVtYmVyO1xuICB2YXIgdmFsdWVCaW5kaW5nID0gZ2V0QmluZGluZ0F0dHIoZWwsICd2YWx1ZScpIHx8ICdudWxsJztcbiAgdmFsdWVCaW5kaW5nID0gbnVtYmVyID8gKFwiX24oXCIgKyB2YWx1ZUJpbmRpbmcgKyBcIilcIikgOiB2YWx1ZUJpbmRpbmc7XG4gIGFkZFByb3AoZWwsICdjaGVja2VkJywgKFwiX3EoXCIgKyB2YWx1ZSArIFwiLFwiICsgdmFsdWVCaW5kaW5nICsgXCIpXCIpKTtcbiAgYWRkSGFuZGxlcihlbCwgJ2NoYW5nZScsIGdlbkFzc2lnbm1lbnRDb2RlKHZhbHVlLCB2YWx1ZUJpbmRpbmcpLCBudWxsLCB0cnVlKTtcbn1cblxuZnVuY3Rpb24gZ2VuU2VsZWN0IChcbiAgZWwsXG4gIHZhbHVlLFxuICBtb2RpZmllcnNcbikge1xuICB2YXIgbnVtYmVyID0gbW9kaWZpZXJzICYmIG1vZGlmaWVycy5udW1iZXI7XG4gIHZhciBzZWxlY3RlZFZhbCA9IFwiQXJyYXkucHJvdG90eXBlLmZpbHRlclwiICtcbiAgICBcIi5jYWxsKCRldmVudC50YXJnZXQub3B0aW9ucyxmdW5jdGlvbihvKXtyZXR1cm4gby5zZWxlY3RlZH0pXCIgK1xuICAgIFwiLm1hcChmdW5jdGlvbihvKXt2YXIgdmFsID0gXFxcIl92YWx1ZVxcXCIgaW4gbyA/IG8uX3ZhbHVlIDogby52YWx1ZTtcIiArXG4gICAgXCJyZXR1cm4gXCIgKyAobnVtYmVyID8gJ19uKHZhbCknIDogJ3ZhbCcpICsgXCJ9KVwiO1xuXG4gIHZhciBhc3NpZ25tZW50ID0gJyRldmVudC50YXJnZXQubXVsdGlwbGUgPyAkJHNlbGVjdGVkVmFsIDogJCRzZWxlY3RlZFZhbFswXSc7XG4gIHZhciBjb2RlID0gXCJ2YXIgJCRzZWxlY3RlZFZhbCA9IFwiICsgc2VsZWN0ZWRWYWwgKyBcIjtcIjtcbiAgY29kZSA9IGNvZGUgKyBcIiBcIiArIChnZW5Bc3NpZ25tZW50Q29kZSh2YWx1ZSwgYXNzaWdubWVudCkpO1xuICBhZGRIYW5kbGVyKGVsLCAnY2hhbmdlJywgY29kZSwgbnVsbCwgdHJ1ZSk7XG59XG5cbmZ1bmN0aW9uIGdlbkRlZmF1bHRNb2RlbCAoXG4gIGVsLFxuICB2YWx1ZSxcbiAgbW9kaWZpZXJzXG4pIHtcbiAgdmFyIHR5cGUgPSBlbC5hdHRyc01hcC50eXBlO1xuXG4gIC8vIHdhcm4gaWYgdi1iaW5kOnZhbHVlIGNvbmZsaWN0cyB3aXRoIHYtbW9kZWxcbiAgLy8gZXhjZXB0IGZvciBpbnB1dHMgd2l0aCB2LWJpbmQ6dHlwZVxuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgIHZhciB2YWx1ZSQxID0gZWwuYXR0cnNNYXBbJ3YtYmluZDp2YWx1ZSddIHx8IGVsLmF0dHJzTWFwWyc6dmFsdWUnXTtcbiAgICB2YXIgdHlwZUJpbmRpbmcgPSBlbC5hdHRyc01hcFsndi1iaW5kOnR5cGUnXSB8fCBlbC5hdHRyc01hcFsnOnR5cGUnXTtcbiAgICBpZiAodmFsdWUkMSAmJiAhdHlwZUJpbmRpbmcpIHtcbiAgICAgIHZhciBiaW5kaW5nID0gZWwuYXR0cnNNYXBbJ3YtYmluZDp2YWx1ZSddID8gJ3YtYmluZDp2YWx1ZScgOiAnOnZhbHVlJztcbiAgICAgIHdhcm4kMShcbiAgICAgICAgYmluZGluZyArIFwiPVxcXCJcIiArIHZhbHVlJDEgKyBcIlxcXCIgY29uZmxpY3RzIHdpdGggdi1tb2RlbCBvbiB0aGUgc2FtZSBlbGVtZW50IFwiICtcbiAgICAgICAgJ2JlY2F1c2UgdGhlIGxhdHRlciBhbHJlYWR5IGV4cGFuZHMgdG8gYSB2YWx1ZSBiaW5kaW5nIGludGVybmFsbHknLFxuICAgICAgICBlbC5yYXdBdHRyc01hcFtiaW5kaW5nXVxuICAgICAgKTtcbiAgICB9XG4gIH1cblxuICB2YXIgcmVmID0gbW9kaWZpZXJzIHx8IHt9O1xuICB2YXIgbGF6eSA9IHJlZi5sYXp5O1xuICB2YXIgbnVtYmVyID0gcmVmLm51bWJlcjtcbiAgdmFyIHRyaW0gPSByZWYudHJpbTtcbiAgdmFyIG5lZWRDb21wb3NpdGlvbkd1YXJkID0gIWxhenkgJiYgdHlwZSAhPT0gJ3JhbmdlJztcbiAgdmFyIGV2ZW50ID0gbGF6eVxuICAgID8gJ2NoYW5nZSdcbiAgICA6IHR5cGUgPT09ICdyYW5nZSdcbiAgICAgID8gUkFOR0VfVE9LRU5cbiAgICAgIDogJ2lucHV0JztcblxuICB2YXIgdmFsdWVFeHByZXNzaW9uID0gJyRldmVudC50YXJnZXQudmFsdWUnO1xuICBpZiAodHJpbSkge1xuICAgIHZhbHVlRXhwcmVzc2lvbiA9IFwiJGV2ZW50LnRhcmdldC52YWx1ZS50cmltKClcIjtcbiAgfVxuICBpZiAobnVtYmVyKSB7XG4gICAgdmFsdWVFeHByZXNzaW9uID0gXCJfbihcIiArIHZhbHVlRXhwcmVzc2lvbiArIFwiKVwiO1xuICB9XG5cbiAgdmFyIGNvZGUgPSBnZW5Bc3NpZ25tZW50Q29kZSh2YWx1ZSwgdmFsdWVFeHByZXNzaW9uKTtcbiAgaWYgKG5lZWRDb21wb3NpdGlvbkd1YXJkKSB7XG4gICAgY29kZSA9IFwiaWYoJGV2ZW50LnRhcmdldC5jb21wb3NpbmcpcmV0dXJuO1wiICsgY29kZTtcbiAgfVxuXG4gIGFkZFByb3AoZWwsICd2YWx1ZScsIChcIihcIiArIHZhbHVlICsgXCIpXCIpKTtcbiAgYWRkSGFuZGxlcihlbCwgZXZlbnQsIGNvZGUsIG51bGwsIHRydWUpO1xuICBpZiAodHJpbSB8fCBudW1iZXIpIHtcbiAgICBhZGRIYW5kbGVyKGVsLCAnYmx1cicsICckZm9yY2VVcGRhdGUoKScpO1xuICB9XG59XG5cbi8qICAqL1xuXG4vLyBub3JtYWxpemUgdi1tb2RlbCBldmVudCB0b2tlbnMgdGhhdCBjYW4gb25seSBiZSBkZXRlcm1pbmVkIGF0IHJ1bnRpbWUuXG4vLyBpdCdzIGltcG9ydGFudCB0byBwbGFjZSB0aGUgZXZlbnQgYXMgdGhlIGZpcnN0IGluIHRoZSBhcnJheSBiZWNhdXNlXG4vLyB0aGUgd2hvbGUgcG9pbnQgaXMgZW5zdXJpbmcgdGhlIHYtbW9kZWwgY2FsbGJhY2sgZ2V0cyBjYWxsZWQgYmVmb3JlXG4vLyB1c2VyLWF0dGFjaGVkIGhhbmRsZXJzLlxuZnVuY3Rpb24gbm9ybWFsaXplRXZlbnRzIChvbikge1xuICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgaWYgKGlzRGVmKG9uW1JBTkdFX1RPS0VOXSkpIHtcbiAgICAvLyBJRSBpbnB1dFt0eXBlPXJhbmdlXSBvbmx5IHN1cHBvcnRzIGBjaGFuZ2VgIGV2ZW50XG4gICAgdmFyIGV2ZW50ID0gaXNJRSA/ICdjaGFuZ2UnIDogJ2lucHV0JztcbiAgICBvbltldmVudF0gPSBbXS5jb25jYXQob25bUkFOR0VfVE9LRU5dLCBvbltldmVudF0gfHwgW10pO1xuICAgIGRlbGV0ZSBvbltSQU5HRV9UT0tFTl07XG4gIH1cbiAgLy8gVGhpcyB3YXMgb3JpZ2luYWxseSBpbnRlbmRlZCB0byBmaXggIzQ1MjEgYnV0IG5vIGxvbmdlciBuZWNlc3NhcnlcbiAgLy8gYWZ0ZXIgMi41LiBLZWVwaW5nIGl0IGZvciBiYWNrd2FyZHMgY29tcGF0IHdpdGggZ2VuZXJhdGVkIGNvZGUgZnJvbSA8IDIuNFxuICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgaWYgKGlzRGVmKG9uW0NIRUNLQk9YX1JBRElPX1RPS0VOXSkpIHtcbiAgICBvbi5jaGFuZ2UgPSBbXS5jb25jYXQob25bQ0hFQ0tCT1hfUkFESU9fVE9LRU5dLCBvbi5jaGFuZ2UgfHwgW10pO1xuICAgIGRlbGV0ZSBvbltDSEVDS0JPWF9SQURJT19UT0tFTl07XG4gIH1cbn1cblxudmFyIHRhcmdldCQxO1xuXG5mdW5jdGlvbiBjcmVhdGVPbmNlSGFuZGxlciQxIChldmVudCwgaGFuZGxlciwgY2FwdHVyZSkge1xuICB2YXIgX3RhcmdldCA9IHRhcmdldCQxOyAvLyBzYXZlIGN1cnJlbnQgdGFyZ2V0IGVsZW1lbnQgaW4gY2xvc3VyZVxuICByZXR1cm4gZnVuY3Rpb24gb25jZUhhbmRsZXIgKCkge1xuICAgIHZhciByZXMgPSBoYW5kbGVyLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG4gICAgaWYgKHJlcyAhPT0gbnVsbCkge1xuICAgICAgcmVtb3ZlJDIoZXZlbnQsIG9uY2VIYW5kbGVyLCBjYXB0dXJlLCBfdGFyZ2V0KTtcbiAgICB9XG4gIH1cbn1cblxuLy8gIzk0NDY6IEZpcmVmb3ggPD0gNTMgKGluIHBhcnRpY3VsYXIsIEVTUiA1MikgaGFzIGluY29ycmVjdCBFdmVudC50aW1lU3RhbXBcbi8vIGltcGxlbWVudGF0aW9uIGFuZCBkb2VzIG5vdCBmaXJlIG1pY3JvdGFza3MgaW4gYmV0d2VlbiBldmVudCBwcm9wYWdhdGlvbiwgc29cbi8vIHNhZmUgdG8gZXhjbHVkZS5cbnZhciB1c2VNaWNyb3Rhc2tGaXggPSBpc1VzaW5nTWljcm9UYXNrICYmICEoaXNGRiAmJiBOdW1iZXIoaXNGRlsxXSkgPD0gNTMpO1xuXG5mdW5jdGlvbiBhZGQkMSAoXG4gIG5hbWUsXG4gIGhhbmRsZXIsXG4gIGNhcHR1cmUsXG4gIHBhc3NpdmVcbikge1xuICAvLyBhc3luYyBlZGdlIGNhc2UgIzY1NjY6IGlubmVyIGNsaWNrIGV2ZW50IHRyaWdnZXJzIHBhdGNoLCBldmVudCBoYW5kbGVyXG4gIC8vIGF0dGFjaGVkIHRvIG91dGVyIGVsZW1lbnQgZHVyaW5nIHBhdGNoLCBhbmQgdHJpZ2dlcmVkIGFnYWluLiBUaGlzXG4gIC8vIGhhcHBlbnMgYmVjYXVzZSBicm93c2VycyBmaXJlIG1pY3JvdGFzayB0aWNrcyBiZXR3ZWVuIGV2ZW50IHByb3BhZ2F0aW9uLlxuICAvLyB0aGUgc29sdXRpb24gaXMgc2ltcGxlOiB3ZSBzYXZlIHRoZSB0aW1lc3RhbXAgd2hlbiBhIGhhbmRsZXIgaXMgYXR0YWNoZWQsXG4gIC8vIGFuZCB0aGUgaGFuZGxlciB3b3VsZCBvbmx5IGZpcmUgaWYgdGhlIGV2ZW50IHBhc3NlZCB0byBpdCB3YXMgZmlyZWRcbiAgLy8gQUZURVIgaXQgd2FzIGF0dGFjaGVkLlxuICBpZiAodXNlTWljcm90YXNrRml4KSB7XG4gICAgdmFyIGF0dGFjaGVkVGltZXN0YW1wID0gY3VycmVudEZsdXNoVGltZXN0YW1wO1xuICAgIHZhciBvcmlnaW5hbCA9IGhhbmRsZXI7XG4gICAgaGFuZGxlciA9IG9yaWdpbmFsLl93cmFwcGVyID0gZnVuY3Rpb24gKGUpIHtcbiAgICAgIGlmIChcbiAgICAgICAgLy8gbm8gYnViYmxpbmcsIHNob3VsZCBhbHdheXMgZmlyZS5cbiAgICAgICAgLy8gdGhpcyBpcyBqdXN0IGEgc2FmZXR5IG5ldCBpbiBjYXNlIGV2ZW50LnRpbWVTdGFtcCBpcyB1bnJlbGlhYmxlIGluXG4gICAgICAgIC8vIGNlcnRhaW4gd2VpcmQgZW52aXJvbm1lbnRzLi4uXG4gICAgICAgIGUudGFyZ2V0ID09PSBlLmN1cnJlbnRUYXJnZXQgfHxcbiAgICAgICAgLy8gZXZlbnQgaXMgZmlyZWQgYWZ0ZXIgaGFuZGxlciBhdHRhY2htZW50XG4gICAgICAgIGUudGltZVN0YW1wID49IGF0dGFjaGVkVGltZXN0YW1wIHx8XG4gICAgICAgIC8vIGJhaWwgZm9yIGVudmlyb25tZW50cyB0aGF0IGhhdmUgYnVnZ3kgZXZlbnQudGltZVN0YW1wIGltcGxlbWVudGF0aW9uc1xuICAgICAgICAvLyAjOTQ2MiBpT1MgOSBidWc6IGV2ZW50LnRpbWVTdGFtcCBpcyAwIGFmdGVyIGhpc3RvcnkucHVzaFN0YXRlXG4gICAgICAgIC8vICM5NjgxIFF0V2ViRW5naW5lIGV2ZW50LnRpbWVTdGFtcCBpcyBuZWdhdGl2ZSB2YWx1ZVxuICAgICAgICBlLnRpbWVTdGFtcCA8PSAwIHx8XG4gICAgICAgIC8vICM5NDQ4IGJhaWwgaWYgZXZlbnQgaXMgZmlyZWQgaW4gYW5vdGhlciBkb2N1bWVudCBpbiBhIG11bHRpLXBhZ2VcbiAgICAgICAgLy8gZWxlY3Ryb24vbncuanMgYXBwLCBzaW5jZSBldmVudC50aW1lU3RhbXAgd2lsbCBiZSB1c2luZyBhIGRpZmZlcmVudFxuICAgICAgICAvLyBzdGFydGluZyByZWZlcmVuY2VcbiAgICAgICAgZS50YXJnZXQub3duZXJEb2N1bWVudCAhPT0gZG9jdW1lbnRcbiAgICAgICkge1xuICAgICAgICByZXR1cm4gb3JpZ2luYWwuYXBwbHkodGhpcywgYXJndW1lbnRzKVxuICAgICAgfVxuICAgIH07XG4gIH1cbiAgdGFyZ2V0JDEuYWRkRXZlbnRMaXN0ZW5lcihcbiAgICBuYW1lLFxuICAgIGhhbmRsZXIsXG4gICAgc3VwcG9ydHNQYXNzaXZlXG4gICAgICA/IHsgY2FwdHVyZTogY2FwdHVyZSwgcGFzc2l2ZTogcGFzc2l2ZSB9XG4gICAgICA6IGNhcHR1cmVcbiAgKTtcbn1cblxuZnVuY3Rpb24gcmVtb3ZlJDIgKFxuICBuYW1lLFxuICBoYW5kbGVyLFxuICBjYXB0dXJlLFxuICBfdGFyZ2V0XG4pIHtcbiAgKF90YXJnZXQgfHwgdGFyZ2V0JDEpLnJlbW92ZUV2ZW50TGlzdGVuZXIoXG4gICAgbmFtZSxcbiAgICBoYW5kbGVyLl93cmFwcGVyIHx8IGhhbmRsZXIsXG4gICAgY2FwdHVyZVxuICApO1xufVxuXG5mdW5jdGlvbiB1cGRhdGVET01MaXN0ZW5lcnMgKG9sZFZub2RlLCB2bm9kZSkge1xuICBpZiAoaXNVbmRlZihvbGRWbm9kZS5kYXRhLm9uKSAmJiBpc1VuZGVmKHZub2RlLmRhdGEub24pKSB7XG4gICAgcmV0dXJuXG4gIH1cbiAgdmFyIG9uID0gdm5vZGUuZGF0YS5vbiB8fCB7fTtcbiAgdmFyIG9sZE9uID0gb2xkVm5vZGUuZGF0YS5vbiB8fCB7fTtcbiAgdGFyZ2V0JDEgPSB2bm9kZS5lbG07XG4gIG5vcm1hbGl6ZUV2ZW50cyhvbik7XG4gIHVwZGF0ZUxpc3RlbmVycyhvbiwgb2xkT24sIGFkZCQxLCByZW1vdmUkMiwgY3JlYXRlT25jZUhhbmRsZXIkMSwgdm5vZGUuY29udGV4dCk7XG4gIHRhcmdldCQxID0gdW5kZWZpbmVkO1xufVxuXG52YXIgZXZlbnRzID0ge1xuICBjcmVhdGU6IHVwZGF0ZURPTUxpc3RlbmVycyxcbiAgdXBkYXRlOiB1cGRhdGVET01MaXN0ZW5lcnNcbn07XG5cbi8qICAqL1xuXG52YXIgc3ZnQ29udGFpbmVyO1xuXG5mdW5jdGlvbiB1cGRhdGVET01Qcm9wcyAob2xkVm5vZGUsIHZub2RlKSB7XG4gIGlmIChpc1VuZGVmKG9sZFZub2RlLmRhdGEuZG9tUHJvcHMpICYmIGlzVW5kZWYodm5vZGUuZGF0YS5kb21Qcm9wcykpIHtcbiAgICByZXR1cm5cbiAgfVxuICB2YXIga2V5LCBjdXI7XG4gIHZhciBlbG0gPSB2bm9kZS5lbG07XG4gIHZhciBvbGRQcm9wcyA9IG9sZFZub2RlLmRhdGEuZG9tUHJvcHMgfHwge307XG4gIHZhciBwcm9wcyA9IHZub2RlLmRhdGEuZG9tUHJvcHMgfHwge307XG4gIC8vIGNsb25lIG9ic2VydmVkIG9iamVjdHMsIGFzIHRoZSB1c2VyIHByb2JhYmx5IHdhbnRzIHRvIG11dGF0ZSBpdFxuICBpZiAoaXNEZWYocHJvcHMuX19vYl9fKSkge1xuICAgIHByb3BzID0gdm5vZGUuZGF0YS5kb21Qcm9wcyA9IGV4dGVuZCh7fSwgcHJvcHMpO1xuICB9XG5cbiAgZm9yIChrZXkgaW4gb2xkUHJvcHMpIHtcbiAgICBpZiAoIShrZXkgaW4gcHJvcHMpKSB7XG4gICAgICBlbG1ba2V5XSA9ICcnO1xuICAgIH1cbiAgfVxuXG4gIGZvciAoa2V5IGluIHByb3BzKSB7XG4gICAgY3VyID0gcHJvcHNba2V5XTtcbiAgICAvLyBpZ25vcmUgY2hpbGRyZW4gaWYgdGhlIG5vZGUgaGFzIHRleHRDb250ZW50IG9yIGlubmVySFRNTCxcbiAgICAvLyBhcyB0aGVzZSB3aWxsIHRocm93IGF3YXkgZXhpc3RpbmcgRE9NIG5vZGVzIGFuZCBjYXVzZSByZW1vdmFsIGVycm9yc1xuICAgIC8vIG9uIHN1YnNlcXVlbnQgcGF0Y2hlcyAoIzMzNjApXG4gICAgaWYgKGtleSA9PT0gJ3RleHRDb250ZW50JyB8fCBrZXkgPT09ICdpbm5lckhUTUwnKSB7XG4gICAgICBpZiAodm5vZGUuY2hpbGRyZW4pIHsgdm5vZGUuY2hpbGRyZW4ubGVuZ3RoID0gMDsgfVxuICAgICAgaWYgKGN1ciA9PT0gb2xkUHJvcHNba2V5XSkgeyBjb250aW51ZSB9XG4gICAgICAvLyAjNjYwMSB3b3JrIGFyb3VuZCBDaHJvbWUgdmVyc2lvbiA8PSA1NSBidWcgd2hlcmUgc2luZ2xlIHRleHROb2RlXG4gICAgICAvLyByZXBsYWNlZCBieSBpbm5lckhUTUwvdGV4dENvbnRlbnQgcmV0YWlucyBpdHMgcGFyZW50Tm9kZSBwcm9wZXJ0eVxuICAgICAgaWYgKGVsbS5jaGlsZE5vZGVzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICBlbG0ucmVtb3ZlQ2hpbGQoZWxtLmNoaWxkTm9kZXNbMF0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChrZXkgPT09ICd2YWx1ZScgJiYgZWxtLnRhZ05hbWUgIT09ICdQUk9HUkVTUycpIHtcbiAgICAgIC8vIHN0b3JlIHZhbHVlIGFzIF92YWx1ZSBhcyB3ZWxsIHNpbmNlXG4gICAgICAvLyBub24tc3RyaW5nIHZhbHVlcyB3aWxsIGJlIHN0cmluZ2lmaWVkXG4gICAgICBlbG0uX3ZhbHVlID0gY3VyO1xuICAgICAgLy8gYXZvaWQgcmVzZXR0aW5nIGN1cnNvciBwb3NpdGlvbiB3aGVuIHZhbHVlIGlzIHRoZSBzYW1lXG4gICAgICB2YXIgc3RyQ3VyID0gaXNVbmRlZihjdXIpID8gJycgOiBTdHJpbmcoY3VyKTtcbiAgICAgIGlmIChzaG91bGRVcGRhdGVWYWx1ZShlbG0sIHN0ckN1cikpIHtcbiAgICAgICAgZWxtLnZhbHVlID0gc3RyQ3VyO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoa2V5ID09PSAnaW5uZXJIVE1MJyAmJiBpc1NWRyhlbG0udGFnTmFtZSkgJiYgaXNVbmRlZihlbG0uaW5uZXJIVE1MKSkge1xuICAgICAgLy8gSUUgZG9lc24ndCBzdXBwb3J0IGlubmVySFRNTCBmb3IgU1ZHIGVsZW1lbnRzXG4gICAgICBzdmdDb250YWluZXIgPSBzdmdDb250YWluZXIgfHwgZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICBzdmdDb250YWluZXIuaW5uZXJIVE1MID0gXCI8c3ZnPlwiICsgY3VyICsgXCI8L3N2Zz5cIjtcbiAgICAgIHZhciBzdmcgPSBzdmdDb250YWluZXIuZmlyc3RDaGlsZDtcbiAgICAgIHdoaWxlIChlbG0uZmlyc3RDaGlsZCkge1xuICAgICAgICBlbG0ucmVtb3ZlQ2hpbGQoZWxtLmZpcnN0Q2hpbGQpO1xuICAgICAgfVxuICAgICAgd2hpbGUgKHN2Zy5maXJzdENoaWxkKSB7XG4gICAgICAgIGVsbS5hcHBlbmRDaGlsZChzdmcuZmlyc3RDaGlsZCk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChcbiAgICAgIC8vIHNraXAgdGhlIHVwZGF0ZSBpZiBvbGQgYW5kIG5ldyBWRE9NIHN0YXRlIGlzIHRoZSBzYW1lLlxuICAgICAgLy8gYHZhbHVlYCBpcyBoYW5kbGVkIHNlcGFyYXRlbHkgYmVjYXVzZSB0aGUgRE9NIHZhbHVlIG1heSBiZSB0ZW1wb3JhcmlseVxuICAgICAgLy8gb3V0IG9mIHN5bmMgd2l0aCBWRE9NIHN0YXRlIGR1ZSB0byBmb2N1cywgY29tcG9zaXRpb24gYW5kIG1vZGlmaWVycy5cbiAgICAgIC8vIFRoaXMgICM0NTIxIGJ5IHNraXBwaW5nIHRoZSB1bm5lY2VzYXJyeSBgY2hlY2tlZGAgdXBkYXRlLlxuICAgICAgY3VyICE9PSBvbGRQcm9wc1trZXldXG4gICAgKSB7XG4gICAgICAvLyBzb21lIHByb3BlcnR5IHVwZGF0ZXMgY2FuIHRocm93XG4gICAgICAvLyBlLmcuIGB2YWx1ZWAgb24gPHByb2dyZXNzPiB3LyBub24tZmluaXRlIHZhbHVlXG4gICAgICB0cnkge1xuICAgICAgICBlbG1ba2V5XSA9IGN1cjtcbiAgICAgIH0gY2F0Y2ggKGUpIHt9XG4gICAgfVxuICB9XG59XG5cbi8vIGNoZWNrIHBsYXRmb3Jtcy93ZWIvdXRpbC9hdHRycy5qcyBhY2NlcHRWYWx1ZVxuXG5cbmZ1bmN0aW9uIHNob3VsZFVwZGF0ZVZhbHVlIChlbG0sIGNoZWNrVmFsKSB7XG4gIHJldHVybiAoIWVsbS5jb21wb3NpbmcgJiYgKFxuICAgIGVsbS50YWdOYW1lID09PSAnT1BUSU9OJyB8fFxuICAgIGlzTm90SW5Gb2N1c0FuZERpcnR5KGVsbSwgY2hlY2tWYWwpIHx8XG4gICAgaXNEaXJ0eVdpdGhNb2RpZmllcnMoZWxtLCBjaGVja1ZhbClcbiAgKSlcbn1cblxuZnVuY3Rpb24gaXNOb3RJbkZvY3VzQW5kRGlydHkgKGVsbSwgY2hlY2tWYWwpIHtcbiAgLy8gcmV0dXJuIHRydWUgd2hlbiB0ZXh0Ym94ICgubnVtYmVyIGFuZCAudHJpbSkgbG9zZXMgZm9jdXMgYW5kIGl0cyB2YWx1ZSBpc1xuICAvLyBub3QgZXF1YWwgdG8gdGhlIHVwZGF0ZWQgdmFsdWVcbiAgdmFyIG5vdEluRm9jdXMgPSB0cnVlO1xuICAvLyAjNjE1N1xuICAvLyB3b3JrIGFyb3VuZCBJRSBidWcgd2hlbiBhY2Nlc3NpbmcgZG9jdW1lbnQuYWN0aXZlRWxlbWVudCBpbiBhbiBpZnJhbWVcbiAgdHJ5IHsgbm90SW5Gb2N1cyA9IGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQgIT09IGVsbTsgfSBjYXRjaCAoZSkge31cbiAgcmV0dXJuIG5vdEluRm9jdXMgJiYgZWxtLnZhbHVlICE9PSBjaGVja1ZhbFxufVxuXG5mdW5jdGlvbiBpc0RpcnR5V2l0aE1vZGlmaWVycyAoZWxtLCBuZXdWYWwpIHtcbiAgdmFyIHZhbHVlID0gZWxtLnZhbHVlO1xuICB2YXIgbW9kaWZpZXJzID0gZWxtLl92TW9kaWZpZXJzOyAvLyBpbmplY3RlZCBieSB2LW1vZGVsIHJ1bnRpbWVcbiAgaWYgKGlzRGVmKG1vZGlmaWVycykpIHtcbiAgICBpZiAobW9kaWZpZXJzLm51bWJlcikge1xuICAgICAgcmV0dXJuIHRvTnVtYmVyKHZhbHVlKSAhPT0gdG9OdW1iZXIobmV3VmFsKVxuICAgIH1cbiAgICBpZiAobW9kaWZpZXJzLnRyaW0pIHtcbiAgICAgIHJldHVybiB2YWx1ZS50cmltKCkgIT09IG5ld1ZhbC50cmltKClcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHZhbHVlICE9PSBuZXdWYWxcbn1cblxudmFyIGRvbVByb3BzID0ge1xuICBjcmVhdGU6IHVwZGF0ZURPTVByb3BzLFxuICB1cGRhdGU6IHVwZGF0ZURPTVByb3BzXG59O1xuXG4vKiAgKi9cblxudmFyIHBhcnNlU3R5bGVUZXh0ID0gY2FjaGVkKGZ1bmN0aW9uIChjc3NUZXh0KSB7XG4gIHZhciByZXMgPSB7fTtcbiAgdmFyIGxpc3REZWxpbWl0ZXIgPSAvOyg/IVteKF0qXFwpKS9nO1xuICB2YXIgcHJvcGVydHlEZWxpbWl0ZXIgPSAvOiguKykvO1xuICBjc3NUZXh0LnNwbGl0KGxpc3REZWxpbWl0ZXIpLmZvckVhY2goZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICBpZiAoaXRlbSkge1xuICAgICAgdmFyIHRtcCA9IGl0ZW0uc3BsaXQocHJvcGVydHlEZWxpbWl0ZXIpO1xuICAgICAgdG1wLmxlbmd0aCA+IDEgJiYgKHJlc1t0bXBbMF0udHJpbSgpXSA9IHRtcFsxXS50cmltKCkpO1xuICAgIH1cbiAgfSk7XG4gIHJldHVybiByZXNcbn0pO1xuXG4vLyBtZXJnZSBzdGF0aWMgYW5kIGR5bmFtaWMgc3R5bGUgZGF0YSBvbiB0aGUgc2FtZSB2bm9kZVxuZnVuY3Rpb24gbm9ybWFsaXplU3R5bGVEYXRhIChkYXRhKSB7XG4gIHZhciBzdHlsZSA9IG5vcm1hbGl6ZVN0eWxlQmluZGluZyhkYXRhLnN0eWxlKTtcbiAgLy8gc3RhdGljIHN0eWxlIGlzIHByZS1wcm9jZXNzZWQgaW50byBhbiBvYmplY3QgZHVyaW5nIGNvbXBpbGF0aW9uXG4gIC8vIGFuZCBpcyBhbHdheXMgYSBmcmVzaCBvYmplY3QsIHNvIGl0J3Mgc2FmZSB0byBtZXJnZSBpbnRvIGl0XG4gIHJldHVybiBkYXRhLnN0YXRpY1N0eWxlXG4gICAgPyBleHRlbmQoZGF0YS5zdGF0aWNTdHlsZSwgc3R5bGUpXG4gICAgOiBzdHlsZVxufVxuXG4vLyBub3JtYWxpemUgcG9zc2libGUgYXJyYXkgLyBzdHJpbmcgdmFsdWVzIGludG8gT2JqZWN0XG5mdW5jdGlvbiBub3JtYWxpemVTdHlsZUJpbmRpbmcgKGJpbmRpbmdTdHlsZSkge1xuICBpZiAoQXJyYXkuaXNBcnJheShiaW5kaW5nU3R5bGUpKSB7XG4gICAgcmV0dXJuIHRvT2JqZWN0KGJpbmRpbmdTdHlsZSlcbiAgfVxuICBpZiAodHlwZW9mIGJpbmRpbmdTdHlsZSA9PT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gcGFyc2VTdHlsZVRleHQoYmluZGluZ1N0eWxlKVxuICB9XG4gIHJldHVybiBiaW5kaW5nU3R5bGVcbn1cblxuLyoqXG4gKiBwYXJlbnQgY29tcG9uZW50IHN0eWxlIHNob3VsZCBiZSBhZnRlciBjaGlsZCdzXG4gKiBzbyB0aGF0IHBhcmVudCBjb21wb25lbnQncyBzdHlsZSBjb3VsZCBvdmVycmlkZSBpdFxuICovXG5mdW5jdGlvbiBnZXRTdHlsZSAodm5vZGUsIGNoZWNrQ2hpbGQpIHtcbiAgdmFyIHJlcyA9IHt9O1xuICB2YXIgc3R5bGVEYXRhO1xuXG4gIGlmIChjaGVja0NoaWxkKSB7XG4gICAgdmFyIGNoaWxkTm9kZSA9IHZub2RlO1xuICAgIHdoaWxlIChjaGlsZE5vZGUuY29tcG9uZW50SW5zdGFuY2UpIHtcbiAgICAgIGNoaWxkTm9kZSA9IGNoaWxkTm9kZS5jb21wb25lbnRJbnN0YW5jZS5fdm5vZGU7XG4gICAgICBpZiAoXG4gICAgICAgIGNoaWxkTm9kZSAmJiBjaGlsZE5vZGUuZGF0YSAmJlxuICAgICAgICAoc3R5bGVEYXRhID0gbm9ybWFsaXplU3R5bGVEYXRhKGNoaWxkTm9kZS5kYXRhKSlcbiAgICAgICkge1xuICAgICAgICBleHRlbmQocmVzLCBzdHlsZURhdGEpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGlmICgoc3R5bGVEYXRhID0gbm9ybWFsaXplU3R5bGVEYXRhKHZub2RlLmRhdGEpKSkge1xuICAgIGV4dGVuZChyZXMsIHN0eWxlRGF0YSk7XG4gIH1cblxuICB2YXIgcGFyZW50Tm9kZSA9IHZub2RlO1xuICB3aGlsZSAoKHBhcmVudE5vZGUgPSBwYXJlbnROb2RlLnBhcmVudCkpIHtcbiAgICBpZiAocGFyZW50Tm9kZS5kYXRhICYmIChzdHlsZURhdGEgPSBub3JtYWxpemVTdHlsZURhdGEocGFyZW50Tm9kZS5kYXRhKSkpIHtcbiAgICAgIGV4dGVuZChyZXMsIHN0eWxlRGF0YSk7XG4gICAgfVxuICB9XG4gIHJldHVybiByZXNcbn1cblxuLyogICovXG5cbnZhciBjc3NWYXJSRSA9IC9eLS0vO1xudmFyIGltcG9ydGFudFJFID0gL1xccyohaW1wb3J0YW50JC87XG52YXIgc2V0UHJvcCA9IGZ1bmN0aW9uIChlbCwgbmFtZSwgdmFsKSB7XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICBpZiAoY3NzVmFyUkUudGVzdChuYW1lKSkge1xuICAgIGVsLnN0eWxlLnNldFByb3BlcnR5KG5hbWUsIHZhbCk7XG4gIH0gZWxzZSBpZiAoaW1wb3J0YW50UkUudGVzdCh2YWwpKSB7XG4gICAgZWwuc3R5bGUuc2V0UHJvcGVydHkoaHlwaGVuYXRlKG5hbWUpLCB2YWwucmVwbGFjZShpbXBvcnRhbnRSRSwgJycpLCAnaW1wb3J0YW50Jyk7XG4gIH0gZWxzZSB7XG4gICAgdmFyIG5vcm1hbGl6ZWROYW1lID0gbm9ybWFsaXplKG5hbWUpO1xuICAgIGlmIChBcnJheS5pc0FycmF5KHZhbCkpIHtcbiAgICAgIC8vIFN1cHBvcnQgdmFsdWVzIGFycmF5IGNyZWF0ZWQgYnkgYXV0b3ByZWZpeGVyLCBlLmcuXG4gICAgICAvLyB7ZGlzcGxheTogW1wiLXdlYmtpdC1ib3hcIiwgXCItbXMtZmxleGJveFwiLCBcImZsZXhcIl19XG4gICAgICAvLyBTZXQgdGhlbSBvbmUgYnkgb25lLCBhbmQgdGhlIGJyb3dzZXIgd2lsbCBvbmx5IHNldCB0aG9zZSBpdCBjYW4gcmVjb2duaXplXG4gICAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gdmFsLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgIGVsLnN0eWxlW25vcm1hbGl6ZWROYW1lXSA9IHZhbFtpXTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgZWwuc3R5bGVbbm9ybWFsaXplZE5hbWVdID0gdmFsO1xuICAgIH1cbiAgfVxufTtcblxudmFyIHZlbmRvck5hbWVzID0gWydXZWJraXQnLCAnTW96JywgJ21zJ107XG5cbnZhciBlbXB0eVN0eWxlO1xudmFyIG5vcm1hbGl6ZSA9IGNhY2hlZChmdW5jdGlvbiAocHJvcCkge1xuICBlbXB0eVN0eWxlID0gZW1wdHlTdHlsZSB8fCBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKS5zdHlsZTtcbiAgcHJvcCA9IGNhbWVsaXplKHByb3ApO1xuICBpZiAocHJvcCAhPT0gJ2ZpbHRlcicgJiYgKHByb3AgaW4gZW1wdHlTdHlsZSkpIHtcbiAgICByZXR1cm4gcHJvcFxuICB9XG4gIHZhciBjYXBOYW1lID0gcHJvcC5jaGFyQXQoMCkudG9VcHBlckNhc2UoKSArIHByb3Auc2xpY2UoMSk7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgdmVuZG9yTmFtZXMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgbmFtZSA9IHZlbmRvck5hbWVzW2ldICsgY2FwTmFtZTtcbiAgICBpZiAobmFtZSBpbiBlbXB0eVN0eWxlKSB7XG4gICAgICByZXR1cm4gbmFtZVxuICAgIH1cbiAgfVxufSk7XG5cbmZ1bmN0aW9uIHVwZGF0ZVN0eWxlIChvbGRWbm9kZSwgdm5vZGUpIHtcbiAgdmFyIGRhdGEgPSB2bm9kZS5kYXRhO1xuICB2YXIgb2xkRGF0YSA9IG9sZFZub2RlLmRhdGE7XG5cbiAgaWYgKGlzVW5kZWYoZGF0YS5zdGF0aWNTdHlsZSkgJiYgaXNVbmRlZihkYXRhLnN0eWxlKSAmJlxuICAgIGlzVW5kZWYob2xkRGF0YS5zdGF0aWNTdHlsZSkgJiYgaXNVbmRlZihvbGREYXRhLnN0eWxlKVxuICApIHtcbiAgICByZXR1cm5cbiAgfVxuXG4gIHZhciBjdXIsIG5hbWU7XG4gIHZhciBlbCA9IHZub2RlLmVsbTtcbiAgdmFyIG9sZFN0YXRpY1N0eWxlID0gb2xkRGF0YS5zdGF0aWNTdHlsZTtcbiAgdmFyIG9sZFN0eWxlQmluZGluZyA9IG9sZERhdGEubm9ybWFsaXplZFN0eWxlIHx8IG9sZERhdGEuc3R5bGUgfHwge307XG5cbiAgLy8gaWYgc3RhdGljIHN0eWxlIGV4aXN0cywgc3R5bGViaW5kaW5nIGFscmVhZHkgbWVyZ2VkIGludG8gaXQgd2hlbiBkb2luZyBub3JtYWxpemVTdHlsZURhdGFcbiAgdmFyIG9sZFN0eWxlID0gb2xkU3RhdGljU3R5bGUgfHwgb2xkU3R5bGVCaW5kaW5nO1xuXG4gIHZhciBzdHlsZSA9IG5vcm1hbGl6ZVN0eWxlQmluZGluZyh2bm9kZS5kYXRhLnN0eWxlKSB8fCB7fTtcblxuICAvLyBzdG9yZSBub3JtYWxpemVkIHN0eWxlIHVuZGVyIGEgZGlmZmVyZW50IGtleSBmb3IgbmV4dCBkaWZmXG4gIC8vIG1ha2Ugc3VyZSB0byBjbG9uZSBpdCBpZiBpdCdzIHJlYWN0aXZlLCBzaW5jZSB0aGUgdXNlciBsaWtlbHkgd2FudHNcbiAgLy8gdG8gbXV0YXRlIGl0LlxuICB2bm9kZS5kYXRhLm5vcm1hbGl6ZWRTdHlsZSA9IGlzRGVmKHN0eWxlLl9fb2JfXylcbiAgICA/IGV4dGVuZCh7fSwgc3R5bGUpXG4gICAgOiBzdHlsZTtcblxuICB2YXIgbmV3U3R5bGUgPSBnZXRTdHlsZSh2bm9kZSwgdHJ1ZSk7XG5cbiAgZm9yIChuYW1lIGluIG9sZFN0eWxlKSB7XG4gICAgaWYgKGlzVW5kZWYobmV3U3R5bGVbbmFtZV0pKSB7XG4gICAgICBzZXRQcm9wKGVsLCBuYW1lLCAnJyk7XG4gICAgfVxuICB9XG4gIGZvciAobmFtZSBpbiBuZXdTdHlsZSkge1xuICAgIGN1ciA9IG5ld1N0eWxlW25hbWVdO1xuICAgIGlmIChjdXIgIT09IG9sZFN0eWxlW25hbWVdKSB7XG4gICAgICAvLyBpZTkgc2V0dGluZyB0byBudWxsIGhhcyBubyBlZmZlY3QsIG11c3QgdXNlIGVtcHR5IHN0cmluZ1xuICAgICAgc2V0UHJvcChlbCwgbmFtZSwgY3VyID09IG51bGwgPyAnJyA6IGN1cik7XG4gICAgfVxuICB9XG59XG5cbnZhciBzdHlsZSA9IHtcbiAgY3JlYXRlOiB1cGRhdGVTdHlsZSxcbiAgdXBkYXRlOiB1cGRhdGVTdHlsZVxufTtcblxuLyogICovXG5cbnZhciB3aGl0ZXNwYWNlUkUgPSAvXFxzKy87XG5cbi8qKlxuICogQWRkIGNsYXNzIHdpdGggY29tcGF0aWJpbGl0eSBmb3IgU1ZHIHNpbmNlIGNsYXNzTGlzdCBpcyBub3Qgc3VwcG9ydGVkIG9uXG4gKiBTVkcgZWxlbWVudHMgaW4gSUVcbiAqL1xuZnVuY3Rpb24gYWRkQ2xhc3MgKGVsLCBjbHMpIHtcbiAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gIGlmICghY2xzIHx8ICEoY2xzID0gY2xzLnRyaW0oKSkpIHtcbiAgICByZXR1cm5cbiAgfVxuXG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovXG4gIGlmIChlbC5jbGFzc0xpc3QpIHtcbiAgICBpZiAoY2xzLmluZGV4T2YoJyAnKSA+IC0xKSB7XG4gICAgICBjbHMuc3BsaXQod2hpdGVzcGFjZVJFKS5mb3JFYWNoKGZ1bmN0aW9uIChjKSB7IHJldHVybiBlbC5jbGFzc0xpc3QuYWRkKGMpOyB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgZWwuY2xhc3NMaXN0LmFkZChjbHMpO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICB2YXIgY3VyID0gXCIgXCIgKyAoZWwuZ2V0QXR0cmlidXRlKCdjbGFzcycpIHx8ICcnKSArIFwiIFwiO1xuICAgIGlmIChjdXIuaW5kZXhPZignICcgKyBjbHMgKyAnICcpIDwgMCkge1xuICAgICAgZWwuc2V0QXR0cmlidXRlKCdjbGFzcycsIChjdXIgKyBjbHMpLnRyaW0oKSk7XG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogUmVtb3ZlIGNsYXNzIHdpdGggY29tcGF0aWJpbGl0eSBmb3IgU1ZHIHNpbmNlIGNsYXNzTGlzdCBpcyBub3Qgc3VwcG9ydGVkIG9uXG4gKiBTVkcgZWxlbWVudHMgaW4gSUVcbiAqL1xuZnVuY3Rpb24gcmVtb3ZlQ2xhc3MgKGVsLCBjbHMpIHtcbiAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gIGlmICghY2xzIHx8ICEoY2xzID0gY2xzLnRyaW0oKSkpIHtcbiAgICByZXR1cm5cbiAgfVxuXG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovXG4gIGlmIChlbC5jbGFzc0xpc3QpIHtcbiAgICBpZiAoY2xzLmluZGV4T2YoJyAnKSA+IC0xKSB7XG4gICAgICBjbHMuc3BsaXQod2hpdGVzcGFjZVJFKS5mb3JFYWNoKGZ1bmN0aW9uIChjKSB7IHJldHVybiBlbC5jbGFzc0xpc3QucmVtb3ZlKGMpOyB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgZWwuY2xhc3NMaXN0LnJlbW92ZShjbHMpO1xuICAgIH1cbiAgICBpZiAoIWVsLmNsYXNzTGlzdC5sZW5ndGgpIHtcbiAgICAgIGVsLnJlbW92ZUF0dHJpYnV0ZSgnY2xhc3MnKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgdmFyIGN1ciA9IFwiIFwiICsgKGVsLmdldEF0dHJpYnV0ZSgnY2xhc3MnKSB8fCAnJykgKyBcIiBcIjtcbiAgICB2YXIgdGFyID0gJyAnICsgY2xzICsgJyAnO1xuICAgIHdoaWxlIChjdXIuaW5kZXhPZih0YXIpID49IDApIHtcbiAgICAgIGN1ciA9IGN1ci5yZXBsYWNlKHRhciwgJyAnKTtcbiAgICB9XG4gICAgY3VyID0gY3VyLnRyaW0oKTtcbiAgICBpZiAoY3VyKSB7XG4gICAgICBlbC5zZXRBdHRyaWJ1dGUoJ2NsYXNzJywgY3VyKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZWwucmVtb3ZlQXR0cmlidXRlKCdjbGFzcycpO1xuICAgIH1cbiAgfVxufVxuXG4vKiAgKi9cblxuZnVuY3Rpb24gcmVzb2x2ZVRyYW5zaXRpb24gKGRlZiQkMSkge1xuICBpZiAoIWRlZiQkMSkge1xuICAgIHJldHVyblxuICB9XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovXG4gIGlmICh0eXBlb2YgZGVmJCQxID09PSAnb2JqZWN0Jykge1xuICAgIHZhciByZXMgPSB7fTtcbiAgICBpZiAoZGVmJCQxLmNzcyAhPT0gZmFsc2UpIHtcbiAgICAgIGV4dGVuZChyZXMsIGF1dG9Dc3NUcmFuc2l0aW9uKGRlZiQkMS5uYW1lIHx8ICd2JykpO1xuICAgIH1cbiAgICBleHRlbmQocmVzLCBkZWYkJDEpO1xuICAgIHJldHVybiByZXNcbiAgfSBlbHNlIGlmICh0eXBlb2YgZGVmJCQxID09PSAnc3RyaW5nJykge1xuICAgIHJldHVybiBhdXRvQ3NzVHJhbnNpdGlvbihkZWYkJDEpXG4gIH1cbn1cblxudmFyIGF1dG9Dc3NUcmFuc2l0aW9uID0gY2FjaGVkKGZ1bmN0aW9uIChuYW1lKSB7XG4gIHJldHVybiB7XG4gICAgZW50ZXJDbGFzczogKG5hbWUgKyBcIi1lbnRlclwiKSxcbiAgICBlbnRlclRvQ2xhc3M6IChuYW1lICsgXCItZW50ZXItdG9cIiksXG4gICAgZW50ZXJBY3RpdmVDbGFzczogKG5hbWUgKyBcIi1lbnRlci1hY3RpdmVcIiksXG4gICAgbGVhdmVDbGFzczogKG5hbWUgKyBcIi1sZWF2ZVwiKSxcbiAgICBsZWF2ZVRvQ2xhc3M6IChuYW1lICsgXCItbGVhdmUtdG9cIiksXG4gICAgbGVhdmVBY3RpdmVDbGFzczogKG5hbWUgKyBcIi1sZWF2ZS1hY3RpdmVcIilcbiAgfVxufSk7XG5cbnZhciBoYXNUcmFuc2l0aW9uID0gaW5Ccm93c2VyICYmICFpc0lFOTtcbnZhciBUUkFOU0lUSU9OID0gJ3RyYW5zaXRpb24nO1xudmFyIEFOSU1BVElPTiA9ICdhbmltYXRpb24nO1xuXG4vLyBUcmFuc2l0aW9uIHByb3BlcnR5L2V2ZW50IHNuaWZmaW5nXG52YXIgdHJhbnNpdGlvblByb3AgPSAndHJhbnNpdGlvbic7XG52YXIgdHJhbnNpdGlvbkVuZEV2ZW50ID0gJ3RyYW5zaXRpb25lbmQnO1xudmFyIGFuaW1hdGlvblByb3AgPSAnYW5pbWF0aW9uJztcbnZhciBhbmltYXRpb25FbmRFdmVudCA9ICdhbmltYXRpb25lbmQnO1xuaWYgKGhhc1RyYW5zaXRpb24pIHtcbiAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gIGlmICh3aW5kb3cub250cmFuc2l0aW9uZW5kID09PSB1bmRlZmluZWQgJiZcbiAgICB3aW5kb3cub253ZWJraXR0cmFuc2l0aW9uZW5kICE9PSB1bmRlZmluZWRcbiAgKSB7XG4gICAgdHJhbnNpdGlvblByb3AgPSAnV2Via2l0VHJhbnNpdGlvbic7XG4gICAgdHJhbnNpdGlvbkVuZEV2ZW50ID0gJ3dlYmtpdFRyYW5zaXRpb25FbmQnO1xuICB9XG4gIGlmICh3aW5kb3cub25hbmltYXRpb25lbmQgPT09IHVuZGVmaW5lZCAmJlxuICAgIHdpbmRvdy5vbndlYmtpdGFuaW1hdGlvbmVuZCAhPT0gdW5kZWZpbmVkXG4gICkge1xuICAgIGFuaW1hdGlvblByb3AgPSAnV2Via2l0QW5pbWF0aW9uJztcbiAgICBhbmltYXRpb25FbmRFdmVudCA9ICd3ZWJraXRBbmltYXRpb25FbmQnO1xuICB9XG59XG5cbi8vIGJpbmRpbmcgdG8gd2luZG93IGlzIG5lY2Vzc2FyeSB0byBtYWtlIGhvdCByZWxvYWQgd29yayBpbiBJRSBpbiBzdHJpY3QgbW9kZVxudmFyIHJhZiA9IGluQnJvd3NlclxuICA/IHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWVcbiAgICA/IHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUuYmluZCh3aW5kb3cpXG4gICAgOiBzZXRUaW1lb3V0XG4gIDogLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi8gZnVuY3Rpb24gKGZuKSB7IHJldHVybiBmbigpOyB9O1xuXG5mdW5jdGlvbiBuZXh0RnJhbWUgKGZuKSB7XG4gIHJhZihmdW5jdGlvbiAoKSB7XG4gICAgcmFmKGZuKTtcbiAgfSk7XG59XG5cbmZ1bmN0aW9uIGFkZFRyYW5zaXRpb25DbGFzcyAoZWwsIGNscykge1xuICB2YXIgdHJhbnNpdGlvbkNsYXNzZXMgPSBlbC5fdHJhbnNpdGlvbkNsYXNzZXMgfHwgKGVsLl90cmFuc2l0aW9uQ2xhc3NlcyA9IFtdKTtcbiAgaWYgKHRyYW5zaXRpb25DbGFzc2VzLmluZGV4T2YoY2xzKSA8IDApIHtcbiAgICB0cmFuc2l0aW9uQ2xhc3Nlcy5wdXNoKGNscyk7XG4gICAgYWRkQ2xhc3MoZWwsIGNscyk7XG4gIH1cbn1cblxuZnVuY3Rpb24gcmVtb3ZlVHJhbnNpdGlvbkNsYXNzIChlbCwgY2xzKSB7XG4gIGlmIChlbC5fdHJhbnNpdGlvbkNsYXNzZXMpIHtcbiAgICByZW1vdmUoZWwuX3RyYW5zaXRpb25DbGFzc2VzLCBjbHMpO1xuICB9XG4gIHJlbW92ZUNsYXNzKGVsLCBjbHMpO1xufVxuXG5mdW5jdGlvbiB3aGVuVHJhbnNpdGlvbkVuZHMgKFxuICBlbCxcbiAgZXhwZWN0ZWRUeXBlLFxuICBjYlxuKSB7XG4gIHZhciByZWYgPSBnZXRUcmFuc2l0aW9uSW5mbyhlbCwgZXhwZWN0ZWRUeXBlKTtcbiAgdmFyIHR5cGUgPSByZWYudHlwZTtcbiAgdmFyIHRpbWVvdXQgPSByZWYudGltZW91dDtcbiAgdmFyIHByb3BDb3VudCA9IHJlZi5wcm9wQ291bnQ7XG4gIGlmICghdHlwZSkgeyByZXR1cm4gY2IoKSB9XG4gIHZhciBldmVudCA9IHR5cGUgPT09IFRSQU5TSVRJT04gPyB0cmFuc2l0aW9uRW5kRXZlbnQgOiBhbmltYXRpb25FbmRFdmVudDtcbiAgdmFyIGVuZGVkID0gMDtcbiAgdmFyIGVuZCA9IGZ1bmN0aW9uICgpIHtcbiAgICBlbC5yZW1vdmVFdmVudExpc3RlbmVyKGV2ZW50LCBvbkVuZCk7XG4gICAgY2IoKTtcbiAgfTtcbiAgdmFyIG9uRW5kID0gZnVuY3Rpb24gKGUpIHtcbiAgICBpZiAoZS50YXJnZXQgPT09IGVsKSB7XG4gICAgICBpZiAoKytlbmRlZCA+PSBwcm9wQ291bnQpIHtcbiAgICAgICAgZW5kKCk7XG4gICAgICB9XG4gICAgfVxuICB9O1xuICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoZW5kZWQgPCBwcm9wQ291bnQpIHtcbiAgICAgIGVuZCgpO1xuICAgIH1cbiAgfSwgdGltZW91dCArIDEpO1xuICBlbC5hZGRFdmVudExpc3RlbmVyKGV2ZW50LCBvbkVuZCk7XG59XG5cbnZhciB0cmFuc2Zvcm1SRSA9IC9cXGIodHJhbnNmb3JtfGFsbCkoLHwkKS87XG5cbmZ1bmN0aW9uIGdldFRyYW5zaXRpb25JbmZvIChlbCwgZXhwZWN0ZWRUeXBlKSB7XG4gIHZhciBzdHlsZXMgPSB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZShlbCk7XG4gIC8vIEpTRE9NIG1heSByZXR1cm4gdW5kZWZpbmVkIGZvciB0cmFuc2l0aW9uIHByb3BlcnRpZXNcbiAgdmFyIHRyYW5zaXRpb25EZWxheXMgPSAoc3R5bGVzW3RyYW5zaXRpb25Qcm9wICsgJ0RlbGF5J10gfHwgJycpLnNwbGl0KCcsICcpO1xuICB2YXIgdHJhbnNpdGlvbkR1cmF0aW9ucyA9IChzdHlsZXNbdHJhbnNpdGlvblByb3AgKyAnRHVyYXRpb24nXSB8fCAnJykuc3BsaXQoJywgJyk7XG4gIHZhciB0cmFuc2l0aW9uVGltZW91dCA9IGdldFRpbWVvdXQodHJhbnNpdGlvbkRlbGF5cywgdHJhbnNpdGlvbkR1cmF0aW9ucyk7XG4gIHZhciBhbmltYXRpb25EZWxheXMgPSAoc3R5bGVzW2FuaW1hdGlvblByb3AgKyAnRGVsYXknXSB8fCAnJykuc3BsaXQoJywgJyk7XG4gIHZhciBhbmltYXRpb25EdXJhdGlvbnMgPSAoc3R5bGVzW2FuaW1hdGlvblByb3AgKyAnRHVyYXRpb24nXSB8fCAnJykuc3BsaXQoJywgJyk7XG4gIHZhciBhbmltYXRpb25UaW1lb3V0ID0gZ2V0VGltZW91dChhbmltYXRpb25EZWxheXMsIGFuaW1hdGlvbkR1cmF0aW9ucyk7XG5cbiAgdmFyIHR5cGU7XG4gIHZhciB0aW1lb3V0ID0gMDtcbiAgdmFyIHByb3BDb3VudCA9IDA7XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICBpZiAoZXhwZWN0ZWRUeXBlID09PSBUUkFOU0lUSU9OKSB7XG4gICAgaWYgKHRyYW5zaXRpb25UaW1lb3V0ID4gMCkge1xuICAgICAgdHlwZSA9IFRSQU5TSVRJT047XG4gICAgICB0aW1lb3V0ID0gdHJhbnNpdGlvblRpbWVvdXQ7XG4gICAgICBwcm9wQ291bnQgPSB0cmFuc2l0aW9uRHVyYXRpb25zLmxlbmd0aDtcbiAgICB9XG4gIH0gZWxzZSBpZiAoZXhwZWN0ZWRUeXBlID09PSBBTklNQVRJT04pIHtcbiAgICBpZiAoYW5pbWF0aW9uVGltZW91dCA+IDApIHtcbiAgICAgIHR5cGUgPSBBTklNQVRJT047XG4gICAgICB0aW1lb3V0ID0gYW5pbWF0aW9uVGltZW91dDtcbiAgICAgIHByb3BDb3VudCA9IGFuaW1hdGlvbkR1cmF0aW9ucy5sZW5ndGg7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHRpbWVvdXQgPSBNYXRoLm1heCh0cmFuc2l0aW9uVGltZW91dCwgYW5pbWF0aW9uVGltZW91dCk7XG4gICAgdHlwZSA9IHRpbWVvdXQgPiAwXG4gICAgICA/IHRyYW5zaXRpb25UaW1lb3V0ID4gYW5pbWF0aW9uVGltZW91dFxuICAgICAgICA/IFRSQU5TSVRJT05cbiAgICAgICAgOiBBTklNQVRJT05cbiAgICAgIDogbnVsbDtcbiAgICBwcm9wQ291bnQgPSB0eXBlXG4gICAgICA/IHR5cGUgPT09IFRSQU5TSVRJT05cbiAgICAgICAgPyB0cmFuc2l0aW9uRHVyYXRpb25zLmxlbmd0aFxuICAgICAgICA6IGFuaW1hdGlvbkR1cmF0aW9ucy5sZW5ndGhcbiAgICAgIDogMDtcbiAgfVxuICB2YXIgaGFzVHJhbnNmb3JtID1cbiAgICB0eXBlID09PSBUUkFOU0lUSU9OICYmXG4gICAgdHJhbnNmb3JtUkUudGVzdChzdHlsZXNbdHJhbnNpdGlvblByb3AgKyAnUHJvcGVydHknXSk7XG4gIHJldHVybiB7XG4gICAgdHlwZTogdHlwZSxcbiAgICB0aW1lb3V0OiB0aW1lb3V0LFxuICAgIHByb3BDb3VudDogcHJvcENvdW50LFxuICAgIGhhc1RyYW5zZm9ybTogaGFzVHJhbnNmb3JtXG4gIH1cbn1cblxuZnVuY3Rpb24gZ2V0VGltZW91dCAoZGVsYXlzLCBkdXJhdGlvbnMpIHtcbiAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgd2hpbGUgKGRlbGF5cy5sZW5ndGggPCBkdXJhdGlvbnMubGVuZ3RoKSB7XG4gICAgZGVsYXlzID0gZGVsYXlzLmNvbmNhdChkZWxheXMpO1xuICB9XG5cbiAgcmV0dXJuIE1hdGgubWF4LmFwcGx5KG51bGwsIGR1cmF0aW9ucy5tYXAoZnVuY3Rpb24gKGQsIGkpIHtcbiAgICByZXR1cm4gdG9NcyhkKSArIHRvTXMoZGVsYXlzW2ldKVxuICB9KSlcbn1cblxuLy8gT2xkIHZlcnNpb25zIG9mIENocm9taXVtIChiZWxvdyA2MS4wLjMxNjMuMTAwKSBmb3JtYXRzIGZsb2F0aW5nIHBvaW50ZXIgbnVtYmVyc1xuLy8gaW4gYSBsb2NhbGUtZGVwZW5kZW50IHdheSwgdXNpbmcgYSBjb21tYSBpbnN0ZWFkIG9mIGEgZG90LlxuLy8gSWYgY29tbWEgaXMgbm90IHJlcGxhY2VkIHdpdGggYSBkb3QsIHRoZSBpbnB1dCB3aWxsIGJlIHJvdW5kZWQgZG93biAoaS5lLiBhY3Rpbmdcbi8vIGFzIGEgZmxvb3IgZnVuY3Rpb24pIGNhdXNpbmcgdW5leHBlY3RlZCBiZWhhdmlvcnNcbmZ1bmN0aW9uIHRvTXMgKHMpIHtcbiAgcmV0dXJuIE51bWJlcihzLnNsaWNlKDAsIC0xKS5yZXBsYWNlKCcsJywgJy4nKSkgKiAxMDAwXG59XG5cbi8qICAqL1xuXG5mdW5jdGlvbiBlbnRlciAodm5vZGUsIHRvZ2dsZURpc3BsYXkpIHtcbiAgdmFyIGVsID0gdm5vZGUuZWxtO1xuXG4gIC8vIGNhbGwgbGVhdmUgY2FsbGJhY2sgbm93XG4gIGlmIChpc0RlZihlbC5fbGVhdmVDYikpIHtcbiAgICBlbC5fbGVhdmVDYi5jYW5jZWxsZWQgPSB0cnVlO1xuICAgIGVsLl9sZWF2ZUNiKCk7XG4gIH1cblxuICB2YXIgZGF0YSA9IHJlc29sdmVUcmFuc2l0aW9uKHZub2RlLmRhdGEudHJhbnNpdGlvbik7XG4gIGlmIChpc1VuZGVmKGRhdGEpKSB7XG4gICAgcmV0dXJuXG4gIH1cblxuICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgaWYgKGlzRGVmKGVsLl9lbnRlckNiKSB8fCBlbC5ub2RlVHlwZSAhPT0gMSkge1xuICAgIHJldHVyblxuICB9XG5cbiAgdmFyIGNzcyA9IGRhdGEuY3NzO1xuICB2YXIgdHlwZSA9IGRhdGEudHlwZTtcbiAgdmFyIGVudGVyQ2xhc3MgPSBkYXRhLmVudGVyQ2xhc3M7XG4gIHZhciBlbnRlclRvQ2xhc3MgPSBkYXRhLmVudGVyVG9DbGFzcztcbiAgdmFyIGVudGVyQWN0aXZlQ2xhc3MgPSBkYXRhLmVudGVyQWN0aXZlQ2xhc3M7XG4gIHZhciBhcHBlYXJDbGFzcyA9IGRhdGEuYXBwZWFyQ2xhc3M7XG4gIHZhciBhcHBlYXJUb0NsYXNzID0gZGF0YS5hcHBlYXJUb0NsYXNzO1xuICB2YXIgYXBwZWFyQWN0aXZlQ2xhc3MgPSBkYXRhLmFwcGVhckFjdGl2ZUNsYXNzO1xuICB2YXIgYmVmb3JlRW50ZXIgPSBkYXRhLmJlZm9yZUVudGVyO1xuICB2YXIgZW50ZXIgPSBkYXRhLmVudGVyO1xuICB2YXIgYWZ0ZXJFbnRlciA9IGRhdGEuYWZ0ZXJFbnRlcjtcbiAgdmFyIGVudGVyQ2FuY2VsbGVkID0gZGF0YS5lbnRlckNhbmNlbGxlZDtcbiAgdmFyIGJlZm9yZUFwcGVhciA9IGRhdGEuYmVmb3JlQXBwZWFyO1xuICB2YXIgYXBwZWFyID0gZGF0YS5hcHBlYXI7XG4gIHZhciBhZnRlckFwcGVhciA9IGRhdGEuYWZ0ZXJBcHBlYXI7XG4gIHZhciBhcHBlYXJDYW5jZWxsZWQgPSBkYXRhLmFwcGVhckNhbmNlbGxlZDtcbiAgdmFyIGR1cmF0aW9uID0gZGF0YS5kdXJhdGlvbjtcblxuICAvLyBhY3RpdmVJbnN0YW5jZSB3aWxsIGFsd2F5cyBiZSB0aGUgPHRyYW5zaXRpb24+IGNvbXBvbmVudCBtYW5hZ2luZyB0aGlzXG4gIC8vIHRyYW5zaXRpb24uIE9uZSBlZGdlIGNhc2UgdG8gY2hlY2sgaXMgd2hlbiB0aGUgPHRyYW5zaXRpb24+IGlzIHBsYWNlZFxuICAvLyBhcyB0aGUgcm9vdCBub2RlIG9mIGEgY2hpbGQgY29tcG9uZW50LiBJbiB0aGF0IGNhc2Ugd2UgbmVlZCB0byBjaGVja1xuICAvLyA8dHJhbnNpdGlvbj4ncyBwYXJlbnQgZm9yIGFwcGVhciBjaGVjay5cbiAgdmFyIGNvbnRleHQgPSBhY3RpdmVJbnN0YW5jZTtcbiAgdmFyIHRyYW5zaXRpb25Ob2RlID0gYWN0aXZlSW5zdGFuY2UuJHZub2RlO1xuICB3aGlsZSAodHJhbnNpdGlvbk5vZGUgJiYgdHJhbnNpdGlvbk5vZGUucGFyZW50KSB7XG4gICAgY29udGV4dCA9IHRyYW5zaXRpb25Ob2RlLmNvbnRleHQ7XG4gICAgdHJhbnNpdGlvbk5vZGUgPSB0cmFuc2l0aW9uTm9kZS5wYXJlbnQ7XG4gIH1cblxuICB2YXIgaXNBcHBlYXIgPSAhY29udGV4dC5faXNNb3VudGVkIHx8ICF2bm9kZS5pc1Jvb3RJbnNlcnQ7XG5cbiAgaWYgKGlzQXBwZWFyICYmICFhcHBlYXIgJiYgYXBwZWFyICE9PSAnJykge1xuICAgIHJldHVyblxuICB9XG5cbiAgdmFyIHN0YXJ0Q2xhc3MgPSBpc0FwcGVhciAmJiBhcHBlYXJDbGFzc1xuICAgID8gYXBwZWFyQ2xhc3NcbiAgICA6IGVudGVyQ2xhc3M7XG4gIHZhciBhY3RpdmVDbGFzcyA9IGlzQXBwZWFyICYmIGFwcGVhckFjdGl2ZUNsYXNzXG4gICAgPyBhcHBlYXJBY3RpdmVDbGFzc1xuICAgIDogZW50ZXJBY3RpdmVDbGFzcztcbiAgdmFyIHRvQ2xhc3MgPSBpc0FwcGVhciAmJiBhcHBlYXJUb0NsYXNzXG4gICAgPyBhcHBlYXJUb0NsYXNzXG4gICAgOiBlbnRlclRvQ2xhc3M7XG5cbiAgdmFyIGJlZm9yZUVudGVySG9vayA9IGlzQXBwZWFyXG4gICAgPyAoYmVmb3JlQXBwZWFyIHx8IGJlZm9yZUVudGVyKVxuICAgIDogYmVmb3JlRW50ZXI7XG4gIHZhciBlbnRlckhvb2sgPSBpc0FwcGVhclxuICAgID8gKHR5cGVvZiBhcHBlYXIgPT09ICdmdW5jdGlvbicgPyBhcHBlYXIgOiBlbnRlcilcbiAgICA6IGVudGVyO1xuICB2YXIgYWZ0ZXJFbnRlckhvb2sgPSBpc0FwcGVhclxuICAgID8gKGFmdGVyQXBwZWFyIHx8IGFmdGVyRW50ZXIpXG4gICAgOiBhZnRlckVudGVyO1xuICB2YXIgZW50ZXJDYW5jZWxsZWRIb29rID0gaXNBcHBlYXJcbiAgICA/IChhcHBlYXJDYW5jZWxsZWQgfHwgZW50ZXJDYW5jZWxsZWQpXG4gICAgOiBlbnRlckNhbmNlbGxlZDtcblxuICB2YXIgZXhwbGljaXRFbnRlckR1cmF0aW9uID0gdG9OdW1iZXIoXG4gICAgaXNPYmplY3QoZHVyYXRpb24pXG4gICAgICA/IGR1cmF0aW9uLmVudGVyXG4gICAgICA6IGR1cmF0aW9uXG4gICk7XG5cbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgZXhwbGljaXRFbnRlckR1cmF0aW9uICE9IG51bGwpIHtcbiAgICBjaGVja0R1cmF0aW9uKGV4cGxpY2l0RW50ZXJEdXJhdGlvbiwgJ2VudGVyJywgdm5vZGUpO1xuICB9XG5cbiAgdmFyIGV4cGVjdHNDU1MgPSBjc3MgIT09IGZhbHNlICYmICFpc0lFOTtcbiAgdmFyIHVzZXJXYW50c0NvbnRyb2wgPSBnZXRIb29rQXJndW1lbnRzTGVuZ3RoKGVudGVySG9vayk7XG5cbiAgdmFyIGNiID0gZWwuX2VudGVyQ2IgPSBvbmNlKGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoZXhwZWN0c0NTUykge1xuICAgICAgcmVtb3ZlVHJhbnNpdGlvbkNsYXNzKGVsLCB0b0NsYXNzKTtcbiAgICAgIHJlbW92ZVRyYW5zaXRpb25DbGFzcyhlbCwgYWN0aXZlQ2xhc3MpO1xuICAgIH1cbiAgICBpZiAoY2IuY2FuY2VsbGVkKSB7XG4gICAgICBpZiAoZXhwZWN0c0NTUykge1xuICAgICAgICByZW1vdmVUcmFuc2l0aW9uQ2xhc3MoZWwsIHN0YXJ0Q2xhc3MpO1xuICAgICAgfVxuICAgICAgZW50ZXJDYW5jZWxsZWRIb29rICYmIGVudGVyQ2FuY2VsbGVkSG9vayhlbCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGFmdGVyRW50ZXJIb29rICYmIGFmdGVyRW50ZXJIb29rKGVsKTtcbiAgICB9XG4gICAgZWwuX2VudGVyQ2IgPSBudWxsO1xuICB9KTtcblxuICBpZiAoIXZub2RlLmRhdGEuc2hvdykge1xuICAgIC8vIHJlbW92ZSBwZW5kaW5nIGxlYXZlIGVsZW1lbnQgb24gZW50ZXIgYnkgaW5qZWN0aW5nIGFuIGluc2VydCBob29rXG4gICAgbWVyZ2VWTm9kZUhvb2sodm5vZGUsICdpbnNlcnQnLCBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgcGFyZW50ID0gZWwucGFyZW50Tm9kZTtcbiAgICAgIHZhciBwZW5kaW5nTm9kZSA9IHBhcmVudCAmJiBwYXJlbnQuX3BlbmRpbmcgJiYgcGFyZW50Ll9wZW5kaW5nW3Zub2RlLmtleV07XG4gICAgICBpZiAocGVuZGluZ05vZGUgJiZcbiAgICAgICAgcGVuZGluZ05vZGUudGFnID09PSB2bm9kZS50YWcgJiZcbiAgICAgICAgcGVuZGluZ05vZGUuZWxtLl9sZWF2ZUNiXG4gICAgICApIHtcbiAgICAgICAgcGVuZGluZ05vZGUuZWxtLl9sZWF2ZUNiKCk7XG4gICAgICB9XG4gICAgICBlbnRlckhvb2sgJiYgZW50ZXJIb29rKGVsLCBjYik7XG4gICAgfSk7XG4gIH1cblxuICAvLyBzdGFydCBlbnRlciB0cmFuc2l0aW9uXG4gIGJlZm9yZUVudGVySG9vayAmJiBiZWZvcmVFbnRlckhvb2soZWwpO1xuICBpZiAoZXhwZWN0c0NTUykge1xuICAgIGFkZFRyYW5zaXRpb25DbGFzcyhlbCwgc3RhcnRDbGFzcyk7XG4gICAgYWRkVHJhbnNpdGlvbkNsYXNzKGVsLCBhY3RpdmVDbGFzcyk7XG4gICAgbmV4dEZyYW1lKGZ1bmN0aW9uICgpIHtcbiAgICAgIHJlbW92ZVRyYW5zaXRpb25DbGFzcyhlbCwgc3RhcnRDbGFzcyk7XG4gICAgICBpZiAoIWNiLmNhbmNlbGxlZCkge1xuICAgICAgICBhZGRUcmFuc2l0aW9uQ2xhc3MoZWwsIHRvQ2xhc3MpO1xuICAgICAgICBpZiAoIXVzZXJXYW50c0NvbnRyb2wpIHtcbiAgICAgICAgICBpZiAoaXNWYWxpZER1cmF0aW9uKGV4cGxpY2l0RW50ZXJEdXJhdGlvbikpIHtcbiAgICAgICAgICAgIHNldFRpbWVvdXQoY2IsIGV4cGxpY2l0RW50ZXJEdXJhdGlvbik7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHdoZW5UcmFuc2l0aW9uRW5kcyhlbCwgdHlwZSwgY2IpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgaWYgKHZub2RlLmRhdGEuc2hvdykge1xuICAgIHRvZ2dsZURpc3BsYXkgJiYgdG9nZ2xlRGlzcGxheSgpO1xuICAgIGVudGVySG9vayAmJiBlbnRlckhvb2soZWwsIGNiKTtcbiAgfVxuXG4gIGlmICghZXhwZWN0c0NTUyAmJiAhdXNlcldhbnRzQ29udHJvbCkge1xuICAgIGNiKCk7XG4gIH1cbn1cblxuZnVuY3Rpb24gbGVhdmUgKHZub2RlLCBybSkge1xuICB2YXIgZWwgPSB2bm9kZS5lbG07XG5cbiAgLy8gY2FsbCBlbnRlciBjYWxsYmFjayBub3dcbiAgaWYgKGlzRGVmKGVsLl9lbnRlckNiKSkge1xuICAgIGVsLl9lbnRlckNiLmNhbmNlbGxlZCA9IHRydWU7XG4gICAgZWwuX2VudGVyQ2IoKTtcbiAgfVxuXG4gIHZhciBkYXRhID0gcmVzb2x2ZVRyYW5zaXRpb24odm5vZGUuZGF0YS50cmFuc2l0aW9uKTtcbiAgaWYgKGlzVW5kZWYoZGF0YSkgfHwgZWwubm9kZVR5cGUgIT09IDEpIHtcbiAgICByZXR1cm4gcm0oKVxuICB9XG5cbiAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gIGlmIChpc0RlZihlbC5fbGVhdmVDYikpIHtcbiAgICByZXR1cm5cbiAgfVxuXG4gIHZhciBjc3MgPSBkYXRhLmNzcztcbiAgdmFyIHR5cGUgPSBkYXRhLnR5cGU7XG4gIHZhciBsZWF2ZUNsYXNzID0gZGF0YS5sZWF2ZUNsYXNzO1xuICB2YXIgbGVhdmVUb0NsYXNzID0gZGF0YS5sZWF2ZVRvQ2xhc3M7XG4gIHZhciBsZWF2ZUFjdGl2ZUNsYXNzID0gZGF0YS5sZWF2ZUFjdGl2ZUNsYXNzO1xuICB2YXIgYmVmb3JlTGVhdmUgPSBkYXRhLmJlZm9yZUxlYXZlO1xuICB2YXIgbGVhdmUgPSBkYXRhLmxlYXZlO1xuICB2YXIgYWZ0ZXJMZWF2ZSA9IGRhdGEuYWZ0ZXJMZWF2ZTtcbiAgdmFyIGxlYXZlQ2FuY2VsbGVkID0gZGF0YS5sZWF2ZUNhbmNlbGxlZDtcbiAgdmFyIGRlbGF5TGVhdmUgPSBkYXRhLmRlbGF5TGVhdmU7XG4gIHZhciBkdXJhdGlvbiA9IGRhdGEuZHVyYXRpb247XG5cbiAgdmFyIGV4cGVjdHNDU1MgPSBjc3MgIT09IGZhbHNlICYmICFpc0lFOTtcbiAgdmFyIHVzZXJXYW50c0NvbnRyb2wgPSBnZXRIb29rQXJndW1lbnRzTGVuZ3RoKGxlYXZlKTtcblxuICB2YXIgZXhwbGljaXRMZWF2ZUR1cmF0aW9uID0gdG9OdW1iZXIoXG4gICAgaXNPYmplY3QoZHVyYXRpb24pXG4gICAgICA/IGR1cmF0aW9uLmxlYXZlXG4gICAgICA6IGR1cmF0aW9uXG4gICk7XG5cbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgaXNEZWYoZXhwbGljaXRMZWF2ZUR1cmF0aW9uKSkge1xuICAgIGNoZWNrRHVyYXRpb24oZXhwbGljaXRMZWF2ZUR1cmF0aW9uLCAnbGVhdmUnLCB2bm9kZSk7XG4gIH1cblxuICB2YXIgY2IgPSBlbC5fbGVhdmVDYiA9IG9uY2UoZnVuY3Rpb24gKCkge1xuICAgIGlmIChlbC5wYXJlbnROb2RlICYmIGVsLnBhcmVudE5vZGUuX3BlbmRpbmcpIHtcbiAgICAgIGVsLnBhcmVudE5vZGUuX3BlbmRpbmdbdm5vZGUua2V5XSA9IG51bGw7XG4gICAgfVxuICAgIGlmIChleHBlY3RzQ1NTKSB7XG4gICAgICByZW1vdmVUcmFuc2l0aW9uQ2xhc3MoZWwsIGxlYXZlVG9DbGFzcyk7XG4gICAgICByZW1vdmVUcmFuc2l0aW9uQ2xhc3MoZWwsIGxlYXZlQWN0aXZlQ2xhc3MpO1xuICAgIH1cbiAgICBpZiAoY2IuY2FuY2VsbGVkKSB7XG4gICAgICBpZiAoZXhwZWN0c0NTUykge1xuICAgICAgICByZW1vdmVUcmFuc2l0aW9uQ2xhc3MoZWwsIGxlYXZlQ2xhc3MpO1xuICAgICAgfVxuICAgICAgbGVhdmVDYW5jZWxsZWQgJiYgbGVhdmVDYW5jZWxsZWQoZWwpO1xuICAgIH0gZWxzZSB7XG4gICAgICBybSgpO1xuICAgICAgYWZ0ZXJMZWF2ZSAmJiBhZnRlckxlYXZlKGVsKTtcbiAgICB9XG4gICAgZWwuX2xlYXZlQ2IgPSBudWxsO1xuICB9KTtcblxuICBpZiAoZGVsYXlMZWF2ZSkge1xuICAgIGRlbGF5TGVhdmUocGVyZm9ybUxlYXZlKTtcbiAgfSBlbHNlIHtcbiAgICBwZXJmb3JtTGVhdmUoKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHBlcmZvcm1MZWF2ZSAoKSB7XG4gICAgLy8gdGhlIGRlbGF5ZWQgbGVhdmUgbWF5IGhhdmUgYWxyZWFkeSBiZWVuIGNhbmNlbGxlZFxuICAgIGlmIChjYi5jYW5jZWxsZWQpIHtcbiAgICAgIHJldHVyblxuICAgIH1cbiAgICAvLyByZWNvcmQgbGVhdmluZyBlbGVtZW50XG4gICAgaWYgKCF2bm9kZS5kYXRhLnNob3cgJiYgZWwucGFyZW50Tm9kZSkge1xuICAgICAgKGVsLnBhcmVudE5vZGUuX3BlbmRpbmcgfHwgKGVsLnBhcmVudE5vZGUuX3BlbmRpbmcgPSB7fSkpWyh2bm9kZS5rZXkpXSA9IHZub2RlO1xuICAgIH1cbiAgICBiZWZvcmVMZWF2ZSAmJiBiZWZvcmVMZWF2ZShlbCk7XG4gICAgaWYgKGV4cGVjdHNDU1MpIHtcbiAgICAgIGFkZFRyYW5zaXRpb25DbGFzcyhlbCwgbGVhdmVDbGFzcyk7XG4gICAgICBhZGRUcmFuc2l0aW9uQ2xhc3MoZWwsIGxlYXZlQWN0aXZlQ2xhc3MpO1xuICAgICAgbmV4dEZyYW1lKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmVtb3ZlVHJhbnNpdGlvbkNsYXNzKGVsLCBsZWF2ZUNsYXNzKTtcbiAgICAgICAgaWYgKCFjYi5jYW5jZWxsZWQpIHtcbiAgICAgICAgICBhZGRUcmFuc2l0aW9uQ2xhc3MoZWwsIGxlYXZlVG9DbGFzcyk7XG4gICAgICAgICAgaWYgKCF1c2VyV2FudHNDb250cm9sKSB7XG4gICAgICAgICAgICBpZiAoaXNWYWxpZER1cmF0aW9uKGV4cGxpY2l0TGVhdmVEdXJhdGlvbikpIHtcbiAgICAgICAgICAgICAgc2V0VGltZW91dChjYiwgZXhwbGljaXRMZWF2ZUR1cmF0aW9uKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHdoZW5UcmFuc2l0aW9uRW5kcyhlbCwgdHlwZSwgY2IpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICAgIGxlYXZlICYmIGxlYXZlKGVsLCBjYik7XG4gICAgaWYgKCFleHBlY3RzQ1NTICYmICF1c2VyV2FudHNDb250cm9sKSB7XG4gICAgICBjYigpO1xuICAgIH1cbiAgfVxufVxuXG4vLyBvbmx5IHVzZWQgaW4gZGV2IG1vZGVcbmZ1bmN0aW9uIGNoZWNrRHVyYXRpb24gKHZhbCwgbmFtZSwgdm5vZGUpIHtcbiAgaWYgKHR5cGVvZiB2YWwgIT09ICdudW1iZXInKSB7XG4gICAgd2FybihcbiAgICAgIFwiPHRyYW5zaXRpb24+IGV4cGxpY2l0IFwiICsgbmFtZSArIFwiIGR1cmF0aW9uIGlzIG5vdCBhIHZhbGlkIG51bWJlciAtIFwiICtcbiAgICAgIFwiZ290IFwiICsgKEpTT04uc3RyaW5naWZ5KHZhbCkpICsgXCIuXCIsXG4gICAgICB2bm9kZS5jb250ZXh0XG4gICAgKTtcbiAgfSBlbHNlIGlmIChpc05hTih2YWwpKSB7XG4gICAgd2FybihcbiAgICAgIFwiPHRyYW5zaXRpb24+IGV4cGxpY2l0IFwiICsgbmFtZSArIFwiIGR1cmF0aW9uIGlzIE5hTiAtIFwiICtcbiAgICAgICd0aGUgZHVyYXRpb24gZXhwcmVzc2lvbiBtaWdodCBiZSBpbmNvcnJlY3QuJyxcbiAgICAgIHZub2RlLmNvbnRleHRcbiAgICApO1xuICB9XG59XG5cbmZ1bmN0aW9uIGlzVmFsaWREdXJhdGlvbiAodmFsKSB7XG4gIHJldHVybiB0eXBlb2YgdmFsID09PSAnbnVtYmVyJyAmJiAhaXNOYU4odmFsKVxufVxuXG4vKipcbiAqIE5vcm1hbGl6ZSBhIHRyYW5zaXRpb24gaG9vaydzIGFyZ3VtZW50IGxlbmd0aC4gVGhlIGhvb2sgbWF5IGJlOlxuICogLSBhIG1lcmdlZCBob29rIChpbnZva2VyKSB3aXRoIHRoZSBvcmlnaW5hbCBpbiAuZm5zXG4gKiAtIGEgd3JhcHBlZCBjb21wb25lbnQgbWV0aG9kIChjaGVjayAuX2xlbmd0aClcbiAqIC0gYSBwbGFpbiBmdW5jdGlvbiAoLmxlbmd0aClcbiAqL1xuZnVuY3Rpb24gZ2V0SG9va0FyZ3VtZW50c0xlbmd0aCAoZm4pIHtcbiAgaWYgKGlzVW5kZWYoZm4pKSB7XG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cbiAgdmFyIGludm9rZXJGbnMgPSBmbi5mbnM7XG4gIGlmIChpc0RlZihpbnZva2VyRm5zKSkge1xuICAgIC8vIGludm9rZXJcbiAgICByZXR1cm4gZ2V0SG9va0FyZ3VtZW50c0xlbmd0aChcbiAgICAgIEFycmF5LmlzQXJyYXkoaW52b2tlckZucylcbiAgICAgICAgPyBpbnZva2VyRm5zWzBdXG4gICAgICAgIDogaW52b2tlckZuc1xuICAgIClcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gKGZuLl9sZW5ndGggfHwgZm4ubGVuZ3RoKSA+IDFcbiAgfVxufVxuXG5mdW5jdGlvbiBfZW50ZXIgKF8sIHZub2RlKSB7XG4gIGlmICh2bm9kZS5kYXRhLnNob3cgIT09IHRydWUpIHtcbiAgICBlbnRlcih2bm9kZSk7XG4gIH1cbn1cblxudmFyIHRyYW5zaXRpb24gPSBpbkJyb3dzZXIgPyB7XG4gIGNyZWF0ZTogX2VudGVyLFxuICBhY3RpdmF0ZTogX2VudGVyLFxuICByZW1vdmU6IGZ1bmN0aW9uIHJlbW92ZSQkMSAodm5vZGUsIHJtKSB7XG4gICAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cbiAgICBpZiAodm5vZGUuZGF0YS5zaG93ICE9PSB0cnVlKSB7XG4gICAgICBsZWF2ZSh2bm9kZSwgcm0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBybSgpO1xuICAgIH1cbiAgfVxufSA6IHt9O1xuXG52YXIgcGxhdGZvcm1Nb2R1bGVzID0gW1xuICBhdHRycyxcbiAga2xhc3MsXG4gIGV2ZW50cyxcbiAgZG9tUHJvcHMsXG4gIHN0eWxlLFxuICB0cmFuc2l0aW9uXG5dO1xuXG4vKiAgKi9cblxuLy8gdGhlIGRpcmVjdGl2ZSBtb2R1bGUgc2hvdWxkIGJlIGFwcGxpZWQgbGFzdCwgYWZ0ZXIgYWxsXG4vLyBidWlsdC1pbiBtb2R1bGVzIGhhdmUgYmVlbiBhcHBsaWVkLlxudmFyIG1vZHVsZXMgPSBwbGF0Zm9ybU1vZHVsZXMuY29uY2F0KGJhc2VNb2R1bGVzKTtcblxudmFyIHBhdGNoID0gY3JlYXRlUGF0Y2hGdW5jdGlvbih7IG5vZGVPcHM6IG5vZGVPcHMsIG1vZHVsZXM6IG1vZHVsZXMgfSk7XG5cbi8qKlxuICogTm90IHR5cGUgY2hlY2tpbmcgdGhpcyBmaWxlIGJlY2F1c2UgZmxvdyBkb2Vzbid0IGxpa2UgYXR0YWNoaW5nXG4gKiBwcm9wZXJ0aWVzIHRvIEVsZW1lbnRzLlxuICovXG5cbi8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuaWYgKGlzSUU5KSB7XG4gIC8vIGh0dHA6Ly93d3cubWF0dHM0MTEuY29tL3Bvc3QvaW50ZXJuZXQtZXhwbG9yZXItOS1vbmlucHV0L1xuICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdzZWxlY3Rpb25jaGFuZ2UnLCBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGVsID0gZG9jdW1lbnQuYWN0aXZlRWxlbWVudDtcbiAgICBpZiAoZWwgJiYgZWwudm1vZGVsKSB7XG4gICAgICB0cmlnZ2VyKGVsLCAnaW5wdXQnKTtcbiAgICB9XG4gIH0pO1xufVxuXG52YXIgZGlyZWN0aXZlID0ge1xuICBpbnNlcnRlZDogZnVuY3Rpb24gaW5zZXJ0ZWQgKGVsLCBiaW5kaW5nLCB2bm9kZSwgb2xkVm5vZGUpIHtcbiAgICBpZiAodm5vZGUudGFnID09PSAnc2VsZWN0Jykge1xuICAgICAgLy8gIzY5MDNcbiAgICAgIGlmIChvbGRWbm9kZS5lbG0gJiYgIW9sZFZub2RlLmVsbS5fdk9wdGlvbnMpIHtcbiAgICAgICAgbWVyZ2VWTm9kZUhvb2sodm5vZGUsICdwb3N0cGF0Y2gnLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgZGlyZWN0aXZlLmNvbXBvbmVudFVwZGF0ZWQoZWwsIGJpbmRpbmcsIHZub2RlKTtcbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzZXRTZWxlY3RlZChlbCwgYmluZGluZywgdm5vZGUuY29udGV4dCk7XG4gICAgICB9XG4gICAgICBlbC5fdk9wdGlvbnMgPSBbXS5tYXAuY2FsbChlbC5vcHRpb25zLCBnZXRWYWx1ZSk7XG4gICAgfSBlbHNlIGlmICh2bm9kZS50YWcgPT09ICd0ZXh0YXJlYScgfHwgaXNUZXh0SW5wdXRUeXBlKGVsLnR5cGUpKSB7XG4gICAgICBlbC5fdk1vZGlmaWVycyA9IGJpbmRpbmcubW9kaWZpZXJzO1xuICAgICAgaWYgKCFiaW5kaW5nLm1vZGlmaWVycy5sYXp5KSB7XG4gICAgICAgIGVsLmFkZEV2ZW50TGlzdGVuZXIoJ2NvbXBvc2l0aW9uc3RhcnQnLCBvbkNvbXBvc2l0aW9uU3RhcnQpO1xuICAgICAgICBlbC5hZGRFdmVudExpc3RlbmVyKCdjb21wb3NpdGlvbmVuZCcsIG9uQ29tcG9zaXRpb25FbmQpO1xuICAgICAgICAvLyBTYWZhcmkgPCAxMC4yICYgVUlXZWJWaWV3IGRvZXNuJ3QgZmlyZSBjb21wb3NpdGlvbmVuZCB3aGVuXG4gICAgICAgIC8vIHN3aXRjaGluZyBmb2N1cyBiZWZvcmUgY29uZmlybWluZyBjb21wb3NpdGlvbiBjaG9pY2VcbiAgICAgICAgLy8gdGhpcyBhbHNvIGZpeGVzIHRoZSBpc3N1ZSB3aGVyZSBzb21lIGJyb3dzZXJzIGUuZy4gaU9TIENocm9tZVxuICAgICAgICAvLyBmaXJlcyBcImNoYW5nZVwiIGluc3RlYWQgb2YgXCJpbnB1dFwiIG9uIGF1dG9jb21wbGV0ZS5cbiAgICAgICAgZWwuYWRkRXZlbnRMaXN0ZW5lcignY2hhbmdlJywgb25Db21wb3NpdGlvbkVuZCk7XG4gICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgICAgICBpZiAoaXNJRTkpIHtcbiAgICAgICAgICBlbC52bW9kZWwgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9LFxuXG4gIGNvbXBvbmVudFVwZGF0ZWQ6IGZ1bmN0aW9uIGNvbXBvbmVudFVwZGF0ZWQgKGVsLCBiaW5kaW5nLCB2bm9kZSkge1xuICAgIGlmICh2bm9kZS50YWcgPT09ICdzZWxlY3QnKSB7XG4gICAgICBzZXRTZWxlY3RlZChlbCwgYmluZGluZywgdm5vZGUuY29udGV4dCk7XG4gICAgICAvLyBpbiBjYXNlIHRoZSBvcHRpb25zIHJlbmRlcmVkIGJ5IHYtZm9yIGhhdmUgY2hhbmdlZCxcbiAgICAgIC8vIGl0J3MgcG9zc2libGUgdGhhdCB0aGUgdmFsdWUgaXMgb3V0LW9mLXN5bmMgd2l0aCB0aGUgcmVuZGVyZWQgb3B0aW9ucy5cbiAgICAgIC8vIGRldGVjdCBzdWNoIGNhc2VzIGFuZCBmaWx0ZXIgb3V0IHZhbHVlcyB0aGF0IG5vIGxvbmdlciBoYXMgYSBtYXRjaGluZ1xuICAgICAgLy8gb3B0aW9uIGluIHRoZSBET00uXG4gICAgICB2YXIgcHJldk9wdGlvbnMgPSBlbC5fdk9wdGlvbnM7XG4gICAgICB2YXIgY3VyT3B0aW9ucyA9IGVsLl92T3B0aW9ucyA9IFtdLm1hcC5jYWxsKGVsLm9wdGlvbnMsIGdldFZhbHVlKTtcbiAgICAgIGlmIChjdXJPcHRpb25zLnNvbWUoZnVuY3Rpb24gKG8sIGkpIHsgcmV0dXJuICFsb29zZUVxdWFsKG8sIHByZXZPcHRpb25zW2ldKTsgfSkpIHtcbiAgICAgICAgLy8gdHJpZ2dlciBjaGFuZ2UgZXZlbnQgaWZcbiAgICAgICAgLy8gbm8gbWF0Y2hpbmcgb3B0aW9uIGZvdW5kIGZvciBhdCBsZWFzdCBvbmUgdmFsdWVcbiAgICAgICAgdmFyIG5lZWRSZXNldCA9IGVsLm11bHRpcGxlXG4gICAgICAgICAgPyBiaW5kaW5nLnZhbHVlLnNvbWUoZnVuY3Rpb24gKHYpIHsgcmV0dXJuIGhhc05vTWF0Y2hpbmdPcHRpb24odiwgY3VyT3B0aW9ucyk7IH0pXG4gICAgICAgICAgOiBiaW5kaW5nLnZhbHVlICE9PSBiaW5kaW5nLm9sZFZhbHVlICYmIGhhc05vTWF0Y2hpbmdPcHRpb24oYmluZGluZy52YWx1ZSwgY3VyT3B0aW9ucyk7XG4gICAgICAgIGlmIChuZWVkUmVzZXQpIHtcbiAgICAgICAgICB0cmlnZ2VyKGVsLCAnY2hhbmdlJyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbn07XG5cbmZ1bmN0aW9uIHNldFNlbGVjdGVkIChlbCwgYmluZGluZywgdm0pIHtcbiAgYWN0dWFsbHlTZXRTZWxlY3RlZChlbCwgYmluZGluZywgdm0pO1xuICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgaWYgKGlzSUUgfHwgaXNFZGdlKSB7XG4gICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICBhY3R1YWxseVNldFNlbGVjdGVkKGVsLCBiaW5kaW5nLCB2bSk7XG4gICAgfSwgMCk7XG4gIH1cbn1cblxuZnVuY3Rpb24gYWN0dWFsbHlTZXRTZWxlY3RlZCAoZWwsIGJpbmRpbmcsIHZtKSB7XG4gIHZhciB2YWx1ZSA9IGJpbmRpbmcudmFsdWU7XG4gIHZhciBpc011bHRpcGxlID0gZWwubXVsdGlwbGU7XG4gIGlmIChpc011bHRpcGxlICYmICFBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgd2FybihcbiAgICAgIFwiPHNlbGVjdCBtdWx0aXBsZSB2LW1vZGVsPVxcXCJcIiArIChiaW5kaW5nLmV4cHJlc3Npb24pICsgXCJcXFwiPiBcIiArXG4gICAgICBcImV4cGVjdHMgYW4gQXJyYXkgdmFsdWUgZm9yIGl0cyBiaW5kaW5nLCBidXQgZ290IFwiICsgKE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh2YWx1ZSkuc2xpY2UoOCwgLTEpKSxcbiAgICAgIHZtXG4gICAgKTtcbiAgICByZXR1cm5cbiAgfVxuICB2YXIgc2VsZWN0ZWQsIG9wdGlvbjtcbiAgZm9yICh2YXIgaSA9IDAsIGwgPSBlbC5vcHRpb25zLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgIG9wdGlvbiA9IGVsLm9wdGlvbnNbaV07XG4gICAgaWYgKGlzTXVsdGlwbGUpIHtcbiAgICAgIHNlbGVjdGVkID0gbG9vc2VJbmRleE9mKHZhbHVlLCBnZXRWYWx1ZShvcHRpb24pKSA+IC0xO1xuICAgICAgaWYgKG9wdGlvbi5zZWxlY3RlZCAhPT0gc2VsZWN0ZWQpIHtcbiAgICAgICAgb3B0aW9uLnNlbGVjdGVkID0gc2VsZWN0ZWQ7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChsb29zZUVxdWFsKGdldFZhbHVlKG9wdGlvbiksIHZhbHVlKSkge1xuICAgICAgICBpZiAoZWwuc2VsZWN0ZWRJbmRleCAhPT0gaSkge1xuICAgICAgICAgIGVsLnNlbGVjdGVkSW5kZXggPSBpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVyblxuICAgICAgfVxuICAgIH1cbiAgfVxuICBpZiAoIWlzTXVsdGlwbGUpIHtcbiAgICBlbC5zZWxlY3RlZEluZGV4ID0gLTE7XG4gIH1cbn1cblxuZnVuY3Rpb24gaGFzTm9NYXRjaGluZ09wdGlvbiAodmFsdWUsIG9wdGlvbnMpIHtcbiAgcmV0dXJuIG9wdGlvbnMuZXZlcnkoZnVuY3Rpb24gKG8pIHsgcmV0dXJuICFsb29zZUVxdWFsKG8sIHZhbHVlKTsgfSlcbn1cblxuZnVuY3Rpb24gZ2V0VmFsdWUgKG9wdGlvbikge1xuICByZXR1cm4gJ192YWx1ZScgaW4gb3B0aW9uXG4gICAgPyBvcHRpb24uX3ZhbHVlXG4gICAgOiBvcHRpb24udmFsdWVcbn1cblxuZnVuY3Rpb24gb25Db21wb3NpdGlvblN0YXJ0IChlKSB7XG4gIGUudGFyZ2V0LmNvbXBvc2luZyA9IHRydWU7XG59XG5cbmZ1bmN0aW9uIG9uQ29tcG9zaXRpb25FbmQgKGUpIHtcbiAgLy8gcHJldmVudCB0cmlnZ2VyaW5nIGFuIGlucHV0IGV2ZW50IGZvciBubyByZWFzb25cbiAgaWYgKCFlLnRhcmdldC5jb21wb3NpbmcpIHsgcmV0dXJuIH1cbiAgZS50YXJnZXQuY29tcG9zaW5nID0gZmFsc2U7XG4gIHRyaWdnZXIoZS50YXJnZXQsICdpbnB1dCcpO1xufVxuXG5mdW5jdGlvbiB0cmlnZ2VyIChlbCwgdHlwZSkge1xuICB2YXIgZSA9IGRvY3VtZW50LmNyZWF0ZUV2ZW50KCdIVE1MRXZlbnRzJyk7XG4gIGUuaW5pdEV2ZW50KHR5cGUsIHRydWUsIHRydWUpO1xuICBlbC5kaXNwYXRjaEV2ZW50KGUpO1xufVxuXG4vKiAgKi9cblxuLy8gcmVjdXJzaXZlbHkgc2VhcmNoIGZvciBwb3NzaWJsZSB0cmFuc2l0aW9uIGRlZmluZWQgaW5zaWRlIHRoZSBjb21wb25lbnQgcm9vdFxuZnVuY3Rpb24gbG9jYXRlTm9kZSAodm5vZGUpIHtcbiAgcmV0dXJuIHZub2RlLmNvbXBvbmVudEluc3RhbmNlICYmICghdm5vZGUuZGF0YSB8fCAhdm5vZGUuZGF0YS50cmFuc2l0aW9uKVxuICAgID8gbG9jYXRlTm9kZSh2bm9kZS5jb21wb25lbnRJbnN0YW5jZS5fdm5vZGUpXG4gICAgOiB2bm9kZVxufVxuXG52YXIgc2hvdyA9IHtcbiAgYmluZDogZnVuY3Rpb24gYmluZCAoZWwsIHJlZiwgdm5vZGUpIHtcbiAgICB2YXIgdmFsdWUgPSByZWYudmFsdWU7XG5cbiAgICB2bm9kZSA9IGxvY2F0ZU5vZGUodm5vZGUpO1xuICAgIHZhciB0cmFuc2l0aW9uJCQxID0gdm5vZGUuZGF0YSAmJiB2bm9kZS5kYXRhLnRyYW5zaXRpb247XG4gICAgdmFyIG9yaWdpbmFsRGlzcGxheSA9IGVsLl9fdk9yaWdpbmFsRGlzcGxheSA9XG4gICAgICBlbC5zdHlsZS5kaXNwbGF5ID09PSAnbm9uZScgPyAnJyA6IGVsLnN0eWxlLmRpc3BsYXk7XG4gICAgaWYgKHZhbHVlICYmIHRyYW5zaXRpb24kJDEpIHtcbiAgICAgIHZub2RlLmRhdGEuc2hvdyA9IHRydWU7XG4gICAgICBlbnRlcih2bm9kZSwgZnVuY3Rpb24gKCkge1xuICAgICAgICBlbC5zdHlsZS5kaXNwbGF5ID0gb3JpZ2luYWxEaXNwbGF5O1xuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGVsLnN0eWxlLmRpc3BsYXkgPSB2YWx1ZSA/IG9yaWdpbmFsRGlzcGxheSA6ICdub25lJztcbiAgICB9XG4gIH0sXG5cbiAgdXBkYXRlOiBmdW5jdGlvbiB1cGRhdGUgKGVsLCByZWYsIHZub2RlKSB7XG4gICAgdmFyIHZhbHVlID0gcmVmLnZhbHVlO1xuICAgIHZhciBvbGRWYWx1ZSA9IHJlZi5vbGRWYWx1ZTtcblxuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgIGlmICghdmFsdWUgPT09ICFvbGRWYWx1ZSkgeyByZXR1cm4gfVxuICAgIHZub2RlID0gbG9jYXRlTm9kZSh2bm9kZSk7XG4gICAgdmFyIHRyYW5zaXRpb24kJDEgPSB2bm9kZS5kYXRhICYmIHZub2RlLmRhdGEudHJhbnNpdGlvbjtcbiAgICBpZiAodHJhbnNpdGlvbiQkMSkge1xuICAgICAgdm5vZGUuZGF0YS5zaG93ID0gdHJ1ZTtcbiAgICAgIGlmICh2YWx1ZSkge1xuICAgICAgICBlbnRlcih2bm9kZSwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgIGVsLnN0eWxlLmRpc3BsYXkgPSBlbC5fX3ZPcmlnaW5hbERpc3BsYXk7XG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbGVhdmUodm5vZGUsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBlbC5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgZWwuc3R5bGUuZGlzcGxheSA9IHZhbHVlID8gZWwuX192T3JpZ2luYWxEaXNwbGF5IDogJ25vbmUnO1xuICAgIH1cbiAgfSxcblxuICB1bmJpbmQ6IGZ1bmN0aW9uIHVuYmluZCAoXG4gICAgZWwsXG4gICAgYmluZGluZyxcbiAgICB2bm9kZSxcbiAgICBvbGRWbm9kZSxcbiAgICBpc0Rlc3Ryb3lcbiAgKSB7XG4gICAgaWYgKCFpc0Rlc3Ryb3kpIHtcbiAgICAgIGVsLnN0eWxlLmRpc3BsYXkgPSBlbC5fX3ZPcmlnaW5hbERpc3BsYXk7XG4gICAgfVxuICB9XG59O1xuXG52YXIgcGxhdGZvcm1EaXJlY3RpdmVzID0ge1xuICBtb2RlbDogZGlyZWN0aXZlLFxuICBzaG93OiBzaG93XG59O1xuXG4vKiAgKi9cblxudmFyIHRyYW5zaXRpb25Qcm9wcyA9IHtcbiAgbmFtZTogU3RyaW5nLFxuICBhcHBlYXI6IEJvb2xlYW4sXG4gIGNzczogQm9vbGVhbixcbiAgbW9kZTogU3RyaW5nLFxuICB0eXBlOiBTdHJpbmcsXG4gIGVudGVyQ2xhc3M6IFN0cmluZyxcbiAgbGVhdmVDbGFzczogU3RyaW5nLFxuICBlbnRlclRvQ2xhc3M6IFN0cmluZyxcbiAgbGVhdmVUb0NsYXNzOiBTdHJpbmcsXG4gIGVudGVyQWN0aXZlQ2xhc3M6IFN0cmluZyxcbiAgbGVhdmVBY3RpdmVDbGFzczogU3RyaW5nLFxuICBhcHBlYXJDbGFzczogU3RyaW5nLFxuICBhcHBlYXJBY3RpdmVDbGFzczogU3RyaW5nLFxuICBhcHBlYXJUb0NsYXNzOiBTdHJpbmcsXG4gIGR1cmF0aW9uOiBbTnVtYmVyLCBTdHJpbmcsIE9iamVjdF1cbn07XG5cbi8vIGluIGNhc2UgdGhlIGNoaWxkIGlzIGFsc28gYW4gYWJzdHJhY3QgY29tcG9uZW50LCBlLmcuIDxrZWVwLWFsaXZlPlxuLy8gd2Ugd2FudCB0byByZWN1cnNpdmVseSByZXRyaWV2ZSB0aGUgcmVhbCBjb21wb25lbnQgdG8gYmUgcmVuZGVyZWRcbmZ1bmN0aW9uIGdldFJlYWxDaGlsZCAodm5vZGUpIHtcbiAgdmFyIGNvbXBPcHRpb25zID0gdm5vZGUgJiYgdm5vZGUuY29tcG9uZW50T3B0aW9ucztcbiAgaWYgKGNvbXBPcHRpb25zICYmIGNvbXBPcHRpb25zLkN0b3Iub3B0aW9ucy5hYnN0cmFjdCkge1xuICAgIHJldHVybiBnZXRSZWFsQ2hpbGQoZ2V0Rmlyc3RDb21wb25lbnRDaGlsZChjb21wT3B0aW9ucy5jaGlsZHJlbikpXG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIHZub2RlXG4gIH1cbn1cblxuZnVuY3Rpb24gZXh0cmFjdFRyYW5zaXRpb25EYXRhIChjb21wKSB7XG4gIHZhciBkYXRhID0ge307XG4gIHZhciBvcHRpb25zID0gY29tcC4kb3B0aW9ucztcbiAgLy8gcHJvcHNcbiAgZm9yICh2YXIga2V5IGluIG9wdGlvbnMucHJvcHNEYXRhKSB7XG4gICAgZGF0YVtrZXldID0gY29tcFtrZXldO1xuICB9XG4gIC8vIGV2ZW50cy5cbiAgLy8gZXh0cmFjdCBsaXN0ZW5lcnMgYW5kIHBhc3MgdGhlbSBkaXJlY3RseSB0byB0aGUgdHJhbnNpdGlvbiBtZXRob2RzXG4gIHZhciBsaXN0ZW5lcnMgPSBvcHRpb25zLl9wYXJlbnRMaXN0ZW5lcnM7XG4gIGZvciAodmFyIGtleSQxIGluIGxpc3RlbmVycykge1xuICAgIGRhdGFbY2FtZWxpemUoa2V5JDEpXSA9IGxpc3RlbmVyc1trZXkkMV07XG4gIH1cbiAgcmV0dXJuIGRhdGFcbn1cblxuZnVuY3Rpb24gcGxhY2Vob2xkZXIgKGgsIHJhd0NoaWxkKSB7XG4gIGlmICgvXFxkLWtlZXAtYWxpdmUkLy50ZXN0KHJhd0NoaWxkLnRhZykpIHtcbiAgICByZXR1cm4gaCgna2VlcC1hbGl2ZScsIHtcbiAgICAgIHByb3BzOiByYXdDaGlsZC5jb21wb25lbnRPcHRpb25zLnByb3BzRGF0YVxuICAgIH0pXG4gIH1cbn1cblxuZnVuY3Rpb24gaGFzUGFyZW50VHJhbnNpdGlvbiAodm5vZGUpIHtcbiAgd2hpbGUgKCh2bm9kZSA9IHZub2RlLnBhcmVudCkpIHtcbiAgICBpZiAodm5vZGUuZGF0YS50cmFuc2l0aW9uKSB7XG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBpc1NhbWVDaGlsZCAoY2hpbGQsIG9sZENoaWxkKSB7XG4gIHJldHVybiBvbGRDaGlsZC5rZXkgPT09IGNoaWxkLmtleSAmJiBvbGRDaGlsZC50YWcgPT09IGNoaWxkLnRhZ1xufVxuXG52YXIgaXNOb3RUZXh0Tm9kZSA9IGZ1bmN0aW9uIChjKSB7IHJldHVybiBjLnRhZyB8fCBpc0FzeW5jUGxhY2Vob2xkZXIoYyk7IH07XG5cbnZhciBpc1ZTaG93RGlyZWN0aXZlID0gZnVuY3Rpb24gKGQpIHsgcmV0dXJuIGQubmFtZSA9PT0gJ3Nob3cnOyB9O1xuXG52YXIgVHJhbnNpdGlvbiA9IHtcbiAgbmFtZTogJ3RyYW5zaXRpb24nLFxuICBwcm9wczogdHJhbnNpdGlvblByb3BzLFxuICBhYnN0cmFjdDogdHJ1ZSxcblxuICByZW5kZXI6IGZ1bmN0aW9uIHJlbmRlciAoaCkge1xuICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gICAgdmFyIGNoaWxkcmVuID0gdGhpcy4kc2xvdHMuZGVmYXVsdDtcbiAgICBpZiAoIWNoaWxkcmVuKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICAvLyBmaWx0ZXIgb3V0IHRleHQgbm9kZXMgKHBvc3NpYmxlIHdoaXRlc3BhY2VzKVxuICAgIGNoaWxkcmVuID0gY2hpbGRyZW4uZmlsdGVyKGlzTm90VGV4dE5vZGUpO1xuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgIGlmICghY2hpbGRyZW4ubGVuZ3RoKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICAvLyB3YXJuIG11bHRpcGxlIGVsZW1lbnRzXG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgY2hpbGRyZW4ubGVuZ3RoID4gMSkge1xuICAgICAgd2FybihcbiAgICAgICAgJzx0cmFuc2l0aW9uPiBjYW4gb25seSBiZSB1c2VkIG9uIGEgc2luZ2xlIGVsZW1lbnQuIFVzZSAnICtcbiAgICAgICAgJzx0cmFuc2l0aW9uLWdyb3VwPiBmb3IgbGlzdHMuJyxcbiAgICAgICAgdGhpcy4kcGFyZW50XG4gICAgICApO1xuICAgIH1cblxuICAgIHZhciBtb2RlID0gdGhpcy5tb2RlO1xuXG4gICAgLy8gd2FybiBpbnZhbGlkIG1vZGVcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJlxuICAgICAgbW9kZSAmJiBtb2RlICE9PSAnaW4tb3V0JyAmJiBtb2RlICE9PSAnb3V0LWluJ1xuICAgICkge1xuICAgICAgd2FybihcbiAgICAgICAgJ2ludmFsaWQgPHRyYW5zaXRpb24+IG1vZGU6ICcgKyBtb2RlLFxuICAgICAgICB0aGlzLiRwYXJlbnRcbiAgICAgICk7XG4gICAgfVxuXG4gICAgdmFyIHJhd0NoaWxkID0gY2hpbGRyZW5bMF07XG5cbiAgICAvLyBpZiB0aGlzIGlzIGEgY29tcG9uZW50IHJvb3Qgbm9kZSBhbmQgdGhlIGNvbXBvbmVudCdzXG4gICAgLy8gcGFyZW50IGNvbnRhaW5lciBub2RlIGFsc28gaGFzIHRyYW5zaXRpb24sIHNraXAuXG4gICAgaWYgKGhhc1BhcmVudFRyYW5zaXRpb24odGhpcy4kdm5vZGUpKSB7XG4gICAgICByZXR1cm4gcmF3Q2hpbGRcbiAgICB9XG5cbiAgICAvLyBhcHBseSB0cmFuc2l0aW9uIGRhdGEgdG8gY2hpbGRcbiAgICAvLyB1c2UgZ2V0UmVhbENoaWxkKCkgdG8gaWdub3JlIGFic3RyYWN0IGNvbXBvbmVudHMgZS5nLiBrZWVwLWFsaXZlXG4gICAgdmFyIGNoaWxkID0gZ2V0UmVhbENoaWxkKHJhd0NoaWxkKTtcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICBpZiAoIWNoaWxkKSB7XG4gICAgICByZXR1cm4gcmF3Q2hpbGRcbiAgICB9XG5cbiAgICBpZiAodGhpcy5fbGVhdmluZykge1xuICAgICAgcmV0dXJuIHBsYWNlaG9sZGVyKGgsIHJhd0NoaWxkKVxuICAgIH1cblxuICAgIC8vIGVuc3VyZSBhIGtleSB0aGF0IGlzIHVuaXF1ZSB0byB0aGUgdm5vZGUgdHlwZSBhbmQgdG8gdGhpcyB0cmFuc2l0aW9uXG4gICAgLy8gY29tcG9uZW50IGluc3RhbmNlLiBUaGlzIGtleSB3aWxsIGJlIHVzZWQgdG8gcmVtb3ZlIHBlbmRpbmcgbGVhdmluZyBub2Rlc1xuICAgIC8vIGR1cmluZyBlbnRlcmluZy5cbiAgICB2YXIgaWQgPSBcIl9fdHJhbnNpdGlvbi1cIiArICh0aGlzLl91aWQpICsgXCItXCI7XG4gICAgY2hpbGQua2V5ID0gY2hpbGQua2V5ID09IG51bGxcbiAgICAgID8gY2hpbGQuaXNDb21tZW50XG4gICAgICAgID8gaWQgKyAnY29tbWVudCdcbiAgICAgICAgOiBpZCArIGNoaWxkLnRhZ1xuICAgICAgOiBpc1ByaW1pdGl2ZShjaGlsZC5rZXkpXG4gICAgICAgID8gKFN0cmluZyhjaGlsZC5rZXkpLmluZGV4T2YoaWQpID09PSAwID8gY2hpbGQua2V5IDogaWQgKyBjaGlsZC5rZXkpXG4gICAgICAgIDogY2hpbGQua2V5O1xuXG4gICAgdmFyIGRhdGEgPSAoY2hpbGQuZGF0YSB8fCAoY2hpbGQuZGF0YSA9IHt9KSkudHJhbnNpdGlvbiA9IGV4dHJhY3RUcmFuc2l0aW9uRGF0YSh0aGlzKTtcbiAgICB2YXIgb2xkUmF3Q2hpbGQgPSB0aGlzLl92bm9kZTtcbiAgICB2YXIgb2xkQ2hpbGQgPSBnZXRSZWFsQ2hpbGQob2xkUmF3Q2hpbGQpO1xuXG4gICAgLy8gbWFyayB2LXNob3dcbiAgICAvLyBzbyB0aGF0IHRoZSB0cmFuc2l0aW9uIG1vZHVsZSBjYW4gaGFuZCBvdmVyIHRoZSBjb250cm9sIHRvIHRoZSBkaXJlY3RpdmVcbiAgICBpZiAoY2hpbGQuZGF0YS5kaXJlY3RpdmVzICYmIGNoaWxkLmRhdGEuZGlyZWN0aXZlcy5zb21lKGlzVlNob3dEaXJlY3RpdmUpKSB7XG4gICAgICBjaGlsZC5kYXRhLnNob3cgPSB0cnVlO1xuICAgIH1cblxuICAgIGlmIChcbiAgICAgIG9sZENoaWxkICYmXG4gICAgICBvbGRDaGlsZC5kYXRhICYmXG4gICAgICAhaXNTYW1lQ2hpbGQoY2hpbGQsIG9sZENoaWxkKSAmJlxuICAgICAgIWlzQXN5bmNQbGFjZWhvbGRlcihvbGRDaGlsZCkgJiZcbiAgICAgIC8vICM2Njg3IGNvbXBvbmVudCByb290IGlzIGEgY29tbWVudCBub2RlXG4gICAgICAhKG9sZENoaWxkLmNvbXBvbmVudEluc3RhbmNlICYmIG9sZENoaWxkLmNvbXBvbmVudEluc3RhbmNlLl92bm9kZS5pc0NvbW1lbnQpXG4gICAgKSB7XG4gICAgICAvLyByZXBsYWNlIG9sZCBjaGlsZCB0cmFuc2l0aW9uIGRhdGEgd2l0aCBmcmVzaCBvbmVcbiAgICAgIC8vIGltcG9ydGFudCBmb3IgZHluYW1pYyB0cmFuc2l0aW9ucyFcbiAgICAgIHZhciBvbGREYXRhID0gb2xkQ2hpbGQuZGF0YS50cmFuc2l0aW9uID0gZXh0ZW5kKHt9LCBkYXRhKTtcbiAgICAgIC8vIGhhbmRsZSB0cmFuc2l0aW9uIG1vZGVcbiAgICAgIGlmIChtb2RlID09PSAnb3V0LWluJykge1xuICAgICAgICAvLyByZXR1cm4gcGxhY2Vob2xkZXIgbm9kZSBhbmQgcXVldWUgdXBkYXRlIHdoZW4gbGVhdmUgZmluaXNoZXNcbiAgICAgICAgdGhpcy5fbGVhdmluZyA9IHRydWU7XG4gICAgICAgIG1lcmdlVk5vZGVIb29rKG9sZERhdGEsICdhZnRlckxlYXZlJywgZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHRoaXMkMS5fbGVhdmluZyA9IGZhbHNlO1xuICAgICAgICAgIHRoaXMkMS4kZm9yY2VVcGRhdGUoKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBwbGFjZWhvbGRlcihoLCByYXdDaGlsZClcbiAgICAgIH0gZWxzZSBpZiAobW9kZSA9PT0gJ2luLW91dCcpIHtcbiAgICAgICAgaWYgKGlzQXN5bmNQbGFjZWhvbGRlcihjaGlsZCkpIHtcbiAgICAgICAgICByZXR1cm4gb2xkUmF3Q2hpbGRcbiAgICAgICAgfVxuICAgICAgICB2YXIgZGVsYXllZExlYXZlO1xuICAgICAgICB2YXIgcGVyZm9ybUxlYXZlID0gZnVuY3Rpb24gKCkgeyBkZWxheWVkTGVhdmUoKTsgfTtcbiAgICAgICAgbWVyZ2VWTm9kZUhvb2soZGF0YSwgJ2FmdGVyRW50ZXInLCBwZXJmb3JtTGVhdmUpO1xuICAgICAgICBtZXJnZVZOb2RlSG9vayhkYXRhLCAnZW50ZXJDYW5jZWxsZWQnLCBwZXJmb3JtTGVhdmUpO1xuICAgICAgICBtZXJnZVZOb2RlSG9vayhvbGREYXRhLCAnZGVsYXlMZWF2ZScsIGZ1bmN0aW9uIChsZWF2ZSkgeyBkZWxheWVkTGVhdmUgPSBsZWF2ZTsgfSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHJhd0NoaWxkXG4gIH1cbn07XG5cbi8qICAqL1xuXG52YXIgcHJvcHMgPSBleHRlbmQoe1xuICB0YWc6IFN0cmluZyxcbiAgbW92ZUNsYXNzOiBTdHJpbmdcbn0sIHRyYW5zaXRpb25Qcm9wcyk7XG5cbmRlbGV0ZSBwcm9wcy5tb2RlO1xuXG52YXIgVHJhbnNpdGlvbkdyb3VwID0ge1xuICBwcm9wczogcHJvcHMsXG5cbiAgYmVmb3JlTW91bnQ6IGZ1bmN0aW9uIGJlZm9yZU1vdW50ICgpIHtcbiAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuICAgIHZhciB1cGRhdGUgPSB0aGlzLl91cGRhdGU7XG4gICAgdGhpcy5fdXBkYXRlID0gZnVuY3Rpb24gKHZub2RlLCBoeWRyYXRpbmcpIHtcbiAgICAgIHZhciByZXN0b3JlQWN0aXZlSW5zdGFuY2UgPSBzZXRBY3RpdmVJbnN0YW5jZSh0aGlzJDEpO1xuICAgICAgLy8gZm9yY2UgcmVtb3ZpbmcgcGFzc1xuICAgICAgdGhpcyQxLl9fcGF0Y2hfXyhcbiAgICAgICAgdGhpcyQxLl92bm9kZSxcbiAgICAgICAgdGhpcyQxLmtlcHQsXG4gICAgICAgIGZhbHNlLCAvLyBoeWRyYXRpbmdcbiAgICAgICAgdHJ1ZSAvLyByZW1vdmVPbmx5ICghaW1wb3J0YW50LCBhdm9pZHMgdW5uZWNlc3NhcnkgbW92ZXMpXG4gICAgICApO1xuICAgICAgdGhpcyQxLl92bm9kZSA9IHRoaXMkMS5rZXB0O1xuICAgICAgcmVzdG9yZUFjdGl2ZUluc3RhbmNlKCk7XG4gICAgICB1cGRhdGUuY2FsbCh0aGlzJDEsIHZub2RlLCBoeWRyYXRpbmcpO1xuICAgIH07XG4gIH0sXG5cbiAgcmVuZGVyOiBmdW5jdGlvbiByZW5kZXIgKGgpIHtcbiAgICB2YXIgdGFnID0gdGhpcy50YWcgfHwgdGhpcy4kdm5vZGUuZGF0YS50YWcgfHwgJ3NwYW4nO1xuICAgIHZhciBtYXAgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgIHZhciBwcmV2Q2hpbGRyZW4gPSB0aGlzLnByZXZDaGlsZHJlbiA9IHRoaXMuY2hpbGRyZW47XG4gICAgdmFyIHJhd0NoaWxkcmVuID0gdGhpcy4kc2xvdHMuZGVmYXVsdCB8fCBbXTtcbiAgICB2YXIgY2hpbGRyZW4gPSB0aGlzLmNoaWxkcmVuID0gW107XG4gICAgdmFyIHRyYW5zaXRpb25EYXRhID0gZXh0cmFjdFRyYW5zaXRpb25EYXRhKHRoaXMpO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCByYXdDaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGMgPSByYXdDaGlsZHJlbltpXTtcbiAgICAgIGlmIChjLnRhZykge1xuICAgICAgICBpZiAoYy5rZXkgIT0gbnVsbCAmJiBTdHJpbmcoYy5rZXkpLmluZGV4T2YoJ19fdmxpc3QnKSAhPT0gMCkge1xuICAgICAgICAgIGNoaWxkcmVuLnB1c2goYyk7XG4gICAgICAgICAgbWFwW2Mua2V5XSA9IGNcbiAgICAgICAgICA7KGMuZGF0YSB8fCAoYy5kYXRhID0ge30pKS50cmFuc2l0aW9uID0gdHJhbnNpdGlvbkRhdGE7XG4gICAgICAgIH0gZWxzZSBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICAgIHZhciBvcHRzID0gYy5jb21wb25lbnRPcHRpb25zO1xuICAgICAgICAgIHZhciBuYW1lID0gb3B0cyA/IChvcHRzLkN0b3Iub3B0aW9ucy5uYW1lIHx8IG9wdHMudGFnIHx8ICcnKSA6IGMudGFnO1xuICAgICAgICAgIHdhcm4oKFwiPHRyYW5zaXRpb24tZ3JvdXA+IGNoaWxkcmVuIG11c3QgYmUga2V5ZWQ6IDxcIiArIG5hbWUgKyBcIj5cIikpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHByZXZDaGlsZHJlbikge1xuICAgICAgdmFyIGtlcHQgPSBbXTtcbiAgICAgIHZhciByZW1vdmVkID0gW107XG4gICAgICBmb3IgKHZhciBpJDEgPSAwOyBpJDEgPCBwcmV2Q2hpbGRyZW4ubGVuZ3RoOyBpJDErKykge1xuICAgICAgICB2YXIgYyQxID0gcHJldkNoaWxkcmVuW2kkMV07XG4gICAgICAgIGMkMS5kYXRhLnRyYW5zaXRpb24gPSB0cmFuc2l0aW9uRGF0YTtcbiAgICAgICAgYyQxLmRhdGEucG9zID0gYyQxLmVsbS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgICAgaWYgKG1hcFtjJDEua2V5XSkge1xuICAgICAgICAgIGtlcHQucHVzaChjJDEpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJlbW92ZWQucHVzaChjJDEpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICB0aGlzLmtlcHQgPSBoKHRhZywgbnVsbCwga2VwdCk7XG4gICAgICB0aGlzLnJlbW92ZWQgPSByZW1vdmVkO1xuICAgIH1cblxuICAgIHJldHVybiBoKHRhZywgbnVsbCwgY2hpbGRyZW4pXG4gIH0sXG5cbiAgdXBkYXRlZDogZnVuY3Rpb24gdXBkYXRlZCAoKSB7XG4gICAgdmFyIGNoaWxkcmVuID0gdGhpcy5wcmV2Q2hpbGRyZW47XG4gICAgdmFyIG1vdmVDbGFzcyA9IHRoaXMubW92ZUNsYXNzIHx8ICgodGhpcy5uYW1lIHx8ICd2JykgKyAnLW1vdmUnKTtcbiAgICBpZiAoIWNoaWxkcmVuLmxlbmd0aCB8fCAhdGhpcy5oYXNNb3ZlKGNoaWxkcmVuWzBdLmVsbSwgbW92ZUNsYXNzKSkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgLy8gd2UgZGl2aWRlIHRoZSB3b3JrIGludG8gdGhyZWUgbG9vcHMgdG8gYXZvaWQgbWl4aW5nIERPTSByZWFkcyBhbmQgd3JpdGVzXG4gICAgLy8gaW4gZWFjaCBpdGVyYXRpb24gLSB3aGljaCBoZWxwcyBwcmV2ZW50IGxheW91dCB0aHJhc2hpbmcuXG4gICAgY2hpbGRyZW4uZm9yRWFjaChjYWxsUGVuZGluZ0Nicyk7XG4gICAgY2hpbGRyZW4uZm9yRWFjaChyZWNvcmRQb3NpdGlvbik7XG4gICAgY2hpbGRyZW4uZm9yRWFjaChhcHBseVRyYW5zbGF0aW9uKTtcblxuICAgIC8vIGZvcmNlIHJlZmxvdyB0byBwdXQgZXZlcnl0aGluZyBpbiBwb3NpdGlvblxuICAgIC8vIGFzc2lnbiB0byB0aGlzIHRvIGF2b2lkIGJlaW5nIHJlbW92ZWQgaW4gdHJlZS1zaGFraW5nXG4gICAgLy8gJGZsb3ctZGlzYWJsZS1saW5lXG4gICAgdGhpcy5fcmVmbG93ID0gZG9jdW1lbnQuYm9keS5vZmZzZXRIZWlnaHQ7XG5cbiAgICBjaGlsZHJlbi5mb3JFYWNoKGZ1bmN0aW9uIChjKSB7XG4gICAgICBpZiAoYy5kYXRhLm1vdmVkKSB7XG4gICAgICAgIHZhciBlbCA9IGMuZWxtO1xuICAgICAgICB2YXIgcyA9IGVsLnN0eWxlO1xuICAgICAgICBhZGRUcmFuc2l0aW9uQ2xhc3MoZWwsIG1vdmVDbGFzcyk7XG4gICAgICAgIHMudHJhbnNmb3JtID0gcy5XZWJraXRUcmFuc2Zvcm0gPSBzLnRyYW5zaXRpb25EdXJhdGlvbiA9ICcnO1xuICAgICAgICBlbC5hZGRFdmVudExpc3RlbmVyKHRyYW5zaXRpb25FbmRFdmVudCwgZWwuX21vdmVDYiA9IGZ1bmN0aW9uIGNiIChlKSB7XG4gICAgICAgICAgaWYgKGUgJiYgZS50YXJnZXQgIT09IGVsKSB7XG4gICAgICAgICAgICByZXR1cm5cbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKCFlIHx8IC90cmFuc2Zvcm0kLy50ZXN0KGUucHJvcGVydHlOYW1lKSkge1xuICAgICAgICAgICAgZWwucmVtb3ZlRXZlbnRMaXN0ZW5lcih0cmFuc2l0aW9uRW5kRXZlbnQsIGNiKTtcbiAgICAgICAgICAgIGVsLl9tb3ZlQ2IgPSBudWxsO1xuICAgICAgICAgICAgcmVtb3ZlVHJhbnNpdGlvbkNsYXNzKGVsLCBtb3ZlQ2xhc3MpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSk7XG4gIH0sXG5cbiAgbWV0aG9kczoge1xuICAgIGhhc01vdmU6IGZ1bmN0aW9uIGhhc01vdmUgKGVsLCBtb3ZlQ2xhc3MpIHtcbiAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgICAgaWYgKCFoYXNUcmFuc2l0aW9uKSB7XG4gICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgfVxuICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgICBpZiAodGhpcy5faGFzTW92ZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5faGFzTW92ZVxuICAgICAgfVxuICAgICAgLy8gRGV0ZWN0IHdoZXRoZXIgYW4gZWxlbWVudCB3aXRoIHRoZSBtb3ZlIGNsYXNzIGFwcGxpZWQgaGFzXG4gICAgICAvLyBDU1MgdHJhbnNpdGlvbnMuIFNpbmNlIHRoZSBlbGVtZW50IG1heSBiZSBpbnNpZGUgYW4gZW50ZXJpbmdcbiAgICAgIC8vIHRyYW5zaXRpb24gYXQgdGhpcyB2ZXJ5IG1vbWVudCwgd2UgbWFrZSBhIGNsb25lIG9mIGl0IGFuZCByZW1vdmVcbiAgICAgIC8vIGFsbCBvdGhlciB0cmFuc2l0aW9uIGNsYXNzZXMgYXBwbGllZCB0byBlbnN1cmUgb25seSB0aGUgbW92ZSBjbGFzc1xuICAgICAgLy8gaXMgYXBwbGllZC5cbiAgICAgIHZhciBjbG9uZSA9IGVsLmNsb25lTm9kZSgpO1xuICAgICAgaWYgKGVsLl90cmFuc2l0aW9uQ2xhc3Nlcykge1xuICAgICAgICBlbC5fdHJhbnNpdGlvbkNsYXNzZXMuZm9yRWFjaChmdW5jdGlvbiAoY2xzKSB7IHJlbW92ZUNsYXNzKGNsb25lLCBjbHMpOyB9KTtcbiAgICAgIH1cbiAgICAgIGFkZENsYXNzKGNsb25lLCBtb3ZlQ2xhc3MpO1xuICAgICAgY2xvbmUuc3R5bGUuZGlzcGxheSA9ICdub25lJztcbiAgICAgIHRoaXMuJGVsLmFwcGVuZENoaWxkKGNsb25lKTtcbiAgICAgIHZhciBpbmZvID0gZ2V0VHJhbnNpdGlvbkluZm8oY2xvbmUpO1xuICAgICAgdGhpcy4kZWwucmVtb3ZlQ2hpbGQoY2xvbmUpO1xuICAgICAgcmV0dXJuICh0aGlzLl9oYXNNb3ZlID0gaW5mby5oYXNUcmFuc2Zvcm0pXG4gICAgfVxuICB9XG59O1xuXG5mdW5jdGlvbiBjYWxsUGVuZGluZ0NicyAoYykge1xuICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgaWYgKGMuZWxtLl9tb3ZlQ2IpIHtcbiAgICBjLmVsbS5fbW92ZUNiKCk7XG4gIH1cbiAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gIGlmIChjLmVsbS5fZW50ZXJDYikge1xuICAgIGMuZWxtLl9lbnRlckNiKCk7XG4gIH1cbn1cblxuZnVuY3Rpb24gcmVjb3JkUG9zaXRpb24gKGMpIHtcbiAgYy5kYXRhLm5ld1BvcyA9IGMuZWxtLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xufVxuXG5mdW5jdGlvbiBhcHBseVRyYW5zbGF0aW9uIChjKSB7XG4gIHZhciBvbGRQb3MgPSBjLmRhdGEucG9zO1xuICB2YXIgbmV3UG9zID0gYy5kYXRhLm5ld1BvcztcbiAgdmFyIGR4ID0gb2xkUG9zLmxlZnQgLSBuZXdQb3MubGVmdDtcbiAgdmFyIGR5ID0gb2xkUG9zLnRvcCAtIG5ld1Bvcy50b3A7XG4gIGlmIChkeCB8fCBkeSkge1xuICAgIGMuZGF0YS5tb3ZlZCA9IHRydWU7XG4gICAgdmFyIHMgPSBjLmVsbS5zdHlsZTtcbiAgICBzLnRyYW5zZm9ybSA9IHMuV2Via2l0VHJhbnNmb3JtID0gXCJ0cmFuc2xhdGUoXCIgKyBkeCArIFwicHgsXCIgKyBkeSArIFwicHgpXCI7XG4gICAgcy50cmFuc2l0aW9uRHVyYXRpb24gPSAnMHMnO1xuICB9XG59XG5cbnZhciBwbGF0Zm9ybUNvbXBvbmVudHMgPSB7XG4gIFRyYW5zaXRpb246IFRyYW5zaXRpb24sXG4gIFRyYW5zaXRpb25Hcm91cDogVHJhbnNpdGlvbkdyb3VwXG59O1xuXG4vKiAgKi9cblxuLy8gaW5zdGFsbCBwbGF0Zm9ybSBzcGVjaWZpYyB1dGlsc1xuVnVlLmNvbmZpZy5tdXN0VXNlUHJvcCA9IG11c3RVc2VQcm9wO1xuVnVlLmNvbmZpZy5pc1Jlc2VydmVkVGFnID0gaXNSZXNlcnZlZFRhZztcblZ1ZS5jb25maWcuaXNSZXNlcnZlZEF0dHIgPSBpc1Jlc2VydmVkQXR0cjtcblZ1ZS5jb25maWcuZ2V0VGFnTmFtZXNwYWNlID0gZ2V0VGFnTmFtZXNwYWNlO1xuVnVlLmNvbmZpZy5pc1Vua25vd25FbGVtZW50ID0gaXNVbmtub3duRWxlbWVudDtcblxuLy8gaW5zdGFsbCBwbGF0Zm9ybSBydW50aW1lIGRpcmVjdGl2ZXMgJiBjb21wb25lbnRzXG5leHRlbmQoVnVlLm9wdGlvbnMuZGlyZWN0aXZlcywgcGxhdGZvcm1EaXJlY3RpdmVzKTtcbmV4dGVuZChWdWUub3B0aW9ucy5jb21wb25lbnRzLCBwbGF0Zm9ybUNvbXBvbmVudHMpO1xuXG4vLyBpbnN0YWxsIHBsYXRmb3JtIHBhdGNoIGZ1bmN0aW9uXG5WdWUucHJvdG90eXBlLl9fcGF0Y2hfXyA9IGluQnJvd3NlciA/IHBhdGNoIDogbm9vcDtcblxuLy8gcHVibGljIG1vdW50IG1ldGhvZFxuVnVlLnByb3RvdHlwZS4kbW91bnQgPSBmdW5jdGlvbiAoXG4gIGVsLFxuICBoeWRyYXRpbmdcbikge1xuICBlbCA9IGVsICYmIGluQnJvd3NlciA/IHF1ZXJ5KGVsKSA6IHVuZGVmaW5lZDtcbiAgcmV0dXJuIG1vdW50Q29tcG9uZW50KHRoaXMsIGVsLCBoeWRyYXRpbmcpXG59O1xuXG4vLyBkZXZ0b29scyBnbG9iYWwgaG9va1xuLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbmlmIChpbkJyb3dzZXIpIHtcbiAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgaWYgKGNvbmZpZy5kZXZ0b29scykge1xuICAgICAgaWYgKGRldnRvb2xzKSB7XG4gICAgICAgIGRldnRvb2xzLmVtaXQoJ2luaXQnLCBWdWUpO1xuICAgICAgfSBlbHNlIGlmIChcbiAgICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJlxuICAgICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Rlc3QnXG4gICAgICApIHtcbiAgICAgICAgY29uc29sZVtjb25zb2xlLmluZm8gPyAnaW5mbycgOiAnbG9nJ10oXG4gICAgICAgICAgJ0Rvd25sb2FkIHRoZSBWdWUgRGV2dG9vbHMgZXh0ZW5zaW9uIGZvciBhIGJldHRlciBkZXZlbG9wbWVudCBleHBlcmllbmNlOlxcbicgK1xuICAgICAgICAgICdodHRwczovL2dpdGh1Yi5jb20vdnVlanMvdnVlLWRldnRvb2xzJ1xuICAgICAgICApO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJlxuICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICd0ZXN0JyAmJlxuICAgICAgY29uZmlnLnByb2R1Y3Rpb25UaXAgIT09IGZhbHNlICYmXG4gICAgICB0eXBlb2YgY29uc29sZSAhPT0gJ3VuZGVmaW5lZCdcbiAgICApIHtcbiAgICAgIGNvbnNvbGVbY29uc29sZS5pbmZvID8gJ2luZm8nIDogJ2xvZyddKFxuICAgICAgICBcIllvdSBhcmUgcnVubmluZyBWdWUgaW4gZGV2ZWxvcG1lbnQgbW9kZS5cXG5cIiArXG4gICAgICAgIFwiTWFrZSBzdXJlIHRvIHR1cm4gb24gcHJvZHVjdGlvbiBtb2RlIHdoZW4gZGVwbG95aW5nIGZvciBwcm9kdWN0aW9uLlxcblwiICtcbiAgICAgICAgXCJTZWUgbW9yZSB0aXBzIGF0IGh0dHBzOi8vdnVlanMub3JnL2d1aWRlL2RlcGxveW1lbnQuaHRtbFwiXG4gICAgICApO1xuICAgIH1cbiAgfSwgMCk7XG59XG5cbi8qICAqL1xuXG52YXIgZGVmYXVsdFRhZ1JFID0gL1xce1xceygoPzoufFxccj9cXG4pKz8pXFx9XFx9L2c7XG52YXIgcmVnZXhFc2NhcGVSRSA9IC9bLS4qKz9eJHt9KCl8W1xcXVxcL1xcXFxdL2c7XG5cbnZhciBidWlsZFJlZ2V4ID0gY2FjaGVkKGZ1bmN0aW9uIChkZWxpbWl0ZXJzKSB7XG4gIHZhciBvcGVuID0gZGVsaW1pdGVyc1swXS5yZXBsYWNlKHJlZ2V4RXNjYXBlUkUsICdcXFxcJCYnKTtcbiAgdmFyIGNsb3NlID0gZGVsaW1pdGVyc1sxXS5yZXBsYWNlKHJlZ2V4RXNjYXBlUkUsICdcXFxcJCYnKTtcbiAgcmV0dXJuIG5ldyBSZWdFeHAob3BlbiArICcoKD86LnxcXFxcbikrPyknICsgY2xvc2UsICdnJylcbn0pO1xuXG5cblxuZnVuY3Rpb24gcGFyc2VUZXh0IChcbiAgdGV4dCxcbiAgZGVsaW1pdGVyc1xuKSB7XG4gIHZhciB0YWdSRSA9IGRlbGltaXRlcnMgPyBidWlsZFJlZ2V4KGRlbGltaXRlcnMpIDogZGVmYXVsdFRhZ1JFO1xuICBpZiAoIXRhZ1JFLnRlc3QodGV4dCkpIHtcbiAgICByZXR1cm5cbiAgfVxuICB2YXIgdG9rZW5zID0gW107XG4gIHZhciByYXdUb2tlbnMgPSBbXTtcbiAgdmFyIGxhc3RJbmRleCA9IHRhZ1JFLmxhc3RJbmRleCA9IDA7XG4gIHZhciBtYXRjaCwgaW5kZXgsIHRva2VuVmFsdWU7XG4gIHdoaWxlICgobWF0Y2ggPSB0YWdSRS5leGVjKHRleHQpKSkge1xuICAgIGluZGV4ID0gbWF0Y2guaW5kZXg7XG4gICAgLy8gcHVzaCB0ZXh0IHRva2VuXG4gICAgaWYgKGluZGV4ID4gbGFzdEluZGV4KSB7XG4gICAgICByYXdUb2tlbnMucHVzaCh0b2tlblZhbHVlID0gdGV4dC5zbGljZShsYXN0SW5kZXgsIGluZGV4KSk7XG4gICAgICB0b2tlbnMucHVzaChKU09OLnN0cmluZ2lmeSh0b2tlblZhbHVlKSk7XG4gICAgfVxuICAgIC8vIHRhZyB0b2tlblxuICAgIHZhciBleHAgPSBwYXJzZUZpbHRlcnMobWF0Y2hbMV0udHJpbSgpKTtcbiAgICB0b2tlbnMucHVzaCgoXCJfcyhcIiArIGV4cCArIFwiKVwiKSk7XG4gICAgcmF3VG9rZW5zLnB1c2goeyAnQGJpbmRpbmcnOiBleHAgfSk7XG4gICAgbGFzdEluZGV4ID0gaW5kZXggKyBtYXRjaFswXS5sZW5ndGg7XG4gIH1cbiAgaWYgKGxhc3RJbmRleCA8IHRleHQubGVuZ3RoKSB7XG4gICAgcmF3VG9rZW5zLnB1c2godG9rZW5WYWx1ZSA9IHRleHQuc2xpY2UobGFzdEluZGV4KSk7XG4gICAgdG9rZW5zLnB1c2goSlNPTi5zdHJpbmdpZnkodG9rZW5WYWx1ZSkpO1xuICB9XG4gIHJldHVybiB7XG4gICAgZXhwcmVzc2lvbjogdG9rZW5zLmpvaW4oJysnKSxcbiAgICB0b2tlbnM6IHJhd1Rva2Vuc1xuICB9XG59XG5cbi8qICAqL1xuXG5mdW5jdGlvbiB0cmFuc2Zvcm1Ob2RlIChlbCwgb3B0aW9ucykge1xuICB2YXIgd2FybiA9IG9wdGlvbnMud2FybiB8fCBiYXNlV2FybjtcbiAgdmFyIHN0YXRpY0NsYXNzID0gZ2V0QW5kUmVtb3ZlQXR0cihlbCwgJ2NsYXNzJyk7XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIHN0YXRpY0NsYXNzKSB7XG4gICAgdmFyIHJlcyA9IHBhcnNlVGV4dChzdGF0aWNDbGFzcywgb3B0aW9ucy5kZWxpbWl0ZXJzKTtcbiAgICBpZiAocmVzKSB7XG4gICAgICB3YXJuKFxuICAgICAgICBcImNsYXNzPVxcXCJcIiArIHN0YXRpY0NsYXNzICsgXCJcXFwiOiBcIiArXG4gICAgICAgICdJbnRlcnBvbGF0aW9uIGluc2lkZSBhdHRyaWJ1dGVzIGhhcyBiZWVuIHJlbW92ZWQuICcgK1xuICAgICAgICAnVXNlIHYtYmluZCBvciB0aGUgY29sb24gc2hvcnRoYW5kIGluc3RlYWQuIEZvciBleGFtcGxlLCAnICtcbiAgICAgICAgJ2luc3RlYWQgb2YgPGRpdiBjbGFzcz1cInt7IHZhbCB9fVwiPiwgdXNlIDxkaXYgOmNsYXNzPVwidmFsXCI+LicsXG4gICAgICAgIGVsLnJhd0F0dHJzTWFwWydjbGFzcyddXG4gICAgICApO1xuICAgIH1cbiAgfVxuICBpZiAoc3RhdGljQ2xhc3MpIHtcbiAgICBlbC5zdGF0aWNDbGFzcyA9IEpTT04uc3RyaW5naWZ5KHN0YXRpY0NsYXNzKTtcbiAgfVxuICB2YXIgY2xhc3NCaW5kaW5nID0gZ2V0QmluZGluZ0F0dHIoZWwsICdjbGFzcycsIGZhbHNlIC8qIGdldFN0YXRpYyAqLyk7XG4gIGlmIChjbGFzc0JpbmRpbmcpIHtcbiAgICBlbC5jbGFzc0JpbmRpbmcgPSBjbGFzc0JpbmRpbmc7XG4gIH1cbn1cblxuZnVuY3Rpb24gZ2VuRGF0YSAoZWwpIHtcbiAgdmFyIGRhdGEgPSAnJztcbiAgaWYgKGVsLnN0YXRpY0NsYXNzKSB7XG4gICAgZGF0YSArPSBcInN0YXRpY0NsYXNzOlwiICsgKGVsLnN0YXRpY0NsYXNzKSArIFwiLFwiO1xuICB9XG4gIGlmIChlbC5jbGFzc0JpbmRpbmcpIHtcbiAgICBkYXRhICs9IFwiY2xhc3M6XCIgKyAoZWwuY2xhc3NCaW5kaW5nKSArIFwiLFwiO1xuICB9XG4gIHJldHVybiBkYXRhXG59XG5cbnZhciBrbGFzcyQxID0ge1xuICBzdGF0aWNLZXlzOiBbJ3N0YXRpY0NsYXNzJ10sXG4gIHRyYW5zZm9ybU5vZGU6IHRyYW5zZm9ybU5vZGUsXG4gIGdlbkRhdGE6IGdlbkRhdGFcbn07XG5cbi8qICAqL1xuXG5mdW5jdGlvbiB0cmFuc2Zvcm1Ob2RlJDEgKGVsLCBvcHRpb25zKSB7XG4gIHZhciB3YXJuID0gb3B0aW9ucy53YXJuIHx8IGJhc2VXYXJuO1xuICB2YXIgc3RhdGljU3R5bGUgPSBnZXRBbmRSZW1vdmVBdHRyKGVsLCAnc3R5bGUnKTtcbiAgaWYgKHN0YXRpY1N0eWxlKSB7XG4gICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIHZhciByZXMgPSBwYXJzZVRleHQoc3RhdGljU3R5bGUsIG9wdGlvbnMuZGVsaW1pdGVycyk7XG4gICAgICBpZiAocmVzKSB7XG4gICAgICAgIHdhcm4oXG4gICAgICAgICAgXCJzdHlsZT1cXFwiXCIgKyBzdGF0aWNTdHlsZSArIFwiXFxcIjogXCIgK1xuICAgICAgICAgICdJbnRlcnBvbGF0aW9uIGluc2lkZSBhdHRyaWJ1dGVzIGhhcyBiZWVuIHJlbW92ZWQuICcgK1xuICAgICAgICAgICdVc2Ugdi1iaW5kIG9yIHRoZSBjb2xvbiBzaG9ydGhhbmQgaW5zdGVhZC4gRm9yIGV4YW1wbGUsICcgK1xuICAgICAgICAgICdpbnN0ZWFkIG9mIDxkaXYgc3R5bGU9XCJ7eyB2YWwgfX1cIj4sIHVzZSA8ZGl2IDpzdHlsZT1cInZhbFwiPi4nLFxuICAgICAgICAgIGVsLnJhd0F0dHJzTWFwWydzdHlsZSddXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfVxuICAgIGVsLnN0YXRpY1N0eWxlID0gSlNPTi5zdHJpbmdpZnkocGFyc2VTdHlsZVRleHQoc3RhdGljU3R5bGUpKTtcbiAgfVxuXG4gIHZhciBzdHlsZUJpbmRpbmcgPSBnZXRCaW5kaW5nQXR0cihlbCwgJ3N0eWxlJywgZmFsc2UgLyogZ2V0U3RhdGljICovKTtcbiAgaWYgKHN0eWxlQmluZGluZykge1xuICAgIGVsLnN0eWxlQmluZGluZyA9IHN0eWxlQmluZGluZztcbiAgfVxufVxuXG5mdW5jdGlvbiBnZW5EYXRhJDEgKGVsKSB7XG4gIHZhciBkYXRhID0gJyc7XG4gIGlmIChlbC5zdGF0aWNTdHlsZSkge1xuICAgIGRhdGEgKz0gXCJzdGF0aWNTdHlsZTpcIiArIChlbC5zdGF0aWNTdHlsZSkgKyBcIixcIjtcbiAgfVxuICBpZiAoZWwuc3R5bGVCaW5kaW5nKSB7XG4gICAgZGF0YSArPSBcInN0eWxlOihcIiArIChlbC5zdHlsZUJpbmRpbmcpICsgXCIpLFwiO1xuICB9XG4gIHJldHVybiBkYXRhXG59XG5cbnZhciBzdHlsZSQxID0ge1xuICBzdGF0aWNLZXlzOiBbJ3N0YXRpY1N0eWxlJ10sXG4gIHRyYW5zZm9ybU5vZGU6IHRyYW5zZm9ybU5vZGUkMSxcbiAgZ2VuRGF0YTogZ2VuRGF0YSQxXG59O1xuXG4vKiAgKi9cblxudmFyIGRlY29kZXI7XG5cbnZhciBoZSA9IHtcbiAgZGVjb2RlOiBmdW5jdGlvbiBkZWNvZGUgKGh0bWwpIHtcbiAgICBkZWNvZGVyID0gZGVjb2RlciB8fCBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICBkZWNvZGVyLmlubmVySFRNTCA9IGh0bWw7XG4gICAgcmV0dXJuIGRlY29kZXIudGV4dENvbnRlbnRcbiAgfVxufTtcblxuLyogICovXG5cbnZhciBpc1VuYXJ5VGFnID0gbWFrZU1hcChcbiAgJ2FyZWEsYmFzZSxicixjb2wsZW1iZWQsZnJhbWUsaHIsaW1nLGlucHV0LGlzaW5kZXgsa2V5Z2VuLCcgK1xuICAnbGluayxtZXRhLHBhcmFtLHNvdXJjZSx0cmFjayx3YnInXG4pO1xuXG4vLyBFbGVtZW50cyB0aGF0IHlvdSBjYW4sIGludGVudGlvbmFsbHksIGxlYXZlIG9wZW5cbi8vIChhbmQgd2hpY2ggY2xvc2UgdGhlbXNlbHZlcylcbnZhciBjYW5CZUxlZnRPcGVuVGFnID0gbWFrZU1hcChcbiAgJ2NvbGdyb3VwLGRkLGR0LGxpLG9wdGlvbnMscCx0ZCx0Zm9vdCx0aCx0aGVhZCx0cixzb3VyY2UnXG4pO1xuXG4vLyBIVE1MNSB0YWdzIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL2luZGljZXMuaHRtbCNlbGVtZW50cy0zXG4vLyBQaHJhc2luZyBDb250ZW50IGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL2RvbS5odG1sI3BocmFzaW5nLWNvbnRlbnRcbnZhciBpc05vblBocmFzaW5nVGFnID0gbWFrZU1hcChcbiAgJ2FkZHJlc3MsYXJ0aWNsZSxhc2lkZSxiYXNlLGJsb2NrcXVvdGUsYm9keSxjYXB0aW9uLGNvbCxjb2xncm91cCxkZCwnICtcbiAgJ2RldGFpbHMsZGlhbG9nLGRpdixkbCxkdCxmaWVsZHNldCxmaWdjYXB0aW9uLGZpZ3VyZSxmb290ZXIsZm9ybSwnICtcbiAgJ2gxLGgyLGgzLGg0LGg1LGg2LGhlYWQsaGVhZGVyLGhncm91cCxocixodG1sLGxlZ2VuZCxsaSxtZW51aXRlbSxtZXRhLCcgK1xuICAnb3B0Z3JvdXAsb3B0aW9uLHBhcmFtLHJwLHJ0LHNvdXJjZSxzdHlsZSxzdW1tYXJ5LHRib2R5LHRkLHRmb290LHRoLHRoZWFkLCcgK1xuICAndGl0bGUsdHIsdHJhY2snXG4pO1xuXG4vKipcbiAqIE5vdCB0eXBlLWNoZWNraW5nIHRoaXMgZmlsZSBiZWNhdXNlIGl0J3MgbW9zdGx5IHZlbmRvciBjb2RlLlxuICovXG5cbi8vIFJlZ3VsYXIgRXhwcmVzc2lvbnMgZm9yIHBhcnNpbmcgdGFncyBhbmQgYXR0cmlidXRlc1xudmFyIGF0dHJpYnV0ZSA9IC9eXFxzKihbXlxcc1wiJzw+XFwvPV0rKSg/OlxccyooPSlcXHMqKD86XCIoW15cIl0qKVwiK3wnKFteJ10qKScrfChbXlxcc1wiJz08PmBdKykpKT8vO1xudmFyIGR5bmFtaWNBcmdBdHRyaWJ1dGUgPSAvXlxccyooKD86di1bXFx3LV0rOnxAfDp8IylcXFtbXj1dK1xcXVteXFxzXCInPD5cXC89XSopKD86XFxzKig9KVxccyooPzpcIihbXlwiXSopXCIrfCcoW14nXSopJyt8KFteXFxzXCInPTw+YF0rKSkpPy87XG52YXIgbmNuYW1lID0gXCJbYS16QS1aX11bXFxcXC1cXFxcLjAtOV9hLXpBLVpcIiArICh1bmljb2RlUmVnRXhwLnNvdXJjZSkgKyBcIl0qXCI7XG52YXIgcW5hbWVDYXB0dXJlID0gXCIoKD86XCIgKyBuY25hbWUgKyBcIlxcXFw6KT9cIiArIG5jbmFtZSArIFwiKVwiO1xudmFyIHN0YXJ0VGFnT3BlbiA9IG5ldyBSZWdFeHAoKFwiXjxcIiArIHFuYW1lQ2FwdHVyZSkpO1xudmFyIHN0YXJ0VGFnQ2xvc2UgPSAvXlxccyooXFwvPyk+LztcbnZhciBlbmRUYWcgPSBuZXcgUmVnRXhwKChcIl48XFxcXC9cIiArIHFuYW1lQ2FwdHVyZSArIFwiW14+XSo+XCIpKTtcbnZhciBkb2N0eXBlID0gL148IURPQ1RZUEUgW14+XSs+L2k7XG4vLyAjNzI5ODogZXNjYXBlIC0gdG8gYXZvaWQgYmVpbmcgcGFzZWQgYXMgSFRNTCBjb21tZW50IHdoZW4gaW5saW5lZCBpbiBwYWdlXG52YXIgY29tbWVudCA9IC9ePCFcXC0tLztcbnZhciBjb25kaXRpb25hbENvbW1lbnQgPSAvXjwhXFxbLztcblxuLy8gU3BlY2lhbCBFbGVtZW50cyAoY2FuIGNvbnRhaW4gYW55dGhpbmcpXG52YXIgaXNQbGFpblRleHRFbGVtZW50ID0gbWFrZU1hcCgnc2NyaXB0LHN0eWxlLHRleHRhcmVhJywgdHJ1ZSk7XG52YXIgcmVDYWNoZSA9IHt9O1xuXG52YXIgZGVjb2RpbmdNYXAgPSB7XG4gICcmbHQ7JzogJzwnLFxuICAnJmd0Oyc6ICc+JyxcbiAgJyZxdW90Oyc6ICdcIicsXG4gICcmYW1wOyc6ICcmJyxcbiAgJyYjMTA7JzogJ1xcbicsXG4gICcmIzk7JzogJ1xcdCcsXG4gICcmIzM5Oyc6IFwiJ1wiXG59O1xudmFyIGVuY29kZWRBdHRyID0gLyYoPzpsdHxndHxxdW90fGFtcHwjMzkpOy9nO1xudmFyIGVuY29kZWRBdHRyV2l0aE5ld0xpbmVzID0gLyYoPzpsdHxndHxxdW90fGFtcHwjMzl8IzEwfCM5KTsvZztcblxuLy8gIzU5OTJcbnZhciBpc0lnbm9yZU5ld2xpbmVUYWcgPSBtYWtlTWFwKCdwcmUsdGV4dGFyZWEnLCB0cnVlKTtcbnZhciBzaG91bGRJZ25vcmVGaXJzdE5ld2xpbmUgPSBmdW5jdGlvbiAodGFnLCBodG1sKSB7IHJldHVybiB0YWcgJiYgaXNJZ25vcmVOZXdsaW5lVGFnKHRhZykgJiYgaHRtbFswXSA9PT0gJ1xcbic7IH07XG5cbmZ1bmN0aW9uIGRlY29kZUF0dHIgKHZhbHVlLCBzaG91bGREZWNvZGVOZXdsaW5lcykge1xuICB2YXIgcmUgPSBzaG91bGREZWNvZGVOZXdsaW5lcyA/IGVuY29kZWRBdHRyV2l0aE5ld0xpbmVzIDogZW5jb2RlZEF0dHI7XG4gIHJldHVybiB2YWx1ZS5yZXBsYWNlKHJlLCBmdW5jdGlvbiAobWF0Y2gpIHsgcmV0dXJuIGRlY29kaW5nTWFwW21hdGNoXTsgfSlcbn1cblxuZnVuY3Rpb24gcGFyc2VIVE1MIChodG1sLCBvcHRpb25zKSB7XG4gIHZhciBzdGFjayA9IFtdO1xuICB2YXIgZXhwZWN0SFRNTCA9IG9wdGlvbnMuZXhwZWN0SFRNTDtcbiAgdmFyIGlzVW5hcnlUYWckJDEgPSBvcHRpb25zLmlzVW5hcnlUYWcgfHwgbm87XG4gIHZhciBjYW5CZUxlZnRPcGVuVGFnJCQxID0gb3B0aW9ucy5jYW5CZUxlZnRPcGVuVGFnIHx8IG5vO1xuICB2YXIgaW5kZXggPSAwO1xuICB2YXIgbGFzdCwgbGFzdFRhZztcbiAgd2hpbGUgKGh0bWwpIHtcbiAgICBsYXN0ID0gaHRtbDtcbiAgICAvLyBNYWtlIHN1cmUgd2UncmUgbm90IGluIGEgcGxhaW50ZXh0IGNvbnRlbnQgZWxlbWVudCBsaWtlIHNjcmlwdC9zdHlsZVxuICAgIGlmICghbGFzdFRhZyB8fCAhaXNQbGFpblRleHRFbGVtZW50KGxhc3RUYWcpKSB7XG4gICAgICB2YXIgdGV4dEVuZCA9IGh0bWwuaW5kZXhPZignPCcpO1xuICAgICAgaWYgKHRleHRFbmQgPT09IDApIHtcbiAgICAgICAgLy8gQ29tbWVudDpcbiAgICAgICAgaWYgKGNvbW1lbnQudGVzdChodG1sKSkge1xuICAgICAgICAgIHZhciBjb21tZW50RW5kID0gaHRtbC5pbmRleE9mKCctLT4nKTtcblxuICAgICAgICAgIGlmIChjb21tZW50RW5kID49IDApIHtcbiAgICAgICAgICAgIGlmIChvcHRpb25zLnNob3VsZEtlZXBDb21tZW50KSB7XG4gICAgICAgICAgICAgIG9wdGlvbnMuY29tbWVudChodG1sLnN1YnN0cmluZyg0LCBjb21tZW50RW5kKSwgaW5kZXgsIGluZGV4ICsgY29tbWVudEVuZCArIDMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYWR2YW5jZShjb21tZW50RW5kICsgMyk7XG4gICAgICAgICAgICBjb250aW51ZVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGh0dHA6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvQ29uZGl0aW9uYWxfY29tbWVudCNEb3dubGV2ZWwtcmV2ZWFsZWRfY29uZGl0aW9uYWxfY29tbWVudFxuICAgICAgICBpZiAoY29uZGl0aW9uYWxDb21tZW50LnRlc3QoaHRtbCkpIHtcbiAgICAgICAgICB2YXIgY29uZGl0aW9uYWxFbmQgPSBodG1sLmluZGV4T2YoJ10+Jyk7XG5cbiAgICAgICAgICBpZiAoY29uZGl0aW9uYWxFbmQgPj0gMCkge1xuICAgICAgICAgICAgYWR2YW5jZShjb25kaXRpb25hbEVuZCArIDIpO1xuICAgICAgICAgICAgY29udGludWVcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBEb2N0eXBlOlxuICAgICAgICB2YXIgZG9jdHlwZU1hdGNoID0gaHRtbC5tYXRjaChkb2N0eXBlKTtcbiAgICAgICAgaWYgKGRvY3R5cGVNYXRjaCkge1xuICAgICAgICAgIGFkdmFuY2UoZG9jdHlwZU1hdGNoWzBdLmxlbmd0aCk7XG4gICAgICAgICAgY29udGludWVcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEVuZCB0YWc6XG4gICAgICAgIHZhciBlbmRUYWdNYXRjaCA9IGh0bWwubWF0Y2goZW5kVGFnKTtcbiAgICAgICAgaWYgKGVuZFRhZ01hdGNoKSB7XG4gICAgICAgICAgdmFyIGN1ckluZGV4ID0gaW5kZXg7XG4gICAgICAgICAgYWR2YW5jZShlbmRUYWdNYXRjaFswXS5sZW5ndGgpO1xuICAgICAgICAgIHBhcnNlRW5kVGFnKGVuZFRhZ01hdGNoWzFdLCBjdXJJbmRleCwgaW5kZXgpO1xuICAgICAgICAgIGNvbnRpbnVlXG4gICAgICAgIH1cblxuICAgICAgICAvLyBTdGFydCB0YWc6XG4gICAgICAgIHZhciBzdGFydFRhZ01hdGNoID0gcGFyc2VTdGFydFRhZygpO1xuICAgICAgICBpZiAoc3RhcnRUYWdNYXRjaCkge1xuICAgICAgICAgIGhhbmRsZVN0YXJ0VGFnKHN0YXJ0VGFnTWF0Y2gpO1xuICAgICAgICAgIGlmIChzaG91bGRJZ25vcmVGaXJzdE5ld2xpbmUoc3RhcnRUYWdNYXRjaC50YWdOYW1lLCBodG1sKSkge1xuICAgICAgICAgICAgYWR2YW5jZSgxKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgY29udGludWVcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB2YXIgdGV4dCA9ICh2b2lkIDApLCByZXN0ID0gKHZvaWQgMCksIG5leHQgPSAodm9pZCAwKTtcbiAgICAgIGlmICh0ZXh0RW5kID49IDApIHtcbiAgICAgICAgcmVzdCA9IGh0bWwuc2xpY2UodGV4dEVuZCk7XG4gICAgICAgIHdoaWxlIChcbiAgICAgICAgICAhZW5kVGFnLnRlc3QocmVzdCkgJiZcbiAgICAgICAgICAhc3RhcnRUYWdPcGVuLnRlc3QocmVzdCkgJiZcbiAgICAgICAgICAhY29tbWVudC50ZXN0KHJlc3QpICYmXG4gICAgICAgICAgIWNvbmRpdGlvbmFsQ29tbWVudC50ZXN0KHJlc3QpXG4gICAgICAgICkge1xuICAgICAgICAgIC8vIDwgaW4gcGxhaW4gdGV4dCwgYmUgZm9yZ2l2aW5nIGFuZCB0cmVhdCBpdCBhcyB0ZXh0XG4gICAgICAgICAgbmV4dCA9IHJlc3QuaW5kZXhPZignPCcsIDEpO1xuICAgICAgICAgIGlmIChuZXh0IDwgMCkgeyBicmVhayB9XG4gICAgICAgICAgdGV4dEVuZCArPSBuZXh0O1xuICAgICAgICAgIHJlc3QgPSBodG1sLnNsaWNlKHRleHRFbmQpO1xuICAgICAgICB9XG4gICAgICAgIHRleHQgPSBodG1sLnN1YnN0cmluZygwLCB0ZXh0RW5kKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHRleHRFbmQgPCAwKSB7XG4gICAgICAgIHRleHQgPSBodG1sO1xuICAgICAgfVxuXG4gICAgICBpZiAodGV4dCkge1xuICAgICAgICBhZHZhbmNlKHRleHQubGVuZ3RoKTtcbiAgICAgIH1cblxuICAgICAgaWYgKG9wdGlvbnMuY2hhcnMgJiYgdGV4dCkge1xuICAgICAgICBvcHRpb25zLmNoYXJzKHRleHQsIGluZGV4IC0gdGV4dC5sZW5ndGgsIGluZGV4KTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIGVuZFRhZ0xlbmd0aCA9IDA7XG4gICAgICB2YXIgc3RhY2tlZFRhZyA9IGxhc3RUYWcudG9Mb3dlckNhc2UoKTtcbiAgICAgIHZhciByZVN0YWNrZWRUYWcgPSByZUNhY2hlW3N0YWNrZWRUYWddIHx8IChyZUNhY2hlW3N0YWNrZWRUYWddID0gbmV3IFJlZ0V4cCgnKFtcXFxcc1xcXFxTXSo/KSg8LycgKyBzdGFja2VkVGFnICsgJ1tePl0qPiknLCAnaScpKTtcbiAgICAgIHZhciByZXN0JDEgPSBodG1sLnJlcGxhY2UocmVTdGFja2VkVGFnLCBmdW5jdGlvbiAoYWxsLCB0ZXh0LCBlbmRUYWcpIHtcbiAgICAgICAgZW5kVGFnTGVuZ3RoID0gZW5kVGFnLmxlbmd0aDtcbiAgICAgICAgaWYgKCFpc1BsYWluVGV4dEVsZW1lbnQoc3RhY2tlZFRhZykgJiYgc3RhY2tlZFRhZyAhPT0gJ25vc2NyaXB0Jykge1xuICAgICAgICAgIHRleHQgPSB0ZXh0XG4gICAgICAgICAgICAucmVwbGFjZSgvPCFcXC0tKFtcXHNcXFNdKj8pLS0+L2csICckMScpIC8vICM3Mjk4XG4gICAgICAgICAgICAucmVwbGFjZSgvPCFcXFtDREFUQVxcWyhbXFxzXFxTXSo/KV1dPi9nLCAnJDEnKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc2hvdWxkSWdub3JlRmlyc3ROZXdsaW5lKHN0YWNrZWRUYWcsIHRleHQpKSB7XG4gICAgICAgICAgdGV4dCA9IHRleHQuc2xpY2UoMSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9wdGlvbnMuY2hhcnMpIHtcbiAgICAgICAgICBvcHRpb25zLmNoYXJzKHRleHQpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAnJ1xuICAgICAgfSk7XG4gICAgICBpbmRleCArPSBodG1sLmxlbmd0aCAtIHJlc3QkMS5sZW5ndGg7XG4gICAgICBodG1sID0gcmVzdCQxO1xuICAgICAgcGFyc2VFbmRUYWcoc3RhY2tlZFRhZywgaW5kZXggLSBlbmRUYWdMZW5ndGgsIGluZGV4KTtcbiAgICB9XG5cbiAgICBpZiAoaHRtbCA9PT0gbGFzdCkge1xuICAgICAgb3B0aW9ucy5jaGFycyAmJiBvcHRpb25zLmNoYXJzKGh0bWwpO1xuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgIXN0YWNrLmxlbmd0aCAmJiBvcHRpb25zLndhcm4pIHtcbiAgICAgICAgb3B0aW9ucy53YXJuKChcIk1hbC1mb3JtYXR0ZWQgdGFnIGF0IGVuZCBvZiB0ZW1wbGF0ZTogXFxcIlwiICsgaHRtbCArIFwiXFxcIlwiKSwgeyBzdGFydDogaW5kZXggKyBodG1sLmxlbmd0aCB9KTtcbiAgICAgIH1cbiAgICAgIGJyZWFrXG4gICAgfVxuICB9XG5cbiAgLy8gQ2xlYW4gdXAgYW55IHJlbWFpbmluZyB0YWdzXG4gIHBhcnNlRW5kVGFnKCk7XG5cbiAgZnVuY3Rpb24gYWR2YW5jZSAobikge1xuICAgIGluZGV4ICs9IG47XG4gICAgaHRtbCA9IGh0bWwuc3Vic3RyaW5nKG4pO1xuICB9XG5cbiAgZnVuY3Rpb24gcGFyc2VTdGFydFRhZyAoKSB7XG4gICAgdmFyIHN0YXJ0ID0gaHRtbC5tYXRjaChzdGFydFRhZ09wZW4pO1xuICAgIGlmIChzdGFydCkge1xuICAgICAgdmFyIG1hdGNoID0ge1xuICAgICAgICB0YWdOYW1lOiBzdGFydFsxXSxcbiAgICAgICAgYXR0cnM6IFtdLFxuICAgICAgICBzdGFydDogaW5kZXhcbiAgICAgIH07XG4gICAgICBhZHZhbmNlKHN0YXJ0WzBdLmxlbmd0aCk7XG4gICAgICB2YXIgZW5kLCBhdHRyO1xuICAgICAgd2hpbGUgKCEoZW5kID0gaHRtbC5tYXRjaChzdGFydFRhZ0Nsb3NlKSkgJiYgKGF0dHIgPSBodG1sLm1hdGNoKGR5bmFtaWNBcmdBdHRyaWJ1dGUpIHx8IGh0bWwubWF0Y2goYXR0cmlidXRlKSkpIHtcbiAgICAgICAgYXR0ci5zdGFydCA9IGluZGV4O1xuICAgICAgICBhZHZhbmNlKGF0dHJbMF0ubGVuZ3RoKTtcbiAgICAgICAgYXR0ci5lbmQgPSBpbmRleDtcbiAgICAgICAgbWF0Y2guYXR0cnMucHVzaChhdHRyKTtcbiAgICAgIH1cbiAgICAgIGlmIChlbmQpIHtcbiAgICAgICAgbWF0Y2gudW5hcnlTbGFzaCA9IGVuZFsxXTtcbiAgICAgICAgYWR2YW5jZShlbmRbMF0ubGVuZ3RoKTtcbiAgICAgICAgbWF0Y2guZW5kID0gaW5kZXg7XG4gICAgICAgIHJldHVybiBtYXRjaFxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGhhbmRsZVN0YXJ0VGFnIChtYXRjaCkge1xuICAgIHZhciB0YWdOYW1lID0gbWF0Y2gudGFnTmFtZTtcbiAgICB2YXIgdW5hcnlTbGFzaCA9IG1hdGNoLnVuYXJ5U2xhc2g7XG5cbiAgICBpZiAoZXhwZWN0SFRNTCkge1xuICAgICAgaWYgKGxhc3RUYWcgPT09ICdwJyAmJiBpc05vblBocmFzaW5nVGFnKHRhZ05hbWUpKSB7XG4gICAgICAgIHBhcnNlRW5kVGFnKGxhc3RUYWcpO1xuICAgICAgfVxuICAgICAgaWYgKGNhbkJlTGVmdE9wZW5UYWckJDEodGFnTmFtZSkgJiYgbGFzdFRhZyA9PT0gdGFnTmFtZSkge1xuICAgICAgICBwYXJzZUVuZFRhZyh0YWdOYW1lKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgdW5hcnkgPSBpc1VuYXJ5VGFnJCQxKHRhZ05hbWUpIHx8ICEhdW5hcnlTbGFzaDtcblxuICAgIHZhciBsID0gbWF0Y2guYXR0cnMubGVuZ3RoO1xuICAgIHZhciBhdHRycyA9IG5ldyBBcnJheShsKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGw7IGkrKykge1xuICAgICAgdmFyIGFyZ3MgPSBtYXRjaC5hdHRyc1tpXTtcbiAgICAgIHZhciB2YWx1ZSA9IGFyZ3NbM10gfHwgYXJnc1s0XSB8fCBhcmdzWzVdIHx8ICcnO1xuICAgICAgdmFyIHNob3VsZERlY29kZU5ld2xpbmVzID0gdGFnTmFtZSA9PT0gJ2EnICYmIGFyZ3NbMV0gPT09ICdocmVmJ1xuICAgICAgICA/IG9wdGlvbnMuc2hvdWxkRGVjb2RlTmV3bGluZXNGb3JIcmVmXG4gICAgICAgIDogb3B0aW9ucy5zaG91bGREZWNvZGVOZXdsaW5lcztcbiAgICAgIGF0dHJzW2ldID0ge1xuICAgICAgICBuYW1lOiBhcmdzWzFdLFxuICAgICAgICB2YWx1ZTogZGVjb2RlQXR0cih2YWx1ZSwgc2hvdWxkRGVjb2RlTmV3bGluZXMpXG4gICAgICB9O1xuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgb3B0aW9ucy5vdXRwdXRTb3VyY2VSYW5nZSkge1xuICAgICAgICBhdHRyc1tpXS5zdGFydCA9IGFyZ3Muc3RhcnQgKyBhcmdzWzBdLm1hdGNoKC9eXFxzKi8pLmxlbmd0aDtcbiAgICAgICAgYXR0cnNbaV0uZW5kID0gYXJncy5lbmQ7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKCF1bmFyeSkge1xuICAgICAgc3RhY2sucHVzaCh7IHRhZzogdGFnTmFtZSwgbG93ZXJDYXNlZFRhZzogdGFnTmFtZS50b0xvd2VyQ2FzZSgpLCBhdHRyczogYXR0cnMsIHN0YXJ0OiBtYXRjaC5zdGFydCwgZW5kOiBtYXRjaC5lbmQgfSk7XG4gICAgICBsYXN0VGFnID0gdGFnTmFtZTtcbiAgICB9XG5cbiAgICBpZiAob3B0aW9ucy5zdGFydCkge1xuICAgICAgb3B0aW9ucy5zdGFydCh0YWdOYW1lLCBhdHRycywgdW5hcnksIG1hdGNoLnN0YXJ0LCBtYXRjaC5lbmQpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHBhcnNlRW5kVGFnICh0YWdOYW1lLCBzdGFydCwgZW5kKSB7XG4gICAgdmFyIHBvcywgbG93ZXJDYXNlZFRhZ05hbWU7XG4gICAgaWYgKHN0YXJ0ID09IG51bGwpIHsgc3RhcnQgPSBpbmRleDsgfVxuICAgIGlmIChlbmQgPT0gbnVsbCkgeyBlbmQgPSBpbmRleDsgfVxuXG4gICAgLy8gRmluZCB0aGUgY2xvc2VzdCBvcGVuZWQgdGFnIG9mIHRoZSBzYW1lIHR5cGVcbiAgICBpZiAodGFnTmFtZSkge1xuICAgICAgbG93ZXJDYXNlZFRhZ05hbWUgPSB0YWdOYW1lLnRvTG93ZXJDYXNlKCk7XG4gICAgICBmb3IgKHBvcyA9IHN0YWNrLmxlbmd0aCAtIDE7IHBvcyA+PSAwOyBwb3MtLSkge1xuICAgICAgICBpZiAoc3RhY2tbcG9zXS5sb3dlckNhc2VkVGFnID09PSBsb3dlckNhc2VkVGFnTmFtZSkge1xuICAgICAgICAgIGJyZWFrXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgLy8gSWYgbm8gdGFnIG5hbWUgaXMgcHJvdmlkZWQsIGNsZWFuIHNob3BcbiAgICAgIHBvcyA9IDA7XG4gICAgfVxuXG4gICAgaWYgKHBvcyA+PSAwKSB7XG4gICAgICAvLyBDbG9zZSBhbGwgdGhlIG9wZW4gZWxlbWVudHMsIHVwIHRoZSBzdGFja1xuICAgICAgZm9yICh2YXIgaSA9IHN0YWNrLmxlbmd0aCAtIDE7IGkgPj0gcG9zOyBpLS0pIHtcbiAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiZcbiAgICAgICAgICAoaSA+IHBvcyB8fCAhdGFnTmFtZSkgJiZcbiAgICAgICAgICBvcHRpb25zLndhcm5cbiAgICAgICAgKSB7XG4gICAgICAgICAgb3B0aW9ucy53YXJuKFxuICAgICAgICAgICAgKFwidGFnIDxcIiArIChzdGFja1tpXS50YWcpICsgXCI+IGhhcyBubyBtYXRjaGluZyBlbmQgdGFnLlwiKSxcbiAgICAgICAgICAgIHsgc3RhcnQ6IHN0YWNrW2ldLnN0YXJ0LCBlbmQ6IHN0YWNrW2ldLmVuZCB9XG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAob3B0aW9ucy5lbmQpIHtcbiAgICAgICAgICBvcHRpb25zLmVuZChzdGFja1tpXS50YWcsIHN0YXJ0LCBlbmQpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIFJlbW92ZSB0aGUgb3BlbiBlbGVtZW50cyBmcm9tIHRoZSBzdGFja1xuICAgICAgc3RhY2subGVuZ3RoID0gcG9zO1xuICAgICAgbGFzdFRhZyA9IHBvcyAmJiBzdGFja1twb3MgLSAxXS50YWc7XG4gICAgfSBlbHNlIGlmIChsb3dlckNhc2VkVGFnTmFtZSA9PT0gJ2JyJykge1xuICAgICAgaWYgKG9wdGlvbnMuc3RhcnQpIHtcbiAgICAgICAgb3B0aW9ucy5zdGFydCh0YWdOYW1lLCBbXSwgdHJ1ZSwgc3RhcnQsIGVuZCk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChsb3dlckNhc2VkVGFnTmFtZSA9PT0gJ3AnKSB7XG4gICAgICBpZiAob3B0aW9ucy5zdGFydCkge1xuICAgICAgICBvcHRpb25zLnN0YXJ0KHRhZ05hbWUsIFtdLCBmYWxzZSwgc3RhcnQsIGVuZCk7XG4gICAgICB9XG4gICAgICBpZiAob3B0aW9ucy5lbmQpIHtcbiAgICAgICAgb3B0aW9ucy5lbmQodGFnTmFtZSwgc3RhcnQsIGVuZCk7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbi8qICAqL1xuXG52YXIgb25SRSA9IC9eQHxedi1vbjovO1xudmFyIGRpclJFID0gL152LXxeQHxeOi87XG52YXIgZm9yQWxpYXNSRSA9IC8oW1xcc1xcU10qPylcXHMrKD86aW58b2YpXFxzKyhbXFxzXFxTXSopLztcbnZhciBmb3JJdGVyYXRvclJFID0gLywoW14sXFx9XFxdXSopKD86LChbXixcXH1cXF1dKikpPyQvO1xudmFyIHN0cmlwUGFyZW5zUkUgPSAvXlxcKHxcXCkkL2c7XG52YXIgZHluYW1pY0FyZ1JFID0gL15cXFsuKlxcXSQvO1xuXG52YXIgYXJnUkUgPSAvOiguKikkLztcbnZhciBiaW5kUkUgPSAvXjp8XlxcLnxedi1iaW5kOi87XG52YXIgbW9kaWZpZXJSRSA9IC9cXC5bXi5cXF1dKyg/PVteXFxdXSokKS9nO1xuXG52YXIgc2xvdFJFID0gL152LXNsb3QoOnwkKXxeIy87XG5cbnZhciBsaW5lQnJlYWtSRSA9IC9bXFxyXFxuXS87XG52YXIgd2hpdGVzcGFjZVJFJDEgPSAvXFxzKy9nO1xuXG52YXIgaW52YWxpZEF0dHJpYnV0ZVJFID0gL1tcXHNcIic8PlxcLz1dLztcblxudmFyIGRlY29kZUhUTUxDYWNoZWQgPSBjYWNoZWQoaGUuZGVjb2RlKTtcblxudmFyIGVtcHR5U2xvdFNjb3BlVG9rZW4gPSBcIl9lbXB0eV9cIjtcblxuLy8gY29uZmlndXJhYmxlIHN0YXRlXG52YXIgd2FybiQyO1xudmFyIGRlbGltaXRlcnM7XG52YXIgdHJhbnNmb3JtcztcbnZhciBwcmVUcmFuc2Zvcm1zO1xudmFyIHBvc3RUcmFuc2Zvcm1zO1xudmFyIHBsYXRmb3JtSXNQcmVUYWc7XG52YXIgcGxhdGZvcm1NdXN0VXNlUHJvcDtcbnZhciBwbGF0Zm9ybUdldFRhZ05hbWVzcGFjZTtcbnZhciBtYXliZUNvbXBvbmVudDtcblxuZnVuY3Rpb24gY3JlYXRlQVNURWxlbWVudCAoXG4gIHRhZyxcbiAgYXR0cnMsXG4gIHBhcmVudFxuKSB7XG4gIHJldHVybiB7XG4gICAgdHlwZTogMSxcbiAgICB0YWc6IHRhZyxcbiAgICBhdHRyc0xpc3Q6IGF0dHJzLFxuICAgIGF0dHJzTWFwOiBtYWtlQXR0cnNNYXAoYXR0cnMpLFxuICAgIHJhd0F0dHJzTWFwOiB7fSxcbiAgICBwYXJlbnQ6IHBhcmVudCxcbiAgICBjaGlsZHJlbjogW11cbiAgfVxufVxuXG4vKipcbiAqIENvbnZlcnQgSFRNTCBzdHJpbmcgdG8gQVNULlxuICovXG5mdW5jdGlvbiBwYXJzZSAoXG4gIHRlbXBsYXRlLFxuICBvcHRpb25zXG4pIHtcbiAgd2FybiQyID0gb3B0aW9ucy53YXJuIHx8IGJhc2VXYXJuO1xuXG4gIHBsYXRmb3JtSXNQcmVUYWcgPSBvcHRpb25zLmlzUHJlVGFnIHx8IG5vO1xuICBwbGF0Zm9ybU11c3RVc2VQcm9wID0gb3B0aW9ucy5tdXN0VXNlUHJvcCB8fCBubztcbiAgcGxhdGZvcm1HZXRUYWdOYW1lc3BhY2UgPSBvcHRpb25zLmdldFRhZ05hbWVzcGFjZSB8fCBubztcbiAgdmFyIGlzUmVzZXJ2ZWRUYWcgPSBvcHRpb25zLmlzUmVzZXJ2ZWRUYWcgfHwgbm87XG4gIG1heWJlQ29tcG9uZW50ID0gZnVuY3Rpb24gKGVsKSB7IHJldHVybiAhIWVsLmNvbXBvbmVudCB8fCAhaXNSZXNlcnZlZFRhZyhlbC50YWcpOyB9O1xuXG4gIHRyYW5zZm9ybXMgPSBwbHVja01vZHVsZUZ1bmN0aW9uKG9wdGlvbnMubW9kdWxlcywgJ3RyYW5zZm9ybU5vZGUnKTtcbiAgcHJlVHJhbnNmb3JtcyA9IHBsdWNrTW9kdWxlRnVuY3Rpb24ob3B0aW9ucy5tb2R1bGVzLCAncHJlVHJhbnNmb3JtTm9kZScpO1xuICBwb3N0VHJhbnNmb3JtcyA9IHBsdWNrTW9kdWxlRnVuY3Rpb24ob3B0aW9ucy5tb2R1bGVzLCAncG9zdFRyYW5zZm9ybU5vZGUnKTtcblxuICBkZWxpbWl0ZXJzID0gb3B0aW9ucy5kZWxpbWl0ZXJzO1xuXG4gIHZhciBzdGFjayA9IFtdO1xuICB2YXIgcHJlc2VydmVXaGl0ZXNwYWNlID0gb3B0aW9ucy5wcmVzZXJ2ZVdoaXRlc3BhY2UgIT09IGZhbHNlO1xuICB2YXIgd2hpdGVzcGFjZU9wdGlvbiA9IG9wdGlvbnMud2hpdGVzcGFjZTtcbiAgdmFyIHJvb3Q7XG4gIHZhciBjdXJyZW50UGFyZW50O1xuICB2YXIgaW5WUHJlID0gZmFsc2U7XG4gIHZhciBpblByZSA9IGZhbHNlO1xuICB2YXIgd2FybmVkID0gZmFsc2U7XG5cbiAgZnVuY3Rpb24gd2Fybk9uY2UgKG1zZywgcmFuZ2UpIHtcbiAgICBpZiAoIXdhcm5lZCkge1xuICAgICAgd2FybmVkID0gdHJ1ZTtcbiAgICAgIHdhcm4kMihtc2csIHJhbmdlKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBjbG9zZUVsZW1lbnQgKGVsZW1lbnQpIHtcbiAgICB0cmltRW5kaW5nV2hpdGVzcGFjZShlbGVtZW50KTtcbiAgICBpZiAoIWluVlByZSAmJiAhZWxlbWVudC5wcm9jZXNzZWQpIHtcbiAgICAgIGVsZW1lbnQgPSBwcm9jZXNzRWxlbWVudChlbGVtZW50LCBvcHRpb25zKTtcbiAgICB9XG4gICAgLy8gdHJlZSBtYW5hZ2VtZW50XG4gICAgaWYgKCFzdGFjay5sZW5ndGggJiYgZWxlbWVudCAhPT0gcm9vdCkge1xuICAgICAgLy8gYWxsb3cgcm9vdCBlbGVtZW50cyB3aXRoIHYtaWYsIHYtZWxzZS1pZiBhbmQgdi1lbHNlXG4gICAgICBpZiAocm9vdC5pZiAmJiAoZWxlbWVudC5lbHNlaWYgfHwgZWxlbWVudC5lbHNlKSkge1xuICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICAgIGNoZWNrUm9vdENvbnN0cmFpbnRzKGVsZW1lbnQpO1xuICAgICAgICB9XG4gICAgICAgIGFkZElmQ29uZGl0aW9uKHJvb3QsIHtcbiAgICAgICAgICBleHA6IGVsZW1lbnQuZWxzZWlmLFxuICAgICAgICAgIGJsb2NrOiBlbGVtZW50XG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgIHdhcm5PbmNlKFxuICAgICAgICAgIFwiQ29tcG9uZW50IHRlbXBsYXRlIHNob3VsZCBjb250YWluIGV4YWN0bHkgb25lIHJvb3QgZWxlbWVudC4gXCIgK1xuICAgICAgICAgIFwiSWYgeW91IGFyZSB1c2luZyB2LWlmIG9uIG11bHRpcGxlIGVsZW1lbnRzLCBcIiArXG4gICAgICAgICAgXCJ1c2Ugdi1lbHNlLWlmIHRvIGNoYWluIHRoZW0gaW5zdGVhZC5cIixcbiAgICAgICAgICB7IHN0YXJ0OiBlbGVtZW50LnN0YXJ0IH1cbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGN1cnJlbnRQYXJlbnQgJiYgIWVsZW1lbnQuZm9yYmlkZGVuKSB7XG4gICAgICBpZiAoZWxlbWVudC5lbHNlaWYgfHwgZWxlbWVudC5lbHNlKSB7XG4gICAgICAgIHByb2Nlc3NJZkNvbmRpdGlvbnMoZWxlbWVudCwgY3VycmVudFBhcmVudCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoZWxlbWVudC5zbG90U2NvcGUpIHtcbiAgICAgICAgICAvLyBzY29wZWQgc2xvdFxuICAgICAgICAgIC8vIGtlZXAgaXQgaW4gdGhlIGNoaWxkcmVuIGxpc3Qgc28gdGhhdCB2LWVsc2UoLWlmKSBjb25kaXRpb25zIGNhblxuICAgICAgICAgIC8vIGZpbmQgaXQgYXMgdGhlIHByZXYgbm9kZS5cbiAgICAgICAgICB2YXIgbmFtZSA9IGVsZW1lbnQuc2xvdFRhcmdldCB8fCAnXCJkZWZhdWx0XCInXG4gICAgICAgICAgOyhjdXJyZW50UGFyZW50LnNjb3BlZFNsb3RzIHx8IChjdXJyZW50UGFyZW50LnNjb3BlZFNsb3RzID0ge30pKVtuYW1lXSA9IGVsZW1lbnQ7XG4gICAgICAgIH1cbiAgICAgICAgY3VycmVudFBhcmVudC5jaGlsZHJlbi5wdXNoKGVsZW1lbnQpO1xuICAgICAgICBlbGVtZW50LnBhcmVudCA9IGN1cnJlbnRQYXJlbnQ7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gZmluYWwgY2hpbGRyZW4gY2xlYW51cFxuICAgIC8vIGZpbHRlciBvdXQgc2NvcGVkIHNsb3RzXG4gICAgZWxlbWVudC5jaGlsZHJlbiA9IGVsZW1lbnQuY2hpbGRyZW4uZmlsdGVyKGZ1bmN0aW9uIChjKSB7IHJldHVybiAhKGMpLnNsb3RTY29wZTsgfSk7XG4gICAgLy8gcmVtb3ZlIHRyYWlsaW5nIHdoaXRlc3BhY2Ugbm9kZSBhZ2FpblxuICAgIHRyaW1FbmRpbmdXaGl0ZXNwYWNlKGVsZW1lbnQpO1xuXG4gICAgLy8gY2hlY2sgcHJlIHN0YXRlXG4gICAgaWYgKGVsZW1lbnQucHJlKSB7XG4gICAgICBpblZQcmUgPSBmYWxzZTtcbiAgICB9XG4gICAgaWYgKHBsYXRmb3JtSXNQcmVUYWcoZWxlbWVudC50YWcpKSB7XG4gICAgICBpblByZSA9IGZhbHNlO1xuICAgIH1cbiAgICAvLyBhcHBseSBwb3N0LXRyYW5zZm9ybXNcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHBvc3RUcmFuc2Zvcm1zLmxlbmd0aDsgaSsrKSB7XG4gICAgICBwb3N0VHJhbnNmb3Jtc1tpXShlbGVtZW50LCBvcHRpb25zKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiB0cmltRW5kaW5nV2hpdGVzcGFjZSAoZWwpIHtcbiAgICAvLyByZW1vdmUgdHJhaWxpbmcgd2hpdGVzcGFjZSBub2RlXG4gICAgaWYgKCFpblByZSkge1xuICAgICAgdmFyIGxhc3ROb2RlO1xuICAgICAgd2hpbGUgKFxuICAgICAgICAobGFzdE5vZGUgPSBlbC5jaGlsZHJlbltlbC5jaGlsZHJlbi5sZW5ndGggLSAxXSkgJiZcbiAgICAgICAgbGFzdE5vZGUudHlwZSA9PT0gMyAmJlxuICAgICAgICBsYXN0Tm9kZS50ZXh0ID09PSAnICdcbiAgICAgICkge1xuICAgICAgICBlbC5jaGlsZHJlbi5wb3AoKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBjaGVja1Jvb3RDb25zdHJhaW50cyAoZWwpIHtcbiAgICBpZiAoZWwudGFnID09PSAnc2xvdCcgfHwgZWwudGFnID09PSAndGVtcGxhdGUnKSB7XG4gICAgICB3YXJuT25jZShcbiAgICAgICAgXCJDYW5ub3QgdXNlIDxcIiArIChlbC50YWcpICsgXCI+IGFzIGNvbXBvbmVudCByb290IGVsZW1lbnQgYmVjYXVzZSBpdCBtYXkgXCIgK1xuICAgICAgICAnY29udGFpbiBtdWx0aXBsZSBub2Rlcy4nLFxuICAgICAgICB7IHN0YXJ0OiBlbC5zdGFydCB9XG4gICAgICApO1xuICAgIH1cbiAgICBpZiAoZWwuYXR0cnNNYXAuaGFzT3duUHJvcGVydHkoJ3YtZm9yJykpIHtcbiAgICAgIHdhcm5PbmNlKFxuICAgICAgICAnQ2Fubm90IHVzZSB2LWZvciBvbiBzdGF0ZWZ1bCBjb21wb25lbnQgcm9vdCBlbGVtZW50IGJlY2F1c2UgJyArXG4gICAgICAgICdpdCByZW5kZXJzIG11bHRpcGxlIGVsZW1lbnRzLicsXG4gICAgICAgIGVsLnJhd0F0dHJzTWFwWyd2LWZvciddXG4gICAgICApO1xuICAgIH1cbiAgfVxuXG4gIHBhcnNlSFRNTCh0ZW1wbGF0ZSwge1xuICAgIHdhcm46IHdhcm4kMixcbiAgICBleHBlY3RIVE1MOiBvcHRpb25zLmV4cGVjdEhUTUwsXG4gICAgaXNVbmFyeVRhZzogb3B0aW9ucy5pc1VuYXJ5VGFnLFxuICAgIGNhbkJlTGVmdE9wZW5UYWc6IG9wdGlvbnMuY2FuQmVMZWZ0T3BlblRhZyxcbiAgICBzaG91bGREZWNvZGVOZXdsaW5lczogb3B0aW9ucy5zaG91bGREZWNvZGVOZXdsaW5lcyxcbiAgICBzaG91bGREZWNvZGVOZXdsaW5lc0ZvckhyZWY6IG9wdGlvbnMuc2hvdWxkRGVjb2RlTmV3bGluZXNGb3JIcmVmLFxuICAgIHNob3VsZEtlZXBDb21tZW50OiBvcHRpb25zLmNvbW1lbnRzLFxuICAgIG91dHB1dFNvdXJjZVJhbmdlOiBvcHRpb25zLm91dHB1dFNvdXJjZVJhbmdlLFxuICAgIHN0YXJ0OiBmdW5jdGlvbiBzdGFydCAodGFnLCBhdHRycywgdW5hcnksIHN0YXJ0JDEsIGVuZCkge1xuICAgICAgLy8gY2hlY2sgbmFtZXNwYWNlLlxuICAgICAgLy8gaW5oZXJpdCBwYXJlbnQgbnMgaWYgdGhlcmUgaXMgb25lXG4gICAgICB2YXIgbnMgPSAoY3VycmVudFBhcmVudCAmJiBjdXJyZW50UGFyZW50Lm5zKSB8fCBwbGF0Zm9ybUdldFRhZ05hbWVzcGFjZSh0YWcpO1xuXG4gICAgICAvLyBoYW5kbGUgSUUgc3ZnIGJ1Z1xuICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgICBpZiAoaXNJRSAmJiBucyA9PT0gJ3N2ZycpIHtcbiAgICAgICAgYXR0cnMgPSBndWFyZElFU1ZHQnVnKGF0dHJzKTtcbiAgICAgIH1cblxuICAgICAgdmFyIGVsZW1lbnQgPSBjcmVhdGVBU1RFbGVtZW50KHRhZywgYXR0cnMsIGN1cnJlbnRQYXJlbnQpO1xuICAgICAgaWYgKG5zKSB7XG4gICAgICAgIGVsZW1lbnQubnMgPSBucztcbiAgICAgIH1cblxuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgaWYgKG9wdGlvbnMub3V0cHV0U291cmNlUmFuZ2UpIHtcbiAgICAgICAgICBlbGVtZW50LnN0YXJ0ID0gc3RhcnQkMTtcbiAgICAgICAgICBlbGVtZW50LmVuZCA9IGVuZDtcbiAgICAgICAgICBlbGVtZW50LnJhd0F0dHJzTWFwID0gZWxlbWVudC5hdHRyc0xpc3QucmVkdWNlKGZ1bmN0aW9uIChjdW11bGF0ZWQsIGF0dHIpIHtcbiAgICAgICAgICAgIGN1bXVsYXRlZFthdHRyLm5hbWVdID0gYXR0cjtcbiAgICAgICAgICAgIHJldHVybiBjdW11bGF0ZWRcbiAgICAgICAgICB9LCB7fSk7XG4gICAgICAgIH1cbiAgICAgICAgYXR0cnMuZm9yRWFjaChmdW5jdGlvbiAoYXR0cikge1xuICAgICAgICAgIGlmIChpbnZhbGlkQXR0cmlidXRlUkUudGVzdChhdHRyLm5hbWUpKSB7XG4gICAgICAgICAgICB3YXJuJDIoXG4gICAgICAgICAgICAgIFwiSW52YWxpZCBkeW5hbWljIGFyZ3VtZW50IGV4cHJlc3Npb246IGF0dHJpYnV0ZSBuYW1lcyBjYW5ub3QgY29udGFpbiBcIiArXG4gICAgICAgICAgICAgIFwic3BhY2VzLCBxdW90ZXMsIDwsID4sIC8gb3IgPS5cIixcbiAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHN0YXJ0OiBhdHRyLnN0YXJ0ICsgYXR0ci5uYW1lLmluZGV4T2YoXCJbXCIpLFxuICAgICAgICAgICAgICAgIGVuZDogYXR0ci5zdGFydCArIGF0dHIubmFtZS5sZW5ndGhcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICBpZiAoaXNGb3JiaWRkZW5UYWcoZWxlbWVudCkgJiYgIWlzU2VydmVyUmVuZGVyaW5nKCkpIHtcbiAgICAgICAgZWxlbWVudC5mb3JiaWRkZW4gPSB0cnVlO1xuICAgICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIHdhcm4kMihcbiAgICAgICAgICAnVGVtcGxhdGVzIHNob3VsZCBvbmx5IGJlIHJlc3BvbnNpYmxlIGZvciBtYXBwaW5nIHRoZSBzdGF0ZSB0byB0aGUgJyArXG4gICAgICAgICAgJ1VJLiBBdm9pZCBwbGFjaW5nIHRhZ3Mgd2l0aCBzaWRlLWVmZmVjdHMgaW4geW91ciB0ZW1wbGF0ZXMsIHN1Y2ggYXMgJyArXG4gICAgICAgICAgXCI8XCIgKyB0YWcgKyBcIj5cIiArICcsIGFzIHRoZXkgd2lsbCBub3QgYmUgcGFyc2VkLicsXG4gICAgICAgICAgeyBzdGFydDogZWxlbWVudC5zdGFydCB9XG4gICAgICAgICk7XG4gICAgICB9XG5cbiAgICAgIC8vIGFwcGx5IHByZS10cmFuc2Zvcm1zXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHByZVRyYW5zZm9ybXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgZWxlbWVudCA9IHByZVRyYW5zZm9ybXNbaV0oZWxlbWVudCwgb3B0aW9ucykgfHwgZWxlbWVudDtcbiAgICAgIH1cblxuICAgICAgaWYgKCFpblZQcmUpIHtcbiAgICAgICAgcHJvY2Vzc1ByZShlbGVtZW50KTtcbiAgICAgICAgaWYgKGVsZW1lbnQucHJlKSB7XG4gICAgICAgICAgaW5WUHJlID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKHBsYXRmb3JtSXNQcmVUYWcoZWxlbWVudC50YWcpKSB7XG4gICAgICAgIGluUHJlID0gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIGlmIChpblZQcmUpIHtcbiAgICAgICAgcHJvY2Vzc1Jhd0F0dHJzKGVsZW1lbnQpO1xuICAgICAgfSBlbHNlIGlmICghZWxlbWVudC5wcm9jZXNzZWQpIHtcbiAgICAgICAgLy8gc3RydWN0dXJhbCBkaXJlY3RpdmVzXG4gICAgICAgIHByb2Nlc3NGb3IoZWxlbWVudCk7XG4gICAgICAgIHByb2Nlc3NJZihlbGVtZW50KTtcbiAgICAgICAgcHJvY2Vzc09uY2UoZWxlbWVudCk7XG4gICAgICB9XG5cbiAgICAgIGlmICghcm9vdCkge1xuICAgICAgICByb290ID0gZWxlbWVudDtcbiAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgICBjaGVja1Jvb3RDb25zdHJhaW50cyhyb290KTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoIXVuYXJ5KSB7XG4gICAgICAgIGN1cnJlbnRQYXJlbnQgPSBlbGVtZW50O1xuICAgICAgICBzdGFjay5wdXNoKGVsZW1lbnQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY2xvc2VFbGVtZW50KGVsZW1lbnQpO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICBlbmQ6IGZ1bmN0aW9uIGVuZCAodGFnLCBzdGFydCwgZW5kJDEpIHtcbiAgICAgIHZhciBlbGVtZW50ID0gc3RhY2tbc3RhY2subGVuZ3RoIC0gMV07XG4gICAgICAvLyBwb3Agc3RhY2tcbiAgICAgIHN0YWNrLmxlbmd0aCAtPSAxO1xuICAgICAgY3VycmVudFBhcmVudCA9IHN0YWNrW3N0YWNrLmxlbmd0aCAtIDFdO1xuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgb3B0aW9ucy5vdXRwdXRTb3VyY2VSYW5nZSkge1xuICAgICAgICBlbGVtZW50LmVuZCA9IGVuZCQxO1xuICAgICAgfVxuICAgICAgY2xvc2VFbGVtZW50KGVsZW1lbnQpO1xuICAgIH0sXG5cbiAgICBjaGFyczogZnVuY3Rpb24gY2hhcnMgKHRleHQsIHN0YXJ0LCBlbmQpIHtcbiAgICAgIGlmICghY3VycmVudFBhcmVudCkge1xuICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICAgIGlmICh0ZXh0ID09PSB0ZW1wbGF0ZSkge1xuICAgICAgICAgICAgd2Fybk9uY2UoXG4gICAgICAgICAgICAgICdDb21wb25lbnQgdGVtcGxhdGUgcmVxdWlyZXMgYSByb290IGVsZW1lbnQsIHJhdGhlciB0aGFuIGp1c3QgdGV4dC4nLFxuICAgICAgICAgICAgICB7IHN0YXJ0OiBzdGFydCB9XG4gICAgICAgICAgICApO1xuICAgICAgICAgIH0gZWxzZSBpZiAoKHRleHQgPSB0ZXh0LnRyaW0oKSkpIHtcbiAgICAgICAgICAgIHdhcm5PbmNlKFxuICAgICAgICAgICAgICAoXCJ0ZXh0IFxcXCJcIiArIHRleHQgKyBcIlxcXCIgb3V0c2lkZSByb290IGVsZW1lbnQgd2lsbCBiZSBpZ25vcmVkLlwiKSxcbiAgICAgICAgICAgICAgeyBzdGFydDogc3RhcnQgfVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuXG4gICAgICB9XG4gICAgICAvLyBJRSB0ZXh0YXJlYSBwbGFjZWhvbGRlciBidWdcbiAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgICAgaWYgKGlzSUUgJiZcbiAgICAgICAgY3VycmVudFBhcmVudC50YWcgPT09ICd0ZXh0YXJlYScgJiZcbiAgICAgICAgY3VycmVudFBhcmVudC5hdHRyc01hcC5wbGFjZWhvbGRlciA9PT0gdGV4dFxuICAgICAgKSB7XG4gICAgICAgIHJldHVyblxuICAgICAgfVxuICAgICAgdmFyIGNoaWxkcmVuID0gY3VycmVudFBhcmVudC5jaGlsZHJlbjtcbiAgICAgIGlmIChpblByZSB8fCB0ZXh0LnRyaW0oKSkge1xuICAgICAgICB0ZXh0ID0gaXNUZXh0VGFnKGN1cnJlbnRQYXJlbnQpID8gdGV4dCA6IGRlY29kZUhUTUxDYWNoZWQodGV4dCk7XG4gICAgICB9IGVsc2UgaWYgKCFjaGlsZHJlbi5sZW5ndGgpIHtcbiAgICAgICAgLy8gcmVtb3ZlIHRoZSB3aGl0ZXNwYWNlLW9ubHkgbm9kZSByaWdodCBhZnRlciBhbiBvcGVuaW5nIHRhZ1xuICAgICAgICB0ZXh0ID0gJyc7XG4gICAgICB9IGVsc2UgaWYgKHdoaXRlc3BhY2VPcHRpb24pIHtcbiAgICAgICAgaWYgKHdoaXRlc3BhY2VPcHRpb24gPT09ICdjb25kZW5zZScpIHtcbiAgICAgICAgICAvLyBpbiBjb25kZW5zZSBtb2RlLCByZW1vdmUgdGhlIHdoaXRlc3BhY2Ugbm9kZSBpZiBpdCBjb250YWluc1xuICAgICAgICAgIC8vIGxpbmUgYnJlYWssIG90aGVyd2lzZSBjb25kZW5zZSB0byBhIHNpbmdsZSBzcGFjZVxuICAgICAgICAgIHRleHQgPSBsaW5lQnJlYWtSRS50ZXN0KHRleHQpID8gJycgOiAnICc7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGV4dCA9ICcgJztcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGV4dCA9IHByZXNlcnZlV2hpdGVzcGFjZSA/ICcgJyA6ICcnO1xuICAgICAgfVxuICAgICAgaWYgKHRleHQpIHtcbiAgICAgICAgaWYgKCFpblByZSAmJiB3aGl0ZXNwYWNlT3B0aW9uID09PSAnY29uZGVuc2UnKSB7XG4gICAgICAgICAgLy8gY29uZGVuc2UgY29uc2VjdXRpdmUgd2hpdGVzcGFjZXMgaW50byBzaW5nbGUgc3BhY2VcbiAgICAgICAgICB0ZXh0ID0gdGV4dC5yZXBsYWNlKHdoaXRlc3BhY2VSRSQxLCAnICcpO1xuICAgICAgICB9XG4gICAgICAgIHZhciByZXM7XG4gICAgICAgIHZhciBjaGlsZDtcbiAgICAgICAgaWYgKCFpblZQcmUgJiYgdGV4dCAhPT0gJyAnICYmIChyZXMgPSBwYXJzZVRleHQodGV4dCwgZGVsaW1pdGVycykpKSB7XG4gICAgICAgICAgY2hpbGQgPSB7XG4gICAgICAgICAgICB0eXBlOiAyLFxuICAgICAgICAgICAgZXhwcmVzc2lvbjogcmVzLmV4cHJlc3Npb24sXG4gICAgICAgICAgICB0b2tlbnM6IHJlcy50b2tlbnMsXG4gICAgICAgICAgICB0ZXh0OiB0ZXh0XG4gICAgICAgICAgfTtcbiAgICAgICAgfSBlbHNlIGlmICh0ZXh0ICE9PSAnICcgfHwgIWNoaWxkcmVuLmxlbmd0aCB8fCBjaGlsZHJlbltjaGlsZHJlbi5sZW5ndGggLSAxXS50ZXh0ICE9PSAnICcpIHtcbiAgICAgICAgICBjaGlsZCA9IHtcbiAgICAgICAgICAgIHR5cGU6IDMsXG4gICAgICAgICAgICB0ZXh0OiB0ZXh0XG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY2hpbGQpIHtcbiAgICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiBvcHRpb25zLm91dHB1dFNvdXJjZVJhbmdlKSB7XG4gICAgICAgICAgICBjaGlsZC5zdGFydCA9IHN0YXJ0O1xuICAgICAgICAgICAgY2hpbGQuZW5kID0gZW5kO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjaGlsZHJlbi5wdXNoKGNoaWxkKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG4gICAgY29tbWVudDogZnVuY3Rpb24gY29tbWVudCAodGV4dCwgc3RhcnQsIGVuZCkge1xuICAgICAgLy8gYWRkaW5nIGFueXRpbmcgYXMgYSBzaWJsaW5nIHRvIHRoZSByb290IG5vZGUgaXMgZm9yYmlkZGVuXG4gICAgICAvLyBjb21tZW50cyBzaG91bGQgc3RpbGwgYmUgYWxsb3dlZCwgYnV0IGlnbm9yZWRcbiAgICAgIGlmIChjdXJyZW50UGFyZW50KSB7XG4gICAgICAgIHZhciBjaGlsZCA9IHtcbiAgICAgICAgICB0eXBlOiAzLFxuICAgICAgICAgIHRleHQ6IHRleHQsXG4gICAgICAgICAgaXNDb21tZW50OiB0cnVlXG4gICAgICAgIH07XG4gICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIG9wdGlvbnMub3V0cHV0U291cmNlUmFuZ2UpIHtcbiAgICAgICAgICBjaGlsZC5zdGFydCA9IHN0YXJ0O1xuICAgICAgICAgIGNoaWxkLmVuZCA9IGVuZDtcbiAgICAgICAgfVxuICAgICAgICBjdXJyZW50UGFyZW50LmNoaWxkcmVuLnB1c2goY2hpbGQpO1xuICAgICAgfVxuICAgIH1cbiAgfSk7XG4gIHJldHVybiByb290XG59XG5cbmZ1bmN0aW9uIHByb2Nlc3NQcmUgKGVsKSB7XG4gIGlmIChnZXRBbmRSZW1vdmVBdHRyKGVsLCAndi1wcmUnKSAhPSBudWxsKSB7XG4gICAgZWwucHJlID0gdHJ1ZTtcbiAgfVxufVxuXG5mdW5jdGlvbiBwcm9jZXNzUmF3QXR0cnMgKGVsKSB7XG4gIHZhciBsaXN0ID0gZWwuYXR0cnNMaXN0O1xuICB2YXIgbGVuID0gbGlzdC5sZW5ndGg7XG4gIGlmIChsZW4pIHtcbiAgICB2YXIgYXR0cnMgPSBlbC5hdHRycyA9IG5ldyBBcnJheShsZW4pO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgIGF0dHJzW2ldID0ge1xuICAgICAgICBuYW1lOiBsaXN0W2ldLm5hbWUsXG4gICAgICAgIHZhbHVlOiBKU09OLnN0cmluZ2lmeShsaXN0W2ldLnZhbHVlKVxuICAgICAgfTtcbiAgICAgIGlmIChsaXN0W2ldLnN0YXJ0ICE9IG51bGwpIHtcbiAgICAgICAgYXR0cnNbaV0uc3RhcnQgPSBsaXN0W2ldLnN0YXJ0O1xuICAgICAgICBhdHRyc1tpXS5lbmQgPSBsaXN0W2ldLmVuZDtcbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSBpZiAoIWVsLnByZSkge1xuICAgIC8vIG5vbiByb290IG5vZGUgaW4gcHJlIGJsb2NrcyB3aXRoIG5vIGF0dHJpYnV0ZXNcbiAgICBlbC5wbGFpbiA9IHRydWU7XG4gIH1cbn1cblxuZnVuY3Rpb24gcHJvY2Vzc0VsZW1lbnQgKFxuICBlbGVtZW50LFxuICBvcHRpb25zXG4pIHtcbiAgcHJvY2Vzc0tleShlbGVtZW50KTtcblxuICAvLyBkZXRlcm1pbmUgd2hldGhlciB0aGlzIGlzIGEgcGxhaW4gZWxlbWVudCBhZnRlclxuICAvLyByZW1vdmluZyBzdHJ1Y3R1cmFsIGF0dHJpYnV0ZXNcbiAgZWxlbWVudC5wbGFpbiA9IChcbiAgICAhZWxlbWVudC5rZXkgJiZcbiAgICAhZWxlbWVudC5zY29wZWRTbG90cyAmJlxuICAgICFlbGVtZW50LmF0dHJzTGlzdC5sZW5ndGhcbiAgKTtcblxuICBwcm9jZXNzUmVmKGVsZW1lbnQpO1xuICBwcm9jZXNzU2xvdENvbnRlbnQoZWxlbWVudCk7XG4gIHByb2Nlc3NTbG90T3V0bGV0KGVsZW1lbnQpO1xuICBwcm9jZXNzQ29tcG9uZW50KGVsZW1lbnQpO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHRyYW5zZm9ybXMubGVuZ3RoOyBpKyspIHtcbiAgICBlbGVtZW50ID0gdHJhbnNmb3Jtc1tpXShlbGVtZW50LCBvcHRpb25zKSB8fCBlbGVtZW50O1xuICB9XG4gIHByb2Nlc3NBdHRycyhlbGVtZW50KTtcbiAgcmV0dXJuIGVsZW1lbnRcbn1cblxuZnVuY3Rpb24gcHJvY2Vzc0tleSAoZWwpIHtcbiAgdmFyIGV4cCA9IGdldEJpbmRpbmdBdHRyKGVsLCAna2V5Jyk7XG4gIGlmIChleHApIHtcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgaWYgKGVsLnRhZyA9PT0gJ3RlbXBsYXRlJykge1xuICAgICAgICB3YXJuJDIoXG4gICAgICAgICAgXCI8dGVtcGxhdGU+IGNhbm5vdCBiZSBrZXllZC4gUGxhY2UgdGhlIGtleSBvbiByZWFsIGVsZW1lbnRzIGluc3RlYWQuXCIsXG4gICAgICAgICAgZ2V0UmF3QmluZGluZ0F0dHIoZWwsICdrZXknKVxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgaWYgKGVsLmZvcikge1xuICAgICAgICB2YXIgaXRlcmF0b3IgPSBlbC5pdGVyYXRvcjIgfHwgZWwuaXRlcmF0b3IxO1xuICAgICAgICB2YXIgcGFyZW50ID0gZWwucGFyZW50O1xuICAgICAgICBpZiAoaXRlcmF0b3IgJiYgaXRlcmF0b3IgPT09IGV4cCAmJiBwYXJlbnQgJiYgcGFyZW50LnRhZyA9PT0gJ3RyYW5zaXRpb24tZ3JvdXAnKSB7XG4gICAgICAgICAgd2FybiQyKFxuICAgICAgICAgICAgXCJEbyBub3QgdXNlIHYtZm9yIGluZGV4IGFzIGtleSBvbiA8dHJhbnNpdGlvbi1ncm91cD4gY2hpbGRyZW4sIFwiICtcbiAgICAgICAgICAgIFwidGhpcyBpcyB0aGUgc2FtZSBhcyBub3QgdXNpbmcga2V5cy5cIixcbiAgICAgICAgICAgIGdldFJhd0JpbmRpbmdBdHRyKGVsLCAna2V5JyksXG4gICAgICAgICAgICB0cnVlIC8qIHRpcCAqL1xuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgZWwua2V5ID0gZXhwO1xuICB9XG59XG5cbmZ1bmN0aW9uIHByb2Nlc3NSZWYgKGVsKSB7XG4gIHZhciByZWYgPSBnZXRCaW5kaW5nQXR0cihlbCwgJ3JlZicpO1xuICBpZiAocmVmKSB7XG4gICAgZWwucmVmID0gcmVmO1xuICAgIGVsLnJlZkluRm9yID0gY2hlY2tJbkZvcihlbCk7XG4gIH1cbn1cblxuZnVuY3Rpb24gcHJvY2Vzc0ZvciAoZWwpIHtcbiAgdmFyIGV4cDtcbiAgaWYgKChleHAgPSBnZXRBbmRSZW1vdmVBdHRyKGVsLCAndi1mb3InKSkpIHtcbiAgICB2YXIgcmVzID0gcGFyc2VGb3IoZXhwKTtcbiAgICBpZiAocmVzKSB7XG4gICAgICBleHRlbmQoZWwsIHJlcyk7XG4gICAgfSBlbHNlIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICB3YXJuJDIoXG4gICAgICAgIChcIkludmFsaWQgdi1mb3IgZXhwcmVzc2lvbjogXCIgKyBleHApLFxuICAgICAgICBlbC5yYXdBdHRyc01hcFsndi1mb3InXVxuICAgICAgKTtcbiAgICB9XG4gIH1cbn1cblxuXG5cbmZ1bmN0aW9uIHBhcnNlRm9yIChleHApIHtcbiAgdmFyIGluTWF0Y2ggPSBleHAubWF0Y2goZm9yQWxpYXNSRSk7XG4gIGlmICghaW5NYXRjaCkgeyByZXR1cm4gfVxuICB2YXIgcmVzID0ge307XG4gIHJlcy5mb3IgPSBpbk1hdGNoWzJdLnRyaW0oKTtcbiAgdmFyIGFsaWFzID0gaW5NYXRjaFsxXS50cmltKCkucmVwbGFjZShzdHJpcFBhcmVuc1JFLCAnJyk7XG4gIHZhciBpdGVyYXRvck1hdGNoID0gYWxpYXMubWF0Y2goZm9ySXRlcmF0b3JSRSk7XG4gIGlmIChpdGVyYXRvck1hdGNoKSB7XG4gICAgcmVzLmFsaWFzID0gYWxpYXMucmVwbGFjZShmb3JJdGVyYXRvclJFLCAnJykudHJpbSgpO1xuICAgIHJlcy5pdGVyYXRvcjEgPSBpdGVyYXRvck1hdGNoWzFdLnRyaW0oKTtcbiAgICBpZiAoaXRlcmF0b3JNYXRjaFsyXSkge1xuICAgICAgcmVzLml0ZXJhdG9yMiA9IGl0ZXJhdG9yTWF0Y2hbMl0udHJpbSgpO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICByZXMuYWxpYXMgPSBhbGlhcztcbiAgfVxuICByZXR1cm4gcmVzXG59XG5cbmZ1bmN0aW9uIHByb2Nlc3NJZiAoZWwpIHtcbiAgdmFyIGV4cCA9IGdldEFuZFJlbW92ZUF0dHIoZWwsICd2LWlmJyk7XG4gIGlmIChleHApIHtcbiAgICBlbC5pZiA9IGV4cDtcbiAgICBhZGRJZkNvbmRpdGlvbihlbCwge1xuICAgICAgZXhwOiBleHAsXG4gICAgICBibG9jazogZWxcbiAgICB9KTtcbiAgfSBlbHNlIHtcbiAgICBpZiAoZ2V0QW5kUmVtb3ZlQXR0cihlbCwgJ3YtZWxzZScpICE9IG51bGwpIHtcbiAgICAgIGVsLmVsc2UgPSB0cnVlO1xuICAgIH1cbiAgICB2YXIgZWxzZWlmID0gZ2V0QW5kUmVtb3ZlQXR0cihlbCwgJ3YtZWxzZS1pZicpO1xuICAgIGlmIChlbHNlaWYpIHtcbiAgICAgIGVsLmVsc2VpZiA9IGVsc2VpZjtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gcHJvY2Vzc0lmQ29uZGl0aW9ucyAoZWwsIHBhcmVudCkge1xuICB2YXIgcHJldiA9IGZpbmRQcmV2RWxlbWVudChwYXJlbnQuY2hpbGRyZW4pO1xuICBpZiAocHJldiAmJiBwcmV2LmlmKSB7XG4gICAgYWRkSWZDb25kaXRpb24ocHJldiwge1xuICAgICAgZXhwOiBlbC5lbHNlaWYsXG4gICAgICBibG9jazogZWxcbiAgICB9KTtcbiAgfSBlbHNlIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgd2FybiQyKFxuICAgICAgXCJ2LVwiICsgKGVsLmVsc2VpZiA/ICgnZWxzZS1pZj1cIicgKyBlbC5lbHNlaWYgKyAnXCInKSA6ICdlbHNlJykgKyBcIiBcIiArXG4gICAgICBcInVzZWQgb24gZWxlbWVudCA8XCIgKyAoZWwudGFnKSArIFwiPiB3aXRob3V0IGNvcnJlc3BvbmRpbmcgdi1pZi5cIixcbiAgICAgIGVsLnJhd0F0dHJzTWFwW2VsLmVsc2VpZiA/ICd2LWVsc2UtaWYnIDogJ3YtZWxzZSddXG4gICAgKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBmaW5kUHJldkVsZW1lbnQgKGNoaWxkcmVuKSB7XG4gIHZhciBpID0gY2hpbGRyZW4ubGVuZ3RoO1xuICB3aGlsZSAoaS0tKSB7XG4gICAgaWYgKGNoaWxkcmVuW2ldLnR5cGUgPT09IDEpIHtcbiAgICAgIHJldHVybiBjaGlsZHJlbltpXVxuICAgIH0gZWxzZSB7XG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiBjaGlsZHJlbltpXS50ZXh0ICE9PSAnICcpIHtcbiAgICAgICAgd2FybiQyKFxuICAgICAgICAgIFwidGV4dCBcXFwiXCIgKyAoY2hpbGRyZW5baV0udGV4dC50cmltKCkpICsgXCJcXFwiIGJldHdlZW4gdi1pZiBhbmQgdi1lbHNlKC1pZikgXCIgK1xuICAgICAgICAgIFwid2lsbCBiZSBpZ25vcmVkLlwiLFxuICAgICAgICAgIGNoaWxkcmVuW2ldXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICBjaGlsZHJlbi5wb3AoKTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gYWRkSWZDb25kaXRpb24gKGVsLCBjb25kaXRpb24pIHtcbiAgaWYgKCFlbC5pZkNvbmRpdGlvbnMpIHtcbiAgICBlbC5pZkNvbmRpdGlvbnMgPSBbXTtcbiAgfVxuICBlbC5pZkNvbmRpdGlvbnMucHVzaChjb25kaXRpb24pO1xufVxuXG5mdW5jdGlvbiBwcm9jZXNzT25jZSAoZWwpIHtcbiAgdmFyIG9uY2UkJDEgPSBnZXRBbmRSZW1vdmVBdHRyKGVsLCAndi1vbmNlJyk7XG4gIGlmIChvbmNlJCQxICE9IG51bGwpIHtcbiAgICBlbC5vbmNlID0gdHJ1ZTtcbiAgfVxufVxuXG4vLyBoYW5kbGUgY29udGVudCBiZWluZyBwYXNzZWQgdG8gYSBjb21wb25lbnQgYXMgc2xvdCxcbi8vIGUuZy4gPHRlbXBsYXRlIHNsb3Q9XCJ4eHhcIj4sIDxkaXYgc2xvdC1zY29wZT1cInh4eFwiPlxuZnVuY3Rpb24gcHJvY2Vzc1Nsb3RDb250ZW50IChlbCkge1xuICB2YXIgc2xvdFNjb3BlO1xuICBpZiAoZWwudGFnID09PSAndGVtcGxhdGUnKSB7XG4gICAgc2xvdFNjb3BlID0gZ2V0QW5kUmVtb3ZlQXR0cihlbCwgJ3Njb3BlJyk7XG4gICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgc2xvdFNjb3BlKSB7XG4gICAgICB3YXJuJDIoXG4gICAgICAgIFwidGhlIFxcXCJzY29wZVxcXCIgYXR0cmlidXRlIGZvciBzY29wZWQgc2xvdHMgaGF2ZSBiZWVuIGRlcHJlY2F0ZWQgYW5kIFwiICtcbiAgICAgICAgXCJyZXBsYWNlZCBieSBcXFwic2xvdC1zY29wZVxcXCIgc2luY2UgMi41LiBUaGUgbmV3IFxcXCJzbG90LXNjb3BlXFxcIiBhdHRyaWJ1dGUgXCIgK1xuICAgICAgICBcImNhbiBhbHNvIGJlIHVzZWQgb24gcGxhaW4gZWxlbWVudHMgaW4gYWRkaXRpb24gdG8gPHRlbXBsYXRlPiB0byBcIiArXG4gICAgICAgIFwiZGVub3RlIHNjb3BlZCBzbG90cy5cIixcbiAgICAgICAgZWwucmF3QXR0cnNNYXBbJ3Njb3BlJ10sXG4gICAgICAgIHRydWVcbiAgICAgICk7XG4gICAgfVxuICAgIGVsLnNsb3RTY29wZSA9IHNsb3RTY29wZSB8fCBnZXRBbmRSZW1vdmVBdHRyKGVsLCAnc2xvdC1zY29wZScpO1xuICB9IGVsc2UgaWYgKChzbG90U2NvcGUgPSBnZXRBbmRSZW1vdmVBdHRyKGVsLCAnc2xvdC1zY29wZScpKSkge1xuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIGVsLmF0dHJzTWFwWyd2LWZvciddKSB7XG4gICAgICB3YXJuJDIoXG4gICAgICAgIFwiQW1iaWd1b3VzIGNvbWJpbmVkIHVzYWdlIG9mIHNsb3Qtc2NvcGUgYW5kIHYtZm9yIG9uIDxcIiArIChlbC50YWcpICsgXCI+IFwiICtcbiAgICAgICAgXCIodi1mb3IgdGFrZXMgaGlnaGVyIHByaW9yaXR5KS4gVXNlIGEgd3JhcHBlciA8dGVtcGxhdGU+IGZvciB0aGUgXCIgK1xuICAgICAgICBcInNjb3BlZCBzbG90IHRvIG1ha2UgaXQgY2xlYXJlci5cIixcbiAgICAgICAgZWwucmF3QXR0cnNNYXBbJ3Nsb3Qtc2NvcGUnXSxcbiAgICAgICAgdHJ1ZVxuICAgICAgKTtcbiAgICB9XG4gICAgZWwuc2xvdFNjb3BlID0gc2xvdFNjb3BlO1xuICB9XG5cbiAgLy8gc2xvdD1cInh4eFwiXG4gIHZhciBzbG90VGFyZ2V0ID0gZ2V0QmluZGluZ0F0dHIoZWwsICdzbG90Jyk7XG4gIGlmIChzbG90VGFyZ2V0KSB7XG4gICAgZWwuc2xvdFRhcmdldCA9IHNsb3RUYXJnZXQgPT09ICdcIlwiJyA/ICdcImRlZmF1bHRcIicgOiBzbG90VGFyZ2V0O1xuICAgIGVsLnNsb3RUYXJnZXREeW5hbWljID0gISEoZWwuYXR0cnNNYXBbJzpzbG90J10gfHwgZWwuYXR0cnNNYXBbJ3YtYmluZDpzbG90J10pO1xuICAgIC8vIHByZXNlcnZlIHNsb3QgYXMgYW4gYXR0cmlidXRlIGZvciBuYXRpdmUgc2hhZG93IERPTSBjb21wYXRcbiAgICAvLyBvbmx5IGZvciBub24tc2NvcGVkIHNsb3RzLlxuICAgIGlmIChlbC50YWcgIT09ICd0ZW1wbGF0ZScgJiYgIWVsLnNsb3RTY29wZSkge1xuICAgICAgYWRkQXR0cihlbCwgJ3Nsb3QnLCBzbG90VGFyZ2V0LCBnZXRSYXdCaW5kaW5nQXR0cihlbCwgJ3Nsb3QnKSk7XG4gICAgfVxuICB9XG5cbiAgLy8gMi42IHYtc2xvdCBzeW50YXhcbiAge1xuICAgIGlmIChlbC50YWcgPT09ICd0ZW1wbGF0ZScpIHtcbiAgICAgIC8vIHYtc2xvdCBvbiA8dGVtcGxhdGU+XG4gICAgICB2YXIgc2xvdEJpbmRpbmcgPSBnZXRBbmRSZW1vdmVBdHRyQnlSZWdleChlbCwgc2xvdFJFKTtcbiAgICAgIGlmIChzbG90QmluZGluZykge1xuICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICAgIGlmIChlbC5zbG90VGFyZ2V0IHx8IGVsLnNsb3RTY29wZSkge1xuICAgICAgICAgICAgd2FybiQyKFxuICAgICAgICAgICAgICBcIlVuZXhwZWN0ZWQgbWl4ZWQgdXNhZ2Ugb2YgZGlmZmVyZW50IHNsb3Qgc3ludGF4ZXMuXCIsXG4gICAgICAgICAgICAgIGVsXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoZWwucGFyZW50ICYmICFtYXliZUNvbXBvbmVudChlbC5wYXJlbnQpKSB7XG4gICAgICAgICAgICB3YXJuJDIoXG4gICAgICAgICAgICAgIFwiPHRlbXBsYXRlIHYtc2xvdD4gY2FuIG9ubHkgYXBwZWFyIGF0IHRoZSByb290IGxldmVsIGluc2lkZSBcIiArXG4gICAgICAgICAgICAgIFwidGhlIHJlY2VpdmluZyB0aGUgY29tcG9uZW50XCIsXG4gICAgICAgICAgICAgIGVsXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB2YXIgcmVmID0gZ2V0U2xvdE5hbWUoc2xvdEJpbmRpbmcpO1xuICAgICAgICB2YXIgbmFtZSA9IHJlZi5uYW1lO1xuICAgICAgICB2YXIgZHluYW1pYyA9IHJlZi5keW5hbWljO1xuICAgICAgICBlbC5zbG90VGFyZ2V0ID0gbmFtZTtcbiAgICAgICAgZWwuc2xvdFRhcmdldER5bmFtaWMgPSBkeW5hbWljO1xuICAgICAgICBlbC5zbG90U2NvcGUgPSBzbG90QmluZGluZy52YWx1ZSB8fCBlbXB0eVNsb3RTY29wZVRva2VuOyAvLyBmb3JjZSBpdCBpbnRvIGEgc2NvcGVkIHNsb3QgZm9yIHBlcmZcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgLy8gdi1zbG90IG9uIGNvbXBvbmVudCwgZGVub3RlcyBkZWZhdWx0IHNsb3RcbiAgICAgIHZhciBzbG90QmluZGluZyQxID0gZ2V0QW5kUmVtb3ZlQXR0ckJ5UmVnZXgoZWwsIHNsb3RSRSk7XG4gICAgICBpZiAoc2xvdEJpbmRpbmckMSkge1xuICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICAgIGlmICghbWF5YmVDb21wb25lbnQoZWwpKSB7XG4gICAgICAgICAgICB3YXJuJDIoXG4gICAgICAgICAgICAgIFwidi1zbG90IGNhbiBvbmx5IGJlIHVzZWQgb24gY29tcG9uZW50cyBvciA8dGVtcGxhdGU+LlwiLFxuICAgICAgICAgICAgICBzbG90QmluZGluZyQxXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoZWwuc2xvdFNjb3BlIHx8IGVsLnNsb3RUYXJnZXQpIHtcbiAgICAgICAgICAgIHdhcm4kMihcbiAgICAgICAgICAgICAgXCJVbmV4cGVjdGVkIG1peGVkIHVzYWdlIG9mIGRpZmZlcmVudCBzbG90IHN5bnRheGVzLlwiLFxuICAgICAgICAgICAgICBlbFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGVsLnNjb3BlZFNsb3RzKSB7XG4gICAgICAgICAgICB3YXJuJDIoXG4gICAgICAgICAgICAgIFwiVG8gYXZvaWQgc2NvcGUgYW1iaWd1aXR5LCB0aGUgZGVmYXVsdCBzbG90IHNob3VsZCBhbHNvIHVzZSBcIiArXG4gICAgICAgICAgICAgIFwiPHRlbXBsYXRlPiBzeW50YXggd2hlbiB0aGVyZSBhcmUgb3RoZXIgbmFtZWQgc2xvdHMuXCIsXG4gICAgICAgICAgICAgIHNsb3RCaW5kaW5nJDFcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIGFkZCB0aGUgY29tcG9uZW50J3MgY2hpbGRyZW4gdG8gaXRzIGRlZmF1bHQgc2xvdFxuICAgICAgICB2YXIgc2xvdHMgPSBlbC5zY29wZWRTbG90cyB8fCAoZWwuc2NvcGVkU2xvdHMgPSB7fSk7XG4gICAgICAgIHZhciByZWYkMSA9IGdldFNsb3ROYW1lKHNsb3RCaW5kaW5nJDEpO1xuICAgICAgICB2YXIgbmFtZSQxID0gcmVmJDEubmFtZTtcbiAgICAgICAgdmFyIGR5bmFtaWMkMSA9IHJlZiQxLmR5bmFtaWM7XG4gICAgICAgIHZhciBzbG90Q29udGFpbmVyID0gc2xvdHNbbmFtZSQxXSA9IGNyZWF0ZUFTVEVsZW1lbnQoJ3RlbXBsYXRlJywgW10sIGVsKTtcbiAgICAgICAgc2xvdENvbnRhaW5lci5zbG90VGFyZ2V0ID0gbmFtZSQxO1xuICAgICAgICBzbG90Q29udGFpbmVyLnNsb3RUYXJnZXREeW5hbWljID0gZHluYW1pYyQxO1xuICAgICAgICBzbG90Q29udGFpbmVyLmNoaWxkcmVuID0gZWwuY2hpbGRyZW4uZmlsdGVyKGZ1bmN0aW9uIChjKSB7XG4gICAgICAgICAgaWYgKCFjLnNsb3RTY29wZSkge1xuICAgICAgICAgICAgYy5wYXJlbnQgPSBzbG90Q29udGFpbmVyO1xuICAgICAgICAgICAgcmV0dXJuIHRydWVcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBzbG90Q29udGFpbmVyLnNsb3RTY29wZSA9IHNsb3RCaW5kaW5nJDEudmFsdWUgfHwgZW1wdHlTbG90U2NvcGVUb2tlbjtcbiAgICAgICAgLy8gcmVtb3ZlIGNoaWxkcmVuIGFzIHRoZXkgYXJlIHJldHVybmVkIGZyb20gc2NvcGVkU2xvdHMgbm93XG4gICAgICAgIGVsLmNoaWxkcmVuID0gW107XG4gICAgICAgIC8vIG1hcmsgZWwgbm9uLXBsYWluIHNvIGRhdGEgZ2V0cyBnZW5lcmF0ZWRcbiAgICAgICAgZWwucGxhaW4gPSBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gZ2V0U2xvdE5hbWUgKGJpbmRpbmcpIHtcbiAgdmFyIG5hbWUgPSBiaW5kaW5nLm5hbWUucmVwbGFjZShzbG90UkUsICcnKTtcbiAgaWYgKCFuYW1lKSB7XG4gICAgaWYgKGJpbmRpbmcubmFtZVswXSAhPT0gJyMnKSB7XG4gICAgICBuYW1lID0gJ2RlZmF1bHQnO1xuICAgIH0gZWxzZSBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgd2FybiQyKFxuICAgICAgICBcInYtc2xvdCBzaG9ydGhhbmQgc3ludGF4IHJlcXVpcmVzIGEgc2xvdCBuYW1lLlwiLFxuICAgICAgICBiaW5kaW5nXG4gICAgICApO1xuICAgIH1cbiAgfVxuICByZXR1cm4gZHluYW1pY0FyZ1JFLnRlc3QobmFtZSlcbiAgICAvLyBkeW5hbWljIFtuYW1lXVxuICAgID8geyBuYW1lOiBuYW1lLnNsaWNlKDEsIC0xKSwgZHluYW1pYzogdHJ1ZSB9XG4gICAgLy8gc3RhdGljIG5hbWVcbiAgICA6IHsgbmFtZTogKFwiXFxcIlwiICsgbmFtZSArIFwiXFxcIlwiKSwgZHluYW1pYzogZmFsc2UgfVxufVxuXG4vLyBoYW5kbGUgPHNsb3QvPiBvdXRsZXRzXG5mdW5jdGlvbiBwcm9jZXNzU2xvdE91dGxldCAoZWwpIHtcbiAgaWYgKGVsLnRhZyA9PT0gJ3Nsb3QnKSB7XG4gICAgZWwuc2xvdE5hbWUgPSBnZXRCaW5kaW5nQXR0cihlbCwgJ25hbWUnKTtcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiBlbC5rZXkpIHtcbiAgICAgIHdhcm4kMihcbiAgICAgICAgXCJga2V5YCBkb2VzIG5vdCB3b3JrIG9uIDxzbG90PiBiZWNhdXNlIHNsb3RzIGFyZSBhYnN0cmFjdCBvdXRsZXRzIFwiICtcbiAgICAgICAgXCJhbmQgY2FuIHBvc3NpYmx5IGV4cGFuZCBpbnRvIG11bHRpcGxlIGVsZW1lbnRzLiBcIiArXG4gICAgICAgIFwiVXNlIHRoZSBrZXkgb24gYSB3cmFwcGluZyBlbGVtZW50IGluc3RlYWQuXCIsXG4gICAgICAgIGdldFJhd0JpbmRpbmdBdHRyKGVsLCAna2V5JylcbiAgICAgICk7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIHByb2Nlc3NDb21wb25lbnQgKGVsKSB7XG4gIHZhciBiaW5kaW5nO1xuICBpZiAoKGJpbmRpbmcgPSBnZXRCaW5kaW5nQXR0cihlbCwgJ2lzJykpKSB7XG4gICAgZWwuY29tcG9uZW50ID0gYmluZGluZztcbiAgfVxuICBpZiAoZ2V0QW5kUmVtb3ZlQXR0cihlbCwgJ2lubGluZS10ZW1wbGF0ZScpICE9IG51bGwpIHtcbiAgICBlbC5pbmxpbmVUZW1wbGF0ZSA9IHRydWU7XG4gIH1cbn1cblxuZnVuY3Rpb24gcHJvY2Vzc0F0dHJzIChlbCkge1xuICB2YXIgbGlzdCA9IGVsLmF0dHJzTGlzdDtcbiAgdmFyIGksIGwsIG5hbWUsIHJhd05hbWUsIHZhbHVlLCBtb2RpZmllcnMsIHN5bmNHZW4sIGlzRHluYW1pYztcbiAgZm9yIChpID0gMCwgbCA9IGxpc3QubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgbmFtZSA9IHJhd05hbWUgPSBsaXN0W2ldLm5hbWU7XG4gICAgdmFsdWUgPSBsaXN0W2ldLnZhbHVlO1xuICAgIGlmIChkaXJSRS50ZXN0KG5hbWUpKSB7XG4gICAgICAvLyBtYXJrIGVsZW1lbnQgYXMgZHluYW1pY1xuICAgICAgZWwuaGFzQmluZGluZ3MgPSB0cnVlO1xuICAgICAgLy8gbW9kaWZpZXJzXG4gICAgICBtb2RpZmllcnMgPSBwYXJzZU1vZGlmaWVycyhuYW1lLnJlcGxhY2UoZGlyUkUsICcnKSk7XG4gICAgICAvLyBzdXBwb3J0IC5mb28gc2hvcnRoYW5kIHN5bnRheCBmb3IgdGhlIC5wcm9wIG1vZGlmaWVyXG4gICAgICBpZiAobW9kaWZpZXJzKSB7XG4gICAgICAgIG5hbWUgPSBuYW1lLnJlcGxhY2UobW9kaWZpZXJSRSwgJycpO1xuICAgICAgfVxuICAgICAgaWYgKGJpbmRSRS50ZXN0KG5hbWUpKSB7IC8vIHYtYmluZFxuICAgICAgICBuYW1lID0gbmFtZS5yZXBsYWNlKGJpbmRSRSwgJycpO1xuICAgICAgICB2YWx1ZSA9IHBhcnNlRmlsdGVycyh2YWx1ZSk7XG4gICAgICAgIGlzRHluYW1pYyA9IGR5bmFtaWNBcmdSRS50ZXN0KG5hbWUpO1xuICAgICAgICBpZiAoaXNEeW5hbWljKSB7XG4gICAgICAgICAgbmFtZSA9IG5hbWUuc2xpY2UoMSwgLTEpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChcbiAgICAgICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmXG4gICAgICAgICAgdmFsdWUudHJpbSgpLmxlbmd0aCA9PT0gMFxuICAgICAgICApIHtcbiAgICAgICAgICB3YXJuJDIoXG4gICAgICAgICAgICAoXCJUaGUgdmFsdWUgZm9yIGEgdi1iaW5kIGV4cHJlc3Npb24gY2Fubm90IGJlIGVtcHR5LiBGb3VuZCBpbiBcXFwidi1iaW5kOlwiICsgbmFtZSArIFwiXFxcIlwiKVxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1vZGlmaWVycykge1xuICAgICAgICAgIGlmIChtb2RpZmllcnMucHJvcCAmJiAhaXNEeW5hbWljKSB7XG4gICAgICAgICAgICBuYW1lID0gY2FtZWxpemUobmFtZSk7XG4gICAgICAgICAgICBpZiAobmFtZSA9PT0gJ2lubmVySHRtbCcpIHsgbmFtZSA9ICdpbm5lckhUTUwnOyB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChtb2RpZmllcnMuY2FtZWwgJiYgIWlzRHluYW1pYykge1xuICAgICAgICAgICAgbmFtZSA9IGNhbWVsaXplKG5hbWUpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAobW9kaWZpZXJzLnN5bmMpIHtcbiAgICAgICAgICAgIHN5bmNHZW4gPSBnZW5Bc3NpZ25tZW50Q29kZSh2YWx1ZSwgXCIkZXZlbnRcIik7XG4gICAgICAgICAgICBpZiAoIWlzRHluYW1pYykge1xuICAgICAgICAgICAgICBhZGRIYW5kbGVyKFxuICAgICAgICAgICAgICAgIGVsLFxuICAgICAgICAgICAgICAgIChcInVwZGF0ZTpcIiArIChjYW1lbGl6ZShuYW1lKSkpLFxuICAgICAgICAgICAgICAgIHN5bmNHZW4sXG4gICAgICAgICAgICAgICAgbnVsbCxcbiAgICAgICAgICAgICAgICBmYWxzZSxcbiAgICAgICAgICAgICAgICB3YXJuJDIsXG4gICAgICAgICAgICAgICAgbGlzdFtpXVxuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICBpZiAoaHlwaGVuYXRlKG5hbWUpICE9PSBjYW1lbGl6ZShuYW1lKSkge1xuICAgICAgICAgICAgICAgIGFkZEhhbmRsZXIoXG4gICAgICAgICAgICAgICAgICBlbCxcbiAgICAgICAgICAgICAgICAgIChcInVwZGF0ZTpcIiArIChoeXBoZW5hdGUobmFtZSkpKSxcbiAgICAgICAgICAgICAgICAgIHN5bmNHZW4sXG4gICAgICAgICAgICAgICAgICBudWxsLFxuICAgICAgICAgICAgICAgICAgZmFsc2UsXG4gICAgICAgICAgICAgICAgICB3YXJuJDIsXG4gICAgICAgICAgICAgICAgICBsaXN0W2ldXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgLy8gaGFuZGxlciB3LyBkeW5hbWljIGV2ZW50IG5hbWVcbiAgICAgICAgICAgICAgYWRkSGFuZGxlcihcbiAgICAgICAgICAgICAgICBlbCxcbiAgICAgICAgICAgICAgICAoXCJcXFwidXBkYXRlOlxcXCIrKFwiICsgbmFtZSArIFwiKVwiKSxcbiAgICAgICAgICAgICAgICBzeW5jR2VuLFxuICAgICAgICAgICAgICAgIG51bGwsXG4gICAgICAgICAgICAgICAgZmFsc2UsXG4gICAgICAgICAgICAgICAgd2FybiQyLFxuICAgICAgICAgICAgICAgIGxpc3RbaV0sXG4gICAgICAgICAgICAgICAgdHJ1ZSAvLyBkeW5hbWljXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICgobW9kaWZpZXJzICYmIG1vZGlmaWVycy5wcm9wKSB8fCAoXG4gICAgICAgICAgIWVsLmNvbXBvbmVudCAmJiBwbGF0Zm9ybU11c3RVc2VQcm9wKGVsLnRhZywgZWwuYXR0cnNNYXAudHlwZSwgbmFtZSlcbiAgICAgICAgKSkge1xuICAgICAgICAgIGFkZFByb3AoZWwsIG5hbWUsIHZhbHVlLCBsaXN0W2ldLCBpc0R5bmFtaWMpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGFkZEF0dHIoZWwsIG5hbWUsIHZhbHVlLCBsaXN0W2ldLCBpc0R5bmFtaWMpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKG9uUkUudGVzdChuYW1lKSkgeyAvLyB2LW9uXG4gICAgICAgIG5hbWUgPSBuYW1lLnJlcGxhY2Uob25SRSwgJycpO1xuICAgICAgICBpc0R5bmFtaWMgPSBkeW5hbWljQXJnUkUudGVzdChuYW1lKTtcbiAgICAgICAgaWYgKGlzRHluYW1pYykge1xuICAgICAgICAgIG5hbWUgPSBuYW1lLnNsaWNlKDEsIC0xKTtcbiAgICAgICAgfVxuICAgICAgICBhZGRIYW5kbGVyKGVsLCBuYW1lLCB2YWx1ZSwgbW9kaWZpZXJzLCBmYWxzZSwgd2FybiQyLCBsaXN0W2ldLCBpc0R5bmFtaWMpO1xuICAgICAgfSBlbHNlIHsgLy8gbm9ybWFsIGRpcmVjdGl2ZXNcbiAgICAgICAgbmFtZSA9IG5hbWUucmVwbGFjZShkaXJSRSwgJycpO1xuICAgICAgICAvLyBwYXJzZSBhcmdcbiAgICAgICAgdmFyIGFyZ01hdGNoID0gbmFtZS5tYXRjaChhcmdSRSk7XG4gICAgICAgIHZhciBhcmcgPSBhcmdNYXRjaCAmJiBhcmdNYXRjaFsxXTtcbiAgICAgICAgaXNEeW5hbWljID0gZmFsc2U7XG4gICAgICAgIGlmIChhcmcpIHtcbiAgICAgICAgICBuYW1lID0gbmFtZS5zbGljZSgwLCAtKGFyZy5sZW5ndGggKyAxKSk7XG4gICAgICAgICAgaWYgKGR5bmFtaWNBcmdSRS50ZXN0KGFyZykpIHtcbiAgICAgICAgICAgIGFyZyA9IGFyZy5zbGljZSgxLCAtMSk7XG4gICAgICAgICAgICBpc0R5bmFtaWMgPSB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBhZGREaXJlY3RpdmUoZWwsIG5hbWUsIHJhd05hbWUsIHZhbHVlLCBhcmcsIGlzRHluYW1pYywgbW9kaWZpZXJzLCBsaXN0W2ldKTtcbiAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgbmFtZSA9PT0gJ21vZGVsJykge1xuICAgICAgICAgIGNoZWNrRm9yQWxpYXNNb2RlbChlbCwgdmFsdWUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIGxpdGVyYWwgYXR0cmlidXRlXG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICB2YXIgcmVzID0gcGFyc2VUZXh0KHZhbHVlLCBkZWxpbWl0ZXJzKTtcbiAgICAgICAgaWYgKHJlcykge1xuICAgICAgICAgIHdhcm4kMihcbiAgICAgICAgICAgIG5hbWUgKyBcIj1cXFwiXCIgKyB2YWx1ZSArIFwiXFxcIjogXCIgK1xuICAgICAgICAgICAgJ0ludGVycG9sYXRpb24gaW5zaWRlIGF0dHJpYnV0ZXMgaGFzIGJlZW4gcmVtb3ZlZC4gJyArXG4gICAgICAgICAgICAnVXNlIHYtYmluZCBvciB0aGUgY29sb24gc2hvcnRoYW5kIGluc3RlYWQuIEZvciBleGFtcGxlLCAnICtcbiAgICAgICAgICAgICdpbnN0ZWFkIG9mIDxkaXYgaWQ9XCJ7eyB2YWwgfX1cIj4sIHVzZSA8ZGl2IDppZD1cInZhbFwiPi4nLFxuICAgICAgICAgICAgbGlzdFtpXVxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGFkZEF0dHIoZWwsIG5hbWUsIEpTT04uc3RyaW5naWZ5KHZhbHVlKSwgbGlzdFtpXSk7XG4gICAgICAvLyAjNjg4NyBmaXJlZm94IGRvZXNuJ3QgdXBkYXRlIG11dGVkIHN0YXRlIGlmIHNldCB2aWEgYXR0cmlidXRlXG4gICAgICAvLyBldmVuIGltbWVkaWF0ZWx5IGFmdGVyIGVsZW1lbnQgY3JlYXRpb25cbiAgICAgIGlmICghZWwuY29tcG9uZW50ICYmXG4gICAgICAgICAgbmFtZSA9PT0gJ211dGVkJyAmJlxuICAgICAgICAgIHBsYXRmb3JtTXVzdFVzZVByb3AoZWwudGFnLCBlbC5hdHRyc01hcC50eXBlLCBuYW1lKSkge1xuICAgICAgICBhZGRQcm9wKGVsLCBuYW1lLCAndHJ1ZScsIGxpc3RbaV0pO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBjaGVja0luRm9yIChlbCkge1xuICB2YXIgcGFyZW50ID0gZWw7XG4gIHdoaWxlIChwYXJlbnQpIHtcbiAgICBpZiAocGFyZW50LmZvciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIH1cbiAgICBwYXJlbnQgPSBwYXJlbnQucGFyZW50O1xuICB9XG4gIHJldHVybiBmYWxzZVxufVxuXG5mdW5jdGlvbiBwYXJzZU1vZGlmaWVycyAobmFtZSkge1xuICB2YXIgbWF0Y2ggPSBuYW1lLm1hdGNoKG1vZGlmaWVyUkUpO1xuICBpZiAobWF0Y2gpIHtcbiAgICB2YXIgcmV0ID0ge307XG4gICAgbWF0Y2guZm9yRWFjaChmdW5jdGlvbiAobSkgeyByZXRbbS5zbGljZSgxKV0gPSB0cnVlOyB9KTtcbiAgICByZXR1cm4gcmV0XG4gIH1cbn1cblxuZnVuY3Rpb24gbWFrZUF0dHJzTWFwIChhdHRycykge1xuICB2YXIgbWFwID0ge307XG4gIGZvciAodmFyIGkgPSAwLCBsID0gYXR0cnMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgaWYgKFxuICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJlxuICAgICAgbWFwW2F0dHJzW2ldLm5hbWVdICYmICFpc0lFICYmICFpc0VkZ2VcbiAgICApIHtcbiAgICAgIHdhcm4kMignZHVwbGljYXRlIGF0dHJpYnV0ZTogJyArIGF0dHJzW2ldLm5hbWUsIGF0dHJzW2ldKTtcbiAgICB9XG4gICAgbWFwW2F0dHJzW2ldLm5hbWVdID0gYXR0cnNbaV0udmFsdWU7XG4gIH1cbiAgcmV0dXJuIG1hcFxufVxuXG4vLyBmb3Igc2NyaXB0IChlLmcuIHR5cGU9XCJ4L3RlbXBsYXRlXCIpIG9yIHN0eWxlLCBkbyBub3QgZGVjb2RlIGNvbnRlbnRcbmZ1bmN0aW9uIGlzVGV4dFRhZyAoZWwpIHtcbiAgcmV0dXJuIGVsLnRhZyA9PT0gJ3NjcmlwdCcgfHwgZWwudGFnID09PSAnc3R5bGUnXG59XG5cbmZ1bmN0aW9uIGlzRm9yYmlkZGVuVGFnIChlbCkge1xuICByZXR1cm4gKFxuICAgIGVsLnRhZyA9PT0gJ3N0eWxlJyB8fFxuICAgIChlbC50YWcgPT09ICdzY3JpcHQnICYmIChcbiAgICAgICFlbC5hdHRyc01hcC50eXBlIHx8XG4gICAgICBlbC5hdHRyc01hcC50eXBlID09PSAndGV4dC9qYXZhc2NyaXB0J1xuICAgICkpXG4gIClcbn1cblxudmFyIGllTlNCdWcgPSAvXnhtbG5zOk5TXFxkKy87XG52YXIgaWVOU1ByZWZpeCA9IC9eTlNcXGQrOi87XG5cbi8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG5mdW5jdGlvbiBndWFyZElFU1ZHQnVnIChhdHRycykge1xuICB2YXIgcmVzID0gW107XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgYXR0cnMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgYXR0ciA9IGF0dHJzW2ldO1xuICAgIGlmICghaWVOU0J1Zy50ZXN0KGF0dHIubmFtZSkpIHtcbiAgICAgIGF0dHIubmFtZSA9IGF0dHIubmFtZS5yZXBsYWNlKGllTlNQcmVmaXgsICcnKTtcbiAgICAgIHJlcy5wdXNoKGF0dHIpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzXG59XG5cbmZ1bmN0aW9uIGNoZWNrRm9yQWxpYXNNb2RlbCAoZWwsIHZhbHVlKSB7XG4gIHZhciBfZWwgPSBlbDtcbiAgd2hpbGUgKF9lbCkge1xuICAgIGlmIChfZWwuZm9yICYmIF9lbC5hbGlhcyA9PT0gdmFsdWUpIHtcbiAgICAgIHdhcm4kMihcbiAgICAgICAgXCI8XCIgKyAoZWwudGFnKSArIFwiIHYtbW9kZWw9XFxcIlwiICsgdmFsdWUgKyBcIlxcXCI+OiBcIiArXG4gICAgICAgIFwiWW91IGFyZSBiaW5kaW5nIHYtbW9kZWwgZGlyZWN0bHkgdG8gYSB2LWZvciBpdGVyYXRpb24gYWxpYXMuIFwiICtcbiAgICAgICAgXCJUaGlzIHdpbGwgbm90IGJlIGFibGUgdG8gbW9kaWZ5IHRoZSB2LWZvciBzb3VyY2UgYXJyYXkgYmVjYXVzZSBcIiArXG4gICAgICAgIFwid3JpdGluZyB0byB0aGUgYWxpYXMgaXMgbGlrZSBtb2RpZnlpbmcgYSBmdW5jdGlvbiBsb2NhbCB2YXJpYWJsZS4gXCIgK1xuICAgICAgICBcIkNvbnNpZGVyIHVzaW5nIGFuIGFycmF5IG9mIG9iamVjdHMgYW5kIHVzZSB2LW1vZGVsIG9uIGFuIG9iamVjdCBwcm9wZXJ0eSBpbnN0ZWFkLlwiLFxuICAgICAgICBlbC5yYXdBdHRyc01hcFsndi1tb2RlbCddXG4gICAgICApO1xuICAgIH1cbiAgICBfZWwgPSBfZWwucGFyZW50O1xuICB9XG59XG5cbi8qICAqL1xuXG5mdW5jdGlvbiBwcmVUcmFuc2Zvcm1Ob2RlIChlbCwgb3B0aW9ucykge1xuICBpZiAoZWwudGFnID09PSAnaW5wdXQnKSB7XG4gICAgdmFyIG1hcCA9IGVsLmF0dHJzTWFwO1xuICAgIGlmICghbWFwWyd2LW1vZGVsJ10pIHtcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIHZhciB0eXBlQmluZGluZztcbiAgICBpZiAobWFwWyc6dHlwZSddIHx8IG1hcFsndi1iaW5kOnR5cGUnXSkge1xuICAgICAgdHlwZUJpbmRpbmcgPSBnZXRCaW5kaW5nQXR0cihlbCwgJ3R5cGUnKTtcbiAgICB9XG4gICAgaWYgKCFtYXAudHlwZSAmJiAhdHlwZUJpbmRpbmcgJiYgbWFwWyd2LWJpbmQnXSkge1xuICAgICAgdHlwZUJpbmRpbmcgPSBcIihcIiArIChtYXBbJ3YtYmluZCddKSArIFwiKS50eXBlXCI7XG4gICAgfVxuXG4gICAgaWYgKHR5cGVCaW5kaW5nKSB7XG4gICAgICB2YXIgaWZDb25kaXRpb24gPSBnZXRBbmRSZW1vdmVBdHRyKGVsLCAndi1pZicsIHRydWUpO1xuICAgICAgdmFyIGlmQ29uZGl0aW9uRXh0cmEgPSBpZkNvbmRpdGlvbiA/IChcIiYmKFwiICsgaWZDb25kaXRpb24gKyBcIilcIikgOiBcIlwiO1xuICAgICAgdmFyIGhhc0Vsc2UgPSBnZXRBbmRSZW1vdmVBdHRyKGVsLCAndi1lbHNlJywgdHJ1ZSkgIT0gbnVsbDtcbiAgICAgIHZhciBlbHNlSWZDb25kaXRpb24gPSBnZXRBbmRSZW1vdmVBdHRyKGVsLCAndi1lbHNlLWlmJywgdHJ1ZSk7XG4gICAgICAvLyAxLiBjaGVja2JveFxuICAgICAgdmFyIGJyYW5jaDAgPSBjbG9uZUFTVEVsZW1lbnQoZWwpO1xuICAgICAgLy8gcHJvY2VzcyBmb3Igb24gdGhlIG1haW4gbm9kZVxuICAgICAgcHJvY2Vzc0ZvcihicmFuY2gwKTtcbiAgICAgIGFkZFJhd0F0dHIoYnJhbmNoMCwgJ3R5cGUnLCAnY2hlY2tib3gnKTtcbiAgICAgIHByb2Nlc3NFbGVtZW50KGJyYW5jaDAsIG9wdGlvbnMpO1xuICAgICAgYnJhbmNoMC5wcm9jZXNzZWQgPSB0cnVlOyAvLyBwcmV2ZW50IGl0IGZyb20gZG91YmxlLXByb2Nlc3NlZFxuICAgICAgYnJhbmNoMC5pZiA9IFwiKFwiICsgdHlwZUJpbmRpbmcgKyBcIik9PT0nY2hlY2tib3gnXCIgKyBpZkNvbmRpdGlvbkV4dHJhO1xuICAgICAgYWRkSWZDb25kaXRpb24oYnJhbmNoMCwge1xuICAgICAgICBleHA6IGJyYW5jaDAuaWYsXG4gICAgICAgIGJsb2NrOiBicmFuY2gwXG4gICAgICB9KTtcbiAgICAgIC8vIDIuIGFkZCByYWRpbyBlbHNlLWlmIGNvbmRpdGlvblxuICAgICAgdmFyIGJyYW5jaDEgPSBjbG9uZUFTVEVsZW1lbnQoZWwpO1xuICAgICAgZ2V0QW5kUmVtb3ZlQXR0cihicmFuY2gxLCAndi1mb3InLCB0cnVlKTtcbiAgICAgIGFkZFJhd0F0dHIoYnJhbmNoMSwgJ3R5cGUnLCAncmFkaW8nKTtcbiAgICAgIHByb2Nlc3NFbGVtZW50KGJyYW5jaDEsIG9wdGlvbnMpO1xuICAgICAgYWRkSWZDb25kaXRpb24oYnJhbmNoMCwge1xuICAgICAgICBleHA6IFwiKFwiICsgdHlwZUJpbmRpbmcgKyBcIik9PT0ncmFkaW8nXCIgKyBpZkNvbmRpdGlvbkV4dHJhLFxuICAgICAgICBibG9jazogYnJhbmNoMVxuICAgICAgfSk7XG4gICAgICAvLyAzLiBvdGhlclxuICAgICAgdmFyIGJyYW5jaDIgPSBjbG9uZUFTVEVsZW1lbnQoZWwpO1xuICAgICAgZ2V0QW5kUmVtb3ZlQXR0cihicmFuY2gyLCAndi1mb3InLCB0cnVlKTtcbiAgICAgIGFkZFJhd0F0dHIoYnJhbmNoMiwgJzp0eXBlJywgdHlwZUJpbmRpbmcpO1xuICAgICAgcHJvY2Vzc0VsZW1lbnQoYnJhbmNoMiwgb3B0aW9ucyk7XG4gICAgICBhZGRJZkNvbmRpdGlvbihicmFuY2gwLCB7XG4gICAgICAgIGV4cDogaWZDb25kaXRpb24sXG4gICAgICAgIGJsb2NrOiBicmFuY2gyXG4gICAgICB9KTtcblxuICAgICAgaWYgKGhhc0Vsc2UpIHtcbiAgICAgICAgYnJhbmNoMC5lbHNlID0gdHJ1ZTtcbiAgICAgIH0gZWxzZSBpZiAoZWxzZUlmQ29uZGl0aW9uKSB7XG4gICAgICAgIGJyYW5jaDAuZWxzZWlmID0gZWxzZUlmQ29uZGl0aW9uO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gYnJhbmNoMFxuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBjbG9uZUFTVEVsZW1lbnQgKGVsKSB7XG4gIHJldHVybiBjcmVhdGVBU1RFbGVtZW50KGVsLnRhZywgZWwuYXR0cnNMaXN0LnNsaWNlKCksIGVsLnBhcmVudClcbn1cblxudmFyIG1vZGVsJDEgPSB7XG4gIHByZVRyYW5zZm9ybU5vZGU6IHByZVRyYW5zZm9ybU5vZGVcbn07XG5cbnZhciBtb2R1bGVzJDEgPSBbXG4gIGtsYXNzJDEsXG4gIHN0eWxlJDEsXG4gIG1vZGVsJDFcbl07XG5cbi8qICAqL1xuXG5mdW5jdGlvbiB0ZXh0IChlbCwgZGlyKSB7XG4gIGlmIChkaXIudmFsdWUpIHtcbiAgICBhZGRQcm9wKGVsLCAndGV4dENvbnRlbnQnLCAoXCJfcyhcIiArIChkaXIudmFsdWUpICsgXCIpXCIpLCBkaXIpO1xuICB9XG59XG5cbi8qICAqL1xuXG5mdW5jdGlvbiBodG1sIChlbCwgZGlyKSB7XG4gIGlmIChkaXIudmFsdWUpIHtcbiAgICBhZGRQcm9wKGVsLCAnaW5uZXJIVE1MJywgKFwiX3MoXCIgKyAoZGlyLnZhbHVlKSArIFwiKVwiKSwgZGlyKTtcbiAgfVxufVxuXG52YXIgZGlyZWN0aXZlcyQxID0ge1xuICBtb2RlbDogbW9kZWwsXG4gIHRleHQ6IHRleHQsXG4gIGh0bWw6IGh0bWxcbn07XG5cbi8qICAqL1xuXG52YXIgYmFzZU9wdGlvbnMgPSB7XG4gIGV4cGVjdEhUTUw6IHRydWUsXG4gIG1vZHVsZXM6IG1vZHVsZXMkMSxcbiAgZGlyZWN0aXZlczogZGlyZWN0aXZlcyQxLFxuICBpc1ByZVRhZzogaXNQcmVUYWcsXG4gIGlzVW5hcnlUYWc6IGlzVW5hcnlUYWcsXG4gIG11c3RVc2VQcm9wOiBtdXN0VXNlUHJvcCxcbiAgY2FuQmVMZWZ0T3BlblRhZzogY2FuQmVMZWZ0T3BlblRhZyxcbiAgaXNSZXNlcnZlZFRhZzogaXNSZXNlcnZlZFRhZyxcbiAgZ2V0VGFnTmFtZXNwYWNlOiBnZXRUYWdOYW1lc3BhY2UsXG4gIHN0YXRpY0tleXM6IGdlblN0YXRpY0tleXMobW9kdWxlcyQxKVxufTtcblxuLyogICovXG5cbnZhciBpc1N0YXRpY0tleTtcbnZhciBpc1BsYXRmb3JtUmVzZXJ2ZWRUYWc7XG5cbnZhciBnZW5TdGF0aWNLZXlzQ2FjaGVkID0gY2FjaGVkKGdlblN0YXRpY0tleXMkMSk7XG5cbi8qKlxuICogR29hbCBvZiB0aGUgb3B0aW1pemVyOiB3YWxrIHRoZSBnZW5lcmF0ZWQgdGVtcGxhdGUgQVNUIHRyZWVcbiAqIGFuZCBkZXRlY3Qgc3ViLXRyZWVzIHRoYXQgYXJlIHB1cmVseSBzdGF0aWMsIGkuZS4gcGFydHMgb2ZcbiAqIHRoZSBET00gdGhhdCBuZXZlciBuZWVkcyB0byBjaGFuZ2UuXG4gKlxuICogT25jZSB3ZSBkZXRlY3QgdGhlc2Ugc3ViLXRyZWVzLCB3ZSBjYW46XG4gKlxuICogMS4gSG9pc3QgdGhlbSBpbnRvIGNvbnN0YW50cywgc28gdGhhdCB3ZSBubyBsb25nZXIgbmVlZCB0b1xuICogICAgY3JlYXRlIGZyZXNoIG5vZGVzIGZvciB0aGVtIG9uIGVhY2ggcmUtcmVuZGVyO1xuICogMi4gQ29tcGxldGVseSBza2lwIHRoZW0gaW4gdGhlIHBhdGNoaW5nIHByb2Nlc3MuXG4gKi9cbmZ1bmN0aW9uIG9wdGltaXplIChyb290LCBvcHRpb25zKSB7XG4gIGlmICghcm9vdCkgeyByZXR1cm4gfVxuICBpc1N0YXRpY0tleSA9IGdlblN0YXRpY0tleXNDYWNoZWQob3B0aW9ucy5zdGF0aWNLZXlzIHx8ICcnKTtcbiAgaXNQbGF0Zm9ybVJlc2VydmVkVGFnID0gb3B0aW9ucy5pc1Jlc2VydmVkVGFnIHx8IG5vO1xuICAvLyBmaXJzdCBwYXNzOiBtYXJrIGFsbCBub24tc3RhdGljIG5vZGVzLlxuICBtYXJrU3RhdGljJDEocm9vdCk7XG4gIC8vIHNlY29uZCBwYXNzOiBtYXJrIHN0YXRpYyByb290cy5cbiAgbWFya1N0YXRpY1Jvb3RzKHJvb3QsIGZhbHNlKTtcbn1cblxuZnVuY3Rpb24gZ2VuU3RhdGljS2V5cyQxIChrZXlzKSB7XG4gIHJldHVybiBtYWtlTWFwKFxuICAgICd0eXBlLHRhZyxhdHRyc0xpc3QsYXR0cnNNYXAscGxhaW4scGFyZW50LGNoaWxkcmVuLGF0dHJzLHN0YXJ0LGVuZCxyYXdBdHRyc01hcCcgK1xuICAgIChrZXlzID8gJywnICsga2V5cyA6ICcnKVxuICApXG59XG5cbmZ1bmN0aW9uIG1hcmtTdGF0aWMkMSAobm9kZSkge1xuICBub2RlLnN0YXRpYyA9IGlzU3RhdGljKG5vZGUpO1xuICBpZiAobm9kZS50eXBlID09PSAxKSB7XG4gICAgLy8gZG8gbm90IG1ha2UgY29tcG9uZW50IHNsb3QgY29udGVudCBzdGF0aWMuIHRoaXMgYXZvaWRzXG4gICAgLy8gMS4gY29tcG9uZW50cyBub3QgYWJsZSB0byBtdXRhdGUgc2xvdCBub2Rlc1xuICAgIC8vIDIuIHN0YXRpYyBzbG90IGNvbnRlbnQgZmFpbHMgZm9yIGhvdC1yZWxvYWRpbmdcbiAgICBpZiAoXG4gICAgICAhaXNQbGF0Zm9ybVJlc2VydmVkVGFnKG5vZGUudGFnKSAmJlxuICAgICAgbm9kZS50YWcgIT09ICdzbG90JyAmJlxuICAgICAgbm9kZS5hdHRyc01hcFsnaW5saW5lLXRlbXBsYXRlJ10gPT0gbnVsbFxuICAgICkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuICAgIGZvciAodmFyIGkgPSAwLCBsID0gbm9kZS5jaGlsZHJlbi5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgIHZhciBjaGlsZCA9IG5vZGUuY2hpbGRyZW5baV07XG4gICAgICBtYXJrU3RhdGljJDEoY2hpbGQpO1xuICAgICAgaWYgKCFjaGlsZC5zdGF0aWMpIHtcbiAgICAgICAgbm9kZS5zdGF0aWMgPSBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKG5vZGUuaWZDb25kaXRpb25zKSB7XG4gICAgICBmb3IgKHZhciBpJDEgPSAxLCBsJDEgPSBub2RlLmlmQ29uZGl0aW9ucy5sZW5ndGg7IGkkMSA8IGwkMTsgaSQxKyspIHtcbiAgICAgICAgdmFyIGJsb2NrID0gbm9kZS5pZkNvbmRpdGlvbnNbaSQxXS5ibG9jaztcbiAgICAgICAgbWFya1N0YXRpYyQxKGJsb2NrKTtcbiAgICAgICAgaWYgKCFibG9jay5zdGF0aWMpIHtcbiAgICAgICAgICBub2RlLnN0YXRpYyA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIG1hcmtTdGF0aWNSb290cyAobm9kZSwgaXNJbkZvcikge1xuICBpZiAobm9kZS50eXBlID09PSAxKSB7XG4gICAgaWYgKG5vZGUuc3RhdGljIHx8IG5vZGUub25jZSkge1xuICAgICAgbm9kZS5zdGF0aWNJbkZvciA9IGlzSW5Gb3I7XG4gICAgfVxuICAgIC8vIEZvciBhIG5vZGUgdG8gcXVhbGlmeSBhcyBhIHN0YXRpYyByb290LCBpdCBzaG91bGQgaGF2ZSBjaGlsZHJlbiB0aGF0XG4gICAgLy8gYXJlIG5vdCBqdXN0IHN0YXRpYyB0ZXh0LiBPdGhlcndpc2UgdGhlIGNvc3Qgb2YgaG9pc3Rpbmcgb3V0IHdpbGxcbiAgICAvLyBvdXR3ZWlnaCB0aGUgYmVuZWZpdHMgYW5kIGl0J3MgYmV0dGVyIG9mZiB0byBqdXN0IGFsd2F5cyByZW5kZXIgaXQgZnJlc2guXG4gICAgaWYgKG5vZGUuc3RhdGljICYmIG5vZGUuY2hpbGRyZW4ubGVuZ3RoICYmICEoXG4gICAgICBub2RlLmNoaWxkcmVuLmxlbmd0aCA9PT0gMSAmJlxuICAgICAgbm9kZS5jaGlsZHJlblswXS50eXBlID09PSAzXG4gICAgKSkge1xuICAgICAgbm9kZS5zdGF0aWNSb290ID0gdHJ1ZTtcbiAgICAgIHJldHVyblxuICAgIH0gZWxzZSB7XG4gICAgICBub2RlLnN0YXRpY1Jvb3QgPSBmYWxzZTtcbiAgICB9XG4gICAgaWYgKG5vZGUuY2hpbGRyZW4pIHtcbiAgICAgIGZvciAodmFyIGkgPSAwLCBsID0gbm9kZS5jaGlsZHJlbi5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgbWFya1N0YXRpY1Jvb3RzKG5vZGUuY2hpbGRyZW5baV0sIGlzSW5Gb3IgfHwgISFub2RlLmZvcik7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChub2RlLmlmQ29uZGl0aW9ucykge1xuICAgICAgZm9yICh2YXIgaSQxID0gMSwgbCQxID0gbm9kZS5pZkNvbmRpdGlvbnMubGVuZ3RoOyBpJDEgPCBsJDE7IGkkMSsrKSB7XG4gICAgICAgIG1hcmtTdGF0aWNSb290cyhub2RlLmlmQ29uZGl0aW9uc1tpJDFdLmJsb2NrLCBpc0luRm9yKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gaXNTdGF0aWMgKG5vZGUpIHtcbiAgaWYgKG5vZGUudHlwZSA9PT0gMikgeyAvLyBleHByZXNzaW9uXG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cbiAgaWYgKG5vZGUudHlwZSA9PT0gMykgeyAvLyB0ZXh0XG4gICAgcmV0dXJuIHRydWVcbiAgfVxuICByZXR1cm4gISEobm9kZS5wcmUgfHwgKFxuICAgICFub2RlLmhhc0JpbmRpbmdzICYmIC8vIG5vIGR5bmFtaWMgYmluZGluZ3NcbiAgICAhbm9kZS5pZiAmJiAhbm9kZS5mb3IgJiYgLy8gbm90IHYtaWYgb3Igdi1mb3Igb3Igdi1lbHNlXG4gICAgIWlzQnVpbHRJblRhZyhub2RlLnRhZykgJiYgLy8gbm90IGEgYnVpbHQtaW5cbiAgICBpc1BsYXRmb3JtUmVzZXJ2ZWRUYWcobm9kZS50YWcpICYmIC8vIG5vdCBhIGNvbXBvbmVudFxuICAgICFpc0RpcmVjdENoaWxkT2ZUZW1wbGF0ZUZvcihub2RlKSAmJlxuICAgIE9iamVjdC5rZXlzKG5vZGUpLmV2ZXJ5KGlzU3RhdGljS2V5KVxuICApKVxufVxuXG5mdW5jdGlvbiBpc0RpcmVjdENoaWxkT2ZUZW1wbGF0ZUZvciAobm9kZSkge1xuICB3aGlsZSAobm9kZS5wYXJlbnQpIHtcbiAgICBub2RlID0gbm9kZS5wYXJlbnQ7XG4gICAgaWYgKG5vZGUudGFnICE9PSAndGVtcGxhdGUnKSB7XG4gICAgICByZXR1cm4gZmFsc2VcbiAgICB9XG4gICAgaWYgKG5vZGUuZm9yKSB7XG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIH1cbiAgfVxuICByZXR1cm4gZmFsc2Vcbn1cblxuLyogICovXG5cbnZhciBmbkV4cFJFID0gL14oW1xcdyRfXSt8XFwoW14pXSo/XFwpKVxccyo9PnxeZnVuY3Rpb25cXHMqKD86W1xcdyRdKyk/XFxzKlxcKC87XG52YXIgZm5JbnZva2VSRSA9IC9cXChbXildKj9cXCk7KiQvO1xudmFyIHNpbXBsZVBhdGhSRSA9IC9eW0EtWmEtel8kXVtcXHckXSooPzpcXC5bQS1aYS16XyRdW1xcdyRdKnxcXFsnW14nXSo/J118XFxbXCJbXlwiXSo/XCJdfFxcW1xcZCtdfFxcW1tBLVphLXpfJF1bXFx3JF0qXSkqJC87XG5cbi8vIEtleWJvYXJkRXZlbnQua2V5Q29kZSBhbGlhc2VzXG52YXIga2V5Q29kZXMgPSB7XG4gIGVzYzogMjcsXG4gIHRhYjogOSxcbiAgZW50ZXI6IDEzLFxuICBzcGFjZTogMzIsXG4gIHVwOiAzOCxcbiAgbGVmdDogMzcsXG4gIHJpZ2h0OiAzOSxcbiAgZG93bjogNDAsXG4gICdkZWxldGUnOiBbOCwgNDZdXG59O1xuXG4vLyBLZXlib2FyZEV2ZW50LmtleSBhbGlhc2VzXG52YXIga2V5TmFtZXMgPSB7XG4gIC8vICM3ODgwOiBJRTExIGFuZCBFZGdlIHVzZSBgRXNjYCBmb3IgRXNjYXBlIGtleSBuYW1lLlxuICBlc2M6IFsnRXNjJywgJ0VzY2FwZSddLFxuICB0YWI6ICdUYWInLFxuICBlbnRlcjogJ0VudGVyJyxcbiAgLy8gIzkxMTI6IElFMTEgdXNlcyBgU3BhY2ViYXJgIGZvciBTcGFjZSBrZXkgbmFtZS5cbiAgc3BhY2U6IFsnICcsICdTcGFjZWJhciddLFxuICAvLyAjNzgwNjogSUUxMSB1c2VzIGtleSBuYW1lcyB3aXRob3V0IGBBcnJvd2AgcHJlZml4IGZvciBhcnJvdyBrZXlzLlxuICB1cDogWydVcCcsICdBcnJvd1VwJ10sXG4gIGxlZnQ6IFsnTGVmdCcsICdBcnJvd0xlZnQnXSxcbiAgcmlnaHQ6IFsnUmlnaHQnLCAnQXJyb3dSaWdodCddLFxuICBkb3duOiBbJ0Rvd24nLCAnQXJyb3dEb3duJ10sXG4gIC8vICM5MTEyOiBJRTExIHVzZXMgYERlbGAgZm9yIERlbGV0ZSBrZXkgbmFtZS5cbiAgJ2RlbGV0ZSc6IFsnQmFja3NwYWNlJywgJ0RlbGV0ZScsICdEZWwnXVxufTtcblxuLy8gIzQ4Njg6IG1vZGlmaWVycyB0aGF0IHByZXZlbnQgdGhlIGV4ZWN1dGlvbiBvZiB0aGUgbGlzdGVuZXJcbi8vIG5lZWQgdG8gZXhwbGljaXRseSByZXR1cm4gbnVsbCBzbyB0aGF0IHdlIGNhbiBkZXRlcm1pbmUgd2hldGhlciB0byByZW1vdmVcbi8vIHRoZSBsaXN0ZW5lciBmb3IgLm9uY2VcbnZhciBnZW5HdWFyZCA9IGZ1bmN0aW9uIChjb25kaXRpb24pIHsgcmV0dXJuIChcImlmKFwiICsgY29uZGl0aW9uICsgXCIpcmV0dXJuIG51bGw7XCIpOyB9O1xuXG52YXIgbW9kaWZpZXJDb2RlID0ge1xuICBzdG9wOiAnJGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpOycsXG4gIHByZXZlbnQ6ICckZXZlbnQucHJldmVudERlZmF1bHQoKTsnLFxuICBzZWxmOiBnZW5HdWFyZChcIiRldmVudC50YXJnZXQgIT09ICRldmVudC5jdXJyZW50VGFyZ2V0XCIpLFxuICBjdHJsOiBnZW5HdWFyZChcIiEkZXZlbnQuY3RybEtleVwiKSxcbiAgc2hpZnQ6IGdlbkd1YXJkKFwiISRldmVudC5zaGlmdEtleVwiKSxcbiAgYWx0OiBnZW5HdWFyZChcIiEkZXZlbnQuYWx0S2V5XCIpLFxuICBtZXRhOiBnZW5HdWFyZChcIiEkZXZlbnQubWV0YUtleVwiKSxcbiAgbGVmdDogZ2VuR3VhcmQoXCInYnV0dG9uJyBpbiAkZXZlbnQgJiYgJGV2ZW50LmJ1dHRvbiAhPT0gMFwiKSxcbiAgbWlkZGxlOiBnZW5HdWFyZChcIididXR0b24nIGluICRldmVudCAmJiAkZXZlbnQuYnV0dG9uICE9PSAxXCIpLFxuICByaWdodDogZ2VuR3VhcmQoXCInYnV0dG9uJyBpbiAkZXZlbnQgJiYgJGV2ZW50LmJ1dHRvbiAhPT0gMlwiKVxufTtcblxuZnVuY3Rpb24gZ2VuSGFuZGxlcnMgKFxuICBldmVudHMsXG4gIGlzTmF0aXZlXG4pIHtcbiAgdmFyIHByZWZpeCA9IGlzTmF0aXZlID8gJ25hdGl2ZU9uOicgOiAnb246JztcbiAgdmFyIHN0YXRpY0hhbmRsZXJzID0gXCJcIjtcbiAgdmFyIGR5bmFtaWNIYW5kbGVycyA9IFwiXCI7XG4gIGZvciAodmFyIG5hbWUgaW4gZXZlbnRzKSB7XG4gICAgdmFyIGhhbmRsZXJDb2RlID0gZ2VuSGFuZGxlcihldmVudHNbbmFtZV0pO1xuICAgIGlmIChldmVudHNbbmFtZV0gJiYgZXZlbnRzW25hbWVdLmR5bmFtaWMpIHtcbiAgICAgIGR5bmFtaWNIYW5kbGVycyArPSBuYW1lICsgXCIsXCIgKyBoYW5kbGVyQ29kZSArIFwiLFwiO1xuICAgIH0gZWxzZSB7XG4gICAgICBzdGF0aWNIYW5kbGVycyArPSBcIlxcXCJcIiArIG5hbWUgKyBcIlxcXCI6XCIgKyBoYW5kbGVyQ29kZSArIFwiLFwiO1xuICAgIH1cbiAgfVxuICBzdGF0aWNIYW5kbGVycyA9IFwie1wiICsgKHN0YXRpY0hhbmRsZXJzLnNsaWNlKDAsIC0xKSkgKyBcIn1cIjtcbiAgaWYgKGR5bmFtaWNIYW5kbGVycykge1xuICAgIHJldHVybiBwcmVmaXggKyBcIl9kKFwiICsgc3RhdGljSGFuZGxlcnMgKyBcIixbXCIgKyAoZHluYW1pY0hhbmRsZXJzLnNsaWNlKDAsIC0xKSkgKyBcIl0pXCJcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gcHJlZml4ICsgc3RhdGljSGFuZGxlcnNcbiAgfVxufVxuXG5mdW5jdGlvbiBnZW5IYW5kbGVyIChoYW5kbGVyKSB7XG4gIGlmICghaGFuZGxlcikge1xuICAgIHJldHVybiAnZnVuY3Rpb24oKXt9J1xuICB9XG5cbiAgaWYgKEFycmF5LmlzQXJyYXkoaGFuZGxlcikpIHtcbiAgICByZXR1cm4gKFwiW1wiICsgKGhhbmRsZXIubWFwKGZ1bmN0aW9uIChoYW5kbGVyKSB7IHJldHVybiBnZW5IYW5kbGVyKGhhbmRsZXIpOyB9KS5qb2luKCcsJykpICsgXCJdXCIpXG4gIH1cblxuICB2YXIgaXNNZXRob2RQYXRoID0gc2ltcGxlUGF0aFJFLnRlc3QoaGFuZGxlci52YWx1ZSk7XG4gIHZhciBpc0Z1bmN0aW9uRXhwcmVzc2lvbiA9IGZuRXhwUkUudGVzdChoYW5kbGVyLnZhbHVlKTtcbiAgdmFyIGlzRnVuY3Rpb25JbnZvY2F0aW9uID0gc2ltcGxlUGF0aFJFLnRlc3QoaGFuZGxlci52YWx1ZS5yZXBsYWNlKGZuSW52b2tlUkUsICcnKSk7XG5cbiAgaWYgKCFoYW5kbGVyLm1vZGlmaWVycykge1xuICAgIGlmIChpc01ldGhvZFBhdGggfHwgaXNGdW5jdGlvbkV4cHJlc3Npb24pIHtcbiAgICAgIHJldHVybiBoYW5kbGVyLnZhbHVlXG4gICAgfVxuICAgIHJldHVybiAoXCJmdW5jdGlvbigkZXZlbnQpe1wiICsgKGlzRnVuY3Rpb25JbnZvY2F0aW9uID8gKFwicmV0dXJuIFwiICsgKGhhbmRsZXIudmFsdWUpKSA6IGhhbmRsZXIudmFsdWUpICsgXCJ9XCIpIC8vIGlubGluZSBzdGF0ZW1lbnRcbiAgfSBlbHNlIHtcbiAgICB2YXIgY29kZSA9ICcnO1xuICAgIHZhciBnZW5Nb2RpZmllckNvZGUgPSAnJztcbiAgICB2YXIga2V5cyA9IFtdO1xuICAgIGZvciAodmFyIGtleSBpbiBoYW5kbGVyLm1vZGlmaWVycykge1xuICAgICAgaWYgKG1vZGlmaWVyQ29kZVtrZXldKSB7XG4gICAgICAgIGdlbk1vZGlmaWVyQ29kZSArPSBtb2RpZmllckNvZGVba2V5XTtcbiAgICAgICAgLy8gbGVmdC9yaWdodFxuICAgICAgICBpZiAoa2V5Q29kZXNba2V5XSkge1xuICAgICAgICAgIGtleXMucHVzaChrZXkpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKGtleSA9PT0gJ2V4YWN0Jykge1xuICAgICAgICB2YXIgbW9kaWZpZXJzID0gKGhhbmRsZXIubW9kaWZpZXJzKTtcbiAgICAgICAgZ2VuTW9kaWZpZXJDb2RlICs9IGdlbkd1YXJkKFxuICAgICAgICAgIFsnY3RybCcsICdzaGlmdCcsICdhbHQnLCAnbWV0YSddXG4gICAgICAgICAgICAuZmlsdGVyKGZ1bmN0aW9uIChrZXlNb2RpZmllcikgeyByZXR1cm4gIW1vZGlmaWVyc1trZXlNb2RpZmllcl07IH0pXG4gICAgICAgICAgICAubWFwKGZ1bmN0aW9uIChrZXlNb2RpZmllcikgeyByZXR1cm4gKFwiJGV2ZW50LlwiICsga2V5TW9kaWZpZXIgKyBcIktleVwiKTsgfSlcbiAgICAgICAgICAgIC5qb2luKCd8fCcpXG4gICAgICAgICk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBrZXlzLnB1c2goa2V5KTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGtleXMubGVuZ3RoKSB7XG4gICAgICBjb2RlICs9IGdlbktleUZpbHRlcihrZXlzKTtcbiAgICB9XG4gICAgLy8gTWFrZSBzdXJlIG1vZGlmaWVycyBsaWtlIHByZXZlbnQgYW5kIHN0b3AgZ2V0IGV4ZWN1dGVkIGFmdGVyIGtleSBmaWx0ZXJpbmdcbiAgICBpZiAoZ2VuTW9kaWZpZXJDb2RlKSB7XG4gICAgICBjb2RlICs9IGdlbk1vZGlmaWVyQ29kZTtcbiAgICB9XG4gICAgdmFyIGhhbmRsZXJDb2RlID0gaXNNZXRob2RQYXRoXG4gICAgICA/IChcInJldHVybiBcIiArIChoYW5kbGVyLnZhbHVlKSArIFwiKCRldmVudClcIilcbiAgICAgIDogaXNGdW5jdGlvbkV4cHJlc3Npb25cbiAgICAgICAgPyAoXCJyZXR1cm4gKFwiICsgKGhhbmRsZXIudmFsdWUpICsgXCIpKCRldmVudClcIilcbiAgICAgICAgOiBpc0Z1bmN0aW9uSW52b2NhdGlvblxuICAgICAgICAgID8gKFwicmV0dXJuIFwiICsgKGhhbmRsZXIudmFsdWUpKVxuICAgICAgICAgIDogaGFuZGxlci52YWx1ZTtcbiAgICByZXR1cm4gKFwiZnVuY3Rpb24oJGV2ZW50KXtcIiArIGNvZGUgKyBoYW5kbGVyQ29kZSArIFwifVwiKVxuICB9XG59XG5cbmZ1bmN0aW9uIGdlbktleUZpbHRlciAoa2V5cykge1xuICByZXR1cm4gKFxuICAgIC8vIG1ha2Ugc3VyZSB0aGUga2V5IGZpbHRlcnMgb25seSBhcHBseSB0byBLZXlib2FyZEV2ZW50c1xuICAgIC8vICM5NDQxOiBjYW4ndCB1c2UgJ2tleUNvZGUnIGluICRldmVudCBiZWNhdXNlIENocm9tZSBhdXRvZmlsbCBmaXJlcyBmYWtlXG4gICAgLy8ga2V5IGV2ZW50cyB0aGF0IGRvIG5vdCBoYXZlIGtleUNvZGUgcHJvcGVydHkuLi5cbiAgICBcImlmKCEkZXZlbnQudHlwZS5pbmRleE9mKCdrZXknKSYmXCIgK1xuICAgIChrZXlzLm1hcChnZW5GaWx0ZXJDb2RlKS5qb2luKCcmJicpKSArIFwiKXJldHVybiBudWxsO1wiXG4gIClcbn1cblxuZnVuY3Rpb24gZ2VuRmlsdGVyQ29kZSAoa2V5KSB7XG4gIHZhciBrZXlWYWwgPSBwYXJzZUludChrZXksIDEwKTtcbiAgaWYgKGtleVZhbCkge1xuICAgIHJldHVybiAoXCIkZXZlbnQua2V5Q29kZSE9PVwiICsga2V5VmFsKVxuICB9XG4gIHZhciBrZXlDb2RlID0ga2V5Q29kZXNba2V5XTtcbiAgdmFyIGtleU5hbWUgPSBrZXlOYW1lc1trZXldO1xuICByZXR1cm4gKFxuICAgIFwiX2soJGV2ZW50LmtleUNvZGUsXCIgK1xuICAgIChKU09OLnN0cmluZ2lmeShrZXkpKSArIFwiLFwiICtcbiAgICAoSlNPTi5zdHJpbmdpZnkoa2V5Q29kZSkpICsgXCIsXCIgK1xuICAgIFwiJGV2ZW50LmtleSxcIiArXG4gICAgXCJcIiArIChKU09OLnN0cmluZ2lmeShrZXlOYW1lKSkgK1xuICAgIFwiKVwiXG4gIClcbn1cblxuLyogICovXG5cbmZ1bmN0aW9uIG9uIChlbCwgZGlyKSB7XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIGRpci5tb2RpZmllcnMpIHtcbiAgICB3YXJuKFwidi1vbiB3aXRob3V0IGFyZ3VtZW50IGRvZXMgbm90IHN1cHBvcnQgbW9kaWZpZXJzLlwiKTtcbiAgfVxuICBlbC53cmFwTGlzdGVuZXJzID0gZnVuY3Rpb24gKGNvZGUpIHsgcmV0dXJuIChcIl9nKFwiICsgY29kZSArIFwiLFwiICsgKGRpci52YWx1ZSkgKyBcIilcIik7IH07XG59XG5cbi8qICAqL1xuXG5mdW5jdGlvbiBiaW5kJDEgKGVsLCBkaXIpIHtcbiAgZWwud3JhcERhdGEgPSBmdW5jdGlvbiAoY29kZSkge1xuICAgIHJldHVybiAoXCJfYihcIiArIGNvZGUgKyBcIiwnXCIgKyAoZWwudGFnKSArIFwiJyxcIiArIChkaXIudmFsdWUpICsgXCIsXCIgKyAoZGlyLm1vZGlmaWVycyAmJiBkaXIubW9kaWZpZXJzLnByb3AgPyAndHJ1ZScgOiAnZmFsc2UnKSArIChkaXIubW9kaWZpZXJzICYmIGRpci5tb2RpZmllcnMuc3luYyA/ICcsdHJ1ZScgOiAnJykgKyBcIilcIilcbiAgfTtcbn1cblxuLyogICovXG5cbnZhciBiYXNlRGlyZWN0aXZlcyA9IHtcbiAgb246IG9uLFxuICBiaW5kOiBiaW5kJDEsXG4gIGNsb2FrOiBub29wXG59O1xuXG4vKiAgKi9cblxuXG5cblxuXG52YXIgQ29kZWdlblN0YXRlID0gZnVuY3Rpb24gQ29kZWdlblN0YXRlIChvcHRpb25zKSB7XG4gIHRoaXMub3B0aW9ucyA9IG9wdGlvbnM7XG4gIHRoaXMud2FybiA9IG9wdGlvbnMud2FybiB8fCBiYXNlV2FybjtcbiAgdGhpcy50cmFuc2Zvcm1zID0gcGx1Y2tNb2R1bGVGdW5jdGlvbihvcHRpb25zLm1vZHVsZXMsICd0cmFuc2Zvcm1Db2RlJyk7XG4gIHRoaXMuZGF0YUdlbkZucyA9IHBsdWNrTW9kdWxlRnVuY3Rpb24ob3B0aW9ucy5tb2R1bGVzLCAnZ2VuRGF0YScpO1xuICB0aGlzLmRpcmVjdGl2ZXMgPSBleHRlbmQoZXh0ZW5kKHt9LCBiYXNlRGlyZWN0aXZlcyksIG9wdGlvbnMuZGlyZWN0aXZlcyk7XG4gIHZhciBpc1Jlc2VydmVkVGFnID0gb3B0aW9ucy5pc1Jlc2VydmVkVGFnIHx8IG5vO1xuICB0aGlzLm1heWJlQ29tcG9uZW50ID0gZnVuY3Rpb24gKGVsKSB7IHJldHVybiAhIWVsLmNvbXBvbmVudCB8fCAhaXNSZXNlcnZlZFRhZyhlbC50YWcpOyB9O1xuICB0aGlzLm9uY2VJZCA9IDA7XG4gIHRoaXMuc3RhdGljUmVuZGVyRm5zID0gW107XG4gIHRoaXMucHJlID0gZmFsc2U7XG59O1xuXG5cblxuZnVuY3Rpb24gZ2VuZXJhdGUgKFxuICBhc3QsXG4gIG9wdGlvbnNcbikge1xuICB2YXIgc3RhdGUgPSBuZXcgQ29kZWdlblN0YXRlKG9wdGlvbnMpO1xuICB2YXIgY29kZSA9IGFzdCA/IGdlbkVsZW1lbnQoYXN0LCBzdGF0ZSkgOiAnX2MoXCJkaXZcIiknO1xuICByZXR1cm4ge1xuICAgIHJlbmRlcjogKFwid2l0aCh0aGlzKXtyZXR1cm4gXCIgKyBjb2RlICsgXCJ9XCIpLFxuICAgIHN0YXRpY1JlbmRlckZuczogc3RhdGUuc3RhdGljUmVuZGVyRm5zXG4gIH1cbn1cblxuZnVuY3Rpb24gZ2VuRWxlbWVudCAoZWwsIHN0YXRlKSB7XG4gIGlmIChlbC5wYXJlbnQpIHtcbiAgICBlbC5wcmUgPSBlbC5wcmUgfHwgZWwucGFyZW50LnByZTtcbiAgfVxuXG4gIGlmIChlbC5zdGF0aWNSb290ICYmICFlbC5zdGF0aWNQcm9jZXNzZWQpIHtcbiAgICByZXR1cm4gZ2VuU3RhdGljKGVsLCBzdGF0ZSlcbiAgfSBlbHNlIGlmIChlbC5vbmNlICYmICFlbC5vbmNlUHJvY2Vzc2VkKSB7XG4gICAgcmV0dXJuIGdlbk9uY2UoZWwsIHN0YXRlKVxuICB9IGVsc2UgaWYgKGVsLmZvciAmJiAhZWwuZm9yUHJvY2Vzc2VkKSB7XG4gICAgcmV0dXJuIGdlbkZvcihlbCwgc3RhdGUpXG4gIH0gZWxzZSBpZiAoZWwuaWYgJiYgIWVsLmlmUHJvY2Vzc2VkKSB7XG4gICAgcmV0dXJuIGdlbklmKGVsLCBzdGF0ZSlcbiAgfSBlbHNlIGlmIChlbC50YWcgPT09ICd0ZW1wbGF0ZScgJiYgIWVsLnNsb3RUYXJnZXQgJiYgIXN0YXRlLnByZSkge1xuICAgIHJldHVybiBnZW5DaGlsZHJlbihlbCwgc3RhdGUpIHx8ICd2b2lkIDAnXG4gIH0gZWxzZSBpZiAoZWwudGFnID09PSAnc2xvdCcpIHtcbiAgICByZXR1cm4gZ2VuU2xvdChlbCwgc3RhdGUpXG4gIH0gZWxzZSB7XG4gICAgLy8gY29tcG9uZW50IG9yIGVsZW1lbnRcbiAgICB2YXIgY29kZTtcbiAgICBpZiAoZWwuY29tcG9uZW50KSB7XG4gICAgICBjb2RlID0gZ2VuQ29tcG9uZW50KGVsLmNvbXBvbmVudCwgZWwsIHN0YXRlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIGRhdGE7XG4gICAgICBpZiAoIWVsLnBsYWluIHx8IChlbC5wcmUgJiYgc3RhdGUubWF5YmVDb21wb25lbnQoZWwpKSkge1xuICAgICAgICBkYXRhID0gZ2VuRGF0YSQyKGVsLCBzdGF0ZSk7XG4gICAgICB9XG5cbiAgICAgIHZhciBjaGlsZHJlbiA9IGVsLmlubGluZVRlbXBsYXRlID8gbnVsbCA6IGdlbkNoaWxkcmVuKGVsLCBzdGF0ZSwgdHJ1ZSk7XG4gICAgICBjb2RlID0gXCJfYygnXCIgKyAoZWwudGFnKSArIFwiJ1wiICsgKGRhdGEgPyAoXCIsXCIgKyBkYXRhKSA6ICcnKSArIChjaGlsZHJlbiA/IChcIixcIiArIGNoaWxkcmVuKSA6ICcnKSArIFwiKVwiO1xuICAgIH1cbiAgICAvLyBtb2R1bGUgdHJhbnNmb3Jtc1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc3RhdGUudHJhbnNmb3Jtcy5sZW5ndGg7IGkrKykge1xuICAgICAgY29kZSA9IHN0YXRlLnRyYW5zZm9ybXNbaV0oZWwsIGNvZGUpO1xuICAgIH1cbiAgICByZXR1cm4gY29kZVxuICB9XG59XG5cbi8vIGhvaXN0IHN0YXRpYyBzdWItdHJlZXMgb3V0XG5mdW5jdGlvbiBnZW5TdGF0aWMgKGVsLCBzdGF0ZSkge1xuICBlbC5zdGF0aWNQcm9jZXNzZWQgPSB0cnVlO1xuICAvLyBTb21lIGVsZW1lbnRzICh0ZW1wbGF0ZXMpIG5lZWQgdG8gYmVoYXZlIGRpZmZlcmVudGx5IGluc2lkZSBvZiBhIHYtcHJlXG4gIC8vIG5vZGUuICBBbGwgcHJlIG5vZGVzIGFyZSBzdGF0aWMgcm9vdHMsIHNvIHdlIGNhbiB1c2UgdGhpcyBhcyBhIGxvY2F0aW9uIHRvXG4gIC8vIHdyYXAgYSBzdGF0ZSBjaGFuZ2UgYW5kIHJlc2V0IGl0IHVwb24gZXhpdGluZyB0aGUgcHJlIG5vZGUuXG4gIHZhciBvcmlnaW5hbFByZVN0YXRlID0gc3RhdGUucHJlO1xuICBpZiAoZWwucHJlKSB7XG4gICAgc3RhdGUucHJlID0gZWwucHJlO1xuICB9XG4gIHN0YXRlLnN0YXRpY1JlbmRlckZucy5wdXNoKChcIndpdGgodGhpcyl7cmV0dXJuIFwiICsgKGdlbkVsZW1lbnQoZWwsIHN0YXRlKSkgKyBcIn1cIikpO1xuICBzdGF0ZS5wcmUgPSBvcmlnaW5hbFByZVN0YXRlO1xuICByZXR1cm4gKFwiX20oXCIgKyAoc3RhdGUuc3RhdGljUmVuZGVyRm5zLmxlbmd0aCAtIDEpICsgKGVsLnN0YXRpY0luRm9yID8gJyx0cnVlJyA6ICcnKSArIFwiKVwiKVxufVxuXG4vLyB2LW9uY2VcbmZ1bmN0aW9uIGdlbk9uY2UgKGVsLCBzdGF0ZSkge1xuICBlbC5vbmNlUHJvY2Vzc2VkID0gdHJ1ZTtcbiAgaWYgKGVsLmlmICYmICFlbC5pZlByb2Nlc3NlZCkge1xuICAgIHJldHVybiBnZW5JZihlbCwgc3RhdGUpXG4gIH0gZWxzZSBpZiAoZWwuc3RhdGljSW5Gb3IpIHtcbiAgICB2YXIga2V5ID0gJyc7XG4gICAgdmFyIHBhcmVudCA9IGVsLnBhcmVudDtcbiAgICB3aGlsZSAocGFyZW50KSB7XG4gICAgICBpZiAocGFyZW50LmZvcikge1xuICAgICAgICBrZXkgPSBwYXJlbnQua2V5O1xuICAgICAgICBicmVha1xuICAgICAgfVxuICAgICAgcGFyZW50ID0gcGFyZW50LnBhcmVudDtcbiAgICB9XG4gICAgaWYgKCFrZXkpIHtcbiAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgc3RhdGUud2FybihcbiAgICAgICAgXCJ2LW9uY2UgY2FuIG9ubHkgYmUgdXNlZCBpbnNpZGUgdi1mb3IgdGhhdCBpcyBrZXllZC4gXCIsXG4gICAgICAgIGVsLnJhd0F0dHJzTWFwWyd2LW9uY2UnXVxuICAgICAgKTtcbiAgICAgIHJldHVybiBnZW5FbGVtZW50KGVsLCBzdGF0ZSlcbiAgICB9XG4gICAgcmV0dXJuIChcIl9vKFwiICsgKGdlbkVsZW1lbnQoZWwsIHN0YXRlKSkgKyBcIixcIiArIChzdGF0ZS5vbmNlSWQrKykgKyBcIixcIiArIGtleSArIFwiKVwiKVxuICB9IGVsc2Uge1xuICAgIHJldHVybiBnZW5TdGF0aWMoZWwsIHN0YXRlKVxuICB9XG59XG5cbmZ1bmN0aW9uIGdlbklmIChcbiAgZWwsXG4gIHN0YXRlLFxuICBhbHRHZW4sXG4gIGFsdEVtcHR5XG4pIHtcbiAgZWwuaWZQcm9jZXNzZWQgPSB0cnVlOyAvLyBhdm9pZCByZWN1cnNpb25cbiAgcmV0dXJuIGdlbklmQ29uZGl0aW9ucyhlbC5pZkNvbmRpdGlvbnMuc2xpY2UoKSwgc3RhdGUsIGFsdEdlbiwgYWx0RW1wdHkpXG59XG5cbmZ1bmN0aW9uIGdlbklmQ29uZGl0aW9ucyAoXG4gIGNvbmRpdGlvbnMsXG4gIHN0YXRlLFxuICBhbHRHZW4sXG4gIGFsdEVtcHR5XG4pIHtcbiAgaWYgKCFjb25kaXRpb25zLmxlbmd0aCkge1xuICAgIHJldHVybiBhbHRFbXB0eSB8fCAnX2UoKSdcbiAgfVxuXG4gIHZhciBjb25kaXRpb24gPSBjb25kaXRpb25zLnNoaWZ0KCk7XG4gIGlmIChjb25kaXRpb24uZXhwKSB7XG4gICAgcmV0dXJuIChcIihcIiArIChjb25kaXRpb24uZXhwKSArIFwiKT9cIiArIChnZW5UZXJuYXJ5RXhwKGNvbmRpdGlvbi5ibG9jaykpICsgXCI6XCIgKyAoZ2VuSWZDb25kaXRpb25zKGNvbmRpdGlvbnMsIHN0YXRlLCBhbHRHZW4sIGFsdEVtcHR5KSkpXG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIChcIlwiICsgKGdlblRlcm5hcnlFeHAoY29uZGl0aW9uLmJsb2NrKSkpXG4gIH1cblxuICAvLyB2LWlmIHdpdGggdi1vbmNlIHNob3VsZCBnZW5lcmF0ZSBjb2RlIGxpa2UgKGEpP19tKDApOl9tKDEpXG4gIGZ1bmN0aW9uIGdlblRlcm5hcnlFeHAgKGVsKSB7XG4gICAgcmV0dXJuIGFsdEdlblxuICAgICAgPyBhbHRHZW4oZWwsIHN0YXRlKVxuICAgICAgOiBlbC5vbmNlXG4gICAgICAgID8gZ2VuT25jZShlbCwgc3RhdGUpXG4gICAgICAgIDogZ2VuRWxlbWVudChlbCwgc3RhdGUpXG4gIH1cbn1cblxuZnVuY3Rpb24gZ2VuRm9yIChcbiAgZWwsXG4gIHN0YXRlLFxuICBhbHRHZW4sXG4gIGFsdEhlbHBlclxuKSB7XG4gIHZhciBleHAgPSBlbC5mb3I7XG4gIHZhciBhbGlhcyA9IGVsLmFsaWFzO1xuICB2YXIgaXRlcmF0b3IxID0gZWwuaXRlcmF0b3IxID8gKFwiLFwiICsgKGVsLml0ZXJhdG9yMSkpIDogJyc7XG4gIHZhciBpdGVyYXRvcjIgPSBlbC5pdGVyYXRvcjIgPyAoXCIsXCIgKyAoZWwuaXRlcmF0b3IyKSkgOiAnJztcblxuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJlxuICAgIHN0YXRlLm1heWJlQ29tcG9uZW50KGVsKSAmJlxuICAgIGVsLnRhZyAhPT0gJ3Nsb3QnICYmXG4gICAgZWwudGFnICE9PSAndGVtcGxhdGUnICYmXG4gICAgIWVsLmtleVxuICApIHtcbiAgICBzdGF0ZS53YXJuKFxuICAgICAgXCI8XCIgKyAoZWwudGFnKSArIFwiIHYtZm9yPVxcXCJcIiArIGFsaWFzICsgXCIgaW4gXCIgKyBleHAgKyBcIlxcXCI+OiBjb21wb25lbnQgbGlzdHMgcmVuZGVyZWQgd2l0aCBcIiArXG4gICAgICBcInYtZm9yIHNob3VsZCBoYXZlIGV4cGxpY2l0IGtleXMuIFwiICtcbiAgICAgIFwiU2VlIGh0dHBzOi8vdnVlanMub3JnL2d1aWRlL2xpc3QuaHRtbCNrZXkgZm9yIG1vcmUgaW5mby5cIixcbiAgICAgIGVsLnJhd0F0dHJzTWFwWyd2LWZvciddLFxuICAgICAgdHJ1ZSAvKiB0aXAgKi9cbiAgICApO1xuICB9XG5cbiAgZWwuZm9yUHJvY2Vzc2VkID0gdHJ1ZTsgLy8gYXZvaWQgcmVjdXJzaW9uXG4gIHJldHVybiAoYWx0SGVscGVyIHx8ICdfbCcpICsgXCIoKFwiICsgZXhwICsgXCIpLFwiICtcbiAgICBcImZ1bmN0aW9uKFwiICsgYWxpYXMgKyBpdGVyYXRvcjEgKyBpdGVyYXRvcjIgKyBcIil7XCIgK1xuICAgICAgXCJyZXR1cm4gXCIgKyAoKGFsdEdlbiB8fCBnZW5FbGVtZW50KShlbCwgc3RhdGUpKSArXG4gICAgJ30pJ1xufVxuXG5mdW5jdGlvbiBnZW5EYXRhJDIgKGVsLCBzdGF0ZSkge1xuICB2YXIgZGF0YSA9ICd7JztcblxuICAvLyBkaXJlY3RpdmVzIGZpcnN0LlxuICAvLyBkaXJlY3RpdmVzIG1heSBtdXRhdGUgdGhlIGVsJ3Mgb3RoZXIgcHJvcGVydGllcyBiZWZvcmUgdGhleSBhcmUgZ2VuZXJhdGVkLlxuICB2YXIgZGlycyA9IGdlbkRpcmVjdGl2ZXMoZWwsIHN0YXRlKTtcbiAgaWYgKGRpcnMpIHsgZGF0YSArPSBkaXJzICsgJywnOyB9XG5cbiAgLy8ga2V5XG4gIGlmIChlbC5rZXkpIHtcbiAgICBkYXRhICs9IFwia2V5OlwiICsgKGVsLmtleSkgKyBcIixcIjtcbiAgfVxuICAvLyByZWZcbiAgaWYgKGVsLnJlZikge1xuICAgIGRhdGEgKz0gXCJyZWY6XCIgKyAoZWwucmVmKSArIFwiLFwiO1xuICB9XG4gIGlmIChlbC5yZWZJbkZvcikge1xuICAgIGRhdGEgKz0gXCJyZWZJbkZvcjp0cnVlLFwiO1xuICB9XG4gIC8vIHByZVxuICBpZiAoZWwucHJlKSB7XG4gICAgZGF0YSArPSBcInByZTp0cnVlLFwiO1xuICB9XG4gIC8vIHJlY29yZCBvcmlnaW5hbCB0YWcgbmFtZSBmb3IgY29tcG9uZW50cyB1c2luZyBcImlzXCIgYXR0cmlidXRlXG4gIGlmIChlbC5jb21wb25lbnQpIHtcbiAgICBkYXRhICs9IFwidGFnOlxcXCJcIiArIChlbC50YWcpICsgXCJcXFwiLFwiO1xuICB9XG4gIC8vIG1vZHVsZSBkYXRhIGdlbmVyYXRpb24gZnVuY3Rpb25zXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgc3RhdGUuZGF0YUdlbkZucy5sZW5ndGg7IGkrKykge1xuICAgIGRhdGEgKz0gc3RhdGUuZGF0YUdlbkZuc1tpXShlbCk7XG4gIH1cbiAgLy8gYXR0cmlidXRlc1xuICBpZiAoZWwuYXR0cnMpIHtcbiAgICBkYXRhICs9IFwiYXR0cnM6XCIgKyAoZ2VuUHJvcHMoZWwuYXR0cnMpKSArIFwiLFwiO1xuICB9XG4gIC8vIERPTSBwcm9wc1xuICBpZiAoZWwucHJvcHMpIHtcbiAgICBkYXRhICs9IFwiZG9tUHJvcHM6XCIgKyAoZ2VuUHJvcHMoZWwucHJvcHMpKSArIFwiLFwiO1xuICB9XG4gIC8vIGV2ZW50IGhhbmRsZXJzXG4gIGlmIChlbC5ldmVudHMpIHtcbiAgICBkYXRhICs9IChnZW5IYW5kbGVycyhlbC5ldmVudHMsIGZhbHNlKSkgKyBcIixcIjtcbiAgfVxuICBpZiAoZWwubmF0aXZlRXZlbnRzKSB7XG4gICAgZGF0YSArPSAoZ2VuSGFuZGxlcnMoZWwubmF0aXZlRXZlbnRzLCB0cnVlKSkgKyBcIixcIjtcbiAgfVxuICAvLyBzbG90IHRhcmdldFxuICAvLyBvbmx5IGZvciBub24tc2NvcGVkIHNsb3RzXG4gIGlmIChlbC5zbG90VGFyZ2V0ICYmICFlbC5zbG90U2NvcGUpIHtcbiAgICBkYXRhICs9IFwic2xvdDpcIiArIChlbC5zbG90VGFyZ2V0KSArIFwiLFwiO1xuICB9XG4gIC8vIHNjb3BlZCBzbG90c1xuICBpZiAoZWwuc2NvcGVkU2xvdHMpIHtcbiAgICBkYXRhICs9IChnZW5TY29wZWRTbG90cyhlbCwgZWwuc2NvcGVkU2xvdHMsIHN0YXRlKSkgKyBcIixcIjtcbiAgfVxuICAvLyBjb21wb25lbnQgdi1tb2RlbFxuICBpZiAoZWwubW9kZWwpIHtcbiAgICBkYXRhICs9IFwibW9kZWw6e3ZhbHVlOlwiICsgKGVsLm1vZGVsLnZhbHVlKSArIFwiLGNhbGxiYWNrOlwiICsgKGVsLm1vZGVsLmNhbGxiYWNrKSArIFwiLGV4cHJlc3Npb246XCIgKyAoZWwubW9kZWwuZXhwcmVzc2lvbikgKyBcIn0sXCI7XG4gIH1cbiAgLy8gaW5saW5lLXRlbXBsYXRlXG4gIGlmIChlbC5pbmxpbmVUZW1wbGF0ZSkge1xuICAgIHZhciBpbmxpbmVUZW1wbGF0ZSA9IGdlbklubGluZVRlbXBsYXRlKGVsLCBzdGF0ZSk7XG4gICAgaWYgKGlubGluZVRlbXBsYXRlKSB7XG4gICAgICBkYXRhICs9IGlubGluZVRlbXBsYXRlICsgXCIsXCI7XG4gICAgfVxuICB9XG4gIGRhdGEgPSBkYXRhLnJlcGxhY2UoLywkLywgJycpICsgJ30nO1xuICAvLyB2LWJpbmQgZHluYW1pYyBhcmd1bWVudCB3cmFwXG4gIC8vIHYtYmluZCB3aXRoIGR5bmFtaWMgYXJndW1lbnRzIG11c3QgYmUgYXBwbGllZCB1c2luZyB0aGUgc2FtZSB2LWJpbmQgb2JqZWN0XG4gIC8vIG1lcmdlIGhlbHBlciBzbyB0aGF0IGNsYXNzL3N0eWxlL211c3RVc2VQcm9wIGF0dHJzIGFyZSBoYW5kbGVkIGNvcnJlY3RseS5cbiAgaWYgKGVsLmR5bmFtaWNBdHRycykge1xuICAgIGRhdGEgPSBcIl9iKFwiICsgZGF0YSArIFwiLFxcXCJcIiArIChlbC50YWcpICsgXCJcXFwiLFwiICsgKGdlblByb3BzKGVsLmR5bmFtaWNBdHRycykpICsgXCIpXCI7XG4gIH1cbiAgLy8gdi1iaW5kIGRhdGEgd3JhcFxuICBpZiAoZWwud3JhcERhdGEpIHtcbiAgICBkYXRhID0gZWwud3JhcERhdGEoZGF0YSk7XG4gIH1cbiAgLy8gdi1vbiBkYXRhIHdyYXBcbiAgaWYgKGVsLndyYXBMaXN0ZW5lcnMpIHtcbiAgICBkYXRhID0gZWwud3JhcExpc3RlbmVycyhkYXRhKTtcbiAgfVxuICByZXR1cm4gZGF0YVxufVxuXG5mdW5jdGlvbiBnZW5EaXJlY3RpdmVzIChlbCwgc3RhdGUpIHtcbiAgdmFyIGRpcnMgPSBlbC5kaXJlY3RpdmVzO1xuICBpZiAoIWRpcnMpIHsgcmV0dXJuIH1cbiAgdmFyIHJlcyA9ICdkaXJlY3RpdmVzOlsnO1xuICB2YXIgaGFzUnVudGltZSA9IGZhbHNlO1xuICB2YXIgaSwgbCwgZGlyLCBuZWVkUnVudGltZTtcbiAgZm9yIChpID0gMCwgbCA9IGRpcnMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgZGlyID0gZGlyc1tpXTtcbiAgICBuZWVkUnVudGltZSA9IHRydWU7XG4gICAgdmFyIGdlbiA9IHN0YXRlLmRpcmVjdGl2ZXNbZGlyLm5hbWVdO1xuICAgIGlmIChnZW4pIHtcbiAgICAgIC8vIGNvbXBpbGUtdGltZSBkaXJlY3RpdmUgdGhhdCBtYW5pcHVsYXRlcyBBU1QuXG4gICAgICAvLyByZXR1cm5zIHRydWUgaWYgaXQgYWxzbyBuZWVkcyBhIHJ1bnRpbWUgY291bnRlcnBhcnQuXG4gICAgICBuZWVkUnVudGltZSA9ICEhZ2VuKGVsLCBkaXIsIHN0YXRlLndhcm4pO1xuICAgIH1cbiAgICBpZiAobmVlZFJ1bnRpbWUpIHtcbiAgICAgIGhhc1J1bnRpbWUgPSB0cnVlO1xuICAgICAgcmVzICs9IFwie25hbWU6XFxcIlwiICsgKGRpci5uYW1lKSArIFwiXFxcIixyYXdOYW1lOlxcXCJcIiArIChkaXIucmF3TmFtZSkgKyBcIlxcXCJcIiArIChkaXIudmFsdWUgPyAoXCIsdmFsdWU6KFwiICsgKGRpci52YWx1ZSkgKyBcIiksZXhwcmVzc2lvbjpcIiArIChKU09OLnN0cmluZ2lmeShkaXIudmFsdWUpKSkgOiAnJykgKyAoZGlyLmFyZyA/IChcIixhcmc6XCIgKyAoZGlyLmlzRHluYW1pY0FyZyA/IGRpci5hcmcgOiAoXCJcXFwiXCIgKyAoZGlyLmFyZykgKyBcIlxcXCJcIikpKSA6ICcnKSArIChkaXIubW9kaWZpZXJzID8gKFwiLG1vZGlmaWVyczpcIiArIChKU09OLnN0cmluZ2lmeShkaXIubW9kaWZpZXJzKSkpIDogJycpICsgXCJ9LFwiO1xuICAgIH1cbiAgfVxuICBpZiAoaGFzUnVudGltZSkge1xuICAgIHJldHVybiByZXMuc2xpY2UoMCwgLTEpICsgJ10nXG4gIH1cbn1cblxuZnVuY3Rpb24gZ2VuSW5saW5lVGVtcGxhdGUgKGVsLCBzdGF0ZSkge1xuICB2YXIgYXN0ID0gZWwuY2hpbGRyZW5bMF07XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIChcbiAgICBlbC5jaGlsZHJlbi5sZW5ndGggIT09IDEgfHwgYXN0LnR5cGUgIT09IDFcbiAgKSkge1xuICAgIHN0YXRlLndhcm4oXG4gICAgICAnSW5saW5lLXRlbXBsYXRlIGNvbXBvbmVudHMgbXVzdCBoYXZlIGV4YWN0bHkgb25lIGNoaWxkIGVsZW1lbnQuJyxcbiAgICAgIHsgc3RhcnQ6IGVsLnN0YXJ0IH1cbiAgICApO1xuICB9XG4gIGlmIChhc3QgJiYgYXN0LnR5cGUgPT09IDEpIHtcbiAgICB2YXIgaW5saW5lUmVuZGVyRm5zID0gZ2VuZXJhdGUoYXN0LCBzdGF0ZS5vcHRpb25zKTtcbiAgICByZXR1cm4gKFwiaW5saW5lVGVtcGxhdGU6e3JlbmRlcjpmdW5jdGlvbigpe1wiICsgKGlubGluZVJlbmRlckZucy5yZW5kZXIpICsgXCJ9LHN0YXRpY1JlbmRlckZuczpbXCIgKyAoaW5saW5lUmVuZGVyRm5zLnN0YXRpY1JlbmRlckZucy5tYXAoZnVuY3Rpb24gKGNvZGUpIHsgcmV0dXJuIChcImZ1bmN0aW9uKCl7XCIgKyBjb2RlICsgXCJ9XCIpOyB9KS5qb2luKCcsJykpICsgXCJdfVwiKVxuICB9XG59XG5cbmZ1bmN0aW9uIGdlblNjb3BlZFNsb3RzIChcbiAgZWwsXG4gIHNsb3RzLFxuICBzdGF0ZVxuKSB7XG4gIC8vIGJ5IGRlZmF1bHQgc2NvcGVkIHNsb3RzIGFyZSBjb25zaWRlcmVkIFwic3RhYmxlXCIsIHRoaXMgYWxsb3dzIGNoaWxkXG4gIC8vIGNvbXBvbmVudHMgd2l0aCBvbmx5IHNjb3BlZCBzbG90cyB0byBza2lwIGZvcmNlZCB1cGRhdGVzIGZyb20gcGFyZW50LlxuICAvLyBidXQgaW4gc29tZSBjYXNlcyB3ZSBoYXZlIHRvIGJhaWwtb3V0IG9mIHRoaXMgb3B0aW1pemF0aW9uXG4gIC8vIGZvciBleGFtcGxlIGlmIHRoZSBzbG90IGNvbnRhaW5zIGR5bmFtaWMgbmFtZXMsIGhhcyB2LWlmIG9yIHYtZm9yIG9uIHRoZW0uLi5cbiAgdmFyIG5lZWRzRm9yY2VVcGRhdGUgPSBlbC5mb3IgfHwgT2JqZWN0LmtleXMoc2xvdHMpLnNvbWUoZnVuY3Rpb24gKGtleSkge1xuICAgIHZhciBzbG90ID0gc2xvdHNba2V5XTtcbiAgICByZXR1cm4gKFxuICAgICAgc2xvdC5zbG90VGFyZ2V0RHluYW1pYyB8fFxuICAgICAgc2xvdC5pZiB8fFxuICAgICAgc2xvdC5mb3IgfHxcbiAgICAgIGNvbnRhaW5zU2xvdENoaWxkKHNsb3QpIC8vIGlzIHBhc3NpbmcgZG93biBzbG90IGZyb20gcGFyZW50IHdoaWNoIG1heSBiZSBkeW5hbWljXG4gICAgKVxuICB9KTtcblxuICAvLyAjOTUzNDogaWYgYSBjb21wb25lbnQgd2l0aCBzY29wZWQgc2xvdHMgaXMgaW5zaWRlIGEgY29uZGl0aW9uYWwgYnJhbmNoLFxuICAvLyBpdCdzIHBvc3NpYmxlIGZvciB0aGUgc2FtZSBjb21wb25lbnQgdG8gYmUgcmV1c2VkIGJ1dCB3aXRoIGRpZmZlcmVudFxuICAvLyBjb21waWxlZCBzbG90IGNvbnRlbnQuIFRvIGF2b2lkIHRoYXQsIHdlIGdlbmVyYXRlIGEgdW5pcXVlIGtleSBiYXNlZCBvblxuICAvLyB0aGUgZ2VuZXJhdGVkIGNvZGUgb2YgYWxsIHRoZSBzbG90IGNvbnRlbnRzLlxuICB2YXIgbmVlZHNLZXkgPSAhIWVsLmlmO1xuXG4gIC8vIE9SIHdoZW4gaXQgaXMgaW5zaWRlIGFub3RoZXIgc2NvcGVkIHNsb3Qgb3Igdi1mb3IgKHRoZSByZWFjdGl2aXR5IG1heSBiZVxuICAvLyBkaXNjb25uZWN0ZWQgZHVlIHRvIHRoZSBpbnRlcm1lZGlhdGUgc2NvcGUgdmFyaWFibGUpXG4gIC8vICM5NDM4LCAjOTUwNlxuICAvLyBUT0RPOiB0aGlzIGNhbiBiZSBmdXJ0aGVyIG9wdGltaXplZCBieSBwcm9wZXJseSBhbmFseXppbmcgaW4tc2NvcGUgYmluZGluZ3NcbiAgLy8gYW5kIHNraXAgZm9yY2UgdXBkYXRpbmcgb25lcyB0aGF0IGRvIG5vdCBhY3R1YWxseSB1c2Ugc2NvcGUgdmFyaWFibGVzLlxuICBpZiAoIW5lZWRzRm9yY2VVcGRhdGUpIHtcbiAgICB2YXIgcGFyZW50ID0gZWwucGFyZW50O1xuICAgIHdoaWxlIChwYXJlbnQpIHtcbiAgICAgIGlmIChcbiAgICAgICAgKHBhcmVudC5zbG90U2NvcGUgJiYgcGFyZW50LnNsb3RTY29wZSAhPT0gZW1wdHlTbG90U2NvcGVUb2tlbikgfHxcbiAgICAgICAgcGFyZW50LmZvclxuICAgICAgKSB7XG4gICAgICAgIG5lZWRzRm9yY2VVcGRhdGUgPSB0cnVlO1xuICAgICAgICBicmVha1xuICAgICAgfVxuICAgICAgaWYgKHBhcmVudC5pZikge1xuICAgICAgICBuZWVkc0tleSA9IHRydWU7XG4gICAgICB9XG4gICAgICBwYXJlbnQgPSBwYXJlbnQucGFyZW50O1xuICAgIH1cbiAgfVxuXG4gIHZhciBnZW5lcmF0ZWRTbG90cyA9IE9iamVjdC5rZXlzKHNsb3RzKVxuICAgIC5tYXAoZnVuY3Rpb24gKGtleSkgeyByZXR1cm4gZ2VuU2NvcGVkU2xvdChzbG90c1trZXldLCBzdGF0ZSk7IH0pXG4gICAgLmpvaW4oJywnKTtcblxuICByZXR1cm4gKFwic2NvcGVkU2xvdHM6X3UoW1wiICsgZ2VuZXJhdGVkU2xvdHMgKyBcIl1cIiArIChuZWVkc0ZvcmNlVXBkYXRlID8gXCIsbnVsbCx0cnVlXCIgOiBcIlwiKSArICghbmVlZHNGb3JjZVVwZGF0ZSAmJiBuZWVkc0tleSA/IChcIixudWxsLGZhbHNlLFwiICsgKGhhc2goZ2VuZXJhdGVkU2xvdHMpKSkgOiBcIlwiKSArIFwiKVwiKVxufVxuXG5mdW5jdGlvbiBoYXNoKHN0cikge1xuICB2YXIgaGFzaCA9IDUzODE7XG4gIHZhciBpID0gc3RyLmxlbmd0aDtcbiAgd2hpbGUoaSkge1xuICAgIGhhc2ggPSAoaGFzaCAqIDMzKSBeIHN0ci5jaGFyQ29kZUF0KC0taSk7XG4gIH1cbiAgcmV0dXJuIGhhc2ggPj4+IDBcbn1cblxuZnVuY3Rpb24gY29udGFpbnNTbG90Q2hpbGQgKGVsKSB7XG4gIGlmIChlbC50eXBlID09PSAxKSB7XG4gICAgaWYgKGVsLnRhZyA9PT0gJ3Nsb3QnKSB7XG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIH1cbiAgICByZXR1cm4gZWwuY2hpbGRyZW4uc29tZShjb250YWluc1Nsb3RDaGlsZClcbiAgfVxuICByZXR1cm4gZmFsc2Vcbn1cblxuZnVuY3Rpb24gZ2VuU2NvcGVkU2xvdCAoXG4gIGVsLFxuICBzdGF0ZVxuKSB7XG4gIHZhciBpc0xlZ2FjeVN5bnRheCA9IGVsLmF0dHJzTWFwWydzbG90LXNjb3BlJ107XG4gIGlmIChlbC5pZiAmJiAhZWwuaWZQcm9jZXNzZWQgJiYgIWlzTGVnYWN5U3ludGF4KSB7XG4gICAgcmV0dXJuIGdlbklmKGVsLCBzdGF0ZSwgZ2VuU2NvcGVkU2xvdCwgXCJudWxsXCIpXG4gIH1cbiAgaWYgKGVsLmZvciAmJiAhZWwuZm9yUHJvY2Vzc2VkKSB7XG4gICAgcmV0dXJuIGdlbkZvcihlbCwgc3RhdGUsIGdlblNjb3BlZFNsb3QpXG4gIH1cbiAgdmFyIHNsb3RTY29wZSA9IGVsLnNsb3RTY29wZSA9PT0gZW1wdHlTbG90U2NvcGVUb2tlblxuICAgID8gXCJcIlxuICAgIDogU3RyaW5nKGVsLnNsb3RTY29wZSk7XG4gIHZhciBmbiA9IFwiZnVuY3Rpb24oXCIgKyBzbG90U2NvcGUgKyBcIil7XCIgK1xuICAgIFwicmV0dXJuIFwiICsgKGVsLnRhZyA9PT0gJ3RlbXBsYXRlJ1xuICAgICAgPyBlbC5pZiAmJiBpc0xlZ2FjeVN5bnRheFxuICAgICAgICA/IChcIihcIiArIChlbC5pZikgKyBcIik/XCIgKyAoZ2VuQ2hpbGRyZW4oZWwsIHN0YXRlKSB8fCAndW5kZWZpbmVkJykgKyBcIjp1bmRlZmluZWRcIilcbiAgICAgICAgOiBnZW5DaGlsZHJlbihlbCwgc3RhdGUpIHx8ICd1bmRlZmluZWQnXG4gICAgICA6IGdlbkVsZW1lbnQoZWwsIHN0YXRlKSkgKyBcIn1cIjtcbiAgLy8gcmV2ZXJzZSBwcm94eSB2LXNsb3Qgd2l0aG91dCBzY29wZSBvbiB0aGlzLiRzbG90c1xuICB2YXIgcmV2ZXJzZVByb3h5ID0gc2xvdFNjb3BlID8gXCJcIiA6IFwiLHByb3h5OnRydWVcIjtcbiAgcmV0dXJuIChcIntrZXk6XCIgKyAoZWwuc2xvdFRhcmdldCB8fCBcIlxcXCJkZWZhdWx0XFxcIlwiKSArIFwiLGZuOlwiICsgZm4gKyByZXZlcnNlUHJveHkgKyBcIn1cIilcbn1cblxuZnVuY3Rpb24gZ2VuQ2hpbGRyZW4gKFxuICBlbCxcbiAgc3RhdGUsXG4gIGNoZWNrU2tpcCxcbiAgYWx0R2VuRWxlbWVudCxcbiAgYWx0R2VuTm9kZVxuKSB7XG4gIHZhciBjaGlsZHJlbiA9IGVsLmNoaWxkcmVuO1xuICBpZiAoY2hpbGRyZW4ubGVuZ3RoKSB7XG4gICAgdmFyIGVsJDEgPSBjaGlsZHJlblswXTtcbiAgICAvLyBvcHRpbWl6ZSBzaW5nbGUgdi1mb3JcbiAgICBpZiAoY2hpbGRyZW4ubGVuZ3RoID09PSAxICYmXG4gICAgICBlbCQxLmZvciAmJlxuICAgICAgZWwkMS50YWcgIT09ICd0ZW1wbGF0ZScgJiZcbiAgICAgIGVsJDEudGFnICE9PSAnc2xvdCdcbiAgICApIHtcbiAgICAgIHZhciBub3JtYWxpemF0aW9uVHlwZSA9IGNoZWNrU2tpcFxuICAgICAgICA/IHN0YXRlLm1heWJlQ29tcG9uZW50KGVsJDEpID8gXCIsMVwiIDogXCIsMFwiXG4gICAgICAgIDogXCJcIjtcbiAgICAgIHJldHVybiAoXCJcIiArICgoYWx0R2VuRWxlbWVudCB8fCBnZW5FbGVtZW50KShlbCQxLCBzdGF0ZSkpICsgbm9ybWFsaXphdGlvblR5cGUpXG4gICAgfVxuICAgIHZhciBub3JtYWxpemF0aW9uVHlwZSQxID0gY2hlY2tTa2lwXG4gICAgICA/IGdldE5vcm1hbGl6YXRpb25UeXBlKGNoaWxkcmVuLCBzdGF0ZS5tYXliZUNvbXBvbmVudClcbiAgICAgIDogMDtcbiAgICB2YXIgZ2VuID0gYWx0R2VuTm9kZSB8fCBnZW5Ob2RlO1xuICAgIHJldHVybiAoXCJbXCIgKyAoY2hpbGRyZW4ubWFwKGZ1bmN0aW9uIChjKSB7IHJldHVybiBnZW4oYywgc3RhdGUpOyB9KS5qb2luKCcsJykpICsgXCJdXCIgKyAobm9ybWFsaXphdGlvblR5cGUkMSA/IChcIixcIiArIG5vcm1hbGl6YXRpb25UeXBlJDEpIDogJycpKVxuICB9XG59XG5cbi8vIGRldGVybWluZSB0aGUgbm9ybWFsaXphdGlvbiBuZWVkZWQgZm9yIHRoZSBjaGlsZHJlbiBhcnJheS5cbi8vIDA6IG5vIG5vcm1hbGl6YXRpb24gbmVlZGVkXG4vLyAxOiBzaW1wbGUgbm9ybWFsaXphdGlvbiBuZWVkZWQgKHBvc3NpYmxlIDEtbGV2ZWwgZGVlcCBuZXN0ZWQgYXJyYXkpXG4vLyAyOiBmdWxsIG5vcm1hbGl6YXRpb24gbmVlZGVkXG5mdW5jdGlvbiBnZXROb3JtYWxpemF0aW9uVHlwZSAoXG4gIGNoaWxkcmVuLFxuICBtYXliZUNvbXBvbmVudFxuKSB7XG4gIHZhciByZXMgPSAwO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGVsID0gY2hpbGRyZW5baV07XG4gICAgaWYgKGVsLnR5cGUgIT09IDEpIHtcbiAgICAgIGNvbnRpbnVlXG4gICAgfVxuICAgIGlmIChuZWVkc05vcm1hbGl6YXRpb24oZWwpIHx8XG4gICAgICAgIChlbC5pZkNvbmRpdGlvbnMgJiYgZWwuaWZDb25kaXRpb25zLnNvbWUoZnVuY3Rpb24gKGMpIHsgcmV0dXJuIG5lZWRzTm9ybWFsaXphdGlvbihjLmJsb2NrKTsgfSkpKSB7XG4gICAgICByZXMgPSAyO1xuICAgICAgYnJlYWtcbiAgICB9XG4gICAgaWYgKG1heWJlQ29tcG9uZW50KGVsKSB8fFxuICAgICAgICAoZWwuaWZDb25kaXRpb25zICYmIGVsLmlmQ29uZGl0aW9ucy5zb21lKGZ1bmN0aW9uIChjKSB7IHJldHVybiBtYXliZUNvbXBvbmVudChjLmJsb2NrKTsgfSkpKSB7XG4gICAgICByZXMgPSAxO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzXG59XG5cbmZ1bmN0aW9uIG5lZWRzTm9ybWFsaXphdGlvbiAoZWwpIHtcbiAgcmV0dXJuIGVsLmZvciAhPT0gdW5kZWZpbmVkIHx8IGVsLnRhZyA9PT0gJ3RlbXBsYXRlJyB8fCBlbC50YWcgPT09ICdzbG90J1xufVxuXG5mdW5jdGlvbiBnZW5Ob2RlIChub2RlLCBzdGF0ZSkge1xuICBpZiAobm9kZS50eXBlID09PSAxKSB7XG4gICAgcmV0dXJuIGdlbkVsZW1lbnQobm9kZSwgc3RhdGUpXG4gIH0gZWxzZSBpZiAobm9kZS50eXBlID09PSAzICYmIG5vZGUuaXNDb21tZW50KSB7XG4gICAgcmV0dXJuIGdlbkNvbW1lbnQobm9kZSlcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gZ2VuVGV4dChub2RlKVxuICB9XG59XG5cbmZ1bmN0aW9uIGdlblRleHQgKHRleHQpIHtcbiAgcmV0dXJuIChcIl92KFwiICsgKHRleHQudHlwZSA9PT0gMlxuICAgID8gdGV4dC5leHByZXNzaW9uIC8vIG5vIG5lZWQgZm9yICgpIGJlY2F1c2UgYWxyZWFkeSB3cmFwcGVkIGluIF9zKClcbiAgICA6IHRyYW5zZm9ybVNwZWNpYWxOZXdsaW5lcyhKU09OLnN0cmluZ2lmeSh0ZXh0LnRleHQpKSkgKyBcIilcIilcbn1cblxuZnVuY3Rpb24gZ2VuQ29tbWVudCAoY29tbWVudCkge1xuICByZXR1cm4gKFwiX2UoXCIgKyAoSlNPTi5zdHJpbmdpZnkoY29tbWVudC50ZXh0KSkgKyBcIilcIilcbn1cblxuZnVuY3Rpb24gZ2VuU2xvdCAoZWwsIHN0YXRlKSB7XG4gIHZhciBzbG90TmFtZSA9IGVsLnNsb3ROYW1lIHx8ICdcImRlZmF1bHRcIic7XG4gIHZhciBjaGlsZHJlbiA9IGdlbkNoaWxkcmVuKGVsLCBzdGF0ZSk7XG4gIHZhciByZXMgPSBcIl90KFwiICsgc2xvdE5hbWUgKyAoY2hpbGRyZW4gPyAoXCIsXCIgKyBjaGlsZHJlbikgOiAnJyk7XG4gIHZhciBhdHRycyA9IGVsLmF0dHJzIHx8IGVsLmR5bmFtaWNBdHRyc1xuICAgID8gZ2VuUHJvcHMoKGVsLmF0dHJzIHx8IFtdKS5jb25jYXQoZWwuZHluYW1pY0F0dHJzIHx8IFtdKS5tYXAoZnVuY3Rpb24gKGF0dHIpIHsgcmV0dXJuICh7XG4gICAgICAgIC8vIHNsb3QgcHJvcHMgYXJlIGNhbWVsaXplZFxuICAgICAgICBuYW1lOiBjYW1lbGl6ZShhdHRyLm5hbWUpLFxuICAgICAgICB2YWx1ZTogYXR0ci52YWx1ZSxcbiAgICAgICAgZHluYW1pYzogYXR0ci5keW5hbWljXG4gICAgICB9KTsgfSkpXG4gICAgOiBudWxsO1xuICB2YXIgYmluZCQkMSA9IGVsLmF0dHJzTWFwWyd2LWJpbmQnXTtcbiAgaWYgKChhdHRycyB8fCBiaW5kJCQxKSAmJiAhY2hpbGRyZW4pIHtcbiAgICByZXMgKz0gXCIsbnVsbFwiO1xuICB9XG4gIGlmIChhdHRycykge1xuICAgIHJlcyArPSBcIixcIiArIGF0dHJzO1xuICB9XG4gIGlmIChiaW5kJCQxKSB7XG4gICAgcmVzICs9IChhdHRycyA/ICcnIDogJyxudWxsJykgKyBcIixcIiArIGJpbmQkJDE7XG4gIH1cbiAgcmV0dXJuIHJlcyArICcpJ1xufVxuXG4vLyBjb21wb25lbnROYW1lIGlzIGVsLmNvbXBvbmVudCwgdGFrZSBpdCBhcyBhcmd1bWVudCB0byBzaHVuIGZsb3cncyBwZXNzaW1pc3RpYyByZWZpbmVtZW50XG5mdW5jdGlvbiBnZW5Db21wb25lbnQgKFxuICBjb21wb25lbnROYW1lLFxuICBlbCxcbiAgc3RhdGVcbikge1xuICB2YXIgY2hpbGRyZW4gPSBlbC5pbmxpbmVUZW1wbGF0ZSA/IG51bGwgOiBnZW5DaGlsZHJlbihlbCwgc3RhdGUsIHRydWUpO1xuICByZXR1cm4gKFwiX2MoXCIgKyBjb21wb25lbnROYW1lICsgXCIsXCIgKyAoZ2VuRGF0YSQyKGVsLCBzdGF0ZSkpICsgKGNoaWxkcmVuID8gKFwiLFwiICsgY2hpbGRyZW4pIDogJycpICsgXCIpXCIpXG59XG5cbmZ1bmN0aW9uIGdlblByb3BzIChwcm9wcykge1xuICB2YXIgc3RhdGljUHJvcHMgPSBcIlwiO1xuICB2YXIgZHluYW1pY1Byb3BzID0gXCJcIjtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBwcm9wID0gcHJvcHNbaV07XG4gICAgdmFyIHZhbHVlID0gdHJhbnNmb3JtU3BlY2lhbE5ld2xpbmVzKHByb3AudmFsdWUpO1xuICAgIGlmIChwcm9wLmR5bmFtaWMpIHtcbiAgICAgIGR5bmFtaWNQcm9wcyArPSAocHJvcC5uYW1lKSArIFwiLFwiICsgdmFsdWUgKyBcIixcIjtcbiAgICB9IGVsc2Uge1xuICAgICAgc3RhdGljUHJvcHMgKz0gXCJcXFwiXCIgKyAocHJvcC5uYW1lKSArIFwiXFxcIjpcIiArIHZhbHVlICsgXCIsXCI7XG4gICAgfVxuICB9XG4gIHN0YXRpY1Byb3BzID0gXCJ7XCIgKyAoc3RhdGljUHJvcHMuc2xpY2UoMCwgLTEpKSArIFwifVwiO1xuICBpZiAoZHluYW1pY1Byb3BzKSB7XG4gICAgcmV0dXJuIChcIl9kKFwiICsgc3RhdGljUHJvcHMgKyBcIixbXCIgKyAoZHluYW1pY1Byb3BzLnNsaWNlKDAsIC0xKSkgKyBcIl0pXCIpXG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIHN0YXRpY1Byb3BzXG4gIH1cbn1cblxuLy8gIzM4OTUsICM0MjY4XG5mdW5jdGlvbiB0cmFuc2Zvcm1TcGVjaWFsTmV3bGluZXMgKHRleHQpIHtcbiAgcmV0dXJuIHRleHRcbiAgICAucmVwbGFjZSgvXFx1MjAyOC9nLCAnXFxcXHUyMDI4JylcbiAgICAucmVwbGFjZSgvXFx1MjAyOS9nLCAnXFxcXHUyMDI5Jylcbn1cblxuLyogICovXG5cblxuXG4vLyB0aGVzZSBrZXl3b3JkcyBzaG91bGQgbm90IGFwcGVhciBpbnNpZGUgZXhwcmVzc2lvbnMsIGJ1dCBvcGVyYXRvcnMgbGlrZVxuLy8gdHlwZW9mLCBpbnN0YW5jZW9mIGFuZCBpbiBhcmUgYWxsb3dlZFxudmFyIHByb2hpYml0ZWRLZXl3b3JkUkUgPSBuZXcgUmVnRXhwKCdcXFxcYicgKyAoXG4gICdkbyxpZixmb3IsbGV0LG5ldyx0cnksdmFyLGNhc2UsZWxzZSx3aXRoLGF3YWl0LGJyZWFrLGNhdGNoLGNsYXNzLGNvbnN0LCcgK1xuICAnc3VwZXIsdGhyb3csd2hpbGUseWllbGQsZGVsZXRlLGV4cG9ydCxpbXBvcnQscmV0dXJuLHN3aXRjaCxkZWZhdWx0LCcgK1xuICAnZXh0ZW5kcyxmaW5hbGx5LGNvbnRpbnVlLGRlYnVnZ2VyLGZ1bmN0aW9uLGFyZ3VtZW50cydcbikuc3BsaXQoJywnKS5qb2luKCdcXFxcYnxcXFxcYicpICsgJ1xcXFxiJyk7XG5cbi8vIHRoZXNlIHVuYXJ5IG9wZXJhdG9ycyBzaG91bGQgbm90IGJlIHVzZWQgYXMgcHJvcGVydHkvbWV0aG9kIG5hbWVzXG52YXIgdW5hcnlPcGVyYXRvcnNSRSA9IG5ldyBSZWdFeHAoJ1xcXFxiJyArIChcbiAgJ2RlbGV0ZSx0eXBlb2Ysdm9pZCdcbikuc3BsaXQoJywnKS5qb2luKCdcXFxccypcXFxcKFteXFxcXCldKlxcXFwpfFxcXFxiJykgKyAnXFxcXHMqXFxcXChbXlxcXFwpXSpcXFxcKScpO1xuXG4vLyBzdHJpcCBzdHJpbmdzIGluIGV4cHJlc3Npb25zXG52YXIgc3RyaXBTdHJpbmdSRSA9IC8nKD86W14nXFxcXF18XFxcXC4pKid8XCIoPzpbXlwiXFxcXF18XFxcXC4pKlwifGAoPzpbXmBcXFxcXXxcXFxcLikqXFwkXFx7fFxcfSg/OlteYFxcXFxdfFxcXFwuKSpgfGAoPzpbXmBcXFxcXXxcXFxcLikqYC9nO1xuXG4vLyBkZXRlY3QgcHJvYmxlbWF0aWMgZXhwcmVzc2lvbnMgaW4gYSB0ZW1wbGF0ZVxuZnVuY3Rpb24gZGV0ZWN0RXJyb3JzIChhc3QsIHdhcm4pIHtcbiAgaWYgKGFzdCkge1xuICAgIGNoZWNrTm9kZShhc3QsIHdhcm4pO1xuICB9XG59XG5cbmZ1bmN0aW9uIGNoZWNrTm9kZSAobm9kZSwgd2Fybikge1xuICBpZiAobm9kZS50eXBlID09PSAxKSB7XG4gICAgZm9yICh2YXIgbmFtZSBpbiBub2RlLmF0dHJzTWFwKSB7XG4gICAgICBpZiAoZGlyUkUudGVzdChuYW1lKSkge1xuICAgICAgICB2YXIgdmFsdWUgPSBub2RlLmF0dHJzTWFwW25hbWVdO1xuICAgICAgICBpZiAodmFsdWUpIHtcbiAgICAgICAgICB2YXIgcmFuZ2UgPSBub2RlLnJhd0F0dHJzTWFwW25hbWVdO1xuICAgICAgICAgIGlmIChuYW1lID09PSAndi1mb3InKSB7XG4gICAgICAgICAgICBjaGVja0Zvcihub2RlLCAoXCJ2LWZvcj1cXFwiXCIgKyB2YWx1ZSArIFwiXFxcIlwiKSwgd2FybiwgcmFuZ2UpO1xuICAgICAgICAgIH0gZWxzZSBpZiAob25SRS50ZXN0KG5hbWUpKSB7XG4gICAgICAgICAgICBjaGVja0V2ZW50KHZhbHVlLCAobmFtZSArIFwiPVxcXCJcIiArIHZhbHVlICsgXCJcXFwiXCIpLCB3YXJuLCByYW5nZSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNoZWNrRXhwcmVzc2lvbih2YWx1ZSwgKG5hbWUgKyBcIj1cXFwiXCIgKyB2YWx1ZSArIFwiXFxcIlwiKSwgd2FybiwgcmFuZ2UpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBpZiAobm9kZS5jaGlsZHJlbikge1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBub2RlLmNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNoZWNrTm9kZShub2RlLmNoaWxkcmVuW2ldLCB3YXJuKTtcbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSBpZiAobm9kZS50eXBlID09PSAyKSB7XG4gICAgY2hlY2tFeHByZXNzaW9uKG5vZGUuZXhwcmVzc2lvbiwgbm9kZS50ZXh0LCB3YXJuLCBub2RlKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBjaGVja0V2ZW50IChleHAsIHRleHQsIHdhcm4sIHJhbmdlKSB7XG4gIHZhciBzdGlwcGVkID0gZXhwLnJlcGxhY2Uoc3RyaXBTdHJpbmdSRSwgJycpO1xuICB2YXIga2V5d29yZE1hdGNoID0gc3RpcHBlZC5tYXRjaCh1bmFyeU9wZXJhdG9yc1JFKTtcbiAgaWYgKGtleXdvcmRNYXRjaCAmJiBzdGlwcGVkLmNoYXJBdChrZXl3b3JkTWF0Y2guaW5kZXggLSAxKSAhPT0gJyQnKSB7XG4gICAgd2FybihcbiAgICAgIFwiYXZvaWQgdXNpbmcgSmF2YVNjcmlwdCB1bmFyeSBvcGVyYXRvciBhcyBwcm9wZXJ0eSBuYW1lOiBcIiArXG4gICAgICBcIlxcXCJcIiArIChrZXl3b3JkTWF0Y2hbMF0pICsgXCJcXFwiIGluIGV4cHJlc3Npb24gXCIgKyAodGV4dC50cmltKCkpLFxuICAgICAgcmFuZ2VcbiAgICApO1xuICB9XG4gIGNoZWNrRXhwcmVzc2lvbihleHAsIHRleHQsIHdhcm4sIHJhbmdlKTtcbn1cblxuZnVuY3Rpb24gY2hlY2tGb3IgKG5vZGUsIHRleHQsIHdhcm4sIHJhbmdlKSB7XG4gIGNoZWNrRXhwcmVzc2lvbihub2RlLmZvciB8fCAnJywgdGV4dCwgd2FybiwgcmFuZ2UpO1xuICBjaGVja0lkZW50aWZpZXIobm9kZS5hbGlhcywgJ3YtZm9yIGFsaWFzJywgdGV4dCwgd2FybiwgcmFuZ2UpO1xuICBjaGVja0lkZW50aWZpZXIobm9kZS5pdGVyYXRvcjEsICd2LWZvciBpdGVyYXRvcicsIHRleHQsIHdhcm4sIHJhbmdlKTtcbiAgY2hlY2tJZGVudGlmaWVyKG5vZGUuaXRlcmF0b3IyLCAndi1mb3IgaXRlcmF0b3InLCB0ZXh0LCB3YXJuLCByYW5nZSk7XG59XG5cbmZ1bmN0aW9uIGNoZWNrSWRlbnRpZmllciAoXG4gIGlkZW50LFxuICB0eXBlLFxuICB0ZXh0LFxuICB3YXJuLFxuICByYW5nZVxuKSB7XG4gIGlmICh0eXBlb2YgaWRlbnQgPT09ICdzdHJpbmcnKSB7XG4gICAgdHJ5IHtcbiAgICAgIG5ldyBGdW5jdGlvbigoXCJ2YXIgXCIgKyBpZGVudCArIFwiPV9cIikpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIHdhcm4oKFwiaW52YWxpZCBcIiArIHR5cGUgKyBcIiBcXFwiXCIgKyBpZGVudCArIFwiXFxcIiBpbiBleHByZXNzaW9uOiBcIiArICh0ZXh0LnRyaW0oKSkpLCByYW5nZSk7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGNoZWNrRXhwcmVzc2lvbiAoZXhwLCB0ZXh0LCB3YXJuLCByYW5nZSkge1xuICB0cnkge1xuICAgIG5ldyBGdW5jdGlvbigoXCJyZXR1cm4gXCIgKyBleHApKTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIHZhciBrZXl3b3JkTWF0Y2ggPSBleHAucmVwbGFjZShzdHJpcFN0cmluZ1JFLCAnJykubWF0Y2gocHJvaGliaXRlZEtleXdvcmRSRSk7XG4gICAgaWYgKGtleXdvcmRNYXRjaCkge1xuICAgICAgd2FybihcbiAgICAgICAgXCJhdm9pZCB1c2luZyBKYXZhU2NyaXB0IGtleXdvcmQgYXMgcHJvcGVydHkgbmFtZTogXCIgK1xuICAgICAgICBcIlxcXCJcIiArIChrZXl3b3JkTWF0Y2hbMF0pICsgXCJcXFwiXFxuICBSYXcgZXhwcmVzc2lvbjogXCIgKyAodGV4dC50cmltKCkpLFxuICAgICAgICByYW5nZVxuICAgICAgKTtcbiAgICB9IGVsc2Uge1xuICAgICAgd2FybihcbiAgICAgICAgXCJpbnZhbGlkIGV4cHJlc3Npb246IFwiICsgKGUubWVzc2FnZSkgKyBcIiBpblxcblxcblwiICtcbiAgICAgICAgXCIgICAgXCIgKyBleHAgKyBcIlxcblxcblwiICtcbiAgICAgICAgXCIgIFJhdyBleHByZXNzaW9uOiBcIiArICh0ZXh0LnRyaW0oKSkgKyBcIlxcblwiLFxuICAgICAgICByYW5nZVxuICAgICAgKTtcbiAgICB9XG4gIH1cbn1cblxuLyogICovXG5cbnZhciByYW5nZSA9IDI7XG5cbmZ1bmN0aW9uIGdlbmVyYXRlQ29kZUZyYW1lIChcbiAgc291cmNlLFxuICBzdGFydCxcbiAgZW5kXG4pIHtcbiAgaWYgKCBzdGFydCA9PT0gdm9pZCAwICkgc3RhcnQgPSAwO1xuICBpZiAoIGVuZCA9PT0gdm9pZCAwICkgZW5kID0gc291cmNlLmxlbmd0aDtcblxuICB2YXIgbGluZXMgPSBzb3VyY2Uuc3BsaXQoL1xccj9cXG4vKTtcbiAgdmFyIGNvdW50ID0gMDtcbiAgdmFyIHJlcyA9IFtdO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGxpbmVzLmxlbmd0aDsgaSsrKSB7XG4gICAgY291bnQgKz0gbGluZXNbaV0ubGVuZ3RoICsgMTtcbiAgICBpZiAoY291bnQgPj0gc3RhcnQpIHtcbiAgICAgIGZvciAodmFyIGogPSBpIC0gcmFuZ2U7IGogPD0gaSArIHJhbmdlIHx8IGVuZCA+IGNvdW50OyBqKyspIHtcbiAgICAgICAgaWYgKGogPCAwIHx8IGogPj0gbGluZXMubGVuZ3RoKSB7IGNvbnRpbnVlIH1cbiAgICAgICAgcmVzLnB1c2goKFwiXCIgKyAoaiArIDEpICsgKHJlcGVhdCQxKFwiIFwiLCAzIC0gU3RyaW5nKGogKyAxKS5sZW5ndGgpKSArIFwifCAgXCIgKyAobGluZXNbal0pKSk7XG4gICAgICAgIHZhciBsaW5lTGVuZ3RoID0gbGluZXNbal0ubGVuZ3RoO1xuICAgICAgICBpZiAoaiA9PT0gaSkge1xuICAgICAgICAgIC8vIHB1c2ggdW5kZXJsaW5lXG4gICAgICAgICAgdmFyIHBhZCA9IHN0YXJ0IC0gKGNvdW50IC0gbGluZUxlbmd0aCkgKyAxO1xuICAgICAgICAgIHZhciBsZW5ndGggPSBlbmQgPiBjb3VudCA/IGxpbmVMZW5ndGggLSBwYWQgOiBlbmQgLSBzdGFydDtcbiAgICAgICAgICByZXMucHVzaChcIiAgIHwgIFwiICsgcmVwZWF0JDEoXCIgXCIsIHBhZCkgKyByZXBlYXQkMShcIl5cIiwgbGVuZ3RoKSk7XG4gICAgICAgIH0gZWxzZSBpZiAoaiA+IGkpIHtcbiAgICAgICAgICBpZiAoZW5kID4gY291bnQpIHtcbiAgICAgICAgICAgIHZhciBsZW5ndGgkMSA9IE1hdGgubWluKGVuZCAtIGNvdW50LCBsaW5lTGVuZ3RoKTtcbiAgICAgICAgICAgIHJlcy5wdXNoKFwiICAgfCAgXCIgKyByZXBlYXQkMShcIl5cIiwgbGVuZ3RoJDEpKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgY291bnQgKz0gbGluZUxlbmd0aCArIDE7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGJyZWFrXG4gICAgfVxuICB9XG4gIHJldHVybiByZXMuam9pbignXFxuJylcbn1cblxuZnVuY3Rpb24gcmVwZWF0JDEgKHN0ciwgbikge1xuICB2YXIgcmVzdWx0ID0gJyc7XG4gIGlmIChuID4gMCkge1xuICAgIHdoaWxlICh0cnVlKSB7IC8vIGVzbGludC1kaXNhYmxlLWxpbmVcbiAgICAgIGlmIChuICYgMSkgeyByZXN1bHQgKz0gc3RyOyB9XG4gICAgICBuID4+Pj0gMTtcbiAgICAgIGlmIChuIDw9IDApIHsgYnJlYWsgfVxuICAgICAgc3RyICs9IHN0cjtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc3VsdFxufVxuXG4vKiAgKi9cblxuXG5cbmZ1bmN0aW9uIGNyZWF0ZUZ1bmN0aW9uIChjb2RlLCBlcnJvcnMpIHtcbiAgdHJ5IHtcbiAgICByZXR1cm4gbmV3IEZ1bmN0aW9uKGNvZGUpXG4gIH0gY2F0Y2ggKGVycikge1xuICAgIGVycm9ycy5wdXNoKHsgZXJyOiBlcnIsIGNvZGU6IGNvZGUgfSk7XG4gICAgcmV0dXJuIG5vb3BcbiAgfVxufVxuXG5mdW5jdGlvbiBjcmVhdGVDb21waWxlVG9GdW5jdGlvbkZuIChjb21waWxlKSB7XG4gIHZhciBjYWNoZSA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG5cbiAgcmV0dXJuIGZ1bmN0aW9uIGNvbXBpbGVUb0Z1bmN0aW9ucyAoXG4gICAgdGVtcGxhdGUsXG4gICAgb3B0aW9ucyxcbiAgICB2bVxuICApIHtcbiAgICBvcHRpb25zID0gZXh0ZW5kKHt9LCBvcHRpb25zKTtcbiAgICB2YXIgd2FybiQkMSA9IG9wdGlvbnMud2FybiB8fCB3YXJuO1xuICAgIGRlbGV0ZSBvcHRpb25zLndhcm47XG5cbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgLy8gZGV0ZWN0IHBvc3NpYmxlIENTUCByZXN0cmljdGlvblxuICAgICAgdHJ5IHtcbiAgICAgICAgbmV3IEZ1bmN0aW9uKCdyZXR1cm4gMScpO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBpZiAoZS50b1N0cmluZygpLm1hdGNoKC91bnNhZmUtZXZhbHxDU1AvKSkge1xuICAgICAgICAgIHdhcm4kJDEoXG4gICAgICAgICAgICAnSXQgc2VlbXMgeW91IGFyZSB1c2luZyB0aGUgc3RhbmRhbG9uZSBidWlsZCBvZiBWdWUuanMgaW4gYW4gJyArXG4gICAgICAgICAgICAnZW52aXJvbm1lbnQgd2l0aCBDb250ZW50IFNlY3VyaXR5IFBvbGljeSB0aGF0IHByb2hpYml0cyB1bnNhZmUtZXZhbC4gJyArXG4gICAgICAgICAgICAnVGhlIHRlbXBsYXRlIGNvbXBpbGVyIGNhbm5vdCB3b3JrIGluIHRoaXMgZW52aXJvbm1lbnQuIENvbnNpZGVyICcgK1xuICAgICAgICAgICAgJ3JlbGF4aW5nIHRoZSBwb2xpY3kgdG8gYWxsb3cgdW5zYWZlLWV2YWwgb3IgcHJlLWNvbXBpbGluZyB5b3VyICcgK1xuICAgICAgICAgICAgJ3RlbXBsYXRlcyBpbnRvIHJlbmRlciBmdW5jdGlvbnMuJ1xuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBjaGVjayBjYWNoZVxuICAgIHZhciBrZXkgPSBvcHRpb25zLmRlbGltaXRlcnNcbiAgICAgID8gU3RyaW5nKG9wdGlvbnMuZGVsaW1pdGVycykgKyB0ZW1wbGF0ZVxuICAgICAgOiB0ZW1wbGF0ZTtcbiAgICBpZiAoY2FjaGVba2V5XSkge1xuICAgICAgcmV0dXJuIGNhY2hlW2tleV1cbiAgICB9XG5cbiAgICAvLyBjb21waWxlXG4gICAgdmFyIGNvbXBpbGVkID0gY29tcGlsZSh0ZW1wbGF0ZSwgb3B0aW9ucyk7XG5cbiAgICAvLyBjaGVjayBjb21waWxhdGlvbiBlcnJvcnMvdGlwc1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICBpZiAoY29tcGlsZWQuZXJyb3JzICYmIGNvbXBpbGVkLmVycm9ycy5sZW5ndGgpIHtcbiAgICAgICAgaWYgKG9wdGlvbnMub3V0cHV0U291cmNlUmFuZ2UpIHtcbiAgICAgICAgICBjb21waWxlZC5lcnJvcnMuZm9yRWFjaChmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgd2FybiQkMShcbiAgICAgICAgICAgICAgXCJFcnJvciBjb21waWxpbmcgdGVtcGxhdGU6XFxuXFxuXCIgKyAoZS5tc2cpICsgXCJcXG5cXG5cIiArXG4gICAgICAgICAgICAgIGdlbmVyYXRlQ29kZUZyYW1lKHRlbXBsYXRlLCBlLnN0YXJ0LCBlLmVuZCksXG4gICAgICAgICAgICAgIHZtXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHdhcm4kJDEoXG4gICAgICAgICAgICBcIkVycm9yIGNvbXBpbGluZyB0ZW1wbGF0ZTpcXG5cXG5cIiArIHRlbXBsYXRlICsgXCJcXG5cXG5cIiArXG4gICAgICAgICAgICBjb21waWxlZC5lcnJvcnMubWFwKGZ1bmN0aW9uIChlKSB7IHJldHVybiAoXCItIFwiICsgZSk7IH0pLmpvaW4oJ1xcbicpICsgJ1xcbicsXG4gICAgICAgICAgICB2bVxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChjb21waWxlZC50aXBzICYmIGNvbXBpbGVkLnRpcHMubGVuZ3RoKSB7XG4gICAgICAgIGlmIChvcHRpb25zLm91dHB1dFNvdXJjZVJhbmdlKSB7XG4gICAgICAgICAgY29tcGlsZWQudGlwcy5mb3JFYWNoKGZ1bmN0aW9uIChlKSB7IHJldHVybiB0aXAoZS5tc2csIHZtKTsgfSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY29tcGlsZWQudGlwcy5mb3JFYWNoKGZ1bmN0aW9uIChtc2cpIHsgcmV0dXJuIHRpcChtc2csIHZtKTsgfSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyB0dXJuIGNvZGUgaW50byBmdW5jdGlvbnNcbiAgICB2YXIgcmVzID0ge307XG4gICAgdmFyIGZuR2VuRXJyb3JzID0gW107XG4gICAgcmVzLnJlbmRlciA9IGNyZWF0ZUZ1bmN0aW9uKGNvbXBpbGVkLnJlbmRlciwgZm5HZW5FcnJvcnMpO1xuICAgIHJlcy5zdGF0aWNSZW5kZXJGbnMgPSBjb21waWxlZC5zdGF0aWNSZW5kZXJGbnMubWFwKGZ1bmN0aW9uIChjb2RlKSB7XG4gICAgICByZXR1cm4gY3JlYXRlRnVuY3Rpb24oY29kZSwgZm5HZW5FcnJvcnMpXG4gICAgfSk7XG5cbiAgICAvLyBjaGVjayBmdW5jdGlvbiBnZW5lcmF0aW9uIGVycm9ycy5cbiAgICAvLyB0aGlzIHNob3VsZCBvbmx5IGhhcHBlbiBpZiB0aGVyZSBpcyBhIGJ1ZyBpbiB0aGUgY29tcGlsZXIgaXRzZWxmLlxuICAgIC8vIG1vc3RseSBmb3IgY29kZWdlbiBkZXZlbG9wbWVudCB1c2VcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgaWYgKCghY29tcGlsZWQuZXJyb3JzIHx8ICFjb21waWxlZC5lcnJvcnMubGVuZ3RoKSAmJiBmbkdlbkVycm9ycy5sZW5ndGgpIHtcbiAgICAgICAgd2FybiQkMShcbiAgICAgICAgICBcIkZhaWxlZCB0byBnZW5lcmF0ZSByZW5kZXIgZnVuY3Rpb246XFxuXFxuXCIgK1xuICAgICAgICAgIGZuR2VuRXJyb3JzLm1hcChmdW5jdGlvbiAocmVmKSB7XG4gICAgICAgICAgICB2YXIgZXJyID0gcmVmLmVycjtcbiAgICAgICAgICAgIHZhciBjb2RlID0gcmVmLmNvZGU7XG5cbiAgICAgICAgICAgIHJldHVybiAoKGVyci50b1N0cmluZygpKSArIFwiIGluXFxuXFxuXCIgKyBjb2RlICsgXCJcXG5cIik7XG4gICAgICAgIH0pLmpvaW4oJ1xcbicpLFxuICAgICAgICAgIHZtXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIChjYWNoZVtrZXldID0gcmVzKVxuICB9XG59XG5cbi8qICAqL1xuXG5mdW5jdGlvbiBjcmVhdGVDb21waWxlckNyZWF0b3IgKGJhc2VDb21waWxlKSB7XG4gIHJldHVybiBmdW5jdGlvbiBjcmVhdGVDb21waWxlciAoYmFzZU9wdGlvbnMpIHtcbiAgICBmdW5jdGlvbiBjb21waWxlIChcbiAgICAgIHRlbXBsYXRlLFxuICAgICAgb3B0aW9uc1xuICAgICkge1xuICAgICAgdmFyIGZpbmFsT3B0aW9ucyA9IE9iamVjdC5jcmVhdGUoYmFzZU9wdGlvbnMpO1xuICAgICAgdmFyIGVycm9ycyA9IFtdO1xuICAgICAgdmFyIHRpcHMgPSBbXTtcblxuICAgICAgdmFyIHdhcm4gPSBmdW5jdGlvbiAobXNnLCByYW5nZSwgdGlwKSB7XG4gICAgICAgICh0aXAgPyB0aXBzIDogZXJyb3JzKS5wdXNoKG1zZyk7XG4gICAgICB9O1xuXG4gICAgICBpZiAob3B0aW9ucykge1xuICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiBvcHRpb25zLm91dHB1dFNvdXJjZVJhbmdlKSB7XG4gICAgICAgICAgLy8gJGZsb3ctZGlzYWJsZS1saW5lXG4gICAgICAgICAgdmFyIGxlYWRpbmdTcGFjZUxlbmd0aCA9IHRlbXBsYXRlLm1hdGNoKC9eXFxzKi8pWzBdLmxlbmd0aDtcblxuICAgICAgICAgIHdhcm4gPSBmdW5jdGlvbiAobXNnLCByYW5nZSwgdGlwKSB7XG4gICAgICAgICAgICB2YXIgZGF0YSA9IHsgbXNnOiBtc2cgfTtcbiAgICAgICAgICAgIGlmIChyYW5nZSkge1xuICAgICAgICAgICAgICBpZiAocmFuZ2Uuc3RhcnQgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGRhdGEuc3RhcnQgPSByYW5nZS5zdGFydCArIGxlYWRpbmdTcGFjZUxlbmd0aDtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBpZiAocmFuZ2UuZW5kICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICBkYXRhLmVuZCA9IHJhbmdlLmVuZCArIGxlYWRpbmdTcGFjZUxlbmd0aDtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgKHRpcCA/IHRpcHMgOiBlcnJvcnMpLnB1c2goZGF0YSk7XG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICAvLyBtZXJnZSBjdXN0b20gbW9kdWxlc1xuICAgICAgICBpZiAob3B0aW9ucy5tb2R1bGVzKSB7XG4gICAgICAgICAgZmluYWxPcHRpb25zLm1vZHVsZXMgPVxuICAgICAgICAgICAgKGJhc2VPcHRpb25zLm1vZHVsZXMgfHwgW10pLmNvbmNhdChvcHRpb25zLm1vZHVsZXMpO1xuICAgICAgICB9XG4gICAgICAgIC8vIG1lcmdlIGN1c3RvbSBkaXJlY3RpdmVzXG4gICAgICAgIGlmIChvcHRpb25zLmRpcmVjdGl2ZXMpIHtcbiAgICAgICAgICBmaW5hbE9wdGlvbnMuZGlyZWN0aXZlcyA9IGV4dGVuZChcbiAgICAgICAgICAgIE9iamVjdC5jcmVhdGUoYmFzZU9wdGlvbnMuZGlyZWN0aXZlcyB8fCBudWxsKSxcbiAgICAgICAgICAgIG9wdGlvbnMuZGlyZWN0aXZlc1xuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gY29weSBvdGhlciBvcHRpb25zXG4gICAgICAgIGZvciAodmFyIGtleSBpbiBvcHRpb25zKSB7XG4gICAgICAgICAgaWYgKGtleSAhPT0gJ21vZHVsZXMnICYmIGtleSAhPT0gJ2RpcmVjdGl2ZXMnKSB7XG4gICAgICAgICAgICBmaW5hbE9wdGlvbnNba2V5XSA9IG9wdGlvbnNba2V5XTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgZmluYWxPcHRpb25zLndhcm4gPSB3YXJuO1xuXG4gICAgICB2YXIgY29tcGlsZWQgPSBiYXNlQ29tcGlsZSh0ZW1wbGF0ZS50cmltKCksIGZpbmFsT3B0aW9ucyk7XG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICBkZXRlY3RFcnJvcnMoY29tcGlsZWQuYXN0LCB3YXJuKTtcbiAgICAgIH1cbiAgICAgIGNvbXBpbGVkLmVycm9ycyA9IGVycm9ycztcbiAgICAgIGNvbXBpbGVkLnRpcHMgPSB0aXBzO1xuICAgICAgcmV0dXJuIGNvbXBpbGVkXG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgIGNvbXBpbGU6IGNvbXBpbGUsXG4gICAgICBjb21waWxlVG9GdW5jdGlvbnM6IGNyZWF0ZUNvbXBpbGVUb0Z1bmN0aW9uRm4oY29tcGlsZSlcbiAgICB9XG4gIH1cbn1cblxuLyogICovXG5cbi8vIGBjcmVhdGVDb21waWxlckNyZWF0b3JgIGFsbG93cyBjcmVhdGluZyBjb21waWxlcnMgdGhhdCB1c2UgYWx0ZXJuYXRpdmVcbi8vIHBhcnNlci9vcHRpbWl6ZXIvY29kZWdlbiwgZS5nIHRoZSBTU1Igb3B0aW1pemluZyBjb21waWxlci5cbi8vIEhlcmUgd2UganVzdCBleHBvcnQgYSBkZWZhdWx0IGNvbXBpbGVyIHVzaW5nIHRoZSBkZWZhdWx0IHBhcnRzLlxudmFyIGNyZWF0ZUNvbXBpbGVyID0gY3JlYXRlQ29tcGlsZXJDcmVhdG9yKGZ1bmN0aW9uIGJhc2VDb21waWxlIChcbiAgdGVtcGxhdGUsXG4gIG9wdGlvbnNcbikge1xuICB2YXIgYXN0ID0gcGFyc2UodGVtcGxhdGUudHJpbSgpLCBvcHRpb25zKTtcbiAgaWYgKG9wdGlvbnMub3B0aW1pemUgIT09IGZhbHNlKSB7XG4gICAgb3B0aW1pemUoYXN0LCBvcHRpb25zKTtcbiAgfVxuICB2YXIgY29kZSA9IGdlbmVyYXRlKGFzdCwgb3B0aW9ucyk7XG4gIHJldHVybiB7XG4gICAgYXN0OiBhc3QsXG4gICAgcmVuZGVyOiBjb2RlLnJlbmRlcixcbiAgICBzdGF0aWNSZW5kZXJGbnM6IGNvZGUuc3RhdGljUmVuZGVyRm5zXG4gIH1cbn0pO1xuXG4vKiAgKi9cblxudmFyIHJlZiQxID0gY3JlYXRlQ29tcGlsZXIoYmFzZU9wdGlvbnMpO1xudmFyIGNvbXBpbGUgPSByZWYkMS5jb21waWxlO1xudmFyIGNvbXBpbGVUb0Z1bmN0aW9ucyA9IHJlZiQxLmNvbXBpbGVUb0Z1bmN0aW9ucztcblxuLyogICovXG5cbi8vIGNoZWNrIHdoZXRoZXIgY3VycmVudCBicm93c2VyIGVuY29kZXMgYSBjaGFyIGluc2lkZSBhdHRyaWJ1dGUgdmFsdWVzXG52YXIgZGl2O1xuZnVuY3Rpb24gZ2V0U2hvdWxkRGVjb2RlIChocmVmKSB7XG4gIGRpdiA9IGRpdiB8fCBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgZGl2LmlubmVySFRNTCA9IGhyZWYgPyBcIjxhIGhyZWY9XFxcIlxcblxcXCIvPlwiIDogXCI8ZGl2IGE9XFxcIlxcblxcXCIvPlwiO1xuICByZXR1cm4gZGl2LmlubmVySFRNTC5pbmRleE9mKCcmIzEwOycpID4gMFxufVxuXG4vLyAjMzY2MzogSUUgZW5jb2RlcyBuZXdsaW5lcyBpbnNpZGUgYXR0cmlidXRlIHZhbHVlcyB3aGlsZSBvdGhlciBicm93c2VycyBkb24ndFxudmFyIHNob3VsZERlY29kZU5ld2xpbmVzID0gaW5Ccm93c2VyID8gZ2V0U2hvdWxkRGVjb2RlKGZhbHNlKSA6IGZhbHNlO1xuLy8gIzY4Mjg6IGNocm9tZSBlbmNvZGVzIGNvbnRlbnQgaW4gYVtocmVmXVxudmFyIHNob3VsZERlY29kZU5ld2xpbmVzRm9ySHJlZiA9IGluQnJvd3NlciA/IGdldFNob3VsZERlY29kZSh0cnVlKSA6IGZhbHNlO1xuXG4vKiAgKi9cblxudmFyIGlkVG9UZW1wbGF0ZSA9IGNhY2hlZChmdW5jdGlvbiAoaWQpIHtcbiAgdmFyIGVsID0gcXVlcnkoaWQpO1xuICByZXR1cm4gZWwgJiYgZWwuaW5uZXJIVE1MXG59KTtcblxudmFyIG1vdW50ID0gVnVlLnByb3RvdHlwZS4kbW91bnQ7XG5WdWUucHJvdG90eXBlLiRtb3VudCA9IGZ1bmN0aW9uIChcbiAgZWwsXG4gIGh5ZHJhdGluZ1xuKSB7XG4gIGVsID0gZWwgJiYgcXVlcnkoZWwpO1xuXG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICBpZiAoZWwgPT09IGRvY3VtZW50LmJvZHkgfHwgZWwgPT09IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudCkge1xuICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgd2FybihcbiAgICAgIFwiRG8gbm90IG1vdW50IFZ1ZSB0byA8aHRtbD4gb3IgPGJvZHk+IC0gbW91bnQgdG8gbm9ybWFsIGVsZW1lbnRzIGluc3RlYWQuXCJcbiAgICApO1xuICAgIHJldHVybiB0aGlzXG4gIH1cblxuICB2YXIgb3B0aW9ucyA9IHRoaXMuJG9wdGlvbnM7XG4gIC8vIHJlc29sdmUgdGVtcGxhdGUvZWwgYW5kIGNvbnZlcnQgdG8gcmVuZGVyIGZ1bmN0aW9uXG4gIGlmICghb3B0aW9ucy5yZW5kZXIpIHtcbiAgICB2YXIgdGVtcGxhdGUgPSBvcHRpb25zLnRlbXBsYXRlO1xuICAgIGlmICh0ZW1wbGF0ZSkge1xuICAgICAgaWYgKHR5cGVvZiB0ZW1wbGF0ZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgaWYgKHRlbXBsYXRlLmNoYXJBdCgwKSA9PT0gJyMnKSB7XG4gICAgICAgICAgdGVtcGxhdGUgPSBpZFRvVGVtcGxhdGUodGVtcGxhdGUpO1xuICAgICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmICF0ZW1wbGF0ZSkge1xuICAgICAgICAgICAgd2FybihcbiAgICAgICAgICAgICAgKFwiVGVtcGxhdGUgZWxlbWVudCBub3QgZm91bmQgb3IgaXMgZW1wdHk6IFwiICsgKG9wdGlvbnMudGVtcGxhdGUpKSxcbiAgICAgICAgICAgICAgdGhpc1xuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAodGVtcGxhdGUubm9kZVR5cGUpIHtcbiAgICAgICAgdGVtcGxhdGUgPSB0ZW1wbGF0ZS5pbm5lckhUTUw7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICAgIHdhcm4oJ2ludmFsaWQgdGVtcGxhdGUgb3B0aW9uOicgKyB0ZW1wbGF0ZSwgdGhpcyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXNcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGVsKSB7XG4gICAgICB0ZW1wbGF0ZSA9IGdldE91dGVySFRNTChlbCk7XG4gICAgfVxuICAgIGlmICh0ZW1wbGF0ZSkge1xuICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiBjb25maWcucGVyZm9ybWFuY2UgJiYgbWFyaykge1xuICAgICAgICBtYXJrKCdjb21waWxlJyk7XG4gICAgICB9XG5cbiAgICAgIHZhciByZWYgPSBjb21waWxlVG9GdW5jdGlvbnModGVtcGxhdGUsIHtcbiAgICAgICAgb3V0cHV0U291cmNlUmFuZ2U6IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicsXG4gICAgICAgIHNob3VsZERlY29kZU5ld2xpbmVzOiBzaG91bGREZWNvZGVOZXdsaW5lcyxcbiAgICAgICAgc2hvdWxkRGVjb2RlTmV3bGluZXNGb3JIcmVmOiBzaG91bGREZWNvZGVOZXdsaW5lc0ZvckhyZWYsXG4gICAgICAgIGRlbGltaXRlcnM6IG9wdGlvbnMuZGVsaW1pdGVycyxcbiAgICAgICAgY29tbWVudHM6IG9wdGlvbnMuY29tbWVudHNcbiAgICAgIH0sIHRoaXMpO1xuICAgICAgdmFyIHJlbmRlciA9IHJlZi5yZW5kZXI7XG4gICAgICB2YXIgc3RhdGljUmVuZGVyRm5zID0gcmVmLnN0YXRpY1JlbmRlckZucztcbiAgICAgIG9wdGlvbnMucmVuZGVyID0gcmVuZGVyO1xuICAgICAgb3B0aW9ucy5zdGF0aWNSZW5kZXJGbnMgPSBzdGF0aWNSZW5kZXJGbnM7XG5cbiAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgY29uZmlnLnBlcmZvcm1hbmNlICYmIG1hcmspIHtcbiAgICAgICAgbWFyaygnY29tcGlsZSBlbmQnKTtcbiAgICAgICAgbWVhc3VyZSgoXCJ2dWUgXCIgKyAodGhpcy5fbmFtZSkgKyBcIiBjb21waWxlXCIpLCAnY29tcGlsZScsICdjb21waWxlIGVuZCcpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gbW91bnQuY2FsbCh0aGlzLCBlbCwgaHlkcmF0aW5nKVxufTtcblxuLyoqXG4gKiBHZXQgb3V0ZXJIVE1MIG9mIGVsZW1lbnRzLCB0YWtpbmcgY2FyZVxuICogb2YgU1ZHIGVsZW1lbnRzIGluIElFIGFzIHdlbGwuXG4gKi9cbmZ1bmN0aW9uIGdldE91dGVySFRNTCAoZWwpIHtcbiAgaWYgKGVsLm91dGVySFRNTCkge1xuICAgIHJldHVybiBlbC5vdXRlckhUTUxcbiAgfSBlbHNlIHtcbiAgICB2YXIgY29udGFpbmVyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgY29udGFpbmVyLmFwcGVuZENoaWxkKGVsLmNsb25lTm9kZSh0cnVlKSk7XG4gICAgcmV0dXJuIGNvbnRhaW5lci5pbm5lckhUTUxcbiAgfVxufVxuXG5WdWUuY29tcGlsZSA9IGNvbXBpbGVUb0Z1bmN0aW9ucztcblxuZXhwb3J0IGRlZmF1bHQgVnVlO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvdnVlL2Rpc3QvdnVlLmVzbS5qc1xuLy8gbW9kdWxlIGlkID0gMTEzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///113\n");

/***/ }),
/* 114 */
/***/ (function(module, exports, __webpack_require__) {

eval("/* WEBPACK VAR INJECTION */(function(global) {var scope = (typeof global !== \"undefined\" && global) ||\n            (typeof self !== \"undefined\" && self) ||\n            window;\nvar apply = Function.prototype.apply;\n\n// DOM APIs, for completeness\n\nexports.setTimeout = function() {\n  return new Timeout(apply.call(setTimeout, scope, arguments), clearTimeout);\n};\nexports.setInterval = function() {\n  return new Timeout(apply.call(setInterval, scope, arguments), clearInterval);\n};\nexports.clearTimeout =\nexports.clearInterval = function(timeout) {\n  if (timeout) {\n    timeout.close();\n  }\n};\n\nfunction Timeout(id, clearFn) {\n  this._id = id;\n  this._clearFn = clearFn;\n}\nTimeout.prototype.unref = Timeout.prototype.ref = function() {};\nTimeout.prototype.close = function() {\n  this._clearFn.call(scope, this._id);\n};\n\n// Does not start the time, just sets up the members needed.\nexports.enroll = function(item, msecs) {\n  clearTimeout(item._idleTimeoutId);\n  item._idleTimeout = msecs;\n};\n\nexports.unenroll = function(item) {\n  clearTimeout(item._idleTimeoutId);\n  item._idleTimeout = -1;\n};\n\nexports._unrefActive = exports.active = function(item) {\n  clearTimeout(item._idleTimeoutId);\n\n  var msecs = item._idleTimeout;\n  if (msecs >= 0) {\n    item._idleTimeoutId = setTimeout(function onTimeout() {\n      if (item._onTimeout)\n        item._onTimeout();\n    }, msecs);\n  }\n};\n\n// setimmediate attaches itself to the global object\n__webpack_require__(115);\n// On some exotic environments, it's not clear which object `setimmediate` was\n// able to install onto.  Search each possibility in the same order as the\n// `setimmediate` library.\nexports.setImmediate = (typeof self !== \"undefined\" && self.setImmediate) ||\n                       (typeof global !== \"undefined\" && global.setImmediate) ||\n                       (this && this.setImmediate);\nexports.clearImmediate = (typeof self !== \"undefined\" && self.clearImmediate) ||\n                         (typeof global !== \"undefined\" && global.clearImmediate) ||\n                         (this && this.clearImmediate);\n\n/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(32)))\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvdGltZXJzLWJyb3dzZXJpZnkvbWFpbi5qcz9kN2FkIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQSxtQkFBTyxDQUFDLEdBQWM7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwiZmlsZSI6IjExNC5qcyIsInNvdXJjZXNDb250ZW50IjpbInZhciBzY29wZSA9ICh0eXBlb2YgZ2xvYmFsICE9PSBcInVuZGVmaW5lZFwiICYmIGdsb2JhbCkgfHxcbiAgICAgICAgICAgICh0eXBlb2Ygc2VsZiAhPT0gXCJ1bmRlZmluZWRcIiAmJiBzZWxmKSB8fFxuICAgICAgICAgICAgd2luZG93O1xudmFyIGFwcGx5ID0gRnVuY3Rpb24ucHJvdG90eXBlLmFwcGx5O1xuXG4vLyBET00gQVBJcywgZm9yIGNvbXBsZXRlbmVzc1xuXG5leHBvcnRzLnNldFRpbWVvdXQgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIG5ldyBUaW1lb3V0KGFwcGx5LmNhbGwoc2V0VGltZW91dCwgc2NvcGUsIGFyZ3VtZW50cyksIGNsZWFyVGltZW91dCk7XG59O1xuZXhwb3J0cy5zZXRJbnRlcnZhbCA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gbmV3IFRpbWVvdXQoYXBwbHkuY2FsbChzZXRJbnRlcnZhbCwgc2NvcGUsIGFyZ3VtZW50cyksIGNsZWFySW50ZXJ2YWwpO1xufTtcbmV4cG9ydHMuY2xlYXJUaW1lb3V0ID1cbmV4cG9ydHMuY2xlYXJJbnRlcnZhbCA9IGZ1bmN0aW9uKHRpbWVvdXQpIHtcbiAgaWYgKHRpbWVvdXQpIHtcbiAgICB0aW1lb3V0LmNsb3NlKCk7XG4gIH1cbn07XG5cbmZ1bmN0aW9uIFRpbWVvdXQoaWQsIGNsZWFyRm4pIHtcbiAgdGhpcy5faWQgPSBpZDtcbiAgdGhpcy5fY2xlYXJGbiA9IGNsZWFyRm47XG59XG5UaW1lb3V0LnByb3RvdHlwZS51bnJlZiA9IFRpbWVvdXQucHJvdG90eXBlLnJlZiA9IGZ1bmN0aW9uKCkge307XG5UaW1lb3V0LnByb3RvdHlwZS5jbG9zZSA9IGZ1bmN0aW9uKCkge1xuICB0aGlzLl9jbGVhckZuLmNhbGwoc2NvcGUsIHRoaXMuX2lkKTtcbn07XG5cbi8vIERvZXMgbm90IHN0YXJ0IHRoZSB0aW1lLCBqdXN0IHNldHMgdXAgdGhlIG1lbWJlcnMgbmVlZGVkLlxuZXhwb3J0cy5lbnJvbGwgPSBmdW5jdGlvbihpdGVtLCBtc2Vjcykge1xuICBjbGVhclRpbWVvdXQoaXRlbS5faWRsZVRpbWVvdXRJZCk7XG4gIGl0ZW0uX2lkbGVUaW1lb3V0ID0gbXNlY3M7XG59O1xuXG5leHBvcnRzLnVuZW5yb2xsID0gZnVuY3Rpb24oaXRlbSkge1xuICBjbGVhclRpbWVvdXQoaXRlbS5faWRsZVRpbWVvdXRJZCk7XG4gIGl0ZW0uX2lkbGVUaW1lb3V0ID0gLTE7XG59O1xuXG5leHBvcnRzLl91bnJlZkFjdGl2ZSA9IGV4cG9ydHMuYWN0aXZlID0gZnVuY3Rpb24oaXRlbSkge1xuICBjbGVhclRpbWVvdXQoaXRlbS5faWRsZVRpbWVvdXRJZCk7XG5cbiAgdmFyIG1zZWNzID0gaXRlbS5faWRsZVRpbWVvdXQ7XG4gIGlmIChtc2VjcyA+PSAwKSB7XG4gICAgaXRlbS5faWRsZVRpbWVvdXRJZCA9IHNldFRpbWVvdXQoZnVuY3Rpb24gb25UaW1lb3V0KCkge1xuICAgICAgaWYgKGl0ZW0uX29uVGltZW91dClcbiAgICAgICAgaXRlbS5fb25UaW1lb3V0KCk7XG4gICAgfSwgbXNlY3MpO1xuICB9XG59O1xuXG4vLyBzZXRpbW1lZGlhdGUgYXR0YWNoZXMgaXRzZWxmIHRvIHRoZSBnbG9iYWwgb2JqZWN0XG5yZXF1aXJlKFwic2V0aW1tZWRpYXRlXCIpO1xuLy8gT24gc29tZSBleG90aWMgZW52aXJvbm1lbnRzLCBpdCdzIG5vdCBjbGVhciB3aGljaCBvYmplY3QgYHNldGltbWVkaWF0ZWAgd2FzXG4vLyBhYmxlIHRvIGluc3RhbGwgb250by4gIFNlYXJjaCBlYWNoIHBvc3NpYmlsaXR5IGluIHRoZSBzYW1lIG9yZGVyIGFzIHRoZVxuLy8gYHNldGltbWVkaWF0ZWAgbGlicmFyeS5cbmV4cG9ydHMuc2V0SW1tZWRpYXRlID0gKHR5cGVvZiBzZWxmICE9PSBcInVuZGVmaW5lZFwiICYmIHNlbGYuc2V0SW1tZWRpYXRlKSB8fFxuICAgICAgICAgICAgICAgICAgICAgICAodHlwZW9mIGdsb2JhbCAhPT0gXCJ1bmRlZmluZWRcIiAmJiBnbG9iYWwuc2V0SW1tZWRpYXRlKSB8fFxuICAgICAgICAgICAgICAgICAgICAgICAodGhpcyAmJiB0aGlzLnNldEltbWVkaWF0ZSk7XG5leHBvcnRzLmNsZWFySW1tZWRpYXRlID0gKHR5cGVvZiBzZWxmICE9PSBcInVuZGVmaW5lZFwiICYmIHNlbGYuY2xlYXJJbW1lZGlhdGUpIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAgKHR5cGVvZiBnbG9iYWwgIT09IFwidW5kZWZpbmVkXCIgJiYgZ2xvYmFsLmNsZWFySW1tZWRpYXRlKSB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgICh0aGlzICYmIHRoaXMuY2xlYXJJbW1lZGlhdGUpO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvdGltZXJzLWJyb3dzZXJpZnkvbWFpbi5qc1xuLy8gbW9kdWxlIGlkID0gMTE0XG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///114\n");

/***/ }),
/* 115 */
/***/ (function(module, exports, __webpack_require__) {

eval("/* WEBPACK VAR INJECTION */(function(global, process) {(function (global, undefined) {\n    \"use strict\";\n\n    if (global.setImmediate) {\n        return;\n    }\n\n    var nextHandle = 1; // Spec says greater than zero\n    var tasksByHandle = {};\n    var currentlyRunningATask = false;\n    var doc = global.document;\n    var registerImmediate;\n\n    function setImmediate(callback) {\n      // Callback can either be a function or a string\n      if (typeof callback !== \"function\") {\n        callback = new Function(\"\" + callback);\n      }\n      // Copy function arguments\n      var args = new Array(arguments.length - 1);\n      for (var i = 0; i < args.length; i++) {\n          args[i] = arguments[i + 1];\n      }\n      // Store and register the task\n      var task = { callback: callback, args: args };\n      tasksByHandle[nextHandle] = task;\n      registerImmediate(nextHandle);\n      return nextHandle++;\n    }\n\n    function clearImmediate(handle) {\n        delete tasksByHandle[handle];\n    }\n\n    function run(task) {\n        var callback = task.callback;\n        var args = task.args;\n        switch (args.length) {\n        case 0:\n            callback();\n            break;\n        case 1:\n            callback(args[0]);\n            break;\n        case 2:\n            callback(args[0], args[1]);\n            break;\n        case 3:\n            callback(args[0], args[1], args[2]);\n            break;\n        default:\n            callback.apply(undefined, args);\n            break;\n        }\n    }\n\n    function runIfPresent(handle) {\n        // From the spec: \"Wait until any invocations of this algorithm started before this one have completed.\"\n        // So if we're currently running a task, we'll need to delay this invocation.\n        if (currentlyRunningATask) {\n            // Delay by doing a setTimeout. setImmediate was tried instead, but in Firefox 7 it generated a\n            // \"too much recursion\" error.\n            setTimeout(runIfPresent, 0, handle);\n        } else {\n            var task = tasksByHandle[handle];\n            if (task) {\n                currentlyRunningATask = true;\n                try {\n                    run(task);\n                } finally {\n                    clearImmediate(handle);\n                    currentlyRunningATask = false;\n                }\n            }\n        }\n    }\n\n    function installNextTickImplementation() {\n        registerImmediate = function(handle) {\n            process.nextTick(function () { runIfPresent(handle); });\n        };\n    }\n\n    function canUsePostMessage() {\n        // The test against `importScripts` prevents this implementation from being installed inside a web worker,\n        // where `global.postMessage` means something completely different and can't be used for this purpose.\n        if (global.postMessage && !global.importScripts) {\n            var postMessageIsAsynchronous = true;\n            var oldOnMessage = global.onmessage;\n            global.onmessage = function() {\n                postMessageIsAsynchronous = false;\n            };\n            global.postMessage(\"\", \"*\");\n            global.onmessage = oldOnMessage;\n            return postMessageIsAsynchronous;\n        }\n    }\n\n    function installPostMessageImplementation() {\n        // Installs an event handler on `global` for the `message` event: see\n        // * https://developer.mozilla.org/en/DOM/window.postMessage\n        // * http://www.whatwg.org/specs/web-apps/current-work/multipage/comms.html#crossDocumentMessages\n\n        var messagePrefix = \"setImmediate$\" + Math.random() + \"$\";\n        var onGlobalMessage = function(event) {\n            if (event.source === global &&\n                typeof event.data === \"string\" &&\n                event.data.indexOf(messagePrefix) === 0) {\n                runIfPresent(+event.data.slice(messagePrefix.length));\n            }\n        };\n\n        if (global.addEventListener) {\n            global.addEventListener(\"message\", onGlobalMessage, false);\n        } else {\n            global.attachEvent(\"onmessage\", onGlobalMessage);\n        }\n\n        registerImmediate = function(handle) {\n            global.postMessage(messagePrefix + handle, \"*\");\n        };\n    }\n\n    function installMessageChannelImplementation() {\n        var channel = new MessageChannel();\n        channel.port1.onmessage = function(event) {\n            var handle = event.data;\n            runIfPresent(handle);\n        };\n\n        registerImmediate = function(handle) {\n            channel.port2.postMessage(handle);\n        };\n    }\n\n    function installReadyStateChangeImplementation() {\n        var html = doc.documentElement;\n        registerImmediate = function(handle) {\n            // Create a <script> element; its readystatechange event will be fired asynchronously once it is inserted\n            // into the document. Do so, thus queuing up the task. Remember to clean up once it's been called.\n            var script = doc.createElement(\"script\");\n            script.onreadystatechange = function () {\n                runIfPresent(handle);\n                script.onreadystatechange = null;\n                html.removeChild(script);\n                script = null;\n            };\n            html.appendChild(script);\n        };\n    }\n\n    function installSetTimeoutImplementation() {\n        registerImmediate = function(handle) {\n            setTimeout(runIfPresent, 0, handle);\n        };\n    }\n\n    // If supported, we should attach to the prototype of global, since that is where setTimeout et al. live.\n    var attachTo = Object.getPrototypeOf && Object.getPrototypeOf(global);\n    attachTo = attachTo && attachTo.setTimeout ? attachTo : global;\n\n    // Don't get fooled by e.g. browserify environments.\n    if ({}.toString.call(global.process) === \"[object process]\") {\n        // For Node.js before 0.9\n        installNextTickImplementation();\n\n    } else if (canUsePostMessage()) {\n        // For non-IE10 modern browsers\n        installPostMessageImplementation();\n\n    } else if (global.MessageChannel) {\n        // For web workers, where supported\n        installMessageChannelImplementation();\n\n    } else if (doc && \"onreadystatechange\" in doc.createElement(\"script\")) {\n        // For IE 6–8\n        installReadyStateChangeImplementation();\n\n    } else {\n        // For older browsers\n        installSetTimeoutImplementation();\n    }\n\n    attachTo.setImmediate = setImmediate;\n    attachTo.clearImmediate = clearImmediate;\n}(typeof self === \"undefined\" ? typeof global === \"undefined\" ? this : global : self));\n\n/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(32), __webpack_require__(11)))\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvc2V0aW1tZWRpYXRlL3NldEltbWVkaWF0ZS5qcz85YjJhIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLHVCQUF1QjtBQUN2QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixpQkFBaUI7QUFDdEM7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDBDQUEwQyxzQkFBc0IsRUFBRTtBQUNsRTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QztBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7O0FBRUEsS0FBSztBQUNMO0FBQ0E7O0FBRUEsS0FBSztBQUNMO0FBQ0E7O0FBRUEsS0FBSztBQUNMO0FBQ0E7O0FBRUEsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsQ0FBQyIsImZpbGUiOiIxMTUuanMiLCJzb3VyY2VzQ29udGVudCI6WyIoZnVuY3Rpb24gKGdsb2JhbCwgdW5kZWZpbmVkKSB7XG4gICAgXCJ1c2Ugc3RyaWN0XCI7XG5cbiAgICBpZiAoZ2xvYmFsLnNldEltbWVkaWF0ZSkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIG5leHRIYW5kbGUgPSAxOyAvLyBTcGVjIHNheXMgZ3JlYXRlciB0aGFuIHplcm9cbiAgICB2YXIgdGFza3NCeUhhbmRsZSA9IHt9O1xuICAgIHZhciBjdXJyZW50bHlSdW5uaW5nQVRhc2sgPSBmYWxzZTtcbiAgICB2YXIgZG9jID0gZ2xvYmFsLmRvY3VtZW50O1xuICAgIHZhciByZWdpc3RlckltbWVkaWF0ZTtcblxuICAgIGZ1bmN0aW9uIHNldEltbWVkaWF0ZShjYWxsYmFjaykge1xuICAgICAgLy8gQ2FsbGJhY2sgY2FuIGVpdGhlciBiZSBhIGZ1bmN0aW9uIG9yIGEgc3RyaW5nXG4gICAgICBpZiAodHlwZW9mIGNhbGxiYWNrICE9PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgY2FsbGJhY2sgPSBuZXcgRnVuY3Rpb24oXCJcIiArIGNhbGxiYWNrKTtcbiAgICAgIH1cbiAgICAgIC8vIENvcHkgZnVuY3Rpb24gYXJndW1lbnRzXG4gICAgICB2YXIgYXJncyA9IG5ldyBBcnJheShhcmd1bWVudHMubGVuZ3RoIC0gMSk7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFyZ3MubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBhcmdzW2ldID0gYXJndW1lbnRzW2kgKyAxXTtcbiAgICAgIH1cbiAgICAgIC8vIFN0b3JlIGFuZCByZWdpc3RlciB0aGUgdGFza1xuICAgICAgdmFyIHRhc2sgPSB7IGNhbGxiYWNrOiBjYWxsYmFjaywgYXJnczogYXJncyB9O1xuICAgICAgdGFza3NCeUhhbmRsZVtuZXh0SGFuZGxlXSA9IHRhc2s7XG4gICAgICByZWdpc3RlckltbWVkaWF0ZShuZXh0SGFuZGxlKTtcbiAgICAgIHJldHVybiBuZXh0SGFuZGxlKys7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY2xlYXJJbW1lZGlhdGUoaGFuZGxlKSB7XG4gICAgICAgIGRlbGV0ZSB0YXNrc0J5SGFuZGxlW2hhbmRsZV07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcnVuKHRhc2spIHtcbiAgICAgICAgdmFyIGNhbGxiYWNrID0gdGFzay5jYWxsYmFjaztcbiAgICAgICAgdmFyIGFyZ3MgPSB0YXNrLmFyZ3M7XG4gICAgICAgIHN3aXRjaCAoYXJncy5sZW5ndGgpIHtcbiAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgY2FsbGJhY2soKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICBjYWxsYmFjayhhcmdzWzBdKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICBjYWxsYmFjayhhcmdzWzBdLCBhcmdzWzFdKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICBjYWxsYmFjayhhcmdzWzBdLCBhcmdzWzFdLCBhcmdzWzJdKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgY2FsbGJhY2suYXBwbHkodW5kZWZpbmVkLCBhcmdzKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcnVuSWZQcmVzZW50KGhhbmRsZSkge1xuICAgICAgICAvLyBGcm9tIHRoZSBzcGVjOiBcIldhaXQgdW50aWwgYW55IGludm9jYXRpb25zIG9mIHRoaXMgYWxnb3JpdGhtIHN0YXJ0ZWQgYmVmb3JlIHRoaXMgb25lIGhhdmUgY29tcGxldGVkLlwiXG4gICAgICAgIC8vIFNvIGlmIHdlJ3JlIGN1cnJlbnRseSBydW5uaW5nIGEgdGFzaywgd2UnbGwgbmVlZCB0byBkZWxheSB0aGlzIGludm9jYXRpb24uXG4gICAgICAgIGlmIChjdXJyZW50bHlSdW5uaW5nQVRhc2spIHtcbiAgICAgICAgICAgIC8vIERlbGF5IGJ5IGRvaW5nIGEgc2V0VGltZW91dC4gc2V0SW1tZWRpYXRlIHdhcyB0cmllZCBpbnN0ZWFkLCBidXQgaW4gRmlyZWZveCA3IGl0IGdlbmVyYXRlZCBhXG4gICAgICAgICAgICAvLyBcInRvbyBtdWNoIHJlY3Vyc2lvblwiIGVycm9yLlxuICAgICAgICAgICAgc2V0VGltZW91dChydW5JZlByZXNlbnQsIDAsIGhhbmRsZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB2YXIgdGFzayA9IHRhc2tzQnlIYW5kbGVbaGFuZGxlXTtcbiAgICAgICAgICAgIGlmICh0YXNrKSB7XG4gICAgICAgICAgICAgICAgY3VycmVudGx5UnVubmluZ0FUYXNrID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBydW4odGFzayk7XG4gICAgICAgICAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgICAgICAgICAgY2xlYXJJbW1lZGlhdGUoaGFuZGxlKTtcbiAgICAgICAgICAgICAgICAgICAgY3VycmVudGx5UnVubmluZ0FUYXNrID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaW5zdGFsbE5leHRUaWNrSW1wbGVtZW50YXRpb24oKSB7XG4gICAgICAgIHJlZ2lzdGVySW1tZWRpYXRlID0gZnVuY3Rpb24oaGFuZGxlKSB7XG4gICAgICAgICAgICBwcm9jZXNzLm5leHRUaWNrKGZ1bmN0aW9uICgpIHsgcnVuSWZQcmVzZW50KGhhbmRsZSk7IH0pO1xuICAgICAgICB9O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNhblVzZVBvc3RNZXNzYWdlKCkge1xuICAgICAgICAvLyBUaGUgdGVzdCBhZ2FpbnN0IGBpbXBvcnRTY3JpcHRzYCBwcmV2ZW50cyB0aGlzIGltcGxlbWVudGF0aW9uIGZyb20gYmVpbmcgaW5zdGFsbGVkIGluc2lkZSBhIHdlYiB3b3JrZXIsXG4gICAgICAgIC8vIHdoZXJlIGBnbG9iYWwucG9zdE1lc3NhZ2VgIG1lYW5zIHNvbWV0aGluZyBjb21wbGV0ZWx5IGRpZmZlcmVudCBhbmQgY2FuJ3QgYmUgdXNlZCBmb3IgdGhpcyBwdXJwb3NlLlxuICAgICAgICBpZiAoZ2xvYmFsLnBvc3RNZXNzYWdlICYmICFnbG9iYWwuaW1wb3J0U2NyaXB0cykge1xuICAgICAgICAgICAgdmFyIHBvc3RNZXNzYWdlSXNBc3luY2hyb25vdXMgPSB0cnVlO1xuICAgICAgICAgICAgdmFyIG9sZE9uTWVzc2FnZSA9IGdsb2JhbC5vbm1lc3NhZ2U7XG4gICAgICAgICAgICBnbG9iYWwub25tZXNzYWdlID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgcG9zdE1lc3NhZ2VJc0FzeW5jaHJvbm91cyA9IGZhbHNlO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGdsb2JhbC5wb3N0TWVzc2FnZShcIlwiLCBcIipcIik7XG4gICAgICAgICAgICBnbG9iYWwub25tZXNzYWdlID0gb2xkT25NZXNzYWdlO1xuICAgICAgICAgICAgcmV0dXJuIHBvc3RNZXNzYWdlSXNBc3luY2hyb25vdXM7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpbnN0YWxsUG9zdE1lc3NhZ2VJbXBsZW1lbnRhdGlvbigpIHtcbiAgICAgICAgLy8gSW5zdGFsbHMgYW4gZXZlbnQgaGFuZGxlciBvbiBgZ2xvYmFsYCBmb3IgdGhlIGBtZXNzYWdlYCBldmVudDogc2VlXG4gICAgICAgIC8vICogaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4vRE9NL3dpbmRvdy5wb3N0TWVzc2FnZVxuICAgICAgICAvLyAqIGh0dHA6Ly93d3cud2hhdHdnLm9yZy9zcGVjcy93ZWItYXBwcy9jdXJyZW50LXdvcmsvbXVsdGlwYWdlL2NvbW1zLmh0bWwjY3Jvc3NEb2N1bWVudE1lc3NhZ2VzXG5cbiAgICAgICAgdmFyIG1lc3NhZ2VQcmVmaXggPSBcInNldEltbWVkaWF0ZSRcIiArIE1hdGgucmFuZG9tKCkgKyBcIiRcIjtcbiAgICAgICAgdmFyIG9uR2xvYmFsTWVzc2FnZSA9IGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgICAgICAgICBpZiAoZXZlbnQuc291cmNlID09PSBnbG9iYWwgJiZcbiAgICAgICAgICAgICAgICB0eXBlb2YgZXZlbnQuZGF0YSA9PT0gXCJzdHJpbmdcIiAmJlxuICAgICAgICAgICAgICAgIGV2ZW50LmRhdGEuaW5kZXhPZihtZXNzYWdlUHJlZml4KSA9PT0gMCkge1xuICAgICAgICAgICAgICAgIHJ1bklmUHJlc2VudCgrZXZlbnQuZGF0YS5zbGljZShtZXNzYWdlUHJlZml4Lmxlbmd0aCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuXG4gICAgICAgIGlmIChnbG9iYWwuYWRkRXZlbnRMaXN0ZW5lcikge1xuICAgICAgICAgICAgZ2xvYmFsLmFkZEV2ZW50TGlzdGVuZXIoXCJtZXNzYWdlXCIsIG9uR2xvYmFsTWVzc2FnZSwgZmFsc2UpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZ2xvYmFsLmF0dGFjaEV2ZW50KFwib25tZXNzYWdlXCIsIG9uR2xvYmFsTWVzc2FnZSk7XG4gICAgICAgIH1cblxuICAgICAgICByZWdpc3RlckltbWVkaWF0ZSA9IGZ1bmN0aW9uKGhhbmRsZSkge1xuICAgICAgICAgICAgZ2xvYmFsLnBvc3RNZXNzYWdlKG1lc3NhZ2VQcmVmaXggKyBoYW5kbGUsIFwiKlwiKTtcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpbnN0YWxsTWVzc2FnZUNoYW5uZWxJbXBsZW1lbnRhdGlvbigpIHtcbiAgICAgICAgdmFyIGNoYW5uZWwgPSBuZXcgTWVzc2FnZUNoYW5uZWwoKTtcbiAgICAgICAgY2hhbm5lbC5wb3J0MS5vbm1lc3NhZ2UgPSBmdW5jdGlvbihldmVudCkge1xuICAgICAgICAgICAgdmFyIGhhbmRsZSA9IGV2ZW50LmRhdGE7XG4gICAgICAgICAgICBydW5JZlByZXNlbnQoaGFuZGxlKTtcbiAgICAgICAgfTtcblxuICAgICAgICByZWdpc3RlckltbWVkaWF0ZSA9IGZ1bmN0aW9uKGhhbmRsZSkge1xuICAgICAgICAgICAgY2hhbm5lbC5wb3J0Mi5wb3N0TWVzc2FnZShoYW5kbGUpO1xuICAgICAgICB9O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGluc3RhbGxSZWFkeVN0YXRlQ2hhbmdlSW1wbGVtZW50YXRpb24oKSB7XG4gICAgICAgIHZhciBodG1sID0gZG9jLmRvY3VtZW50RWxlbWVudDtcbiAgICAgICAgcmVnaXN0ZXJJbW1lZGlhdGUgPSBmdW5jdGlvbihoYW5kbGUpIHtcbiAgICAgICAgICAgIC8vIENyZWF0ZSBhIDxzY3JpcHQ+IGVsZW1lbnQ7IGl0cyByZWFkeXN0YXRlY2hhbmdlIGV2ZW50IHdpbGwgYmUgZmlyZWQgYXN5bmNocm9ub3VzbHkgb25jZSBpdCBpcyBpbnNlcnRlZFxuICAgICAgICAgICAgLy8gaW50byB0aGUgZG9jdW1lbnQuIERvIHNvLCB0aHVzIHF1ZXVpbmcgdXAgdGhlIHRhc2suIFJlbWVtYmVyIHRvIGNsZWFuIHVwIG9uY2UgaXQncyBiZWVuIGNhbGxlZC5cbiAgICAgICAgICAgIHZhciBzY3JpcHQgPSBkb2MuY3JlYXRlRWxlbWVudChcInNjcmlwdFwiKTtcbiAgICAgICAgICAgIHNjcmlwdC5vbnJlYWR5c3RhdGVjaGFuZ2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcnVuSWZQcmVzZW50KGhhbmRsZSk7XG4gICAgICAgICAgICAgICAgc2NyaXB0Lm9ucmVhZHlzdGF0ZWNoYW5nZSA9IG51bGw7XG4gICAgICAgICAgICAgICAgaHRtbC5yZW1vdmVDaGlsZChzY3JpcHQpO1xuICAgICAgICAgICAgICAgIHNjcmlwdCA9IG51bGw7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgaHRtbC5hcHBlbmRDaGlsZChzY3JpcHQpO1xuICAgICAgICB9O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGluc3RhbGxTZXRUaW1lb3V0SW1wbGVtZW50YXRpb24oKSB7XG4gICAgICAgIHJlZ2lzdGVySW1tZWRpYXRlID0gZnVuY3Rpb24oaGFuZGxlKSB7XG4gICAgICAgICAgICBzZXRUaW1lb3V0KHJ1bklmUHJlc2VudCwgMCwgaGFuZGxlKTtcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICAvLyBJZiBzdXBwb3J0ZWQsIHdlIHNob3VsZCBhdHRhY2ggdG8gdGhlIHByb3RvdHlwZSBvZiBnbG9iYWwsIHNpbmNlIHRoYXQgaXMgd2hlcmUgc2V0VGltZW91dCBldCBhbC4gbGl2ZS5cbiAgICB2YXIgYXR0YWNoVG8gPSBPYmplY3QuZ2V0UHJvdG90eXBlT2YgJiYgT2JqZWN0LmdldFByb3RvdHlwZU9mKGdsb2JhbCk7XG4gICAgYXR0YWNoVG8gPSBhdHRhY2hUbyAmJiBhdHRhY2hUby5zZXRUaW1lb3V0ID8gYXR0YWNoVG8gOiBnbG9iYWw7XG5cbiAgICAvLyBEb24ndCBnZXQgZm9vbGVkIGJ5IGUuZy4gYnJvd3NlcmlmeSBlbnZpcm9ubWVudHMuXG4gICAgaWYgKHt9LnRvU3RyaW5nLmNhbGwoZ2xvYmFsLnByb2Nlc3MpID09PSBcIltvYmplY3QgcHJvY2Vzc11cIikge1xuICAgICAgICAvLyBGb3IgTm9kZS5qcyBiZWZvcmUgMC45XG4gICAgICAgIGluc3RhbGxOZXh0VGlja0ltcGxlbWVudGF0aW9uKCk7XG5cbiAgICB9IGVsc2UgaWYgKGNhblVzZVBvc3RNZXNzYWdlKCkpIHtcbiAgICAgICAgLy8gRm9yIG5vbi1JRTEwIG1vZGVybiBicm93c2Vyc1xuICAgICAgICBpbnN0YWxsUG9zdE1lc3NhZ2VJbXBsZW1lbnRhdGlvbigpO1xuXG4gICAgfSBlbHNlIGlmIChnbG9iYWwuTWVzc2FnZUNoYW5uZWwpIHtcbiAgICAgICAgLy8gRm9yIHdlYiB3b3JrZXJzLCB3aGVyZSBzdXBwb3J0ZWRcbiAgICAgICAgaW5zdGFsbE1lc3NhZ2VDaGFubmVsSW1wbGVtZW50YXRpb24oKTtcblxuICAgIH0gZWxzZSBpZiAoZG9jICYmIFwib25yZWFkeXN0YXRlY2hhbmdlXCIgaW4gZG9jLmNyZWF0ZUVsZW1lbnQoXCJzY3JpcHRcIikpIHtcbiAgICAgICAgLy8gRm9yIElFIDbigJM4XG4gICAgICAgIGluc3RhbGxSZWFkeVN0YXRlQ2hhbmdlSW1wbGVtZW50YXRpb24oKTtcblxuICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIEZvciBvbGRlciBicm93c2Vyc1xuICAgICAgICBpbnN0YWxsU2V0VGltZW91dEltcGxlbWVudGF0aW9uKCk7XG4gICAgfVxuXG4gICAgYXR0YWNoVG8uc2V0SW1tZWRpYXRlID0gc2V0SW1tZWRpYXRlO1xuICAgIGF0dGFjaFRvLmNsZWFySW1tZWRpYXRlID0gY2xlYXJJbW1lZGlhdGU7XG59KHR5cGVvZiBzZWxmID09PSBcInVuZGVmaW5lZFwiID8gdHlwZW9mIGdsb2JhbCA9PT0gXCJ1bmRlZmluZWRcIiA/IHRoaXMgOiBnbG9iYWwgOiBzZWxmKSk7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9zZXRpbW1lZGlhdGUvc2V0SW1tZWRpYXRlLmpzXG4vLyBtb2R1bGUgaWQgPSAxMTVcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///115\n");

/***/ })
/******/ ]);
});